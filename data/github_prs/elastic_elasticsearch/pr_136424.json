{
  "id": 136424,
  "repository": "elastic/elasticsearch",
  "title": "Refactor ThrottleAllocationDecider#canAllocate",
  "body": "I was looking around in here for ES-12942, and thought this should be better.",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-24T19:38:01+00:00",
  "created_at": "2025-10-10T17:33:41+00:00",
  "updated_at": "2025-10-24T19:38:01+00:00",
  "author": "DiannaHohensee",
  "reviewers": [
    "nicktindall",
    "DiannaHohensee"
  ],
  "base_sha": "bd94fd85d23e36f0b8a4db031e303182a14bcf3a",
  "head_sha": "2f54d9621cbc60dfda7beef6da8c6d8085d7aef4",
  "review_comments": [
    {
      "user": "DiannaHohensee",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-10T22:19:37+00:00"
    },
    {
      "user": "nicktindall",
      "state": "APPROVED",
      "body": "LGTM",
      "submitted_at": "2025-10-20T21:54:28+00:00"
    }
  ],
  "pr_comments": [
    {
      "user": "elasticsearchmachine",
      "body": "Pinging @elastic/es-distributed-coordination (Team:Distributed Coordination)",
      "created_at": "2025-10-10T22:20:55+00:00"
    }
  ],
  "files_changed": [
    {
      "filename": "server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "patch": "@@ -118,10 +118,14 @@ private void setPrimariesInitialRecoveries(int primariesInitialRecoveries) {\n     @Override\n     public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n         if (shardRouting.primary() && shardRouting.unassigned()) {\n+            // Primary is unassigned, means we are going to do recovery from store, snapshot or local shards\n             assert initializingShard(shardRouting, node.nodeId()).recoverySource().getType() != RecoverySource.Type.PEER;\n-            // primary is unassigned, means we are going to do recovery from store, snapshot or local shards\n-            // count *just the primaries* currently doing recovery on the node and check against primariesInitialRecoveries\n \n+            if (allocation.isSimulating()) {\n+                return allocation.decision(Decision.YES, NAME, \"primary allocation is not throttled when simulating\");\n+            }\n+\n+            // Count the primaries currently doing recovery on the node, to ensure the primariesInitialRecoveries setting is obeyed.\n             int primariesInRecovery = 0;\n             for (ShardRouting shard : node.initializing()) {\n                 // when a primary shard is INITIALIZING, it can be because of *initial recovery* or *relocation from another node*\n@@ -130,10 +134,7 @@ public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, Routing\n                     primariesInRecovery++;\n                 }\n             }\n-            if (allocation.isSimulating()) {\n-                return allocation.decision(Decision.YES, NAME, \"primary allocation is not throttled when simulating\");\n-            } else if (primariesInRecovery >= primariesInitialRecoveries) {\n-                // TODO: Should index creation not be throttled for primary shards?\n+            if (primariesInRecovery >= primariesInitialRecoveries) {\n                 return allocation.decision(\n                     THROTTLE,\n                     NAME,\n@@ -142,9 +143,8 @@ public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, Routing\n                     CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES_SETTING.getKey(),\n                     primariesInitialRecoveries\n                 );\n-            } else {\n-                return allocation.decision(YES, NAME, \"below primary recovery limit of [%d]\", primariesInitialRecoveries);\n             }\n+            return allocation.decision(YES, NAME, \"below primary recovery limit of [%d]\", primariesInitialRecoveries);\n         } else {\n             // Peer recovery\n             assert initializingShard(shardRouting, node.nodeId()).recoverySource().getType() == RecoverySource.Type.PEER;"
    }
  ],
  "diff": "diff --git a/server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java\nindex f22c139f3b009..b66d9e890e0ba 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/ThrottlingAllocationDecider.java\n@@ -118,10 +118,14 @@ private void setPrimariesInitialRecoveries(int primariesInitialRecoveries) {\n     @Override\n     public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n         if (shardRouting.primary() && shardRouting.unassigned()) {\n+            // Primary is unassigned, means we are going to do recovery from store, snapshot or local shards\n             assert initializingShard(shardRouting, node.nodeId()).recoverySource().getType() != RecoverySource.Type.PEER;\n-            // primary is unassigned, means we are going to do recovery from store, snapshot or local shards\n-            // count *just the primaries* currently doing recovery on the node and check against primariesInitialRecoveries\n \n+            if (allocation.isSimulating()) {\n+                return allocation.decision(Decision.YES, NAME, \"primary allocation is not throttled when simulating\");\n+            }\n+\n+            // Count the primaries currently doing recovery on the node, to ensure the primariesInitialRecoveries setting is obeyed.\n             int primariesInRecovery = 0;\n             for (ShardRouting shard : node.initializing()) {\n                 // when a primary shard is INITIALIZING, it can be because of *initial recovery* or *relocation from another node*\n@@ -130,10 +134,7 @@ public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, Routing\n                     primariesInRecovery++;\n                 }\n             }\n-            if (allocation.isSimulating()) {\n-                return allocation.decision(Decision.YES, NAME, \"primary allocation is not throttled when simulating\");\n-            } else if (primariesInRecovery >= primariesInitialRecoveries) {\n-                // TODO: Should index creation not be throttled for primary shards?\n+            if (primariesInRecovery >= primariesInitialRecoveries) {\n                 return allocation.decision(\n                     THROTTLE,\n                     NAME,\n@@ -142,9 +143,8 @@ public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, Routing\n                     CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES_SETTING.getKey(),\n                     primariesInitialRecoveries\n                 );\n-            } else {\n-                return allocation.decision(YES, NAME, \"below primary recovery limit of [%d]\", primariesInitialRecoveries);\n             }\n+            return allocation.decision(YES, NAME, \"below primary recovery limit of [%d]\", primariesInitialRecoveries);\n         } else {\n             // Peer recovery\n             assert initializingShard(shardRouting, node.nodeId()).recoverySource().getType() == RecoverySource.Type.PEER;\n",
  "additions": 8,
  "deletions": 8,
  "changed_files": 1,
  "url": "https://github.com/elastic/elasticsearch/pull/136424",
  "mined_at": "2025-10-25T13:13:36.230865"
}