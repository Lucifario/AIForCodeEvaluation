{
  "id": 136910,
  "repository": "elastic/elasticsearch",
  "title": "[9.1] Fixed geo point block loader slowness (#136147)",
  "body": "# Backport\n\nThis will backport the following commits from `main` to `9.1`:\n - [Fixed geo point block loader slowness (#136147)](https://github.com/elastic/elasticsearch/pull/136147)\n\n<!--- Backport version: 10.1.0 -->\n\n### Questions ?\nPlease refer to the [Backport tool documentation](https://github.com/sorenlouv/backport)",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-23T18:05:30+00:00",
  "created_at": "2025-10-21T21:00:15+00:00",
  "updated_at": "2025-10-23T18:05:34+00:00",
  "author": "Kubik42",
  "reviewers": [],
  "base_sha": "3d9725f5fe3550fe69a6d5568b6a51b24891ef5a",
  "head_sha": "0e87688e050a678135826beccf4c572e9a12f206",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "docs/changelog/136147.yaml",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "patch": "@@ -0,0 +1,5 @@\n+pr: 136147\n+summary: Fixed geo point block loader slowness\n+area: Mapping\n+type: bug\n+issues: []"
    },
    {
      "filename": "server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java",
      "status": "modified",
      "additions": 107,
      "deletions": 13,
      "changes": 120,
      "patch": "@@ -18,6 +18,7 @@\n import org.apache.lucene.geo.LatLonGeometry;\n import org.apache.lucene.index.DocValuesType;\n import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedNumericDocValues;\n import org.apache.lucene.search.IndexOrDocValuesQuery;\n import org.apache.lucene.search.Query;\n import org.apache.lucene.util.BytesRef;\n@@ -34,6 +35,7 @@\n import org.elasticsearch.core.CheckedConsumer;\n import org.elasticsearch.core.CheckedFunction;\n import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.utils.WellKnownBinary;\n import org.elasticsearch.index.IndexMode;\n import org.elasticsearch.index.IndexVersion;\n import org.elasticsearch.index.fielddata.FieldDataContext;\n@@ -62,6 +64,7 @@\n \n import java.io.IOException;\n import java.io.UncheckedIOException;\n+import java.nio.ByteOrder;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n@@ -70,6 +73,7 @@\n import java.util.function.Function;\n \n import static org.elasticsearch.index.mapper.MappedFieldType.FieldExtractPreference.DOC_VALUES;\n+import static org.elasticsearch.index.mapper.MappedFieldType.FieldExtractPreference.NONE;\n \n /**\n  * Field Mapper for geo_point types.\n@@ -387,7 +391,7 @@ public static class GeoPointFieldType extends AbstractPointFieldType<GeoPoint> i\n         private final IndexMode indexMode;\n         private final boolean isSyntheticSource;\n \n-        private GeoPointFieldType(\n+        GeoPointFieldType(\n             String name,\n             boolean indexed,\n             boolean stored,\n@@ -545,28 +549,118 @@ public TimeSeriesParams.MetricType getMetricType() {\n \n         @Override\n         public BlockLoader blockLoader(BlockLoaderContext blContext) {\n-            if (blContext.fieldExtractPreference() == DOC_VALUES && hasDocValues()) {\n-                return new BlockDocValuesReader.LongsBlockLoader(name());\n+            // load from doc values\n+            if (hasDocValues()) {\n+                if (blContext.fieldExtractPreference() == DOC_VALUES) {\n+                    return new BlockDocValuesReader.LongsBlockLoader(name());\n+                } else if (blContext.fieldExtractPreference() == NONE && isSyntheticSource) {\n+                    // when the preference is not explicitly set to DOC_VALUES, we expect a BytesRef -> see PlannerUtils.toElementType()\n+                    return new BytesRefFromLongsBlockLoader(name());\n+                }\n+                // if we got here, then either synthetic source is not enabled or the preference prohibits us from using doc_values\n             }\n \n-            // There are two scenarios possible once we arrive here:\n-            //\n-            // * Stored source - we'll just use blockLoaderFromSource\n-            // * Synthetic source. However, because of the fieldExtractPreference() check above it is still possible that doc_values are\n-            // present here.\n-            // So we have two subcases:\n-            // - doc_values are enabled - _ignored_source field does not exist since we have doc_values. We will use\n-            // blockLoaderFromSource which reads \"native\" synthetic source.\n-            // - doc_values are disabled - we know that _ignored_source field is present and use a special block loader unless it's a multi\n-            // field.\n+            // doc_values are disabled, fallback to ignored_source, except for multi fields since then don't have fallback synthetic source\n             if (isSyntheticSource && hasDocValues() == false && blContext.parentField(name()) == null) {\n                 return blockLoaderFromFallbackSyntheticSource(blContext);\n             }\n \n+            // otherwise, load from _source (synthetic or otherwise) - very slow\n             return blockLoaderFromSource(blContext);\n         }\n     }\n \n+    /**\n+     * This is a GeoPoint-specific block loader that helps deal with an edge case where doc_values are available, yet\n+     * FieldExtractPreference = NONE. When this happens, the BlockLoader sanity checker (see PlannerUtils.toElementType) expects a BytesRef.\n+     * This implies that we need to load the value from _source. This however is very slow, especially when synthetic source is enabled.\n+     * We're better off reading from doc_values and converting to BytesRef to satisfy the checker. This is what this block loader is for.\n+     */\n+    static final class BytesRefFromLongsBlockLoader extends BlockDocValuesReader.DocValuesBlockLoader {\n+\n+        private final String fieldName;\n+\n+        BytesRefFromLongsBlockLoader(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public Builder builder(BlockFactory factory, int expectedCount) {\n+            return factory.bytesRefs(expectedCount);\n+        }\n+\n+        @Override\n+        public AllReader reader(LeafReaderContext context) throws IOException {\n+            SortedNumericDocValues docValues = context.reader().getSortedNumericDocValues(fieldName);\n+            if (docValues != null) {\n+                return new BytesRefsFromLong(docValues, (geoPointLong) -> {\n+                    GeoPoint gp = new GeoPoint().resetFromEncoded(geoPointLong);\n+                    byte[] wkb = WellKnownBinary.toWKB(new Point(gp.getX(), gp.getY()), ByteOrder.LITTLE_ENDIAN);\n+                    return new BytesRef(wkb);\n+                });\n+            }\n+            return new ConstantNullsReader();\n+        }\n+    }\n+\n+    private static final class BytesRefsFromLong extends BlockDocValuesReader {\n+\n+        private final SortedNumericDocValues numericDocValues;\n+        private final Function<Long, BytesRef> longsToBytesRef;\n+\n+        BytesRefsFromLong(SortedNumericDocValues numericDocValues, Function<Long, BytesRef> longsToBytesRef) {\n+            this.numericDocValues = numericDocValues;\n+            this.longsToBytesRef = longsToBytesRef;\n+        }\n+\n+        @Override\n+        protected int docId() {\n+            return numericDocValues.docID();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"BlockDocValuesReader.BytesRefsFromLong\";\n+        }\n+\n+        @Override\n+        public BlockLoader.Block read(BlockLoader.BlockFactory factory, BlockLoader.Docs docs, int offset) throws IOException {\n+\n+            try (BlockLoader.BytesRefBuilder builder = factory.bytesRefs(docs.count() - offset)) {\n+                for (int i = offset; i < docs.count(); i++) {\n+                    int doc = docs.get(i);\n+                    read(doc, builder);\n+                }\n+                return builder.build();\n+            }\n+        }\n+\n+        @Override\n+        public void read(int docId, BlockLoader.StoredFields storedFields, BlockLoader.Builder builder) throws IOException {\n+            read(docId, (BlockLoader.BytesRefBuilder) builder);\n+        }\n+\n+        private void read(int doc, BlockLoader.BytesRefBuilder builder) throws IOException {\n+            // no more values remaining\n+            if (numericDocValues.advanceExact(doc) == false) {\n+                builder.appendNull();\n+                return;\n+            }\n+            int count = numericDocValues.docValueCount();\n+            if (count == 1) {\n+                BytesRef bytesRefValue = longsToBytesRef.apply(numericDocValues.nextValue());\n+                builder.appendBytesRef(bytesRefValue);\n+                return;\n+            }\n+            builder.beginPositionEntry();\n+            for (int v = 0; v < count; v++) {\n+                BytesRef bytesRefValue = longsToBytesRef.apply(numericDocValues.nextValue());\n+                builder.appendBytesRef(bytesRefValue);\n+            }\n+            builder.endPositionEntry();\n+        }\n+    }\n+\n     /** GeoPoint parser implementation */\n     private static class GeoPointParser extends PointParser<GeoPoint> {\n         private final boolean storeMalformedDataForSyntheticSource;"
    },
    {
      "filename": "server/src/test/java/org/elasticsearch/index/mapper/GeoPointFieldTypeTests.java",
      "status": "modified",
      "additions": 147,
      "deletions": 0,
      "changes": 147,
      "patch": "@@ -10,20 +10,28 @@\n package org.elasticsearch.index.mapper;\n \n import org.apache.lucene.tests.geo.GeoTestUtil;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n import org.elasticsearch.common.geo.GeoPoint;\n import org.elasticsearch.common.geo.SimpleFeatureFactory;\n+import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.geometry.Point;\n import org.elasticsearch.geometry.utils.WellKnownBinary;\n+import org.elasticsearch.index.IndexMode;\n+import org.elasticsearch.index.IndexSettings;\n import org.elasticsearch.index.IndexVersion;\n import org.elasticsearch.script.ScriptCompiler;\n \n import java.io.IOException;\n import java.nio.ByteOrder;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n \n public class GeoPointFieldTypeTests extends FieldTypeTestCase {\n \n@@ -147,4 +155,143 @@ public void testFetchVectorTile() throws IOException {\n         assertThat(sourceValue.size(), equalTo(1));\n         assertThat(sourceValue.get(0), equalTo(featureFactory.points(geoPoints)));\n     }\n+\n+    public void testBlockLoaderWhenDocValuesAreEnabledAndThePreferenceIsToUseDocValues() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = new GeoPointFieldMapper.GeoPointFieldType(\"potato\");\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(false, MappedFieldType.FieldExtractPreference.DOC_VALUES);\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(BlockDocValuesReader.LongsBlockLoader.class));\n+    }\n+\n+    public void testBlockLoaderWhenDocValuesAreEnabledAndThereIsNoPreference() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = new GeoPointFieldMapper.GeoPointFieldType(\"potato\");\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(false, MappedFieldType.FieldExtractPreference.NONE);\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(BlockSourceReader.GeometriesBlockLoader.class));\n+    }\n+\n+    public void testBlockLoaderWhenFieldIsStoredAndThePreferenceIsToUseStoredFields() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = createFieldType(true, false, false);\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(false, MappedFieldType.FieldExtractPreference.STORED);\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(BlockSourceReader.GeometriesBlockLoader.class));\n+    }\n+\n+    public void testBlockLoaderWhenFieldIsStoredAndThereIsNoPreference() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = createFieldType(true, false, false);\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(false, MappedFieldType.FieldExtractPreference.NONE);\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(BlockSourceReader.GeometriesBlockLoader.class));\n+    }\n+\n+    public void testBlockLoaderWhenSyntheticSourceIsEnabledAndFieldIsStoredInIgnoredSource() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = createFieldType(false, false, true);\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(true, MappedFieldType.FieldExtractPreference.NONE);\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(FallbackSyntheticSourceBlockLoader.class));\n+    }\n+\n+    public void testBlockLoaderWhenSyntheticSourceAndDocValuesAreEnabled() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = createFieldType(false, true, true);\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(true, MappedFieldType.FieldExtractPreference.NONE);\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(GeoPointFieldMapper.BytesRefFromLongsBlockLoader.class));\n+    }\n+\n+    public void testBlockLoaderFallsBackToSource() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = new GeoPointFieldMapper.GeoPointFieldType(\"potato\");\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(\n+            false,\n+            MappedFieldType.FieldExtractPreference.EXTRACT_SPATIAL_BOUNDS\n+        );\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(BlockSourceReader.GeometriesBlockLoader.class));\n+    }\n+\n+    private MappedFieldType.BlockLoaderContext mockBlockLoaderContext(\n+        boolean enableSyntheticSource,\n+        MappedFieldType.FieldExtractPreference fieldExtractPreference\n+    ) {\n+        Settings.Builder builder = Settings.builder()\n+            .put(IndexMetadata.SETTING_VERSION_CREATED, IndexVersion.current())\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1);\n+\n+        if (enableSyntheticSource) {\n+            builder.put(\"index.mapping.source.mode\", \"synthetic\");\n+        }\n+\n+        Settings settings = builder.build();\n+\n+        IndexSettings indexSettings = new IndexSettings(IndexMetadata.builder(\"index\").settings(builder).build(), settings);\n+\n+        MappedFieldType.BlockLoaderContext blContextMock = mock(MappedFieldType.BlockLoaderContext.class);\n+        doReturn(fieldExtractPreference).when(blContextMock).fieldExtractPreference();\n+        doReturn(indexSettings).when(blContextMock).indexSettings();\n+\n+        return blContextMock;\n+    }\n+\n+    private GeoPointFieldMapper.GeoPointFieldType createFieldType(\n+        boolean isStored,\n+        boolean hasDocValues,\n+        boolean isSyntheticSourceEnabled\n+    ) {\n+        return new GeoPointFieldMapper.GeoPointFieldType(\n+            \"potato\",\n+            true,\n+            isStored,\n+            hasDocValues,\n+            null,\n+            null,\n+            null,\n+            Collections.emptyMap(),\n+            TimeSeriesParams.MetricType.COUNTER,\n+            IndexMode.LOGSDB,\n+            isSyntheticSourceEnabled\n+        );\n+    }\n+\n }"
    },
    {
      "filename": "server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java",
      "status": "modified",
      "additions": 54,
      "deletions": 24,
      "changes": 78,
      "patch": "@@ -36,19 +36,15 @@ protected Object expected(Map<String, Object> fieldMapping, Object values, TestC\n             default -> throw new IllegalStateException(\"Unexpected null_value format\");\n         };\n \n-        if (params.preference() == MappedFieldType.FieldExtractPreference.DOC_VALUES && hasDocValues(fieldMapping, true)) {\n-            if (values instanceof List<?> == false) {\n-                var point = convert(values, nullValue, testContext.isMultifield());\n-                return point != null ? point.getEncoded() : null;\n+        // read from doc_values\n+        boolean preferToLoadFromDocValues = params.preference() == MappedFieldType.FieldExtractPreference.DOC_VALUES;\n+        boolean noPreference = params.preference() == MappedFieldType.FieldExtractPreference.NONE;\n+        if (hasDocValues(fieldMapping, true)) {\n+            if (preferToLoadFromDocValues) {\n+                return longValues(values, nullValue, testContext.isMultifield());\n+            } else if (noPreference && params.syntheticSource()) {\n+                return bytesRefWkbValues(values, nullValue, testContext.isMultifield());\n             }\n-\n-            var resultList = ((List<Object>) values).stream()\n-                .map(v -> convert(v, nullValue, testContext.isMultifield()))\n-                .filter(Objects::nonNull)\n-                .map(GeoPoint::getEncoded)\n-                .sorted()\n-                .toList();\n-            return maybeFoldList(resultList);\n         }\n \n         // stored source is used\n@@ -74,23 +70,50 @@ protected Object expected(Map<String, Object> fieldMapping, Object values, TestC\n \n         // synthetic source and doc_values are present\n         if (hasDocValues(fieldMapping, true)) {\n-            if (values instanceof List<?> == false) {\n-                return toWKB(normalize(convert(values, nullValue, false)));\n-            }\n-\n-            var resultList = ((List<Object>) values).stream()\n-                .map(v -> convert(v, nullValue, false))\n-                .filter(Objects::nonNull)\n-                .sorted(Comparator.comparingLong(GeoPoint::getEncoded))\n-                .map(p -> toWKB(normalize(p)))\n-                .toList();\n-            return maybeFoldList(resultList);\n+            return bytesRefWkbValues(values, nullValue, false);\n         }\n \n-        // synthetic source but no doc_values so using fallback synthetic source\n+        // synthetic source is enabled, but no doc_values are present, so fallback to ignored source\n         return exactValuesFromSource(values, nullValue, false);\n     }\n \n+    /**\n+     * Use when values are stored as points encoded as longs.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Object longValues(Object values, GeoPoint nullValue, boolean needsMultifieldAdjustment) {\n+        if (values instanceof List<?> == false) {\n+            var point = convert(values, nullValue, needsMultifieldAdjustment);\n+            return point != null ? point.getEncoded() : null;\n+        }\n+\n+        var resultList = ((List<Object>) values).stream()\n+            .map(v -> convert(v, nullValue, needsMultifieldAdjustment))\n+            .filter(Objects::nonNull)\n+            .map(GeoPoint::getEncoded)\n+            .sorted()\n+            .toList();\n+        return maybeFoldList(resultList);\n+    }\n+\n+    /**\n+     * Use when values are stored as WKB encoded points.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Object bytesRefWkbValues(Object values, GeoPoint nullValue, boolean needsMultifieldAdjustment) {\n+        if (values instanceof List<?> == false) {\n+            return toWKB(normalize(convert(values, nullValue, needsMultifieldAdjustment)));\n+        }\n+\n+        var resultList = ((List<Object>) values).stream()\n+            .map(v -> convert(v, nullValue, needsMultifieldAdjustment))\n+            .filter(Objects::nonNull)\n+            .sorted(Comparator.comparingLong(GeoPoint::getEncoded))\n+            .map(p -> toWKB(normalize(p)))\n+            .toList();\n+        return maybeFoldList(resultList);\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     private Object exactValuesFromSource(Object value, GeoPoint nullValue, boolean needsMultifieldAdjustment) {\n         if (value instanceof List<?> == false) {\n@@ -150,6 +173,12 @@ private GeoPoint possiblyAdjustMultifieldValue(GeoPoint point, boolean isMultifi\n         return point;\n     }\n \n+    /**\n+     * Normalizes the given point by forcing it to be encoded and then decoded, similarly to how actual block loaders work when they read\n+     * values. During encoding/decoding, some precision may be lost, so the lat/lon coordinates may change. Without this, the point returned\n+     * by the block loader will be ever so slightly different from the original point. This will cause the tests to fail. This method\n+     * exists to essentially mimic what happens to the point when it gets stored and then later loaded back.\n+     */\n     private GeoPoint normalize(GeoPoint point) {\n         if (point == null) {\n             return null;\n@@ -164,4 +193,5 @@ private BytesRef toWKB(GeoPoint point) {\n \n         return new BytesRef(WellKnownBinary.toWKB(new Point(point.getX(), point.getY()), ByteOrder.LITTLE_ENDIAN));\n     }\n+\n }"
    }
  ],
  "diff": "diff --git a/docs/changelog/136147.yaml b/docs/changelog/136147.yaml\nnew file mode 100644\nindex 0000000000000..1f9f4dac5a97f\n--- /dev/null\n+++ b/docs/changelog/136147.yaml\n@@ -0,0 +1,5 @@\n+pr: 136147\n+summary: Fixed geo point block loader slowness\n+area: Mapping\n+type: bug\n+issues: []\ndiff --git a/server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java b/server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java\nindex be5c4b82bf1f2..79eef5040b0a0 100644\n--- a/server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/GeoPointFieldMapper.java\n@@ -18,6 +18,7 @@\n import org.apache.lucene.geo.LatLonGeometry;\n import org.apache.lucene.index.DocValuesType;\n import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.SortedNumericDocValues;\n import org.apache.lucene.search.IndexOrDocValuesQuery;\n import org.apache.lucene.search.Query;\n import org.apache.lucene.util.BytesRef;\n@@ -34,6 +35,7 @@\n import org.elasticsearch.core.CheckedConsumer;\n import org.elasticsearch.core.CheckedFunction;\n import org.elasticsearch.geometry.Point;\n+import org.elasticsearch.geometry.utils.WellKnownBinary;\n import org.elasticsearch.index.IndexMode;\n import org.elasticsearch.index.IndexVersion;\n import org.elasticsearch.index.fielddata.FieldDataContext;\n@@ -62,6 +64,7 @@\n \n import java.io.IOException;\n import java.io.UncheckedIOException;\n+import java.nio.ByteOrder;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n@@ -70,6 +73,7 @@\n import java.util.function.Function;\n \n import static org.elasticsearch.index.mapper.MappedFieldType.FieldExtractPreference.DOC_VALUES;\n+import static org.elasticsearch.index.mapper.MappedFieldType.FieldExtractPreference.NONE;\n \n /**\n  * Field Mapper for geo_point types.\n@@ -387,7 +391,7 @@ public static class GeoPointFieldType extends AbstractPointFieldType<GeoPoint> i\n         private final IndexMode indexMode;\n         private final boolean isSyntheticSource;\n \n-        private GeoPointFieldType(\n+        GeoPointFieldType(\n             String name,\n             boolean indexed,\n             boolean stored,\n@@ -545,28 +549,118 @@ public TimeSeriesParams.MetricType getMetricType() {\n \n         @Override\n         public BlockLoader blockLoader(BlockLoaderContext blContext) {\n-            if (blContext.fieldExtractPreference() == DOC_VALUES && hasDocValues()) {\n-                return new BlockDocValuesReader.LongsBlockLoader(name());\n+            // load from doc values\n+            if (hasDocValues()) {\n+                if (blContext.fieldExtractPreference() == DOC_VALUES) {\n+                    return new BlockDocValuesReader.LongsBlockLoader(name());\n+                } else if (blContext.fieldExtractPreference() == NONE && isSyntheticSource) {\n+                    // when the preference is not explicitly set to DOC_VALUES, we expect a BytesRef -> see PlannerUtils.toElementType()\n+                    return new BytesRefFromLongsBlockLoader(name());\n+                }\n+                // if we got here, then either synthetic source is not enabled or the preference prohibits us from using doc_values\n             }\n \n-            // There are two scenarios possible once we arrive here:\n-            //\n-            // * Stored source - we'll just use blockLoaderFromSource\n-            // * Synthetic source. However, because of the fieldExtractPreference() check above it is still possible that doc_values are\n-            // present here.\n-            // So we have two subcases:\n-            // - doc_values are enabled - _ignored_source field does not exist since we have doc_values. We will use\n-            // blockLoaderFromSource which reads \"native\" synthetic source.\n-            // - doc_values are disabled - we know that _ignored_source field is present and use a special block loader unless it's a multi\n-            // field.\n+            // doc_values are disabled, fallback to ignored_source, except for multi fields since then don't have fallback synthetic source\n             if (isSyntheticSource && hasDocValues() == false && blContext.parentField(name()) == null) {\n                 return blockLoaderFromFallbackSyntheticSource(blContext);\n             }\n \n+            // otherwise, load from _source (synthetic or otherwise) - very slow\n             return blockLoaderFromSource(blContext);\n         }\n     }\n \n+    /**\n+     * This is a GeoPoint-specific block loader that helps deal with an edge case where doc_values are available, yet\n+     * FieldExtractPreference = NONE. When this happens, the BlockLoader sanity checker (see PlannerUtils.toElementType) expects a BytesRef.\n+     * This implies that we need to load the value from _source. This however is very slow, especially when synthetic source is enabled.\n+     * We're better off reading from doc_values and converting to BytesRef to satisfy the checker. This is what this block loader is for.\n+     */\n+    static final class BytesRefFromLongsBlockLoader extends BlockDocValuesReader.DocValuesBlockLoader {\n+\n+        private final String fieldName;\n+\n+        BytesRefFromLongsBlockLoader(String fieldName) {\n+            this.fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public Builder builder(BlockFactory factory, int expectedCount) {\n+            return factory.bytesRefs(expectedCount);\n+        }\n+\n+        @Override\n+        public AllReader reader(LeafReaderContext context) throws IOException {\n+            SortedNumericDocValues docValues = context.reader().getSortedNumericDocValues(fieldName);\n+            if (docValues != null) {\n+                return new BytesRefsFromLong(docValues, (geoPointLong) -> {\n+                    GeoPoint gp = new GeoPoint().resetFromEncoded(geoPointLong);\n+                    byte[] wkb = WellKnownBinary.toWKB(new Point(gp.getX(), gp.getY()), ByteOrder.LITTLE_ENDIAN);\n+                    return new BytesRef(wkb);\n+                });\n+            }\n+            return new ConstantNullsReader();\n+        }\n+    }\n+\n+    private static final class BytesRefsFromLong extends BlockDocValuesReader {\n+\n+        private final SortedNumericDocValues numericDocValues;\n+        private final Function<Long, BytesRef> longsToBytesRef;\n+\n+        BytesRefsFromLong(SortedNumericDocValues numericDocValues, Function<Long, BytesRef> longsToBytesRef) {\n+            this.numericDocValues = numericDocValues;\n+            this.longsToBytesRef = longsToBytesRef;\n+        }\n+\n+        @Override\n+        protected int docId() {\n+            return numericDocValues.docID();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"BlockDocValuesReader.BytesRefsFromLong\";\n+        }\n+\n+        @Override\n+        public BlockLoader.Block read(BlockLoader.BlockFactory factory, BlockLoader.Docs docs, int offset) throws IOException {\n+\n+            try (BlockLoader.BytesRefBuilder builder = factory.bytesRefs(docs.count() - offset)) {\n+                for (int i = offset; i < docs.count(); i++) {\n+                    int doc = docs.get(i);\n+                    read(doc, builder);\n+                }\n+                return builder.build();\n+            }\n+        }\n+\n+        @Override\n+        public void read(int docId, BlockLoader.StoredFields storedFields, BlockLoader.Builder builder) throws IOException {\n+            read(docId, (BlockLoader.BytesRefBuilder) builder);\n+        }\n+\n+        private void read(int doc, BlockLoader.BytesRefBuilder builder) throws IOException {\n+            // no more values remaining\n+            if (numericDocValues.advanceExact(doc) == false) {\n+                builder.appendNull();\n+                return;\n+            }\n+            int count = numericDocValues.docValueCount();\n+            if (count == 1) {\n+                BytesRef bytesRefValue = longsToBytesRef.apply(numericDocValues.nextValue());\n+                builder.appendBytesRef(bytesRefValue);\n+                return;\n+            }\n+            builder.beginPositionEntry();\n+            for (int v = 0; v < count; v++) {\n+                BytesRef bytesRefValue = longsToBytesRef.apply(numericDocValues.nextValue());\n+                builder.appendBytesRef(bytesRefValue);\n+            }\n+            builder.endPositionEntry();\n+        }\n+    }\n+\n     /** GeoPoint parser implementation */\n     private static class GeoPointParser extends PointParser<GeoPoint> {\n         private final boolean storeMalformedDataForSyntheticSource;\ndiff --git a/server/src/test/java/org/elasticsearch/index/mapper/GeoPointFieldTypeTests.java b/server/src/test/java/org/elasticsearch/index/mapper/GeoPointFieldTypeTests.java\nindex 93f1b2b977b0f..4b32fe141ba20 100644\n--- a/server/src/test/java/org/elasticsearch/index/mapper/GeoPointFieldTypeTests.java\n+++ b/server/src/test/java/org/elasticsearch/index/mapper/GeoPointFieldTypeTests.java\n@@ -10,20 +10,28 @@\n package org.elasticsearch.index.mapper;\n \n import org.apache.lucene.tests.geo.GeoTestUtil;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n import org.elasticsearch.common.geo.GeoPoint;\n import org.elasticsearch.common.geo.SimpleFeatureFactory;\n+import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.geometry.Point;\n import org.elasticsearch.geometry.utils.WellKnownBinary;\n+import org.elasticsearch.index.IndexMode;\n+import org.elasticsearch.index.IndexSettings;\n import org.elasticsearch.index.IndexVersion;\n import org.elasticsearch.script.ScriptCompiler;\n \n import java.io.IOException;\n import java.nio.ByteOrder;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n \n public class GeoPointFieldTypeTests extends FieldTypeTestCase {\n \n@@ -147,4 +155,143 @@ public void testFetchVectorTile() throws IOException {\n         assertThat(sourceValue.size(), equalTo(1));\n         assertThat(sourceValue.get(0), equalTo(featureFactory.points(geoPoints)));\n     }\n+\n+    public void testBlockLoaderWhenDocValuesAreEnabledAndThePreferenceIsToUseDocValues() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = new GeoPointFieldMapper.GeoPointFieldType(\"potato\");\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(false, MappedFieldType.FieldExtractPreference.DOC_VALUES);\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(BlockDocValuesReader.LongsBlockLoader.class));\n+    }\n+\n+    public void testBlockLoaderWhenDocValuesAreEnabledAndThereIsNoPreference() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = new GeoPointFieldMapper.GeoPointFieldType(\"potato\");\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(false, MappedFieldType.FieldExtractPreference.NONE);\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(BlockSourceReader.GeometriesBlockLoader.class));\n+    }\n+\n+    public void testBlockLoaderWhenFieldIsStoredAndThePreferenceIsToUseStoredFields() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = createFieldType(true, false, false);\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(false, MappedFieldType.FieldExtractPreference.STORED);\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(BlockSourceReader.GeometriesBlockLoader.class));\n+    }\n+\n+    public void testBlockLoaderWhenFieldIsStoredAndThereIsNoPreference() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = createFieldType(true, false, false);\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(false, MappedFieldType.FieldExtractPreference.NONE);\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(BlockSourceReader.GeometriesBlockLoader.class));\n+    }\n+\n+    public void testBlockLoaderWhenSyntheticSourceIsEnabledAndFieldIsStoredInIgnoredSource() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = createFieldType(false, false, true);\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(true, MappedFieldType.FieldExtractPreference.NONE);\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(FallbackSyntheticSourceBlockLoader.class));\n+    }\n+\n+    public void testBlockLoaderWhenSyntheticSourceAndDocValuesAreEnabled() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = createFieldType(false, true, true);\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(true, MappedFieldType.FieldExtractPreference.NONE);\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(GeoPointFieldMapper.BytesRefFromLongsBlockLoader.class));\n+    }\n+\n+    public void testBlockLoaderFallsBackToSource() {\n+        // given\n+        GeoPointFieldMapper.GeoPointFieldType fieldType = new GeoPointFieldMapper.GeoPointFieldType(\"potato\");\n+        MappedFieldType.BlockLoaderContext blContextMock = mockBlockLoaderContext(\n+            false,\n+            MappedFieldType.FieldExtractPreference.EXTRACT_SPATIAL_BOUNDS\n+        );\n+\n+        // when\n+        BlockLoader loader = fieldType.blockLoader(blContextMock);\n+\n+        // then\n+        // verify that we use the correct block value reader\n+        assertThat(loader, instanceOf(BlockSourceReader.GeometriesBlockLoader.class));\n+    }\n+\n+    private MappedFieldType.BlockLoaderContext mockBlockLoaderContext(\n+        boolean enableSyntheticSource,\n+        MappedFieldType.FieldExtractPreference fieldExtractPreference\n+    ) {\n+        Settings.Builder builder = Settings.builder()\n+            .put(IndexMetadata.SETTING_VERSION_CREATED, IndexVersion.current())\n+            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n+            .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 1);\n+\n+        if (enableSyntheticSource) {\n+            builder.put(\"index.mapping.source.mode\", \"synthetic\");\n+        }\n+\n+        Settings settings = builder.build();\n+\n+        IndexSettings indexSettings = new IndexSettings(IndexMetadata.builder(\"index\").settings(builder).build(), settings);\n+\n+        MappedFieldType.BlockLoaderContext blContextMock = mock(MappedFieldType.BlockLoaderContext.class);\n+        doReturn(fieldExtractPreference).when(blContextMock).fieldExtractPreference();\n+        doReturn(indexSettings).when(blContextMock).indexSettings();\n+\n+        return blContextMock;\n+    }\n+\n+    private GeoPointFieldMapper.GeoPointFieldType createFieldType(\n+        boolean isStored,\n+        boolean hasDocValues,\n+        boolean isSyntheticSourceEnabled\n+    ) {\n+        return new GeoPointFieldMapper.GeoPointFieldType(\n+            \"potato\",\n+            true,\n+            isStored,\n+            hasDocValues,\n+            null,\n+            null,\n+            null,\n+            Collections.emptyMap(),\n+            TimeSeriesParams.MetricType.COUNTER,\n+            IndexMode.LOGSDB,\n+            isSyntheticSourceEnabled\n+        );\n+    }\n+\n }\ndiff --git a/server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java b/server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java\nindex fdb1d89175fef..0e55c0d2bb536 100644\n--- a/server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java\n+++ b/server/src/test/java/org/elasticsearch/index/mapper/blockloader/GeoPointFieldBlockLoaderTests.java\n@@ -36,19 +36,15 @@ protected Object expected(Map<String, Object> fieldMapping, Object values, TestC\n             default -> throw new IllegalStateException(\"Unexpected null_value format\");\n         };\n \n-        if (params.preference() == MappedFieldType.FieldExtractPreference.DOC_VALUES && hasDocValues(fieldMapping, true)) {\n-            if (values instanceof List<?> == false) {\n-                var point = convert(values, nullValue, testContext.isMultifield());\n-                return point != null ? point.getEncoded() : null;\n+        // read from doc_values\n+        boolean preferToLoadFromDocValues = params.preference() == MappedFieldType.FieldExtractPreference.DOC_VALUES;\n+        boolean noPreference = params.preference() == MappedFieldType.FieldExtractPreference.NONE;\n+        if (hasDocValues(fieldMapping, true)) {\n+            if (preferToLoadFromDocValues) {\n+                return longValues(values, nullValue, testContext.isMultifield());\n+            } else if (noPreference && params.syntheticSource()) {\n+                return bytesRefWkbValues(values, nullValue, testContext.isMultifield());\n             }\n-\n-            var resultList = ((List<Object>) values).stream()\n-                .map(v -> convert(v, nullValue, testContext.isMultifield()))\n-                .filter(Objects::nonNull)\n-                .map(GeoPoint::getEncoded)\n-                .sorted()\n-                .toList();\n-            return maybeFoldList(resultList);\n         }\n \n         // stored source is used\n@@ -74,23 +70,50 @@ protected Object expected(Map<String, Object> fieldMapping, Object values, TestC\n \n         // synthetic source and doc_values are present\n         if (hasDocValues(fieldMapping, true)) {\n-            if (values instanceof List<?> == false) {\n-                return toWKB(normalize(convert(values, nullValue, false)));\n-            }\n-\n-            var resultList = ((List<Object>) values).stream()\n-                .map(v -> convert(v, nullValue, false))\n-                .filter(Objects::nonNull)\n-                .sorted(Comparator.comparingLong(GeoPoint::getEncoded))\n-                .map(p -> toWKB(normalize(p)))\n-                .toList();\n-            return maybeFoldList(resultList);\n+            return bytesRefWkbValues(values, nullValue, false);\n         }\n \n-        // synthetic source but no doc_values so using fallback synthetic source\n+        // synthetic source is enabled, but no doc_values are present, so fallback to ignored source\n         return exactValuesFromSource(values, nullValue, false);\n     }\n \n+    /**\n+     * Use when values are stored as points encoded as longs.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Object longValues(Object values, GeoPoint nullValue, boolean needsMultifieldAdjustment) {\n+        if (values instanceof List<?> == false) {\n+            var point = convert(values, nullValue, needsMultifieldAdjustment);\n+            return point != null ? point.getEncoded() : null;\n+        }\n+\n+        var resultList = ((List<Object>) values).stream()\n+            .map(v -> convert(v, nullValue, needsMultifieldAdjustment))\n+            .filter(Objects::nonNull)\n+            .map(GeoPoint::getEncoded)\n+            .sorted()\n+            .toList();\n+        return maybeFoldList(resultList);\n+    }\n+\n+    /**\n+     * Use when values are stored as WKB encoded points.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Object bytesRefWkbValues(Object values, GeoPoint nullValue, boolean needsMultifieldAdjustment) {\n+        if (values instanceof List<?> == false) {\n+            return toWKB(normalize(convert(values, nullValue, needsMultifieldAdjustment)));\n+        }\n+\n+        var resultList = ((List<Object>) values).stream()\n+            .map(v -> convert(v, nullValue, needsMultifieldAdjustment))\n+            .filter(Objects::nonNull)\n+            .sorted(Comparator.comparingLong(GeoPoint::getEncoded))\n+            .map(p -> toWKB(normalize(p)))\n+            .toList();\n+        return maybeFoldList(resultList);\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     private Object exactValuesFromSource(Object value, GeoPoint nullValue, boolean needsMultifieldAdjustment) {\n         if (value instanceof List<?> == false) {\n@@ -150,6 +173,12 @@ private GeoPoint possiblyAdjustMultifieldValue(GeoPoint point, boolean isMultifi\n         return point;\n     }\n \n+    /**\n+     * Normalizes the given point by forcing it to be encoded and then decoded, similarly to how actual block loaders work when they read\n+     * values. During encoding/decoding, some precision may be lost, so the lat/lon coordinates may change. Without this, the point returned\n+     * by the block loader will be ever so slightly different from the original point. This will cause the tests to fail. This method\n+     * exists to essentially mimic what happens to the point when it gets stored and then later loaded back.\n+     */\n     private GeoPoint normalize(GeoPoint point) {\n         if (point == null) {\n             return null;\n@@ -164,4 +193,5 @@ private BytesRef toWKB(GeoPoint point) {\n \n         return new BytesRef(WellKnownBinary.toWKB(new Point(point.getX(), point.getY()), ByteOrder.LITTLE_ENDIAN));\n     }\n+\n }\n",
  "additions": 313,
  "deletions": 37,
  "changed_files": 4,
  "url": "https://github.com/elastic/elasticsearch/pull/136910",
  "mined_at": "2025-10-25T13:39:54.749600"
}