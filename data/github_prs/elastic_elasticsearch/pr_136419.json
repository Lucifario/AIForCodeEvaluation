{
  "id": 136419,
  "repository": "elastic/elasticsearch",
  "title": "[ESQL] Support first/last functions.",
  "body": "- Change `AggregatorImplementor` to use `Argument` instead of `AggregationParameter`.\r\n- Compiling esql module resulted in only 2 modified `SpatialExtent*` classes",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-23T13:24:43+00:00",
  "created_at": "2025-10-10T16:17:26+00:00",
  "updated_at": "2025-10-24T03:13:55+00:00",
  "author": "mouhc1ne",
  "reviewers": [
    "mouhc1ne",
    "nik9000",
    "ivancea",
    "craigtaverner"
  ],
  "base_sha": "fc7ae8e31dfd44b9a02f8fb7ff05d4caafca8726",
  "head_sha": "f9e2dcecffd98c747ae36c3e85d461514f6daaca",
  "review_comments": [
    {
      "user": "ivancea",
      "state": "APPROVED",
      "body": "LGTM!",
      "submitted_at": "2025-10-14T10:42:06+00:00"
    },
    {
      "user": "ivancea",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-14T10:44:16+00:00"
    },
    {
      "user": "craigtaverner",
      "state": "CHANGES_REQUESTED",
      "body": "I did a quick review, and it seems to be like something is not quite right. It looks like the vector optimization for spatial points has been disabled.",
      "submitted_at": "2025-10-15T10:47:44+00:00"
    },
    {
      "user": "nik9000",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-21T13:49:51+00:00"
    },
    {
      "user": "mouhc1ne",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-21T14:41:24+00:00"
    },
    {
      "user": "mouhc1ne",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-21T14:41:57+00:00"
    },
    {
      "user": "mouhc1ne",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-21T14:42:17+00:00"
    },
    {
      "user": "mouhc1ne",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-21T14:43:08+00:00"
    },
    {
      "user": "craigtaverner",
      "state": "APPROVED",
      "body": "OK. I see the optimization I was worried about did not even exist.",
      "submitted_at": "2025-10-21T16:06:12+00:00"
    },
    {
      "user": "mouhc1ne",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-21T18:06:19+00:00"
    },
    {
      "user": "mouhc1ne",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-21T18:08:47+00:00"
    },
    {
      "user": "nik9000",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-21T21:05:17+00:00"
    },
    {
      "user": "mouhc1ne",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-22T12:52:13+00:00"
    },
    {
      "user": "nik9000",
      "state": "APPROVED",
      "body": "",
      "submitted_at": "2025-10-22T16:26:57+00:00"
    }
  ],
  "pr_comments": [
    {
      "user": "elasticsearchmachine",
      "body": "Pinging @elastic/es-analytical-engine (Team:Analytics)",
      "created_at": "2025-10-10T19:45:19+00:00"
    },
    {
      "user": "nicpenning",
      "body": "Does this allow this : https://github.com/elastic/elasticsearch/issues/108385",
      "created_at": "2025-10-24T03:13:55+00:00"
    }
  ],
  "files_changed": [
    {
      "filename": "x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/AggregatorImplementer.java",
      "status": "modified",
      "additions": 69,
      "deletions": 65,
      "changes": 134,
      "patch": "@@ -85,7 +85,8 @@ public class AggregatorImplementer {\n     private final List<IntermediateStateDesc> intermediateState;\n \n     private final AggregationState aggState;\n-    private final List<AggregationParameter> aggParams;\n+    private final List<Argument> aggParams;\n+    private final boolean hasOnlyBlockArguments;\n \n     public AggregatorImplementer(\n         Elements elements,\n@@ -111,15 +112,15 @@ public AggregatorImplementer(\n             requireName(\"combine\"),\n             requireArgsStartsWith(requireType(aggState.declaredType()), requireAnyType(\"<aggregation input column type>\"))\n         );\n-        this.aggParams = combine.getParameters().stream().skip(1).flatMap(v -> {\n+        this.aggParams = combine.getParameters().stream().skip(1).map(v -> {\n             Argument a = Argument.fromParameter(types, v);\n-            return switch (a) {\n-                case StandardArgument sa -> Stream.of(new AggregationParameter(sa.name(), sa.type(), false));\n-                case BlockArgument ba -> Stream.of(new AggregationParameter(ba.name(), Types.elementType(ba.type()), true));\n-                case PositionArgument pa -> Stream.of();\n-                default -> throw new IllegalArgumentException(\"unsupported argument [\" + declarationType + \"][\" + a + \"]\");\n-            };\n-        }).toList();\n+            if ((a instanceof StandardArgument || a instanceof BlockArgument || a instanceof PositionArgument) == false) {\n+                throw new IllegalArgumentException(\"unsupported argument [\" + declarationType + \"][\" + a + \"]\");\n+            }\n+            return a;\n+        }).filter(a -> a instanceof PositionArgument == false).toList();\n+\n+        this.hasOnlyBlockArguments = this.aggParams.stream().allMatch(a -> a instanceof BlockArgument);\n \n         this.createParameters = init.getParameters()\n             .stream()\n@@ -199,8 +200,10 @@ private TypeSpec type() {\n         builder.addMethod(addRawInput());\n         builder.addMethod(addRawInputExploded(true));\n         builder.addMethod(addRawInputExploded(false));\n-        builder.addMethod(addRawVector(false));\n-        builder.addMethod(addRawVector(true));\n+        if (hasOnlyBlockArguments == false) {\n+            builder.addMethod(addRawVector(false));\n+            builder.addMethod(addRawVector(true));\n+        }\n         builder.addMethod(addRawBlock(false));\n         builder.addMethod(addRawBlock(true));\n         builder.addMethod(addIntermediateInput());\n@@ -334,35 +337,39 @@ private MethodSpec addRawInputExploded(boolean hasMask) {\n         }\n \n         for (int i = 0; i < aggParams.size(); i++) {\n-            AggregationParameter p = aggParams.get(i);\n-            builder.addStatement(\"$T $L = page.getBlock(channels.get($L))\", blockType(p.type()), p.blockName(), i);\n-        }\n-        for (AggregationParameter p : aggParams) {\n-            builder.addStatement(\"$T $L = $L.asVector()\", vectorType(p.type()), p.vectorName(), p.blockName());\n-            builder.beginControlFlow(\"if ($L == null)\", p.vectorName());\n-            builder.addStatement(\n-                \"addRawBlock(\"\n-                    + aggParams.stream().map(AggregationParameter::blockName).collect(joining(\", \"))\n-                    + (hasMask ? \", mask\" : \"\")\n-                    + \")\"\n-            );\n-            builder.addStatement(\"return\");\n-            builder.endControlFlow();\n+            Argument a = aggParams.get(i);\n+            builder.addStatement(\"$T $L = page.getBlock(channels.get($L))\", a.dataType(true), a.blockName(), i);\n         }\n-        builder.addStatement(\n-            \"addRawVector(\"\n-                + aggParams.stream().map(AggregationParameter::vectorName).collect(joining(\", \"))\n+\n+        for (Argument a : aggParams) {\n+            String rawBlock = \"addRawBlock(\"\n+                + aggParams.stream().map(arg -> arg.blockName()).collect(joining(\", \"))\n                 + (hasMask ? \", mask\" : \"\")\n-                + \")\"\n-        );\n+                + \")\";\n+\n+            a.resolveVectors(builder, rawBlock, \"return\");\n+        }\n+\n+        builder.addStatement(invokeAddRaw(hasOnlyBlockArguments, hasMask));\n         return builder.build();\n     }\n \n+    private String invokeAddRaw(boolean blockStyle, boolean hasMask) {\n+        return addRawName(blockStyle)\n+            + \"(\"\n+            + aggParams.stream().map(a -> blockStyle ? a.blockName() : a.vectorName()).collect(joining(\", \"))\n+            + (hasMask ? \", mask\" : \"\")\n+            + \")\";\n+    }\n+\n+    private String addRawName(boolean blockStyle) {\n+        return blockStyle ? \"addRawBlock\" : \"addRawVector\";\n+    }\n+\n     private MethodSpec addRawVector(boolean masked) {\n-        MethodSpec.Builder builder = initAddRaw(true, masked);\n-        if (aggParams.getFirst().isArray()) {\n-            builder.addComment(\"This type does not support vectors because all values are multi-valued\");\n-            return builder.build();\n+        MethodSpec.Builder builder = initAddRaw(false, masked);\n+        if (aggParams.getFirst() instanceof BlockArgument) {\n+            throw new IllegalStateException(\"The BlockArgument type does not support vectors because all values are multi-valued\");\n         }\n \n         if (first != null) {\n@@ -383,8 +390,8 @@ private MethodSpec addRawVector(boolean masked) {\n             if (masked) {\n                 builder.beginControlFlow(\"if (mask.getBoolean(valuesPosition) == false)\").addStatement(\"continue\").endControlFlow();\n             }\n-            for (AggregationParameter p : aggParams) {\n-                p.read(builder, true);\n+            for (Argument a : aggParams) {\n+                a.read(builder, a.vectorName(), \"valuesPosition\");\n             }\n             combineRawInput(builder, false);\n         }\n@@ -406,8 +413,8 @@ private void addRawVectorWithFirst(MethodSpec.Builder builder, boolean firstPass\n                 builder.addStatement(\"continue\");\n                 builder.endControlFlow();\n             }\n-            for (AggregationParameter p : aggParams) {\n-                p.read(builder, true);\n+            for (Argument a : aggParams) {\n+                a.read(builder, a.vectorName(), \"valuesPosition\");\n             }\n             combineRawInput(builder, firstPass);\n             builder.addStatement(\"valuesPosition++\");\n@@ -420,21 +427,21 @@ private void addRawVectorWithFirst(MethodSpec.Builder builder, boolean firstPass\n     }\n \n     private MethodSpec addRawBlock(boolean masked) {\n-        MethodSpec.Builder builder = initAddRaw(false, masked);\n+        MethodSpec.Builder builder = initAddRaw(true, masked);\n \n         builder.beginControlFlow(\"for (int p = 0; p < $L.getPositionCount(); p++)\", aggParams.getFirst().blockName());\n         {\n             if (masked) {\n                 builder.beginControlFlow(\"if (mask.getBoolean(p) == false)\").addStatement(\"continue\").endControlFlow();\n             }\n-            for (AggregationParameter p : aggParams) {\n-                builder.addStatement(\"int $LValueCount = $L.getValueCount(p)\", p.name(), p.blockName());\n-                builder.beginControlFlow(\"if ($LValueCount == 0)\", p.name());\n+            for (Argument a : aggParams) {\n+                builder.addStatement(\"int $LValueCount = $L.getValueCount(p)\", a.name(), a.blockName());\n+                builder.beginControlFlow(\"if ($LValueCount == 0)\", a.name());\n                 builder.addStatement(\"continue\");\n                 builder.endControlFlow();\n             }\n \n-            if (aggParams.getFirst().isArray()) {\n+            if (aggParams.getFirst() instanceof BlockArgument) {\n                 if (aggParams.size() > 1) {\n                     throw new IllegalArgumentException(\"array mode not supported for multiple args\");\n                 }\n@@ -446,18 +453,18 @@ private MethodSpec addRawBlock(boolean masked) {\n                 if (first == null && aggState.hasSeen()) {\n                     builder.addStatement(\"state.seen(true)\");\n                 }\n-                for (AggregationParameter p : aggParams) {\n-                    builder.addStatement(\"int $L = $L.getFirstValueIndex(p)\", p.startName(), p.blockName());\n-                    builder.addStatement(\"int $L = $L + $LValueCount\", p.endName(), p.startName(), p.name());\n+                for (Argument a : aggParams) {\n+                    builder.addStatement(\"int $L = $L.getFirstValueIndex(p)\", a.startName(), a.blockName());\n+                    builder.addStatement(\"int $L = $L + $LValueCount\", a.endName(), a.startName(), a.name());\n                     builder.beginControlFlow(\n                         \"for (int $L = $L; $L < $L; $L++)\",\n-                        p.offsetName(),\n-                        p.startName(),\n-                        p.offsetName(),\n-                        p.endName(),\n-                        p.offsetName()\n+                        a.offsetName(),\n+                        a.startName(),\n+                        a.offsetName(),\n+                        a.endName(),\n+                        a.offsetName()\n                     );\n-                    p.read(builder, false);\n+                    a.read(builder, a.blockName(), a.offsetName());\n                 }\n                 if (first != null) {\n                     builder.addComment(\"Check seen in every iteration to save on complexity in the Block path\");\n@@ -474,7 +481,7 @@ private MethodSpec addRawBlock(boolean masked) {\n                 } else {\n                     combineRawInput(builder, false);\n                 }\n-                for (AggregationParameter p : aggParams) {\n+                for (Argument a : aggParams) {\n                     builder.endControlFlow();\n                 }\n             }\n@@ -483,22 +490,19 @@ private MethodSpec addRawBlock(boolean masked) {\n         return builder.build();\n     }\n \n-    private MethodSpec.Builder initAddRaw(boolean valuesAreVector, boolean masked) {\n-        MethodSpec.Builder builder = MethodSpec.methodBuilder(valuesAreVector ? \"addRawVector\" : \"addRawBlock\");\n+    private MethodSpec.Builder initAddRaw(boolean blockStyle, boolean masked) {\n+        MethodSpec.Builder builder = MethodSpec.methodBuilder(addRawName(blockStyle));\n         builder.addModifiers(Modifier.PRIVATE);\n-        for (AggregationParameter p : aggParams) {\n-            builder.addParameter(\n-                valuesAreVector ? vectorType(p.type) : blockType(p.type),\n-                valuesAreVector ? p.vectorName() : p.blockName()\n-            );\n+        for (Argument a : aggParams) {\n+            a.declareProcessParameter(builder, blockStyle);\n         }\n         if (masked) {\n             builder.addParameter(BOOLEAN_VECTOR, \"mask\");\n         }\n-        for (AggregationParameter p : aggParams) {\n-            if (p.isBytesRef()) {\n+        for (Argument a : aggParams) {\n+            if (a.isBytesRef()) {\n                 // Add bytes_ref scratch var that will be used for bytes_ref blocks/vectors\n-                builder.addStatement(\"$T $L = new $T()\", BYTES_REF, p.scratchName(), BYTES_REF);\n+                builder.addStatement(\"$T $L = new $T()\", BYTES_REF, a.scratchName(), BYTES_REF);\n             }\n         }\n         return builder;\n@@ -527,9 +531,9 @@ private void invokeCombineRawInput(TypeName returnType, MethodSpec.Builder build\n         } else {\n             throw new IllegalArgumentException(\"combine must return void or a primitive\");\n         }\n-        for (AggregationParameter p : aggParams) {\n+        for (Argument a : aggParams) {\n             pattern.append(\", $L\");\n-            params.add(p.valueName());\n+            params.add(a.valueName());\n         }\n         if (returnType.isPrimitive()) {\n             pattern.append(\")\");"
    },
    {
      "filename": "x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/Types.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -242,7 +242,7 @@ static ClassName vectorFixedBuilderType(TypeName elementType) {\n         throw new IllegalArgumentException(\"unknown vector fixed builder type for [\" + elementType + \"]\");\n     }\n \n-    static TypeName elementType(TypeName t) {\n+    public static TypeName elementType(TypeName t) {\n         if (t.equals(BOOLEAN_BLOCK) || t.equals(BOOLEAN_VECTOR) || t.equals(BOOLEAN_BLOCK_BUILDER)) {\n             return TypeName.BOOLEAN;\n         }"
    },
    {
      "filename": "x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/Argument.java",
      "status": "modified",
      "additions": 72,
      "deletions": 2,
      "changes": 74,
      "patch": "@@ -17,12 +17,17 @@\n import org.elasticsearch.compute.gen.Types;\n \n import java.util.List;\n+import java.util.Objects;\n \n import javax.lang.model.element.VariableElement;\n import javax.lang.model.type.ArrayType;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n \n+import static org.elasticsearch.compute.gen.Methods.getMethod;\n+import static org.elasticsearch.compute.gen.Types.BYTES_REF;\n+import static org.elasticsearch.compute.gen.Types.blockType;\n+import static org.elasticsearch.compute.gen.Types.vectorType;\n import static org.elasticsearch.compute.gen.argument.StandardArgument.isBlockType;\n \n /**\n@@ -45,7 +50,7 @@ static Argument fromParameter(javax.lang.model.util.Types types, VariableElement\n \n         Position position = v.getAnnotation(Position.class);\n         if (position != null) {\n-            return new PositionArgument();\n+            return new PositionArgument(type, name);\n         }\n \n         if (type instanceof ClassName c\n@@ -64,6 +69,50 @@ static Argument fromParameter(javax.lang.model.util.Types types, VariableElement\n         return new StandardArgument(type, name);\n     }\n \n+    default String blockName() {\n+        return paramName(true);\n+    }\n+\n+    default String vectorName() {\n+        return paramName(false);\n+    }\n+\n+    default String valueName() {\n+        return name() + \"Value\";\n+    }\n+\n+    default String startName() {\n+        return name() + \"Start\";\n+    }\n+\n+    default String endName() {\n+        return name() + \"End\";\n+    }\n+\n+    default String offsetName() {\n+        return name() + \"Offset\";\n+    }\n+\n+    default String scratchName() {\n+        if (isBytesRef() == false) {\n+            throw new IllegalStateException(\"can't build scratch for non-BytesRef\");\n+        }\n+\n+        return name() + \"Scratch\";\n+    }\n+\n+    default boolean isBytesRef() {\n+        return Objects.equals(type(), BYTES_REF);\n+    }\n+\n+    String name();\n+\n+    TypeName type();\n+\n+    default TypeName elementType() {\n+        return type();\n+    }\n+\n     /**\n      * Type containing the actual data for a page of values for this field. Usually a\n      * Block or Vector, but for fixed fields will be the original fixed type.\n@@ -121,7 +170,7 @@ static Argument fromParameter(javax.lang.model.util.Types types, VariableElement\n      * call the block flavored evaluator if this is a block. Noop if the\n      * parameter is {@link Fixed}.\n      */\n-    void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval);\n+    void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval);\n \n     /**\n      * Create any scratch structures needed by {@code eval}.\n@@ -144,6 +193,27 @@ static Argument fromParameter(javax.lang.model.util.Types types, VariableElement\n      */\n     void read(MethodSpec.Builder builder, boolean blockStyle);\n \n+    /**\n+     * Read the value of this parameter to a local variable, by calling the accessor's typed get method and passing necessary params.\n+     */\n+    default void read(MethodSpec.Builder builder, String accessor, String firstParam) {\n+        String params = firstParam;\n+        if (isBytesRef()) {\n+            params += \", \" + scratchName();\n+        }\n+        builder.addStatement(\"$T $L = $L.$L($L)\", type(), valueName(), accessor, getMethod(type()), params);\n+    }\n+\n+    /**\n+     * Adds the parameter declaration for this argument to the method spec.\n+     */\n+    default void declareProcessParameter(MethodSpec.Builder builder, boolean blockStyle) {\n+        TypeName typeName = elementType();\n+        ClassName parameterType = blockStyle ? blockType(typeName) : vectorType(typeName);\n+        String parameterName = blockStyle ? blockName() : vectorName();\n+        builder.addParameter(parameterType, parameterName);\n+    }\n+\n     /**\n      * Build the invocation of the process method for this parameter.\n      */"
    },
    {
      "filename": "x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/ArrayArgument.java",
      "status": "modified",
      "additions": 13,
      "deletions": 12,
      "changes": 25,
      "patch": "@@ -26,13 +26,13 @@\n import static org.elasticsearch.compute.gen.Types.blockType;\n import static org.elasticsearch.compute.gen.Types.vectorType;\n \n-public record ArrayArgument(TypeName componentType, String name) implements Argument {\n+public record ArrayArgument(TypeName type, String name) implements Argument {\n     @Override\n     public TypeName dataType(boolean blockStyle) {\n         if (blockStyle) {\n-            return ArrayTypeName.of(blockType(componentType));\n+            return ArrayTypeName.of(blockType(type));\n         }\n-        return ArrayTypeName.of(vectorType(componentType));\n+        return ArrayTypeName.of(vectorType(type));\n     }\n \n     @Override\n@@ -76,7 +76,7 @@ public String factoryInvocation(MethodSpec.Builder factoryMethodBuilder) {\n \n     @Override\n     public void evalToBlock(MethodSpec.Builder builder) {\n-        TypeName blockType = blockType(componentType);\n+        TypeName blockType = blockType(type);\n         builder.addStatement(\"$T[] $LBlocks = new $T[$L.length]\", blockType, name, blockType, name);\n         builder.beginControlFlow(\"try ($T $LRelease = $T.wrap($LBlocks))\", RELEASABLE, name, RELEASABLES, name);\n         builder.beginControlFlow(\"for (int i = 0; i < $LBlocks.length; i++)\", name);\n@@ -92,20 +92,21 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {\n     }\n \n     @Override\n-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {\n-        TypeName vectorType = vectorType(componentType);\n+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {\n+        assert invokeBlockEval != null && invokeBlockEval.length == 1;\n+        TypeName vectorType = vectorType(type);\n         builder.addStatement(\"$T[] $LVectors = new $T[$L.length]\", vectorType, name, vectorType, name);\n         builder.beginControlFlow(\"for (int i = 0; i < $LBlocks.length; i++)\", name);\n         builder.addStatement(\"$LVectors[i] = $LBlocks[i].asVector()\", name, name);\n-        builder.beginControlFlow(\"if ($LVectors[i] == null)\", name).addStatement(invokeBlockEval).endControlFlow();\n+        builder.beginControlFlow(\"if ($LVectors[i] == null)\", name).addStatement(invokeBlockEval[0]).endControlFlow();\n         builder.endControlFlow();\n     }\n \n     @Override\n     public void createScratch(MethodSpec.Builder builder) {\n-        builder.addStatement(\"$T[] $LValues = new $T[$L.length]\", componentType, name, componentType, name);\n-        if (componentType.equals(BYTES_REF)) {\n-            builder.addStatement(\"$T[] $LScratch = new $T[$L.length]\", componentType, name, componentType, name);\n+        builder.addStatement(\"$T[] $LValues = new $T[$L.length]\", type, name, type, name);\n+        if (isBytesRef()) {\n+            builder.addStatement(\"$T[] $LScratch = new $T[$L.length]\", type, name, type, name);\n             builder.beginControlFlow(\"for (int i = 0; i < $L.length; i++)\", name);\n             builder.addStatement(\"$LScratch[i] = new $T()\", name, BYTES_REF);\n             builder.endControlFlow();\n@@ -135,10 +136,10 @@ public void read(MethodSpec.Builder builder, boolean blockStyle) {\n         } else {\n             lookupVar = \"p\";\n         }\n-        if (componentType.equals(BYTES_REF)) {\n+        if (isBytesRef()) {\n             builder.addStatement(\"$LValues[i] = $L[i].getBytesRef($L, $LScratch[i])\", name, paramName(blockStyle), lookupVar, name);\n         } else {\n-            builder.addStatement(\"$LValues[i] = $L[i].$L($L)\", name, paramName(blockStyle), getMethod(componentType), lookupVar);\n+            builder.addStatement(\"$LValues[i] = $L[i].$L($L)\", name, paramName(blockStyle), getMethod(type), lookupVar);\n         }\n         builder.endControlFlow();\n     }"
    },
    {
      "filename": "x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BlockArgument.java",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "patch": "@@ -11,6 +11,8 @@\n import com.squareup.javapoet.TypeName;\n import com.squareup.javapoet.TypeSpec;\n \n+import org.elasticsearch.compute.gen.Types;\n+\n import java.util.List;\n \n import javax.lang.model.element.Modifier;\n@@ -24,6 +26,11 @@ public TypeName dataType(boolean blockStyle) {\n         return type;\n     }\n \n+    @Override\n+    public TypeName elementType() {\n+        return Types.elementType(type());\n+    }\n+\n     @Override\n     public String paramName(boolean blockStyle) {\n         return name + \"Block\";\n@@ -67,7 +74,7 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {\n     }\n \n     @Override\n-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {\n+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {\n         // nothing to do\n     }\n "
    },
    {
      "filename": "x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BuilderArgument.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -62,7 +62,7 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {\n     }\n \n     @Override\n-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {\n+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {\n         // nothing to do\n     }\n "
    },
    {
      "filename": "x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/FixedArgument.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -84,7 +84,7 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {\n     }\n \n     @Override\n-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {\n+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {\n         // nothing to do\n     }\n "
    },
    {
      "filename": "x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/PositionArgument.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "patch": "@@ -16,7 +16,7 @@\n /**\n  * The position in a block.\n  */\n-public record PositionArgument() implements Argument {\n+public record PositionArgument(TypeName type, String name) implements Argument {\n     @Override\n     public TypeName dataType(boolean blockStyle) {\n         return TypeName.INT;\n@@ -64,7 +64,7 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {\n     }\n \n     @Override\n-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {\n+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {\n         // nothing to do\n     }\n "
    },
    {
      "filename": "x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/StandardArgument.java",
      "status": "modified",
      "additions": 11,
      "deletions": 6,
      "changes": 17,
      "patch": "@@ -80,14 +80,20 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {\n     }\n \n     @Override\n-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {\n+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {\n         builder.addStatement(\"$T $LVector = $LBlock.asVector()\", vectorType(type), name, name);\n-        builder.beginControlFlow(\"if ($LVector == null)\", name).addStatement(invokeBlockEval).endControlFlow();\n+        builder.beginControlFlow(\"if ($LVector == null)\", name);\n+\n+        for (String statement : invokeBlockEval) {\n+            builder.addStatement(statement);\n+        }\n+\n+        builder.endControlFlow();\n     }\n \n     @Override\n     public void createScratch(MethodSpec.Builder builder) {\n-        if (type.equals(BYTES_REF)) {\n+        if (isBytesRef()) {\n             builder.addStatement(\"$T $LScratch = new $T()\", BYTES_REF, name, BYTES_REF);\n         }\n     }\n@@ -117,10 +123,9 @@ static boolean isBlockType(TypeName type) {\n     @Override\n     public void read(MethodSpec.Builder builder, boolean blockStyle) {\n         String params = blockStyle ? paramName(true) + \".getFirstValueIndex(p)\" : \"p\";\n-        if (type.equals(BYTES_REF)) {\n-            params += \", \" + name + \"Scratch\";\n+        if (isBytesRef()) {\n+            params += \", \" + scratchName();\n         }\n-\n         builder.addStatement(\"$T $L = $L.$L($L)\", type, name, paramName(blockStyle), getMethod(type), params);\n     }\n "
    },
    {
      "filename": "x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentCartesianShapeDocValuesAggregatorFunction.java",
      "status": "modified",
      "additions": 2,
      "deletions": 20,
      "changes": 22,
      "patch": "@@ -70,30 +70,12 @@ public void addRawInput(Page page, BooleanVector mask) {\n \n   private void addRawInputMasked(Page page, BooleanVector mask) {\n     IntBlock valuesBlock = page.getBlock(channels.get(0));\n-    IntVector valuesVector = valuesBlock.asVector();\n-    if (valuesVector == null) {\n-      addRawBlock(valuesBlock, mask);\n-      return;\n-    }\n-    addRawVector(valuesVector, mask);\n+    addRawBlock(valuesBlock, mask);\n   }\n \n   private void addRawInputNotMasked(Page page) {\n     IntBlock valuesBlock = page.getBlock(channels.get(0));\n-    IntVector valuesVector = valuesBlock.asVector();\n-    if (valuesVector == null) {\n-      addRawBlock(valuesBlock);\n-      return;\n-    }\n-    addRawVector(valuesVector);\n-  }\n-\n-  private void addRawVector(IntVector valuesVector) {\n-    // This type does not support vectors because all values are multi-valued\n-  }\n-\n-  private void addRawVector(IntVector valuesVector, BooleanVector mask) {\n-    // This type does not support vectors because all values are multi-valued\n+    addRawBlock(valuesBlock);\n   }\n \n   private void addRawBlock(IntBlock valuesBlock) {"
    },
    {
      "filename": "x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentGeoShapeDocValuesAggregatorFunction.java",
      "status": "modified",
      "additions": 2,
      "deletions": 20,
      "changes": 22,
      "patch": "@@ -72,30 +72,12 @@ public void addRawInput(Page page, BooleanVector mask) {\n \n   private void addRawInputMasked(Page page, BooleanVector mask) {\n     IntBlock valuesBlock = page.getBlock(channels.get(0));\n-    IntVector valuesVector = valuesBlock.asVector();\n-    if (valuesVector == null) {\n-      addRawBlock(valuesBlock, mask);\n-      return;\n-    }\n-    addRawVector(valuesVector, mask);\n+    addRawBlock(valuesBlock, mask);\n   }\n \n   private void addRawInputNotMasked(Page page) {\n     IntBlock valuesBlock = page.getBlock(channels.get(0));\n-    IntVector valuesVector = valuesBlock.asVector();\n-    if (valuesVector == null) {\n-      addRawBlock(valuesBlock);\n-      return;\n-    }\n-    addRawVector(valuesVector);\n-  }\n-\n-  private void addRawVector(IntVector valuesVector) {\n-    // This type does not support vectors because all values are multi-valued\n-  }\n-\n-  private void addRawVector(IntVector valuesVector, BooleanVector mask) {\n-    // This type does not support vectors because all values are multi-valued\n+    addRawBlock(valuesBlock);\n   }\n \n   private void addRawBlock(IntBlock valuesBlock) {"
    }
  ],
  "diff": "diff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/AggregatorImplementer.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/AggregatorImplementer.java\nindex 7989268a02071..e30164bc8aec5 100644\n--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/AggregatorImplementer.java\n+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/AggregatorImplementer.java\n@@ -85,7 +85,8 @@ public class AggregatorImplementer {\n     private final List<IntermediateStateDesc> intermediateState;\n \n     private final AggregationState aggState;\n-    private final List<AggregationParameter> aggParams;\n+    private final List<Argument> aggParams;\n+    private final boolean hasOnlyBlockArguments;\n \n     public AggregatorImplementer(\n         Elements elements,\n@@ -111,15 +112,15 @@ public AggregatorImplementer(\n             requireName(\"combine\"),\n             requireArgsStartsWith(requireType(aggState.declaredType()), requireAnyType(\"<aggregation input column type>\"))\n         );\n-        this.aggParams = combine.getParameters().stream().skip(1).flatMap(v -> {\n+        this.aggParams = combine.getParameters().stream().skip(1).map(v -> {\n             Argument a = Argument.fromParameter(types, v);\n-            return switch (a) {\n-                case StandardArgument sa -> Stream.of(new AggregationParameter(sa.name(), sa.type(), false));\n-                case BlockArgument ba -> Stream.of(new AggregationParameter(ba.name(), Types.elementType(ba.type()), true));\n-                case PositionArgument pa -> Stream.of();\n-                default -> throw new IllegalArgumentException(\"unsupported argument [\" + declarationType + \"][\" + a + \"]\");\n-            };\n-        }).toList();\n+            if ((a instanceof StandardArgument || a instanceof BlockArgument || a instanceof PositionArgument) == false) {\n+                throw new IllegalArgumentException(\"unsupported argument [\" + declarationType + \"][\" + a + \"]\");\n+            }\n+            return a;\n+        }).filter(a -> a instanceof PositionArgument == false).toList();\n+\n+        this.hasOnlyBlockArguments = this.aggParams.stream().allMatch(a -> a instanceof BlockArgument);\n \n         this.createParameters = init.getParameters()\n             .stream()\n@@ -199,8 +200,10 @@ private TypeSpec type() {\n         builder.addMethod(addRawInput());\n         builder.addMethod(addRawInputExploded(true));\n         builder.addMethod(addRawInputExploded(false));\n-        builder.addMethod(addRawVector(false));\n-        builder.addMethod(addRawVector(true));\n+        if (hasOnlyBlockArguments == false) {\n+            builder.addMethod(addRawVector(false));\n+            builder.addMethod(addRawVector(true));\n+        }\n         builder.addMethod(addRawBlock(false));\n         builder.addMethod(addRawBlock(true));\n         builder.addMethod(addIntermediateInput());\n@@ -334,35 +337,39 @@ private MethodSpec addRawInputExploded(boolean hasMask) {\n         }\n \n         for (int i = 0; i < aggParams.size(); i++) {\n-            AggregationParameter p = aggParams.get(i);\n-            builder.addStatement(\"$T $L = page.getBlock(channels.get($L))\", blockType(p.type()), p.blockName(), i);\n-        }\n-        for (AggregationParameter p : aggParams) {\n-            builder.addStatement(\"$T $L = $L.asVector()\", vectorType(p.type()), p.vectorName(), p.blockName());\n-            builder.beginControlFlow(\"if ($L == null)\", p.vectorName());\n-            builder.addStatement(\n-                \"addRawBlock(\"\n-                    + aggParams.stream().map(AggregationParameter::blockName).collect(joining(\", \"))\n-                    + (hasMask ? \", mask\" : \"\")\n-                    + \")\"\n-            );\n-            builder.addStatement(\"return\");\n-            builder.endControlFlow();\n+            Argument a = aggParams.get(i);\n+            builder.addStatement(\"$T $L = page.getBlock(channels.get($L))\", a.dataType(true), a.blockName(), i);\n         }\n-        builder.addStatement(\n-            \"addRawVector(\"\n-                + aggParams.stream().map(AggregationParameter::vectorName).collect(joining(\", \"))\n+\n+        for (Argument a : aggParams) {\n+            String rawBlock = \"addRawBlock(\"\n+                + aggParams.stream().map(arg -> arg.blockName()).collect(joining(\", \"))\n                 + (hasMask ? \", mask\" : \"\")\n-                + \")\"\n-        );\n+                + \")\";\n+\n+            a.resolveVectors(builder, rawBlock, \"return\");\n+        }\n+\n+        builder.addStatement(invokeAddRaw(hasOnlyBlockArguments, hasMask));\n         return builder.build();\n     }\n \n+    private String invokeAddRaw(boolean blockStyle, boolean hasMask) {\n+        return addRawName(blockStyle)\n+            + \"(\"\n+            + aggParams.stream().map(a -> blockStyle ? a.blockName() : a.vectorName()).collect(joining(\", \"))\n+            + (hasMask ? \", mask\" : \"\")\n+            + \")\";\n+    }\n+\n+    private String addRawName(boolean blockStyle) {\n+        return blockStyle ? \"addRawBlock\" : \"addRawVector\";\n+    }\n+\n     private MethodSpec addRawVector(boolean masked) {\n-        MethodSpec.Builder builder = initAddRaw(true, masked);\n-        if (aggParams.getFirst().isArray()) {\n-            builder.addComment(\"This type does not support vectors because all values are multi-valued\");\n-            return builder.build();\n+        MethodSpec.Builder builder = initAddRaw(false, masked);\n+        if (aggParams.getFirst() instanceof BlockArgument) {\n+            throw new IllegalStateException(\"The BlockArgument type does not support vectors because all values are multi-valued\");\n         }\n \n         if (first != null) {\n@@ -383,8 +390,8 @@ private MethodSpec addRawVector(boolean masked) {\n             if (masked) {\n                 builder.beginControlFlow(\"if (mask.getBoolean(valuesPosition) == false)\").addStatement(\"continue\").endControlFlow();\n             }\n-            for (AggregationParameter p : aggParams) {\n-                p.read(builder, true);\n+            for (Argument a : aggParams) {\n+                a.read(builder, a.vectorName(), \"valuesPosition\");\n             }\n             combineRawInput(builder, false);\n         }\n@@ -406,8 +413,8 @@ private void addRawVectorWithFirst(MethodSpec.Builder builder, boolean firstPass\n                 builder.addStatement(\"continue\");\n                 builder.endControlFlow();\n             }\n-            for (AggregationParameter p : aggParams) {\n-                p.read(builder, true);\n+            for (Argument a : aggParams) {\n+                a.read(builder, a.vectorName(), \"valuesPosition\");\n             }\n             combineRawInput(builder, firstPass);\n             builder.addStatement(\"valuesPosition++\");\n@@ -420,21 +427,21 @@ private void addRawVectorWithFirst(MethodSpec.Builder builder, boolean firstPass\n     }\n \n     private MethodSpec addRawBlock(boolean masked) {\n-        MethodSpec.Builder builder = initAddRaw(false, masked);\n+        MethodSpec.Builder builder = initAddRaw(true, masked);\n \n         builder.beginControlFlow(\"for (int p = 0; p < $L.getPositionCount(); p++)\", aggParams.getFirst().blockName());\n         {\n             if (masked) {\n                 builder.beginControlFlow(\"if (mask.getBoolean(p) == false)\").addStatement(\"continue\").endControlFlow();\n             }\n-            for (AggregationParameter p : aggParams) {\n-                builder.addStatement(\"int $LValueCount = $L.getValueCount(p)\", p.name(), p.blockName());\n-                builder.beginControlFlow(\"if ($LValueCount == 0)\", p.name());\n+            for (Argument a : aggParams) {\n+                builder.addStatement(\"int $LValueCount = $L.getValueCount(p)\", a.name(), a.blockName());\n+                builder.beginControlFlow(\"if ($LValueCount == 0)\", a.name());\n                 builder.addStatement(\"continue\");\n                 builder.endControlFlow();\n             }\n \n-            if (aggParams.getFirst().isArray()) {\n+            if (aggParams.getFirst() instanceof BlockArgument) {\n                 if (aggParams.size() > 1) {\n                     throw new IllegalArgumentException(\"array mode not supported for multiple args\");\n                 }\n@@ -446,18 +453,18 @@ private MethodSpec addRawBlock(boolean masked) {\n                 if (first == null && aggState.hasSeen()) {\n                     builder.addStatement(\"state.seen(true)\");\n                 }\n-                for (AggregationParameter p : aggParams) {\n-                    builder.addStatement(\"int $L = $L.getFirstValueIndex(p)\", p.startName(), p.blockName());\n-                    builder.addStatement(\"int $L = $L + $LValueCount\", p.endName(), p.startName(), p.name());\n+                for (Argument a : aggParams) {\n+                    builder.addStatement(\"int $L = $L.getFirstValueIndex(p)\", a.startName(), a.blockName());\n+                    builder.addStatement(\"int $L = $L + $LValueCount\", a.endName(), a.startName(), a.name());\n                     builder.beginControlFlow(\n                         \"for (int $L = $L; $L < $L; $L++)\",\n-                        p.offsetName(),\n-                        p.startName(),\n-                        p.offsetName(),\n-                        p.endName(),\n-                        p.offsetName()\n+                        a.offsetName(),\n+                        a.startName(),\n+                        a.offsetName(),\n+                        a.endName(),\n+                        a.offsetName()\n                     );\n-                    p.read(builder, false);\n+                    a.read(builder, a.blockName(), a.offsetName());\n                 }\n                 if (first != null) {\n                     builder.addComment(\"Check seen in every iteration to save on complexity in the Block path\");\n@@ -474,7 +481,7 @@ private MethodSpec addRawBlock(boolean masked) {\n                 } else {\n                     combineRawInput(builder, false);\n                 }\n-                for (AggregationParameter p : aggParams) {\n+                for (Argument a : aggParams) {\n                     builder.endControlFlow();\n                 }\n             }\n@@ -483,22 +490,19 @@ private MethodSpec addRawBlock(boolean masked) {\n         return builder.build();\n     }\n \n-    private MethodSpec.Builder initAddRaw(boolean valuesAreVector, boolean masked) {\n-        MethodSpec.Builder builder = MethodSpec.methodBuilder(valuesAreVector ? \"addRawVector\" : \"addRawBlock\");\n+    private MethodSpec.Builder initAddRaw(boolean blockStyle, boolean masked) {\n+        MethodSpec.Builder builder = MethodSpec.methodBuilder(addRawName(blockStyle));\n         builder.addModifiers(Modifier.PRIVATE);\n-        for (AggregationParameter p : aggParams) {\n-            builder.addParameter(\n-                valuesAreVector ? vectorType(p.type) : blockType(p.type),\n-                valuesAreVector ? p.vectorName() : p.blockName()\n-            );\n+        for (Argument a : aggParams) {\n+            a.declareProcessParameter(builder, blockStyle);\n         }\n         if (masked) {\n             builder.addParameter(BOOLEAN_VECTOR, \"mask\");\n         }\n-        for (AggregationParameter p : aggParams) {\n-            if (p.isBytesRef()) {\n+        for (Argument a : aggParams) {\n+            if (a.isBytesRef()) {\n                 // Add bytes_ref scratch var that will be used for bytes_ref blocks/vectors\n-                builder.addStatement(\"$T $L = new $T()\", BYTES_REF, p.scratchName(), BYTES_REF);\n+                builder.addStatement(\"$T $L = new $T()\", BYTES_REF, a.scratchName(), BYTES_REF);\n             }\n         }\n         return builder;\n@@ -527,9 +531,9 @@ private void invokeCombineRawInput(TypeName returnType, MethodSpec.Builder build\n         } else {\n             throw new IllegalArgumentException(\"combine must return void or a primitive\");\n         }\n-        for (AggregationParameter p : aggParams) {\n+        for (Argument a : aggParams) {\n             pattern.append(\", $L\");\n-            params.add(p.valueName());\n+            params.add(a.valueName());\n         }\n         if (returnType.isPrimitive()) {\n             pattern.append(\")\");\ndiff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/Types.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/Types.java\nindex 3bfb1601f7b16..82b3450343ced 100644\n--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/Types.java\n+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/Types.java\n@@ -242,7 +242,7 @@ static ClassName vectorFixedBuilderType(TypeName elementType) {\n         throw new IllegalArgumentException(\"unknown vector fixed builder type for [\" + elementType + \"]\");\n     }\n \n-    static TypeName elementType(TypeName t) {\n+    public static TypeName elementType(TypeName t) {\n         if (t.equals(BOOLEAN_BLOCK) || t.equals(BOOLEAN_VECTOR) || t.equals(BOOLEAN_BLOCK_BUILDER)) {\n             return TypeName.BOOLEAN;\n         }\ndiff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/Argument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/Argument.java\nindex 56777ea46b985..4a2100a177e92 100644\n--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/Argument.java\n+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/Argument.java\n@@ -17,12 +17,17 @@\n import org.elasticsearch.compute.gen.Types;\n \n import java.util.List;\n+import java.util.Objects;\n \n import javax.lang.model.element.VariableElement;\n import javax.lang.model.type.ArrayType;\n import javax.lang.model.type.TypeKind;\n import javax.lang.model.type.TypeMirror;\n \n+import static org.elasticsearch.compute.gen.Methods.getMethod;\n+import static org.elasticsearch.compute.gen.Types.BYTES_REF;\n+import static org.elasticsearch.compute.gen.Types.blockType;\n+import static org.elasticsearch.compute.gen.Types.vectorType;\n import static org.elasticsearch.compute.gen.argument.StandardArgument.isBlockType;\n \n /**\n@@ -45,7 +50,7 @@ static Argument fromParameter(javax.lang.model.util.Types types, VariableElement\n \n         Position position = v.getAnnotation(Position.class);\n         if (position != null) {\n-            return new PositionArgument();\n+            return new PositionArgument(type, name);\n         }\n \n         if (type instanceof ClassName c\n@@ -64,6 +69,50 @@ static Argument fromParameter(javax.lang.model.util.Types types, VariableElement\n         return new StandardArgument(type, name);\n     }\n \n+    default String blockName() {\n+        return paramName(true);\n+    }\n+\n+    default String vectorName() {\n+        return paramName(false);\n+    }\n+\n+    default String valueName() {\n+        return name() + \"Value\";\n+    }\n+\n+    default String startName() {\n+        return name() + \"Start\";\n+    }\n+\n+    default String endName() {\n+        return name() + \"End\";\n+    }\n+\n+    default String offsetName() {\n+        return name() + \"Offset\";\n+    }\n+\n+    default String scratchName() {\n+        if (isBytesRef() == false) {\n+            throw new IllegalStateException(\"can't build scratch for non-BytesRef\");\n+        }\n+\n+        return name() + \"Scratch\";\n+    }\n+\n+    default boolean isBytesRef() {\n+        return Objects.equals(type(), BYTES_REF);\n+    }\n+\n+    String name();\n+\n+    TypeName type();\n+\n+    default TypeName elementType() {\n+        return type();\n+    }\n+\n     /**\n      * Type containing the actual data for a page of values for this field. Usually a\n      * Block or Vector, but for fixed fields will be the original fixed type.\n@@ -121,7 +170,7 @@ static Argument fromParameter(javax.lang.model.util.Types types, VariableElement\n      * call the block flavored evaluator if this is a block. Noop if the\n      * parameter is {@link Fixed}.\n      */\n-    void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval);\n+    void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval);\n \n     /**\n      * Create any scratch structures needed by {@code eval}.\n@@ -144,6 +193,27 @@ static Argument fromParameter(javax.lang.model.util.Types types, VariableElement\n      */\n     void read(MethodSpec.Builder builder, boolean blockStyle);\n \n+    /**\n+     * Read the value of this parameter to a local variable, by calling the accessor's typed get method and passing necessary params.\n+     */\n+    default void read(MethodSpec.Builder builder, String accessor, String firstParam) {\n+        String params = firstParam;\n+        if (isBytesRef()) {\n+            params += \", \" + scratchName();\n+        }\n+        builder.addStatement(\"$T $L = $L.$L($L)\", type(), valueName(), accessor, getMethod(type()), params);\n+    }\n+\n+    /**\n+     * Adds the parameter declaration for this argument to the method spec.\n+     */\n+    default void declareProcessParameter(MethodSpec.Builder builder, boolean blockStyle) {\n+        TypeName typeName = elementType();\n+        ClassName parameterType = blockStyle ? blockType(typeName) : vectorType(typeName);\n+        String parameterName = blockStyle ? blockName() : vectorName();\n+        builder.addParameter(parameterType, parameterName);\n+    }\n+\n     /**\n      * Build the invocation of the process method for this parameter.\n      */\ndiff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/ArrayArgument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/ArrayArgument.java\nindex ad25985a0fc80..0ee2bf1998a74 100644\n--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/ArrayArgument.java\n+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/ArrayArgument.java\n@@ -26,13 +26,13 @@\n import static org.elasticsearch.compute.gen.Types.blockType;\n import static org.elasticsearch.compute.gen.Types.vectorType;\n \n-public record ArrayArgument(TypeName componentType, String name) implements Argument {\n+public record ArrayArgument(TypeName type, String name) implements Argument {\n     @Override\n     public TypeName dataType(boolean blockStyle) {\n         if (blockStyle) {\n-            return ArrayTypeName.of(blockType(componentType));\n+            return ArrayTypeName.of(blockType(type));\n         }\n-        return ArrayTypeName.of(vectorType(componentType));\n+        return ArrayTypeName.of(vectorType(type));\n     }\n \n     @Override\n@@ -76,7 +76,7 @@ public String factoryInvocation(MethodSpec.Builder factoryMethodBuilder) {\n \n     @Override\n     public void evalToBlock(MethodSpec.Builder builder) {\n-        TypeName blockType = blockType(componentType);\n+        TypeName blockType = blockType(type);\n         builder.addStatement(\"$T[] $LBlocks = new $T[$L.length]\", blockType, name, blockType, name);\n         builder.beginControlFlow(\"try ($T $LRelease = $T.wrap($LBlocks))\", RELEASABLE, name, RELEASABLES, name);\n         builder.beginControlFlow(\"for (int i = 0; i < $LBlocks.length; i++)\", name);\n@@ -92,20 +92,21 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {\n     }\n \n     @Override\n-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {\n-        TypeName vectorType = vectorType(componentType);\n+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {\n+        assert invokeBlockEval != null && invokeBlockEval.length == 1;\n+        TypeName vectorType = vectorType(type);\n         builder.addStatement(\"$T[] $LVectors = new $T[$L.length]\", vectorType, name, vectorType, name);\n         builder.beginControlFlow(\"for (int i = 0; i < $LBlocks.length; i++)\", name);\n         builder.addStatement(\"$LVectors[i] = $LBlocks[i].asVector()\", name, name);\n-        builder.beginControlFlow(\"if ($LVectors[i] == null)\", name).addStatement(invokeBlockEval).endControlFlow();\n+        builder.beginControlFlow(\"if ($LVectors[i] == null)\", name).addStatement(invokeBlockEval[0]).endControlFlow();\n         builder.endControlFlow();\n     }\n \n     @Override\n     public void createScratch(MethodSpec.Builder builder) {\n-        builder.addStatement(\"$T[] $LValues = new $T[$L.length]\", componentType, name, componentType, name);\n-        if (componentType.equals(BYTES_REF)) {\n-            builder.addStatement(\"$T[] $LScratch = new $T[$L.length]\", componentType, name, componentType, name);\n+        builder.addStatement(\"$T[] $LValues = new $T[$L.length]\", type, name, type, name);\n+        if (isBytesRef()) {\n+            builder.addStatement(\"$T[] $LScratch = new $T[$L.length]\", type, name, type, name);\n             builder.beginControlFlow(\"for (int i = 0; i < $L.length; i++)\", name);\n             builder.addStatement(\"$LScratch[i] = new $T()\", name, BYTES_REF);\n             builder.endControlFlow();\n@@ -135,10 +136,10 @@ public void read(MethodSpec.Builder builder, boolean blockStyle) {\n         } else {\n             lookupVar = \"p\";\n         }\n-        if (componentType.equals(BYTES_REF)) {\n+        if (isBytesRef()) {\n             builder.addStatement(\"$LValues[i] = $L[i].getBytesRef($L, $LScratch[i])\", name, paramName(blockStyle), lookupVar, name);\n         } else {\n-            builder.addStatement(\"$LValues[i] = $L[i].$L($L)\", name, paramName(blockStyle), getMethod(componentType), lookupVar);\n+            builder.addStatement(\"$LValues[i] = $L[i].$L($L)\", name, paramName(blockStyle), getMethod(type), lookupVar);\n         }\n         builder.endControlFlow();\n     }\ndiff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BlockArgument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BlockArgument.java\nindex 8adbd7a40c2d2..13a670224e8e4 100644\n--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BlockArgument.java\n+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BlockArgument.java\n@@ -11,6 +11,8 @@\n import com.squareup.javapoet.TypeName;\n import com.squareup.javapoet.TypeSpec;\n \n+import org.elasticsearch.compute.gen.Types;\n+\n import java.util.List;\n \n import javax.lang.model.element.Modifier;\n@@ -24,6 +26,11 @@ public TypeName dataType(boolean blockStyle) {\n         return type;\n     }\n \n+    @Override\n+    public TypeName elementType() {\n+        return Types.elementType(type());\n+    }\n+\n     @Override\n     public String paramName(boolean blockStyle) {\n         return name + \"Block\";\n@@ -67,7 +74,7 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {\n     }\n \n     @Override\n-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {\n+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {\n         // nothing to do\n     }\n \ndiff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BuilderArgument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BuilderArgument.java\nindex 4c2f335dbae66..7afaa5e89dcc6 100644\n--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BuilderArgument.java\n+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BuilderArgument.java\n@@ -62,7 +62,7 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {\n     }\n \n     @Override\n-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {\n+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {\n         // nothing to do\n     }\n \ndiff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/FixedArgument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/FixedArgument.java\nindex 2c2c24aeebd75..19d8f910bcbee 100644\n--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/FixedArgument.java\n+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/FixedArgument.java\n@@ -84,7 +84,7 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {\n     }\n \n     @Override\n-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {\n+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {\n         // nothing to do\n     }\n \ndiff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/PositionArgument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/PositionArgument.java\nindex 7f40a87c68efa..92c5b9e476917 100644\n--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/PositionArgument.java\n+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/PositionArgument.java\n@@ -16,7 +16,7 @@\n /**\n  * The position in a block.\n  */\n-public record PositionArgument() implements Argument {\n+public record PositionArgument(TypeName type, String name) implements Argument {\n     @Override\n     public TypeName dataType(boolean blockStyle) {\n         return TypeName.INT;\n@@ -64,7 +64,7 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {\n     }\n \n     @Override\n-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {\n+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {\n         // nothing to do\n     }\n \ndiff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/StandardArgument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/StandardArgument.java\nindex 217621c061e43..981e3de3f22f4 100644\n--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/StandardArgument.java\n+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/StandardArgument.java\n@@ -80,14 +80,20 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {\n     }\n \n     @Override\n-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {\n+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {\n         builder.addStatement(\"$T $LVector = $LBlock.asVector()\", vectorType(type), name, name);\n-        builder.beginControlFlow(\"if ($LVector == null)\", name).addStatement(invokeBlockEval).endControlFlow();\n+        builder.beginControlFlow(\"if ($LVector == null)\", name);\n+\n+        for (String statement : invokeBlockEval) {\n+            builder.addStatement(statement);\n+        }\n+\n+        builder.endControlFlow();\n     }\n \n     @Override\n     public void createScratch(MethodSpec.Builder builder) {\n-        if (type.equals(BYTES_REF)) {\n+        if (isBytesRef()) {\n             builder.addStatement(\"$T $LScratch = new $T()\", BYTES_REF, name, BYTES_REF);\n         }\n     }\n@@ -117,10 +123,9 @@ static boolean isBlockType(TypeName type) {\n     @Override\n     public void read(MethodSpec.Builder builder, boolean blockStyle) {\n         String params = blockStyle ? paramName(true) + \".getFirstValueIndex(p)\" : \"p\";\n-        if (type.equals(BYTES_REF)) {\n-            params += \", \" + name + \"Scratch\";\n+        if (isBytesRef()) {\n+            params += \", \" + scratchName();\n         }\n-\n         builder.addStatement(\"$T $L = $L.$L($L)\", type, name, paramName(blockStyle), getMethod(type), params);\n     }\n \ndiff --git a/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentCartesianShapeDocValuesAggregatorFunction.java b/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentCartesianShapeDocValuesAggregatorFunction.java\nindex d6568f2d7c06e..4da958d774821 100644\n--- a/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentCartesianShapeDocValuesAggregatorFunction.java\n+++ b/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentCartesianShapeDocValuesAggregatorFunction.java\n@@ -70,30 +70,12 @@ public void addRawInput(Page page, BooleanVector mask) {\n \n   private void addRawInputMasked(Page page, BooleanVector mask) {\n     IntBlock valuesBlock = page.getBlock(channels.get(0));\n-    IntVector valuesVector = valuesBlock.asVector();\n-    if (valuesVector == null) {\n-      addRawBlock(valuesBlock, mask);\n-      return;\n-    }\n-    addRawVector(valuesVector, mask);\n+    addRawBlock(valuesBlock, mask);\n   }\n \n   private void addRawInputNotMasked(Page page) {\n     IntBlock valuesBlock = page.getBlock(channels.get(0));\n-    IntVector valuesVector = valuesBlock.asVector();\n-    if (valuesVector == null) {\n-      addRawBlock(valuesBlock);\n-      return;\n-    }\n-    addRawVector(valuesVector);\n-  }\n-\n-  private void addRawVector(IntVector valuesVector) {\n-    // This type does not support vectors because all values are multi-valued\n-  }\n-\n-  private void addRawVector(IntVector valuesVector, BooleanVector mask) {\n-    // This type does not support vectors because all values are multi-valued\n+    addRawBlock(valuesBlock);\n   }\n \n   private void addRawBlock(IntBlock valuesBlock) {\ndiff --git a/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentGeoShapeDocValuesAggregatorFunction.java b/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentGeoShapeDocValuesAggregatorFunction.java\nindex e397362159356..71ab91a86241f 100644\n--- a/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentGeoShapeDocValuesAggregatorFunction.java\n+++ b/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentGeoShapeDocValuesAggregatorFunction.java\n@@ -72,30 +72,12 @@ public void addRawInput(Page page, BooleanVector mask) {\n \n   private void addRawInputMasked(Page page, BooleanVector mask) {\n     IntBlock valuesBlock = page.getBlock(channels.get(0));\n-    IntVector valuesVector = valuesBlock.asVector();\n-    if (valuesVector == null) {\n-      addRawBlock(valuesBlock, mask);\n-      return;\n-    }\n-    addRawVector(valuesVector, mask);\n+    addRawBlock(valuesBlock, mask);\n   }\n \n   private void addRawInputNotMasked(Page page) {\n     IntBlock valuesBlock = page.getBlock(channels.get(0));\n-    IntVector valuesVector = valuesBlock.asVector();\n-    if (valuesVector == null) {\n-      addRawBlock(valuesBlock);\n-      return;\n-    }\n-    addRawVector(valuesVector);\n-  }\n-\n-  private void addRawVector(IntVector valuesVector) {\n-    // This type does not support vectors because all values are multi-valued\n-  }\n-\n-  private void addRawVector(IntVector valuesVector, BooleanVector mask) {\n-    // This type does not support vectors because all values are multi-valued\n+    addRawBlock(valuesBlock);\n   }\n \n   private void addRawBlock(IntBlock valuesBlock) {\n",
  "additions": 182,
  "deletions": 131,
  "changed_files": 11,
  "url": "https://github.com/elastic/elasticsearch/pull/136419",
  "mined_at": "2025-10-25T13:35:01.273084"
}