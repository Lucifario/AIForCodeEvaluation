{
  "id": 136548,
  "repository": "elastic/elasticsearch",
  "title": "ESQL: Locale and timezone argument for date_parse",
  "body": "Fixes https://github.com/elastic/elasticsearch/issues/132487\r\n\r\n```\r\nPOST _query\r\n{\r\n  \"query\": \"\"\"\r\n    ROW date_string=\"10 septembre 2025\" | EVAL date = DATE_PARSE(\"dd MMMM yyyy\", date_string, {\"locale\": \"fr\", \"time_zone\": \"Europe/Paris\" })\r\n  \"\"\"\r\n}\r\n```\r\n\r\nreturns\r\n\r\n```\r\n   date_string   |          date\r\n-----------------+------------------------\r\n10 septembre 2025|2025-09-09T22:00:00.000Z\r\n```\r\n\r\nIn case the time zone or the locale can't be resolved, this throws an error.",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-24T13:53:13+00:00",
  "created_at": "2025-10-14T16:13:38+00:00",
  "updated_at": "2025-10-24T13:53:13+00:00",
  "author": "flash1293",
  "reviewers": [
    "flash1293",
    "ivancea",
    "nik9000"
  ],
  "base_sha": "7e9049e74cdc397431bb9203595c7434d20ffca2",
  "head_sha": "75cc23b45012611e99da61fd38e8301d0aea9e1e",
  "review_comments": [
    {
      "user": "ivancea",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-15T13:35:18+00:00"
    },
    {
      "user": "flash1293",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-15T13:44:11+00:00"
    },
    {
      "user": "ivancea",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T12:05:41+00:00"
    },
    {
      "user": "flash1293",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T12:32:45+00:00"
    },
    {
      "user": "flash1293",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T13:51:57+00:00"
    },
    {
      "user": "ivancea",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T16:04:57+00:00"
    },
    {
      "user": "flash1293",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-22T09:34:42+00:00"
    },
    {
      "user": "flash1293",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-22T10:05:24+00:00"
    },
    {
      "user": "nik9000",
      "state": "APPROVED",
      "body": "LGTM.\n\nEnjoy fighting CI.",
      "submitted_at": "2025-10-22T16:35:47+00:00"
    }
  ],
  "pr_comments": [
    {
      "user": "github-actions[bot]",
      "body": "## ‚ÑπÔ∏è Important: Docs version tagging\n\nüëã Thanks for updating the docs! Just a friendly reminder that our docs are now **cumulative**. This means all 9.x versions are documented on the same page and published off of the main branch, instead of creating separate pages for each minor version.\n\nWe use [applies_to tags](https://elastic.github.io/docs-builder/syntax/applies) to mark version-specific features and changes.\n\n<details>\n<summary>Expand for a quick overview</summary>\n\n### When to use applies_to tags:\n‚úÖ At the page level to indicate which products/deployments the content applies to (mandatory)\n‚úÖ When features change state (e.g. preview, ga) in a specific version\n‚úÖ When availability differs across deployments and environments\n\n### What NOT to do:\n‚ùå Don't remove or replace information that applies to an older version\n‚ùå Don't add new information that applies to a specific version without an applies_to tag\n‚ùå Don't forget that applies_to tags can be used at the page, section, and inline level\n</details>\n\n### ü§î Need help?\n- Check out the [cumulative docs guidelines](https://elastic.github.io/docs-builder/contribute/cumulative-docs/)\n- Reach out in the [#docs](https://elastic.slack.com/archives/C0JF80CJZ) Slack channel",
      "created_at": "2025-10-17T09:45:04+00:00"
    },
    {
      "user": "elasticsearchmachine",
      "body": "Pinging @elastic/es-analytical-engine (Team:Analytics)",
      "created_at": "2025-10-17T11:21:36+00:00"
    },
    {
      "user": "elasticsearchmachine",
      "body": "Hi @flash1293, I've created a changelog YAML for you.",
      "created_at": "2025-10-17T11:21:43+00:00"
    },
    {
      "user": "flash1293",
      "body": "Should be ready for another look",
      "created_at": "2025-10-22T10:05:39+00:00"
    },
    {
      "user": "flash1293",
      "body": " I've been trying to figure it out, but I can't make it work, I'm stuck. Happy to pair with someone. It seems like the failure test case builder is building a failure case where the third parameter is null, and it complains it's not rejected as unresolved. I think I have to add a test case for this so it's marked as valid, but I can't manage to - if I try something like\r\n\r\n```java\r\nnew TestCaseSupplier(\r\n                    List.of(DataType.KEYWORD, DataType.KEYWORD, DataType.NULL),\r\n                    () -> new TestCaseSupplier.TestCase(\r\n                        List.of(\r\n                            new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"pattern\"),\r\n                            new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"date\"),\r\n                            new TestCaseSupplier.TypedData(\r\n                                null,\r\n                                DataType.NULL,\r\n                                \"options\"\r\n                            )\r\n                        ),\r\n                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\r\n                        DataType.DATETIME,\r\n                        equalTo(1683244800000L)\r\n                    )\r\n                )\r\n```\r\n\r\nit breaks really bad and I'm not sure why. I get a bit confused with the null as in Java null pointer vs. ESQL null, something's up there and I'm not even sure what the right behavior should be - do we want to allow `date_parse(a, b, null)` or not, and depending on the answer, how do I construct the right test cases?",
      "created_at": "2025-10-22T16:23:09+00:00"
    },
    {
      "user": "flash1293",
      "body": "Test failure looks like CI instability (503), trying to rerun",
      "created_at": "2025-10-24T09:25:31+00:00"
    }
  ],
  "files_changed": [
    {
      "filename": "docs/changelog/136548.yaml",
      "status": "added",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "patch": "@@ -0,0 +1,6 @@\n+pr: 136548\n+summary: Locale and timezone argument for `date_parse`\n+area: ES|QL\n+type: enhancement\n+issues:\n+ - 132487"
    },
    {
      "filename": "docs/reference/query-languages/esql/_snippets/functions/functionNamedParams/date_parse.md",
      "status": "added",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "patch": "@@ -0,0 +1,10 @@\n+% This is generated by ESQL's AbstractFunctionTestCase. Do not edit it. See ../README.md for how to regenerate it.\n+\n+**Supported function named parameters**\n+\n+`time_zone`\n+:   (keyword) Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.\n+\n+`locale`\n+:   (keyword) The locale to use when parsing the date, relevant when parsing month names or week days.\n+"
    },
    {
      "filename": "docs/reference/query-languages/esql/_snippets/functions/layout/date_parse.md",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "patch": "@@ -19,5 +19,8 @@\n :::{include} ../types/date_parse.md\n :::\n \n+:::{include} ../functionNamedParams/date_parse.md\n+:::\n+\n :::{include} ../examples/date_parse.md\n :::"
    },
    {
      "filename": "docs/reference/query-languages/esql/_snippets/functions/parameters/date_parse.md",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "patch": "@@ -8,3 +8,6 @@\n `dateString`\n :   Date expression as a string. If `null` or an empty string, the function returns `null`.\n \n+`options`\n+:   (Optional) Additional options for date parsing, specifying time zone and locale as [function named parameters](/reference/query-languages/esql/esql-syntax.md#esql-function-named-params).\n+"
    },
    {
      "filename": "docs/reference/query-languages/esql/_snippets/functions/types/date_parse.md",
      "status": "modified",
      "additions": 7,
      "deletions": 6,
      "changes": 13,
      "patch": "@@ -2,10 +2,11 @@\n \n **Supported types**\n \n-| datePattern | dateString | result |\n-| --- | --- | --- |\n-| keyword | keyword | date |\n-| keyword | text | date |\n-| text | keyword | date |\n-| text | text | date |\n+| datePattern | dateString | options | result |\n+| --- | --- | --- | --- |\n+| keyword | keyword | named parameters | date |\n+| keyword | keyword | | date |\n+| keyword | text | | date |\n+| text | keyword | | date |\n+| text | text | | date |\n "
    },
    {
      "filename": "docs/reference/query-languages/esql/images/functions/date_parse.svg",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -1 +1 @@\n-<svg version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns=\"http://www.w3.org/2000/svg\" width=\"628\" height=\"61\" viewbox=\"0 0 628 61\"><defs><style type=\"text/css\">.c{fill:none;stroke:#222222;}.k{fill:#000000;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;font-size:20px;}.s{fill:#e4f4ff;stroke:#222222;}.syn{fill:#8D8D8D;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;font-size:20px;}</style></defs><path class=\"c\" d=\"M0 31h5m140 0h10m32 0h30m152 0h10m32 0h20m-229 0q5 0 5 5v10q0 5 5 5h204q5 0 5-5v-10q0-5 5-5m5 0h10m140 0h10m32 0h5\"/><rect class=\"s\" x=\"5\" y=\"5\" width=\"140\" height=\"36\"/><text class=\"k\" x=\"15\" y=\"31\">DATE_PARSE</text><rect class=\"s\" x=\"155\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"165\" y=\"31\">(</text><rect class=\"s\" x=\"217\" y=\"5\" width=\"152\" height=\"36\" rx=\"7\"/><text class=\"k\" x=\"227\" y=\"31\">datePattern</text><rect class=\"s\" x=\"379\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"389\" y=\"31\">,</text><rect class=\"s\" x=\"441\" y=\"5\" width=\"140\" height=\"36\" rx=\"7\"/><text class=\"k\" x=\"451\" y=\"31\">dateString</text><rect class=\"s\" x=\"591\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"601\" y=\"31\">)</text></svg>\n\\ No newline at end of file\n+<svg version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns=\"http://www.w3.org/2000/svg\" width=\"824\" height=\"61\" viewbox=\"0 0 824 61\"><defs><style type=\"text/css\">.c{fill:none;stroke:#222222;}.k{fill:#000000;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;font-size:20px;}.s{fill:#e4f4ff;stroke:#222222;}.syn{fill:#8D8D8D;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;font-size:20px;}</style></defs><path class=\"c\" d=\"M0 31h5m140 0h10m32 0h30m152 0h10m32 0h20m-229 0q5 0 5 5v10q0 5 5 5h204q5 0 5-5v-10q0-5 5-5m5 0h10m140 0h30m32 0h10m104 0h20m-181 0q5 0 5 5v10q0 5 5 5h156q5 0 5-5v-10q0-5 5-5m5 0h10m32 0h5\"/><rect class=\"s\" x=\"5\" y=\"5\" width=\"140\" height=\"36\"/><text class=\"k\" x=\"15\" y=\"31\">DATE_PARSE</text><rect class=\"s\" x=\"155\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"165\" y=\"31\">(</text><rect class=\"s\" x=\"217\" y=\"5\" width=\"152\" height=\"36\" rx=\"7\"/><text class=\"k\" x=\"227\" y=\"31\">datePattern</text><rect class=\"s\" x=\"379\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"389\" y=\"31\">,</text><rect class=\"s\" x=\"441\" y=\"5\" width=\"140\" height=\"36\" rx=\"7\"/><text class=\"k\" x=\"451\" y=\"31\">dateString</text><rect class=\"s\" x=\"611\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"621\" y=\"31\">,</text><rect class=\"s\" x=\"653\" y=\"5\" width=\"104\" height=\"36\" rx=\"7\"/><text class=\"k\" x=\"663\" y=\"31\">options</text><rect class=\"s\" x=\"787\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"797\" y=\"31\">)</text></svg>\n\\ No newline at end of file"
    },
    {
      "filename": "docs/reference/query-languages/esql/kibana/definition/functions/date_parse.json",
      "status": "modified",
      "additions": 25,
      "deletions": 0,
      "changes": 25,
      "patch": "@@ -22,6 +22,31 @@\n       \"variadic\" : false,\n       \"returnType\" : \"date\"\n     },\n+    {\n+      \"params\" : [\n+        {\n+          \"name\" : \"datePattern\",\n+          \"type\" : \"keyword\",\n+          \"optional\" : true,\n+          \"description\" : \"The date format. Refer to the {javadoc14}/java.base/java/time/format/DateTimeFormatter.html[`DateTimeFormatter` documentation] for the syntax. If `null`, the function returns `null`.\"\n+        },\n+        {\n+          \"name\" : \"dateString\",\n+          \"type\" : \"keyword\",\n+          \"optional\" : false,\n+          \"description\" : \"Date expression as a string. If `null` or an empty string, the function returns `null`.\"\n+        },\n+        {\n+          \"name\" : \"options\",\n+          \"type\" : \"function_named_parameters\",\n+          \"mapParams\" : \"{name='time_zone', values=[standard], description='Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.'}, {name='locale', values=[standard], description='The locale to use when parsing the date, relevant when parsing month names or week days.'}\",\n+          \"optional\" : true,\n+          \"description\" : \"(Optional) Additional options for date parsing, specifying time zone and locale as <<esql-function-named-params,function named parameters>>.\"\n+        }\n+      ],\n+      \"variadic\" : false,\n+      \"returnType\" : \"date\"\n+    },\n     {\n       \"params\" : [\n         {"
    },
    {
      "filename": "x-pack/plugin/esql/qa/testFixtures/src/main/resources/date.csv-spec",
      "status": "modified",
      "additions": 40,
      "deletions": 0,
      "changes": 40,
      "patch": "@@ -644,6 +644,46 @@ emp_no:integer  | new_date:datetime          | birth_date:datetime       | bool:\n 10050           | 1958-05-21T00:00:00.000Z   | 1958-05-21T00:00:00.000Z  | true\n ;\n \n+evalDateParseWithTimezoneOption\n+required_capability: date_parse_options\n+row a = \"10-10-2025\" | eval b = date_parse(\"dd-mm-yyyy\", a, {\"time_zone\":\"Europe/Paris\"}) | keep b;\n+\n+b:datetime\n+2024-12-31T23:00:00.000Z\n+;\n+\n+evalDateParseWithLocaleOption\n+required_capability: date_parse_options\n+row a = \"10 septembre 2025\" | eval b = date_parse(\"dd MMMM yyyy\", a, {\"locale\":\"fr\"}) | keep b;\n+\n+b:datetime\n+2025-09-10T00:00:00.000Z\n+;\n+\n+evalDateParseWithLocaleAndTimezoneOption\n+required_capability: date_parse_options\n+row a = \"10 septembre 2025\" | eval b = date_parse(\"dd MMMM yyyy\", a, {\"locale\":\"fr\",\"time_zone\":\"Europe/Paris\"}) | keep b;\n+\n+b:datetime\n+2025-09-09T22:00:00.000Z\n+;\n+\n+evalDateParseDefaultFormatWithTimezoneOption\n+required_capability: date_parse_options\n+row a = \"2023-02-01T12:15:55.000+01:00\" | eval b = date_parse(a, {\"time_zone\":\"Europe/Paris\"}) | keep b;\n+\n+b:datetime\n+2023-02-01T11:15:55.000Z\n+;\n+\n+evalDateParseDefaultFormatWithLocaleOption\n+required_capability: date_parse_options\n+row a = \"2023-02-01T12:15:55.000Z\" | eval b = date_parse(a, {\"locale\":\"fr\"}) | keep b;\n+\n+b:datetime\n+2023-02-01T12:15:55.000Z\n+;\n+\n dateFields\n from employees | where emp_no == 10049 or emp_no == 10050 \n | eval year = date_extract(\"year\", birth_date), month = date_extract(\"month_of_year\", birth_date), day = date_extract(\"day_of_month\", birth_date)"
    },
    {
      "filename": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "patch": "@@ -1532,6 +1532,11 @@ public enum Cap {\n          */\n         FIX_FILTER_ORDINALS,\n \n+        /**\n+         * Optional options argument for DATE_PARSE\n+         */\n+        DATE_PARSE_OPTIONS,\n+\n         /**\n          * Allow multiple patterns for GROK command\n          */"
    },
    {
      "filename": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/EsqlFunctionRegistry.java",
      "status": "modified",
      "additions": 11,
      "deletions": 3,
      "changes": 14,
      "patch": "@@ -1042,12 +1042,20 @@ public interface BinaryBuilder<T> {\n     protected static <T extends Function> FunctionDefinition def(Class<T> function, TernaryBuilder<T> ctorRef, String... names) {\n         FunctionBuilder builder = (source, children, cfg) -> {\n             boolean hasMinimumTwo = OptionalArgument.class.isAssignableFrom(function);\n-            if (hasMinimumTwo && (children.size() > 3 || children.size() < 2)) {\n+            boolean hasMinimumOne = TwoOptionalArguments.class.isAssignableFrom(function);\n+            if (hasMinimumOne && (children.size() > 3 || children.isEmpty())) {\n+                throw new QlIllegalArgumentException(\"expects one, two or three arguments\");\n+            } else if (hasMinimumTwo && (children.size() > 3 || children.size() < 2)) {\n                 throw new QlIllegalArgumentException(\"expects two or three arguments\");\n-            } else if (hasMinimumTwo == false && children.size() != 3) {\n+            } else if (hasMinimumOne == false && hasMinimumTwo == false && children.size() != 3) {\n                 throw new QlIllegalArgumentException(\"expects exactly three arguments\");\n             }\n-            return ctorRef.build(source, children.get(0), children.get(1), children.size() == 3 ? children.get(2) : null);\n+            return ctorRef.build(\n+                source,\n+                children.get(0),\n+                children.size() > 1 ? children.get(1) : null,\n+                children.size() == 3 ? children.get(2) : null\n+            );\n         };\n         return def(function, builder, names);\n     }"
    },
    {
      "filename": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParse.java",
      "status": "modified",
      "additions": 152,
      "deletions": 11,
      "changes": 163,
      "patch": "@@ -12,41 +12,59 @@\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.common.time.DateFormatter;\n+import org.elasticsearch.common.util.LocaleUtils;\n import org.elasticsearch.compute.ann.Evaluator;\n import org.elasticsearch.compute.ann.Fixed;\n import org.elasticsearch.compute.operator.EvalOperator.ExpressionEvaluator;\n import org.elasticsearch.xpack.esql.core.InvalidArgumentException;\n import org.elasticsearch.xpack.esql.core.expression.Expression;\n+import org.elasticsearch.xpack.esql.core.expression.MapExpression;\n import org.elasticsearch.xpack.esql.core.tree.NodeInfo;\n import org.elasticsearch.xpack.esql.core.tree.Source;\n import org.elasticsearch.xpack.esql.core.type.DataType;\n import org.elasticsearch.xpack.esql.expression.function.Example;\n import org.elasticsearch.xpack.esql.expression.function.FunctionInfo;\n-import org.elasticsearch.xpack.esql.expression.function.OptionalArgument;\n+import org.elasticsearch.xpack.esql.expression.function.MapParam;\n+import org.elasticsearch.xpack.esql.expression.function.Options;\n import org.elasticsearch.xpack.esql.expression.function.Param;\n+import org.elasticsearch.xpack.esql.expression.function.TwoOptionalArguments;\n import org.elasticsearch.xpack.esql.expression.function.scalar.EsqlScalarFunction;\n import org.elasticsearch.xpack.esql.io.stream.PlanStreamInput;\n \n import java.io.IOException;\n+import java.time.ZoneId;\n+import java.time.zone.ZoneRulesException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n \n+import static java.util.Map.entry;\n import static org.elasticsearch.common.time.DateFormatter.forPattern;\n import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.ParamOrdinal.FIRST;\n import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.ParamOrdinal.SECOND;\n+import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.ParamOrdinal.THIRD;\n+import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.isMapExpression;\n import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.esql.core.type.DataType.KEYWORD;\n import static org.elasticsearch.xpack.esql.expression.EsqlTypeResolutions.isStringAndExact;\n import static org.elasticsearch.xpack.esql.type.EsqlDataTypeConverter.DEFAULT_DATE_TIME_FORMATTER;\n import static org.elasticsearch.xpack.esql.type.EsqlDataTypeConverter.dateTimeToLong;\n \n-public class DateParse extends EsqlScalarFunction implements OptionalArgument {\n+public class DateParse extends EsqlScalarFunction implements TwoOptionalArguments {\n     public static final NamedWriteableRegistry.Entry ENTRY = new NamedWriteableRegistry.Entry(\n         Expression.class,\n         \"DateParse\",\n         DateParse::new\n     );\n \n-    private final Expression field;\n-    private final Expression format;\n+    private static final String TIME_ZONE_PARAM_NAME = \"time_zone\";\n+    private static final String LOCALE_PARAM_NAME = \"locale\";\n+\n+    private final Expression first;\n+    private final Expression second;\n+    private final Expression third;\n \n     @FunctionInfo(\n         returnType = \"date\",\n@@ -63,17 +81,80 @@ public DateParse(\n             name = \"dateString\",\n             type = { \"keyword\", \"text\" },\n             description = \"Date expression as a string. If `null` or an empty string, the function returns `null`.\"\n-        ) Expression second\n+        ) Expression second,\n+        @MapParam(\n+            name = \"options\",\n+            params = {\n+                @MapParam.MapParamEntry(\n+                    name = TIME_ZONE_PARAM_NAME,\n+                    type = \"keyword\",\n+                    valueHint = { \"standard\" },\n+                    description = \"Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the \"\n+                        + \"query string to UTC.\"\n+                ),\n+                @MapParam.MapParamEntry(\n+                    name = LOCALE_PARAM_NAME,\n+                    type = \"keyword\",\n+                    valueHint = { \"standard\" },\n+                    description = \"The locale to use when parsing the date, relevant when parsing month names or week days.\"\n+                ) },\n+            description = \"(Optional) Additional options for date parsing, specifying time zone and locale \"\n+                + \"as <<esql-function-named-params,function named parameters>>.\",\n+            optional = true\n+        ) Expression third\n     ) {\n-        super(source, second != null ? List.of(first, second) : List.of(first));\n-        this.field = second != null ? second : first;\n-        this.format = second != null ? first : null;\n+        super(source, fields(first, second, third));\n+        this.first = first;\n+        this.second = second;\n+        this.third = third;\n+    }\n+\n+    private static List<Expression> fields(Expression first, Expression second, Expression third) {\n+        List<Expression> list = new ArrayList<>(3);\n+        list.add(first);\n+        if (second != null) {\n+            list.add(second);\n+        }\n+        if (third != null) {\n+            list.add(third);\n+        }\n+        return list;\n+    }\n+\n+    private Expression field() {\n+        // If second is a MapExpression, then: first=date, second=options, third=null\n+        // If second is not a MapExpression and second exists, then: first=pattern, second=date, third=options\n+        // If only first exists, then: first=date, second=null, third=null\n+        if (second instanceof MapExpression) {\n+            return first;\n+        }\n+        return second != null ? second : first;\n+    }\n+\n+    private Expression format() {\n+        // If second is a MapExpression, then: first=date, second=options, third=null (no format)\n+        // If second is not a MapExpression and second exists, then: first=pattern, second=date, third=options\n+        // If only first exists, then: first=date, second=null, third=null (no format)\n+        if (second instanceof MapExpression || second == null) {\n+            return null;\n+        }\n+        return first;\n+    }\n+\n+    private Expression options() {\n+        // If second is a MapExpression, then: first=date, second=options, third=null\n+        // If second is not a MapExpression and third exists, then: first=pattern, second=date, third=options\n+        if (second instanceof MapExpression) {\n+            return second;\n+        }\n+        return third;\n     }\n \n     private DateParse(StreamInput in) throws IOException {\n         this(\n             Source.readFrom((PlanStreamInput) in),\n             in.readNamedWriteable(Expression.class),\n+            in.readOptionalNamedWriteable(Expression.class),\n             in.readOptionalNamedWriteable(Expression.class)\n         );\n     }\n@@ -82,7 +163,8 @@ private DateParse(StreamInput in) throws IOException {\n     public void writeTo(StreamOutput out) throws IOException {\n         source().writeTo(out);\n         out.writeNamedWriteable(children().get(0));\n-        out.writeOptionalNamedWriteable(children().size() == 2 ? children().get(1) : null);\n+        out.writeOptionalNamedWriteable(children().size() > 1 ? children().get(1) : null);\n+        out.writeOptionalNamedWriteable(children().size() > 2 ? children().get(2) : null);\n     }\n \n     @Override\n@@ -102,23 +184,36 @@ protected TypeResolution resolveType() {\n         }\n \n         TypeResolution resolution;\n+        Expression format = format();\n         if (format != null) {\n             resolution = isStringAndExact(format, sourceText(), FIRST);\n             if (resolution.unresolved()) {\n                 return resolution;\n             }\n         }\n \n+        Expression field = field();\n         resolution = isString(field, sourceText(), format != null ? SECOND : FIRST);\n         if (resolution.unresolved()) {\n             return resolution;\n         }\n \n+        // Validate options parameter if present\n+        Expression options = options();\n+        if (options != null) {\n+            resolution = isMapExpression(options, sourceText(), THIRD);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+\n         return TypeResolution.TYPE_RESOLVED;\n     }\n \n     @Override\n     public boolean foldable() {\n+        Expression field = field();\n+        Expression format = format();\n         return field.foldable() && (format == null || format.foldable());\n     }\n \n@@ -132,18 +227,56 @@ static long process(BytesRef val, BytesRef formatter) throws IllegalArgumentExce\n         return dateTimeToLong(val.utf8ToString(), toFormatter(formatter));\n     }\n \n+    public static final Map<String, DataType> ALLOWED_OPTIONS = Map.ofEntries(\n+        entry(TIME_ZONE_PARAM_NAME, KEYWORD),\n+        entry(LOCALE_PARAM_NAME, KEYWORD)\n+    );\n+\n+    private Map<String, Object> parseOptions() throws InvalidArgumentException {\n+        Map<String, Object> matchOptions = new HashMap<>();\n+        Expression options = options();\n+        if (options == null) {\n+            return matchOptions;\n+        }\n+\n+        Options.populateMap((MapExpression) options, matchOptions, source(), THIRD, ALLOWED_OPTIONS);\n+        return matchOptions;\n+    }\n+\n     @Override\n     public ExpressionEvaluator.Factory toEvaluator(ToEvaluator toEvaluator) {\n+        Expression field = field();\n+        Expression format = format();\n         ExpressionEvaluator.Factory fieldEvaluator = toEvaluator.apply(field);\n         if (format == null) {\n             return new DateParseConstantEvaluator.Factory(source(), fieldEvaluator, DEFAULT_DATE_TIME_FORMATTER);\n         }\n         if (DataType.isString(format.dataType()) == false) {\n             throw new IllegalArgumentException(\"unsupported data type for date_parse [\" + format.dataType() + \"]\");\n         }\n+        var parsedOptions = this.parseOptions();\n+        String localeAsString = (String) parsedOptions.get(LOCALE_PARAM_NAME);\n+        Locale locale = localeAsString == null ? null : LocaleUtils.parse(localeAsString);\n+\n+        String timezoneAsString = (String) parsedOptions.get(TIME_ZONE_PARAM_NAME);\n+        ZoneId timezone = null;\n+        try {\n+            if (timezoneAsString != null) {\n+                timezone = ZoneId.of(timezoneAsString);\n+            }\n+        } catch (ZoneRulesException e) {\n+            throw new IllegalArgumentException(\"unsupported timezone [\" + timezoneAsString + \"]\");\n+        }\n+\n         if (format.foldable()) {\n             try {\n                 DateFormatter formatter = toFormatter(format.fold(toEvaluator.foldCtx()));\n+                if (locale != null) {\n+                    formatter = formatter.withLocale(locale);\n+                }\n+                if (timezone != null) {\n+                    formatter = formatter.withZone(timezone);\n+                }\n                 return new DateParseConstantEvaluator.Factory(source(), fieldEvaluator, formatter);\n             } catch (IllegalArgumentException e) {\n                 throw new InvalidArgumentException(e, \"invalid date pattern for [{}]: {}\", sourceText(), e.getMessage());\n@@ -159,13 +292,21 @@ private static DateFormatter toFormatter(Object format) {\n \n     @Override\n     public Expression replaceChildren(List<Expression> newChildren) {\n-        return new DateParse(source(), newChildren.get(0), newChildren.size() > 1 ? newChildren.get(1) : null);\n+        return new DateParse(\n+            source(),\n+            newChildren.get(0),\n+            newChildren.size() > 1 ? newChildren.get(1) : null,\n+            newChildren.size() > 2 ? newChildren.get(2) : null\n+        );\n     }\n \n     @Override\n     protected NodeInfo<? extends Expression> info() {\n+        Expression format = format();\n+        Expression field = field();\n+        Expression options = options();\n         Expression first = format != null ? format : field;\n         Expression second = format != null ? field : null;\n-        return NodeInfo.create(this, DateParse::new, first, second);\n+        return NodeInfo.create(this, DateParse::new, first, second, options);\n     }\n }"
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseErrorTests.java",
      "status": "modified",
      "additions": 20,
      "deletions": 1,
      "changes": 21,
      "patch": "@@ -15,8 +15,10 @@\n import org.hamcrest.Matcher;\n \n import java.util.List;\n+import java.util.Locale;\n import java.util.Set;\n \n+import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.ParamOrdinal;\n import static org.hamcrest.Matchers.equalTo;\n \n public class DateParseErrorTests extends ErrorsForCasesWithoutExamplesTestCase {\n@@ -27,11 +29,28 @@ protected List<TestCaseSupplier> cases() {\n \n     @Override\n     protected Expression build(Source source, List<Expression> args) {\n-        return new DateParse(source, args.get(0), args.size() > 1 ? args.get(1) : null);\n+        return new DateParse(source, args.get(0), args.size() > 1 ? args.get(1) : null, args.size() > 2 ? args.get(2) : null);\n     }\n \n     @Override\n     protected Matcher<String> expectedTypeErrorMatcher(List<Set<DataType>> validPerPosition, List<DataType> signature) {\n+        // Need custom matchers for the MapExpression case\n+        if (signature.size() == 3 && validPerPosition.size() >= 3) {\n+            boolean firstParamValid = validPerPosition.get(0).isEmpty() == false\n+                && (signature.get(0) == null || validPerPosition.get(0).contains(signature.get(0)));\n+            boolean secondParamValid = validPerPosition.get(1).isEmpty() == false\n+                && (signature.get(1) == null || validPerPosition.get(1).contains(signature.get(1)));\n+\n+            boolean thirdParamInvalid = validPerPosition.get(2).isEmpty()\n+                || signature.get(2) == DataType.NULL\n+                || (validPerPosition.get(2).contains(signature.get(2)) == false && signature.get(2) != null);\n+\n+            if (firstParamValid && secondParamValid && thirdParamInvalid) {\n+                String ordinal = ParamOrdinal.THIRD.name().toLowerCase(Locale.ROOT);\n+                return equalTo(ordinal + \" argument of [\" + sourceForSignature(signature) + \"] must be a map expression, received []\");\n+            }\n+        }\n+\n         return equalTo(typeErrorMessage(true, validPerPosition, signature, (v, i) -> \"string\"));\n     }\n }"
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseSerializationTests.java",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "patch": "@@ -19,19 +19,21 @@ protected DateParse createTestInstance() {\n         Source source = randomSource();\n         Expression first = randomChild();\n         Expression second = randomBoolean() ? null : randomChild();\n-        return new DateParse(source, first, second);\n+        Expression third = randomBoolean() ? randomChild() : null;\n+        return new DateParse(source, first, second, third);\n     }\n \n     @Override\n     protected DateParse mutateInstance(DateParse instance) throws IOException {\n         Source source = instance.source();\n         Expression first = instance.children().get(0);\n-        Expression second = instance.children().size() == 1 ? null : instance.children().get(1);\n-        if (randomBoolean()) {\n-            first = randomValueOtherThan(first, AbstractExpressionSerializationTests::randomChild);\n-        } else {\n-            second = randomValueOtherThan(second, () -> randomBoolean() ? null : randomChild());\n+        Expression second = instance.children().size() > 1 ? instance.children().get(1) : null;\n+        Expression third = instance.children().size() > 2 ? instance.children().get(2) : null;\n+        switch (between(0, 2)) {\n+            case 0 -> first = randomValueOtherThan(first, AbstractExpressionSerializationTests::randomChild);\n+            case 1 -> second = randomValueOtherThan(second, () -> randomBoolean() ? null : randomChild());\n+            case 2 -> third = randomValueOtherThan(third, () -> randomBoolean() ? null : randomChild());\n         }\n-        return new DateParse(source, first, second);\n+        return new DateParse(source, first, second, third);\n     }\n }"
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseTests.java",
      "status": "modified",
      "additions": 189,
      "deletions": 105,
      "changes": 294,
      "patch": "@@ -15,11 +15,13 @@\n import org.elasticsearch.xpack.esql.core.InvalidArgumentException;\n import org.elasticsearch.xpack.esql.core.expression.Expression;\n import org.elasticsearch.xpack.esql.core.expression.Literal;\n+import org.elasticsearch.xpack.esql.core.expression.MapExpression;\n import org.elasticsearch.xpack.esql.core.tree.Source;\n import org.elasticsearch.xpack.esql.core.type.DataType;\n import org.elasticsearch.xpack.esql.expression.function.AbstractScalarFunctionTestCase;\n import org.elasticsearch.xpack.esql.expression.function.TestCaseSupplier;\n \n+import java.util.ArrayList;\n import java.util.List;\n import java.util.Locale;\n import java.util.function.Supplier;\n@@ -36,115 +38,148 @@ public DateParseTests(@Name(\"TestCase\") Supplier<TestCaseSupplier.TestCase> test\n \n     @ParametersFactory\n     public static Iterable<Object[]> parameters() {\n-        return parameterSuppliersFromTypedDataWithDefaultChecks(\n-            true,\n-            List.of(\n-                new TestCaseSupplier(\n-                    \"Basic Case\",\n-                    List.of(DataType.KEYWORD, DataType.KEYWORD),\n-                    () -> new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"second\")\n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        equalTo(1683244800000L)\n-                    )\n-                ),\n-                new TestCaseSupplier(\"Timezoned Case\", List.of(DataType.KEYWORD, DataType.KEYWORD), () -> {\n-                    long ts_sec = 1657585450L; // 2022-07-12T00:24:10Z\n-                    int hours = randomIntBetween(0, 23);\n-                    String date = String.format(Locale.ROOT, \"12/Jul/2022:%02d:24:10 +0900\", hours);\n-                    long expected_ts = (ts_sec + (hours - 9) * 3600L) * 1000L;\n-                    return new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"dd/MMM/yyyy:HH:mm:ss Z\"), DataType.KEYWORD, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(date), DataType.KEYWORD, \"second\")\n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        equalTo(expected_ts)\n-                    );\n-                }),\n-                new TestCaseSupplier(\n-                    \"With Text\",\n-                    List.of(DataType.KEYWORD, DataType.TEXT),\n-                    () -> new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.TEXT, \"second\")\n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        equalTo(1683244800000L)\n-                    )\n-                ),\n-                new TestCaseSupplier(\n-                    \"With Both Text\",\n-                    List.of(DataType.TEXT, DataType.TEXT),\n-                    () -> new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.TEXT, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.TEXT, \"second\")\n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        equalTo(1683244800000L)\n-                    )\n-                ),\n-                new TestCaseSupplier(\n-                    \"With keyword\",\n-                    List.of(DataType.TEXT, DataType.KEYWORD),\n-                    () -> new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.TEXT, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"second\")\n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        equalTo(1683244800000L)\n-                    )\n+        List<TestCaseSupplier> cases = new ArrayList<>();\n+        cases.add(\n+            new TestCaseSupplier(\n+                \"Basic Case\",\n+                List.of(DataType.KEYWORD, DataType.KEYWORD),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"first\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"second\")\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    equalTo(1683244800000L)\n+                )\n+            )\n+        );\n+        cases.add(new TestCaseSupplier(\"Timezoned Case\", List.of(DataType.KEYWORD, DataType.KEYWORD), () -> {\n+            long ts_sec = 1657585450L; // 2022-07-12T00:24:10Z\n+            int hours = randomIntBetween(0, 23);\n+            String date = String.format(Locale.ROOT, \"12/Jul/2022:%02d:24:10 +0900\", hours);\n+            long expected_ts = (ts_sec + (hours - 9) * 3600L) * 1000L;\n+            return new TestCaseSupplier.TestCase(\n+                List.of(\n+                    new TestCaseSupplier.TypedData(new BytesRef(\"dd/MMM/yyyy:HH:mm:ss Z\"), DataType.KEYWORD, \"first\"),\n+                    new TestCaseSupplier.TypedData(new BytesRef(date), DataType.KEYWORD, \"second\")\n                 ),\n-                new TestCaseSupplier(\n-                    List.of(DataType.KEYWORD, DataType.KEYWORD),\n-                    () -> new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"not a format\"), DataType.KEYWORD, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"second\")\n+                \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                DataType.DATETIME,\n+                equalTo(expected_ts)\n+            );\n+        }));\n+        cases.add(\n+            new TestCaseSupplier(\n+                \"With Text\",\n+                List.of(DataType.KEYWORD, DataType.TEXT),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"first\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.TEXT, \"second\")\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    equalTo(1683244800000L)\n+                )\n+            )\n+        );\n+        cases.add(\n+            new TestCaseSupplier(\n+                \"With Both Text\",\n+                List.of(DataType.TEXT, DataType.TEXT),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.TEXT, \"first\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.TEXT, \"second\")\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    equalTo(1683244800000L)\n+                )\n+            )\n+        );\n+        cases.add(\n+            new TestCaseSupplier(\n+                \"With keyword\",\n+                List.of(DataType.TEXT, DataType.KEYWORD),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.TEXT, \"first\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"second\")\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    equalTo(1683244800000L)\n+                )\n+            )\n+        );\n+        cases.add(\n+            new TestCaseSupplier(\n+                List.of(DataType.KEYWORD, DataType.KEYWORD),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"not a format\"), DataType.KEYWORD, \"first\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"second\")\n \n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        is(nullValue())\n-                    ).withWarning(\"Line 1:1: evaluation of [source] failed, treating result as null. Only first 20 failures recorded.\")\n-                        .withWarning(\n-                            \"Line 1:1: java.lang.IllegalArgumentException: Invalid format: [not a format]: Unknown pattern letter: o\"\n-                        )\n-                        .withFoldingException(\n-                            InvalidArgumentException.class,\n-                            \"invalid date pattern for [source]: Invalid format: [not a format]: Unknown pattern letter: o\"\n-                        )\n-                ),\n-                new TestCaseSupplier(\n-                    List.of(DataType.KEYWORD, DataType.KEYWORD),\n-                    () -> new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"not a date\"), DataType.KEYWORD, \"second\")\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    is(nullValue())\n+                ).withWarning(\"Line 1:1: evaluation of [source] failed, treating result as null. Only first 20 failures recorded.\")\n+                    .withWarning(\"Line 1:1: java.lang.IllegalArgumentException: Invalid format: [not a format]: Unknown pattern letter: o\")\n+                    .withFoldingException(\n+                        InvalidArgumentException.class,\n+                        \"invalid date pattern for [source]: Invalid format: [not a format]: Unknown pattern letter: o\"\n+                    )\n+            )\n+        );\n+        cases.add(\n+            new TestCaseSupplier(\n+                List.of(DataType.KEYWORD, DataType.KEYWORD),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"first\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"not a date\"), DataType.KEYWORD, \"second\")\n \n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        is(nullValue())\n-                    ).withWarning(\"Line 1:1: evaluation of [source] failed, treating result as null. Only first 20 failures recorded.\")\n-                        .withWarning(\n-                            \"Line 1:1: java.lang.IllegalArgumentException: \"\n-                                + \"failed to parse date field [not a date] with format [yyyy-MM-dd]\"\n-                        )\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    is(nullValue())\n+                ).withWarning(\"Line 1:1: evaluation of [source] failed, treating result as null. Only first 20 failures recorded.\")\n+                    .withWarning(\n+                        \"Line 1:1: java.lang.IllegalArgumentException: \"\n+                            + \"failed to parse date field [not a date] with format [yyyy-MM-dd]\"\n+                    )\n+            )\n+        );\n+        cases = anyNullIsNull(true, cases);\n+        cases.add(\n+            new TestCaseSupplier(\n+                List.of(DataType.KEYWORD, DataType.KEYWORD, DataType.OBJECT),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"pattern\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"date\"),\n+                        new TestCaseSupplier.TypedData(\n+                            new MapExpression(\n+                                Source.EMPTY,\n+                                List.of(\n+                                    new Literal(Source.EMPTY, new BytesRef(\"time_zone\"), DataType.KEYWORD),\n+                                    new Literal(Source.EMPTY, new BytesRef(\"UTC\"), DataType.KEYWORD)\n+                                )\n+                            ),\n+                            DataType.OBJECT,\n+                            \"options\"\n+                        ).forceLiteral()\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    equalTo(1683244800000L)\n                 )\n             )\n         );\n+        return parameterSuppliersFromTypedData(randomizeBytesRefsOffset(cases));\n     }\n \n     public void testInvalidPattern() {\n@@ -156,15 +191,64 @@ public void testInvalidPattern() {\n                 new DateParse(\n                     Source.EMPTY,\n                     new Literal(Source.EMPTY, new BytesRef(pattern), DataType.KEYWORD),\n-                    field(\"str\", DataType.KEYWORD)\n+                    field(\"str\", DataType.KEYWORD),\n+                    null\n                 )\n             ).get(driverContext)\n         );\n         assertThat(e.getMessage(), startsWith(\"invalid date pattern for []: Invalid format: [\" + pattern + \"]\"));\n     }\n \n+    public void testInvalidLocale() {\n+        String pattern = \"YYYY\";\n+        String locale = \"nonexistinglocale\";\n+        DriverContext driverContext = driverContext();\n+        IllegalArgumentException e = expectThrows(\n+            IllegalArgumentException.class,\n+            () -> evaluator(\n+                new DateParse(\n+                    Source.EMPTY,\n+                    new Literal(Source.EMPTY, new BytesRef(pattern), DataType.KEYWORD),\n+                    field(\"str\", DataType.KEYWORD),\n+                    new MapExpression(\n+                        Source.EMPTY,\n+                        List.of(\n+                            new Literal(Source.EMPTY, new BytesRef(\"locale\"), DataType.KEYWORD),\n+                            new Literal(Source.EMPTY, new BytesRef(locale), DataType.KEYWORD)\n+                        )\n+                    )\n+                )\n+            ).get(driverContext)\n+        );\n+        assertThat(e.getMessage(), startsWith(\"Unknown language: \" + locale));\n+    }\n+\n+    public void testInvalidTimezone() {\n+        String pattern = \"YYYY\";\n+        String timezone = \"NON-EXISTING-TIMEZONE\";\n+        DriverContext driverContext = driverContext();\n+        IllegalArgumentException e = expectThrows(\n+            IllegalArgumentException.class,\n+            () -> evaluator(\n+                new DateParse(\n+                    Source.EMPTY,\n+                    new Literal(Source.EMPTY, new BytesRef(pattern), DataType.KEYWORD),\n+                    field(\"str\", DataType.KEYWORD),\n+                    new MapExpression(\n+                        Source.EMPTY,\n+                        List.of(\n+                            new Literal(Source.EMPTY, new BytesRef(\"time_zone\"), DataType.KEYWORD),\n+                            new Literal(Source.EMPTY, new BytesRef(timezone), DataType.KEYWORD)\n+                        )\n+                    )\n+                )\n+            ).get(driverContext)\n+        );\n+        assertThat(e.getMessage(), startsWith(\"unsupported timezone [\" + timezone + \"]\"));\n+    }\n+\n     @Override\n     protected Expression build(Source source, List<Expression> args) {\n-        return new DateParse(source, args.get(0), args.size() > 1 ? args.get(1) : null);\n+        return new DateParse(source, args.get(0), args.size() > 1 ? args.get(1) : null, args.size() == 3 ? args.get(2) : null);\n     }\n }"
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/FoldNullTests.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -97,7 +97,7 @@ public void testBasicNullFolding() {\n         assertNullLiteral(foldNull(new Round(EMPTY, Literal.NULL, null)));\n         assertNullLiteral(foldNull(new Pow(EMPTY, Literal.NULL, Literal.NULL)));\n         assertNullLiteral(foldNull(new DateFormat(EMPTY, Literal.NULL, Literal.NULL, null)));\n-        assertNullLiteral(foldNull(new DateParse(EMPTY, Literal.NULL, Literal.NULL)));\n+        assertNullLiteral(foldNull(new DateParse(EMPTY, Literal.NULL, Literal.NULL, NULL)));\n         assertNullLiteral(foldNull(new DateTrunc(EMPTY, Literal.NULL, Literal.NULL)));\n         assertNullLiteral(foldNull(new Substring(EMPTY, Literal.NULL, Literal.NULL, Literal.NULL)));\n     }"
    }
  ],
  "diff": "diff --git a/docs/changelog/136548.yaml b/docs/changelog/136548.yaml\nnew file mode 100644\nindex 0000000000000..1c360c8e3cb49\n--- /dev/null\n+++ b/docs/changelog/136548.yaml\n@@ -0,0 +1,6 @@\n+pr: 136548\n+summary: Locale and timezone argument for `date_parse`\n+area: ES|QL\n+type: enhancement\n+issues:\n+ - 132487\ndiff --git a/docs/reference/query-languages/esql/_snippets/functions/functionNamedParams/date_parse.md b/docs/reference/query-languages/esql/_snippets/functions/functionNamedParams/date_parse.md\nnew file mode 100644\nindex 0000000000000..328494ce830d3\n--- /dev/null\n+++ b/docs/reference/query-languages/esql/_snippets/functions/functionNamedParams/date_parse.md\n@@ -0,0 +1,10 @@\n+% This is generated by ESQL's AbstractFunctionTestCase. Do not edit it. See ../README.md for how to regenerate it.\n+\n+**Supported function named parameters**\n+\n+`time_zone`\n+:   (keyword) Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.\n+\n+`locale`\n+:   (keyword) The locale to use when parsing the date, relevant when parsing month names or week days.\n+\ndiff --git a/docs/reference/query-languages/esql/_snippets/functions/layout/date_parse.md b/docs/reference/query-languages/esql/_snippets/functions/layout/date_parse.md\nindex 4ac4734ef823b..f9c3d45b01c6d 100644\n--- a/docs/reference/query-languages/esql/_snippets/functions/layout/date_parse.md\n+++ b/docs/reference/query-languages/esql/_snippets/functions/layout/date_parse.md\n@@ -19,5 +19,8 @@\n :::{include} ../types/date_parse.md\n :::\n \n+:::{include} ../functionNamedParams/date_parse.md\n+:::\n+\n :::{include} ../examples/date_parse.md\n :::\ndiff --git a/docs/reference/query-languages/esql/_snippets/functions/parameters/date_parse.md b/docs/reference/query-languages/esql/_snippets/functions/parameters/date_parse.md\nindex adc0a0c86b19d..b10bec180329c 100644\n--- a/docs/reference/query-languages/esql/_snippets/functions/parameters/date_parse.md\n+++ b/docs/reference/query-languages/esql/_snippets/functions/parameters/date_parse.md\n@@ -8,3 +8,6 @@\n `dateString`\n :   Date expression as a string. If `null` or an empty string, the function returns `null`.\n \n+`options`\n+:   (Optional) Additional options for date parsing, specifying time zone and locale as [function named parameters](/reference/query-languages/esql/esql-syntax.md#esql-function-named-params).\n+\ndiff --git a/docs/reference/query-languages/esql/_snippets/functions/types/date_parse.md b/docs/reference/query-languages/esql/_snippets/functions/types/date_parse.md\nindex 4f1873cd3796b..41836f67f152c 100644\n--- a/docs/reference/query-languages/esql/_snippets/functions/types/date_parse.md\n+++ b/docs/reference/query-languages/esql/_snippets/functions/types/date_parse.md\n@@ -2,10 +2,11 @@\n \n **Supported types**\n \n-| datePattern | dateString | result |\n-| --- | --- | --- |\n-| keyword | keyword | date |\n-| keyword | text | date |\n-| text | keyword | date |\n-| text | text | date |\n+| datePattern | dateString | options | result |\n+| --- | --- | --- | --- |\n+| keyword | keyword | named parameters | date |\n+| keyword | keyword | | date |\n+| keyword | text | | date |\n+| text | keyword | | date |\n+| text | text | | date |\n \ndiff --git a/docs/reference/query-languages/esql/images/functions/date_parse.svg b/docs/reference/query-languages/esql/images/functions/date_parse.svg\nindex 0f5e5f624143a..4a16582db66f8 100644\n--- a/docs/reference/query-languages/esql/images/functions/date_parse.svg\n+++ b/docs/reference/query-languages/esql/images/functions/date_parse.svg\n@@ -1 +1 @@\n-<svg version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns=\"http://www.w3.org/2000/svg\" width=\"628\" height=\"61\" viewbox=\"0 0 628 61\"><defs><style type=\"text/css\">.c{fill:none;stroke:#222222;}.k{fill:#000000;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;font-size:20px;}.s{fill:#e4f4ff;stroke:#222222;}.syn{fill:#8D8D8D;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;font-size:20px;}</style></defs><path class=\"c\" d=\"M0 31h5m140 0h10m32 0h30m152 0h10m32 0h20m-229 0q5 0 5 5v10q0 5 5 5h204q5 0 5-5v-10q0-5 5-5m5 0h10m140 0h10m32 0h5\"/><rect class=\"s\" x=\"5\" y=\"5\" width=\"140\" height=\"36\"/><text class=\"k\" x=\"15\" y=\"31\">DATE_PARSE</text><rect class=\"s\" x=\"155\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"165\" y=\"31\">(</text><rect class=\"s\" x=\"217\" y=\"5\" width=\"152\" height=\"36\" rx=\"7\"/><text class=\"k\" x=\"227\" y=\"31\">datePattern</text><rect class=\"s\" x=\"379\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"389\" y=\"31\">,</text><rect class=\"s\" x=\"441\" y=\"5\" width=\"140\" height=\"36\" rx=\"7\"/><text class=\"k\" x=\"451\" y=\"31\">dateString</text><rect class=\"s\" x=\"591\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"601\" y=\"31\">)</text></svg>\n\\ No newline at end of file\n+<svg version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns=\"http://www.w3.org/2000/svg\" width=\"824\" height=\"61\" viewbox=\"0 0 824 61\"><defs><style type=\"text/css\">.c{fill:none;stroke:#222222;}.k{fill:#000000;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;font-size:20px;}.s{fill:#e4f4ff;stroke:#222222;}.syn{fill:#8D8D8D;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;font-size:20px;}</style></defs><path class=\"c\" d=\"M0 31h5m140 0h10m32 0h30m152 0h10m32 0h20m-229 0q5 0 5 5v10q0 5 5 5h204q5 0 5-5v-10q0-5 5-5m5 0h10m140 0h30m32 0h10m104 0h20m-181 0q5 0 5 5v10q0 5 5 5h156q5 0 5-5v-10q0-5 5-5m5 0h10m32 0h5\"/><rect class=\"s\" x=\"5\" y=\"5\" width=\"140\" height=\"36\"/><text class=\"k\" x=\"15\" y=\"31\">DATE_PARSE</text><rect class=\"s\" x=\"155\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"165\" y=\"31\">(</text><rect class=\"s\" x=\"217\" y=\"5\" width=\"152\" height=\"36\" rx=\"7\"/><text class=\"k\" x=\"227\" y=\"31\">datePattern</text><rect class=\"s\" x=\"379\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"389\" y=\"31\">,</text><rect class=\"s\" x=\"441\" y=\"5\" width=\"140\" height=\"36\" rx=\"7\"/><text class=\"k\" x=\"451\" y=\"31\">dateString</text><rect class=\"s\" x=\"611\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"621\" y=\"31\">,</text><rect class=\"s\" x=\"653\" y=\"5\" width=\"104\" height=\"36\" rx=\"7\"/><text class=\"k\" x=\"663\" y=\"31\">options</text><rect class=\"s\" x=\"787\" y=\"5\" width=\"32\" height=\"36\" rx=\"7\"/><text class=\"syn\" x=\"797\" y=\"31\">)</text></svg>\n\\ No newline at end of file\ndiff --git a/docs/reference/query-languages/esql/kibana/definition/functions/date_parse.json b/docs/reference/query-languages/esql/kibana/definition/functions/date_parse.json\nindex 7c4b5c4ac9461..158060cfaf3db 100644\n--- a/docs/reference/query-languages/esql/kibana/definition/functions/date_parse.json\n+++ b/docs/reference/query-languages/esql/kibana/definition/functions/date_parse.json\n@@ -22,6 +22,31 @@\n       \"variadic\" : false,\n       \"returnType\" : \"date\"\n     },\n+    {\n+      \"params\" : [\n+        {\n+          \"name\" : \"datePattern\",\n+          \"type\" : \"keyword\",\n+          \"optional\" : true,\n+          \"description\" : \"The date format. Refer to the {javadoc14}/java.base/java/time/format/DateTimeFormatter.html[`DateTimeFormatter` documentation] for the syntax. If `null`, the function returns `null`.\"\n+        },\n+        {\n+          \"name\" : \"dateString\",\n+          \"type\" : \"keyword\",\n+          \"optional\" : false,\n+          \"description\" : \"Date expression as a string. If `null` or an empty string, the function returns `null`.\"\n+        },\n+        {\n+          \"name\" : \"options\",\n+          \"type\" : \"function_named_parameters\",\n+          \"mapParams\" : \"{name='time_zone', values=[standard], description='Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.'}, {name='locale', values=[standard], description='The locale to use when parsing the date, relevant when parsing month names or week days.'}\",\n+          \"optional\" : true,\n+          \"description\" : \"(Optional) Additional options for date parsing, specifying time zone and locale as <<esql-function-named-params,function named parameters>>.\"\n+        }\n+      ],\n+      \"variadic\" : false,\n+      \"returnType\" : \"date\"\n+    },\n     {\n       \"params\" : [\n         {\ndiff --git a/x-pack/plugin/esql/qa/testFixtures/src/main/resources/date.csv-spec b/x-pack/plugin/esql/qa/testFixtures/src/main/resources/date.csv-spec\nindex e5efc9e7a37aa..8beef707706ca 100644\n--- a/x-pack/plugin/esql/qa/testFixtures/src/main/resources/date.csv-spec\n+++ b/x-pack/plugin/esql/qa/testFixtures/src/main/resources/date.csv-spec\n@@ -644,6 +644,46 @@ emp_no:integer  | new_date:datetime          | birth_date:datetime       | bool:\n 10050           | 1958-05-21T00:00:00.000Z   | 1958-05-21T00:00:00.000Z  | true\n ;\n \n+evalDateParseWithTimezoneOption\n+required_capability: date_parse_options\n+row a = \"10-10-2025\" | eval b = date_parse(\"dd-mm-yyyy\", a, {\"time_zone\":\"Europe/Paris\"}) | keep b;\n+\n+b:datetime\n+2024-12-31T23:00:00.000Z\n+;\n+\n+evalDateParseWithLocaleOption\n+required_capability: date_parse_options\n+row a = \"10 septembre 2025\" | eval b = date_parse(\"dd MMMM yyyy\", a, {\"locale\":\"fr\"}) | keep b;\n+\n+b:datetime\n+2025-09-10T00:00:00.000Z\n+;\n+\n+evalDateParseWithLocaleAndTimezoneOption\n+required_capability: date_parse_options\n+row a = \"10 septembre 2025\" | eval b = date_parse(\"dd MMMM yyyy\", a, {\"locale\":\"fr\",\"time_zone\":\"Europe/Paris\"}) | keep b;\n+\n+b:datetime\n+2025-09-09T22:00:00.000Z\n+;\n+\n+evalDateParseDefaultFormatWithTimezoneOption\n+required_capability: date_parse_options\n+row a = \"2023-02-01T12:15:55.000+01:00\" | eval b = date_parse(a, {\"time_zone\":\"Europe/Paris\"}) | keep b;\n+\n+b:datetime\n+2023-02-01T11:15:55.000Z\n+;\n+\n+evalDateParseDefaultFormatWithLocaleOption\n+required_capability: date_parse_options\n+row a = \"2023-02-01T12:15:55.000Z\" | eval b = date_parse(a, {\"locale\":\"fr\"}) | keep b;\n+\n+b:datetime\n+2023-02-01T12:15:55.000Z\n+;\n+\n dateFields\n from employees | where emp_no == 10049 or emp_no == 10050 \n | eval year = date_extract(\"year\", birth_date), month = date_extract(\"month_of_year\", birth_date), day = date_extract(\"day_of_month\", birth_date)\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java\nindex e637481c7e058..f10061a14175b 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java\n@@ -1532,6 +1532,11 @@ public enum Cap {\n          */\n         FIX_FILTER_ORDINALS,\n \n+        /**\n+         * Optional options argument for DATE_PARSE\n+         */\n+        DATE_PARSE_OPTIONS,\n+\n         /**\n          * Allow multiple patterns for GROK command\n          */\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/EsqlFunctionRegistry.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/EsqlFunctionRegistry.java\nindex a44d7cb719a50..4214c3c49558d 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/EsqlFunctionRegistry.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/EsqlFunctionRegistry.java\n@@ -1042,12 +1042,20 @@ public interface BinaryBuilder<T> {\n     protected static <T extends Function> FunctionDefinition def(Class<T> function, TernaryBuilder<T> ctorRef, String... names) {\n         FunctionBuilder builder = (source, children, cfg) -> {\n             boolean hasMinimumTwo = OptionalArgument.class.isAssignableFrom(function);\n-            if (hasMinimumTwo && (children.size() > 3 || children.size() < 2)) {\n+            boolean hasMinimumOne = TwoOptionalArguments.class.isAssignableFrom(function);\n+            if (hasMinimumOne && (children.size() > 3 || children.isEmpty())) {\n+                throw new QlIllegalArgumentException(\"expects one, two or three arguments\");\n+            } else if (hasMinimumTwo && (children.size() > 3 || children.size() < 2)) {\n                 throw new QlIllegalArgumentException(\"expects two or three arguments\");\n-            } else if (hasMinimumTwo == false && children.size() != 3) {\n+            } else if (hasMinimumOne == false && hasMinimumTwo == false && children.size() != 3) {\n                 throw new QlIllegalArgumentException(\"expects exactly three arguments\");\n             }\n-            return ctorRef.build(source, children.get(0), children.get(1), children.size() == 3 ? children.get(2) : null);\n+            return ctorRef.build(\n+                source,\n+                children.get(0),\n+                children.size() > 1 ? children.get(1) : null,\n+                children.size() == 3 ? children.get(2) : null\n+            );\n         };\n         return def(function, builder, names);\n     }\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParse.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParse.java\nindex ef1acbc395308..01b83a466aec4 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParse.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParse.java\n@@ -12,41 +12,59 @@\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.common.time.DateFormatter;\n+import org.elasticsearch.common.util.LocaleUtils;\n import org.elasticsearch.compute.ann.Evaluator;\n import org.elasticsearch.compute.ann.Fixed;\n import org.elasticsearch.compute.operator.EvalOperator.ExpressionEvaluator;\n import org.elasticsearch.xpack.esql.core.InvalidArgumentException;\n import org.elasticsearch.xpack.esql.core.expression.Expression;\n+import org.elasticsearch.xpack.esql.core.expression.MapExpression;\n import org.elasticsearch.xpack.esql.core.tree.NodeInfo;\n import org.elasticsearch.xpack.esql.core.tree.Source;\n import org.elasticsearch.xpack.esql.core.type.DataType;\n import org.elasticsearch.xpack.esql.expression.function.Example;\n import org.elasticsearch.xpack.esql.expression.function.FunctionInfo;\n-import org.elasticsearch.xpack.esql.expression.function.OptionalArgument;\n+import org.elasticsearch.xpack.esql.expression.function.MapParam;\n+import org.elasticsearch.xpack.esql.expression.function.Options;\n import org.elasticsearch.xpack.esql.expression.function.Param;\n+import org.elasticsearch.xpack.esql.expression.function.TwoOptionalArguments;\n import org.elasticsearch.xpack.esql.expression.function.scalar.EsqlScalarFunction;\n import org.elasticsearch.xpack.esql.io.stream.PlanStreamInput;\n \n import java.io.IOException;\n+import java.time.ZoneId;\n+import java.time.zone.ZoneRulesException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n \n+import static java.util.Map.entry;\n import static org.elasticsearch.common.time.DateFormatter.forPattern;\n import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.ParamOrdinal.FIRST;\n import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.ParamOrdinal.SECOND;\n+import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.ParamOrdinal.THIRD;\n+import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.isMapExpression;\n import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.isString;\n+import static org.elasticsearch.xpack.esql.core.type.DataType.KEYWORD;\n import static org.elasticsearch.xpack.esql.expression.EsqlTypeResolutions.isStringAndExact;\n import static org.elasticsearch.xpack.esql.type.EsqlDataTypeConverter.DEFAULT_DATE_TIME_FORMATTER;\n import static org.elasticsearch.xpack.esql.type.EsqlDataTypeConverter.dateTimeToLong;\n \n-public class DateParse extends EsqlScalarFunction implements OptionalArgument {\n+public class DateParse extends EsqlScalarFunction implements TwoOptionalArguments {\n     public static final NamedWriteableRegistry.Entry ENTRY = new NamedWriteableRegistry.Entry(\n         Expression.class,\n         \"DateParse\",\n         DateParse::new\n     );\n \n-    private final Expression field;\n-    private final Expression format;\n+    private static final String TIME_ZONE_PARAM_NAME = \"time_zone\";\n+    private static final String LOCALE_PARAM_NAME = \"locale\";\n+\n+    private final Expression first;\n+    private final Expression second;\n+    private final Expression third;\n \n     @FunctionInfo(\n         returnType = \"date\",\n@@ -63,17 +81,80 @@ public DateParse(\n             name = \"dateString\",\n             type = { \"keyword\", \"text\" },\n             description = \"Date expression as a string. If `null` or an empty string, the function returns `null`.\"\n-        ) Expression second\n+        ) Expression second,\n+        @MapParam(\n+            name = \"options\",\n+            params = {\n+                @MapParam.MapParamEntry(\n+                    name = TIME_ZONE_PARAM_NAME,\n+                    type = \"keyword\",\n+                    valueHint = { \"standard\" },\n+                    description = \"Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the \"\n+                        + \"query string to UTC.\"\n+                ),\n+                @MapParam.MapParamEntry(\n+                    name = LOCALE_PARAM_NAME,\n+                    type = \"keyword\",\n+                    valueHint = { \"standard\" },\n+                    description = \"The locale to use when parsing the date, relevant when parsing month names or week days.\"\n+                ) },\n+            description = \"(Optional) Additional options for date parsing, specifying time zone and locale \"\n+                + \"as <<esql-function-named-params,function named parameters>>.\",\n+            optional = true\n+        ) Expression third\n     ) {\n-        super(source, second != null ? List.of(first, second) : List.of(first));\n-        this.field = second != null ? second : first;\n-        this.format = second != null ? first : null;\n+        super(source, fields(first, second, third));\n+        this.first = first;\n+        this.second = second;\n+        this.third = third;\n+    }\n+\n+    private static List<Expression> fields(Expression first, Expression second, Expression third) {\n+        List<Expression> list = new ArrayList<>(3);\n+        list.add(first);\n+        if (second != null) {\n+            list.add(second);\n+        }\n+        if (third != null) {\n+            list.add(third);\n+        }\n+        return list;\n+    }\n+\n+    private Expression field() {\n+        // If second is a MapExpression, then: first=date, second=options, third=null\n+        // If second is not a MapExpression and second exists, then: first=pattern, second=date, third=options\n+        // If only first exists, then: first=date, second=null, third=null\n+        if (second instanceof MapExpression) {\n+            return first;\n+        }\n+        return second != null ? second : first;\n+    }\n+\n+    private Expression format() {\n+        // If second is a MapExpression, then: first=date, second=options, third=null (no format)\n+        // If second is not a MapExpression and second exists, then: first=pattern, second=date, third=options\n+        // If only first exists, then: first=date, second=null, third=null (no format)\n+        if (second instanceof MapExpression || second == null) {\n+            return null;\n+        }\n+        return first;\n+    }\n+\n+    private Expression options() {\n+        // If second is a MapExpression, then: first=date, second=options, third=null\n+        // If second is not a MapExpression and third exists, then: first=pattern, second=date, third=options\n+        if (second instanceof MapExpression) {\n+            return second;\n+        }\n+        return third;\n     }\n \n     private DateParse(StreamInput in) throws IOException {\n         this(\n             Source.readFrom((PlanStreamInput) in),\n             in.readNamedWriteable(Expression.class),\n+            in.readOptionalNamedWriteable(Expression.class),\n             in.readOptionalNamedWriteable(Expression.class)\n         );\n     }\n@@ -82,7 +163,8 @@ private DateParse(StreamInput in) throws IOException {\n     public void writeTo(StreamOutput out) throws IOException {\n         source().writeTo(out);\n         out.writeNamedWriteable(children().get(0));\n-        out.writeOptionalNamedWriteable(children().size() == 2 ? children().get(1) : null);\n+        out.writeOptionalNamedWriteable(children().size() > 1 ? children().get(1) : null);\n+        out.writeOptionalNamedWriteable(children().size() > 2 ? children().get(2) : null);\n     }\n \n     @Override\n@@ -102,6 +184,7 @@ protected TypeResolution resolveType() {\n         }\n \n         TypeResolution resolution;\n+        Expression format = format();\n         if (format != null) {\n             resolution = isStringAndExact(format, sourceText(), FIRST);\n             if (resolution.unresolved()) {\n@@ -109,16 +192,28 @@ protected TypeResolution resolveType() {\n             }\n         }\n \n+        Expression field = field();\n         resolution = isString(field, sourceText(), format != null ? SECOND : FIRST);\n         if (resolution.unresolved()) {\n             return resolution;\n         }\n \n+        // Validate options parameter if present\n+        Expression options = options();\n+        if (options != null) {\n+            resolution = isMapExpression(options, sourceText(), THIRD);\n+            if (resolution.unresolved()) {\n+                return resolution;\n+            }\n+        }\n+\n         return TypeResolution.TYPE_RESOLVED;\n     }\n \n     @Override\n     public boolean foldable() {\n+        Expression field = field();\n+        Expression format = format();\n         return field.foldable() && (format == null || format.foldable());\n     }\n \n@@ -132,8 +227,26 @@ static long process(BytesRef val, BytesRef formatter) throws IllegalArgumentExce\n         return dateTimeToLong(val.utf8ToString(), toFormatter(formatter));\n     }\n \n+    public static final Map<String, DataType> ALLOWED_OPTIONS = Map.ofEntries(\n+        entry(TIME_ZONE_PARAM_NAME, KEYWORD),\n+        entry(LOCALE_PARAM_NAME, KEYWORD)\n+    );\n+\n+    private Map<String, Object> parseOptions() throws InvalidArgumentException {\n+        Map<String, Object> matchOptions = new HashMap<>();\n+        Expression options = options();\n+        if (options == null) {\n+            return matchOptions;\n+        }\n+\n+        Options.populateMap((MapExpression) options, matchOptions, source(), THIRD, ALLOWED_OPTIONS);\n+        return matchOptions;\n+    }\n+\n     @Override\n     public ExpressionEvaluator.Factory toEvaluator(ToEvaluator toEvaluator) {\n+        Expression field = field();\n+        Expression format = format();\n         ExpressionEvaluator.Factory fieldEvaluator = toEvaluator.apply(field);\n         if (format == null) {\n             return new DateParseConstantEvaluator.Factory(source(), fieldEvaluator, DEFAULT_DATE_TIME_FORMATTER);\n@@ -141,9 +254,29 @@ public ExpressionEvaluator.Factory toEvaluator(ToEvaluator toEvaluator) {\n         if (DataType.isString(format.dataType()) == false) {\n             throw new IllegalArgumentException(\"unsupported data type for date_parse [\" + format.dataType() + \"]\");\n         }\n+        var parsedOptions = this.parseOptions();\n+        String localeAsString = (String) parsedOptions.get(LOCALE_PARAM_NAME);\n+        Locale locale = localeAsString == null ? null : LocaleUtils.parse(localeAsString);\n+\n+        String timezoneAsString = (String) parsedOptions.get(TIME_ZONE_PARAM_NAME);\n+        ZoneId timezone = null;\n+        try {\n+            if (timezoneAsString != null) {\n+                timezone = ZoneId.of(timezoneAsString);\n+            }\n+        } catch (ZoneRulesException e) {\n+            throw new IllegalArgumentException(\"unsupported timezone [\" + timezoneAsString + \"]\");\n+        }\n+\n         if (format.foldable()) {\n             try {\n                 DateFormatter formatter = toFormatter(format.fold(toEvaluator.foldCtx()));\n+                if (locale != null) {\n+                    formatter = formatter.withLocale(locale);\n+                }\n+                if (timezone != null) {\n+                    formatter = formatter.withZone(timezone);\n+                }\n                 return new DateParseConstantEvaluator.Factory(source(), fieldEvaluator, formatter);\n             } catch (IllegalArgumentException e) {\n                 throw new InvalidArgumentException(e, \"invalid date pattern for [{}]: {}\", sourceText(), e.getMessage());\n@@ -159,13 +292,21 @@ private static DateFormatter toFormatter(Object format) {\n \n     @Override\n     public Expression replaceChildren(List<Expression> newChildren) {\n-        return new DateParse(source(), newChildren.get(0), newChildren.size() > 1 ? newChildren.get(1) : null);\n+        return new DateParse(\n+            source(),\n+            newChildren.get(0),\n+            newChildren.size() > 1 ? newChildren.get(1) : null,\n+            newChildren.size() > 2 ? newChildren.get(2) : null\n+        );\n     }\n \n     @Override\n     protected NodeInfo<? extends Expression> info() {\n+        Expression format = format();\n+        Expression field = field();\n+        Expression options = options();\n         Expression first = format != null ? format : field;\n         Expression second = format != null ? field : null;\n-        return NodeInfo.create(this, DateParse::new, first, second);\n+        return NodeInfo.create(this, DateParse::new, first, second, options);\n     }\n }\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseErrorTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseErrorTests.java\nindex 21d9b5fb00537..9d8642b63aa13 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseErrorTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseErrorTests.java\n@@ -15,8 +15,10 @@\n import org.hamcrest.Matcher;\n \n import java.util.List;\n+import java.util.Locale;\n import java.util.Set;\n \n+import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.ParamOrdinal;\n import static org.hamcrest.Matchers.equalTo;\n \n public class DateParseErrorTests extends ErrorsForCasesWithoutExamplesTestCase {\n@@ -27,11 +29,28 @@ protected List<TestCaseSupplier> cases() {\n \n     @Override\n     protected Expression build(Source source, List<Expression> args) {\n-        return new DateParse(source, args.get(0), args.size() > 1 ? args.get(1) : null);\n+        return new DateParse(source, args.get(0), args.size() > 1 ? args.get(1) : null, args.size() > 2 ? args.get(2) : null);\n     }\n \n     @Override\n     protected Matcher<String> expectedTypeErrorMatcher(List<Set<DataType>> validPerPosition, List<DataType> signature) {\n+        // Need custom matchers for the MapExpression case\n+        if (signature.size() == 3 && validPerPosition.size() >= 3) {\n+            boolean firstParamValid = validPerPosition.get(0).isEmpty() == false\n+                && (signature.get(0) == null || validPerPosition.get(0).contains(signature.get(0)));\n+            boolean secondParamValid = validPerPosition.get(1).isEmpty() == false\n+                && (signature.get(1) == null || validPerPosition.get(1).contains(signature.get(1)));\n+\n+            boolean thirdParamInvalid = validPerPosition.get(2).isEmpty()\n+                || signature.get(2) == DataType.NULL\n+                || (validPerPosition.get(2).contains(signature.get(2)) == false && signature.get(2) != null);\n+\n+            if (firstParamValid && secondParamValid && thirdParamInvalid) {\n+                String ordinal = ParamOrdinal.THIRD.name().toLowerCase(Locale.ROOT);\n+                return equalTo(ordinal + \" argument of [\" + sourceForSignature(signature) + \"] must be a map expression, received []\");\n+            }\n+        }\n+\n         return equalTo(typeErrorMessage(true, validPerPosition, signature, (v, i) -> \"string\"));\n     }\n }\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseSerializationTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseSerializationTests.java\nindex 79a650c8dd963..8ed72c12bd115 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseSerializationTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseSerializationTests.java\n@@ -19,19 +19,21 @@ protected DateParse createTestInstance() {\n         Source source = randomSource();\n         Expression first = randomChild();\n         Expression second = randomBoolean() ? null : randomChild();\n-        return new DateParse(source, first, second);\n+        Expression third = randomBoolean() ? randomChild() : null;\n+        return new DateParse(source, first, second, third);\n     }\n \n     @Override\n     protected DateParse mutateInstance(DateParse instance) throws IOException {\n         Source source = instance.source();\n         Expression first = instance.children().get(0);\n-        Expression second = instance.children().size() == 1 ? null : instance.children().get(1);\n-        if (randomBoolean()) {\n-            first = randomValueOtherThan(first, AbstractExpressionSerializationTests::randomChild);\n-        } else {\n-            second = randomValueOtherThan(second, () -> randomBoolean() ? null : randomChild());\n+        Expression second = instance.children().size() > 1 ? instance.children().get(1) : null;\n+        Expression third = instance.children().size() > 2 ? instance.children().get(2) : null;\n+        switch (between(0, 2)) {\n+            case 0 -> first = randomValueOtherThan(first, AbstractExpressionSerializationTests::randomChild);\n+            case 1 -> second = randomValueOtherThan(second, () -> randomBoolean() ? null : randomChild());\n+            case 2 -> third = randomValueOtherThan(third, () -> randomBoolean() ? null : randomChild());\n         }\n-        return new DateParse(source, first, second);\n+        return new DateParse(source, first, second, third);\n     }\n }\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseTests.java\nindex e2e379c3f3cf7..6aded21e11a98 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseTests.java\n@@ -15,11 +15,13 @@\n import org.elasticsearch.xpack.esql.core.InvalidArgumentException;\n import org.elasticsearch.xpack.esql.core.expression.Expression;\n import org.elasticsearch.xpack.esql.core.expression.Literal;\n+import org.elasticsearch.xpack.esql.core.expression.MapExpression;\n import org.elasticsearch.xpack.esql.core.tree.Source;\n import org.elasticsearch.xpack.esql.core.type.DataType;\n import org.elasticsearch.xpack.esql.expression.function.AbstractScalarFunctionTestCase;\n import org.elasticsearch.xpack.esql.expression.function.TestCaseSupplier;\n \n+import java.util.ArrayList;\n import java.util.List;\n import java.util.Locale;\n import java.util.function.Supplier;\n@@ -36,115 +38,148 @@ public DateParseTests(@Name(\"TestCase\") Supplier<TestCaseSupplier.TestCase> test\n \n     @ParametersFactory\n     public static Iterable<Object[]> parameters() {\n-        return parameterSuppliersFromTypedDataWithDefaultChecks(\n-            true,\n-            List.of(\n-                new TestCaseSupplier(\n-                    \"Basic Case\",\n-                    List.of(DataType.KEYWORD, DataType.KEYWORD),\n-                    () -> new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"second\")\n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        equalTo(1683244800000L)\n-                    )\n-                ),\n-                new TestCaseSupplier(\"Timezoned Case\", List.of(DataType.KEYWORD, DataType.KEYWORD), () -> {\n-                    long ts_sec = 1657585450L; // 2022-07-12T00:24:10Z\n-                    int hours = randomIntBetween(0, 23);\n-                    String date = String.format(Locale.ROOT, \"12/Jul/2022:%02d:24:10 +0900\", hours);\n-                    long expected_ts = (ts_sec + (hours - 9) * 3600L) * 1000L;\n-                    return new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"dd/MMM/yyyy:HH:mm:ss Z\"), DataType.KEYWORD, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(date), DataType.KEYWORD, \"second\")\n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        equalTo(expected_ts)\n-                    );\n-                }),\n-                new TestCaseSupplier(\n-                    \"With Text\",\n-                    List.of(DataType.KEYWORD, DataType.TEXT),\n-                    () -> new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.TEXT, \"second\")\n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        equalTo(1683244800000L)\n-                    )\n-                ),\n-                new TestCaseSupplier(\n-                    \"With Both Text\",\n-                    List.of(DataType.TEXT, DataType.TEXT),\n-                    () -> new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.TEXT, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.TEXT, \"second\")\n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        equalTo(1683244800000L)\n-                    )\n-                ),\n-                new TestCaseSupplier(\n-                    \"With keyword\",\n-                    List.of(DataType.TEXT, DataType.KEYWORD),\n-                    () -> new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.TEXT, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"second\")\n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        equalTo(1683244800000L)\n-                    )\n+        List<TestCaseSupplier> cases = new ArrayList<>();\n+        cases.add(\n+            new TestCaseSupplier(\n+                \"Basic Case\",\n+                List.of(DataType.KEYWORD, DataType.KEYWORD),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"first\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"second\")\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    equalTo(1683244800000L)\n+                )\n+            )\n+        );\n+        cases.add(new TestCaseSupplier(\"Timezoned Case\", List.of(DataType.KEYWORD, DataType.KEYWORD), () -> {\n+            long ts_sec = 1657585450L; // 2022-07-12T00:24:10Z\n+            int hours = randomIntBetween(0, 23);\n+            String date = String.format(Locale.ROOT, \"12/Jul/2022:%02d:24:10 +0900\", hours);\n+            long expected_ts = (ts_sec + (hours - 9) * 3600L) * 1000L;\n+            return new TestCaseSupplier.TestCase(\n+                List.of(\n+                    new TestCaseSupplier.TypedData(new BytesRef(\"dd/MMM/yyyy:HH:mm:ss Z\"), DataType.KEYWORD, \"first\"),\n+                    new TestCaseSupplier.TypedData(new BytesRef(date), DataType.KEYWORD, \"second\")\n                 ),\n-                new TestCaseSupplier(\n-                    List.of(DataType.KEYWORD, DataType.KEYWORD),\n-                    () -> new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"not a format\"), DataType.KEYWORD, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"second\")\n+                \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                DataType.DATETIME,\n+                equalTo(expected_ts)\n+            );\n+        }));\n+        cases.add(\n+            new TestCaseSupplier(\n+                \"With Text\",\n+                List.of(DataType.KEYWORD, DataType.TEXT),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"first\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.TEXT, \"second\")\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    equalTo(1683244800000L)\n+                )\n+            )\n+        );\n+        cases.add(\n+            new TestCaseSupplier(\n+                \"With Both Text\",\n+                List.of(DataType.TEXT, DataType.TEXT),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.TEXT, \"first\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.TEXT, \"second\")\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    equalTo(1683244800000L)\n+                )\n+            )\n+        );\n+        cases.add(\n+            new TestCaseSupplier(\n+                \"With keyword\",\n+                List.of(DataType.TEXT, DataType.KEYWORD),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.TEXT, \"first\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"second\")\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    equalTo(1683244800000L)\n+                )\n+            )\n+        );\n+        cases.add(\n+            new TestCaseSupplier(\n+                List.of(DataType.KEYWORD, DataType.KEYWORD),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"not a format\"), DataType.KEYWORD, \"first\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"second\")\n \n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        is(nullValue())\n-                    ).withWarning(\"Line 1:1: evaluation of [source] failed, treating result as null. Only first 20 failures recorded.\")\n-                        .withWarning(\n-                            \"Line 1:1: java.lang.IllegalArgumentException: Invalid format: [not a format]: Unknown pattern letter: o\"\n-                        )\n-                        .withFoldingException(\n-                            InvalidArgumentException.class,\n-                            \"invalid date pattern for [source]: Invalid format: [not a format]: Unknown pattern letter: o\"\n-                        )\n-                ),\n-                new TestCaseSupplier(\n-                    List.of(DataType.KEYWORD, DataType.KEYWORD),\n-                    () -> new TestCaseSupplier.TestCase(\n-                        List.of(\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"first\"),\n-                            new TestCaseSupplier.TypedData(new BytesRef(\"not a date\"), DataType.KEYWORD, \"second\")\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    is(nullValue())\n+                ).withWarning(\"Line 1:1: evaluation of [source] failed, treating result as null. Only first 20 failures recorded.\")\n+                    .withWarning(\"Line 1:1: java.lang.IllegalArgumentException: Invalid format: [not a format]: Unknown pattern letter: o\")\n+                    .withFoldingException(\n+                        InvalidArgumentException.class,\n+                        \"invalid date pattern for [source]: Invalid format: [not a format]: Unknown pattern letter: o\"\n+                    )\n+            )\n+        );\n+        cases.add(\n+            new TestCaseSupplier(\n+                List.of(DataType.KEYWORD, DataType.KEYWORD),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"first\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"not a date\"), DataType.KEYWORD, \"second\")\n \n-                        ),\n-                        \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n-                        DataType.DATETIME,\n-                        is(nullValue())\n-                    ).withWarning(\"Line 1:1: evaluation of [source] failed, treating result as null. Only first 20 failures recorded.\")\n-                        .withWarning(\n-                            \"Line 1:1: java.lang.IllegalArgumentException: \"\n-                                + \"failed to parse date field [not a date] with format [yyyy-MM-dd]\"\n-                        )\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    is(nullValue())\n+                ).withWarning(\"Line 1:1: evaluation of [source] failed, treating result as null. Only first 20 failures recorded.\")\n+                    .withWarning(\n+                        \"Line 1:1: java.lang.IllegalArgumentException: \"\n+                            + \"failed to parse date field [not a date] with format [yyyy-MM-dd]\"\n+                    )\n+            )\n+        );\n+        cases = anyNullIsNull(true, cases);\n+        cases.add(\n+            new TestCaseSupplier(\n+                List.of(DataType.KEYWORD, DataType.KEYWORD, DataType.OBJECT),\n+                () -> new TestCaseSupplier.TestCase(\n+                    List.of(\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"yyyy-MM-dd\"), DataType.KEYWORD, \"pattern\"),\n+                        new TestCaseSupplier.TypedData(new BytesRef(\"2023-05-05\"), DataType.KEYWORD, \"date\"),\n+                        new TestCaseSupplier.TypedData(\n+                            new MapExpression(\n+                                Source.EMPTY,\n+                                List.of(\n+                                    new Literal(Source.EMPTY, new BytesRef(\"time_zone\"), DataType.KEYWORD),\n+                                    new Literal(Source.EMPTY, new BytesRef(\"UTC\"), DataType.KEYWORD)\n+                                )\n+                            ),\n+                            DataType.OBJECT,\n+                            \"options\"\n+                        ).forceLiteral()\n+                    ),\n+                    \"DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]\",\n+                    DataType.DATETIME,\n+                    equalTo(1683244800000L)\n                 )\n             )\n         );\n+        return parameterSuppliersFromTypedData(randomizeBytesRefsOffset(cases));\n     }\n \n     public void testInvalidPattern() {\n@@ -156,15 +191,64 @@ public void testInvalidPattern() {\n                 new DateParse(\n                     Source.EMPTY,\n                     new Literal(Source.EMPTY, new BytesRef(pattern), DataType.KEYWORD),\n-                    field(\"str\", DataType.KEYWORD)\n+                    field(\"str\", DataType.KEYWORD),\n+                    null\n                 )\n             ).get(driverContext)\n         );\n         assertThat(e.getMessage(), startsWith(\"invalid date pattern for []: Invalid format: [\" + pattern + \"]\"));\n     }\n \n+    public void testInvalidLocale() {\n+        String pattern = \"YYYY\";\n+        String locale = \"nonexistinglocale\";\n+        DriverContext driverContext = driverContext();\n+        IllegalArgumentException e = expectThrows(\n+            IllegalArgumentException.class,\n+            () -> evaluator(\n+                new DateParse(\n+                    Source.EMPTY,\n+                    new Literal(Source.EMPTY, new BytesRef(pattern), DataType.KEYWORD),\n+                    field(\"str\", DataType.KEYWORD),\n+                    new MapExpression(\n+                        Source.EMPTY,\n+                        List.of(\n+                            new Literal(Source.EMPTY, new BytesRef(\"locale\"), DataType.KEYWORD),\n+                            new Literal(Source.EMPTY, new BytesRef(locale), DataType.KEYWORD)\n+                        )\n+                    )\n+                )\n+            ).get(driverContext)\n+        );\n+        assertThat(e.getMessage(), startsWith(\"Unknown language: \" + locale));\n+    }\n+\n+    public void testInvalidTimezone() {\n+        String pattern = \"YYYY\";\n+        String timezone = \"NON-EXISTING-TIMEZONE\";\n+        DriverContext driverContext = driverContext();\n+        IllegalArgumentException e = expectThrows(\n+            IllegalArgumentException.class,\n+            () -> evaluator(\n+                new DateParse(\n+                    Source.EMPTY,\n+                    new Literal(Source.EMPTY, new BytesRef(pattern), DataType.KEYWORD),\n+                    field(\"str\", DataType.KEYWORD),\n+                    new MapExpression(\n+                        Source.EMPTY,\n+                        List.of(\n+                            new Literal(Source.EMPTY, new BytesRef(\"time_zone\"), DataType.KEYWORD),\n+                            new Literal(Source.EMPTY, new BytesRef(timezone), DataType.KEYWORD)\n+                        )\n+                    )\n+                )\n+            ).get(driverContext)\n+        );\n+        assertThat(e.getMessage(), startsWith(\"unsupported timezone [\" + timezone + \"]\"));\n+    }\n+\n     @Override\n     protected Expression build(Source source, List<Expression> args) {\n-        return new DateParse(source, args.get(0), args.size() > 1 ? args.get(1) : null);\n+        return new DateParse(source, args.get(0), args.size() > 1 ? args.get(1) : null, args.size() == 3 ? args.get(2) : null);\n     }\n }\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/FoldNullTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/FoldNullTests.java\nindex ae30dce97ce5a..e45782dcf80ee 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/FoldNullTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/FoldNullTests.java\n@@ -97,7 +97,7 @@ public void testBasicNullFolding() {\n         assertNullLiteral(foldNull(new Round(EMPTY, Literal.NULL, null)));\n         assertNullLiteral(foldNull(new Pow(EMPTY, Literal.NULL, Literal.NULL)));\n         assertNullLiteral(foldNull(new DateFormat(EMPTY, Literal.NULL, Literal.NULL, null)));\n-        assertNullLiteral(foldNull(new DateParse(EMPTY, Literal.NULL, Literal.NULL)));\n+        assertNullLiteral(foldNull(new DateParse(EMPTY, Literal.NULL, Literal.NULL, NULL)));\n         assertNullLiteral(foldNull(new DateTrunc(EMPTY, Literal.NULL, Literal.NULL)));\n         assertNullLiteral(foldNull(new Substring(EMPTY, Literal.NULL, Literal.NULL, Literal.NULL)));\n     }\n",
  "additions": 482,
  "deletions": 135,
  "changed_files": 15,
  "url": "https://github.com/elastic/elasticsearch/pull/136548",
  "mined_at": "2025-10-25T13:21:29.283209"
}