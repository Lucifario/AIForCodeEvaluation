diff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/AggregatorImplementer.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/AggregatorImplementer.java
index 7989268a02071..e30164bc8aec5 100644
--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/AggregatorImplementer.java
+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/AggregatorImplementer.java
@@ -85,7 +85,8 @@ public class AggregatorImplementer {
     private final List<IntermediateStateDesc> intermediateState;
 
     private final AggregationState aggState;
-    private final List<AggregationParameter> aggParams;
+    private final List<Argument> aggParams;
+    private final boolean hasOnlyBlockArguments;
 
     public AggregatorImplementer(
         Elements elements,
@@ -111,15 +112,15 @@ public AggregatorImplementer(
             requireName("combine"),
             requireArgsStartsWith(requireType(aggState.declaredType()), requireAnyType("<aggregation input column type>"))
         );
-        this.aggParams = combine.getParameters().stream().skip(1).flatMap(v -> {
+        this.aggParams = combine.getParameters().stream().skip(1).map(v -> {
             Argument a = Argument.fromParameter(types, v);
-            return switch (a) {
-                case StandardArgument sa -> Stream.of(new AggregationParameter(sa.name(), sa.type(), false));
-                case BlockArgument ba -> Stream.of(new AggregationParameter(ba.name(), Types.elementType(ba.type()), true));
-                case PositionArgument pa -> Stream.of();
-                default -> throw new IllegalArgumentException("unsupported argument [" + declarationType + "][" + a + "]");
-            };
-        }).toList();
+            if ((a instanceof StandardArgument || a instanceof BlockArgument || a instanceof PositionArgument) == false) {
+                throw new IllegalArgumentException("unsupported argument [" + declarationType + "][" + a + "]");
+            }
+            return a;
+        }).filter(a -> a instanceof PositionArgument == false).toList();
+
+        this.hasOnlyBlockArguments = this.aggParams.stream().allMatch(a -> a instanceof BlockArgument);
 
         this.createParameters = init.getParameters()
             .stream()
@@ -199,8 +200,10 @@ private TypeSpec type() {
         builder.addMethod(addRawInput());
         builder.addMethod(addRawInputExploded(true));
         builder.addMethod(addRawInputExploded(false));
-        builder.addMethod(addRawVector(false));
-        builder.addMethod(addRawVector(true));
+        if (hasOnlyBlockArguments == false) {
+            builder.addMethod(addRawVector(false));
+            builder.addMethod(addRawVector(true));
+        }
         builder.addMethod(addRawBlock(false));
         builder.addMethod(addRawBlock(true));
         builder.addMethod(addIntermediateInput());
@@ -334,35 +337,39 @@ private MethodSpec addRawInputExploded(boolean hasMask) {
         }
 
         for (int i = 0; i < aggParams.size(); i++) {
-            AggregationParameter p = aggParams.get(i);
-            builder.addStatement("$T $L = page.getBlock(channels.get($L))", blockType(p.type()), p.blockName(), i);
-        }
-        for (AggregationParameter p : aggParams) {
-            builder.addStatement("$T $L = $L.asVector()", vectorType(p.type()), p.vectorName(), p.blockName());
-            builder.beginControlFlow("if ($L == null)", p.vectorName());
-            builder.addStatement(
-                "addRawBlock("
-                    + aggParams.stream().map(AggregationParameter::blockName).collect(joining(", "))
-                    + (hasMask ? ", mask" : "")
-                    + ")"
-            );
-            builder.addStatement("return");
-            builder.endControlFlow();
+            Argument a = aggParams.get(i);
+            builder.addStatement("$T $L = page.getBlock(channels.get($L))", a.dataType(true), a.blockName(), i);
         }
-        builder.addStatement(
-            "addRawVector("
-                + aggParams.stream().map(AggregationParameter::vectorName).collect(joining(", "))
+
+        for (Argument a : aggParams) {
+            String rawBlock = "addRawBlock("
+                + aggParams.stream().map(arg -> arg.blockName()).collect(joining(", "))
                 + (hasMask ? ", mask" : "")
-                + ")"
-        );
+                + ")";
+
+            a.resolveVectors(builder, rawBlock, "return");
+        }
+
+        builder.addStatement(invokeAddRaw(hasOnlyBlockArguments, hasMask));
         return builder.build();
     }
 
+    private String invokeAddRaw(boolean blockStyle, boolean hasMask) {
+        return addRawName(blockStyle)
+            + "("
+            + aggParams.stream().map(a -> blockStyle ? a.blockName() : a.vectorName()).collect(joining(", "))
+            + (hasMask ? ", mask" : "")
+            + ")";
+    }
+
+    private String addRawName(boolean blockStyle) {
+        return blockStyle ? "addRawBlock" : "addRawVector";
+    }
+
     private MethodSpec addRawVector(boolean masked) {
-        MethodSpec.Builder builder = initAddRaw(true, masked);
-        if (aggParams.getFirst().isArray()) {
-            builder.addComment("This type does not support vectors because all values are multi-valued");
-            return builder.build();
+        MethodSpec.Builder builder = initAddRaw(false, masked);
+        if (aggParams.getFirst() instanceof BlockArgument) {
+            throw new IllegalStateException("The BlockArgument type does not support vectors because all values are multi-valued");
         }
 
         if (first != null) {
@@ -383,8 +390,8 @@ private MethodSpec addRawVector(boolean masked) {
             if (masked) {
                 builder.beginControlFlow("if (mask.getBoolean(valuesPosition) == false)").addStatement("continue").endControlFlow();
             }
-            for (AggregationParameter p : aggParams) {
-                p.read(builder, true);
+            for (Argument a : aggParams) {
+                a.read(builder, a.vectorName(), "valuesPosition");
             }
             combineRawInput(builder, false);
         }
@@ -406,8 +413,8 @@ private void addRawVectorWithFirst(MethodSpec.Builder builder, boolean firstPass
                 builder.addStatement("continue");
                 builder.endControlFlow();
             }
-            for (AggregationParameter p : aggParams) {
-                p.read(builder, true);
+            for (Argument a : aggParams) {
+                a.read(builder, a.vectorName(), "valuesPosition");
             }
             combineRawInput(builder, firstPass);
             builder.addStatement("valuesPosition++");
@@ -420,21 +427,21 @@ private void addRawVectorWithFirst(MethodSpec.Builder builder, boolean firstPass
     }
 
     private MethodSpec addRawBlock(boolean masked) {
-        MethodSpec.Builder builder = initAddRaw(false, masked);
+        MethodSpec.Builder builder = initAddRaw(true, masked);
 
         builder.beginControlFlow("for (int p = 0; p < $L.getPositionCount(); p++)", aggParams.getFirst().blockName());
         {
             if (masked) {
                 builder.beginControlFlow("if (mask.getBoolean(p) == false)").addStatement("continue").endControlFlow();
             }
-            for (AggregationParameter p : aggParams) {
-                builder.addStatement("int $LValueCount = $L.getValueCount(p)", p.name(), p.blockName());
-                builder.beginControlFlow("if ($LValueCount == 0)", p.name());
+            for (Argument a : aggParams) {
+                builder.addStatement("int $LValueCount = $L.getValueCount(p)", a.name(), a.blockName());
+                builder.beginControlFlow("if ($LValueCount == 0)", a.name());
                 builder.addStatement("continue");
                 builder.endControlFlow();
             }
 
-            if (aggParams.getFirst().isArray()) {
+            if (aggParams.getFirst() instanceof BlockArgument) {
                 if (aggParams.size() > 1) {
                     throw new IllegalArgumentException("array mode not supported for multiple args");
                 }
@@ -446,18 +453,18 @@ private MethodSpec addRawBlock(boolean masked) {
                 if (first == null && aggState.hasSeen()) {
                     builder.addStatement("state.seen(true)");
                 }
-                for (AggregationParameter p : aggParams) {
-                    builder.addStatement("int $L = $L.getFirstValueIndex(p)", p.startName(), p.blockName());
-                    builder.addStatement("int $L = $L + $LValueCount", p.endName(), p.startName(), p.name());
+                for (Argument a : aggParams) {
+                    builder.addStatement("int $L = $L.getFirstValueIndex(p)", a.startName(), a.blockName());
+                    builder.addStatement("int $L = $L + $LValueCount", a.endName(), a.startName(), a.name());
                     builder.beginControlFlow(
                         "for (int $L = $L; $L < $L; $L++)",
-                        p.offsetName(),
-                        p.startName(),
-                        p.offsetName(),
-                        p.endName(),
-                        p.offsetName()
+                        a.offsetName(),
+                        a.startName(),
+                        a.offsetName(),
+                        a.endName(),
+                        a.offsetName()
                     );
-                    p.read(builder, false);
+                    a.read(builder, a.blockName(), a.offsetName());
                 }
                 if (first != null) {
                     builder.addComment("Check seen in every iteration to save on complexity in the Block path");
@@ -474,7 +481,7 @@ private MethodSpec addRawBlock(boolean masked) {
                 } else {
                     combineRawInput(builder, false);
                 }
-                for (AggregationParameter p : aggParams) {
+                for (Argument a : aggParams) {
                     builder.endControlFlow();
                 }
             }
@@ -483,22 +490,19 @@ private MethodSpec addRawBlock(boolean masked) {
         return builder.build();
     }
 
-    private MethodSpec.Builder initAddRaw(boolean valuesAreVector, boolean masked) {
-        MethodSpec.Builder builder = MethodSpec.methodBuilder(valuesAreVector ? "addRawVector" : "addRawBlock");
+    private MethodSpec.Builder initAddRaw(boolean blockStyle, boolean masked) {
+        MethodSpec.Builder builder = MethodSpec.methodBuilder(addRawName(blockStyle));
         builder.addModifiers(Modifier.PRIVATE);
-        for (AggregationParameter p : aggParams) {
-            builder.addParameter(
-                valuesAreVector ? vectorType(p.type) : blockType(p.type),
-                valuesAreVector ? p.vectorName() : p.blockName()
-            );
+        for (Argument a : aggParams) {
+            a.declareProcessParameter(builder, blockStyle);
         }
         if (masked) {
             builder.addParameter(BOOLEAN_VECTOR, "mask");
         }
-        for (AggregationParameter p : aggParams) {
-            if (p.isBytesRef()) {
+        for (Argument a : aggParams) {
+            if (a.isBytesRef()) {
                 // Add bytes_ref scratch var that will be used for bytes_ref blocks/vectors
-                builder.addStatement("$T $L = new $T()", BYTES_REF, p.scratchName(), BYTES_REF);
+                builder.addStatement("$T $L = new $T()", BYTES_REF, a.scratchName(), BYTES_REF);
             }
         }
         return builder;
@@ -527,9 +531,9 @@ private void invokeCombineRawInput(TypeName returnType, MethodSpec.Builder build
         } else {
             throw new IllegalArgumentException("combine must return void or a primitive");
         }
-        for (AggregationParameter p : aggParams) {
+        for (Argument a : aggParams) {
             pattern.append(", $L");
-            params.add(p.valueName());
+            params.add(a.valueName());
         }
         if (returnType.isPrimitive()) {
             pattern.append(")");
diff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/Types.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/Types.java
index 3bfb1601f7b16..82b3450343ced 100644
--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/Types.java
+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/Types.java
@@ -242,7 +242,7 @@ static ClassName vectorFixedBuilderType(TypeName elementType) {
         throw new IllegalArgumentException("unknown vector fixed builder type for [" + elementType + "]");
     }
 
-    static TypeName elementType(TypeName t) {
+    public static TypeName elementType(TypeName t) {
         if (t.equals(BOOLEAN_BLOCK) || t.equals(BOOLEAN_VECTOR) || t.equals(BOOLEAN_BLOCK_BUILDER)) {
             return TypeName.BOOLEAN;
         }
diff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/Argument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/Argument.java
index 56777ea46b985..4a2100a177e92 100644
--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/Argument.java
+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/Argument.java
@@ -17,12 +17,17 @@
 import org.elasticsearch.compute.gen.Types;
 
 import java.util.List;
+import java.util.Objects;
 
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 
+import static org.elasticsearch.compute.gen.Methods.getMethod;
+import static org.elasticsearch.compute.gen.Types.BYTES_REF;
+import static org.elasticsearch.compute.gen.Types.blockType;
+import static org.elasticsearch.compute.gen.Types.vectorType;
 import static org.elasticsearch.compute.gen.argument.StandardArgument.isBlockType;
 
 /**
@@ -45,7 +50,7 @@ static Argument fromParameter(javax.lang.model.util.Types types, VariableElement
 
         Position position = v.getAnnotation(Position.class);
         if (position != null) {
-            return new PositionArgument();
+            return new PositionArgument(type, name);
         }
 
         if (type instanceof ClassName c
@@ -64,6 +69,50 @@ static Argument fromParameter(javax.lang.model.util.Types types, VariableElement
         return new StandardArgument(type, name);
     }
 
+    default String blockName() {
+        return paramName(true);
+    }
+
+    default String vectorName() {
+        return paramName(false);
+    }
+
+    default String valueName() {
+        return name() + "Value";
+    }
+
+    default String startName() {
+        return name() + "Start";
+    }
+
+    default String endName() {
+        return name() + "End";
+    }
+
+    default String offsetName() {
+        return name() + "Offset";
+    }
+
+    default String scratchName() {
+        if (isBytesRef() == false) {
+            throw new IllegalStateException("can't build scratch for non-BytesRef");
+        }
+
+        return name() + "Scratch";
+    }
+
+    default boolean isBytesRef() {
+        return Objects.equals(type(), BYTES_REF);
+    }
+
+    String name();
+
+    TypeName type();
+
+    default TypeName elementType() {
+        return type();
+    }
+
     /**
      * Type containing the actual data for a page of values for this field. Usually a
      * Block or Vector, but for fixed fields will be the original fixed type.
@@ -121,7 +170,7 @@ static Argument fromParameter(javax.lang.model.util.Types types, VariableElement
      * call the block flavored evaluator if this is a block. Noop if the
      * parameter is {@link Fixed}.
      */
-    void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval);
+    void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval);
 
     /**
      * Create any scratch structures needed by {@code eval}.
@@ -144,6 +193,27 @@ static Argument fromParameter(javax.lang.model.util.Types types, VariableElement
      */
     void read(MethodSpec.Builder builder, boolean blockStyle);
 
+    /**
+     * Read the value of this parameter to a local variable, by calling the accessor's typed get method and passing necessary params.
+     */
+    default void read(MethodSpec.Builder builder, String accessor, String firstParam) {
+        String params = firstParam;
+        if (isBytesRef()) {
+            params += ", " + scratchName();
+        }
+        builder.addStatement("$T $L = $L.$L($L)", type(), valueName(), accessor, getMethod(type()), params);
+    }
+
+    /**
+     * Adds the parameter declaration for this argument to the method spec.
+     */
+    default void declareProcessParameter(MethodSpec.Builder builder, boolean blockStyle) {
+        TypeName typeName = elementType();
+        ClassName parameterType = blockStyle ? blockType(typeName) : vectorType(typeName);
+        String parameterName = blockStyle ? blockName() : vectorName();
+        builder.addParameter(parameterType, parameterName);
+    }
+
     /**
      * Build the invocation of the process method for this parameter.
      */
diff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/ArrayArgument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/ArrayArgument.java
index ad25985a0fc80..0ee2bf1998a74 100644
--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/ArrayArgument.java
+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/ArrayArgument.java
@@ -26,13 +26,13 @@
 import static org.elasticsearch.compute.gen.Types.blockType;
 import static org.elasticsearch.compute.gen.Types.vectorType;
 
-public record ArrayArgument(TypeName componentType, String name) implements Argument {
+public record ArrayArgument(TypeName type, String name) implements Argument {
     @Override
     public TypeName dataType(boolean blockStyle) {
         if (blockStyle) {
-            return ArrayTypeName.of(blockType(componentType));
+            return ArrayTypeName.of(blockType(type));
         }
-        return ArrayTypeName.of(vectorType(componentType));
+        return ArrayTypeName.of(vectorType(type));
     }
 
     @Override
@@ -76,7 +76,7 @@ public String factoryInvocation(MethodSpec.Builder factoryMethodBuilder) {
 
     @Override
     public void evalToBlock(MethodSpec.Builder builder) {
-        TypeName blockType = blockType(componentType);
+        TypeName blockType = blockType(type);
         builder.addStatement("$T[] $LBlocks = new $T[$L.length]", blockType, name, blockType, name);
         builder.beginControlFlow("try ($T $LRelease = $T.wrap($LBlocks))", RELEASABLE, name, RELEASABLES, name);
         builder.beginControlFlow("for (int i = 0; i < $LBlocks.length; i++)", name);
@@ -92,20 +92,21 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {
     }
 
     @Override
-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {
-        TypeName vectorType = vectorType(componentType);
+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {
+        assert invokeBlockEval != null && invokeBlockEval.length == 1;
+        TypeName vectorType = vectorType(type);
         builder.addStatement("$T[] $LVectors = new $T[$L.length]", vectorType, name, vectorType, name);
         builder.beginControlFlow("for (int i = 0; i < $LBlocks.length; i++)", name);
         builder.addStatement("$LVectors[i] = $LBlocks[i].asVector()", name, name);
-        builder.beginControlFlow("if ($LVectors[i] == null)", name).addStatement(invokeBlockEval).endControlFlow();
+        builder.beginControlFlow("if ($LVectors[i] == null)", name).addStatement(invokeBlockEval[0]).endControlFlow();
         builder.endControlFlow();
     }
 
     @Override
     public void createScratch(MethodSpec.Builder builder) {
-        builder.addStatement("$T[] $LValues = new $T[$L.length]", componentType, name, componentType, name);
-        if (componentType.equals(BYTES_REF)) {
-            builder.addStatement("$T[] $LScratch = new $T[$L.length]", componentType, name, componentType, name);
+        builder.addStatement("$T[] $LValues = new $T[$L.length]", type, name, type, name);
+        if (isBytesRef()) {
+            builder.addStatement("$T[] $LScratch = new $T[$L.length]", type, name, type, name);
             builder.beginControlFlow("for (int i = 0; i < $L.length; i++)", name);
             builder.addStatement("$LScratch[i] = new $T()", name, BYTES_REF);
             builder.endControlFlow();
@@ -135,10 +136,10 @@ public void read(MethodSpec.Builder builder, boolean blockStyle) {
         } else {
             lookupVar = "p";
         }
-        if (componentType.equals(BYTES_REF)) {
+        if (isBytesRef()) {
             builder.addStatement("$LValues[i] = $L[i].getBytesRef($L, $LScratch[i])", name, paramName(blockStyle), lookupVar, name);
         } else {
-            builder.addStatement("$LValues[i] = $L[i].$L($L)", name, paramName(blockStyle), getMethod(componentType), lookupVar);
+            builder.addStatement("$LValues[i] = $L[i].$L($L)", name, paramName(blockStyle), getMethod(type), lookupVar);
         }
         builder.endControlFlow();
     }
diff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BlockArgument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BlockArgument.java
index 8adbd7a40c2d2..13a670224e8e4 100644
--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BlockArgument.java
+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BlockArgument.java
@@ -11,6 +11,8 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 
+import org.elasticsearch.compute.gen.Types;
+
 import java.util.List;
 
 import javax.lang.model.element.Modifier;
@@ -24,6 +26,11 @@ public TypeName dataType(boolean blockStyle) {
         return type;
     }
 
+    @Override
+    public TypeName elementType() {
+        return Types.elementType(type());
+    }
+
     @Override
     public String paramName(boolean blockStyle) {
         return name + "Block";
@@ -67,7 +74,7 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {
     }
 
     @Override
-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {
+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {
         // nothing to do
     }
 
diff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BuilderArgument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BuilderArgument.java
index 4c2f335dbae66..7afaa5e89dcc6 100644
--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BuilderArgument.java
+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/BuilderArgument.java
@@ -62,7 +62,7 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {
     }
 
     @Override
-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {
+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {
         // nothing to do
     }
 
diff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/FixedArgument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/FixedArgument.java
index 2c2c24aeebd75..19d8f910bcbee 100644
--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/FixedArgument.java
+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/FixedArgument.java
@@ -84,7 +84,7 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {
     }
 
     @Override
-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {
+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {
         // nothing to do
     }
 
diff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/PositionArgument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/PositionArgument.java
index 7f40a87c68efa..92c5b9e476917 100644
--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/PositionArgument.java
+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/PositionArgument.java
@@ -16,7 +16,7 @@
 /**
  * The position in a block.
  */
-public record PositionArgument() implements Argument {
+public record PositionArgument(TypeName type, String name) implements Argument {
     @Override
     public TypeName dataType(boolean blockStyle) {
         return TypeName.INT;
@@ -64,7 +64,7 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {
     }
 
     @Override
-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {
+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {
         // nothing to do
     }
 
diff --git a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/StandardArgument.java b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/StandardArgument.java
index 217621c061e43..981e3de3f22f4 100644
--- a/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/StandardArgument.java
+++ b/x-pack/plugin/esql/compute/gen/src/main/java/org/elasticsearch/compute/gen/argument/StandardArgument.java
@@ -80,14 +80,20 @@ public void closeEvalToBlock(MethodSpec.Builder builder) {
     }
 
     @Override
-    public void resolveVectors(MethodSpec.Builder builder, String invokeBlockEval) {
+    public void resolveVectors(MethodSpec.Builder builder, String... invokeBlockEval) {
         builder.addStatement("$T $LVector = $LBlock.asVector()", vectorType(type), name, name);
-        builder.beginControlFlow("if ($LVector == null)", name).addStatement(invokeBlockEval).endControlFlow();
+        builder.beginControlFlow("if ($LVector == null)", name);
+
+        for (String statement : invokeBlockEval) {
+            builder.addStatement(statement);
+        }
+
+        builder.endControlFlow();
     }
 
     @Override
     public void createScratch(MethodSpec.Builder builder) {
-        if (type.equals(BYTES_REF)) {
+        if (isBytesRef()) {
             builder.addStatement("$T $LScratch = new $T()", BYTES_REF, name, BYTES_REF);
         }
     }
@@ -117,10 +123,9 @@ static boolean isBlockType(TypeName type) {
     @Override
     public void read(MethodSpec.Builder builder, boolean blockStyle) {
         String params = blockStyle ? paramName(true) + ".getFirstValueIndex(p)" : "p";
-        if (type.equals(BYTES_REF)) {
-            params += ", " + name + "Scratch";
+        if (isBytesRef()) {
+            params += ", " + scratchName();
         }
-
         builder.addStatement("$T $L = $L.$L($L)", type, name, paramName(blockStyle), getMethod(type), params);
     }
 
diff --git a/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentCartesianShapeDocValuesAggregatorFunction.java b/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentCartesianShapeDocValuesAggregatorFunction.java
index d6568f2d7c06e..4da958d774821 100644
--- a/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentCartesianShapeDocValuesAggregatorFunction.java
+++ b/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentCartesianShapeDocValuesAggregatorFunction.java
@@ -70,30 +70,12 @@ public void addRawInput(Page page, BooleanVector mask) {
 
   private void addRawInputMasked(Page page, BooleanVector mask) {
     IntBlock valuesBlock = page.getBlock(channels.get(0));
-    IntVector valuesVector = valuesBlock.asVector();
-    if (valuesVector == null) {
-      addRawBlock(valuesBlock, mask);
-      return;
-    }
-    addRawVector(valuesVector, mask);
+    addRawBlock(valuesBlock, mask);
   }
 
   private void addRawInputNotMasked(Page page) {
     IntBlock valuesBlock = page.getBlock(channels.get(0));
-    IntVector valuesVector = valuesBlock.asVector();
-    if (valuesVector == null) {
-      addRawBlock(valuesBlock);
-      return;
-    }
-    addRawVector(valuesVector);
-  }
-
-  private void addRawVector(IntVector valuesVector) {
-    // This type does not support vectors because all values are multi-valued
-  }
-
-  private void addRawVector(IntVector valuesVector, BooleanVector mask) {
-    // This type does not support vectors because all values are multi-valued
+    addRawBlock(valuesBlock);
   }
 
   private void addRawBlock(IntBlock valuesBlock) {
diff --git a/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentGeoShapeDocValuesAggregatorFunction.java b/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentGeoShapeDocValuesAggregatorFunction.java
index e397362159356..71ab91a86241f 100644
--- a/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentGeoShapeDocValuesAggregatorFunction.java
+++ b/x-pack/plugin/esql/compute/src/main/generated/org/elasticsearch/compute/aggregation/spatial/SpatialExtentGeoShapeDocValuesAggregatorFunction.java
@@ -72,30 +72,12 @@ public void addRawInput(Page page, BooleanVector mask) {
 
   private void addRawInputMasked(Page page, BooleanVector mask) {
     IntBlock valuesBlock = page.getBlock(channels.get(0));
-    IntVector valuesVector = valuesBlock.asVector();
-    if (valuesVector == null) {
-      addRawBlock(valuesBlock, mask);
-      return;
-    }
-    addRawVector(valuesVector, mask);
+    addRawBlock(valuesBlock, mask);
   }
 
   private void addRawInputNotMasked(Page page) {
     IntBlock valuesBlock = page.getBlock(channels.get(0));
-    IntVector valuesVector = valuesBlock.asVector();
-    if (valuesVector == null) {
-      addRawBlock(valuesBlock);
-      return;
-    }
-    addRawVector(valuesVector);
-  }
-
-  private void addRawVector(IntVector valuesVector) {
-    // This type does not support vectors because all values are multi-valued
-  }
-
-  private void addRawVector(IntVector valuesVector, BooleanVector mask) {
-    // This type does not support vectors because all values are multi-valued
+    addRawBlock(valuesBlock);
   }
 
   private void addRawBlock(IntBlock valuesBlock) {
