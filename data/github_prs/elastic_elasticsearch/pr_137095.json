{
  "id": 137095,
  "repository": "elastic/elasticsearch",
  "title": "ESQL: Add BytesRefsFromBinaryBlockLoader",
  "body": "For the blockloader for `exponential_histograms` I'd like to reuse the existing doc values BlockLoader implementations ([PR](https://github.com/elastic/elasticsearch/pulls/JonasKunz).\r\n\r\nFor unformatted `BinaryDocValues` we don't have a `BlockLoader` implementation yet, just an `AllReader` implementation (`BytesRefsFromBinary`). That reader was recently moved outside of the `server` project in https://github.com/elastic/elasticsearch/pull/137063.\r\n\r\nI'd like to reuse that to profit from potential future optimizations in the loader, so this PR introduces a reusable `BytesRefsFromBinaryBlockLoader` class.\r\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-24T15:05:21+00:00",
  "created_at": "2025-10-24T11:04:07+00:00",
  "updated_at": "2025-10-24T15:05:30+00:00",
  "author": "JonasKunz",
  "reviewers": [
    "dnhatn"
  ],
  "base_sha": "7e9049e74cdc397431bb9203595c7434d20ffca2",
  "head_sha": "f3d3203af282f04e891ad0971ab02128cf97c0d9",
  "review_comments": [
    {
      "user": "dnhatn",
      "state": "APPROVED",
      "body": "LGTM. Thanks Jonas!",
      "submitted_at": "2025-10-24T14:31:46+00:00"
    }
  ],
  "pr_comments": [
    {
      "user": "elasticsearchmachine",
      "body": "Pinging @elastic/es-analytical-engine (Team:Analytics)",
      "created_at": "2025-10-24T11:05:10+00:00"
    }
  ],
  "files_changed": [
    {
      "filename": "server/src/main/java/org/elasticsearch/index/mapper/blockloader/docvalues/BytesRefsFromBinaryBlockLoader.java",
      "status": "added",
      "additions": 70,
      "deletions": 0,
      "changes": 70,
      "patch": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.index.mapper.blockloader.docvalues;\n+\n+import org.apache.lucene.index.BinaryDocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.core.Nullable;\n+\n+import java.io.IOException;\n+\n+public class BytesRefsFromBinaryBlockLoader extends BlockDocValuesReader.DocValuesBlockLoader {\n+\n+    private final String fieldName;\n+\n+    public BytesRefsFromBinaryBlockLoader(String fieldName) {\n+        this.fieldName = fieldName;\n+    }\n+\n+    @Override\n+    public Builder builder(BlockFactory factory, int expectedCount) {\n+        return factory.bytesRefs(expectedCount);\n+    }\n+\n+    @Override\n+    public AllReader reader(LeafReaderContext context) throws IOException {\n+        BinaryDocValues docValues = context.reader().getBinaryDocValues(fieldName);\n+        return createReader(docValues);\n+    }\n+\n+    public static AllReader createReader(@Nullable BinaryDocValues docValues) {\n+        if (docValues == null) {\n+            return new ConstantNullsReader();\n+        }\n+        return new BytesRefsFromBinary(docValues);\n+    }\n+\n+    /**\n+     * Read BinaryDocValues with no additional structure in the BytesRefs.\n+     * Each BytesRef from the doc values maps directly to a value in the block loader.\n+     */\n+    static class BytesRefsFromBinary extends BytesRefsFromCustomBinaryBlockLoader.AbstractBytesRefsFromBinary {\n+\n+        BytesRefsFromBinary(BinaryDocValues docValues) {\n+            super(docValues);\n+        }\n+\n+        @Override\n+        public void read(int doc, BytesRefBuilder builder) throws IOException {\n+            if (false == docValues.advanceExact(doc)) {\n+                builder.appendNull();\n+                return;\n+            }\n+            BytesRef bytes = docValues.binaryValue();\n+            builder.appendBytesRef(bytes);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"BlockDocValuesReader.Bytes\";\n+        }\n+    }\n+}"
    },
    {
      "filename": "x-pack/plugin/logsdb/src/main/java/org/elasticsearch/xpack/logsdb/patterntext/PatternTextBlockLoader.java",
      "status": "modified",
      "additions": 2,
      "deletions": 31,
      "changes": 33,
      "patch": "@@ -7,11 +7,9 @@\n \n package org.elasticsearch.xpack.logsdb.patterntext;\n \n-import org.apache.lucene.index.BinaryDocValues;\n import org.apache.lucene.index.LeafReaderContext;\n-import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.index.mapper.blockloader.docvalues.BlockDocValuesReader;\n-import org.elasticsearch.index.mapper.blockloader.docvalues.BytesRefsFromCustomBinaryBlockLoader;\n+import org.elasticsearch.index.mapper.blockloader.docvalues.BytesRefsFromBinaryBlockLoader;\n \n import java.io.IOException;\n \n@@ -31,34 +29,7 @@ public BytesRefBuilder builder(BlockFactory factory, int expectedCount) {\n     @Override\n     public AllReader reader(LeafReaderContext context) throws IOException {\n         var docValues = docValuesSupplier.get(context.reader());\n-        if (docValues == null) {\n-            return new ConstantNullsReader();\n-        }\n-        return new BytesRefsFromBinary(docValues);\n+        return BytesRefsFromBinaryBlockLoader.createReader(docValues);\n     }\n \n-    /**\n-     * Read BinaryDocValues with no additional structure in the BytesRefs.\n-     * Each BytesRef from the doc values maps directly to a value in the block loader.\n-     */\n-    public static class BytesRefsFromBinary extends BytesRefsFromCustomBinaryBlockLoader.AbstractBytesRefsFromBinary {\n-        public BytesRefsFromBinary(BinaryDocValues docValues) {\n-            super(docValues);\n-        }\n-\n-        @Override\n-        public void read(int doc, BytesRefBuilder builder) throws IOException {\n-            if (false == docValues.advanceExact(doc)) {\n-                builder.appendNull();\n-                return;\n-            }\n-            BytesRef bytes = docValues.binaryValue();\n-            builder.appendBytesRef(bytes);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"BlockDocValuesReader.Bytes\";\n-        }\n-    }\n }"
    }
  ],
  "diff": "diff --git a/server/src/main/java/org/elasticsearch/index/mapper/blockloader/docvalues/BytesRefsFromBinaryBlockLoader.java b/server/src/main/java/org/elasticsearch/index/mapper/blockloader/docvalues/BytesRefsFromBinaryBlockLoader.java\nnew file mode 100644\nindex 0000000000000..99d2b04ca73a9\n--- /dev/null\n+++ b/server/src/main/java/org/elasticsearch/index/mapper/blockloader/docvalues/BytesRefsFromBinaryBlockLoader.java\n@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.index.mapper.blockloader.docvalues;\n+\n+import org.apache.lucene.index.BinaryDocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.core.Nullable;\n+\n+import java.io.IOException;\n+\n+public class BytesRefsFromBinaryBlockLoader extends BlockDocValuesReader.DocValuesBlockLoader {\n+\n+    private final String fieldName;\n+\n+    public BytesRefsFromBinaryBlockLoader(String fieldName) {\n+        this.fieldName = fieldName;\n+    }\n+\n+    @Override\n+    public Builder builder(BlockFactory factory, int expectedCount) {\n+        return factory.bytesRefs(expectedCount);\n+    }\n+\n+    @Override\n+    public AllReader reader(LeafReaderContext context) throws IOException {\n+        BinaryDocValues docValues = context.reader().getBinaryDocValues(fieldName);\n+        return createReader(docValues);\n+    }\n+\n+    public static AllReader createReader(@Nullable BinaryDocValues docValues) {\n+        if (docValues == null) {\n+            return new ConstantNullsReader();\n+        }\n+        return new BytesRefsFromBinary(docValues);\n+    }\n+\n+    /**\n+     * Read BinaryDocValues with no additional structure in the BytesRefs.\n+     * Each BytesRef from the doc values maps directly to a value in the block loader.\n+     */\n+    static class BytesRefsFromBinary extends BytesRefsFromCustomBinaryBlockLoader.AbstractBytesRefsFromBinary {\n+\n+        BytesRefsFromBinary(BinaryDocValues docValues) {\n+            super(docValues);\n+        }\n+\n+        @Override\n+        public void read(int doc, BytesRefBuilder builder) throws IOException {\n+            if (false == docValues.advanceExact(doc)) {\n+                builder.appendNull();\n+                return;\n+            }\n+            BytesRef bytes = docValues.binaryValue();\n+            builder.appendBytesRef(bytes);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"BlockDocValuesReader.Bytes\";\n+        }\n+    }\n+}\ndiff --git a/x-pack/plugin/logsdb/src/main/java/org/elasticsearch/xpack/logsdb/patterntext/PatternTextBlockLoader.java b/x-pack/plugin/logsdb/src/main/java/org/elasticsearch/xpack/logsdb/patterntext/PatternTextBlockLoader.java\nindex ae7c07b2fb948..f0806f0cbe73d 100644\n--- a/x-pack/plugin/logsdb/src/main/java/org/elasticsearch/xpack/logsdb/patterntext/PatternTextBlockLoader.java\n+++ b/x-pack/plugin/logsdb/src/main/java/org/elasticsearch/xpack/logsdb/patterntext/PatternTextBlockLoader.java\n@@ -7,11 +7,9 @@\n \n package org.elasticsearch.xpack.logsdb.patterntext;\n \n-import org.apache.lucene.index.BinaryDocValues;\n import org.apache.lucene.index.LeafReaderContext;\n-import org.apache.lucene.util.BytesRef;\n import org.elasticsearch.index.mapper.blockloader.docvalues.BlockDocValuesReader;\n-import org.elasticsearch.index.mapper.blockloader.docvalues.BytesRefsFromCustomBinaryBlockLoader;\n+import org.elasticsearch.index.mapper.blockloader.docvalues.BytesRefsFromBinaryBlockLoader;\n \n import java.io.IOException;\n \n@@ -31,34 +29,7 @@ public BytesRefBuilder builder(BlockFactory factory, int expectedCount) {\n     @Override\n     public AllReader reader(LeafReaderContext context) throws IOException {\n         var docValues = docValuesSupplier.get(context.reader());\n-        if (docValues == null) {\n-            return new ConstantNullsReader();\n-        }\n-        return new BytesRefsFromBinary(docValues);\n+        return BytesRefsFromBinaryBlockLoader.createReader(docValues);\n     }\n \n-    /**\n-     * Read BinaryDocValues with no additional structure in the BytesRefs.\n-     * Each BytesRef from the doc values maps directly to a value in the block loader.\n-     */\n-    public static class BytesRefsFromBinary extends BytesRefsFromCustomBinaryBlockLoader.AbstractBytesRefsFromBinary {\n-        public BytesRefsFromBinary(BinaryDocValues docValues) {\n-            super(docValues);\n-        }\n-\n-        @Override\n-        public void read(int doc, BytesRefBuilder builder) throws IOException {\n-            if (false == docValues.advanceExact(doc)) {\n-                builder.appendNull();\n-                return;\n-            }\n-            BytesRef bytes = docValues.binaryValue();\n-            builder.appendBytesRef(bytes);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"BlockDocValuesReader.Bytes\";\n-        }\n-    }\n }\n",
  "additions": 72,
  "deletions": 31,
  "changed_files": 2,
  "url": "https://github.com/elastic/elasticsearch/pull/137095",
  "mined_at": "2025-10-25T13:20:04.843427"
}