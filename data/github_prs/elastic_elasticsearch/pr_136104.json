{
  "id": 136104,
  "repository": "elastic/elasticsearch",
  "title": "ESQL: Add support for Full Text Functions and Lucene Pushable Predicates for Lookup Join",
  "body": "â€¢ Added Full Text Functions Support in Lookup Join Expressions: Extended lookup join functionality to support full-text functions like MATCH() as part of join conditions, enabling text search capabilities within lookup operations.\r\n  â€¢ Enhanced Lucene Pushable Filters Support. Implemented support for any Lucene pushable filters that contain only fields from the right side of the lookup join, allowing for more complex filtering conditions. At least one condition relating the left and right side of the Lookup Join is still required. \r\n  \r\n  \r\n**Full text function**\r\n```\r\nFROM left_table\r\n| LOOKUP JOIN right_table ON left_id == right_id AND MATCH(right_field, \"search_term\")\r\n```\r\n\r\n**OR of Lucene pushable filters on fields from the lookup index**\r\n```\r\nFROM left_table\r\n| LOOKUP JOIN right_table ON left_id == right_id AND (right_field like \"*pattern\" OR right_value > 1000)\r\n```\r\n\r\n**OR and NOT of Lucene pushable filters on fields from the lookup index**\r\n```\r\nFROM left_table\r\n| LOOKUP JOIN right_table ON (MATCH(right_field, \"search_term\") AND right_value < 5000 OR NOT (right_field != \"exclude1\" AND right_field != \"exclude2\")) AND left_id == right_id\r\n```\r\n\r\n  ",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-23T20:02:33+00:00",
  "created_at": "2025-10-07T16:04:17+00:00",
  "updated_at": "2025-10-23T20:02:34+00:00",
  "author": "julian-elastic",
  "reviewers": [
    "julian-elastic",
    "alex-spies",
    "carlosdelest",
    "nik9000"
  ],
  "base_sha": "440faee03ee04b4ab8dbf2e41afcc3cc6f0a26c0",
  "head_sha": "520fc048aa3d5570e42b5628348c48d47767acda",
  "review_comments": [
    {
      "user": "carlosdelest",
      "state": "COMMENTED",
      "body": "LGTM from the full text functions perspective ðŸ‘ :\n- Changes imply adding checks for lookup join conditions\n- IT tests have been updated with relevant tests",
      "submitted_at": "2025-10-14T07:54:22+00:00"
    },
    {
      "user": "alex-spies",
      "state": "COMMENTED",
      "body": "First round of comments: analysis",
      "submitted_at": "2025-10-16T09:08:31+00:00"
    },
    {
      "user": "alex-spies",
      "state": "COMMENTED",
      "body": "I have a question on the modeling of right-only filters, see below.",
      "submitted_at": "2025-10-16T11:53:37+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T13:03:04+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T13:04:17+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T13:10:44+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T13:23:37+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T14:22:24+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T14:31:50+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T14:57:05+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T14:58:39+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T15:05:03+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T15:26:23+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T15:37:40+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T16:30:49+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-16T18:53:32+00:00"
    },
    {
      "user": "alex-spies",
      "state": "COMMENTED",
      "body": "Productive code reviewed and looking mighty good!\r\n\r\nWrapping up the tests as well. Found some things that we need to have a look at there, but nothing that'll block this for long.\r\n\r\nI think we'll want to add the new expression joins to our generative tests, no?\r\n\r\nAlso, this generally allows all Lucene-pushable filters to be put into the `ON` condition. Some expressions might not consider this correct and will require an update of, say, the validation (as for full text functions). Maybe we should consider a randomized test that generates a pushable expression that we then stuff into the join condition? (We can compare the result by just running the `WHERE` filter on the lookup index in a separate query.)",
      "submitted_at": "2025-10-17T11:19:16+00:00"
    },
    {
      "user": "alex-spies",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T11:22:07+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T12:22:19+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T12:25:09+00:00"
    },
    {
      "user": "alex-spies",
      "state": "COMMENTED",
      "body": "Ok, all done now. This still looks very good. I found another oopsie re. the capabilities used which we should fix, but in total I think we can merge after the next iteration, most likely. Nice!",
      "submitted_at": "2025-10-17T13:15:08+00:00"
    },
    {
      "user": "alex-spies",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T13:16:28+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T17:25:53+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T17:29:16+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T17:30:23+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T17:32:15+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T17:33:51+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T17:34:08+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T17:54:22+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T17:57:40+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T17:58:00+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T18:19:24+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T18:26:28+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-17T19:02:43+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-20T14:57:16+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-20T15:44:02+00:00"
    },
    {
      "user": "julian-elastic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-20T19:57:44+00:00"
    },
    {
      "user": "nik9000",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-22T16:08:06+00:00"
    },
    {
      "user": "alex-spies",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-23T15:14:21+00:00"
    },
    {
      "user": "alex-spies",
      "state": "APPROVED",
      "body": "This is great, thanks @julian-elastic !",
      "submitted_at": "2025-10-23T15:20:09+00:00"
    }
  ],
  "pr_comments": [
    {
      "user": "elasticsearchmachine",
      "body": "Hi @julian-elastic, I've created a changelog YAML for you.",
      "created_at": "2025-10-07T16:17:17+00:00"
    },
    {
      "user": "elasticsearchmachine",
      "body": "Pinging @elastic/es-analytical-engine (Team:Analytics)",
      "created_at": "2025-10-07T16:17:17+00:00"
    },
    {
      "user": "julian-elastic",
      "body": "@vadimkibana @stratoula This PR is not making any changes to the antler grammar, but it does allow for more complex expressions as part of the lookup join on condition. Do you need any changes on your side for this? Please have this in mind when working on https://github.com/elastic/kibana/issues/236939",
      "created_at": "2025-10-22T14:07:55+00:00"
    },
    {
      "user": "stratoula",
      "body": "Thanx @julian-elastic noted!",
      "created_at": "2025-10-22T14:27:32+00:00"
    }
  ],
  "files_changed": [
    {
      "filename": "docs/changelog/136104.yaml",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "patch": "@@ -0,0 +1,5 @@\n+pr: 136104\n+summary: Add support for Full Text Functions and Lucene pushable conditions on fields from the Lookup Index for Lookup Join\n+area: ES|QL\n+type: enhancement\n+issues: [ ]"
    },
    {
      "filename": "server/src/main/resources/transport/definitions/referable/esql_lookup_join_full_text_function.csv",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "patch": "@@ -0,0 +1 @@\n+9201000"
    },
    {
      "filename": "server/src/main/resources/transport/upper_bounds/9.3.csv",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -1 +1 @@\n-inference_cached_tokens,9200000\n+esql_lookup_join_full_text_function,9201000"
    },
    {
      "filename": "test/external-modules/esql-heap-attack/src/javaRestTest/java/org/elasticsearch/xpack/esql/heap_attack/HeapAttackIT.java",
      "status": "modified",
      "additions": 16,
      "deletions": 5,
      "changes": 21,
      "patch": "@@ -861,11 +861,22 @@ private Map<String, Object> lookupExplosion(\n                 }\n             }\n             if (lookupEntries != lookupEntriesToKeep) {\n-                // add a filter to reduce the number of matches\n-                // we add both a Lucene pushable filter and a non-pushable filter\n-                // this is to make sure that even if there are non-pushable filters the pushable filters is still applied\n-                query.append(\" | WHERE ABS(filter_key) > -1 AND filter_key < \").append(lookupEntriesToKeep);\n-\n+                boolean applyAsExpressionJoinFilter = expressionBasedJoin && randomBoolean();\n+                // we randomly add the filter after the join or as part of the join\n+                // in both cases we should have the same amount of results\n+                if (applyAsExpressionJoinFilter == false) {\n+                    // add a filter after the join to reduce the number of matches\n+                    // we add both a Lucene pushable filter and a non-pushable filter\n+                    // this is to make sure that even if there are non-pushable filters the pushable filters is still applied\n+                    query.append(\" | WHERE ABS(filter_key) > -1 AND filter_key < \").append(lookupEntriesToKeep);\n+                } else {\n+                    // apply the filter as part of the join\n+                    // then we filter out the rows that do not match the filter after\n+                    // so the number of rows is the same as in the field based join case\n+                    // and can get the same number of rows for verification purposes\n+                    query.append(\" AND filter_key < \").append(lookupEntriesToKeep);\n+                    query.append(\" | WHERE filter_key IS NOT NULL \");\n+                }\n             }\n             query.append(\" | STATS COUNT(location) | LIMIT 100\\\"}\");\n             return responseAsMap(query(query.toString(), null));"
    },
    {
      "filename": "x-pack/plugin/esql/qa/security/src/javaRestTest/java/org/elasticsearch/xpack/esql/EsqlSecurityIT.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "patch": "@@ -828,7 +828,7 @@ private void testLookupJoinFieldLevelSecurityHelper(boolean useExpressionJoin) t\n         ResponseException error = expectThrows(ResponseException.class, () -> runESQLCommand(\"fls_user4_1\", query));\n         assertThat(error.getResponse().getStatusLine().getStatusCode(), equalTo(HttpStatus.SC_BAD_REQUEST));\n         if (useExpressionJoin) {\n-            assertThat(error.getMessage(), containsString(\"Unsupported join filter expression:value_left == value\"));\n+            assertThat(error.getMessage(), containsString(\"Unknown column [value], did you mean [value_left]?\"));\n         } else {\n             assertThat(error.getMessage(), containsString(\"Unknown column [value] in right side of join\"));\n         }\n@@ -902,7 +902,7 @@ private void testLookupJoinFieldLevelSecurityOnAliasHelper(boolean useExpression\n         ResponseException error = expectThrows(ResponseException.class, () -> runESQLCommand(\"fls_user4_1_alias\", query));\n         assertThat(error.getResponse().getStatusLine().getStatusCode(), equalTo(HttpStatus.SC_BAD_REQUEST));\n         if (useExpressionJoin) {\n-            assertThat(error.getMessage(), containsString(\"Unsupported join filter expression:value_left == value\"));\n+            assertThat(error.getMessage(), containsString(\"Unknown column [value], did you mean [value_left]?\"));\n         } else {\n             assertThat(error.getMessage(), containsString(\"Unknown column [value] in right side of join\"));\n         }"
    },
    {
      "filename": "x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/CsvTestsDataLoader.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "patch": "@@ -149,7 +149,9 @@ public class CsvTestsDataLoader {\n     private static final TestDataset DATE_NANOS_UNION_TYPES = new TestDataset(\"date_nanos_union_types\");\n     private static final TestDataset COUNTRIES_BBOX = new TestDataset(\"countries_bbox\");\n     private static final TestDataset COUNTRIES_BBOX_WEB = new TestDataset(\"countries_bbox_web\");\n-    private static final TestDataset AIRPORT_CITY_BOUNDARIES = new TestDataset(\"airport_city_boundaries\");\n+    private static final TestDataset AIRPORT_CITY_BOUNDARIES = new TestDataset(\"airport_city_boundaries\").withSetting(\n+        \"lookup-settings.json\"\n+    );\n     private static final TestDataset CARTESIAN_MULTIPOLYGONS = new TestDataset(\"cartesian_multipolygons\");\n     private static final TestDataset CARTESIAN_MULTIPOLYGONS_NO_DOC_VALUES = new TestDataset(\"cartesian_multipolygons_no_doc_values\")\n         .withData(\"cartesian_multipolygons.csv\");"
    },
    {
      "filename": "x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/EsqlTestUtils.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "patch": "@@ -62,9 +62,9 @@\n import org.elasticsearch.xcontent.XContentType;\n import org.elasticsearch.xcontent.json.JsonXContent;\n import org.elasticsearch.xpack.esql.action.EsqlQueryResponse;\n-import org.elasticsearch.xpack.esql.analysis.AnalyzerContext;\n import org.elasticsearch.xpack.esql.analysis.AnalyzerSettings;\n import org.elasticsearch.xpack.esql.analysis.EnrichResolution;\n+import org.elasticsearch.xpack.esql.analysis.MutableAnalyzerContext;\n import org.elasticsearch.xpack.esql.analysis.Verifier;\n import org.elasticsearch.xpack.esql.core.expression.Alias;\n import org.elasticsearch.xpack.esql.core.expression.Attribute;\n@@ -449,7 +449,7 @@ public static TransportVersion randomMinimumVersion() {\n     }\n \n     // TODO: make this even simpler, remove the enrichResolution for tests that do not require it (most tests)\n-    public static AnalyzerContext testAnalyzerContext(\n+    public static MutableAnalyzerContext testAnalyzerContext(\n         Configuration configuration,\n         EsqlFunctionRegistry functionRegistry,\n         Map<IndexPattern, IndexResolution> indexResolutions,\n@@ -462,15 +462,15 @@ public static AnalyzerContext testAnalyzerContext(\n     /**\n      * Analyzer context for a random (but compatible) minimum transport version.\n      */\n-    public static AnalyzerContext testAnalyzerContext(\n+    public static MutableAnalyzerContext testAnalyzerContext(\n         Configuration configuration,\n         EsqlFunctionRegistry functionRegistry,\n         Map<IndexPattern, IndexResolution> indexResolutions,\n         Map<String, IndexResolution> lookupResolution,\n         EnrichResolution enrichResolution,\n         InferenceResolution inferenceResolution\n     ) {\n-        return new AnalyzerContext(\n+        return new MutableAnalyzerContext(\n             configuration,\n             functionRegistry,\n             indexResolutions,"
    },
    {
      "filename": "x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/analysis/MutableAnalyzerContext.java",
      "status": "added",
      "additions": 74,
      "deletions": 0,
      "changes": 74,
      "patch": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License\n+ * 2.0; you may not use this file except in compliance with the Elastic License\n+ * 2.0.\n+ */\n+\n+package org.elasticsearch.xpack.esql.analysis;\n+\n+import org.elasticsearch.TransportVersion;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.TransportVersionUtils;\n+import org.elasticsearch.xpack.esql.expression.function.EsqlFunctionRegistry;\n+import org.elasticsearch.xpack.esql.index.IndexResolution;\n+import org.elasticsearch.xpack.esql.inference.InferenceResolution;\n+import org.elasticsearch.xpack.esql.plan.IndexPattern;\n+import org.elasticsearch.xpack.esql.session.Configuration;\n+\n+import java.util.Map;\n+\n+/**\n+ * A mutable version of AnalyzerContext that allows temporarily changing the transport version.\n+ * This is useful for testing scenarios where different transport versions need to be tested.\n+ */\n+public class MutableAnalyzerContext extends AnalyzerContext {\n+    private TransportVersion currentVersion;\n+\n+    public MutableAnalyzerContext(\n+        Configuration configuration,\n+        EsqlFunctionRegistry functionRegistry,\n+        Map<IndexPattern, IndexResolution> indexResolution,\n+        Map<String, IndexResolution> lookupResolution,\n+        EnrichResolution enrichResolution,\n+        InferenceResolution inferenceResolution,\n+        TransportVersion minimumVersion\n+    ) {\n+        super(configuration, functionRegistry, indexResolution, lookupResolution, enrichResolution, inferenceResolution, minimumVersion);\n+        this.currentVersion = minimumVersion;\n+    }\n+\n+    @Override\n+    public TransportVersion minimumVersion() {\n+        return currentVersion;\n+    }\n+\n+    /**\n+     * Temporarily set the transport version to a random version between the passed-in version and the latest,\n+     * and return an AutoCloseable to restore it.\n+     * Usage:\n+     * try (var restore = context.setTemporaryTransportVersionOnOrAfter(minVersion)) {...}\n+     */\n+    public RestoreTransportVersion setTemporaryTransportVersionOnOrAfter(TransportVersion minVersion) {\n+        TransportVersion oldVersion = this.currentVersion;\n+        // Set to a random version between minVersion and current\n+        this.currentVersion = TransportVersionUtils.randomVersionBetween(ESTestCase.random(), minVersion, TransportVersion.current());\n+        return new RestoreTransportVersion(oldVersion);\n+    }\n+\n+    /**\n+     * AutoCloseable that restores the original transport version when closed.\n+     */\n+    public class RestoreTransportVersion implements AutoCloseable {\n+        private final TransportVersion originalVersion;\n+\n+        private RestoreTransportVersion(TransportVersion originalVersion) {\n+            this.originalVersion = originalVersion;\n+        }\n+\n+        @Override\n+        public void close() {\n+            MutableAnalyzerContext.this.currentVersion = originalVersion;\n+        }\n+    }\n+}"
    },
    {
      "filename": "x-pack/plugin/esql/qa/testFixtures/src/main/resources/lookup-join-expression.csv-spec",
      "status": "modified",
      "additions": 504,
      "deletions": 0,
      "changes": 504,
      "patch": "@@ -725,6 +725,9 @@ id_int:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:int\n 14             | Nina             | foo2           | omicron        | 15000\n ;\n \n+\n+\n+\n lookupJoinExpressionOnUnionTypes\n required_capability: join_lookup_v12\n required_capability: lookup_join_on_boolean_expression\n@@ -747,3 +750,504 @@ apps           | 2                     | French\n apps_short     | 1                     | English\n apps_short     | 2                     | French\n ;\n+\n+lookupJoinWithGreaterThanCondition\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON id_int == id_left and is_active_left == is_active_bool AND other2 > 10000\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON id_int == id_left and is_active_left == is_active_bool AND other2 > 10000] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | null             | foo            | null           | null\n+[1, 19, 21]     | null             | zyx            | null           | null\n+2               | null             | bar            | null           | null\n+3               | null             | baz            | null           | null\n+4               | null             | qux            | null           | null\n+5               | null             | quux           | null           | null\n+6               | null             | corge          | null           | null\n+7               | null             | grault         | null           | null\n+8               | Hank             | garply         | lambda         | 11000\n+9               | null             | waldo          | null           | null\n+10              | null             | fred           | null           | null\n+12              | Liam             | xyzzy          | nu             | 13000\n+13              | Mia              | thud           | xi             | 14000\n+14              | Nina             | foo2           | omicron        | 15000\n+15              | null             | bar2           | null           | null\n+[17, 18]        | null             | xyz            | null           | null\n+null            | null             | plugh          | null           | null\n+;\n+\n+lookupJoinWithLikeCondition\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON id_int == id_left and is_active_left == is_active_bool AND other1 like \"*ta\"\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON id_int == id_left and is_active_left == is_active_bool AND other1 like \\\"*ta\\\"] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+[1, 19, 21]     | null             | zyx            | null           | null\n+2               | null             | bar            | null           | null\n+3               | Charlie          | baz            | delta          | 4000\n+4               | David            | qux            | zeta           | 6000\n+5               | Eve              | quux           | eta            | 7000\n+5               | Eve              | quux           | theta          | 8000\n+6               | null             | corge          | iota           | 9000\n+7               | null             | grault         | null           | null\n+8               | null             | garply         | null           | null\n+9               | null             | waldo          | null           | null\n+10              | null             | fred           | null           | null\n+12              | null             | xyzzy          | null           | null\n+13              | null             | thud           | null           | null\n+14              | null             | foo2           | null           | null\n+15              | null             | bar2           | null           | null\n+[17, 18]        | null             | xyz            | null           | null\n+null            | null             | plugh          | null           | null\n+;\n+\n+lookupJoinWithOrOfLikeGt\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON id_int == id_left and is_active_left == is_active_bool AND (other1 like \"*ta\" OR other2 > 10000)\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON id_int == id_left and is_active_left == is_active_bool AND (other1 like \\\"*ta\\\" OR other2 > 10000)] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+[1, 19, 21]     | null             | zyx            | null           | null\n+2               | null             | bar            | null           | null\n+3               | Charlie          | baz            | delta          | 4000\n+4               | David            | qux            | zeta           | 6000\n+5               | Eve              | quux           | eta            | 7000\n+5               | Eve              | quux           | theta          | 8000\n+6               | null             | corge          | iota           | 9000\n+7               | null             | grault         | null           | null\n+8               | Hank             | garply         | lambda         | 11000\n+9               | null             | waldo          | null           | null\n+10              | null             | fred           | null           | null\n+12              | Liam             | xyzzy          | nu             | 13000\n+13              | Mia              | thud           | xi             | 14000\n+14              | Nina             | foo2           | omicron        | 15000\n+15              | null             | bar2           | null           | null\n+[17, 18]        | null             | xyz            | null           | null\n+null            | null             | plugh          | null           | null\n+;\n+\n+lookupJoinExpressionWithMatch\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON MATCH(other1, \"beta\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON MATCH(other1, \\\"beta\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+;\n+\n+lookupJoinOnSameFieldTwiceWithOrNot\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, name_str AS name_left, is_active_bool AS is_active_left, ip_addr AS ip_addr_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON (other2 < 12000 OR NOT (other1 != \"omicron\" AND other1 != \"nu\")) AND id_left == id_int AND  name_left == name_str AND  id_left < other2\n+| KEEP id_left, name_left, extra1, other1, other2\n+| SORT id_left, name_left, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON (other2 < 12000 OR NOT (other1 != \\\"omicron\\\" AND other1 != \\\"nu\\\")) AND id_left == id_int AND  name_left == name_str AND  id_left < other2] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_left:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice             | foo            | alpha          | 1000\n+1               | Alice             | foo            | beta           | 2000\n+[1, 19, 21]     | Sophia            | zyx            | null           | null\n+2               | Bob               | bar            | gamma          | 3000\n+3               | Charlie           | baz            | delta          | 4000\n+3               | Charlie           | baz            | epsilon        | 5000\n+4               | David             | qux            | zeta           | 6000\n+5               | Eve               | quux           | eta            | 7000\n+5               | Eve               | quux           | theta          | 8000\n+6               | null              | corge          | null           | null\n+7               | Grace             | grault         | kappa          | 10000\n+8               | Hank              | garply         | lambda         | 11000\n+9               | Ivy               | waldo          | null           | null\n+10              | John              | fred           | null           | null\n+12              | Liam              | xyzzy          | nu             | 13000\n+13              | Mia               | thud           | null           | null\n+14              | Nina              | foo2           | omicron        | 15000\n+15              | Oscar             | bar2           | null           | null\n+[17, 18]        | Olivia            | xyz            | null           | null\n+null            | Kate              | plugh          | null           | null\n+;\n+\n+\n+lookupJoinOnSameFieldWithPushableRightFilterAfter\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, name_str AS name_left, is_active_bool AS is_active_left, ip_addr AS ip_addr_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON (other2 < 12000 OR NOT (other1 != \"omicron\" AND other1 != \"nu\")) AND id_left == id_int AND  name_left == name_str AND  id_left < other2\n+| WHERE other1 like (\"a*\", \"b*\", \"o*\")\n+| KEEP id_left, name_left, extra1, other1, other2\n+| SORT id_left, name_left, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON (other2 < 12000 OR NOT (other1 != \\\"omicron\\\" AND other1 != \\\"nu\\\")) AND id_left == id_int AND  name_left == name_str AND  id_left < other2] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_left:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice             | foo            | alpha          | 1000\n+1               | Alice             | foo            | beta           | 2000\n+14              | Nina              | foo2           | omicron        | 15000\n+;\n+\n+twoLookupJoinsInSameQueryOtherFilter\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| WHERE id_int == 1\n+| RENAME id_int AS id_left, name_str AS name_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON id_left == id_int AND name_left == name_str\n+| RENAME other1 AS other1_from_first_join, id_int AS id_from_first_join, name_str AS name_from_first_join\n+| LOOKUP JOIN multi_column_joinable_lookup ON id_left == id_int AND other1_from_first_join != other1 AND other1 like (\"a*\", \"c*\")\n+| KEEP id_left, name_left, other1_from_first_join, other1\n+| SORT id_left, name_left, other1_from_first_join, other1\n+;\n+\n+warning:Line 2:9: evaluation of [id_int == 1] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 2:9: java.lang.IllegalArgumentException: single-value function encountered multi-value\n+\n+id_left:integer | name_left:keyword | other1_from_first_join:keyword | other1:keyword\n+1               | Alice             | alpha                          | null\n+1               | Alice             | beta                           | alpha\n+;\n+\n+lookupJoinExpressionWithTerm\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON TERM(other1, \"beta\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON TERM(other1, \\\"beta\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+;\n+\n+lookupJoinExpressionWithQueryString\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON QSTR(\"other1:alpha OR other1:beta\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON QSTR(\\\"other1:alpha OR other1:beta\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | alpha          | 1000\n+1               | Alice            | foo            | beta           | 2000\n+;\n+\n+lookupJoinExpressionWithKql\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON KQL(\"other1:alpha OR other1:beta\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON KQL(\\\"other1:alpha OR other1:beta\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | alpha          | 1000\n+1               | Alice            | foo            | beta           | 2000\n+;\n+\n+lookupJoinExpressionWithMultiMatch\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left, name_str AS name_str_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON MULTI_MATCH(\"beta\", other1, name_str) AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON MULTI_MATCH(\\\"beta\\\", other1, name_str) AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+;\n+\n+lookupJoinExpressionWithMatchPhrase\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON MATCH_PHRASE(other1, \"beta\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON MATCH_PHRASE(other1, \\\"beta\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+;\n+\n+lookupJoinExpressionWithCidrMatch\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left, ip_addr AS ip_addr_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON CIDR_MATCH(ip_addr, \"192.168.1.0/30\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2, ip_addr\n+| SORT id_left, name_str, extra1, other1, other2, ip_addr\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON CIDR_MATCH(ip_addr, \\\"192.168.1.0/30\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer | ip_addr:ip\n+1               | Alice            | foo            | alpha          | 1000           | 192.168.1.1\n+1               | Alice            | foo            | beta           | 2000           | 192.168.1.2\n+2               | Bob              | bar            | gamma          | 3000           | 192.168.1.3\n+3               | Charlie          | baz            | delta          | 4000           | 192.168.1.3\n+;\n+\n+lookupJoinExpressionWithIn\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON other1 IN (\"alpha\", \"beta\", \"gamma\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON other1 IN (\\\"alpha\\\", \\\"beta\\\", \\\"gamma\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | alpha          | 1000\n+1               | Alice            | foo            | beta           | 2000\n+2               | Bob              | bar            | gamma          | 3000\n+;\n+\n+lookupJoinExpressionWithIsNull\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON other1 IS NULL AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON other1 IS NULL AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+;\n+\n+lookupJoinExpressionWithIsNotNull\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON other1 IS NOT NULL AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON other1 IS NOT NULL AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | alpha          | 1000\n+1               | Alice            | foo            | beta           | 2000\n+2               | Bob              | bar            | gamma          | 3000\n+3               | Charlie          | baz            | delta          | 4000\n+4               | David            | qux            | zeta           | 6000\n+5               | Eve              | quux           | eta            | 7000\n+5               | Eve              | quux           | theta          | 8000\n+6               | null             | corge          | iota           | 9000\n+7               | Grace            | grault         | kappa          | 10000\n+8               | Hank             | garply         | lambda         | 11000\n+12              | Liam             | xyzzy          | nu             | 13000\n+13              | Mia              | thud           | xi             | 14000\n+14              | Nina             | foo2           | omicron        | 15000\n+;\n+\n+lookupJoinExpressionWithStartsWith\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON STARTS_WITH(other1, \"al\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON STARTS_WITH(other1, \\\"al\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | alpha          | 1000\n+;\n+\n+lookupJoinExpressionWithEndsWith\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON ENDS_WITH(other1, \"ta\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON ENDS_WITH(other1, \\\"ta\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+3               | Charlie          | baz            | delta          | 4000\n+4               | David            | qux            | zeta           | 6000\n+5               | Eve              | quux           | eta            | 7000\n+5               | Eve              | quux           | theta          | 8000\n+6               | null             | corge          | iota           | 9000\n+;\n+\n+lookupJoinExpressionWithAirportIntersects\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM airports\n+| RENAME abbrev AS airport_code\n+| LOOKUP JOIN airport_city_boundaries ON airport_code == abbrev AND ST_INTERSECTS(TO_GEOSHAPE(\"POLYGON((-74.5 40.4, -73.5 40.4, -73.5 41.0, -74.5 41.0, -74.5 40.4))\"), city_boundary)\n+| WHERE city is not null\n+| KEEP airport_code, name, city, country, city_boundary\n+| SORT airport_code, name, city, country\n+;\n+\n+airport_code:keyword | name:text | city:keyword | country:keyword | city_boundary:geo_shape\n+EWR                  | Newark Int'l         | New York     | United States   | POLYGON ((-74.2588 40.4989, -74.2253 40.4766, -73.9779 40.5191, -73.9021 40.4921, -73.8126 40.53, -73.7572 40.5312, -73.7565 40.5862, -73.7381 40.6026, -73.7681 40.6263, -73.7248 40.6523, -73.7303 40.7222, -73.7002 40.7393, -73.7797 40.8121, -73.7484 40.8718, -73.8382 40.8941, -73.8511 40.9101, -73.8593 40.9005, -73.9183 40.9176, -74.014 40.7576, -74.0558 40.6515, -74.1914 40.642, -74.2146 40.5605, -74.2475 40.5494, -74.2588 40.4989))\n+JFK                  | John F Kennedy Int'l | New York     | United States   | POLYGON ((-74.2588 40.4989, -74.2253 40.4766, -73.9779 40.5191, -73.9021 40.4921, -73.8126 40.53, -73.7572 40.5312, -73.7565 40.5862, -73.7381 40.6026, -73.7681 40.6263, -73.7248 40.6523, -73.7303 40.7222, -73.7002 40.7393, -73.7797 40.8121, -73.7484 40.8718, -73.8382 40.8941, -73.8511 40.9101, -73.8593 40.9005, -73.9183 40.9176, -74.014 40.7576, -74.0558 40.6515, -74.1914 40.642, -74.2146 40.5605, -74.2475 40.5494, -74.2588 40.4989))\n+LGA                  | LaGuardia            | New York     | United States   | POLYGON ((-74.2588 40.4989, -74.2253 40.4766, -73.9779 40.5191, -73.9021 40.4921, -73.8126 40.53, -73.7572 40.5312, -73.7565 40.5862, -73.7381 40.6026, -73.7681 40.6263, -73.7248 40.6523, -73.7303 40.7222, -73.7002 40.7393, -73.7797 40.8121, -73.7484 40.8718, -73.8382 40.8941, -73.8511 40.9101, -73.8593 40.9005, -73.9183 40.9176, -74.014 40.7576, -74.0558 40.6515, -74.1914 40.642, -74.2146 40.5605, -74.2475 40.5494, -74.2588 40.4989))\n+;\n+\n+lookupJoinExpressionWithAirportWithin\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM airports\n+| RENAME abbrev AS airport_code\n+| LOOKUP JOIN airport_city_boundaries ON airport_code == abbrev AND ST_INTERSECTS(TO_GEOSHAPE(\"POLYGON((-0.5 51.4, -0.2 51.4, -0.2 51.5, -0.5 51.5, -0.5 51.4))\"), city_boundary)\n+| WHERE city is not null\n+| KEEP airport_code, name, city, country, city_boundary\n+| SORT airport_code, name, city, country\n+;\n+\n+airport_code:keyword | name:text | city:keyword | country:keyword | city_boundary:geo_shape\n+LHR                  | London Heathrow | Hounslow | United Kingdom | POLYGON((-0.4615 51.449, -0.3855 51.4206, -0.3668 51.4416, -0.3878 51.4494, -0.327 51.457, -0.2921 51.4873, -0.2565 51.4715, -0.2444 51.4979, -0.4092 51.5003, -0.4112 51.4699, -0.4615 51.449))\n+;\n+\n+lookupJoinExpressionWithAirportContains\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM airports\n+| RENAME abbrev AS airport_code\n+| LOOKUP JOIN airport_city_boundaries ON airport_code == abbrev AND ST_CONTAINS(TO_GEOSHAPE(\"POLYGON((-0.3 51.0, -0.1 51.0, -0.1 51.2, -0.3 51.2, -0.3 51.0))\"), city_boundary)\n+| WHERE city is not null\n+| KEEP airport_code, name, city, country, city_boundary\n+| SORT airport_code, name, city, country\n+;\n+\n+airport_code:keyword | name:text | city:keyword | country:keyword | city_boundary:geo_shape\n+LGW                  | London Gatwick | Crawley | United Kingdom | POLYGON((-0.2556 51.1418, -0.2003 51.1391, -0.2369 51.1094, -0.1964 51.0848, -0.1395 51.1081, -0.133 51.1589, -0.1785 51.1672, -0.2556 51.1418))\n+;\n+\n+lookupJoinExpressionWithAirportGeoPoint\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM airports\n+| RENAME abbrev AS airport_code\n+| LOOKUP JOIN airport_city_boundaries ON airport_code == abbrev AND ST_INTERSECTS(TO_GEOPOINT(\"POINT(-0.376227267397439 51.8802952570969)\"), city_boundary)\n+| WHERE city is not null\n+| KEEP airport_code, name, city, country, location, city_boundary\n+| SORT airport_code, name, city, country\n+;\n+\n+airport_code:keyword | name:text | city:keyword | country:keyword | location:geo_point | city_boundary:geo_shape\n+LTN                  | London Luton | Luton | United Kingdom | POINT(-0.376227267397439 51.8802952570969) | POLYGON((-0.5059 51.9006, -0.4225 51.8545, -0.3499 51.8787, -0.3856 51.9157, -0.4191 51.9123, -0.4263 51.9267, -0.4857 51.9227, -0.4823 51.9078, -0.5059 51.9006))\n+;"
    },
    {
      "filename": "x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/action/LookupFromIndexIT.java",
      "status": "modified",
      "additions": 27,
      "deletions": 13,
      "changes": 40,
      "patch": "@@ -250,7 +250,7 @@ private PhysicalPlan buildGreaterThanFilter(long value) {\n         return new FragmentExec(filter);\n     }\n \n-    private void runLookup(List<DataType> keyTypes, PopulateIndices populateIndices, PhysicalPlan filters) throws IOException {\n+    private void runLookup(List<DataType> keyTypes, PopulateIndices populateIndices, PhysicalPlan pushedDownFilter) throws IOException {\n         String[] fieldMappers = new String[keyTypes.size() * 2];\n         for (int i = 0; i < keyTypes.size(); i++) {\n             fieldMappers[2 * i] = \"key\" + i;\n@@ -283,17 +283,8 @@ private void runLookup(List<DataType> keyTypes, PopulateIndices populateIndices,\n         client().admin().cluster().prepareHealth(TEST_REQUEST_TIMEOUT).setWaitForGreenStatus().get();\n \n         Predicate<Integer> filterPredicate = l -> true;\n-        if (filters instanceof FragmentExec fragmentExec) {\n-            if (fragmentExec.fragment() instanceof Filter filter\n-                && filter.condition() instanceof GreaterThan gt\n-                && gt.left() instanceof FieldAttribute fa\n-                && fa.name().equals(\"l\")\n-                && gt.right() instanceof Literal lit) {\n-                long value = ((Number) lit.value()).longValue();\n-                filterPredicate = l -> l > value;\n-            } else {\n-                fail(\"Unsupported filter type in test baseline generation: \" + filters);\n-            }\n+        if (pushedDownFilter instanceof FragmentExec fragmentExec && fragmentExec.fragment() instanceof Filter filter) {\n+            filterPredicate = getPredicateFromFilter(filter);\n         }\n \n         int docCount = between(10, 1000);\n@@ -396,6 +387,16 @@ private void runLookup(List<DataType> keyTypes, PopulateIndices populateIndices,\n                         new EsField(\"rkey\" + i, keyTypes.get(i), Collections.emptyMap(), true, EsField.TimeSeriesFieldType.NONE)\n                     );\n                     joinOnConditions.add(new Equals(Source.EMPTY, leftAttr, rightAttr));\n+                    // randomly decide to apply the filter as additional join on filter instead of pushed down filter\n+                    boolean applyAsJoinOnCondition = EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+                        ? randomBoolean()\n+                        : false;\n+                    if (applyAsJoinOnCondition\n+                        && pushedDownFilter instanceof FragmentExec fragmentExec\n+                        && fragmentExec.fragment() instanceof Filter filter) {\n+                        joinOnConditions.add(filter.condition());\n+                        pushedDownFilter = null;\n+                    }\n                 }\n             }\n             // the matchFields are shared for both types of join\n@@ -412,7 +413,7 @@ private void runLookup(List<DataType> keyTypes, PopulateIndices populateIndices,\n                 \"lookup\",\n                 List.of(new Alias(Source.EMPTY, \"l\", new ReferenceAttribute(Source.EMPTY, \"l\", DataType.LONG))),\n                 Source.EMPTY,\n-                filters,\n+                pushedDownFilter,\n                 Predicates.combineAnd(joinOnConditions)\n             );\n             DriverContext driverContext = driverContext();\n@@ -478,6 +479,19 @@ protected void start(Driver driver, ActionListener<Void> driverListener) {\n         }\n     }\n \n+    private static Predicate<Integer> getPredicateFromFilter(Filter filter) {\n+        if (filter.condition() instanceof GreaterThan gt\n+            && gt.left() instanceof FieldAttribute fa\n+            && fa.name().equals(\"l\")\n+            && gt.right() instanceof Literal lit) {\n+            long value = ((Number) lit.value()).longValue();\n+            return l -> l > value;\n+        } else {\n+            fail(\"Unsupported filter type in test baseline generation: \" + filter);\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Creates a {@link BigArrays} that tracks releases but doesn't throw circuit breaking exceptions.\n      */"
    },
    {
      "filename": "x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/plugin/MatchFunctionIT.java",
      "status": "modified",
      "additions": 35,
      "deletions": 0,
      "changes": 35,
      "patch": "@@ -313,6 +313,27 @@ public void testMatchWithLookupJoin() {\n         );\n     }\n \n+    public void testMatchWithLookupJoinOnMatch() {\n+        var query = \"\"\"\n+            FROM test\n+            | rename id as id_left\n+            | LOOKUP JOIN test_lookup ON id_left == id and MATCH(lookup_content, \"fox\")\n+            | WHERE id > 0\n+            \"\"\";\n+        try (var resp = run(query)) {\n+            assertColumnNames(resp.columns(), List.of(\"content\", \"id_left\", \"id\", \"lookup_content\"));\n+            assertColumnTypes(resp.columns(), List.of(\"text\", \"integer\", \"integer\", \"text\"));\n+            // Should return rows where lookup_content matches \"fox\" (ids 1 and 6)\n+            assertValues(\n+                resp.values(),\n+                List.of(\n+                    List.of(\"This is a brown fox\", 1, 1, \"This is a brown fox\"),\n+                    List.of(\"The quick brown fox jumps over the lazy dog\", 6, 6, \"The quick brown fox jumps over the lazy dog\")\n+                )\n+            );\n+        }\n+    }\n+\n     static void createAndPopulateIndex(Consumer<String[]> ensureYellow) {\n         var indexName = \"test\";\n         var client = client().admin().indices();\n@@ -341,5 +362,19 @@ static void createAndPopulateLookupIndex(IndicesAdminClient client, String looku\n             .setSettings(Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.mode\", \"lookup\"))\n             .setMapping(\"id\", \"type=integer\", \"lookup_content\", \"type=text\");\n         assertAcked(createRequest);\n+\n+        // Populate the lookup index with test data\n+        client().prepareBulk()\n+            .add(new IndexRequest(lookupIndexName).id(\"1\").source(\"id\", 1, \"lookup_content\", \"This is a brown fox\"))\n+            .add(new IndexRequest(lookupIndexName).id(\"2\").source(\"id\", 2, \"lookup_content\", \"This is a brown dog\"))\n+            .add(new IndexRequest(lookupIndexName).id(\"3\").source(\"id\", 3, \"lookup_content\", \"This dog is really brown\"))\n+            .add(\n+                new IndexRequest(lookupIndexName).id(\"4\")\n+                    .source(\"id\", 4, \"lookup_content\", \"The dog is brown but this document is very very long\")\n+            )\n+            .add(new IndexRequest(lookupIndexName).id(\"5\").source(\"id\", 5, \"lookup_content\", \"There is also a white cat\"))\n+            .add(new IndexRequest(lookupIndexName).id(\"6\").source(\"id\", 6, \"lookup_content\", \"The quick brown fox jumps over the lazy dog\"))\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n+            .get();\n     }\n }"
    },
    {
      "filename": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "patch": "@@ -1411,7 +1411,11 @@ public enum Cap {\n          * Allow lookup join on boolean expressions\n          */\n         LOOKUP_JOIN_ON_BOOLEAN_EXPRESSION,\n-\n+        /**\n+         * Lookup join with Full Text Function or other Lucene Pushable condition\n+         * to be applied to the lookup index used\n+         */\n+        LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION,\n         /**\n          * FORK with remote indices\n          */"
    },
    {
      "filename": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/analysis/Analyzer.java",
      "status": "modified",
      "additions": 106,
      "deletions": 44,
      "changes": 150,
      "patch": "@@ -7,6 +7,7 @@\n \n package org.elasticsearch.xpack.esql.analysis;\n \n+import org.elasticsearch.TransportVersion;\n import org.elasticsearch.common.logging.HeaderWarning;\n import org.elasticsearch.common.logging.LoggerMessageFormat;\n import org.elasticsearch.common.lucene.BytesRefs;\n@@ -21,6 +22,7 @@\n import org.elasticsearch.xpack.esql.EsqlIllegalArgumentException;\n import org.elasticsearch.xpack.esql.VerificationException;\n import org.elasticsearch.xpack.esql.analysis.AnalyzerRules.ParameterizedAnalyzerRule;\n+import org.elasticsearch.xpack.esql.capabilities.TranslationAware;\n import org.elasticsearch.xpack.esql.common.Failure;\n import org.elasticsearch.xpack.esql.core.capabilities.Resolvables;\n import org.elasticsearch.xpack.esql.core.expression.Alias;\n@@ -102,6 +104,7 @@\n import org.elasticsearch.xpack.esql.index.IndexResolution;\n import org.elasticsearch.xpack.esql.inference.ResolvedInference;\n import org.elasticsearch.xpack.esql.optimizer.rules.logical.SubstituteSurrogateExpressions;\n+import org.elasticsearch.xpack.esql.optimizer.rules.physical.local.LucenePushdownPredicates;\n import org.elasticsearch.xpack.esql.parser.ParsingException;\n import org.elasticsearch.xpack.esql.plan.IndexPattern;\n import org.elasticsearch.xpack.esql.plan.logical.Aggregate;\n@@ -162,6 +165,7 @@\n import static java.util.Collections.emptyList;\n import static java.util.Collections.singletonList;\n import static org.elasticsearch.xpack.core.enrich.EnrichPolicy.GEO_MATCH_TYPE;\n+import static org.elasticsearch.xpack.esql.capabilities.TranslationAware.translatable;\n import static org.elasticsearch.xpack.esql.core.type.DataType.AGGREGATE_METRIC_DOUBLE;\n import static org.elasticsearch.xpack.esql.core.type.DataType.BOOLEAN;\n import static org.elasticsearch.xpack.esql.core.type.DataType.DATETIME;\n@@ -217,6 +221,9 @@ public class Analyzer extends ParameterizedRuleExecutor<LogicalPlan, AnalyzerCon\n         ),\n         new Batch<>(\"Finish Analysis\", Limiter.ONCE, new AddImplicitLimit(), new AddImplicitForkLimit(), new UnionTypesCleanup())\n     );\n+    public static final TransportVersion ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION = TransportVersion.fromName(\n+        \"esql_lookup_join_full_text_function\"\n+    );\n \n     private final Verifier verifier;\n \n@@ -532,7 +539,7 @@ protected LogicalPlan rule(LogicalPlan plan, AnalyzerContext context) {\n             }\n \n             if (plan instanceof LookupJoin j) {\n-                return resolveLookupJoin(j);\n+                return resolveLookupJoin(j, context);\n             }\n \n             if (plan instanceof Insist i) {\n@@ -721,55 +728,114 @@ private LogicalPlan resolveLookup(Lookup l, List<Attribute> childrenOutput) {\n             return l;\n         }\n \n-        private List<Expression> resolveJoinFiltersAndSwapIfNeeded(\n-            List<Expression> filters,\n-            AttributeSet leftOutput,\n-            AttributeSet rightOutput\n+        private Expression resolveJoinFiltersAndSwapIfNeeded(\n+            Expression joinOnCondition,\n+            AttributeSet leftChildOutput,\n+            AttributeSet rightChildOutput,\n+            List<Attribute> leftJoinKeysToPopulate,\n+            List<Attribute> rightJoinKeysToPopulate,\n+            AnalyzerContext context\n         ) {\n-            if (filters.isEmpty()) {\n-                return emptyList();\n+            if (joinOnCondition == null) {\n+                return joinOnCondition;\n             }\n-            List<Attribute> childrenOutput = new ArrayList<>(leftOutput);\n-            childrenOutput.addAll(rightOutput);\n+            List<Expression> filters = Predicates.splitAnd(joinOnCondition);\n+            List<Attribute> childrenOutput = new ArrayList<>(leftChildOutput);\n+            childrenOutput.addAll(rightChildOutput);\n \n             List<Expression> resolvedFilters = new ArrayList<>(filters.size());\n             for (Expression filter : filters) {\n                 Expression filterResolved = filter.transformUp(UnresolvedAttribute.class, ua -> maybeResolveAttribute(ua, childrenOutput));\n-                resolvedFilters.add(resolveAndOrientJoinCondition(filterResolved, leftOutput, rightOutput));\n+                // Check if the filterResolved contains unresolved attributes, if it does, we cannot process it further\n+                // and the error message about the unresolved attribute is already appropriate\n+                if (filterResolved.anyMatch(UnresolvedAttribute.class::isInstance)) {\n+                    resolvedFilters.add(filterResolved);\n+                    continue;\n+                }\n+                Expression result = resolveAndOrientJoinCondition(\n+                    filterResolved,\n+                    leftChildOutput,\n+                    rightChildOutput,\n+                    leftJoinKeysToPopulate,\n+                    rightJoinKeysToPopulate,\n+                    context\n+                );\n+                resolvedFilters.add(result);\n             }\n-            return resolvedFilters;\n+            return Predicates.combineAndWithSource(resolvedFilters, joinOnCondition.source());\n         }\n \n-        private Expression resolveAndOrientJoinCondition(Expression condition, AttributeSet leftOutput, AttributeSet rightOutput) {\n+        /**\n+         * This function resolves and orients a single join on condition.\n+         * We support AND of such conditions, here we handle a single child of the AND\n+         * We support the following 2 cases:\n+         * 1) Binary comparisons between a left and a right attribute.\n+         * We resolve all attributes and orient them so that the attribute on the left side of the join\n+         * is on the left side of the binary comparison\n+         *  and the attribute from the lookup index is on the right side of the binary comparison\n+         * 2) A Lucene pushable expression containing only attributes from the lookup side of the join\n+         * We resolve all attributes in the expression, verify they are from the right side of the join\n+         * and also verify that the expression is potentially Lucene pushable\n+         */\n+        private Expression resolveAndOrientJoinCondition(\n+            Expression condition,\n+            AttributeSet leftChildOutput,\n+            AttributeSet rightChildOutput,\n+            List<Attribute> leftJoinKeysToPopulate,\n+            List<Attribute> rightJoinKeysToPopulate,\n+            AnalyzerContext context\n+        ) {\n             if (condition instanceof EsqlBinaryComparison comp\n                 && comp.left() instanceof Attribute leftAttr\n                 && comp.right() instanceof Attribute rightAttr) {\n \n-                boolean leftIsFromLeft = leftOutput.contains(leftAttr);\n-                boolean rightIsFromRight = rightOutput.contains(rightAttr);\n+                boolean leftIsFromLeft = leftChildOutput.contains(leftAttr);\n+                boolean rightIsFromRight = rightChildOutput.contains(rightAttr);\n \n                 if (leftIsFromLeft && rightIsFromRight) {\n+                    leftJoinKeysToPopulate.add(leftAttr);\n+                    rightJoinKeysToPopulate.add(rightAttr);\n                     return comp; // Correct orientation\n                 }\n \n-                boolean leftIsFromRight = rightOutput.contains(leftAttr);\n-                boolean rightIsFromLeft = leftOutput.contains(rightAttr);\n+                boolean leftIsFromRight = rightChildOutput.contains(leftAttr);\n+                boolean rightIsFromLeft = leftChildOutput.contains(rightAttr);\n \n                 if (leftIsFromRight && rightIsFromLeft) {\n+                    leftJoinKeysToPopulate.add(rightAttr);\n+                    rightJoinKeysToPopulate.add(leftAttr);\n                     return comp.swapLeftAndRight(); // Swapped orientation\n                 }\n+            }\n+            if (context.minimumVersion().onOrAfter(ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION) == false) {\n                 return new UnresolvedAttribute(\n                     condition.source(),\n                     \"unsupported\",\n-                    \"Join condition must be between one attribute on the left side and \"\n-                        + \"one attribute on the right side of the join, but found: \"\n+                    \"Lookup join on condition is not supported on the remote node,\"\n+                        + \" consider upgrading the remote node. Unsupported join filter expression:\"\n                         + condition.sourceText()\n                 );\n             }\n-            return condition; // Not a binary comparison between two attributes, no change needed.\n+            return handleRightOnlyPushableFilter(condition, rightChildOutput);\n+        }\n+\n+        private Expression handleRightOnlyPushableFilter(Expression condition, AttributeSet rightChildOutput) {\n+            if (isCompletelyRightSideAndTranslatable(condition, rightChildOutput)) {\n+                // The condition is completely on the right side and is translation aware, so it can be (potentially) pushed down\n+                return condition;\n+            } else {\n+                // The condition cannot be used in the join on clause for now\n+                // It is not a binary comparison between left and right attributes\n+                // It is not using fields from the right side only and translation aware\n+                return new UnresolvedAttribute(\n+                    condition.source(),\n+                    \"unsupported\",\n+                    \"Unsupported join filter expression:\" + condition.sourceText()\n+                );\n+            }\n         }\n \n-        private Join resolveLookupJoin(LookupJoin join) {\n+        private Join resolveLookupJoin(LookupJoin join, AnalyzerContext context) {\n             JoinConfig config = join.config();\n             // for now, support only (LEFT) USING clauses\n             JoinType type = config.type();\n@@ -785,38 +851,22 @@ private Join resolveLookupJoin(LookupJoin join) {\n                 }\n                 List<Attribute> leftKeys = new ArrayList<>();\n                 List<Attribute> rightKeys = new ArrayList<>();\n-                List<Expression> resolvedFilters = new ArrayList<>();\n+                Expression joinOnConditions = null;\n                 if (join.config().joinOnConditions() != null) {\n-                    resolvedFilters = resolveJoinFiltersAndSwapIfNeeded(\n-                        Predicates.splitAnd(join.config().joinOnConditions()),\n+                    joinOnConditions = resolveJoinFiltersAndSwapIfNeeded(\n+                        join.config().joinOnConditions(),\n                         join.left().outputSet(),\n-                        join.right().outputSet()\n+                        join.right().outputSet(),\n+                        leftKeys,\n+                        rightKeys,\n+                        context\n                     );\n-                    // build leftKeys and rightKeys using the correct side of the resolvedFilters.\n-                    // resolveJoinFiltersAndSwapIfNeeded already put the left and right on the correct side\n-                    for (Expression expression : resolvedFilters) {\n-                        if (expression instanceof EsqlBinaryComparison binaryComparison\n-                            && binaryComparison.left() instanceof Attribute leftAttribute\n-                            && binaryComparison.right() instanceof Attribute rightAttribute) {\n-                            leftKeys.add(leftAttribute);\n-                            rightKeys.add(rightAttribute);\n-                        } else {\n-                            UnresolvedAttribute errorAttribute = new UnresolvedAttribute(\n-                                expression.source(),\n-                                \"unsupported\",\n-                                \"Unsupported join filter expression:\" + expression.sourceText()\n-                            );\n-                            return join.withConfig(new JoinConfig(type, singletonList(errorAttribute), emptyList(), null));\n-\n-                        }\n-                    }\n                 } else {\n                     // resolve the using columns against the left and the right side then assemble the new join config\n                     leftKeys = resolveUsingColumns(join.config().leftFields(), join.left().output(), \"left\");\n                     rightKeys = resolveUsingColumns(join.config().rightFields(), join.right().output(), \"right\");\n                 }\n-\n-                config = new JoinConfig(type, leftKeys, rightKeys, Predicates.combineAnd(resolvedFilters));\n+                config = new JoinConfig(type, leftKeys, rightKeys, joinOnConditions);\n                 return new LookupJoin(join.source(), join.left(), join.right(), config, join.isRemote());\n             } else {\n                 // everything else is unsupported for now\n@@ -826,6 +876,18 @@ private Join resolveLookupJoin(LookupJoin join) {\n             }\n         }\n \n+        private boolean isCompletelyRightSideAndTranslatable(Expression expression, AttributeSet rightOutputSet) {\n+            return rightOutputSet.containsAll(expression.references()) && isTranslatable(expression);\n+        }\n+\n+        private boolean isTranslatable(Expression expression) {\n+            // Here we are trying to eliminate cases where the expression is definitely not translatable.\n+            // We do this early and without access to search stats for the lookup index that are only on the lookup node,\n+            // so we only eliminate some of the not translatable cases here\n+            // Later we will do a more thorough check on the lookup node\n+            return translatable(expression, LucenePushdownPredicates.DEFAULT) != TranslationAware.Translatable.NO;\n+        }\n+\n         private LogicalPlan resolveFork(Fork fork, AnalyzerContext context) {\n             // we align the outputs of the sub plans such that they have the same columns\n             boolean changed = false;"
    },
    {
      "filename": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/analysis/AnalyzerContext.java",
      "status": "modified",
      "additions": 36,
      "deletions": 9,
      "changes": 45,
      "patch": "@@ -17,15 +17,14 @@\n \n import java.util.Map;\n \n-public record AnalyzerContext(\n-    Configuration configuration,\n-    EsqlFunctionRegistry functionRegistry,\n-    Map<IndexPattern, IndexResolution> indexResolution,\n-    Map<String, IndexResolution> lookupResolution,\n-    EnrichResolution enrichResolution,\n-    InferenceResolution inferenceResolution,\n-    TransportVersion minimumVersion\n-) {\n+public class AnalyzerContext {\n+    private final Configuration configuration;\n+    private final EsqlFunctionRegistry functionRegistry;\n+    private final Map<IndexPattern, IndexResolution> indexResolution;\n+    private final Map<String, IndexResolution> lookupResolution;\n+    private final EnrichResolution enrichResolution;\n+    private final InferenceResolution inferenceResolution;\n+    private final TransportVersion minimumVersion;\n \n     public AnalyzerContext(\n         Configuration configuration,\n@@ -49,6 +48,34 @@ public AnalyzerContext(\n             : \"AnalyzerContext [\" + minimumVersion + \"] is not on or before current transport version [\" + TransportVersion.current() + \"]\";\n     }\n \n+    public Configuration configuration() {\n+        return configuration;\n+    }\n+\n+    public EsqlFunctionRegistry functionRegistry() {\n+        return functionRegistry;\n+    }\n+\n+    public Map<IndexPattern, IndexResolution> indexResolution() {\n+        return indexResolution;\n+    }\n+\n+    public Map<String, IndexResolution> lookupResolution() {\n+        return lookupResolution;\n+    }\n+\n+    public EnrichResolution enrichResolution() {\n+        return enrichResolution;\n+    }\n+\n+    public InferenceResolution inferenceResolution() {\n+        return inferenceResolution;\n+    }\n+\n+    public TransportVersion minimumVersion() {\n+        return minimumVersion;\n+    }\n+\n     public AnalyzerContext(Configuration configuration, EsqlFunctionRegistry functionRegistry, EsqlSession.PreAnalysisResult result) {\n         this(\n             configuration,"
    },
    {
      "filename": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/BinaryComparisonQueryList.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -92,7 +92,7 @@ public Query doGetQuery(int position, int firstValueIndex, int valueCount) {\n                 new Literal(binaryComparison.right().source(), value, binaryComparison.right().dataType())\n             );\n         try {\n-            if (TranslationAware.Translatable.YES.equals(comparison.translatable(lucenePushdownPredicates))) {\n+            if (TranslationAware.Translatable.YES == comparison.translatable(lucenePushdownPredicates)) {\n                 return comparison.asQuery(lucenePushdownPredicates, TranslatorHandler.TRANSLATOR_HANDLER)\n                     .toQueryBuilder()\n                     .toQuery(searchExecutionContext);"
    },
    {
      "filename": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/ExpressionQueryList.java",
      "status": "modified",
      "additions": 87,
      "deletions": 74,
      "changes": 161,
      "patch": "@@ -18,11 +18,13 @@\n import org.elasticsearch.compute.operator.lookup.QueryList;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.Rewriteable;\n import org.elasticsearch.index.query.SearchExecutionContext;\n import org.elasticsearch.search.internal.AliasFilter;\n import org.elasticsearch.xpack.esql.capabilities.TranslationAware;\n import org.elasticsearch.xpack.esql.core.expression.Attribute;\n import org.elasticsearch.xpack.esql.core.expression.Expression;\n+import org.elasticsearch.xpack.esql.core.type.DataType;\n import org.elasticsearch.xpack.esql.expression.predicate.Predicates;\n import org.elasticsearch.xpack.esql.expression.predicate.operator.comparison.Equals;\n import org.elasticsearch.xpack.esql.expression.predicate.operator.comparison.EsqlBinaryComparison;\n@@ -56,9 +58,10 @@\n  */\n public class ExpressionQueryList implements LookupEnrichQueryGenerator {\n     private final List<QueryList> queryLists;\n-    private final List<Query> preJoinFilters = new ArrayList<>();\n+    private final List<Query> lucenePushableFilters = new ArrayList<>();\n     private final SearchExecutionContext context;\n     private final AliasFilter aliasFilter;\n+    private final LucenePushdownPredicates lucenePushdownPredicates;\n \n     private ExpressionQueryList(\n         List<QueryList> queryLists,\n@@ -70,6 +73,10 @@ private ExpressionQueryList(\n         this.queryLists = new ArrayList<>(queryLists);\n         this.context = context;\n         this.aliasFilter = aliasFilter;\n+        this.lucenePushdownPredicates = LucenePushdownPredicates.from(\n+            SearchContextStats.from(List.of(context)),\n+            new EsqlFlags(clusterService.getClusterSettings())\n+        );\n         buildPreJoinFilter(rightPreJoinPlan, clusterService);\n     }\n \n@@ -141,98 +148,104 @@ private void buildJoinOnForExpressionJoin(\n     ) {\n         List<Expression> expressions = Predicates.splitAnd(joinOnConditions);\n         for (Expression expr : expressions) {\n-            if (expr instanceof EsqlBinaryComparison binaryComparison) {\n-                // the left side comes from the page that was sent to the lookup node\n-                // the right side is the field from the lookup index\n-                // check if the left side is in the matchFields\n-                // if it is its corresponding page is the corresponding number in inputPage\n-                Expression left = binaryComparison.left();\n-                if (left instanceof Attribute leftAttribute) {\n-                    boolean matched = false;\n-                    for (int i = 0; i < matchFields.size(); i++) {\n-                        if (matchFields.get(i).fieldName().equals(leftAttribute.name())) {\n-                            Block block = inputPage.getBlock(i);\n-                            Expression right = binaryComparison.right();\n-                            if (right instanceof Attribute rightAttribute) {\n-                                MappedFieldType fieldType = context.getFieldType(rightAttribute.name());\n-                                if (fieldType != null) {\n-                                    // special handle Equals operator\n-                                    // TermQuery is faster than BinaryComparisonQueryList, as it does less work per row\n-                                    // so here we reuse the existing logic from field based join to build a termQueryList for Equals\n-                                    if (binaryComparison instanceof Equals) {\n-                                        QueryList termQueryForEquals = termQueryList(\n-                                            fieldType,\n-                                            context,\n-                                            aliasFilter,\n-                                            inputPage.getBlock(matchFields.get(i).channel()),\n-                                            matchFields.get(i).type()\n-                                        ).onlySingleValues(warnings, \"LOOKUP JOIN encountered multi-value\");\n-                                        queryLists.add(termQueryForEquals);\n-                                    } else {\n-                                        queryLists.add(\n-                                            new BinaryComparisonQueryList(\n-                                                fieldType,\n-                                                context,\n-                                                block,\n-                                                binaryComparison,\n-                                                clusterService,\n-                                                aliasFilter,\n-                                                warnings\n-                                            )\n-                                        );\n-                                    }\n-                                    matched = true;\n-                                    break;\n-                                } else {\n-                                    throw new IllegalStateException(\n-                                        \"Could not find field [\" + rightAttribute.name() + \"] in the lookup join index\"\n-                                    );\n-                                }\n-                            } else {\n-                                throw new IllegalStateException(\n-                                    \"Only field from the right dataset are supported on the right of the join on condition but got: \" + expr\n-                                );\n-                            }\n-                        }\n-                    }\n-                    if (matched == false) {\n-                        throw new IllegalStateException(\n-                            \"Could not find field [\" + leftAttribute.name() + \"] in the left side of the lookup join\"\n-                        );\n-                    }\n+            boolean applied = applyAsLeftRightBinaryComparison(expr, matchFields, inputPage, clusterService, warnings);\n+            if (applied == false) {\n+                applied = applyAsRightSidePushableFilter(expr);\n+            }\n+            if (applied == false) {\n+                throw new IllegalArgumentException(\"Cannot apply join condition: \" + expr);\n+            }\n+        }\n+    }\n+\n+    private boolean applyAsRightSidePushableFilter(Expression filter) {\n+        if (filter instanceof TranslationAware translationAware) {\n+            if (TranslationAware.Translatable.YES.equals(translationAware.translatable(lucenePushdownPredicates))) {\n+                QueryBuilder queryBuilder = translationAware.asQuery(lucenePushdownPredicates, TRANSLATOR_HANDLER).toQueryBuilder();\n+                // Rewrite the query builder to ensure doIndexMetadataRewrite is called\n+                // Some functions, such as KQL require rewriting to work properly\n+                try {\n+                    queryBuilder = Rewriteable.rewrite(queryBuilder, context, true);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(\"Error while rewriting query for Lucene pushable filter\", e);\n+                }\n+                addToLucenePushableFilters(queryBuilder);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean applyAsLeftRightBinaryComparison(\n+        Expression expr,\n+        List<MatchConfig> matchFields,\n+        Page inputPage,\n+        ClusterService clusterService,\n+        Warnings warnings\n+    ) {\n+        if (expr instanceof EsqlBinaryComparison binaryComparison\n+            && binaryComparison.left() instanceof Attribute leftAttribute\n+            && binaryComparison.right() instanceof Attribute rightAttribute) {\n+            // the left side comes from the page that was sent to the lookup node\n+            // the right side is the field from the lookup index\n+            // check if the left side is in the matchFields\n+            // if it is its corresponding page is the corresponding number in inputPage\n+            Block block = null;\n+            DataType dataType = null;\n+            for (int i = 0; i < matchFields.size(); i++) {\n+                if (matchFields.get(i).fieldName().equals(leftAttribute.name())) {\n+                    block = inputPage.getBlock(i);\n+                    dataType = matchFields.get(i).type();\n+                    break;\n+                }\n+            }\n+            MappedFieldType rightFieldType = context.getFieldType(rightAttribute.name());\n+            if (block != null && rightFieldType != null && dataType != null) {\n+                // special handle Equals operator\n+                // TermQuery is faster than BinaryComparisonQueryList, as it does less work per row\n+                // so here we reuse the existing logic from field based join to build a termQueryList for Equals\n+                if (binaryComparison instanceof Equals) {\n+                    QueryList termQueryForEquals = termQueryList(rightFieldType, context, aliasFilter, block, dataType).onlySingleValues(\n+                        warnings,\n+                        \"LOOKUP JOIN encountered multi-value\"\n+                    );\n+                    queryLists.add(termQueryForEquals);\n                 } else {\n-                    throw new IllegalStateException(\n-                        \"Only field from the left dataset are supported on the left of the join on condition but got: \" + expr\n+                    queryLists.add(\n+                        new BinaryComparisonQueryList(\n+                            rightFieldType,\n+                            context,\n+                            block,\n+                            binaryComparison,\n+                            clusterService,\n+                            aliasFilter,\n+                            warnings\n+                        )\n                     );\n                 }\n-            } else {\n-                // we only support binary comparisons in the join on conditions\n-                throw new IllegalStateException(\"Only binary comparisons are supported in join ON conditions, but got: \" + expr);\n+                return true;\n             }\n         }\n+        return false;\n     }\n \n-    private void addToPreJoinFilters(QueryBuilder query) {\n+    private void addToLucenePushableFilters(QueryBuilder query) {\n         try {\n             if (query != null) {\n-                preJoinFilters.add(query.toQuery(context));\n+                lucenePushableFilters.add(query.toQuery(context));\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Error while building query for PreJoinFilters filter\", e);\n+            throw new UncheckedIOException(\"Error while building query for Lucene pushable filter\", e);\n         }\n     }\n \n     private void buildPreJoinFilter(PhysicalPlan rightPreJoinPlan, ClusterService clusterService) {\n         if (rightPreJoinPlan instanceof FilterExec filterExec) {\n             List<Expression> candidateRightHandFilters = Predicates.splitAnd(filterExec.condition());\n-            LucenePushdownPredicates lucenePushdownPredicates = LucenePushdownPredicates.from(\n-                SearchContextStats.from(List.of(context)),\n-                new EsqlFlags(clusterService.getClusterSettings())\n-            );\n             for (Expression filter : candidateRightHandFilters) {\n                 if (filter instanceof TranslationAware translationAware) {\n                     if (TranslationAware.Translatable.YES.equals(translationAware.translatable(lucenePushdownPredicates))) {\n-                        addToPreJoinFilters(translationAware.asQuery(lucenePushdownPredicates, TRANSLATOR_HANDLER).toQueryBuilder());\n+                        addToLucenePushableFilters(translationAware.asQuery(lucenePushdownPredicates, TRANSLATOR_HANDLER).toQueryBuilder());\n                     }\n                 }\n                 // If the filter is not translatable we will not apply it for now\n@@ -268,7 +281,7 @@ public Query getQuery(int position) {\n             builder.add(q, BooleanClause.Occur.FILTER);\n         }\n         // also attach the pre-join filter if it exists\n-        for (Query preJoinFilter : preJoinFilters) {\n+        for (Query preJoinFilter : lucenePushableFilters) {\n             builder.add(preJoinFilter, BooleanClause.Occur.FILTER);\n         }\n         return builder.build();"
    },
    {
      "filename": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/fulltext/FullTextFunction.java",
      "status": "modified",
      "additions": 66,
      "deletions": 26,
      "changes": 92,
      "patch": "@@ -30,6 +30,7 @@\n import org.elasticsearch.xpack.esql.core.tree.Source;\n import org.elasticsearch.xpack.esql.core.type.DataType;\n import org.elasticsearch.xpack.esql.core.type.MultiTypeEsField;\n+import org.elasticsearch.xpack.esql.core.util.Holder;\n import org.elasticsearch.xpack.esql.evaluator.mapper.EvaluatorMapper;\n import org.elasticsearch.xpack.esql.expression.function.scalar.convert.AbstractConvertFunction;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.BinaryLogic;\n@@ -42,6 +43,7 @@\n import org.elasticsearch.xpack.esql.plan.logical.Limit;\n import org.elasticsearch.xpack.esql.plan.logical.LogicalPlan;\n import org.elasticsearch.xpack.esql.plan.logical.OrderBy;\n+import org.elasticsearch.xpack.esql.plan.logical.join.LookupJoin;\n import org.elasticsearch.xpack.esql.planner.EsPhysicalOperationProviders;\n import org.elasticsearch.xpack.esql.planner.TranslatorHandler;\n import org.elasticsearch.xpack.esql.querydsl.query.TranslationAwareExpressionQuery;\n@@ -188,34 +190,11 @@ public BiConsumer<LogicalPlan, Failures> postAnalysisPlanVerification() {\n     private static void checkFullTextQueryFunctions(LogicalPlan plan, Failures failures) {\n         if (plan instanceof Filter f) {\n             Expression condition = f.condition();\n-\n-            if (condition instanceof Score) {\n-                failures.add(fail(condition, \"[SCORE] function can't be used in WHERE\"));\n-            }\n-\n-            List.of(QueryString.class, Kql.class).forEach(functionClass -> {\n-                // Check for limitations of QSTR and KQL function.\n-                checkCommandsBeforeExpression(\n-                    plan,\n-                    condition,\n-                    functionClass,\n-                    lp -> (lp instanceof Filter || lp instanceof OrderBy || lp instanceof EsRelation),\n-                    fullTextFunction -> \"[\" + fullTextFunction.functionName() + \"] \" + fullTextFunction.functionType(),\n-                    failures\n-                );\n-            });\n-\n-            checkCommandsBeforeExpression(\n-                plan,\n-                condition,\n-                FullTextFunction.class,\n-                lp -> (lp instanceof Limit == false) && (lp instanceof Aggregate == false),\n-                m -> \"[\" + m.functionName() + \"] \" + m.functionType(),\n-                failures\n-            );\n-            checkFullTextFunctionsParents(condition, failures);\n+            checkFullTextQueryFunctionForCondition(plan, failures, condition, false);\n         } else if (plan instanceof Aggregate agg) {\n             checkFullTextFunctionsInAggs(agg, failures);\n+        } else if (plan instanceof LookupJoin lookupJoin) {\n+            checkFullTextQueryFunctionForCondition(plan, failures, lookupJoin.config().joinOnConditions(), true);\n         } else {\n             List<FullTextFunction> scoredFTFs = new ArrayList<>();\n             plan.forEachExpression(Score.class, scoreFunction -> {\n@@ -238,6 +217,43 @@ private static void checkFullTextQueryFunctions(LogicalPlan plan, Failures failu\n         }\n     }\n \n+    private static void checkFullTextQueryFunctionForCondition(\n+        LogicalPlan plan,\n+        Failures failures,\n+        Expression condition,\n+        boolean isLookupJoinOnCondition\n+    ) {\n+        if (condition == null) {\n+            return;\n+        }\n+        if (condition instanceof Score) {\n+            failures.add(fail(condition, \"[SCORE] function can't be used in WHERE or LOOKUP JOIN ON conditions\"));\n+        }\n+        if (isLookupJoinOnCondition == false) {\n+            List.of(QueryString.class, Kql.class).forEach(functionClass -> {\n+                // Check for limitations of QSTR and KQL function.\n+                checkCommandsBeforeExpression(\n+                    plan,\n+                    condition,\n+                    functionClass,\n+                    lp -> (lp instanceof Filter || lp instanceof OrderBy || lp instanceof EsRelation),\n+                    fullTextFunction -> \"[\" + fullTextFunction.functionName() + \"] \" + fullTextFunction.functionType(),\n+                    failures\n+                );\n+            });\n+        }\n+\n+        checkCommandsBeforeExpression(\n+            plan,\n+            condition,\n+            FullTextFunction.class,\n+            lp -> (lp instanceof Limit == false) && (lp instanceof Aggregate == false),\n+            m -> \"[\" + m.functionName() + \"] \" + m.functionType(),\n+            failures\n+        );\n+        checkFullTextFunctionsParents(condition, failures);\n+    }\n+\n     private static void checkScoreFunction(LogicalPlan plan, Failures failures, Score scoreFunction) {\n         checkCommandsBeforeExpression(\n             plan,\n@@ -341,6 +357,11 @@ private static FullTextFunction forEachFullTextFunctionParent(Expression conditi\n     }\n \n     public static void fieldVerifier(LogicalPlan plan, FullTextFunction function, Expression field, Failures failures) {\n+        // Only run the check if the current node contains the full-text function\n+        // This is to avoid running the check multiple times in the same plan\n+        if (isInCurrentNode(plan, function) == false) {\n+            return;\n+        }\n         var fieldAttribute = fieldAsFieldAttribute(field);\n         if (fieldAttribute == null) {\n             plan.forEachExpression(function.getClass(), m -> {\n@@ -357,6 +378,12 @@ public static void fieldVerifier(LogicalPlan plan, FullTextFunction function, Ex\n                 }\n             });\n         } else {\n+            if (plan instanceof LookupJoin) {\n+                // Full Text Functions are allowed in LOOKUP JOIN ON conditions\n+                // We are only running this code for the node containing the Full Text Function\n+                // So if it is a Lookup Join we know the function is in the join on condition\n+                return;\n+            }\n             // Traverse the plan to find the EsRelation outputting the field\n             plan.forEachDown(p -> {\n                 if (p instanceof EsRelation esRelation && esRelation.indexMode() != IndexMode.STANDARD) {\n@@ -428,4 +455,17 @@ public static FieldAttribute fieldAsFieldAttribute(Expression field) {\n     public void postOptimizationVerification(Failures failures) {\n         resolveTypeQuery(query(), sourceText(), forPostOptimizationValidation(query(), failures));\n     }\n+\n+    /**\n+     * Check if the full-text function exists only in the current node (not in child nodes)\n+     */\n+    private static boolean isInCurrentNode(LogicalPlan plan, FullTextFunction function) {\n+        final Holder<Boolean> found = new Holder<>(false);\n+        plan.forEachExpression(FullTextFunction.class, ftf -> {\n+            if (ftf == function) {\n+                found.set(true);\n+            }\n+        });\n+        return found.get();\n+    }\n }"
    },
    {
      "filename": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/predicate/Predicates.java",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "patch": "@@ -9,6 +9,7 @@\n import org.elasticsearch.core.Tuple;\n import org.elasticsearch.xpack.esql.core.expression.Expression;\n import org.elasticsearch.xpack.esql.core.expression.Literal;\n+import org.elasticsearch.xpack.esql.core.tree.Source;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.And;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.Or;\n \n@@ -49,6 +50,10 @@ public static Expression combineAnd(List<Expression> exps) {\n         return combine(exps, (l, r) -> new And(l.source(), l, r));\n     }\n \n+    public static Expression combineAndWithSource(List<Expression> exps, Source source) {\n+        return combine(exps, (l, r) -> new And(source, l, r));\n+    }\n+\n     /**\n      * Build a binary 'pyramid' from the given list:\n      * <pre>"
    },
    {
      "filename": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/parser/LogicalPlanBuilder.java",
      "status": "modified",
      "additions": 49,
      "deletions": 12,
      "changes": 61,
      "patch": "@@ -46,6 +46,7 @@\n import org.elasticsearch.xpack.esql.expression.UnresolvedNamePattern;\n import org.elasticsearch.xpack.esql.expression.function.UnresolvedFunction;\n import org.elasticsearch.xpack.esql.expression.predicate.Predicates;\n+import org.elasticsearch.xpack.esql.expression.predicate.logical.BinaryLogic;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.Not;\n import org.elasticsearch.xpack.esql.expression.predicate.operator.comparison.Equals;\n import org.elasticsearch.xpack.esql.expression.predicate.operator.comparison.EsqlBinaryComparison;\n@@ -721,7 +722,14 @@ public PlanFactory visitJoinCommand(EsqlBaseParser.JoinCommandContext ctx) {\n             if (hasRemotes && EsqlCapabilities.Cap.ENABLE_LOOKUP_JOIN_ON_REMOTE.isEnabled() == false) {\n                 throw new ParsingException(source, \"remote clusters are not supported with LOOKUP JOIN\");\n             }\n-            return new LookupJoin(source, p, right, joinInfo.joinFields(), hasRemotes, Predicates.combineAnd(joinInfo.joinExpressions()));\n+            return new LookupJoin(\n+                source,\n+                p,\n+                right,\n+                joinInfo.joinFields(),\n+                hasRemotes,\n+                Predicates.combineAndWithSource(joinInfo.joinExpressions(), source(condition))\n+            );\n         };\n     }\n \n@@ -734,8 +742,10 @@ public JoinInfo visitJoinCondition(EsqlBaseParser.JoinConditionContext ctx) {\n             throw new ParsingException(source(ctx), \"JOIN ON clause cannot be empty\");\n         }\n \n-        // inspect the first expression to determine the type of join (field-based or expression-based)\n-        boolean isFieldBased = expressions.get(0) instanceof UnresolvedAttribute;\n+        // Inspect the first expression to determine the type of join (field-based or expression-based)\n+        // We treat literals as field-based as it is more likely the user was trying to write a field name\n+        // and so the field based error message is more helpful\n+        boolean isFieldBased = expressions.get(0) instanceof UnresolvedAttribute || expressions.get(0) instanceof Literal;\n \n         if (isFieldBased) {\n             return processFieldBasedJoin(expressions);\n@@ -784,26 +794,53 @@ private JoinInfo processExpressionBasedJoin(List<Expression> expressions, EsqlBa\n         }\n         expressions = Predicates.splitAnd(expressions.get(0));\n         for (var f : expressions) {\n-            addJoinExpression(f, joinFields, joinExpressions);\n+            addJoinExpression(f, joinFields, joinExpressions, ctx);\n+        }\n+        if (joinFields.isEmpty()) {\n+            throw new ParsingException(\n+                source(ctx),\n+                \"JOIN ON clause with expressions must contain at least one condition relating the left index and the lookup index\"\n+            );\n         }\n         return new JoinInfo(joinFields, joinExpressions);\n     }\n \n-    private void addJoinExpression(Expression exp, List<Attribute> joinFields, List<Expression> joinExpressions) {\n+    private void addJoinExpression(\n+        Expression exp,\n+        List<Attribute> joinFields,\n+        List<Expression> joinExpressions,\n+        EsqlBaseParser.JoinConditionContext ctx\n+    ) {\n         exp = handleNegationOfEquals(exp);\n+        if (containsBareFieldsInBooleanExpression(exp)) {\n+            throw new ParsingException(\n+                source(ctx),\n+                \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found [{}]\",\n+                exp.sourceText()\n+            );\n+        }\n         if (exp instanceof EsqlBinaryComparison comparison\n             && comparison.left() instanceof UnresolvedAttribute left\n             && comparison.right() instanceof UnresolvedAttribute right) {\n             joinFields.add(left);\n             joinFields.add(right);\n-            joinExpressions.add(exp);\n-        } else {\n-            throw new ParsingException(\n-                exp.source(),\n-                \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found [{}]\",\n-                exp.sourceText()\n-            );\n         }\n+        joinExpressions.add(exp);\n+    }\n+\n+    private boolean containsBareFieldsInBooleanExpression(Expression expression) {\n+        if (expression instanceof UnresolvedAttribute) {\n+            return true; // This is a bare field\n+        }\n+        if (expression instanceof EsqlBinaryComparison) {\n+            return false; // This is a binary comparison, not a bare field\n+        }\n+        if (expression instanceof BinaryLogic binaryLogic) {\n+            // Check if either side contains bare fields\n+            return containsBareFieldsInBooleanExpression(binaryLogic.left()) || containsBareFieldsInBooleanExpression(binaryLogic.right());\n+        }\n+        // For other expression types (functions, constants, etc.), they are not bare fields\n+        return false;\n     }\n \n     private void validateJoinFields(List<Attribute> joinFields) {"
    },
    {
      "filename": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plan/logical/join/JoinConfig.java",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "patch": "@@ -20,6 +20,19 @@\n import java.util.List;\n \n /**\n+ * Configuration of a join operation.\n+ * We support equi-joins on a list of fields, as well as expression based joins.\n+ * For list of fields based joins, the left and right lists must be of the same size and match positionally.\n+ * For expression based joins, the join conditions are expressed as a boolean expression.\n+ * The join on condition is stored in the {@code joinOnConditions} field.\n+ * We support one or more binary expressions (e.g. {@code ==, <, >, <=, >=, !=}) combined with {@code AND}.\n+ * One side of each binary expression must be an attribute from the left side of the join\n+ * and the other side an attribute from the side of the join child.\n+ * Those are populated in the {@code leftFields} and {@code rightFields} lists respectively.\n+ * Notice however that {@code leftFields} and {@code rightFields} might have different size if a field is reused\n+ * (e.g. {@code left_a == right_b AND left_a = right_c}).\n+ * In addition, you can AND an optional Lucene pushable expression containing references to the right side of the join only.\n+ * This expression can contain OR and NOT nodes, as those operators are Lucene pushable.\n  * @param type        type of join\n  * @param leftFields  fields from the left child to join on\n  * @param rightFields fields from the right child to join on"
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/AnalyzerTestUtils.java",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "patch": "@@ -235,7 +235,9 @@ public static Map<String, IndexResolution> defaultLookupResolution() {\n             \"languages_lookup\",\n             loadMapping(\"mapping-languages.json\", \"languages_lookup\", IndexMode.LOOKUP),\n             \"test_lookup\",\n-            loadMapping(\"mapping-basic.json\", \"test_lookup\", IndexMode.LOOKUP)\n+            loadMapping(\"mapping-basic.json\", \"test_lookup\", IndexMode.LOOKUP),\n+            \"spatial_lookup\",\n+            loadMapping(\"mapping-multivalue_geometries.json\", \"spatial_lookup\", IndexMode.LOOKUP)\n         );\n     }\n "
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/AnalyzerTests.java",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "patch": "@@ -163,6 +163,12 @@\n import static org.hamcrest.Matchers.startsWith;\n \n //@TestLogging(value = \"org.elasticsearch.xpack.esql.analysis:TRACE\", reason = \"debug\")\n+/**\n+ * Parses a plan, builds an AST for it, runs logical analysis.\n+ * So if we don't error out in the process, analysis was successful\n+ * Use this class if you want to test analysis phase\n+ * and especially if you expect to get a VerificationException during analysis\n+ */\n public class AnalyzerTests extends ESTestCase {\n \n     private static final UnresolvedRelation UNRESOLVED_RELATION = unresolvedRelation(\"idx\");"
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/ParsingTests.java",
      "status": "modified",
      "additions": 80,
      "deletions": 4,
      "changes": 84,
      "patch": "@@ -51,6 +51,12 @@\n import static org.hamcrest.Matchers.instanceOf;\n import static org.hamcrest.Matchers.is;\n \n+/**\n+ * Parses a plan, builds an AST for it, and then runs logical analysis on it.\n+ * So if we don't error out in the process,  all references were resolved correctly.\n+ * Use this class if you want to test parsing and resolution of a query\n+ *  and especially if you expect to get a ParsingException\n+ */\n public class ParsingTests extends ESTestCase {\n     private static final String INDEX_NAME = \"test\";\n     private static final EsqlParser parser = new EsqlParser();\n@@ -141,22 +147,92 @@ public void testTooBigQuery() {\n     public void testJoinOnConstant() {\n         assumeTrue(\n             \"requires LOOKUP JOIN ON boolean expression capability\",\n-            EsqlCapabilities.Cap.LOOKUP_JOIN_ON_BOOLEAN_EXPRESSION.isEnabled()\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n         );\n         assertEquals(\n-            \"1:55: JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found [123]\",\n+            \"1:55: JOIN ON clause must be a comma separated list of fields or a single expression, found [123]\",\n             error(\"row languages = 1, gender = \\\"f\\\" | lookup join test on 123\")\n         );\n         assertEquals(\n-            \"1:55: JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found [\\\"abc\\\"]\",\n+            \"1:55: JOIN ON clause must be a comma separated list of fields or a single expression, found [\\\"abc\\\"]\",\n             error(\"row languages = 1, gender = \\\"f\\\" | lookup join test on \\\"abc\\\"\")\n         );\n         assertEquals(\n-            \"1:55: JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found [false]\",\n+            \"1:55: JOIN ON clause must be a comma separated list of fields or a single expression, found [false]\",\n             error(\"row languages = 1, gender = \\\"f\\\" | lookup join test on false\")\n         );\n     }\n \n+    public void testLookupJoinExpressionMixed() {\n+        assumeTrue(\"requires LOOKUP JOIN capability\", EsqlCapabilities.Cap.JOIN_LOOKUP_V12.isEnabled());\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON languages_left == language_code or salary > 1000\n+            \"\"\";\n+\n+        assertEquals(\n+            \"3:32: JOIN ON clause with expressions must contain at least one condition relating the left index and the lookup index\",\n+            error(queryString)\n+        );\n+    }\n+\n+    public void testLookupJoinExpressionOnlyRightFilter() {\n+        assumeTrue(\"requires LOOKUP JOIN capability\", EsqlCapabilities.Cap.JOIN_LOOKUP_V12.isEnabled());\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON salary > 1000\n+            \"\"\";\n+\n+        assertEquals(\n+            \"3:32: JOIN ON clause with expressions must contain at least one condition relating the left index and the lookup index\",\n+            error(queryString)\n+        );\n+    }\n+\n+    public void testLookupJoinExpressionFieldBasePlusRightFilterAnd() {\n+        assumeTrue(\"requires LOOKUP JOIN capability\", EsqlCapabilities.Cap.JOIN_LOOKUP_V12.isEnabled());\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | lookup join languages_lookup ON languages and salary > 1000\n+            \"\"\";\n+\n+        assertEquals(\n+            \"2:32: JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found [languages]\",\n+            error(queryString)\n+        );\n+    }\n+\n+    public void testLookupJoinExpressionFieldBasePlusRightFilterComma() {\n+        assumeTrue(\"requires LOOKUP JOIN capability\", EsqlCapabilities.Cap.JOIN_LOOKUP_V12.isEnabled());\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | lookup join languages_lookup ON languages, salary > 1000\n+            \"\"\";\n+\n+        assertEquals(\n+            \"2:46: JOIN ON clause must be a comma separated list of fields or a single expression, found [salary > 1000]\",\n+            error(queryString)\n+        );\n+    }\n+\n     public void testJoinTwiceOnTheSameField() {\n         assertEquals(\n             \"1:66: JOIN ON clause does not support multiple fields with the same name, found multiple instances of [languages]\","
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/VerifierTests.java",
      "status": "modified",
      "additions": 102,
      "deletions": 1,
      "changes": 103,
      "patch": "@@ -8,6 +8,7 @@\n package org.elasticsearch.xpack.esql.analysis;\n \n import org.elasticsearch.Build;\n+import org.elasticsearch.TransportVersion;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.test.ESTestCase;\n import org.elasticsearch.xpack.esql.VerificationException;\n@@ -41,6 +42,7 @@\n \n import static org.elasticsearch.xpack.esql.EsqlTestUtils.paramAsConstant;\n import static org.elasticsearch.xpack.esql.EsqlTestUtils.withDefaultLimitWarning;\n+import static org.elasticsearch.xpack.esql.analysis.Analyzer.ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION;\n import static org.elasticsearch.xpack.esql.analysis.AnalyzerTestUtils.TEXT_EMBEDDING_INFERENCE_ID;\n import static org.elasticsearch.xpack.esql.analysis.AnalyzerTestUtils.loadMapping;\n import static org.elasticsearch.xpack.esql.core.type.DataType.BOOLEAN;\n@@ -72,6 +74,12 @@\n import static org.hamcrest.Matchers.startsWith;\n \n //@TestLogging(value = \"org.elasticsearch.xpack.esql:TRACE,org.elasticsearch.compute:TRACE\", reason = \"debug\")\n+/**\n+ * Parses a plan, builds an AST for it, runs logical analysis and post analysis verification.\n+ * So if we don't error out in the process, post analysis verification passed\n+ * Use this class if you want to test post analysis verification\n+ * and especially if you expect to get a VerificationException\n+ */\n public class VerifierTests extends ESTestCase {\n \n     private static final EsqlParser parser = new EsqlParser();\n@@ -2251,6 +2259,88 @@ public void testLookupJoinExpressionAmbiguousRight() {\n         );\n     }\n \n+    public void testLookupJoinExpressionRightNotPushable() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON languages_left == language_code and abs(salary) > 1000\n+            \"\"\";\n+\n+        assertEquals(\n+            \"3:71: Unsupported join filter expression:abs(salary) > 1000\",\n+            error(queryString, ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION)\n+        );\n+    }\n+\n+    public void testLookupJoinExpressionConstant() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON false and languages_left == language_code\n+            \"\"\";\n+\n+        assertEquals(\"3:35: Unsupported join filter expression:false\", error(queryString, ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION));\n+    }\n+\n+    public void testLookupJoinExpressionTranslatableButFromLeft() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON languages_left == language_code and languages_left == \"English\"\n+            \"\"\";\n+\n+        assertEquals(\n+            \"3:71: Unsupported join filter expression:languages_left == \\\"English\\\"\",\n+            error(queryString, ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION)\n+        );\n+    }\n+\n+    public void testLookupJoinExpressionTranslatableButMixedLeftRight() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON languages_left == language_code and CONCAT(languages_left, language_code) == \"English\"\n+            \"\"\";\n+\n+        assertEquals(\n+            \"3:71: Unsupported join filter expression:CONCAT(languages_left, language_code) == \\\"English\\\"\",\n+            error(queryString, ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION)\n+        );\n+    }\n+\n+    public void testLookupJoinExpressionComplexFormula() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON languages_left == language_code AND STARTSWITH(languages_left, language_code)\n+            \"\"\";\n+\n+        assertEquals(\n+            \"3:71: Unsupported join filter expression:STARTSWITH(languages_left, language_code)\",\n+            error(queryString, ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION)\n+        );\n+    }\n+\n     public void testLookupJoinExpressionAmbiguousLeft() {\n         assumeTrue(\n             \"requires LOOKUP JOIN ON boolean expression capability\",\n@@ -2993,13 +3083,17 @@ private String error(String query) {\n     }\n \n     private String error(String query, Object... params) {\n-        return error(query, defaultAnalyzer, params);\n+        return error(query, defaultAnalyzer, VerificationException.class, params);\n     }\n \n     private String error(String query, Analyzer analyzer, Object... params) {\n         return error(query, analyzer, VerificationException.class, params);\n     }\n \n+    private String error(String query, TransportVersion transportVersion, Object... params) {\n+        return error(query, transportVersion, VerificationException.class, params);\n+    }\n+\n     private String error(String query, Analyzer analyzer, Class<? extends Exception> exception, Object... params) {\n         List<QueryParam> parameters = new ArrayList<>();\n         for (Object param : params) {\n@@ -3029,6 +3123,13 @@ private String error(String query, Analyzer analyzer, Class<? extends Exception>\n         return message.substring(index + pattern.length());\n     }\n \n+    private String error(String query, TransportVersion transportVersion, Class<? extends Exception> exception, Object... params) {\n+        MutableAnalyzerContext mutableContext = (MutableAnalyzerContext) defaultAnalyzer.context();\n+        try (var restore = mutableContext.setTemporaryTransportVersionOnOrAfter(transportVersion)) {\n+            return error(query, defaultAnalyzer, exception, params);\n+        }\n+    }\n+\n     @Override\n     protected List<String> filteredWarnings() {\n         return withDefaultLimitWarning(super.filteredWarnings());"
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/LookupFromIndexOperatorTests.java",
      "status": "modified",
      "additions": 45,
      "deletions": 19,
      "changes": 64,
      "patch": "@@ -108,6 +108,7 @@ public class LookupFromIndexOperatorTests extends AsyncOperatorTestCase {\n     private final ThreadPool threadPool = threadPool();\n     private final Directory lookupIndexDirectory = newDirectory();\n     private final List<Releasable> releasables = new ArrayList<>();\n+    private final boolean applyRightFilterAsJoinOnFilter;\n     private int numberOfJoinColumns; // we only allow 1 or 2 columns due to simpleInput() implementation\n     private EsqlBinaryComparison.BinaryComparisonOperation operation;\n \n@@ -129,6 +130,7 @@ public static Iterable<Object[]> parametersFactory() {\n     public LookupFromIndexOperatorTests(EsqlBinaryComparison.BinaryComparisonOperation operation) {\n         super();\n         this.operation = operation;\n+        this.applyRightFilterAsJoinOnFilter = randomBoolean();\n     }\n \n     @Before\n@@ -248,6 +250,7 @@ protected Operator.OperatorFactory simple(SimpleOptions options) {\n             matchFields.add(new MatchConfig(matchField, i, inputDataType));\n         }\n         Expression joinOnExpression = null;\n+        FragmentExec rightPlanWithOptionalPreJoinFilter = buildLessThanFilter(LESS_THAN_VALUE);\n         if (operation != null) {\n             List<Expression> conditions = new ArrayList<>();\n             for (int i = 0; i < numberOfJoinColumns; i++) {\n@@ -265,6 +268,13 @@ protected Operator.OperatorFactory simple(SimpleOptions options) {\n                 );\n                 conditions.add(operation.buildNewInstance(Source.EMPTY, left, right));\n             }\n+            if (applyRightFilterAsJoinOnFilter) {\n+                if (rightPlanWithOptionalPreJoinFilter instanceof FragmentExec fragmentExec\n+                    && fragmentExec.fragment() instanceof Filter filterPlan) {\n+                    conditions.add(filterPlan.condition());\n+                    rightPlanWithOptionalPreJoinFilter = null;\n+                }\n+            }\n             joinOnExpression = Predicates.combineAnd(conditions);\n         }\n \n@@ -278,7 +288,7 @@ protected Operator.OperatorFactory simple(SimpleOptions options) {\n             lookupIndex,\n             loadFields,\n             Source.EMPTY,\n-            buildLessThanFilter(LESS_THAN_VALUE),\n+            rightPlanWithOptionalPreJoinFilter,\n             joinOnExpression\n         );\n     }\n@@ -321,25 +331,41 @@ protected Matcher<String> expectedToStringOfSimple() {\n             // match_field=match<i>_left (index first, then suffix)\n             sb.append(\"input_type=LONG match_field=match\").append(i).append(suffix).append(\" inputChannel=\").append(i).append(\" \");\n         }\n-        // Accept either the legacy physical plan rendering (FilterExec/EsQueryExec) or the new FragmentExec rendering\n-        sb.append(\"right_pre_join_plan=(?:\");\n-        // Legacy pattern\n-        sb.append(\"FilterExec\\\\[lint\\\\{f}#\\\\d+ < \")\n-            .append(LESS_THAN_VALUE)\n-            .append(\n-                \"\\\\[INTEGER]]\\\\n\\\\\\\\_EsQueryExec\\\\[test], indexMode\\\\[lookup],\\\\s*(?:query\\\\[\\\\]|\\\\[\\\\])?,?\\\\s*\"\n-                    + \"limit\\\\[\\\\],?\\\\s*sort\\\\[(?:\\\\[\\\\])?\\\\]\\\\s*estimatedRowSize\\\\[null\\\\]\\\\s*queryBuilderAndTags \\\\[(?:\\\\[\\\\]\\\\])\\\\]\"\n-            );\n-        sb.append(\"|\");\n-        // New FragmentExec pattern - match the actual output format\n-        sb.append(\"FragmentExec\\\\[filter=null, estimatedRowSize=\\\\d+, reducer=\\\\[\\\\], fragment=\\\\[<>\\\\n\")\n-            .append(\"Filter\\\\[lint\\\\{f}#\\\\d+ < \")\n-            .append(LESS_THAN_VALUE)\n-            .append(\"\\\\[INTEGER]]\\\\n\")\n-            .append(\"\\\\\\\\_EsRelation\\\\[test]\\\\[LOOKUP]\\\\[\\\\]<>\\\\]\\\\]\");\n-        sb.append(\")\");\n+\n+        if (applyRightFilterAsJoinOnFilter && operation != null) {\n+            // When applyRightFilterAsJoinOnFilter is true, right_pre_join_plan should be null\n+            sb.append(\"right_pre_join_plan=null\");\n+        } else {\n+            // Accept either the legacy physical plan rendering (FilterExec/EsQueryExec) or the new FragmentExec rendering\n+            sb.append(\"right_pre_join_plan=(?:\");\n+            // Legacy pattern\n+            sb.append(\"FilterExec\\\\[lint\\\\{f}#\\\\d+ < \")\n+                .append(LESS_THAN_VALUE)\n+                .append(\n+                    \"\\\\[INTEGER]]\\\\n\\\\\\\\_EsQueryExec\\\\[test], indexMode\\\\[lookup],\\\\s*(?:query\\\\[\\\\]|\\\\[\\\\])?,?\\\\s*\"\n+                        + \"limit\\\\[\\\\],?\\\\s*sort\\\\[(?:\\\\[\\\\])?\\\\]\\\\s*estimatedRowSize\\\\[null\\\\]\\\\s*queryBuilderAndTags \\\\[(?:\\\\[\\\\]\\\\])\\\\]\"\n+                );\n+            sb.append(\"|\");\n+            // New FragmentExec pattern - match the actual output format\n+            sb.append(\"FragmentExec\\\\[filter=null, estimatedRowSize=\\\\d+, reducer=\\\\[\\\\], fragment=\\\\[<>\\\\n\")\n+                .append(\"Filter\\\\[lint\\\\{f}#\\\\d+ < \")\n+                .append(LESS_THAN_VALUE)\n+                .append(\"\\\\[INTEGER]]\\\\n\")\n+                .append(\"\\\\\\\\_EsRelation\\\\[test]\\\\[LOOKUP]\\\\[\\\\]<>\\\\]\\\\]\");\n+            sb.append(\")\");\n+        }\n+\n         // Accept join_on_expression=null or a valid join predicate\n-        sb.append(\" join_on_expression=(null|match\\\\d+left [=!<>]+ match\\\\d+right( AND match\\\\d+left [=!<>]+ match\\\\d+right)*|)\\\\]\");\n+        if (applyRightFilterAsJoinOnFilter && operation != null) {\n+            // When applyRightFilterAsJoinOnFilter is true and operation is not null, the join expression includes the filter condition\n+            sb.append(\n+                \" join_on_expression=(match\\\\d+left [=!<>]+ match\\\\d+right( \"\n+                    + \"AND match\\\\d+left [=!<>]+ match\\\\d+right)* AND lint\\\\{f}#\\\\d+ < \"\n+            ).append(LESS_THAN_VALUE).append(\"\\\\[INTEGER]|)\\\\]\");\n+        } else {\n+            // Standard pattern for other cases\n+            sb.append(\" join_on_expression=(null|match\\\\d+left [=!<>]+ match\\\\d+right( AND match\\\\d+left [=!<>]+ match\\\\d+right)*|)\\\\]\");\n+        }\n         return matchesPattern(sb.toString());\n     }\n "
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/AbstractLogicalPlanOptimizerTests.java",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "patch": "@@ -15,6 +15,7 @@\n import org.elasticsearch.xpack.esql.analysis.Analyzer;\n import org.elasticsearch.xpack.esql.analysis.AnalyzerTestUtils;\n import org.elasticsearch.xpack.esql.analysis.EnrichResolution;\n+import org.elasticsearch.xpack.esql.analysis.MutableAnalyzerContext;\n import org.elasticsearch.xpack.esql.core.type.EsField;\n import org.elasticsearch.xpack.esql.expression.function.EsqlFunctionRegistry;\n import org.elasticsearch.xpack.esql.index.EsIndex;\n@@ -217,6 +218,13 @@ protected LogicalPlan optimizedPlan(String query) {\n         return plan(query);\n     }\n \n+    protected LogicalPlan optimizedPlan(String query, TransportVersion transportVersion) {\n+        MutableAnalyzerContext mutableContext = (MutableAnalyzerContext) analyzer.context();\n+        try (var restore = mutableContext.setTemporaryTransportVersionOnOrAfter(transportVersion)) {\n+            return optimizedPlan(query);\n+        }\n+    }\n+\n     protected LogicalPlan plan(String query) {\n         return plan(query, logicalOptimizer);\n     }"
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/LogicalPlanOptimizerTests.java",
      "status": "modified",
      "additions": 163,
      "deletions": 0,
      "changes": 163,
      "patch": "@@ -78,6 +78,7 @@\n import org.elasticsearch.xpack.esql.expression.function.scalar.multivalue.MvSum;\n import org.elasticsearch.xpack.esql.expression.function.scalar.nulls.Coalesce;\n import org.elasticsearch.xpack.esql.expression.function.scalar.string.Concat;\n+import org.elasticsearch.xpack.esql.expression.function.scalar.string.regex.WildcardLike;\n import org.elasticsearch.xpack.esql.expression.function.vector.Knn;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.And;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.Not;\n@@ -177,6 +178,7 @@\n import static org.elasticsearch.xpack.esql.EsqlTestUtils.singleValue;\n import static org.elasticsearch.xpack.esql.EsqlTestUtils.testAnalyzerContext;\n import static org.elasticsearch.xpack.esql.EsqlTestUtils.withDefaultLimitWarning;\n+import static org.elasticsearch.xpack.esql.analysis.Analyzer.ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION;\n import static org.elasticsearch.xpack.esql.analysis.Analyzer.NO_FIELDS;\n import static org.elasticsearch.xpack.esql.analysis.AnalyzerTestUtils.analyze;\n import static org.elasticsearch.xpack.esql.analysis.AnalyzerTestUtils.defaultAnalyzer;\n@@ -5405,6 +5407,82 @@ public void testPlanSanityCheckWithBinaryPlans() {\n         assertThat(e.getMessage(), containsString(\" optimized incorrectly due to missing references from right hand side [language_code\"));\n     }\n \n+    /**\n+     * Expected\n+     * <pre>{@code\n+     * Limit[1000[INTEGER],true]\n+     * \\_Join[LEFT,[languages{f}#8],[language_code{f}#16],languages{f}#8 == language_code{f}#16 AND language_name{f}#17 == English\n+     * [KEYWORD]]\n+     *   |_Limit[1000[INTEGER],false]\n+     *   | \\_EsRelation[test][_meta_field{f}#11, emp_no{f}#5, first_name{f}#6, ge..]\n+     *   \\_EsRelation[languages_lookup][LOOKUP][language_code{f}#16, language_name{f}#17]\n+     * }</pre>\n+     */\n+    public void testLookupJoinRightFilter() {\n+        assumeTrue(\"Requires LOOKUP JOIN\", EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled());\n+\n+        var plan = optimizedPlan(\"\"\"\n+              FROM test\n+            | LOOKUP JOIN languages_lookup ON languages == language_code and language_name == \"English\"\n+            \"\"\", ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION);\n+\n+        var upperLimit = asLimit(plan, 1000, true);\n+        var join = as(upperLimit.child(), Join.class);\n+        assertEquals(\"ON languages == language_code and language_name == \\\"English\\\"\", join.config().joinOnConditions().toString());\n+        var limitPastJoin = asLimit(join.left(), 1000, false);\n+        as(limitPastJoin.child(), EsRelation.class);\n+        as(join.right(), EsRelation.class);\n+    }\n+\n+    public void testLookupJoinRightFilterMatch() {\n+        assumeTrue(\"Requires LOOKUP JOIN\", EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled());\n+\n+        var plan = optimizedPlan(\"\"\"\n+              FROM test\n+            | LOOKUP JOIN languages_lookup ON languages == language_code and MATCH(language_name,\"English\")\n+            \"\"\", ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION);\n+\n+        var upperLimit = asLimit(plan, 1000, true);\n+        var join = as(upperLimit.child(), Join.class);\n+        assertEquals(\"ON languages == language_code and MATCH(language_name,\\\"English\\\")\", join.config().joinOnConditions().toString());\n+        var limitPastJoin = asLimit(join.left(), 1000, false);\n+        as(limitPastJoin.child(), EsRelation.class);\n+        as(join.right(), EsRelation.class);\n+    }\n+\n+    /**\n+     * Limit[1000[INTEGER],false]\n+     * \\_Filter[LIKE(language_name{f}#18, \"French*\", false)]\n+     *   \\_Join[LEFT,[languages{f}#9],[language_code{f}#17],languages{f}#9 == language_code{f}#17 AND MATCH(language_name{f}#18,\n+     * English[KEYWORD])]\n+     *     |_EsRelation[test][_meta_field{f}#12, emp_no{f}#6, first_name{f}#7, ge..]\n+     *     \\_Filter[LIKE(language_name{f}#18, \"French*\", false)]\n+     *       \\_EsRelation[languages_lookup][LOOKUP][language_code{f}#17, language_name{f}#18]\n+     */\n+    public void testLookupJoinRightFilterMatchWithWhereClause() {\n+        assumeTrue(\"Requires LOOKUP JOIN\", EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled());\n+\n+        var plan = optimizedPlan(\"\"\"\n+              FROM test\n+            | LOOKUP JOIN languages_lookup ON languages == language_code and MATCH(language_name,\"English\")\n+            | WHERE language_name LIKE \"French*\"\n+            \"\"\", ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION);\n+\n+        var upperLimit = asLimit(plan, 1000, false);\n+        var topFilter = as(upperLimit.child(), Filter.class);\n+        var join = as(topFilter.child(), Join.class);\n+        assertEquals(\"ON languages == language_code and MATCH(language_name,\\\"English\\\")\", join.config().joinOnConditions().toString());\n+\n+        // Check that the LIKE condition is pushed down as a right pre-join filter\n+        var rightFilter = as(join.right(), Filter.class);\n+        var likeCondition = as(rightFilter.condition(), WildcardLike.class);\n+        var field = as(likeCondition.field(), FieldAttribute.class);\n+        assertEquals(\"language_name\", field.name());\n+        assertEquals(\"French*\", likeCondition.pattern().pattern());\n+\n+        as(rightFilter.child(), EsRelation.class);\n+    }\n+\n     // https://github.com/elastic/elasticsearch/issues/104995\n     public void testNoWrongIsNotNullPruning() {\n         var plan = optimizedPlan(\"\"\"\n@@ -7332,6 +7410,91 @@ public void testLookupJoinPushDownSeparatedForConjunctionBetweenLeftAndRightFiel\n         var rightRel = as(rightFilter.child(), EsRelation.class);\n     }\n \n+    /**\n+     * Limit[1000[INTEGER],true]\n+     * \\_Join[LEFT,[emp_no{f}#5],[id{f}#16],emp_no{f}#5 == id{f}#16 AND SPATIALINTERSECTS([1 3 0 0 0 1 0 0 0 5 0 0 0 0 0 0 0 0\n+     * 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 f0 3f 0 0 0 0 0 0 0 0 0 0 0 0 0 0 f0 3f 0 0 0 0 0 0 f0 3f 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n+     * f0 3f 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0][GEO_SHAPE],shape{f}#19)]\n+     *   |_Limit[1000[INTEGER],false]\n+     *   | \\_EsRelation[test][_meta_field{f}#11, emp_no{f}#5, first_name{f}#6, ge..]\n+     *   \\_EsRelation[spatial_lookup][LOOKUP][contains{f}#18, id{f}#16, intersects{f}#17, shape{f..]\n+     */\n+    public void testLookupJoinRightFilterSpatialIntersects() {\n+        assumeTrue(\"Requires LOOKUP JOIN\", EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled());\n+\n+        var plan = optimizedPlan(\"\"\"\n+              FROM test\n+            | LOOKUP JOIN spatial_lookup ON emp_no == id AND ST_INTERSECTS(TO_GEOSHAPE(\"POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))\"), shape)\n+            \"\"\", ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION);\n+\n+        var upperLimit = asLimit(plan, 1000, true);\n+        var join = as(upperLimit.child(), Join.class);\n+        assertEquals(\n+            \"ON emp_no == id AND ST_INTERSECTS(TO_GEOSHAPE(\\\"POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))\\\"), shape)\",\n+            join.config().joinOnConditions().toString()\n+        );\n+        var limitPastJoin = asLimit(join.left(), 1000, false);\n+        as(limitPastJoin.child(), EsRelation.class);\n+        as(join.right(), EsRelation.class);\n+    }\n+\n+    /**\n+     * Limit[1000[INTEGER],true]\n+     * \\_Join[LEFT,[emp_no{f}#5],[id{f}#16],emp_no{f}#5 == id{f}#16 AND SPATIALINTERSECTS([1 3 0 0 0 1 0 0 0 5 0 0 0 0 0 0 0 0\n+     * 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 f0 3f 0 0 0 0 0 0 0 0 0 0 0 0 0 0 f0 3f 0 0 0 0 0 0 f0 3f 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n+     * f0 3f 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0][GEO_SHAPE],shape{f}#19)]\n+     *   |_Limit[1000[INTEGER],false]\n+     *   | \\_EsRelation[test][_meta_field{f}#11, emp_no{f}#5, first_name{f}#6, ge..]\n+     *   \\_EsRelation[spatial_lookup][LOOKUP][contains{f}#18, id{f}#16, intersects{f}#17, shape{f..]\n+     */\n+    public void testLookupJoinRightFilterSpatialWithin() {\n+        assumeTrue(\"Requires LOOKUP JOIN\", EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled());\n+\n+        var plan = optimizedPlan(\"\"\"\n+              FROM test\n+            | LOOKUP JOIN spatial_lookup ON emp_no == id AND ST_WITHIN(shape, TO_GEOSHAPE(\"POLYGON((0 0, 2 0, 2 2, 0 2, 0 0))\"))\n+            \"\"\", ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION);\n+\n+        var upperLimit = asLimit(plan, 1000, true);\n+        var join = as(upperLimit.child(), Join.class);\n+        assertEquals(\n+            \"ON emp_no == id AND ST_WITHIN(shape, TO_GEOSHAPE(\\\"POLYGON((0 0, 2 0, 2 2, 0 2, 0 0))\\\"))\",\n+            join.config().joinOnConditions().toString()\n+        );\n+        var limitPastJoin = asLimit(join.left(), 1000, false);\n+        as(limitPastJoin.child(), EsRelation.class);\n+        as(join.right(), EsRelation.class);\n+    }\n+\n+    /**\n+     * Limit[1000[INTEGER],true]\n+     * \\_Join[LEFT,[emp_no{f}#5],[id{f}#16],emp_no{f}#5 == id{f}#16 AND SPATIALCONTAINS(shape{f}#19,[1 3 0 0 0 1 0 0 0 5 0 0 0\n+     * 0 0 0 0 0 0 e0 3f 0 0 0 0 0 0 e0 3f 0 0 0 0 0 0 f8 3f 0 0 0 0 0 0 e0 3f 0 0 0 0 0 0 f8 3f 0 0 0 0 0 0 f8 3f 0 0 0 0 0 0\n+     * e0 3f 0 0 0 0 0 0 f8 3f 0 0 0 0 0 0 e0 3f 0 0 0 0 0 0 e0 3f][GEO_SHAPE])]\n+     *   |_Limit[1000[INTEGER],false]\n+     *   | \\_EsRelation[test][_meta_field{f}#11, emp_no{f}#5, first_name{f}#6, ge..]\n+     *   \\_EsRelation[spatial_lookup][LOOKUP][contains{f}#18, id{f}#16, intersects{f}#17, shape{f..]\n+     */\n+    public void testLookupJoinRightFilterSpatialContains() {\n+        assumeTrue(\"Requires LOOKUP JOIN\", EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled());\n+\n+        var plan = optimizedPlan(\"\"\"\n+              FROM test\n+            | LOOKUP JOIN spatial_lookup\n+            ON emp_no == id AND ST_CONTAINS(shape, TO_GEOSHAPE(\"POLYGON((0.5 0.5, 1.5 0.5, 1.5 1.5, 0.5 1.5, 0.5 0.5))\"))\n+            \"\"\", ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION);\n+\n+        var upperLimit = asLimit(plan, 1000, true);\n+        var join = as(upperLimit.child(), Join.class);\n+        assertEquals(\n+            \"ON emp_no == id AND ST_CONTAINS(shape, TO_GEOSHAPE(\\\"POLYGON((0.5 0.5, 1.5 0.5, 1.5 1.5, 0.5 1.5, 0.5 0.5))\\\"))\",\n+            join.config().joinOnConditions().toString()\n+        );\n+        var limitPastJoin = asLimit(join.left(), 1000, false);\n+        as(limitPastJoin.child(), EsRelation.class);\n+        as(join.right(), EsRelation.class);\n+    }\n+\n     /**\n      * Disjunctions however keep the filter in place, even on pushable fields\n      * <p>"
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/parser/StatementParserTests.java",
      "status": "modified",
      "additions": 103,
      "deletions": 1,
      "changes": 104,
      "patch": "@@ -35,6 +35,7 @@\n import org.elasticsearch.xpack.esql.expression.function.scalar.string.regex.RLike;\n import org.elasticsearch.xpack.esql.expression.function.scalar.string.regex.WildcardLike;\n import org.elasticsearch.xpack.esql.expression.predicate.Predicates;\n+import org.elasticsearch.xpack.esql.expression.predicate.logical.And;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.Not;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.Or;\n import org.elasticsearch.xpack.esql.expression.predicate.operator.arithmetic.Add;\n@@ -116,6 +117,13 @@\n import static org.hamcrest.Matchers.startsWith;\n \n //@TestLogging(value = \"org.elasticsearch.xpack.esql:TRACE\", reason = \"debug\")\n+\n+/**\n+ * Only parses a plan and builds an AST/Logical Plan for it.\n+ * Analysis is not run, so the plan will contain unresolved references.\n+ * Use this class to test cases where we throw a Parsing exception\n+ * especially if it is throw before we get to the Analysis phase\n+ */\n public class StatementParserTests extends AbstractStatementParserTests {\n \n     private static final LogicalPlan PROCESSING_CMD_INPUT = new Row(EMPTY, List.of(new Alias(EMPTY, \"a\", integer(1))));\n@@ -3540,6 +3548,28 @@ public void testInvalidLookupJoinOnClause() {\n             \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found\"\n         );\n \n+        expectError(\n+            \"FROM test  | LOOKUP JOIN test2 ON \"\n+                + singleExpressionJoinClause()\n+                + \" AND (\"\n+                + randomIdentifier()\n+                + \" OR \"\n+                + singleExpressionJoinClause()\n+                + \")\",\n+            \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found\"\n+        );\n+\n+        expectError(\n+            \"FROM test  | LOOKUP JOIN test2 ON \"\n+                + singleExpressionJoinClause()\n+                + \" AND (\"\n+                + randomIdentifier()\n+                + \"OR\"\n+                + randomIdentifier()\n+                + \")\",\n+            \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found\"\n+        );\n+\n         expectError(\n             \"FROM test  | LOOKUP JOIN test2 ON \" + randomIdentifier() + \" AND \" + randomIdentifier(),\n             \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found\"\n@@ -3703,6 +3733,78 @@ private void testInvalidJoinPatterns(String onClause) {\n         }\n     }\n \n+    public void testLookupJoinOnExpressionWithNamedQueryParameters() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+\n+        // Test LOOKUP JOIN ON expression with named query parameters and MATCH function\n+        var plan = statement(\n+            \"FROM test | LOOKUP JOIN test2 ON left_field >= right_field AND match(left_field, ?search_term)\",\n+            new QueryParams(List.of(paramAsConstant(\"search_term\", \"elasticsearch\")))\n+        );\n+\n+        var join = as(plan, LookupJoin.class);\n+        assertThat(as(join.left(), UnresolvedRelation.class).indexPattern().indexPattern(), equalTo(\"test\"));\n+        assertThat(as(join.right(), UnresolvedRelation.class).indexPattern().indexPattern(), equalTo(\"test2\"));\n+\n+        // Verify the join condition contains both the comparison and MATCH function\n+        var condition = join.config().joinOnConditions();\n+        assertThat(condition, instanceOf(And.class));\n+        var andCondition = (And) condition;\n+\n+        // Check that we have both conditions in the correct order\n+        assertThat(andCondition.children().size(), equalTo(2));\n+\n+        // First child should be a binary comparison (left_field >= right_field)\n+        var firstChild = andCondition.children().get(0);\n+        assertThat(\"First condition should be binary comparison\", firstChild, instanceOf(EsqlBinaryComparison.class));\n+\n+        // Second child should be a MATCH function (match(left_field, ?search_term))\n+        var secondChild = andCondition.children().get(1);\n+        assertThat(\"Second condition should be UnresolvedFunction\", secondChild, instanceOf(UnresolvedFunction.class));\n+        var function = (UnresolvedFunction) secondChild;\n+        assertThat(\"Second condition should be MATCH function\", function.name(), equalTo(\"match\"));\n+    }\n+\n+    public void testLookupJoinOnExpressionWithPositionalQueryParameters() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+\n+        // Test LOOKUP JOIN ON expression with positional query parameters and MATCH function\n+        var plan = statement(\n+            \"FROM test | LOOKUP JOIN test2 ON left_field >= right_field AND match(left_field, ?2)\",\n+            new QueryParams(List.of(paramAsConstant(null, \"dummy\"), paramAsConstant(null, \"elasticsearch\")))\n+        );\n+\n+        var join = as(plan, LookupJoin.class);\n+        assertThat(as(join.left(), UnresolvedRelation.class).indexPattern().indexPattern(), equalTo(\"test\"));\n+        assertThat(as(join.right(), UnresolvedRelation.class).indexPattern().indexPattern(), equalTo(\"test2\"));\n+\n+        // Verify the join condition contains both the comparison and MATCH function\n+        var condition = join.config().joinOnConditions();\n+        assertThat(condition, instanceOf(And.class));\n+        var andCondition = (And) condition;\n+\n+        // Check that we have both conditions in the correct order\n+        assertThat(andCondition.children().size(), equalTo(2));\n+\n+        // First child should be a binary comparison (left_field >= right_field)\n+        var firstChild = andCondition.children().get(0);\n+        assertThat(\"First condition should be binary comparison\", firstChild, instanceOf(EsqlBinaryComparison.class));\n+\n+        // Second child should be a MATCH function (match(left_field, ?))\n+        var secondChild = andCondition.children().get(1);\n+        assertThat(\"Second condition should be UnresolvedFunction\", secondChild, instanceOf(UnresolvedFunction.class));\n+        var function = (UnresolvedFunction) secondChild;\n+        assertThat(\"Second condition should be MATCH function\", function.name(), equalTo(\"match\"));\n+        assertEquals(2, function.children().size());\n+        assertEquals(\"elasticsearch\", function.children().get(1).toString());\n+    }\n+\n     public void testInvalidInsistAsterisk() {\n         assumeTrue(\"requires snapshot build\", Build.current().isSnapshot());\n         expectError(\"FROM text | EVAL x = 4 | INSIST_ðŸ” *\", \"INSIST doesn't support wildcards, found [*]\");\n@@ -5080,7 +5182,7 @@ public void testMixedSingleDoubleParams() {\n                     expectError(\n                         LoggerMessageFormat.format(null, \"from test | \" + command, param1, param2, param3),\n                         List.of(paramAsConstant(\"f1\", \"f1\"), paramAsConstant(\"f2\", \"f2\"), paramAsConstant(\"f3\", \"f3\")),\n-                        \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment\"\n+                        \"JOIN ON clause must be a comma separated list of fields or a single expression, found\"\n                     );\n \n                 }"
    }
  ],
  "diff": "diff --git a/docs/changelog/136104.yaml b/docs/changelog/136104.yaml\nnew file mode 100644\nindex 0000000000000..ecb1a01ce87c5\n--- /dev/null\n+++ b/docs/changelog/136104.yaml\n@@ -0,0 +1,5 @@\n+pr: 136104\n+summary: Add support for Full Text Functions and Lucene pushable conditions on fields from the Lookup Index for Lookup Join\n+area: ES|QL\n+type: enhancement\n+issues: [ ]\ndiff --git a/server/src/main/resources/transport/definitions/referable/esql_lookup_join_full_text_function.csv b/server/src/main/resources/transport/definitions/referable/esql_lookup_join_full_text_function.csv\nnew file mode 100644\nindex 0000000000000..d8997da1b2882\n--- /dev/null\n+++ b/server/src/main/resources/transport/definitions/referable/esql_lookup_join_full_text_function.csv\n@@ -0,0 +1 @@\n+9201000\ndiff --git a/server/src/main/resources/transport/upper_bounds/9.3.csv b/server/src/main/resources/transport/upper_bounds/9.3.csv\nindex 311c14ca764ac..238cf894d79b4 100644\n--- a/server/src/main/resources/transport/upper_bounds/9.3.csv\n+++ b/server/src/main/resources/transport/upper_bounds/9.3.csv\n@@ -1 +1 @@\n-inference_cached_tokens,9200000\n+esql_lookup_join_full_text_function,9201000\ndiff --git a/test/external-modules/esql-heap-attack/src/javaRestTest/java/org/elasticsearch/xpack/esql/heap_attack/HeapAttackIT.java b/test/external-modules/esql-heap-attack/src/javaRestTest/java/org/elasticsearch/xpack/esql/heap_attack/HeapAttackIT.java\nindex d5a12db64d291..50ada817970a6 100644\n--- a/test/external-modules/esql-heap-attack/src/javaRestTest/java/org/elasticsearch/xpack/esql/heap_attack/HeapAttackIT.java\n+++ b/test/external-modules/esql-heap-attack/src/javaRestTest/java/org/elasticsearch/xpack/esql/heap_attack/HeapAttackIT.java\n@@ -861,11 +861,22 @@ private Map<String, Object> lookupExplosion(\n                 }\n             }\n             if (lookupEntries != lookupEntriesToKeep) {\n-                // add a filter to reduce the number of matches\n-                // we add both a Lucene pushable filter and a non-pushable filter\n-                // this is to make sure that even if there are non-pushable filters the pushable filters is still applied\n-                query.append(\" | WHERE ABS(filter_key) > -1 AND filter_key < \").append(lookupEntriesToKeep);\n-\n+                boolean applyAsExpressionJoinFilter = expressionBasedJoin && randomBoolean();\n+                // we randomly add the filter after the join or as part of the join\n+                // in both cases we should have the same amount of results\n+                if (applyAsExpressionJoinFilter == false) {\n+                    // add a filter after the join to reduce the number of matches\n+                    // we add both a Lucene pushable filter and a non-pushable filter\n+                    // this is to make sure that even if there are non-pushable filters the pushable filters is still applied\n+                    query.append(\" | WHERE ABS(filter_key) > -1 AND filter_key < \").append(lookupEntriesToKeep);\n+                } else {\n+                    // apply the filter as part of the join\n+                    // then we filter out the rows that do not match the filter after\n+                    // so the number of rows is the same as in the field based join case\n+                    // and can get the same number of rows for verification purposes\n+                    query.append(\" AND filter_key < \").append(lookupEntriesToKeep);\n+                    query.append(\" | WHERE filter_key IS NOT NULL \");\n+                }\n             }\n             query.append(\" | STATS COUNT(location) | LIMIT 100\\\"}\");\n             return responseAsMap(query(query.toString(), null));\ndiff --git a/x-pack/plugin/esql/qa/security/src/javaRestTest/java/org/elasticsearch/xpack/esql/EsqlSecurityIT.java b/x-pack/plugin/esql/qa/security/src/javaRestTest/java/org/elasticsearch/xpack/esql/EsqlSecurityIT.java\nindex f398485768587..8b7331248bd2c 100644\n--- a/x-pack/plugin/esql/qa/security/src/javaRestTest/java/org/elasticsearch/xpack/esql/EsqlSecurityIT.java\n+++ b/x-pack/plugin/esql/qa/security/src/javaRestTest/java/org/elasticsearch/xpack/esql/EsqlSecurityIT.java\n@@ -828,7 +828,7 @@ private void testLookupJoinFieldLevelSecurityHelper(boolean useExpressionJoin) t\n         ResponseException error = expectThrows(ResponseException.class, () -> runESQLCommand(\"fls_user4_1\", query));\n         assertThat(error.getResponse().getStatusLine().getStatusCode(), equalTo(HttpStatus.SC_BAD_REQUEST));\n         if (useExpressionJoin) {\n-            assertThat(error.getMessage(), containsString(\"Unsupported join filter expression:value_left == value\"));\n+            assertThat(error.getMessage(), containsString(\"Unknown column [value], did you mean [value_left]?\"));\n         } else {\n             assertThat(error.getMessage(), containsString(\"Unknown column [value] in right side of join\"));\n         }\n@@ -902,7 +902,7 @@ private void testLookupJoinFieldLevelSecurityOnAliasHelper(boolean useExpression\n         ResponseException error = expectThrows(ResponseException.class, () -> runESQLCommand(\"fls_user4_1_alias\", query));\n         assertThat(error.getResponse().getStatusLine().getStatusCode(), equalTo(HttpStatus.SC_BAD_REQUEST));\n         if (useExpressionJoin) {\n-            assertThat(error.getMessage(), containsString(\"Unsupported join filter expression:value_left == value\"));\n+            assertThat(error.getMessage(), containsString(\"Unknown column [value], did you mean [value_left]?\"));\n         } else {\n             assertThat(error.getMessage(), containsString(\"Unknown column [value] in right side of join\"));\n         }\ndiff --git a/x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/CsvTestsDataLoader.java b/x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/CsvTestsDataLoader.java\nindex ef3514308a436..70f0c9fd1d57a 100644\n--- a/x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/CsvTestsDataLoader.java\n+++ b/x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/CsvTestsDataLoader.java\n@@ -149,7 +149,9 @@ public class CsvTestsDataLoader {\n     private static final TestDataset DATE_NANOS_UNION_TYPES = new TestDataset(\"date_nanos_union_types\");\n     private static final TestDataset COUNTRIES_BBOX = new TestDataset(\"countries_bbox\");\n     private static final TestDataset COUNTRIES_BBOX_WEB = new TestDataset(\"countries_bbox_web\");\n-    private static final TestDataset AIRPORT_CITY_BOUNDARIES = new TestDataset(\"airport_city_boundaries\");\n+    private static final TestDataset AIRPORT_CITY_BOUNDARIES = new TestDataset(\"airport_city_boundaries\").withSetting(\n+        \"lookup-settings.json\"\n+    );\n     private static final TestDataset CARTESIAN_MULTIPOLYGONS = new TestDataset(\"cartesian_multipolygons\");\n     private static final TestDataset CARTESIAN_MULTIPOLYGONS_NO_DOC_VALUES = new TestDataset(\"cartesian_multipolygons_no_doc_values\")\n         .withData(\"cartesian_multipolygons.csv\");\ndiff --git a/x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/EsqlTestUtils.java b/x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/EsqlTestUtils.java\nindex a0f40813bb99f..39cfe2f28ece7 100644\n--- a/x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/EsqlTestUtils.java\n+++ b/x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/EsqlTestUtils.java\n@@ -62,9 +62,9 @@\n import org.elasticsearch.xcontent.XContentType;\n import org.elasticsearch.xcontent.json.JsonXContent;\n import org.elasticsearch.xpack.esql.action.EsqlQueryResponse;\n-import org.elasticsearch.xpack.esql.analysis.AnalyzerContext;\n import org.elasticsearch.xpack.esql.analysis.AnalyzerSettings;\n import org.elasticsearch.xpack.esql.analysis.EnrichResolution;\n+import org.elasticsearch.xpack.esql.analysis.MutableAnalyzerContext;\n import org.elasticsearch.xpack.esql.analysis.Verifier;\n import org.elasticsearch.xpack.esql.core.expression.Alias;\n import org.elasticsearch.xpack.esql.core.expression.Attribute;\n@@ -449,7 +449,7 @@ public static TransportVersion randomMinimumVersion() {\n     }\n \n     // TODO: make this even simpler, remove the enrichResolution for tests that do not require it (most tests)\n-    public static AnalyzerContext testAnalyzerContext(\n+    public static MutableAnalyzerContext testAnalyzerContext(\n         Configuration configuration,\n         EsqlFunctionRegistry functionRegistry,\n         Map<IndexPattern, IndexResolution> indexResolutions,\n@@ -462,7 +462,7 @@ public static AnalyzerContext testAnalyzerContext(\n     /**\n      * Analyzer context for a random (but compatible) minimum transport version.\n      */\n-    public static AnalyzerContext testAnalyzerContext(\n+    public static MutableAnalyzerContext testAnalyzerContext(\n         Configuration configuration,\n         EsqlFunctionRegistry functionRegistry,\n         Map<IndexPattern, IndexResolution> indexResolutions,\n@@ -470,7 +470,7 @@ public static AnalyzerContext testAnalyzerContext(\n         EnrichResolution enrichResolution,\n         InferenceResolution inferenceResolution\n     ) {\n-        return new AnalyzerContext(\n+        return new MutableAnalyzerContext(\n             configuration,\n             functionRegistry,\n             indexResolutions,\ndiff --git a/x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/analysis/MutableAnalyzerContext.java b/x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/analysis/MutableAnalyzerContext.java\nnew file mode 100644\nindex 0000000000000..69e7b5bdb980f\n--- /dev/null\n+++ b/x-pack/plugin/esql/qa/testFixtures/src/main/java/org/elasticsearch/xpack/esql/analysis/MutableAnalyzerContext.java\n@@ -0,0 +1,74 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License\n+ * 2.0; you may not use this file except in compliance with the Elastic License\n+ * 2.0.\n+ */\n+\n+package org.elasticsearch.xpack.esql.analysis;\n+\n+import org.elasticsearch.TransportVersion;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.TransportVersionUtils;\n+import org.elasticsearch.xpack.esql.expression.function.EsqlFunctionRegistry;\n+import org.elasticsearch.xpack.esql.index.IndexResolution;\n+import org.elasticsearch.xpack.esql.inference.InferenceResolution;\n+import org.elasticsearch.xpack.esql.plan.IndexPattern;\n+import org.elasticsearch.xpack.esql.session.Configuration;\n+\n+import java.util.Map;\n+\n+/**\n+ * A mutable version of AnalyzerContext that allows temporarily changing the transport version.\n+ * This is useful for testing scenarios where different transport versions need to be tested.\n+ */\n+public class MutableAnalyzerContext extends AnalyzerContext {\n+    private TransportVersion currentVersion;\n+\n+    public MutableAnalyzerContext(\n+        Configuration configuration,\n+        EsqlFunctionRegistry functionRegistry,\n+        Map<IndexPattern, IndexResolution> indexResolution,\n+        Map<String, IndexResolution> lookupResolution,\n+        EnrichResolution enrichResolution,\n+        InferenceResolution inferenceResolution,\n+        TransportVersion minimumVersion\n+    ) {\n+        super(configuration, functionRegistry, indexResolution, lookupResolution, enrichResolution, inferenceResolution, minimumVersion);\n+        this.currentVersion = minimumVersion;\n+    }\n+\n+    @Override\n+    public TransportVersion minimumVersion() {\n+        return currentVersion;\n+    }\n+\n+    /**\n+     * Temporarily set the transport version to a random version between the passed-in version and the latest,\n+     * and return an AutoCloseable to restore it.\n+     * Usage:\n+     * try (var restore = context.setTemporaryTransportVersionOnOrAfter(minVersion)) {...}\n+     */\n+    public RestoreTransportVersion setTemporaryTransportVersionOnOrAfter(TransportVersion minVersion) {\n+        TransportVersion oldVersion = this.currentVersion;\n+        // Set to a random version between minVersion and current\n+        this.currentVersion = TransportVersionUtils.randomVersionBetween(ESTestCase.random(), minVersion, TransportVersion.current());\n+        return new RestoreTransportVersion(oldVersion);\n+    }\n+\n+    /**\n+     * AutoCloseable that restores the original transport version when closed.\n+     */\n+    public class RestoreTransportVersion implements AutoCloseable {\n+        private final TransportVersion originalVersion;\n+\n+        private RestoreTransportVersion(TransportVersion originalVersion) {\n+            this.originalVersion = originalVersion;\n+        }\n+\n+        @Override\n+        public void close() {\n+            MutableAnalyzerContext.this.currentVersion = originalVersion;\n+        }\n+    }\n+}\ndiff --git a/x-pack/plugin/esql/qa/testFixtures/src/main/resources/lookup-join-expression.csv-spec b/x-pack/plugin/esql/qa/testFixtures/src/main/resources/lookup-join-expression.csv-spec\nindex 44a16bbcf0c31..f0f961f7d6c2d 100644\n--- a/x-pack/plugin/esql/qa/testFixtures/src/main/resources/lookup-join-expression.csv-spec\n+++ b/x-pack/plugin/esql/qa/testFixtures/src/main/resources/lookup-join-expression.csv-spec\n@@ -725,6 +725,9 @@ id_int:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:int\n 14             | Nina             | foo2           | omicron        | 15000\n ;\n \n+\n+\n+\n lookupJoinExpressionOnUnionTypes\n required_capability: join_lookup_v12\n required_capability: lookup_join_on_boolean_expression\n@@ -747,3 +750,504 @@ apps           | 2                     | French\n apps_short     | 1                     | English\n apps_short     | 2                     | French\n ;\n+\n+lookupJoinWithGreaterThanCondition\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON id_int == id_left and is_active_left == is_active_bool AND other2 > 10000\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON id_int == id_left and is_active_left == is_active_bool AND other2 > 10000] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | null             | foo            | null           | null\n+[1, 19, 21]     | null             | zyx            | null           | null\n+2               | null             | bar            | null           | null\n+3               | null             | baz            | null           | null\n+4               | null             | qux            | null           | null\n+5               | null             | quux           | null           | null\n+6               | null             | corge          | null           | null\n+7               | null             | grault         | null           | null\n+8               | Hank             | garply         | lambda         | 11000\n+9               | null             | waldo          | null           | null\n+10              | null             | fred           | null           | null\n+12              | Liam             | xyzzy          | nu             | 13000\n+13              | Mia              | thud           | xi             | 14000\n+14              | Nina             | foo2           | omicron        | 15000\n+15              | null             | bar2           | null           | null\n+[17, 18]        | null             | xyz            | null           | null\n+null            | null             | plugh          | null           | null\n+;\n+\n+lookupJoinWithLikeCondition\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON id_int == id_left and is_active_left == is_active_bool AND other1 like \"*ta\"\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON id_int == id_left and is_active_left == is_active_bool AND other1 like \\\"*ta\\\"] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+[1, 19, 21]     | null             | zyx            | null           | null\n+2               | null             | bar            | null           | null\n+3               | Charlie          | baz            | delta          | 4000\n+4               | David            | qux            | zeta           | 6000\n+5               | Eve              | quux           | eta            | 7000\n+5               | Eve              | quux           | theta          | 8000\n+6               | null             | corge          | iota           | 9000\n+7               | null             | grault         | null           | null\n+8               | null             | garply         | null           | null\n+9               | null             | waldo          | null           | null\n+10              | null             | fred           | null           | null\n+12              | null             | xyzzy          | null           | null\n+13              | null             | thud           | null           | null\n+14              | null             | foo2           | null           | null\n+15              | null             | bar2           | null           | null\n+[17, 18]        | null             | xyz            | null           | null\n+null            | null             | plugh          | null           | null\n+;\n+\n+lookupJoinWithOrOfLikeGt\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON id_int == id_left and is_active_left == is_active_bool AND (other1 like \"*ta\" OR other2 > 10000)\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON id_int == id_left and is_active_left == is_active_bool AND (other1 like \\\"*ta\\\" OR other2 > 10000)] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+[1, 19, 21]     | null             | zyx            | null           | null\n+2               | null             | bar            | null           | null\n+3               | Charlie          | baz            | delta          | 4000\n+4               | David            | qux            | zeta           | 6000\n+5               | Eve              | quux           | eta            | 7000\n+5               | Eve              | quux           | theta          | 8000\n+6               | null             | corge          | iota           | 9000\n+7               | null             | grault         | null           | null\n+8               | Hank             | garply         | lambda         | 11000\n+9               | null             | waldo          | null           | null\n+10              | null             | fred           | null           | null\n+12              | Liam             | xyzzy          | nu             | 13000\n+13              | Mia              | thud           | xi             | 14000\n+14              | Nina             | foo2           | omicron        | 15000\n+15              | null             | bar2           | null           | null\n+[17, 18]        | null             | xyz            | null           | null\n+null            | null             | plugh          | null           | null\n+;\n+\n+lookupJoinExpressionWithMatch\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON MATCH(other1, \"beta\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON MATCH(other1, \\\"beta\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+;\n+\n+lookupJoinOnSameFieldTwiceWithOrNot\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, name_str AS name_left, is_active_bool AS is_active_left, ip_addr AS ip_addr_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON (other2 < 12000 OR NOT (other1 != \"omicron\" AND other1 != \"nu\")) AND id_left == id_int AND  name_left == name_str AND  id_left < other2\n+| KEEP id_left, name_left, extra1, other1, other2\n+| SORT id_left, name_left, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON (other2 < 12000 OR NOT (other1 != \\\"omicron\\\" AND other1 != \\\"nu\\\")) AND id_left == id_int AND  name_left == name_str AND  id_left < other2] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_left:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice             | foo            | alpha          | 1000\n+1               | Alice             | foo            | beta           | 2000\n+[1, 19, 21]     | Sophia            | zyx            | null           | null\n+2               | Bob               | bar            | gamma          | 3000\n+3               | Charlie           | baz            | delta          | 4000\n+3               | Charlie           | baz            | epsilon        | 5000\n+4               | David             | qux            | zeta           | 6000\n+5               | Eve               | quux           | eta            | 7000\n+5               | Eve               | quux           | theta          | 8000\n+6               | null              | corge          | null           | null\n+7               | Grace             | grault         | kappa          | 10000\n+8               | Hank              | garply         | lambda         | 11000\n+9               | Ivy               | waldo          | null           | null\n+10              | John              | fred           | null           | null\n+12              | Liam              | xyzzy          | nu             | 13000\n+13              | Mia               | thud           | null           | null\n+14              | Nina              | foo2           | omicron        | 15000\n+15              | Oscar             | bar2           | null           | null\n+[17, 18]        | Olivia            | xyz            | null           | null\n+null            | Kate              | plugh          | null           | null\n+;\n+\n+\n+lookupJoinOnSameFieldWithPushableRightFilterAfter\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, name_str AS name_left, is_active_bool AS is_active_left, ip_addr AS ip_addr_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON (other2 < 12000 OR NOT (other1 != \"omicron\" AND other1 != \"nu\")) AND id_left == id_int AND  name_left == name_str AND  id_left < other2\n+| WHERE other1 like (\"a*\", \"b*\", \"o*\")\n+| KEEP id_left, name_left, extra1, other1, other2\n+| SORT id_left, name_left, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON (other2 < 12000 OR NOT (other1 != \\\"omicron\\\" AND other1 != \\\"nu\\\")) AND id_left == id_int AND  name_left == name_str AND  id_left < other2] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_left:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice             | foo            | alpha          | 1000\n+1               | Alice             | foo            | beta           | 2000\n+14              | Nina              | foo2           | omicron        | 15000\n+;\n+\n+twoLookupJoinsInSameQueryOtherFilter\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| WHERE id_int == 1\n+| RENAME id_int AS id_left, name_str AS name_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON id_left == id_int AND name_left == name_str\n+| RENAME other1 AS other1_from_first_join, id_int AS id_from_first_join, name_str AS name_from_first_join\n+| LOOKUP JOIN multi_column_joinable_lookup ON id_left == id_int AND other1_from_first_join != other1 AND other1 like (\"a*\", \"c*\")\n+| KEEP id_left, name_left, other1_from_first_join, other1\n+| SORT id_left, name_left, other1_from_first_join, other1\n+;\n+\n+warning:Line 2:9: evaluation of [id_int == 1] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 2:9: java.lang.IllegalArgumentException: single-value function encountered multi-value\n+\n+id_left:integer | name_left:keyword | other1_from_first_join:keyword | other1:keyword\n+1               | Alice             | alpha                          | null\n+1               | Alice             | beta                           | alpha\n+;\n+\n+lookupJoinExpressionWithTerm\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON TERM(other1, \"beta\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON TERM(other1, \\\"beta\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+;\n+\n+lookupJoinExpressionWithQueryString\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON QSTR(\"other1:alpha OR other1:beta\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON QSTR(\\\"other1:alpha OR other1:beta\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | alpha          | 1000\n+1               | Alice            | foo            | beta           | 2000\n+;\n+\n+lookupJoinExpressionWithKql\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON KQL(\"other1:alpha OR other1:beta\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON KQL(\\\"other1:alpha OR other1:beta\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | alpha          | 1000\n+1               | Alice            | foo            | beta           | 2000\n+;\n+\n+lookupJoinExpressionWithMultiMatch\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left, name_str AS name_str_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON MULTI_MATCH(\"beta\", other1, name_str) AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON MULTI_MATCH(\\\"beta\\\", other1, name_str) AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+;\n+\n+lookupJoinExpressionWithMatchPhrase\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON MATCH_PHRASE(other1, \"beta\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON MATCH_PHRASE(other1, \\\"beta\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+;\n+\n+lookupJoinExpressionWithCidrMatch\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left, ip_addr AS ip_addr_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON CIDR_MATCH(ip_addr, \"192.168.1.0/30\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2, ip_addr\n+| SORT id_left, name_str, extra1, other1, other2, ip_addr\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON CIDR_MATCH(ip_addr, \\\"192.168.1.0/30\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer | ip_addr:ip\n+1               | Alice            | foo            | alpha          | 1000           | 192.168.1.1\n+1               | Alice            | foo            | beta           | 2000           | 192.168.1.2\n+2               | Bob              | bar            | gamma          | 3000           | 192.168.1.3\n+3               | Charlie          | baz            | delta          | 4000           | 192.168.1.3\n+;\n+\n+lookupJoinExpressionWithIn\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON other1 IN (\"alpha\", \"beta\", \"gamma\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON other1 IN (\\\"alpha\\\", \\\"beta\\\", \\\"gamma\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | alpha          | 1000\n+1               | Alice            | foo            | beta           | 2000\n+2               | Bob              | bar            | gamma          | 3000\n+;\n+\n+lookupJoinExpressionWithIsNull\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON other1 IS NULL AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON other1 IS NULL AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+;\n+\n+lookupJoinExpressionWithIsNotNull\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON other1 IS NOT NULL AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON other1 IS NOT NULL AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | alpha          | 1000\n+1               | Alice            | foo            | beta           | 2000\n+2               | Bob              | bar            | gamma          | 3000\n+3               | Charlie          | baz            | delta          | 4000\n+4               | David            | qux            | zeta           | 6000\n+5               | Eve              | quux           | eta            | 7000\n+5               | Eve              | quux           | theta          | 8000\n+6               | null             | corge          | iota           | 9000\n+7               | Grace            | grault         | kappa          | 10000\n+8               | Hank             | garply         | lambda         | 11000\n+12              | Liam             | xyzzy          | nu             | 13000\n+13              | Mia              | thud           | xi             | 14000\n+14              | Nina             | foo2           | omicron        | 15000\n+;\n+\n+lookupJoinExpressionWithStartsWith\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON STARTS_WITH(other1, \"al\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON STARTS_WITH(other1, \\\"al\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | alpha          | 1000\n+;\n+\n+lookupJoinExpressionWithEndsWith\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM multi_column_joinable\n+| RENAME id_int AS id_left, is_active_bool AS is_active_left\n+| LOOKUP JOIN multi_column_joinable_lookup ON ENDS_WITH(other1, \"ta\") AND id_int == id_left and is_active_left == is_active_bool\n+| WHERE other2 IS NOT NULL\n+| KEEP id_left, name_str, extra1, other1, other2\n+| SORT id_left, name_str, extra1, other1, other2\n+;\n+\n+warning:Line 3:3: evaluation of [LOOKUP JOIN multi_column_joinable_lookup ON ENDS_WITH(other1, \\\"ta\\\") AND id_int == id_left and is_active_left == is_active_bool] failed, treating result as null. Only first 20 failures recorded.\n+warning:Line 3:3: java.lang.IllegalArgumentException: LOOKUP JOIN encountered multi-value\n+\n+id_left:integer | name_str:keyword | extra1:keyword | other1:keyword | other2:integer\n+1               | Alice            | foo            | beta           | 2000\n+3               | Charlie          | baz            | delta          | 4000\n+4               | David            | qux            | zeta           | 6000\n+5               | Eve              | quux           | eta            | 7000\n+5               | Eve              | quux           | theta          | 8000\n+6               | null             | corge          | iota           | 9000\n+;\n+\n+lookupJoinExpressionWithAirportIntersects\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM airports\n+| RENAME abbrev AS airport_code\n+| LOOKUP JOIN airport_city_boundaries ON airport_code == abbrev AND ST_INTERSECTS(TO_GEOSHAPE(\"POLYGON((-74.5 40.4, -73.5 40.4, -73.5 41.0, -74.5 41.0, -74.5 40.4))\"), city_boundary)\n+| WHERE city is not null\n+| KEEP airport_code, name, city, country, city_boundary\n+| SORT airport_code, name, city, country\n+;\n+\n+airport_code:keyword | name:text | city:keyword | country:keyword | city_boundary:geo_shape\n+EWR                  | Newark Int'l         | New York     | United States   | POLYGON ((-74.2588 40.4989, -74.2253 40.4766, -73.9779 40.5191, -73.9021 40.4921, -73.8126 40.53, -73.7572 40.5312, -73.7565 40.5862, -73.7381 40.6026, -73.7681 40.6263, -73.7248 40.6523, -73.7303 40.7222, -73.7002 40.7393, -73.7797 40.8121, -73.7484 40.8718, -73.8382 40.8941, -73.8511 40.9101, -73.8593 40.9005, -73.9183 40.9176, -74.014 40.7576, -74.0558 40.6515, -74.1914 40.642, -74.2146 40.5605, -74.2475 40.5494, -74.2588 40.4989))\n+JFK                  | John F Kennedy Int'l | New York     | United States   | POLYGON ((-74.2588 40.4989, -74.2253 40.4766, -73.9779 40.5191, -73.9021 40.4921, -73.8126 40.53, -73.7572 40.5312, -73.7565 40.5862, -73.7381 40.6026, -73.7681 40.6263, -73.7248 40.6523, -73.7303 40.7222, -73.7002 40.7393, -73.7797 40.8121, -73.7484 40.8718, -73.8382 40.8941, -73.8511 40.9101, -73.8593 40.9005, -73.9183 40.9176, -74.014 40.7576, -74.0558 40.6515, -74.1914 40.642, -74.2146 40.5605, -74.2475 40.5494, -74.2588 40.4989))\n+LGA                  | LaGuardia            | New York     | United States   | POLYGON ((-74.2588 40.4989, -74.2253 40.4766, -73.9779 40.5191, -73.9021 40.4921, -73.8126 40.53, -73.7572 40.5312, -73.7565 40.5862, -73.7381 40.6026, -73.7681 40.6263, -73.7248 40.6523, -73.7303 40.7222, -73.7002 40.7393, -73.7797 40.8121, -73.7484 40.8718, -73.8382 40.8941, -73.8511 40.9101, -73.8593 40.9005, -73.9183 40.9176, -74.014 40.7576, -74.0558 40.6515, -74.1914 40.642, -74.2146 40.5605, -74.2475 40.5494, -74.2588 40.4989))\n+;\n+\n+lookupJoinExpressionWithAirportWithin\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM airports\n+| RENAME abbrev AS airport_code\n+| LOOKUP JOIN airport_city_boundaries ON airport_code == abbrev AND ST_INTERSECTS(TO_GEOSHAPE(\"POLYGON((-0.5 51.4, -0.2 51.4, -0.2 51.5, -0.5 51.5, -0.5 51.4))\"), city_boundary)\n+| WHERE city is not null\n+| KEEP airport_code, name, city, country, city_boundary\n+| SORT airport_code, name, city, country\n+;\n+\n+airport_code:keyword | name:text | city:keyword | country:keyword | city_boundary:geo_shape\n+LHR                  | London Heathrow | Hounslow | United Kingdom | POLYGON((-0.4615 51.449, -0.3855 51.4206, -0.3668 51.4416, -0.3878 51.4494, -0.327 51.457, -0.2921 51.4873, -0.2565 51.4715, -0.2444 51.4979, -0.4092 51.5003, -0.4112 51.4699, -0.4615 51.449))\n+;\n+\n+lookupJoinExpressionWithAirportContains\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM airports\n+| RENAME abbrev AS airport_code\n+| LOOKUP JOIN airport_city_boundaries ON airport_code == abbrev AND ST_CONTAINS(TO_GEOSHAPE(\"POLYGON((-0.3 51.0, -0.1 51.0, -0.1 51.2, -0.3 51.2, -0.3 51.0))\"), city_boundary)\n+| WHERE city is not null\n+| KEEP airport_code, name, city, country, city_boundary\n+| SORT airport_code, name, city, country\n+;\n+\n+airport_code:keyword | name:text | city:keyword | country:keyword | city_boundary:geo_shape\n+LGW                  | London Gatwick | Crawley | United Kingdom | POLYGON((-0.2556 51.1418, -0.2003 51.1391, -0.2369 51.1094, -0.1964 51.0848, -0.1395 51.1081, -0.133 51.1589, -0.1785 51.1672, -0.2556 51.1418))\n+;\n+\n+lookupJoinExpressionWithAirportGeoPoint\n+required_capability: join_lookup_v12\n+required_capability: lookup_join_with_full_text_function\n+\n+FROM airports\n+| RENAME abbrev AS airport_code\n+| LOOKUP JOIN airport_city_boundaries ON airport_code == abbrev AND ST_INTERSECTS(TO_GEOPOINT(\"POINT(-0.376227267397439 51.8802952570969)\"), city_boundary)\n+| WHERE city is not null\n+| KEEP airport_code, name, city, country, location, city_boundary\n+| SORT airport_code, name, city, country\n+;\n+\n+airport_code:keyword | name:text | city:keyword | country:keyword | location:geo_point | city_boundary:geo_shape\n+LTN                  | London Luton | Luton | United Kingdom | POINT(-0.376227267397439 51.8802952570969) | POLYGON((-0.5059 51.9006, -0.4225 51.8545, -0.3499 51.8787, -0.3856 51.9157, -0.4191 51.9123, -0.4263 51.9267, -0.4857 51.9227, -0.4823 51.9078, -0.5059 51.9006))\n+;\ndiff --git a/x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/action/LookupFromIndexIT.java b/x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/action/LookupFromIndexIT.java\nindex 9af360dd1695c..f2fdb24e88dc4 100644\n--- a/x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/action/LookupFromIndexIT.java\n+++ b/x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/action/LookupFromIndexIT.java\n@@ -250,7 +250,7 @@ private PhysicalPlan buildGreaterThanFilter(long value) {\n         return new FragmentExec(filter);\n     }\n \n-    private void runLookup(List<DataType> keyTypes, PopulateIndices populateIndices, PhysicalPlan filters) throws IOException {\n+    private void runLookup(List<DataType> keyTypes, PopulateIndices populateIndices, PhysicalPlan pushedDownFilter) throws IOException {\n         String[] fieldMappers = new String[keyTypes.size() * 2];\n         for (int i = 0; i < keyTypes.size(); i++) {\n             fieldMappers[2 * i] = \"key\" + i;\n@@ -283,17 +283,8 @@ private void runLookup(List<DataType> keyTypes, PopulateIndices populateIndices,\n         client().admin().cluster().prepareHealth(TEST_REQUEST_TIMEOUT).setWaitForGreenStatus().get();\n \n         Predicate<Integer> filterPredicate = l -> true;\n-        if (filters instanceof FragmentExec fragmentExec) {\n-            if (fragmentExec.fragment() instanceof Filter filter\n-                && filter.condition() instanceof GreaterThan gt\n-                && gt.left() instanceof FieldAttribute fa\n-                && fa.name().equals(\"l\")\n-                && gt.right() instanceof Literal lit) {\n-                long value = ((Number) lit.value()).longValue();\n-                filterPredicate = l -> l > value;\n-            } else {\n-                fail(\"Unsupported filter type in test baseline generation: \" + filters);\n-            }\n+        if (pushedDownFilter instanceof FragmentExec fragmentExec && fragmentExec.fragment() instanceof Filter filter) {\n+            filterPredicate = getPredicateFromFilter(filter);\n         }\n \n         int docCount = between(10, 1000);\n@@ -396,6 +387,16 @@ private void runLookup(List<DataType> keyTypes, PopulateIndices populateIndices,\n                         new EsField(\"rkey\" + i, keyTypes.get(i), Collections.emptyMap(), true, EsField.TimeSeriesFieldType.NONE)\n                     );\n                     joinOnConditions.add(new Equals(Source.EMPTY, leftAttr, rightAttr));\n+                    // randomly decide to apply the filter as additional join on filter instead of pushed down filter\n+                    boolean applyAsJoinOnCondition = EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+                        ? randomBoolean()\n+                        : false;\n+                    if (applyAsJoinOnCondition\n+                        && pushedDownFilter instanceof FragmentExec fragmentExec\n+                        && fragmentExec.fragment() instanceof Filter filter) {\n+                        joinOnConditions.add(filter.condition());\n+                        pushedDownFilter = null;\n+                    }\n                 }\n             }\n             // the matchFields are shared for both types of join\n@@ -412,7 +413,7 @@ private void runLookup(List<DataType> keyTypes, PopulateIndices populateIndices,\n                 \"lookup\",\n                 List.of(new Alias(Source.EMPTY, \"l\", new ReferenceAttribute(Source.EMPTY, \"l\", DataType.LONG))),\n                 Source.EMPTY,\n-                filters,\n+                pushedDownFilter,\n                 Predicates.combineAnd(joinOnConditions)\n             );\n             DriverContext driverContext = driverContext();\n@@ -478,6 +479,19 @@ protected void start(Driver driver, ActionListener<Void> driverListener) {\n         }\n     }\n \n+    private static Predicate<Integer> getPredicateFromFilter(Filter filter) {\n+        if (filter.condition() instanceof GreaterThan gt\n+            && gt.left() instanceof FieldAttribute fa\n+            && fa.name().equals(\"l\")\n+            && gt.right() instanceof Literal lit) {\n+            long value = ((Number) lit.value()).longValue();\n+            return l -> l > value;\n+        } else {\n+            fail(\"Unsupported filter type in test baseline generation: \" + filter);\n+        }\n+        return null;\n+    }\n+\n     /**\n      * Creates a {@link BigArrays} that tracks releases but doesn't throw circuit breaking exceptions.\n      */\ndiff --git a/x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/plugin/MatchFunctionIT.java b/x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/plugin/MatchFunctionIT.java\nindex 82124c4c85bb8..98a1a86df645b 100644\n--- a/x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/plugin/MatchFunctionIT.java\n+++ b/x-pack/plugin/esql/src/internalClusterTest/java/org/elasticsearch/xpack/esql/plugin/MatchFunctionIT.java\n@@ -313,6 +313,27 @@ public void testMatchWithLookupJoin() {\n         );\n     }\n \n+    public void testMatchWithLookupJoinOnMatch() {\n+        var query = \"\"\"\n+            FROM test\n+            | rename id as id_left\n+            | LOOKUP JOIN test_lookup ON id_left == id and MATCH(lookup_content, \"fox\")\n+            | WHERE id > 0\n+            \"\"\";\n+        try (var resp = run(query)) {\n+            assertColumnNames(resp.columns(), List.of(\"content\", \"id_left\", \"id\", \"lookup_content\"));\n+            assertColumnTypes(resp.columns(), List.of(\"text\", \"integer\", \"integer\", \"text\"));\n+            // Should return rows where lookup_content matches \"fox\" (ids 1 and 6)\n+            assertValues(\n+                resp.values(),\n+                List.of(\n+                    List.of(\"This is a brown fox\", 1, 1, \"This is a brown fox\"),\n+                    List.of(\"The quick brown fox jumps over the lazy dog\", 6, 6, \"The quick brown fox jumps over the lazy dog\")\n+                )\n+            );\n+        }\n+    }\n+\n     static void createAndPopulateIndex(Consumer<String[]> ensureYellow) {\n         var indexName = \"test\";\n         var client = client().admin().indices();\n@@ -341,5 +362,19 @@ static void createAndPopulateLookupIndex(IndicesAdminClient client, String looku\n             .setSettings(Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.mode\", \"lookup\"))\n             .setMapping(\"id\", \"type=integer\", \"lookup_content\", \"type=text\");\n         assertAcked(createRequest);\n+\n+        // Populate the lookup index with test data\n+        client().prepareBulk()\n+            .add(new IndexRequest(lookupIndexName).id(\"1\").source(\"id\", 1, \"lookup_content\", \"This is a brown fox\"))\n+            .add(new IndexRequest(lookupIndexName).id(\"2\").source(\"id\", 2, \"lookup_content\", \"This is a brown dog\"))\n+            .add(new IndexRequest(lookupIndexName).id(\"3\").source(\"id\", 3, \"lookup_content\", \"This dog is really brown\"))\n+            .add(\n+                new IndexRequest(lookupIndexName).id(\"4\")\n+                    .source(\"id\", 4, \"lookup_content\", \"The dog is brown but this document is very very long\")\n+            )\n+            .add(new IndexRequest(lookupIndexName).id(\"5\").source(\"id\", 5, \"lookup_content\", \"There is also a white cat\"))\n+            .add(new IndexRequest(lookupIndexName).id(\"6\").source(\"id\", 6, \"lookup_content\", \"The quick brown fox jumps over the lazy dog\"))\n+            .setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE)\n+            .get();\n     }\n }\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java\nindex 1338d337b1eaa..9cff541ca5569 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java\n@@ -1411,7 +1411,11 @@ public enum Cap {\n          * Allow lookup join on boolean expressions\n          */\n         LOOKUP_JOIN_ON_BOOLEAN_EXPRESSION,\n-\n+        /**\n+         * Lookup join with Full Text Function or other Lucene Pushable condition\n+         * to be applied to the lookup index used\n+         */\n+        LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION,\n         /**\n          * FORK with remote indices\n          */\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/analysis/Analyzer.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/analysis/Analyzer.java\nindex a1774c5ddcf77..2ffe4ebb56299 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/analysis/Analyzer.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/analysis/Analyzer.java\n@@ -7,6 +7,7 @@\n \n package org.elasticsearch.xpack.esql.analysis;\n \n+import org.elasticsearch.TransportVersion;\n import org.elasticsearch.common.logging.HeaderWarning;\n import org.elasticsearch.common.logging.LoggerMessageFormat;\n import org.elasticsearch.common.lucene.BytesRefs;\n@@ -21,6 +22,7 @@\n import org.elasticsearch.xpack.esql.EsqlIllegalArgumentException;\n import org.elasticsearch.xpack.esql.VerificationException;\n import org.elasticsearch.xpack.esql.analysis.AnalyzerRules.ParameterizedAnalyzerRule;\n+import org.elasticsearch.xpack.esql.capabilities.TranslationAware;\n import org.elasticsearch.xpack.esql.common.Failure;\n import org.elasticsearch.xpack.esql.core.capabilities.Resolvables;\n import org.elasticsearch.xpack.esql.core.expression.Alias;\n@@ -102,6 +104,7 @@\n import org.elasticsearch.xpack.esql.index.IndexResolution;\n import org.elasticsearch.xpack.esql.inference.ResolvedInference;\n import org.elasticsearch.xpack.esql.optimizer.rules.logical.SubstituteSurrogateExpressions;\n+import org.elasticsearch.xpack.esql.optimizer.rules.physical.local.LucenePushdownPredicates;\n import org.elasticsearch.xpack.esql.parser.ParsingException;\n import org.elasticsearch.xpack.esql.plan.IndexPattern;\n import org.elasticsearch.xpack.esql.plan.logical.Aggregate;\n@@ -162,6 +165,7 @@\n import static java.util.Collections.emptyList;\n import static java.util.Collections.singletonList;\n import static org.elasticsearch.xpack.core.enrich.EnrichPolicy.GEO_MATCH_TYPE;\n+import static org.elasticsearch.xpack.esql.capabilities.TranslationAware.translatable;\n import static org.elasticsearch.xpack.esql.core.type.DataType.AGGREGATE_METRIC_DOUBLE;\n import static org.elasticsearch.xpack.esql.core.type.DataType.BOOLEAN;\n import static org.elasticsearch.xpack.esql.core.type.DataType.DATETIME;\n@@ -217,6 +221,9 @@ public class Analyzer extends ParameterizedRuleExecutor<LogicalPlan, AnalyzerCon\n         ),\n         new Batch<>(\"Finish Analysis\", Limiter.ONCE, new AddImplicitLimit(), new AddImplicitForkLimit(), new UnionTypesCleanup())\n     );\n+    public static final TransportVersion ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION = TransportVersion.fromName(\n+        \"esql_lookup_join_full_text_function\"\n+    );\n \n     private final Verifier verifier;\n \n@@ -532,7 +539,7 @@ protected LogicalPlan rule(LogicalPlan plan, AnalyzerContext context) {\n             }\n \n             if (plan instanceof LookupJoin j) {\n-                return resolveLookupJoin(j);\n+                return resolveLookupJoin(j, context);\n             }\n \n             if (plan instanceof Insist i) {\n@@ -721,55 +728,114 @@ private LogicalPlan resolveLookup(Lookup l, List<Attribute> childrenOutput) {\n             return l;\n         }\n \n-        private List<Expression> resolveJoinFiltersAndSwapIfNeeded(\n-            List<Expression> filters,\n-            AttributeSet leftOutput,\n-            AttributeSet rightOutput\n+        private Expression resolveJoinFiltersAndSwapIfNeeded(\n+            Expression joinOnCondition,\n+            AttributeSet leftChildOutput,\n+            AttributeSet rightChildOutput,\n+            List<Attribute> leftJoinKeysToPopulate,\n+            List<Attribute> rightJoinKeysToPopulate,\n+            AnalyzerContext context\n         ) {\n-            if (filters.isEmpty()) {\n-                return emptyList();\n+            if (joinOnCondition == null) {\n+                return joinOnCondition;\n             }\n-            List<Attribute> childrenOutput = new ArrayList<>(leftOutput);\n-            childrenOutput.addAll(rightOutput);\n+            List<Expression> filters = Predicates.splitAnd(joinOnCondition);\n+            List<Attribute> childrenOutput = new ArrayList<>(leftChildOutput);\n+            childrenOutput.addAll(rightChildOutput);\n \n             List<Expression> resolvedFilters = new ArrayList<>(filters.size());\n             for (Expression filter : filters) {\n                 Expression filterResolved = filter.transformUp(UnresolvedAttribute.class, ua -> maybeResolveAttribute(ua, childrenOutput));\n-                resolvedFilters.add(resolveAndOrientJoinCondition(filterResolved, leftOutput, rightOutput));\n+                // Check if the filterResolved contains unresolved attributes, if it does, we cannot process it further\n+                // and the error message about the unresolved attribute is already appropriate\n+                if (filterResolved.anyMatch(UnresolvedAttribute.class::isInstance)) {\n+                    resolvedFilters.add(filterResolved);\n+                    continue;\n+                }\n+                Expression result = resolveAndOrientJoinCondition(\n+                    filterResolved,\n+                    leftChildOutput,\n+                    rightChildOutput,\n+                    leftJoinKeysToPopulate,\n+                    rightJoinKeysToPopulate,\n+                    context\n+                );\n+                resolvedFilters.add(result);\n             }\n-            return resolvedFilters;\n+            return Predicates.combineAndWithSource(resolvedFilters, joinOnCondition.source());\n         }\n \n-        private Expression resolveAndOrientJoinCondition(Expression condition, AttributeSet leftOutput, AttributeSet rightOutput) {\n+        /**\n+         * This function resolves and orients a single join on condition.\n+         * We support AND of such conditions, here we handle a single child of the AND\n+         * We support the following 2 cases:\n+         * 1) Binary comparisons between a left and a right attribute.\n+         * We resolve all attributes and orient them so that the attribute on the left side of the join\n+         * is on the left side of the binary comparison\n+         *  and the attribute from the lookup index is on the right side of the binary comparison\n+         * 2) A Lucene pushable expression containing only attributes from the lookup side of the join\n+         * We resolve all attributes in the expression, verify they are from the right side of the join\n+         * and also verify that the expression is potentially Lucene pushable\n+         */\n+        private Expression resolveAndOrientJoinCondition(\n+            Expression condition,\n+            AttributeSet leftChildOutput,\n+            AttributeSet rightChildOutput,\n+            List<Attribute> leftJoinKeysToPopulate,\n+            List<Attribute> rightJoinKeysToPopulate,\n+            AnalyzerContext context\n+        ) {\n             if (condition instanceof EsqlBinaryComparison comp\n                 && comp.left() instanceof Attribute leftAttr\n                 && comp.right() instanceof Attribute rightAttr) {\n \n-                boolean leftIsFromLeft = leftOutput.contains(leftAttr);\n-                boolean rightIsFromRight = rightOutput.contains(rightAttr);\n+                boolean leftIsFromLeft = leftChildOutput.contains(leftAttr);\n+                boolean rightIsFromRight = rightChildOutput.contains(rightAttr);\n \n                 if (leftIsFromLeft && rightIsFromRight) {\n+                    leftJoinKeysToPopulate.add(leftAttr);\n+                    rightJoinKeysToPopulate.add(rightAttr);\n                     return comp; // Correct orientation\n                 }\n \n-                boolean leftIsFromRight = rightOutput.contains(leftAttr);\n-                boolean rightIsFromLeft = leftOutput.contains(rightAttr);\n+                boolean leftIsFromRight = rightChildOutput.contains(leftAttr);\n+                boolean rightIsFromLeft = leftChildOutput.contains(rightAttr);\n \n                 if (leftIsFromRight && rightIsFromLeft) {\n+                    leftJoinKeysToPopulate.add(rightAttr);\n+                    rightJoinKeysToPopulate.add(leftAttr);\n                     return comp.swapLeftAndRight(); // Swapped orientation\n                 }\n+            }\n+            if (context.minimumVersion().onOrAfter(ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION) == false) {\n                 return new UnresolvedAttribute(\n                     condition.source(),\n                     \"unsupported\",\n-                    \"Join condition must be between one attribute on the left side and \"\n-                        + \"one attribute on the right side of the join, but found: \"\n+                    \"Lookup join on condition is not supported on the remote node,\"\n+                        + \" consider upgrading the remote node. Unsupported join filter expression:\"\n                         + condition.sourceText()\n                 );\n             }\n-            return condition; // Not a binary comparison between two attributes, no change needed.\n+            return handleRightOnlyPushableFilter(condition, rightChildOutput);\n+        }\n+\n+        private Expression handleRightOnlyPushableFilter(Expression condition, AttributeSet rightChildOutput) {\n+            if (isCompletelyRightSideAndTranslatable(condition, rightChildOutput)) {\n+                // The condition is completely on the right side and is translation aware, so it can be (potentially) pushed down\n+                return condition;\n+            } else {\n+                // The condition cannot be used in the join on clause for now\n+                // It is not a binary comparison between left and right attributes\n+                // It is not using fields from the right side only and translation aware\n+                return new UnresolvedAttribute(\n+                    condition.source(),\n+                    \"unsupported\",\n+                    \"Unsupported join filter expression:\" + condition.sourceText()\n+                );\n+            }\n         }\n \n-        private Join resolveLookupJoin(LookupJoin join) {\n+        private Join resolveLookupJoin(LookupJoin join, AnalyzerContext context) {\n             JoinConfig config = join.config();\n             // for now, support only (LEFT) USING clauses\n             JoinType type = config.type();\n@@ -785,38 +851,22 @@ private Join resolveLookupJoin(LookupJoin join) {\n                 }\n                 List<Attribute> leftKeys = new ArrayList<>();\n                 List<Attribute> rightKeys = new ArrayList<>();\n-                List<Expression> resolvedFilters = new ArrayList<>();\n+                Expression joinOnConditions = null;\n                 if (join.config().joinOnConditions() != null) {\n-                    resolvedFilters = resolveJoinFiltersAndSwapIfNeeded(\n-                        Predicates.splitAnd(join.config().joinOnConditions()),\n+                    joinOnConditions = resolveJoinFiltersAndSwapIfNeeded(\n+                        join.config().joinOnConditions(),\n                         join.left().outputSet(),\n-                        join.right().outputSet()\n+                        join.right().outputSet(),\n+                        leftKeys,\n+                        rightKeys,\n+                        context\n                     );\n-                    // build leftKeys and rightKeys using the correct side of the resolvedFilters.\n-                    // resolveJoinFiltersAndSwapIfNeeded already put the left and right on the correct side\n-                    for (Expression expression : resolvedFilters) {\n-                        if (expression instanceof EsqlBinaryComparison binaryComparison\n-                            && binaryComparison.left() instanceof Attribute leftAttribute\n-                            && binaryComparison.right() instanceof Attribute rightAttribute) {\n-                            leftKeys.add(leftAttribute);\n-                            rightKeys.add(rightAttribute);\n-                        } else {\n-                            UnresolvedAttribute errorAttribute = new UnresolvedAttribute(\n-                                expression.source(),\n-                                \"unsupported\",\n-                                \"Unsupported join filter expression:\" + expression.sourceText()\n-                            );\n-                            return join.withConfig(new JoinConfig(type, singletonList(errorAttribute), emptyList(), null));\n-\n-                        }\n-                    }\n                 } else {\n                     // resolve the using columns against the left and the right side then assemble the new join config\n                     leftKeys = resolveUsingColumns(join.config().leftFields(), join.left().output(), \"left\");\n                     rightKeys = resolveUsingColumns(join.config().rightFields(), join.right().output(), \"right\");\n                 }\n-\n-                config = new JoinConfig(type, leftKeys, rightKeys, Predicates.combineAnd(resolvedFilters));\n+                config = new JoinConfig(type, leftKeys, rightKeys, joinOnConditions);\n                 return new LookupJoin(join.source(), join.left(), join.right(), config, join.isRemote());\n             } else {\n                 // everything else is unsupported for now\n@@ -826,6 +876,18 @@ private Join resolveLookupJoin(LookupJoin join) {\n             }\n         }\n \n+        private boolean isCompletelyRightSideAndTranslatable(Expression expression, AttributeSet rightOutputSet) {\n+            return rightOutputSet.containsAll(expression.references()) && isTranslatable(expression);\n+        }\n+\n+        private boolean isTranslatable(Expression expression) {\n+            // Here we are trying to eliminate cases where the expression is definitely not translatable.\n+            // We do this early and without access to search stats for the lookup index that are only on the lookup node,\n+            // so we only eliminate some of the not translatable cases here\n+            // Later we will do a more thorough check on the lookup node\n+            return translatable(expression, LucenePushdownPredicates.DEFAULT) != TranslationAware.Translatable.NO;\n+        }\n+\n         private LogicalPlan resolveFork(Fork fork, AnalyzerContext context) {\n             // we align the outputs of the sub plans such that they have the same columns\n             boolean changed = false;\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/analysis/AnalyzerContext.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/analysis/AnalyzerContext.java\nindex adebb69407e15..b6ca354175c77 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/analysis/AnalyzerContext.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/analysis/AnalyzerContext.java\n@@ -17,15 +17,14 @@\n \n import java.util.Map;\n \n-public record AnalyzerContext(\n-    Configuration configuration,\n-    EsqlFunctionRegistry functionRegistry,\n-    Map<IndexPattern, IndexResolution> indexResolution,\n-    Map<String, IndexResolution> lookupResolution,\n-    EnrichResolution enrichResolution,\n-    InferenceResolution inferenceResolution,\n-    TransportVersion minimumVersion\n-) {\n+public class AnalyzerContext {\n+    private final Configuration configuration;\n+    private final EsqlFunctionRegistry functionRegistry;\n+    private final Map<IndexPattern, IndexResolution> indexResolution;\n+    private final Map<String, IndexResolution> lookupResolution;\n+    private final EnrichResolution enrichResolution;\n+    private final InferenceResolution inferenceResolution;\n+    private final TransportVersion minimumVersion;\n \n     public AnalyzerContext(\n         Configuration configuration,\n@@ -49,6 +48,34 @@ public AnalyzerContext(\n             : \"AnalyzerContext [\" + minimumVersion + \"] is not on or before current transport version [\" + TransportVersion.current() + \"]\";\n     }\n \n+    public Configuration configuration() {\n+        return configuration;\n+    }\n+\n+    public EsqlFunctionRegistry functionRegistry() {\n+        return functionRegistry;\n+    }\n+\n+    public Map<IndexPattern, IndexResolution> indexResolution() {\n+        return indexResolution;\n+    }\n+\n+    public Map<String, IndexResolution> lookupResolution() {\n+        return lookupResolution;\n+    }\n+\n+    public EnrichResolution enrichResolution() {\n+        return enrichResolution;\n+    }\n+\n+    public InferenceResolution inferenceResolution() {\n+        return inferenceResolution;\n+    }\n+\n+    public TransportVersion minimumVersion() {\n+        return minimumVersion;\n+    }\n+\n     public AnalyzerContext(Configuration configuration, EsqlFunctionRegistry functionRegistry, EsqlSession.PreAnalysisResult result) {\n         this(\n             configuration,\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/BinaryComparisonQueryList.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/BinaryComparisonQueryList.java\nindex 883589e3b93cf..9805d944089fc 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/BinaryComparisonQueryList.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/BinaryComparisonQueryList.java\n@@ -92,7 +92,7 @@ public Query doGetQuery(int position, int firstValueIndex, int valueCount) {\n                 new Literal(binaryComparison.right().source(), value, binaryComparison.right().dataType())\n             );\n         try {\n-            if (TranslationAware.Translatable.YES.equals(comparison.translatable(lucenePushdownPredicates))) {\n+            if (TranslationAware.Translatable.YES == comparison.translatable(lucenePushdownPredicates)) {\n                 return comparison.asQuery(lucenePushdownPredicates, TranslatorHandler.TRANSLATOR_HANDLER)\n                     .toQueryBuilder()\n                     .toQuery(searchExecutionContext);\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/ExpressionQueryList.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/ExpressionQueryList.java\nindex d881644849f2f..934dd94770e73 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/ExpressionQueryList.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/ExpressionQueryList.java\n@@ -18,11 +18,13 @@\n import org.elasticsearch.compute.operator.lookup.QueryList;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.Rewriteable;\n import org.elasticsearch.index.query.SearchExecutionContext;\n import org.elasticsearch.search.internal.AliasFilter;\n import org.elasticsearch.xpack.esql.capabilities.TranslationAware;\n import org.elasticsearch.xpack.esql.core.expression.Attribute;\n import org.elasticsearch.xpack.esql.core.expression.Expression;\n+import org.elasticsearch.xpack.esql.core.type.DataType;\n import org.elasticsearch.xpack.esql.expression.predicate.Predicates;\n import org.elasticsearch.xpack.esql.expression.predicate.operator.comparison.Equals;\n import org.elasticsearch.xpack.esql.expression.predicate.operator.comparison.EsqlBinaryComparison;\n@@ -56,9 +58,10 @@\n  */\n public class ExpressionQueryList implements LookupEnrichQueryGenerator {\n     private final List<QueryList> queryLists;\n-    private final List<Query> preJoinFilters = new ArrayList<>();\n+    private final List<Query> lucenePushableFilters = new ArrayList<>();\n     private final SearchExecutionContext context;\n     private final AliasFilter aliasFilter;\n+    private final LucenePushdownPredicates lucenePushdownPredicates;\n \n     private ExpressionQueryList(\n         List<QueryList> queryLists,\n@@ -70,6 +73,10 @@ private ExpressionQueryList(\n         this.queryLists = new ArrayList<>(queryLists);\n         this.context = context;\n         this.aliasFilter = aliasFilter;\n+        this.lucenePushdownPredicates = LucenePushdownPredicates.from(\n+            SearchContextStats.from(List.of(context)),\n+            new EsqlFlags(clusterService.getClusterSettings())\n+        );\n         buildPreJoinFilter(rightPreJoinPlan, clusterService);\n     }\n \n@@ -141,98 +148,104 @@ private void buildJoinOnForExpressionJoin(\n     ) {\n         List<Expression> expressions = Predicates.splitAnd(joinOnConditions);\n         for (Expression expr : expressions) {\n-            if (expr instanceof EsqlBinaryComparison binaryComparison) {\n-                // the left side comes from the page that was sent to the lookup node\n-                // the right side is the field from the lookup index\n-                // check if the left side is in the matchFields\n-                // if it is its corresponding page is the corresponding number in inputPage\n-                Expression left = binaryComparison.left();\n-                if (left instanceof Attribute leftAttribute) {\n-                    boolean matched = false;\n-                    for (int i = 0; i < matchFields.size(); i++) {\n-                        if (matchFields.get(i).fieldName().equals(leftAttribute.name())) {\n-                            Block block = inputPage.getBlock(i);\n-                            Expression right = binaryComparison.right();\n-                            if (right instanceof Attribute rightAttribute) {\n-                                MappedFieldType fieldType = context.getFieldType(rightAttribute.name());\n-                                if (fieldType != null) {\n-                                    // special handle Equals operator\n-                                    // TermQuery is faster than BinaryComparisonQueryList, as it does less work per row\n-                                    // so here we reuse the existing logic from field based join to build a termQueryList for Equals\n-                                    if (binaryComparison instanceof Equals) {\n-                                        QueryList termQueryForEquals = termQueryList(\n-                                            fieldType,\n-                                            context,\n-                                            aliasFilter,\n-                                            inputPage.getBlock(matchFields.get(i).channel()),\n-                                            matchFields.get(i).type()\n-                                        ).onlySingleValues(warnings, \"LOOKUP JOIN encountered multi-value\");\n-                                        queryLists.add(termQueryForEquals);\n-                                    } else {\n-                                        queryLists.add(\n-                                            new BinaryComparisonQueryList(\n-                                                fieldType,\n-                                                context,\n-                                                block,\n-                                                binaryComparison,\n-                                                clusterService,\n-                                                aliasFilter,\n-                                                warnings\n-                                            )\n-                                        );\n-                                    }\n-                                    matched = true;\n-                                    break;\n-                                } else {\n-                                    throw new IllegalStateException(\n-                                        \"Could not find field [\" + rightAttribute.name() + \"] in the lookup join index\"\n-                                    );\n-                                }\n-                            } else {\n-                                throw new IllegalStateException(\n-                                    \"Only field from the right dataset are supported on the right of the join on condition but got: \" + expr\n-                                );\n-                            }\n-                        }\n-                    }\n-                    if (matched == false) {\n-                        throw new IllegalStateException(\n-                            \"Could not find field [\" + leftAttribute.name() + \"] in the left side of the lookup join\"\n-                        );\n-                    }\n+            boolean applied = applyAsLeftRightBinaryComparison(expr, matchFields, inputPage, clusterService, warnings);\n+            if (applied == false) {\n+                applied = applyAsRightSidePushableFilter(expr);\n+            }\n+            if (applied == false) {\n+                throw new IllegalArgumentException(\"Cannot apply join condition: \" + expr);\n+            }\n+        }\n+    }\n+\n+    private boolean applyAsRightSidePushableFilter(Expression filter) {\n+        if (filter instanceof TranslationAware translationAware) {\n+            if (TranslationAware.Translatable.YES.equals(translationAware.translatable(lucenePushdownPredicates))) {\n+                QueryBuilder queryBuilder = translationAware.asQuery(lucenePushdownPredicates, TRANSLATOR_HANDLER).toQueryBuilder();\n+                // Rewrite the query builder to ensure doIndexMetadataRewrite is called\n+                // Some functions, such as KQL require rewriting to work properly\n+                try {\n+                    queryBuilder = Rewriteable.rewrite(queryBuilder, context, true);\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(\"Error while rewriting query for Lucene pushable filter\", e);\n+                }\n+                addToLucenePushableFilters(queryBuilder);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean applyAsLeftRightBinaryComparison(\n+        Expression expr,\n+        List<MatchConfig> matchFields,\n+        Page inputPage,\n+        ClusterService clusterService,\n+        Warnings warnings\n+    ) {\n+        if (expr instanceof EsqlBinaryComparison binaryComparison\n+            && binaryComparison.left() instanceof Attribute leftAttribute\n+            && binaryComparison.right() instanceof Attribute rightAttribute) {\n+            // the left side comes from the page that was sent to the lookup node\n+            // the right side is the field from the lookup index\n+            // check if the left side is in the matchFields\n+            // if it is its corresponding page is the corresponding number in inputPage\n+            Block block = null;\n+            DataType dataType = null;\n+            for (int i = 0; i < matchFields.size(); i++) {\n+                if (matchFields.get(i).fieldName().equals(leftAttribute.name())) {\n+                    block = inputPage.getBlock(i);\n+                    dataType = matchFields.get(i).type();\n+                    break;\n+                }\n+            }\n+            MappedFieldType rightFieldType = context.getFieldType(rightAttribute.name());\n+            if (block != null && rightFieldType != null && dataType != null) {\n+                // special handle Equals operator\n+                // TermQuery is faster than BinaryComparisonQueryList, as it does less work per row\n+                // so here we reuse the existing logic from field based join to build a termQueryList for Equals\n+                if (binaryComparison instanceof Equals) {\n+                    QueryList termQueryForEquals = termQueryList(rightFieldType, context, aliasFilter, block, dataType).onlySingleValues(\n+                        warnings,\n+                        \"LOOKUP JOIN encountered multi-value\"\n+                    );\n+                    queryLists.add(termQueryForEquals);\n                 } else {\n-                    throw new IllegalStateException(\n-                        \"Only field from the left dataset are supported on the left of the join on condition but got: \" + expr\n+                    queryLists.add(\n+                        new BinaryComparisonQueryList(\n+                            rightFieldType,\n+                            context,\n+                            block,\n+                            binaryComparison,\n+                            clusterService,\n+                            aliasFilter,\n+                            warnings\n+                        )\n                     );\n                 }\n-            } else {\n-                // we only support binary comparisons in the join on conditions\n-                throw new IllegalStateException(\"Only binary comparisons are supported in join ON conditions, but got: \" + expr);\n+                return true;\n             }\n         }\n+        return false;\n     }\n \n-    private void addToPreJoinFilters(QueryBuilder query) {\n+    private void addToLucenePushableFilters(QueryBuilder query) {\n         try {\n             if (query != null) {\n-                preJoinFilters.add(query.toQuery(context));\n+                lucenePushableFilters.add(query.toQuery(context));\n             }\n         } catch (IOException e) {\n-            throw new UncheckedIOException(\"Error while building query for PreJoinFilters filter\", e);\n+            throw new UncheckedIOException(\"Error while building query for Lucene pushable filter\", e);\n         }\n     }\n \n     private void buildPreJoinFilter(PhysicalPlan rightPreJoinPlan, ClusterService clusterService) {\n         if (rightPreJoinPlan instanceof FilterExec filterExec) {\n             List<Expression> candidateRightHandFilters = Predicates.splitAnd(filterExec.condition());\n-            LucenePushdownPredicates lucenePushdownPredicates = LucenePushdownPredicates.from(\n-                SearchContextStats.from(List.of(context)),\n-                new EsqlFlags(clusterService.getClusterSettings())\n-            );\n             for (Expression filter : candidateRightHandFilters) {\n                 if (filter instanceof TranslationAware translationAware) {\n                     if (TranslationAware.Translatable.YES.equals(translationAware.translatable(lucenePushdownPredicates))) {\n-                        addToPreJoinFilters(translationAware.asQuery(lucenePushdownPredicates, TRANSLATOR_HANDLER).toQueryBuilder());\n+                        addToLucenePushableFilters(translationAware.asQuery(lucenePushdownPredicates, TRANSLATOR_HANDLER).toQueryBuilder());\n                     }\n                 }\n                 // If the filter is not translatable we will not apply it for now\n@@ -268,7 +281,7 @@ public Query getQuery(int position) {\n             builder.add(q, BooleanClause.Occur.FILTER);\n         }\n         // also attach the pre-join filter if it exists\n-        for (Query preJoinFilter : preJoinFilters) {\n+        for (Query preJoinFilter : lucenePushableFilters) {\n             builder.add(preJoinFilter, BooleanClause.Occur.FILTER);\n         }\n         return builder.build();\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/fulltext/FullTextFunction.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/fulltext/FullTextFunction.java\nindex 7ab187fe060fa..147d2e6bbfa4c 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/fulltext/FullTextFunction.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/fulltext/FullTextFunction.java\n@@ -30,6 +30,7 @@\n import org.elasticsearch.xpack.esql.core.tree.Source;\n import org.elasticsearch.xpack.esql.core.type.DataType;\n import org.elasticsearch.xpack.esql.core.type.MultiTypeEsField;\n+import org.elasticsearch.xpack.esql.core.util.Holder;\n import org.elasticsearch.xpack.esql.evaluator.mapper.EvaluatorMapper;\n import org.elasticsearch.xpack.esql.expression.function.scalar.convert.AbstractConvertFunction;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.BinaryLogic;\n@@ -42,6 +43,7 @@\n import org.elasticsearch.xpack.esql.plan.logical.Limit;\n import org.elasticsearch.xpack.esql.plan.logical.LogicalPlan;\n import org.elasticsearch.xpack.esql.plan.logical.OrderBy;\n+import org.elasticsearch.xpack.esql.plan.logical.join.LookupJoin;\n import org.elasticsearch.xpack.esql.planner.EsPhysicalOperationProviders;\n import org.elasticsearch.xpack.esql.planner.TranslatorHandler;\n import org.elasticsearch.xpack.esql.querydsl.query.TranslationAwareExpressionQuery;\n@@ -188,34 +190,11 @@ public BiConsumer<LogicalPlan, Failures> postAnalysisPlanVerification() {\n     private static void checkFullTextQueryFunctions(LogicalPlan plan, Failures failures) {\n         if (plan instanceof Filter f) {\n             Expression condition = f.condition();\n-\n-            if (condition instanceof Score) {\n-                failures.add(fail(condition, \"[SCORE] function can't be used in WHERE\"));\n-            }\n-\n-            List.of(QueryString.class, Kql.class).forEach(functionClass -> {\n-                // Check for limitations of QSTR and KQL function.\n-                checkCommandsBeforeExpression(\n-                    plan,\n-                    condition,\n-                    functionClass,\n-                    lp -> (lp instanceof Filter || lp instanceof OrderBy || lp instanceof EsRelation),\n-                    fullTextFunction -> \"[\" + fullTextFunction.functionName() + \"] \" + fullTextFunction.functionType(),\n-                    failures\n-                );\n-            });\n-\n-            checkCommandsBeforeExpression(\n-                plan,\n-                condition,\n-                FullTextFunction.class,\n-                lp -> (lp instanceof Limit == false) && (lp instanceof Aggregate == false),\n-                m -> \"[\" + m.functionName() + \"] \" + m.functionType(),\n-                failures\n-            );\n-            checkFullTextFunctionsParents(condition, failures);\n+            checkFullTextQueryFunctionForCondition(plan, failures, condition, false);\n         } else if (plan instanceof Aggregate agg) {\n             checkFullTextFunctionsInAggs(agg, failures);\n+        } else if (plan instanceof LookupJoin lookupJoin) {\n+            checkFullTextQueryFunctionForCondition(plan, failures, lookupJoin.config().joinOnConditions(), true);\n         } else {\n             List<FullTextFunction> scoredFTFs = new ArrayList<>();\n             plan.forEachExpression(Score.class, scoreFunction -> {\n@@ -238,6 +217,43 @@ private static void checkFullTextQueryFunctions(LogicalPlan plan, Failures failu\n         }\n     }\n \n+    private static void checkFullTextQueryFunctionForCondition(\n+        LogicalPlan plan,\n+        Failures failures,\n+        Expression condition,\n+        boolean isLookupJoinOnCondition\n+    ) {\n+        if (condition == null) {\n+            return;\n+        }\n+        if (condition instanceof Score) {\n+            failures.add(fail(condition, \"[SCORE] function can't be used in WHERE or LOOKUP JOIN ON conditions\"));\n+        }\n+        if (isLookupJoinOnCondition == false) {\n+            List.of(QueryString.class, Kql.class).forEach(functionClass -> {\n+                // Check for limitations of QSTR and KQL function.\n+                checkCommandsBeforeExpression(\n+                    plan,\n+                    condition,\n+                    functionClass,\n+                    lp -> (lp instanceof Filter || lp instanceof OrderBy || lp instanceof EsRelation),\n+                    fullTextFunction -> \"[\" + fullTextFunction.functionName() + \"] \" + fullTextFunction.functionType(),\n+                    failures\n+                );\n+            });\n+        }\n+\n+        checkCommandsBeforeExpression(\n+            plan,\n+            condition,\n+            FullTextFunction.class,\n+            lp -> (lp instanceof Limit == false) && (lp instanceof Aggregate == false),\n+            m -> \"[\" + m.functionName() + \"] \" + m.functionType(),\n+            failures\n+        );\n+        checkFullTextFunctionsParents(condition, failures);\n+    }\n+\n     private static void checkScoreFunction(LogicalPlan plan, Failures failures, Score scoreFunction) {\n         checkCommandsBeforeExpression(\n             plan,\n@@ -341,6 +357,11 @@ private static FullTextFunction forEachFullTextFunctionParent(Expression conditi\n     }\n \n     public static void fieldVerifier(LogicalPlan plan, FullTextFunction function, Expression field, Failures failures) {\n+        // Only run the check if the current node contains the full-text function\n+        // This is to avoid running the check multiple times in the same plan\n+        if (isInCurrentNode(plan, function) == false) {\n+            return;\n+        }\n         var fieldAttribute = fieldAsFieldAttribute(field);\n         if (fieldAttribute == null) {\n             plan.forEachExpression(function.getClass(), m -> {\n@@ -357,6 +378,12 @@ public static void fieldVerifier(LogicalPlan plan, FullTextFunction function, Ex\n                 }\n             });\n         } else {\n+            if (plan instanceof LookupJoin) {\n+                // Full Text Functions are allowed in LOOKUP JOIN ON conditions\n+                // We are only running this code for the node containing the Full Text Function\n+                // So if it is a Lookup Join we know the function is in the join on condition\n+                return;\n+            }\n             // Traverse the plan to find the EsRelation outputting the field\n             plan.forEachDown(p -> {\n                 if (p instanceof EsRelation esRelation && esRelation.indexMode() != IndexMode.STANDARD) {\n@@ -428,4 +455,17 @@ public static FieldAttribute fieldAsFieldAttribute(Expression field) {\n     public void postOptimizationVerification(Failures failures) {\n         resolveTypeQuery(query(), sourceText(), forPostOptimizationValidation(query(), failures));\n     }\n+\n+    /**\n+     * Check if the full-text function exists only in the current node (not in child nodes)\n+     */\n+    private static boolean isInCurrentNode(LogicalPlan plan, FullTextFunction function) {\n+        final Holder<Boolean> found = new Holder<>(false);\n+        plan.forEachExpression(FullTextFunction.class, ftf -> {\n+            if (ftf == function) {\n+                found.set(true);\n+            }\n+        });\n+        return found.get();\n+    }\n }\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/predicate/Predicates.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/predicate/Predicates.java\nindex b9a58e82a2349..10f4f6a8a8500 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/predicate/Predicates.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/predicate/Predicates.java\n@@ -9,6 +9,7 @@\n import org.elasticsearch.core.Tuple;\n import org.elasticsearch.xpack.esql.core.expression.Expression;\n import org.elasticsearch.xpack.esql.core.expression.Literal;\n+import org.elasticsearch.xpack.esql.core.tree.Source;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.And;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.Or;\n \n@@ -49,6 +50,10 @@ public static Expression combineAnd(List<Expression> exps) {\n         return combine(exps, (l, r) -> new And(l.source(), l, r));\n     }\n \n+    public static Expression combineAndWithSource(List<Expression> exps, Source source) {\n+        return combine(exps, (l, r) -> new And(source, l, r));\n+    }\n+\n     /**\n      * Build a binary 'pyramid' from the given list:\n      * <pre>\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/parser/LogicalPlanBuilder.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/parser/LogicalPlanBuilder.java\nindex 06b07117b5328..3caf9a9600f73 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/parser/LogicalPlanBuilder.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/parser/LogicalPlanBuilder.java\n@@ -46,6 +46,7 @@\n import org.elasticsearch.xpack.esql.expression.UnresolvedNamePattern;\n import org.elasticsearch.xpack.esql.expression.function.UnresolvedFunction;\n import org.elasticsearch.xpack.esql.expression.predicate.Predicates;\n+import org.elasticsearch.xpack.esql.expression.predicate.logical.BinaryLogic;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.Not;\n import org.elasticsearch.xpack.esql.expression.predicate.operator.comparison.Equals;\n import org.elasticsearch.xpack.esql.expression.predicate.operator.comparison.EsqlBinaryComparison;\n@@ -721,7 +722,14 @@ public PlanFactory visitJoinCommand(EsqlBaseParser.JoinCommandContext ctx) {\n             if (hasRemotes && EsqlCapabilities.Cap.ENABLE_LOOKUP_JOIN_ON_REMOTE.isEnabled() == false) {\n                 throw new ParsingException(source, \"remote clusters are not supported with LOOKUP JOIN\");\n             }\n-            return new LookupJoin(source, p, right, joinInfo.joinFields(), hasRemotes, Predicates.combineAnd(joinInfo.joinExpressions()));\n+            return new LookupJoin(\n+                source,\n+                p,\n+                right,\n+                joinInfo.joinFields(),\n+                hasRemotes,\n+                Predicates.combineAndWithSource(joinInfo.joinExpressions(), source(condition))\n+            );\n         };\n     }\n \n@@ -734,8 +742,10 @@ public JoinInfo visitJoinCondition(EsqlBaseParser.JoinConditionContext ctx) {\n             throw new ParsingException(source(ctx), \"JOIN ON clause cannot be empty\");\n         }\n \n-        // inspect the first expression to determine the type of join (field-based or expression-based)\n-        boolean isFieldBased = expressions.get(0) instanceof UnresolvedAttribute;\n+        // Inspect the first expression to determine the type of join (field-based or expression-based)\n+        // We treat literals as field-based as it is more likely the user was trying to write a field name\n+        // and so the field based error message is more helpful\n+        boolean isFieldBased = expressions.get(0) instanceof UnresolvedAttribute || expressions.get(0) instanceof Literal;\n \n         if (isFieldBased) {\n             return processFieldBasedJoin(expressions);\n@@ -784,26 +794,53 @@ private JoinInfo processExpressionBasedJoin(List<Expression> expressions, EsqlBa\n         }\n         expressions = Predicates.splitAnd(expressions.get(0));\n         for (var f : expressions) {\n-            addJoinExpression(f, joinFields, joinExpressions);\n+            addJoinExpression(f, joinFields, joinExpressions, ctx);\n+        }\n+        if (joinFields.isEmpty()) {\n+            throw new ParsingException(\n+                source(ctx),\n+                \"JOIN ON clause with expressions must contain at least one condition relating the left index and the lookup index\"\n+            );\n         }\n         return new JoinInfo(joinFields, joinExpressions);\n     }\n \n-    private void addJoinExpression(Expression exp, List<Attribute> joinFields, List<Expression> joinExpressions) {\n+    private void addJoinExpression(\n+        Expression exp,\n+        List<Attribute> joinFields,\n+        List<Expression> joinExpressions,\n+        EsqlBaseParser.JoinConditionContext ctx\n+    ) {\n         exp = handleNegationOfEquals(exp);\n+        if (containsBareFieldsInBooleanExpression(exp)) {\n+            throw new ParsingException(\n+                source(ctx),\n+                \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found [{}]\",\n+                exp.sourceText()\n+            );\n+        }\n         if (exp instanceof EsqlBinaryComparison comparison\n             && comparison.left() instanceof UnresolvedAttribute left\n             && comparison.right() instanceof UnresolvedAttribute right) {\n             joinFields.add(left);\n             joinFields.add(right);\n-            joinExpressions.add(exp);\n-        } else {\n-            throw new ParsingException(\n-                exp.source(),\n-                \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found [{}]\",\n-                exp.sourceText()\n-            );\n         }\n+        joinExpressions.add(exp);\n+    }\n+\n+    private boolean containsBareFieldsInBooleanExpression(Expression expression) {\n+        if (expression instanceof UnresolvedAttribute) {\n+            return true; // This is a bare field\n+        }\n+        if (expression instanceof EsqlBinaryComparison) {\n+            return false; // This is a binary comparison, not a bare field\n+        }\n+        if (expression instanceof BinaryLogic binaryLogic) {\n+            // Check if either side contains bare fields\n+            return containsBareFieldsInBooleanExpression(binaryLogic.left()) || containsBareFieldsInBooleanExpression(binaryLogic.right());\n+        }\n+        // For other expression types (functions, constants, etc.), they are not bare fields\n+        return false;\n     }\n \n     private void validateJoinFields(List<Attribute> joinFields) {\ndiff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plan/logical/join/JoinConfig.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plan/logical/join/JoinConfig.java\nindex e870580eecd17..682a3fdcc3027 100644\n--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plan/logical/join/JoinConfig.java\n+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/plan/logical/join/JoinConfig.java\n@@ -20,6 +20,19 @@\n import java.util.List;\n \n /**\n+ * Configuration of a join operation.\n+ * We support equi-joins on a list of fields, as well as expression based joins.\n+ * For list of fields based joins, the left and right lists must be of the same size and match positionally.\n+ * For expression based joins, the join conditions are expressed as a boolean expression.\n+ * The join on condition is stored in the {@code joinOnConditions} field.\n+ * We support one or more binary expressions (e.g. {@code ==, <, >, <=, >=, !=}) combined with {@code AND}.\n+ * One side of each binary expression must be an attribute from the left side of the join\n+ * and the other side an attribute from the side of the join child.\n+ * Those are populated in the {@code leftFields} and {@code rightFields} lists respectively.\n+ * Notice however that {@code leftFields} and {@code rightFields} might have different size if a field is reused\n+ * (e.g. {@code left_a == right_b AND left_a = right_c}).\n+ * In addition, you can AND an optional Lucene pushable expression containing references to the right side of the join only.\n+ * This expression can contain OR and NOT nodes, as those operators are Lucene pushable.\n  * @param type        type of join\n  * @param leftFields  fields from the left child to join on\n  * @param rightFields fields from the right child to join on\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/AnalyzerTestUtils.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/AnalyzerTestUtils.java\nindex 4b46c26f56f35..9afc89b8cd8a8 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/AnalyzerTestUtils.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/AnalyzerTestUtils.java\n@@ -235,7 +235,9 @@ public static Map<String, IndexResolution> defaultLookupResolution() {\n             \"languages_lookup\",\n             loadMapping(\"mapping-languages.json\", \"languages_lookup\", IndexMode.LOOKUP),\n             \"test_lookup\",\n-            loadMapping(\"mapping-basic.json\", \"test_lookup\", IndexMode.LOOKUP)\n+            loadMapping(\"mapping-basic.json\", \"test_lookup\", IndexMode.LOOKUP),\n+            \"spatial_lookup\",\n+            loadMapping(\"mapping-multivalue_geometries.json\", \"spatial_lookup\", IndexMode.LOOKUP)\n         );\n     }\n \ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/AnalyzerTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/AnalyzerTests.java\nindex 46c8b73213abe..5a66526c9af50 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/AnalyzerTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/AnalyzerTests.java\n@@ -163,6 +163,12 @@\n import static org.hamcrest.Matchers.startsWith;\n \n //@TestLogging(value = \"org.elasticsearch.xpack.esql.analysis:TRACE\", reason = \"debug\")\n+/**\n+ * Parses a plan, builds an AST for it, runs logical analysis.\n+ * So if we don't error out in the process, analysis was successful\n+ * Use this class if you want to test analysis phase\n+ * and especially if you expect to get a VerificationException during analysis\n+ */\n public class AnalyzerTests extends ESTestCase {\n \n     private static final UnresolvedRelation UNRESOLVED_RELATION = unresolvedRelation(\"idx\");\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/ParsingTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/ParsingTests.java\nindex ae3426178e36b..4260f41187cc1 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/ParsingTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/ParsingTests.java\n@@ -51,6 +51,12 @@\n import static org.hamcrest.Matchers.instanceOf;\n import static org.hamcrest.Matchers.is;\n \n+/**\n+ * Parses a plan, builds an AST for it, and then runs logical analysis on it.\n+ * So if we don't error out in the process,  all references were resolved correctly.\n+ * Use this class if you want to test parsing and resolution of a query\n+ *  and especially if you expect to get a ParsingException\n+ */\n public class ParsingTests extends ESTestCase {\n     private static final String INDEX_NAME = \"test\";\n     private static final EsqlParser parser = new EsqlParser();\n@@ -141,22 +147,92 @@ public void testTooBigQuery() {\n     public void testJoinOnConstant() {\n         assumeTrue(\n             \"requires LOOKUP JOIN ON boolean expression capability\",\n-            EsqlCapabilities.Cap.LOOKUP_JOIN_ON_BOOLEAN_EXPRESSION.isEnabled()\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n         );\n         assertEquals(\n-            \"1:55: JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found [123]\",\n+            \"1:55: JOIN ON clause must be a comma separated list of fields or a single expression, found [123]\",\n             error(\"row languages = 1, gender = \\\"f\\\" | lookup join test on 123\")\n         );\n         assertEquals(\n-            \"1:55: JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found [\\\"abc\\\"]\",\n+            \"1:55: JOIN ON clause must be a comma separated list of fields or a single expression, found [\\\"abc\\\"]\",\n             error(\"row languages = 1, gender = \\\"f\\\" | lookup join test on \\\"abc\\\"\")\n         );\n         assertEquals(\n-            \"1:55: JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found [false]\",\n+            \"1:55: JOIN ON clause must be a comma separated list of fields or a single expression, found [false]\",\n             error(\"row languages = 1, gender = \\\"f\\\" | lookup join test on false\")\n         );\n     }\n \n+    public void testLookupJoinExpressionMixed() {\n+        assumeTrue(\"requires LOOKUP JOIN capability\", EsqlCapabilities.Cap.JOIN_LOOKUP_V12.isEnabled());\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON languages_left == language_code or salary > 1000\n+            \"\"\";\n+\n+        assertEquals(\n+            \"3:32: JOIN ON clause with expressions must contain at least one condition relating the left index and the lookup index\",\n+            error(queryString)\n+        );\n+    }\n+\n+    public void testLookupJoinExpressionOnlyRightFilter() {\n+        assumeTrue(\"requires LOOKUP JOIN capability\", EsqlCapabilities.Cap.JOIN_LOOKUP_V12.isEnabled());\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON salary > 1000\n+            \"\"\";\n+\n+        assertEquals(\n+            \"3:32: JOIN ON clause with expressions must contain at least one condition relating the left index and the lookup index\",\n+            error(queryString)\n+        );\n+    }\n+\n+    public void testLookupJoinExpressionFieldBasePlusRightFilterAnd() {\n+        assumeTrue(\"requires LOOKUP JOIN capability\", EsqlCapabilities.Cap.JOIN_LOOKUP_V12.isEnabled());\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | lookup join languages_lookup ON languages and salary > 1000\n+            \"\"\";\n+\n+        assertEquals(\n+            \"2:32: JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found [languages]\",\n+            error(queryString)\n+        );\n+    }\n+\n+    public void testLookupJoinExpressionFieldBasePlusRightFilterComma() {\n+        assumeTrue(\"requires LOOKUP JOIN capability\", EsqlCapabilities.Cap.JOIN_LOOKUP_V12.isEnabled());\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | lookup join languages_lookup ON languages, salary > 1000\n+            \"\"\";\n+\n+        assertEquals(\n+            \"2:46: JOIN ON clause must be a comma separated list of fields or a single expression, found [salary > 1000]\",\n+            error(queryString)\n+        );\n+    }\n+\n     public void testJoinTwiceOnTheSameField() {\n         assertEquals(\n             \"1:66: JOIN ON clause does not support multiple fields with the same name, found multiple instances of [languages]\",\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/VerifierTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/VerifierTests.java\nindex d8e84fd8abd51..9d05b33d81c01 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/VerifierTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/analysis/VerifierTests.java\n@@ -8,6 +8,7 @@\n package org.elasticsearch.xpack.esql.analysis;\n \n import org.elasticsearch.Build;\n+import org.elasticsearch.TransportVersion;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.test.ESTestCase;\n import org.elasticsearch.xpack.esql.VerificationException;\n@@ -41,6 +42,7 @@\n \n import static org.elasticsearch.xpack.esql.EsqlTestUtils.paramAsConstant;\n import static org.elasticsearch.xpack.esql.EsqlTestUtils.withDefaultLimitWarning;\n+import static org.elasticsearch.xpack.esql.analysis.Analyzer.ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION;\n import static org.elasticsearch.xpack.esql.analysis.AnalyzerTestUtils.TEXT_EMBEDDING_INFERENCE_ID;\n import static org.elasticsearch.xpack.esql.analysis.AnalyzerTestUtils.loadMapping;\n import static org.elasticsearch.xpack.esql.core.type.DataType.BOOLEAN;\n@@ -72,6 +74,12 @@\n import static org.hamcrest.Matchers.startsWith;\n \n //@TestLogging(value = \"org.elasticsearch.xpack.esql:TRACE,org.elasticsearch.compute:TRACE\", reason = \"debug\")\n+/**\n+ * Parses a plan, builds an AST for it, runs logical analysis and post analysis verification.\n+ * So if we don't error out in the process, post analysis verification passed\n+ * Use this class if you want to test post analysis verification\n+ * and especially if you expect to get a VerificationException\n+ */\n public class VerifierTests extends ESTestCase {\n \n     private static final EsqlParser parser = new EsqlParser();\n@@ -2251,6 +2259,88 @@ public void testLookupJoinExpressionAmbiguousRight() {\n         );\n     }\n \n+    public void testLookupJoinExpressionRightNotPushable() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON languages_left == language_code and abs(salary) > 1000\n+            \"\"\";\n+\n+        assertEquals(\n+            \"3:71: Unsupported join filter expression:abs(salary) > 1000\",\n+            error(queryString, ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION)\n+        );\n+    }\n+\n+    public void testLookupJoinExpressionConstant() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON false and languages_left == language_code\n+            \"\"\";\n+\n+        assertEquals(\"3:35: Unsupported join filter expression:false\", error(queryString, ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION));\n+    }\n+\n+    public void testLookupJoinExpressionTranslatableButFromLeft() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON languages_left == language_code and languages_left == \"English\"\n+            \"\"\";\n+\n+        assertEquals(\n+            \"3:71: Unsupported join filter expression:languages_left == \\\"English\\\"\",\n+            error(queryString, ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION)\n+        );\n+    }\n+\n+    public void testLookupJoinExpressionTranslatableButMixedLeftRight() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON languages_left == language_code and CONCAT(languages_left, language_code) == \"English\"\n+            \"\"\";\n+\n+        assertEquals(\n+            \"3:71: Unsupported join filter expression:CONCAT(languages_left, language_code) == \\\"English\\\"\",\n+            error(queryString, ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION)\n+        );\n+    }\n+\n+    public void testLookupJoinExpressionComplexFormula() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+        String queryString = \"\"\"\n+            from test\n+            | rename languages as languages_left\n+            | lookup join languages_lookup ON languages_left == language_code AND STARTSWITH(languages_left, language_code)\n+            \"\"\";\n+\n+        assertEquals(\n+            \"3:71: Unsupported join filter expression:STARTSWITH(languages_left, language_code)\",\n+            error(queryString, ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION)\n+        );\n+    }\n+\n     public void testLookupJoinExpressionAmbiguousLeft() {\n         assumeTrue(\n             \"requires LOOKUP JOIN ON boolean expression capability\",\n@@ -2993,13 +3083,17 @@ private String error(String query) {\n     }\n \n     private String error(String query, Object... params) {\n-        return error(query, defaultAnalyzer, params);\n+        return error(query, defaultAnalyzer, VerificationException.class, params);\n     }\n \n     private String error(String query, Analyzer analyzer, Object... params) {\n         return error(query, analyzer, VerificationException.class, params);\n     }\n \n+    private String error(String query, TransportVersion transportVersion, Object... params) {\n+        return error(query, transportVersion, VerificationException.class, params);\n+    }\n+\n     private String error(String query, Analyzer analyzer, Class<? extends Exception> exception, Object... params) {\n         List<QueryParam> parameters = new ArrayList<>();\n         for (Object param : params) {\n@@ -3029,6 +3123,13 @@ private String error(String query, Analyzer analyzer, Class<? extends Exception>\n         return message.substring(index + pattern.length());\n     }\n \n+    private String error(String query, TransportVersion transportVersion, Class<? extends Exception> exception, Object... params) {\n+        MutableAnalyzerContext mutableContext = (MutableAnalyzerContext) defaultAnalyzer.context();\n+        try (var restore = mutableContext.setTemporaryTransportVersionOnOrAfter(transportVersion)) {\n+            return error(query, defaultAnalyzer, exception, params);\n+        }\n+    }\n+\n     @Override\n     protected List<String> filteredWarnings() {\n         return withDefaultLimitWarning(super.filteredWarnings());\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/LookupFromIndexOperatorTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/LookupFromIndexOperatorTests.java\nindex c342377e7894f..e02ef6110e5c4 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/LookupFromIndexOperatorTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/enrich/LookupFromIndexOperatorTests.java\n@@ -108,6 +108,7 @@ public class LookupFromIndexOperatorTests extends AsyncOperatorTestCase {\n     private final ThreadPool threadPool = threadPool();\n     private final Directory lookupIndexDirectory = newDirectory();\n     private final List<Releasable> releasables = new ArrayList<>();\n+    private final boolean applyRightFilterAsJoinOnFilter;\n     private int numberOfJoinColumns; // we only allow 1 or 2 columns due to simpleInput() implementation\n     private EsqlBinaryComparison.BinaryComparisonOperation operation;\n \n@@ -129,6 +130,7 @@ public static Iterable<Object[]> parametersFactory() {\n     public LookupFromIndexOperatorTests(EsqlBinaryComparison.BinaryComparisonOperation operation) {\n         super();\n         this.operation = operation;\n+        this.applyRightFilterAsJoinOnFilter = randomBoolean();\n     }\n \n     @Before\n@@ -248,6 +250,7 @@ protected Operator.OperatorFactory simple(SimpleOptions options) {\n             matchFields.add(new MatchConfig(matchField, i, inputDataType));\n         }\n         Expression joinOnExpression = null;\n+        FragmentExec rightPlanWithOptionalPreJoinFilter = buildLessThanFilter(LESS_THAN_VALUE);\n         if (operation != null) {\n             List<Expression> conditions = new ArrayList<>();\n             for (int i = 0; i < numberOfJoinColumns; i++) {\n@@ -265,6 +268,13 @@ protected Operator.OperatorFactory simple(SimpleOptions options) {\n                 );\n                 conditions.add(operation.buildNewInstance(Source.EMPTY, left, right));\n             }\n+            if (applyRightFilterAsJoinOnFilter) {\n+                if (rightPlanWithOptionalPreJoinFilter instanceof FragmentExec fragmentExec\n+                    && fragmentExec.fragment() instanceof Filter filterPlan) {\n+                    conditions.add(filterPlan.condition());\n+                    rightPlanWithOptionalPreJoinFilter = null;\n+                }\n+            }\n             joinOnExpression = Predicates.combineAnd(conditions);\n         }\n \n@@ -278,7 +288,7 @@ protected Operator.OperatorFactory simple(SimpleOptions options) {\n             lookupIndex,\n             loadFields,\n             Source.EMPTY,\n-            buildLessThanFilter(LESS_THAN_VALUE),\n+            rightPlanWithOptionalPreJoinFilter,\n             joinOnExpression\n         );\n     }\n@@ -321,25 +331,41 @@ protected Matcher<String> expectedToStringOfSimple() {\n             // match_field=match<i>_left (index first, then suffix)\n             sb.append(\"input_type=LONG match_field=match\").append(i).append(suffix).append(\" inputChannel=\").append(i).append(\" \");\n         }\n-        // Accept either the legacy physical plan rendering (FilterExec/EsQueryExec) or the new FragmentExec rendering\n-        sb.append(\"right_pre_join_plan=(?:\");\n-        // Legacy pattern\n-        sb.append(\"FilterExec\\\\[lint\\\\{f}#\\\\d+ < \")\n-            .append(LESS_THAN_VALUE)\n-            .append(\n-                \"\\\\[INTEGER]]\\\\n\\\\\\\\_EsQueryExec\\\\[test], indexMode\\\\[lookup],\\\\s*(?:query\\\\[\\\\]|\\\\[\\\\])?,?\\\\s*\"\n-                    + \"limit\\\\[\\\\],?\\\\s*sort\\\\[(?:\\\\[\\\\])?\\\\]\\\\s*estimatedRowSize\\\\[null\\\\]\\\\s*queryBuilderAndTags \\\\[(?:\\\\[\\\\]\\\\])\\\\]\"\n-            );\n-        sb.append(\"|\");\n-        // New FragmentExec pattern - match the actual output format\n-        sb.append(\"FragmentExec\\\\[filter=null, estimatedRowSize=\\\\d+, reducer=\\\\[\\\\], fragment=\\\\[<>\\\\n\")\n-            .append(\"Filter\\\\[lint\\\\{f}#\\\\d+ < \")\n-            .append(LESS_THAN_VALUE)\n-            .append(\"\\\\[INTEGER]]\\\\n\")\n-            .append(\"\\\\\\\\_EsRelation\\\\[test]\\\\[LOOKUP]\\\\[\\\\]<>\\\\]\\\\]\");\n-        sb.append(\")\");\n+\n+        if (applyRightFilterAsJoinOnFilter && operation != null) {\n+            // When applyRightFilterAsJoinOnFilter is true, right_pre_join_plan should be null\n+            sb.append(\"right_pre_join_plan=null\");\n+        } else {\n+            // Accept either the legacy physical plan rendering (FilterExec/EsQueryExec) or the new FragmentExec rendering\n+            sb.append(\"right_pre_join_plan=(?:\");\n+            // Legacy pattern\n+            sb.append(\"FilterExec\\\\[lint\\\\{f}#\\\\d+ < \")\n+                .append(LESS_THAN_VALUE)\n+                .append(\n+                    \"\\\\[INTEGER]]\\\\n\\\\\\\\_EsQueryExec\\\\[test], indexMode\\\\[lookup],\\\\s*(?:query\\\\[\\\\]|\\\\[\\\\])?,?\\\\s*\"\n+                        + \"limit\\\\[\\\\],?\\\\s*sort\\\\[(?:\\\\[\\\\])?\\\\]\\\\s*estimatedRowSize\\\\[null\\\\]\\\\s*queryBuilderAndTags \\\\[(?:\\\\[\\\\]\\\\])\\\\]\"\n+                );\n+            sb.append(\"|\");\n+            // New FragmentExec pattern - match the actual output format\n+            sb.append(\"FragmentExec\\\\[filter=null, estimatedRowSize=\\\\d+, reducer=\\\\[\\\\], fragment=\\\\[<>\\\\n\")\n+                .append(\"Filter\\\\[lint\\\\{f}#\\\\d+ < \")\n+                .append(LESS_THAN_VALUE)\n+                .append(\"\\\\[INTEGER]]\\\\n\")\n+                .append(\"\\\\\\\\_EsRelation\\\\[test]\\\\[LOOKUP]\\\\[\\\\]<>\\\\]\\\\]\");\n+            sb.append(\")\");\n+        }\n+\n         // Accept join_on_expression=null or a valid join predicate\n-        sb.append(\" join_on_expression=(null|match\\\\d+left [=!<>]+ match\\\\d+right( AND match\\\\d+left [=!<>]+ match\\\\d+right)*|)\\\\]\");\n+        if (applyRightFilterAsJoinOnFilter && operation != null) {\n+            // When applyRightFilterAsJoinOnFilter is true and operation is not null, the join expression includes the filter condition\n+            sb.append(\n+                \" join_on_expression=(match\\\\d+left [=!<>]+ match\\\\d+right( \"\n+                    + \"AND match\\\\d+left [=!<>]+ match\\\\d+right)* AND lint\\\\{f}#\\\\d+ < \"\n+            ).append(LESS_THAN_VALUE).append(\"\\\\[INTEGER]|)\\\\]\");\n+        } else {\n+            // Standard pattern for other cases\n+            sb.append(\" join_on_expression=(null|match\\\\d+left [=!<>]+ match\\\\d+right( AND match\\\\d+left [=!<>]+ match\\\\d+right)*|)\\\\]\");\n+        }\n         return matchesPattern(sb.toString());\n     }\n \ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/AbstractLogicalPlanOptimizerTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/AbstractLogicalPlanOptimizerTests.java\nindex 498c138bb92bc..94f1e0bada932 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/AbstractLogicalPlanOptimizerTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/AbstractLogicalPlanOptimizerTests.java\n@@ -15,6 +15,7 @@\n import org.elasticsearch.xpack.esql.analysis.Analyzer;\n import org.elasticsearch.xpack.esql.analysis.AnalyzerTestUtils;\n import org.elasticsearch.xpack.esql.analysis.EnrichResolution;\n+import org.elasticsearch.xpack.esql.analysis.MutableAnalyzerContext;\n import org.elasticsearch.xpack.esql.core.type.EsField;\n import org.elasticsearch.xpack.esql.expression.function.EsqlFunctionRegistry;\n import org.elasticsearch.xpack.esql.index.EsIndex;\n@@ -217,6 +218,13 @@ protected LogicalPlan optimizedPlan(String query) {\n         return plan(query);\n     }\n \n+    protected LogicalPlan optimizedPlan(String query, TransportVersion transportVersion) {\n+        MutableAnalyzerContext mutableContext = (MutableAnalyzerContext) analyzer.context();\n+        try (var restore = mutableContext.setTemporaryTransportVersionOnOrAfter(transportVersion)) {\n+            return optimizedPlan(query);\n+        }\n+    }\n+\n     protected LogicalPlan plan(String query) {\n         return plan(query, logicalOptimizer);\n     }\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/LogicalPlanOptimizerTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/LogicalPlanOptimizerTests.java\nindex a7ab9979104c3..542180a1b85e6 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/LogicalPlanOptimizerTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/LogicalPlanOptimizerTests.java\n@@ -78,6 +78,7 @@\n import org.elasticsearch.xpack.esql.expression.function.scalar.multivalue.MvSum;\n import org.elasticsearch.xpack.esql.expression.function.scalar.nulls.Coalesce;\n import org.elasticsearch.xpack.esql.expression.function.scalar.string.Concat;\n+import org.elasticsearch.xpack.esql.expression.function.scalar.string.regex.WildcardLike;\n import org.elasticsearch.xpack.esql.expression.function.vector.Knn;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.And;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.Not;\n@@ -177,6 +178,7 @@\n import static org.elasticsearch.xpack.esql.EsqlTestUtils.singleValue;\n import static org.elasticsearch.xpack.esql.EsqlTestUtils.testAnalyzerContext;\n import static org.elasticsearch.xpack.esql.EsqlTestUtils.withDefaultLimitWarning;\n+import static org.elasticsearch.xpack.esql.analysis.Analyzer.ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION;\n import static org.elasticsearch.xpack.esql.analysis.Analyzer.NO_FIELDS;\n import static org.elasticsearch.xpack.esql.analysis.AnalyzerTestUtils.analyze;\n import static org.elasticsearch.xpack.esql.analysis.AnalyzerTestUtils.defaultAnalyzer;\n@@ -5405,6 +5407,82 @@ public void testPlanSanityCheckWithBinaryPlans() {\n         assertThat(e.getMessage(), containsString(\" optimized incorrectly due to missing references from right hand side [language_code\"));\n     }\n \n+    /**\n+     * Expected\n+     * <pre>{@code\n+     * Limit[1000[INTEGER],true]\n+     * \\_Join[LEFT,[languages{f}#8],[language_code{f}#16],languages{f}#8 == language_code{f}#16 AND language_name{f}#17 == English\n+     * [KEYWORD]]\n+     *   |_Limit[1000[INTEGER],false]\n+     *   | \\_EsRelation[test][_meta_field{f}#11, emp_no{f}#5, first_name{f}#6, ge..]\n+     *   \\_EsRelation[languages_lookup][LOOKUP][language_code{f}#16, language_name{f}#17]\n+     * }</pre>\n+     */\n+    public void testLookupJoinRightFilter() {\n+        assumeTrue(\"Requires LOOKUP JOIN\", EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled());\n+\n+        var plan = optimizedPlan(\"\"\"\n+              FROM test\n+            | LOOKUP JOIN languages_lookup ON languages == language_code and language_name == \"English\"\n+            \"\"\", ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION);\n+\n+        var upperLimit = asLimit(plan, 1000, true);\n+        var join = as(upperLimit.child(), Join.class);\n+        assertEquals(\"ON languages == language_code and language_name == \\\"English\\\"\", join.config().joinOnConditions().toString());\n+        var limitPastJoin = asLimit(join.left(), 1000, false);\n+        as(limitPastJoin.child(), EsRelation.class);\n+        as(join.right(), EsRelation.class);\n+    }\n+\n+    public void testLookupJoinRightFilterMatch() {\n+        assumeTrue(\"Requires LOOKUP JOIN\", EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled());\n+\n+        var plan = optimizedPlan(\"\"\"\n+              FROM test\n+            | LOOKUP JOIN languages_lookup ON languages == language_code and MATCH(language_name,\"English\")\n+            \"\"\", ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION);\n+\n+        var upperLimit = asLimit(plan, 1000, true);\n+        var join = as(upperLimit.child(), Join.class);\n+        assertEquals(\"ON languages == language_code and MATCH(language_name,\\\"English\\\")\", join.config().joinOnConditions().toString());\n+        var limitPastJoin = asLimit(join.left(), 1000, false);\n+        as(limitPastJoin.child(), EsRelation.class);\n+        as(join.right(), EsRelation.class);\n+    }\n+\n+    /**\n+     * Limit[1000[INTEGER],false]\n+     * \\_Filter[LIKE(language_name{f}#18, \"French*\", false)]\n+     *   \\_Join[LEFT,[languages{f}#9],[language_code{f}#17],languages{f}#9 == language_code{f}#17 AND MATCH(language_name{f}#18,\n+     * English[KEYWORD])]\n+     *     |_EsRelation[test][_meta_field{f}#12, emp_no{f}#6, first_name{f}#7, ge..]\n+     *     \\_Filter[LIKE(language_name{f}#18, \"French*\", false)]\n+     *       \\_EsRelation[languages_lookup][LOOKUP][language_code{f}#17, language_name{f}#18]\n+     */\n+    public void testLookupJoinRightFilterMatchWithWhereClause() {\n+        assumeTrue(\"Requires LOOKUP JOIN\", EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled());\n+\n+        var plan = optimizedPlan(\"\"\"\n+              FROM test\n+            | LOOKUP JOIN languages_lookup ON languages == language_code and MATCH(language_name,\"English\")\n+            | WHERE language_name LIKE \"French*\"\n+            \"\"\", ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION);\n+\n+        var upperLimit = asLimit(plan, 1000, false);\n+        var topFilter = as(upperLimit.child(), Filter.class);\n+        var join = as(topFilter.child(), Join.class);\n+        assertEquals(\"ON languages == language_code and MATCH(language_name,\\\"English\\\")\", join.config().joinOnConditions().toString());\n+\n+        // Check that the LIKE condition is pushed down as a right pre-join filter\n+        var rightFilter = as(join.right(), Filter.class);\n+        var likeCondition = as(rightFilter.condition(), WildcardLike.class);\n+        var field = as(likeCondition.field(), FieldAttribute.class);\n+        assertEquals(\"language_name\", field.name());\n+        assertEquals(\"French*\", likeCondition.pattern().pattern());\n+\n+        as(rightFilter.child(), EsRelation.class);\n+    }\n+\n     // https://github.com/elastic/elasticsearch/issues/104995\n     public void testNoWrongIsNotNullPruning() {\n         var plan = optimizedPlan(\"\"\"\n@@ -7332,6 +7410,91 @@ public void testLookupJoinPushDownSeparatedForConjunctionBetweenLeftAndRightFiel\n         var rightRel = as(rightFilter.child(), EsRelation.class);\n     }\n \n+    /**\n+     * Limit[1000[INTEGER],true]\n+     * \\_Join[LEFT,[emp_no{f}#5],[id{f}#16],emp_no{f}#5 == id{f}#16 AND SPATIALINTERSECTS([1 3 0 0 0 1 0 0 0 5 0 0 0 0 0 0 0 0\n+     * 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 f0 3f 0 0 0 0 0 0 0 0 0 0 0 0 0 0 f0 3f 0 0 0 0 0 0 f0 3f 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n+     * f0 3f 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0][GEO_SHAPE],shape{f}#19)]\n+     *   |_Limit[1000[INTEGER],false]\n+     *   | \\_EsRelation[test][_meta_field{f}#11, emp_no{f}#5, first_name{f}#6, ge..]\n+     *   \\_EsRelation[spatial_lookup][LOOKUP][contains{f}#18, id{f}#16, intersects{f}#17, shape{f..]\n+     */\n+    public void testLookupJoinRightFilterSpatialIntersects() {\n+        assumeTrue(\"Requires LOOKUP JOIN\", EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled());\n+\n+        var plan = optimizedPlan(\"\"\"\n+              FROM test\n+            | LOOKUP JOIN spatial_lookup ON emp_no == id AND ST_INTERSECTS(TO_GEOSHAPE(\"POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))\"), shape)\n+            \"\"\", ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION);\n+\n+        var upperLimit = asLimit(plan, 1000, true);\n+        var join = as(upperLimit.child(), Join.class);\n+        assertEquals(\n+            \"ON emp_no == id AND ST_INTERSECTS(TO_GEOSHAPE(\\\"POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))\\\"), shape)\",\n+            join.config().joinOnConditions().toString()\n+        );\n+        var limitPastJoin = asLimit(join.left(), 1000, false);\n+        as(limitPastJoin.child(), EsRelation.class);\n+        as(join.right(), EsRelation.class);\n+    }\n+\n+    /**\n+     * Limit[1000[INTEGER],true]\n+     * \\_Join[LEFT,[emp_no{f}#5],[id{f}#16],emp_no{f}#5 == id{f}#16 AND SPATIALINTERSECTS([1 3 0 0 0 1 0 0 0 5 0 0 0 0 0 0 0 0\n+     * 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 f0 3f 0 0 0 0 0 0 0 0 0 0 0 0 0 0 f0 3f 0 0 0 0 0 0 f0 3f 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n+     * f0 3f 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0][GEO_SHAPE],shape{f}#19)]\n+     *   |_Limit[1000[INTEGER],false]\n+     *   | \\_EsRelation[test][_meta_field{f}#11, emp_no{f}#5, first_name{f}#6, ge..]\n+     *   \\_EsRelation[spatial_lookup][LOOKUP][contains{f}#18, id{f}#16, intersects{f}#17, shape{f..]\n+     */\n+    public void testLookupJoinRightFilterSpatialWithin() {\n+        assumeTrue(\"Requires LOOKUP JOIN\", EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled());\n+\n+        var plan = optimizedPlan(\"\"\"\n+              FROM test\n+            | LOOKUP JOIN spatial_lookup ON emp_no == id AND ST_WITHIN(shape, TO_GEOSHAPE(\"POLYGON((0 0, 2 0, 2 2, 0 2, 0 0))\"))\n+            \"\"\", ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION);\n+\n+        var upperLimit = asLimit(plan, 1000, true);\n+        var join = as(upperLimit.child(), Join.class);\n+        assertEquals(\n+            \"ON emp_no == id AND ST_WITHIN(shape, TO_GEOSHAPE(\\\"POLYGON((0 0, 2 0, 2 2, 0 2, 0 0))\\\"))\",\n+            join.config().joinOnConditions().toString()\n+        );\n+        var limitPastJoin = asLimit(join.left(), 1000, false);\n+        as(limitPastJoin.child(), EsRelation.class);\n+        as(join.right(), EsRelation.class);\n+    }\n+\n+    /**\n+     * Limit[1000[INTEGER],true]\n+     * \\_Join[LEFT,[emp_no{f}#5],[id{f}#16],emp_no{f}#5 == id{f}#16 AND SPATIALCONTAINS(shape{f}#19,[1 3 0 0 0 1 0 0 0 5 0 0 0\n+     * 0 0 0 0 0 0 e0 3f 0 0 0 0 0 0 e0 3f 0 0 0 0 0 0 f8 3f 0 0 0 0 0 0 e0 3f 0 0 0 0 0 0 f8 3f 0 0 0 0 0 0 f8 3f 0 0 0 0 0 0\n+     * e0 3f 0 0 0 0 0 0 f8 3f 0 0 0 0 0 0 e0 3f 0 0 0 0 0 0 e0 3f][GEO_SHAPE])]\n+     *   |_Limit[1000[INTEGER],false]\n+     *   | \\_EsRelation[test][_meta_field{f}#11, emp_no{f}#5, first_name{f}#6, ge..]\n+     *   \\_EsRelation[spatial_lookup][LOOKUP][contains{f}#18, id{f}#16, intersects{f}#17, shape{f..]\n+     */\n+    public void testLookupJoinRightFilterSpatialContains() {\n+        assumeTrue(\"Requires LOOKUP JOIN\", EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled());\n+\n+        var plan = optimizedPlan(\"\"\"\n+              FROM test\n+            | LOOKUP JOIN spatial_lookup\n+            ON emp_no == id AND ST_CONTAINS(shape, TO_GEOSHAPE(\"POLYGON((0.5 0.5, 1.5 0.5, 1.5 1.5, 0.5 1.5, 0.5 0.5))\"))\n+            \"\"\", ESQL_LOOKUP_JOIN_FULL_TEXT_FUNCTION);\n+\n+        var upperLimit = asLimit(plan, 1000, true);\n+        var join = as(upperLimit.child(), Join.class);\n+        assertEquals(\n+            \"ON emp_no == id AND ST_CONTAINS(shape, TO_GEOSHAPE(\\\"POLYGON((0.5 0.5, 1.5 0.5, 1.5 1.5, 0.5 1.5, 0.5 0.5))\\\"))\",\n+            join.config().joinOnConditions().toString()\n+        );\n+        var limitPastJoin = asLimit(join.left(), 1000, false);\n+        as(limitPastJoin.child(), EsRelation.class);\n+        as(join.right(), EsRelation.class);\n+    }\n+\n     /**\n      * Disjunctions however keep the filter in place, even on pushable fields\n      * <p>\ndiff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/parser/StatementParserTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/parser/StatementParserTests.java\nindex ffe6c102ed516..b61856ab5333e 100644\n--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/parser/StatementParserTests.java\n+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/parser/StatementParserTests.java\n@@ -35,6 +35,7 @@\n import org.elasticsearch.xpack.esql.expression.function.scalar.string.regex.RLike;\n import org.elasticsearch.xpack.esql.expression.function.scalar.string.regex.WildcardLike;\n import org.elasticsearch.xpack.esql.expression.predicate.Predicates;\n+import org.elasticsearch.xpack.esql.expression.predicate.logical.And;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.Not;\n import org.elasticsearch.xpack.esql.expression.predicate.logical.Or;\n import org.elasticsearch.xpack.esql.expression.predicate.operator.arithmetic.Add;\n@@ -116,6 +117,13 @@\n import static org.hamcrest.Matchers.startsWith;\n \n //@TestLogging(value = \"org.elasticsearch.xpack.esql:TRACE\", reason = \"debug\")\n+\n+/**\n+ * Only parses a plan and builds an AST/Logical Plan for it.\n+ * Analysis is not run, so the plan will contain unresolved references.\n+ * Use this class to test cases where we throw a Parsing exception\n+ * especially if it is throw before we get to the Analysis phase\n+ */\n public class StatementParserTests extends AbstractStatementParserTests {\n \n     private static final LogicalPlan PROCESSING_CMD_INPUT = new Row(EMPTY, List.of(new Alias(EMPTY, \"a\", integer(1))));\n@@ -3540,6 +3548,28 @@ public void testInvalidLookupJoinOnClause() {\n             \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found\"\n         );\n \n+        expectError(\n+            \"FROM test  | LOOKUP JOIN test2 ON \"\n+                + singleExpressionJoinClause()\n+                + \" AND (\"\n+                + randomIdentifier()\n+                + \" OR \"\n+                + singleExpressionJoinClause()\n+                + \")\",\n+            \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found\"\n+        );\n+\n+        expectError(\n+            \"FROM test  | LOOKUP JOIN test2 ON \"\n+                + singleExpressionJoinClause()\n+                + \" AND (\"\n+                + randomIdentifier()\n+                + \"OR\"\n+                + randomIdentifier()\n+                + \")\",\n+            \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found\"\n+        );\n+\n         expectError(\n             \"FROM test  | LOOKUP JOIN test2 ON \" + randomIdentifier() + \" AND \" + randomIdentifier(),\n             \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment, found\"\n@@ -3703,6 +3733,78 @@ private void testInvalidJoinPatterns(String onClause) {\n         }\n     }\n \n+    public void testLookupJoinOnExpressionWithNamedQueryParameters() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+\n+        // Test LOOKUP JOIN ON expression with named query parameters and MATCH function\n+        var plan = statement(\n+            \"FROM test | LOOKUP JOIN test2 ON left_field >= right_field AND match(left_field, ?search_term)\",\n+            new QueryParams(List.of(paramAsConstant(\"search_term\", \"elasticsearch\")))\n+        );\n+\n+        var join = as(plan, LookupJoin.class);\n+        assertThat(as(join.left(), UnresolvedRelation.class).indexPattern().indexPattern(), equalTo(\"test\"));\n+        assertThat(as(join.right(), UnresolvedRelation.class).indexPattern().indexPattern(), equalTo(\"test2\"));\n+\n+        // Verify the join condition contains both the comparison and MATCH function\n+        var condition = join.config().joinOnConditions();\n+        assertThat(condition, instanceOf(And.class));\n+        var andCondition = (And) condition;\n+\n+        // Check that we have both conditions in the correct order\n+        assertThat(andCondition.children().size(), equalTo(2));\n+\n+        // First child should be a binary comparison (left_field >= right_field)\n+        var firstChild = andCondition.children().get(0);\n+        assertThat(\"First condition should be binary comparison\", firstChild, instanceOf(EsqlBinaryComparison.class));\n+\n+        // Second child should be a MATCH function (match(left_field, ?search_term))\n+        var secondChild = andCondition.children().get(1);\n+        assertThat(\"Second condition should be UnresolvedFunction\", secondChild, instanceOf(UnresolvedFunction.class));\n+        var function = (UnresolvedFunction) secondChild;\n+        assertThat(\"Second condition should be MATCH function\", function.name(), equalTo(\"match\"));\n+    }\n+\n+    public void testLookupJoinOnExpressionWithPositionalQueryParameters() {\n+        assumeTrue(\n+            \"requires LOOKUP JOIN ON boolean expression capability\",\n+            EsqlCapabilities.Cap.LOOKUP_JOIN_WITH_FULL_TEXT_FUNCTION.isEnabled()\n+        );\n+\n+        // Test LOOKUP JOIN ON expression with positional query parameters and MATCH function\n+        var plan = statement(\n+            \"FROM test | LOOKUP JOIN test2 ON left_field >= right_field AND match(left_field, ?2)\",\n+            new QueryParams(List.of(paramAsConstant(null, \"dummy\"), paramAsConstant(null, \"elasticsearch\")))\n+        );\n+\n+        var join = as(plan, LookupJoin.class);\n+        assertThat(as(join.left(), UnresolvedRelation.class).indexPattern().indexPattern(), equalTo(\"test\"));\n+        assertThat(as(join.right(), UnresolvedRelation.class).indexPattern().indexPattern(), equalTo(\"test2\"));\n+\n+        // Verify the join condition contains both the comparison and MATCH function\n+        var condition = join.config().joinOnConditions();\n+        assertThat(condition, instanceOf(And.class));\n+        var andCondition = (And) condition;\n+\n+        // Check that we have both conditions in the correct order\n+        assertThat(andCondition.children().size(), equalTo(2));\n+\n+        // First child should be a binary comparison (left_field >= right_field)\n+        var firstChild = andCondition.children().get(0);\n+        assertThat(\"First condition should be binary comparison\", firstChild, instanceOf(EsqlBinaryComparison.class));\n+\n+        // Second child should be a MATCH function (match(left_field, ?))\n+        var secondChild = andCondition.children().get(1);\n+        assertThat(\"Second condition should be UnresolvedFunction\", secondChild, instanceOf(UnresolvedFunction.class));\n+        var function = (UnresolvedFunction) secondChild;\n+        assertThat(\"Second condition should be MATCH function\", function.name(), equalTo(\"match\"));\n+        assertEquals(2, function.children().size());\n+        assertEquals(\"elasticsearch\", function.children().get(1).toString());\n+    }\n+\n     public void testInvalidInsistAsterisk() {\n         assumeTrue(\"requires snapshot build\", Build.current().isSnapshot());\n         expectError(\"FROM text | EVAL x = 4 | INSIST_ðŸ” *\", \"INSIST doesn't support wildcards, found [*]\");\n@@ -5080,7 +5182,7 @@ public void testMixedSingleDoubleParams() {\n                     expectError(\n                         LoggerMessageFormat.format(null, \"from test | \" + command, param1, param2, param3),\n                         List.of(paramAsConstant(\"f1\", \"f1\"), paramAsConstant(\"f2\", \"f2\"), paramAsConstant(\"f3\", \"f3\")),\n-                        \"JOIN ON clause only supports fields or AND of Binary Expressions at the moment\"\n+                        \"JOIN ON clause must be a comma separated list of fields or a single expression, found\"\n                     );\n \n                 }\n",
  "additions": 1550,
  "deletions": 219,
  "changed_files": 28,
  "url": "https://github.com/elastic/elasticsearch/pull/136104",
  "mined_at": "2025-10-25T13:37:35.604652"
}