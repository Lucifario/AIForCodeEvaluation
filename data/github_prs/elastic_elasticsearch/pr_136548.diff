diff --git a/docs/changelog/136548.yaml b/docs/changelog/136548.yaml
new file mode 100644
index 0000000000000..1c360c8e3cb49
--- /dev/null
+++ b/docs/changelog/136548.yaml
@@ -0,0 +1,6 @@
+pr: 136548
+summary: Locale and timezone argument for `date_parse`
+area: ES|QL
+type: enhancement
+issues:
+ - 132487
diff --git a/docs/reference/query-languages/esql/_snippets/functions/functionNamedParams/date_parse.md b/docs/reference/query-languages/esql/_snippets/functions/functionNamedParams/date_parse.md
new file mode 100644
index 0000000000000..328494ce830d3
--- /dev/null
+++ b/docs/reference/query-languages/esql/_snippets/functions/functionNamedParams/date_parse.md
@@ -0,0 +1,10 @@
+% This is generated by ESQL's AbstractFunctionTestCase. Do not edit it. See ../README.md for how to regenerate it.
+
+**Supported function named parameters**
+
+`time_zone`
+:   (keyword) Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.
+
+`locale`
+:   (keyword) The locale to use when parsing the date, relevant when parsing month names or week days.
+
diff --git a/docs/reference/query-languages/esql/_snippets/functions/layout/date_parse.md b/docs/reference/query-languages/esql/_snippets/functions/layout/date_parse.md
index 4ac4734ef823b..f9c3d45b01c6d 100644
--- a/docs/reference/query-languages/esql/_snippets/functions/layout/date_parse.md
+++ b/docs/reference/query-languages/esql/_snippets/functions/layout/date_parse.md
@@ -19,5 +19,8 @@
 :::{include} ../types/date_parse.md
 :::
 
+:::{include} ../functionNamedParams/date_parse.md
+:::
+
 :::{include} ../examples/date_parse.md
 :::
diff --git a/docs/reference/query-languages/esql/_snippets/functions/parameters/date_parse.md b/docs/reference/query-languages/esql/_snippets/functions/parameters/date_parse.md
index adc0a0c86b19d..b10bec180329c 100644
--- a/docs/reference/query-languages/esql/_snippets/functions/parameters/date_parse.md
+++ b/docs/reference/query-languages/esql/_snippets/functions/parameters/date_parse.md
@@ -8,3 +8,6 @@
 `dateString`
 :   Date expression as a string. If `null` or an empty string, the function returns `null`.
 
+`options`
+:   (Optional) Additional options for date parsing, specifying time zone and locale as [function named parameters](/reference/query-languages/esql/esql-syntax.md#esql-function-named-params).
+
diff --git a/docs/reference/query-languages/esql/_snippets/functions/types/date_parse.md b/docs/reference/query-languages/esql/_snippets/functions/types/date_parse.md
index 4f1873cd3796b..41836f67f152c 100644
--- a/docs/reference/query-languages/esql/_snippets/functions/types/date_parse.md
+++ b/docs/reference/query-languages/esql/_snippets/functions/types/date_parse.md
@@ -2,10 +2,11 @@
 
 **Supported types**
 
-| datePattern | dateString | result |
-| --- | --- | --- |
-| keyword | keyword | date |
-| keyword | text | date |
-| text | keyword | date |
-| text | text | date |
+| datePattern | dateString | options | result |
+| --- | --- | --- | --- |
+| keyword | keyword | named parameters | date |
+| keyword | keyword | | date |
+| keyword | text | | date |
+| text | keyword | | date |
+| text | text | | date |
 
diff --git a/docs/reference/query-languages/esql/images/functions/date_parse.svg b/docs/reference/query-languages/esql/images/functions/date_parse.svg
index 0f5e5f624143a..4a16582db66f8 100644
--- a/docs/reference/query-languages/esql/images/functions/date_parse.svg
+++ b/docs/reference/query-languages/esql/images/functions/date_parse.svg
@@ -1 +1 @@
-<svg version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" width="628" height="61" viewbox="0 0 628 61"><defs><style type="text/css">.c{fill:none;stroke:#222222;}.k{fill:#000000;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:20px;}.s{fill:#e4f4ff;stroke:#222222;}.syn{fill:#8D8D8D;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:20px;}</style></defs><path class="c" d="M0 31h5m140 0h10m32 0h30m152 0h10m32 0h20m-229 0q5 0 5 5v10q0 5 5 5h204q5 0 5-5v-10q0-5 5-5m5 0h10m140 0h10m32 0h5"/><rect class="s" x="5" y="5" width="140" height="36"/><text class="k" x="15" y="31">DATE_PARSE</text><rect class="s" x="155" y="5" width="32" height="36" rx="7"/><text class="syn" x="165" y="31">(</text><rect class="s" x="217" y="5" width="152" height="36" rx="7"/><text class="k" x="227" y="31">datePattern</text><rect class="s" x="379" y="5" width="32" height="36" rx="7"/><text class="syn" x="389" y="31">,</text><rect class="s" x="441" y="5" width="140" height="36" rx="7"/><text class="k" x="451" y="31">dateString</text><rect class="s" x="591" y="5" width="32" height="36" rx="7"/><text class="syn" x="601" y="31">)</text></svg>
\ No newline at end of file
+<svg version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" width="824" height="61" viewbox="0 0 824 61"><defs><style type="text/css">.c{fill:none;stroke:#222222;}.k{fill:#000000;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:20px;}.s{fill:#e4f4ff;stroke:#222222;}.syn{fill:#8D8D8D;font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:20px;}</style></defs><path class="c" d="M0 31h5m140 0h10m32 0h30m152 0h10m32 0h20m-229 0q5 0 5 5v10q0 5 5 5h204q5 0 5-5v-10q0-5 5-5m5 0h10m140 0h30m32 0h10m104 0h20m-181 0q5 0 5 5v10q0 5 5 5h156q5 0 5-5v-10q0-5 5-5m5 0h10m32 0h5"/><rect class="s" x="5" y="5" width="140" height="36"/><text class="k" x="15" y="31">DATE_PARSE</text><rect class="s" x="155" y="5" width="32" height="36" rx="7"/><text class="syn" x="165" y="31">(</text><rect class="s" x="217" y="5" width="152" height="36" rx="7"/><text class="k" x="227" y="31">datePattern</text><rect class="s" x="379" y="5" width="32" height="36" rx="7"/><text class="syn" x="389" y="31">,</text><rect class="s" x="441" y="5" width="140" height="36" rx="7"/><text class="k" x="451" y="31">dateString</text><rect class="s" x="611" y="5" width="32" height="36" rx="7"/><text class="syn" x="621" y="31">,</text><rect class="s" x="653" y="5" width="104" height="36" rx="7"/><text class="k" x="663" y="31">options</text><rect class="s" x="787" y="5" width="32" height="36" rx="7"/><text class="syn" x="797" y="31">)</text></svg>
\ No newline at end of file
diff --git a/docs/reference/query-languages/esql/kibana/definition/functions/date_parse.json b/docs/reference/query-languages/esql/kibana/definition/functions/date_parse.json
index 7c4b5c4ac9461..158060cfaf3db 100644
--- a/docs/reference/query-languages/esql/kibana/definition/functions/date_parse.json
+++ b/docs/reference/query-languages/esql/kibana/definition/functions/date_parse.json
@@ -22,6 +22,31 @@
       "variadic" : false,
       "returnType" : "date"
     },
+    {
+      "params" : [
+        {
+          "name" : "datePattern",
+          "type" : "keyword",
+          "optional" : true,
+          "description" : "The date format. Refer to the {javadoc14}/java.base/java/time/format/DateTimeFormatter.html[`DateTimeFormatter` documentation] for the syntax. If `null`, the function returns `null`."
+        },
+        {
+          "name" : "dateString",
+          "type" : "keyword",
+          "optional" : false,
+          "description" : "Date expression as a string. If `null` or an empty string, the function returns `null`."
+        },
+        {
+          "name" : "options",
+          "type" : "function_named_parameters",
+          "mapParams" : "{name='time_zone', values=[standard], description='Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.'}, {name='locale', values=[standard], description='The locale to use when parsing the date, relevant when parsing month names or week days.'}",
+          "optional" : true,
+          "description" : "(Optional) Additional options for date parsing, specifying time zone and locale as <<esql-function-named-params,function named parameters>>."
+        }
+      ],
+      "variadic" : false,
+      "returnType" : "date"
+    },
     {
       "params" : [
         {
diff --git a/x-pack/plugin/esql/qa/testFixtures/src/main/resources/date.csv-spec b/x-pack/plugin/esql/qa/testFixtures/src/main/resources/date.csv-spec
index e5efc9e7a37aa..8beef707706ca 100644
--- a/x-pack/plugin/esql/qa/testFixtures/src/main/resources/date.csv-spec
+++ b/x-pack/plugin/esql/qa/testFixtures/src/main/resources/date.csv-spec
@@ -644,6 +644,46 @@ emp_no:integer  | new_date:datetime          | birth_date:datetime       | bool:
 10050           | 1958-05-21T00:00:00.000Z   | 1958-05-21T00:00:00.000Z  | true
 ;
 
+evalDateParseWithTimezoneOption
+required_capability: date_parse_options
+row a = "10-10-2025" | eval b = date_parse("dd-mm-yyyy", a, {"time_zone":"Europe/Paris"}) | keep b;
+
+b:datetime
+2024-12-31T23:00:00.000Z
+;
+
+evalDateParseWithLocaleOption
+required_capability: date_parse_options
+row a = "10 septembre 2025" | eval b = date_parse("dd MMMM yyyy", a, {"locale":"fr"}) | keep b;
+
+b:datetime
+2025-09-10T00:00:00.000Z
+;
+
+evalDateParseWithLocaleAndTimezoneOption
+required_capability: date_parse_options
+row a = "10 septembre 2025" | eval b = date_parse("dd MMMM yyyy", a, {"locale":"fr","time_zone":"Europe/Paris"}) | keep b;
+
+b:datetime
+2025-09-09T22:00:00.000Z
+;
+
+evalDateParseDefaultFormatWithTimezoneOption
+required_capability: date_parse_options
+row a = "2023-02-01T12:15:55.000+01:00" | eval b = date_parse(a, {"time_zone":"Europe/Paris"}) | keep b;
+
+b:datetime
+2023-02-01T11:15:55.000Z
+;
+
+evalDateParseDefaultFormatWithLocaleOption
+required_capability: date_parse_options
+row a = "2023-02-01T12:15:55.000Z" | eval b = date_parse(a, {"locale":"fr"}) | keep b;
+
+b:datetime
+2023-02-01T12:15:55.000Z
+;
+
 dateFields
 from employees | where emp_no == 10049 or emp_no == 10050 
 | eval year = date_extract("year", birth_date), month = date_extract("month_of_year", birth_date), day = date_extract("day_of_month", birth_date)
diff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java
index e637481c7e058..f10061a14175b 100644
--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java
+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/action/EsqlCapabilities.java
@@ -1532,6 +1532,11 @@ public enum Cap {
          */
         FIX_FILTER_ORDINALS,
 
+        /**
+         * Optional options argument for DATE_PARSE
+         */
+        DATE_PARSE_OPTIONS,
+
         /**
          * Allow multiple patterns for GROK command
          */
diff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/EsqlFunctionRegistry.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/EsqlFunctionRegistry.java
index a44d7cb719a50..4214c3c49558d 100644
--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/EsqlFunctionRegistry.java
+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/EsqlFunctionRegistry.java
@@ -1042,12 +1042,20 @@ public interface BinaryBuilder<T> {
     protected static <T extends Function> FunctionDefinition def(Class<T> function, TernaryBuilder<T> ctorRef, String... names) {
         FunctionBuilder builder = (source, children, cfg) -> {
             boolean hasMinimumTwo = OptionalArgument.class.isAssignableFrom(function);
-            if (hasMinimumTwo && (children.size() > 3 || children.size() < 2)) {
+            boolean hasMinimumOne = TwoOptionalArguments.class.isAssignableFrom(function);
+            if (hasMinimumOne && (children.size() > 3 || children.isEmpty())) {
+                throw new QlIllegalArgumentException("expects one, two or three arguments");
+            } else if (hasMinimumTwo && (children.size() > 3 || children.size() < 2)) {
                 throw new QlIllegalArgumentException("expects two or three arguments");
-            } else if (hasMinimumTwo == false && children.size() != 3) {
+            } else if (hasMinimumOne == false && hasMinimumTwo == false && children.size() != 3) {
                 throw new QlIllegalArgumentException("expects exactly three arguments");
             }
-            return ctorRef.build(source, children.get(0), children.get(1), children.size() == 3 ? children.get(2) : null);
+            return ctorRef.build(
+                source,
+                children.get(0),
+                children.size() > 1 ? children.get(1) : null,
+                children.size() == 3 ? children.get(2) : null
+            );
         };
         return def(function, builder, names);
     }
diff --git a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParse.java b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParse.java
index ef1acbc395308..01b83a466aec4 100644
--- a/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParse.java
+++ b/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParse.java
@@ -12,41 +12,59 @@
 import org.elasticsearch.common.io.stream.StreamInput;
 import org.elasticsearch.common.io.stream.StreamOutput;
 import org.elasticsearch.common.time.DateFormatter;
+import org.elasticsearch.common.util.LocaleUtils;
 import org.elasticsearch.compute.ann.Evaluator;
 import org.elasticsearch.compute.ann.Fixed;
 import org.elasticsearch.compute.operator.EvalOperator.ExpressionEvaluator;
 import org.elasticsearch.xpack.esql.core.InvalidArgumentException;
 import org.elasticsearch.xpack.esql.core.expression.Expression;
+import org.elasticsearch.xpack.esql.core.expression.MapExpression;
 import org.elasticsearch.xpack.esql.core.tree.NodeInfo;
 import org.elasticsearch.xpack.esql.core.tree.Source;
 import org.elasticsearch.xpack.esql.core.type.DataType;
 import org.elasticsearch.xpack.esql.expression.function.Example;
 import org.elasticsearch.xpack.esql.expression.function.FunctionInfo;
-import org.elasticsearch.xpack.esql.expression.function.OptionalArgument;
+import org.elasticsearch.xpack.esql.expression.function.MapParam;
+import org.elasticsearch.xpack.esql.expression.function.Options;
 import org.elasticsearch.xpack.esql.expression.function.Param;
+import org.elasticsearch.xpack.esql.expression.function.TwoOptionalArguments;
 import org.elasticsearch.xpack.esql.expression.function.scalar.EsqlScalarFunction;
 import org.elasticsearch.xpack.esql.io.stream.PlanStreamInput;
 
 import java.io.IOException;
+import java.time.ZoneId;
+import java.time.zone.ZoneRulesException;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Locale;
+import java.util.Map;
 
+import static java.util.Map.entry;
 import static org.elasticsearch.common.time.DateFormatter.forPattern;
 import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.ParamOrdinal.FIRST;
 import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.ParamOrdinal.SECOND;
+import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.ParamOrdinal.THIRD;
+import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.isMapExpression;
 import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.isString;
+import static org.elasticsearch.xpack.esql.core.type.DataType.KEYWORD;
 import static org.elasticsearch.xpack.esql.expression.EsqlTypeResolutions.isStringAndExact;
 import static org.elasticsearch.xpack.esql.type.EsqlDataTypeConverter.DEFAULT_DATE_TIME_FORMATTER;
 import static org.elasticsearch.xpack.esql.type.EsqlDataTypeConverter.dateTimeToLong;
 
-public class DateParse extends EsqlScalarFunction implements OptionalArgument {
+public class DateParse extends EsqlScalarFunction implements TwoOptionalArguments {
     public static final NamedWriteableRegistry.Entry ENTRY = new NamedWriteableRegistry.Entry(
         Expression.class,
         "DateParse",
         DateParse::new
     );
 
-    private final Expression field;
-    private final Expression format;
+    private static final String TIME_ZONE_PARAM_NAME = "time_zone";
+    private static final String LOCALE_PARAM_NAME = "locale";
+
+    private final Expression first;
+    private final Expression second;
+    private final Expression third;
 
     @FunctionInfo(
         returnType = "date",
@@ -63,17 +81,80 @@ public DateParse(
             name = "dateString",
             type = { "keyword", "text" },
             description = "Date expression as a string. If `null` or an empty string, the function returns `null`."
-        ) Expression second
+        ) Expression second,
+        @MapParam(
+            name = "options",
+            params = {
+                @MapParam.MapParamEntry(
+                    name = TIME_ZONE_PARAM_NAME,
+                    type = "keyword",
+                    valueHint = { "standard" },
+                    description = "Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the "
+                        + "query string to UTC."
+                ),
+                @MapParam.MapParamEntry(
+                    name = LOCALE_PARAM_NAME,
+                    type = "keyword",
+                    valueHint = { "standard" },
+                    description = "The locale to use when parsing the date, relevant when parsing month names or week days."
+                ) },
+            description = "(Optional) Additional options for date parsing, specifying time zone and locale "
+                + "as <<esql-function-named-params,function named parameters>>.",
+            optional = true
+        ) Expression third
     ) {
-        super(source, second != null ? List.of(first, second) : List.of(first));
-        this.field = second != null ? second : first;
-        this.format = second != null ? first : null;
+        super(source, fields(first, second, third));
+        this.first = first;
+        this.second = second;
+        this.third = third;
+    }
+
+    private static List<Expression> fields(Expression first, Expression second, Expression third) {
+        List<Expression> list = new ArrayList<>(3);
+        list.add(first);
+        if (second != null) {
+            list.add(second);
+        }
+        if (third != null) {
+            list.add(third);
+        }
+        return list;
+    }
+
+    private Expression field() {
+        // If second is a MapExpression, then: first=date, second=options, third=null
+        // If second is not a MapExpression and second exists, then: first=pattern, second=date, third=options
+        // If only first exists, then: first=date, second=null, third=null
+        if (second instanceof MapExpression) {
+            return first;
+        }
+        return second != null ? second : first;
+    }
+
+    private Expression format() {
+        // If second is a MapExpression, then: first=date, second=options, third=null (no format)
+        // If second is not a MapExpression and second exists, then: first=pattern, second=date, third=options
+        // If only first exists, then: first=date, second=null, third=null (no format)
+        if (second instanceof MapExpression || second == null) {
+            return null;
+        }
+        return first;
+    }
+
+    private Expression options() {
+        // If second is a MapExpression, then: first=date, second=options, third=null
+        // If second is not a MapExpression and third exists, then: first=pattern, second=date, third=options
+        if (second instanceof MapExpression) {
+            return second;
+        }
+        return third;
     }
 
     private DateParse(StreamInput in) throws IOException {
         this(
             Source.readFrom((PlanStreamInput) in),
             in.readNamedWriteable(Expression.class),
+            in.readOptionalNamedWriteable(Expression.class),
             in.readOptionalNamedWriteable(Expression.class)
         );
     }
@@ -82,7 +163,8 @@ private DateParse(StreamInput in) throws IOException {
     public void writeTo(StreamOutput out) throws IOException {
         source().writeTo(out);
         out.writeNamedWriteable(children().get(0));
-        out.writeOptionalNamedWriteable(children().size() == 2 ? children().get(1) : null);
+        out.writeOptionalNamedWriteable(children().size() > 1 ? children().get(1) : null);
+        out.writeOptionalNamedWriteable(children().size() > 2 ? children().get(2) : null);
     }
 
     @Override
@@ -102,6 +184,7 @@ protected TypeResolution resolveType() {
         }
 
         TypeResolution resolution;
+        Expression format = format();
         if (format != null) {
             resolution = isStringAndExact(format, sourceText(), FIRST);
             if (resolution.unresolved()) {
@@ -109,16 +192,28 @@ protected TypeResolution resolveType() {
             }
         }
 
+        Expression field = field();
         resolution = isString(field, sourceText(), format != null ? SECOND : FIRST);
         if (resolution.unresolved()) {
             return resolution;
         }
 
+        // Validate options parameter if present
+        Expression options = options();
+        if (options != null) {
+            resolution = isMapExpression(options, sourceText(), THIRD);
+            if (resolution.unresolved()) {
+                return resolution;
+            }
+        }
+
         return TypeResolution.TYPE_RESOLVED;
     }
 
     @Override
     public boolean foldable() {
+        Expression field = field();
+        Expression format = format();
         return field.foldable() && (format == null || format.foldable());
     }
 
@@ -132,8 +227,26 @@ static long process(BytesRef val, BytesRef formatter) throws IllegalArgumentExce
         return dateTimeToLong(val.utf8ToString(), toFormatter(formatter));
     }
 
+    public static final Map<String, DataType> ALLOWED_OPTIONS = Map.ofEntries(
+        entry(TIME_ZONE_PARAM_NAME, KEYWORD),
+        entry(LOCALE_PARAM_NAME, KEYWORD)
+    );
+
+    private Map<String, Object> parseOptions() throws InvalidArgumentException {
+        Map<String, Object> matchOptions = new HashMap<>();
+        Expression options = options();
+        if (options == null) {
+            return matchOptions;
+        }
+
+        Options.populateMap((MapExpression) options, matchOptions, source(), THIRD, ALLOWED_OPTIONS);
+        return matchOptions;
+    }
+
     @Override
     public ExpressionEvaluator.Factory toEvaluator(ToEvaluator toEvaluator) {
+        Expression field = field();
+        Expression format = format();
         ExpressionEvaluator.Factory fieldEvaluator = toEvaluator.apply(field);
         if (format == null) {
             return new DateParseConstantEvaluator.Factory(source(), fieldEvaluator, DEFAULT_DATE_TIME_FORMATTER);
@@ -141,9 +254,29 @@ public ExpressionEvaluator.Factory toEvaluator(ToEvaluator toEvaluator) {
         if (DataType.isString(format.dataType()) == false) {
             throw new IllegalArgumentException("unsupported data type for date_parse [" + format.dataType() + "]");
         }
+        var parsedOptions = this.parseOptions();
+        String localeAsString = (String) parsedOptions.get(LOCALE_PARAM_NAME);
+        Locale locale = localeAsString == null ? null : LocaleUtils.parse(localeAsString);
+
+        String timezoneAsString = (String) parsedOptions.get(TIME_ZONE_PARAM_NAME);
+        ZoneId timezone = null;
+        try {
+            if (timezoneAsString != null) {
+                timezone = ZoneId.of(timezoneAsString);
+            }
+        } catch (ZoneRulesException e) {
+            throw new IllegalArgumentException("unsupported timezone [" + timezoneAsString + "]");
+        }
+
         if (format.foldable()) {
             try {
                 DateFormatter formatter = toFormatter(format.fold(toEvaluator.foldCtx()));
+                if (locale != null) {
+                    formatter = formatter.withLocale(locale);
+                }
+                if (timezone != null) {
+                    formatter = formatter.withZone(timezone);
+                }
                 return new DateParseConstantEvaluator.Factory(source(), fieldEvaluator, formatter);
             } catch (IllegalArgumentException e) {
                 throw new InvalidArgumentException(e, "invalid date pattern for [{}]: {}", sourceText(), e.getMessage());
@@ -159,13 +292,21 @@ private static DateFormatter toFormatter(Object format) {
 
     @Override
     public Expression replaceChildren(List<Expression> newChildren) {
-        return new DateParse(source(), newChildren.get(0), newChildren.size() > 1 ? newChildren.get(1) : null);
+        return new DateParse(
+            source(),
+            newChildren.get(0),
+            newChildren.size() > 1 ? newChildren.get(1) : null,
+            newChildren.size() > 2 ? newChildren.get(2) : null
+        );
     }
 
     @Override
     protected NodeInfo<? extends Expression> info() {
+        Expression format = format();
+        Expression field = field();
+        Expression options = options();
         Expression first = format != null ? format : field;
         Expression second = format != null ? field : null;
-        return NodeInfo.create(this, DateParse::new, first, second);
+        return NodeInfo.create(this, DateParse::new, first, second, options);
     }
 }
diff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseErrorTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseErrorTests.java
index 21d9b5fb00537..9d8642b63aa13 100644
--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseErrorTests.java
+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseErrorTests.java
@@ -15,8 +15,10 @@
 import org.hamcrest.Matcher;
 
 import java.util.List;
+import java.util.Locale;
 import java.util.Set;
 
+import static org.elasticsearch.xpack.esql.core.expression.TypeResolutions.ParamOrdinal;
 import static org.hamcrest.Matchers.equalTo;
 
 public class DateParseErrorTests extends ErrorsForCasesWithoutExamplesTestCase {
@@ -27,11 +29,28 @@ protected List<TestCaseSupplier> cases() {
 
     @Override
     protected Expression build(Source source, List<Expression> args) {
-        return new DateParse(source, args.get(0), args.size() > 1 ? args.get(1) : null);
+        return new DateParse(source, args.get(0), args.size() > 1 ? args.get(1) : null, args.size() > 2 ? args.get(2) : null);
     }
 
     @Override
     protected Matcher<String> expectedTypeErrorMatcher(List<Set<DataType>> validPerPosition, List<DataType> signature) {
+        // Need custom matchers for the MapExpression case
+        if (signature.size() == 3 && validPerPosition.size() >= 3) {
+            boolean firstParamValid = validPerPosition.get(0).isEmpty() == false
+                && (signature.get(0) == null || validPerPosition.get(0).contains(signature.get(0)));
+            boolean secondParamValid = validPerPosition.get(1).isEmpty() == false
+                && (signature.get(1) == null || validPerPosition.get(1).contains(signature.get(1)));
+
+            boolean thirdParamInvalid = validPerPosition.get(2).isEmpty()
+                || signature.get(2) == DataType.NULL
+                || (validPerPosition.get(2).contains(signature.get(2)) == false && signature.get(2) != null);
+
+            if (firstParamValid && secondParamValid && thirdParamInvalid) {
+                String ordinal = ParamOrdinal.THIRD.name().toLowerCase(Locale.ROOT);
+                return equalTo(ordinal + " argument of [" + sourceForSignature(signature) + "] must be a map expression, received []");
+            }
+        }
+
         return equalTo(typeErrorMessage(true, validPerPosition, signature, (v, i) -> "string"));
     }
 }
diff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseSerializationTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseSerializationTests.java
index 79a650c8dd963..8ed72c12bd115 100644
--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseSerializationTests.java
+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseSerializationTests.java
@@ -19,19 +19,21 @@ protected DateParse createTestInstance() {
         Source source = randomSource();
         Expression first = randomChild();
         Expression second = randomBoolean() ? null : randomChild();
-        return new DateParse(source, first, second);
+        Expression third = randomBoolean() ? randomChild() : null;
+        return new DateParse(source, first, second, third);
     }
 
     @Override
     protected DateParse mutateInstance(DateParse instance) throws IOException {
         Source source = instance.source();
         Expression first = instance.children().get(0);
-        Expression second = instance.children().size() == 1 ? null : instance.children().get(1);
-        if (randomBoolean()) {
-            first = randomValueOtherThan(first, AbstractExpressionSerializationTests::randomChild);
-        } else {
-            second = randomValueOtherThan(second, () -> randomBoolean() ? null : randomChild());
+        Expression second = instance.children().size() > 1 ? instance.children().get(1) : null;
+        Expression third = instance.children().size() > 2 ? instance.children().get(2) : null;
+        switch (between(0, 2)) {
+            case 0 -> first = randomValueOtherThan(first, AbstractExpressionSerializationTests::randomChild);
+            case 1 -> second = randomValueOtherThan(second, () -> randomBoolean() ? null : randomChild());
+            case 2 -> third = randomValueOtherThan(third, () -> randomBoolean() ? null : randomChild());
         }
-        return new DateParse(source, first, second);
+        return new DateParse(source, first, second, third);
     }
 }
diff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseTests.java
index e2e379c3f3cf7..6aded21e11a98 100644
--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseTests.java
+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/scalar/date/DateParseTests.java
@@ -15,11 +15,13 @@
 import org.elasticsearch.xpack.esql.core.InvalidArgumentException;
 import org.elasticsearch.xpack.esql.core.expression.Expression;
 import org.elasticsearch.xpack.esql.core.expression.Literal;
+import org.elasticsearch.xpack.esql.core.expression.MapExpression;
 import org.elasticsearch.xpack.esql.core.tree.Source;
 import org.elasticsearch.xpack.esql.core.type.DataType;
 import org.elasticsearch.xpack.esql.expression.function.AbstractScalarFunctionTestCase;
 import org.elasticsearch.xpack.esql.expression.function.TestCaseSupplier;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
 import java.util.function.Supplier;
@@ -36,115 +38,148 @@ public DateParseTests(@Name("TestCase") Supplier<TestCaseSupplier.TestCase> test
 
     @ParametersFactory
     public static Iterable<Object[]> parameters() {
-        return parameterSuppliersFromTypedDataWithDefaultChecks(
-            true,
-            List.of(
-                new TestCaseSupplier(
-                    "Basic Case",
-                    List.of(DataType.KEYWORD, DataType.KEYWORD),
-                    () -> new TestCaseSupplier.TestCase(
-                        List.of(
-                            new TestCaseSupplier.TypedData(new BytesRef("yyyy-MM-dd"), DataType.KEYWORD, "first"),
-                            new TestCaseSupplier.TypedData(new BytesRef("2023-05-05"), DataType.KEYWORD, "second")
-                        ),
-                        "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
-                        DataType.DATETIME,
-                        equalTo(1683244800000L)
-                    )
-                ),
-                new TestCaseSupplier("Timezoned Case", List.of(DataType.KEYWORD, DataType.KEYWORD), () -> {
-                    long ts_sec = 1657585450L; // 2022-07-12T00:24:10Z
-                    int hours = randomIntBetween(0, 23);
-                    String date = String.format(Locale.ROOT, "12/Jul/2022:%02d:24:10 +0900", hours);
-                    long expected_ts = (ts_sec + (hours - 9) * 3600L) * 1000L;
-                    return new TestCaseSupplier.TestCase(
-                        List.of(
-                            new TestCaseSupplier.TypedData(new BytesRef("dd/MMM/yyyy:HH:mm:ss Z"), DataType.KEYWORD, "first"),
-                            new TestCaseSupplier.TypedData(new BytesRef(date), DataType.KEYWORD, "second")
-                        ),
-                        "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
-                        DataType.DATETIME,
-                        equalTo(expected_ts)
-                    );
-                }),
-                new TestCaseSupplier(
-                    "With Text",
-                    List.of(DataType.KEYWORD, DataType.TEXT),
-                    () -> new TestCaseSupplier.TestCase(
-                        List.of(
-                            new TestCaseSupplier.TypedData(new BytesRef("yyyy-MM-dd"), DataType.KEYWORD, "first"),
-                            new TestCaseSupplier.TypedData(new BytesRef("2023-05-05"), DataType.TEXT, "second")
-                        ),
-                        "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
-                        DataType.DATETIME,
-                        equalTo(1683244800000L)
-                    )
-                ),
-                new TestCaseSupplier(
-                    "With Both Text",
-                    List.of(DataType.TEXT, DataType.TEXT),
-                    () -> new TestCaseSupplier.TestCase(
-                        List.of(
-                            new TestCaseSupplier.TypedData(new BytesRef("yyyy-MM-dd"), DataType.TEXT, "first"),
-                            new TestCaseSupplier.TypedData(new BytesRef("2023-05-05"), DataType.TEXT, "second")
-                        ),
-                        "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
-                        DataType.DATETIME,
-                        equalTo(1683244800000L)
-                    )
-                ),
-                new TestCaseSupplier(
-                    "With keyword",
-                    List.of(DataType.TEXT, DataType.KEYWORD),
-                    () -> new TestCaseSupplier.TestCase(
-                        List.of(
-                            new TestCaseSupplier.TypedData(new BytesRef("yyyy-MM-dd"), DataType.TEXT, "first"),
-                            new TestCaseSupplier.TypedData(new BytesRef("2023-05-05"), DataType.KEYWORD, "second")
-                        ),
-                        "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
-                        DataType.DATETIME,
-                        equalTo(1683244800000L)
-                    )
+        List<TestCaseSupplier> cases = new ArrayList<>();
+        cases.add(
+            new TestCaseSupplier(
+                "Basic Case",
+                List.of(DataType.KEYWORD, DataType.KEYWORD),
+                () -> new TestCaseSupplier.TestCase(
+                    List.of(
+                        new TestCaseSupplier.TypedData(new BytesRef("yyyy-MM-dd"), DataType.KEYWORD, "first"),
+                        new TestCaseSupplier.TypedData(new BytesRef("2023-05-05"), DataType.KEYWORD, "second")
+                    ),
+                    "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
+                    DataType.DATETIME,
+                    equalTo(1683244800000L)
+                )
+            )
+        );
+        cases.add(new TestCaseSupplier("Timezoned Case", List.of(DataType.KEYWORD, DataType.KEYWORD), () -> {
+            long ts_sec = 1657585450L; // 2022-07-12T00:24:10Z
+            int hours = randomIntBetween(0, 23);
+            String date = String.format(Locale.ROOT, "12/Jul/2022:%02d:24:10 +0900", hours);
+            long expected_ts = (ts_sec + (hours - 9) * 3600L) * 1000L;
+            return new TestCaseSupplier.TestCase(
+                List.of(
+                    new TestCaseSupplier.TypedData(new BytesRef("dd/MMM/yyyy:HH:mm:ss Z"), DataType.KEYWORD, "first"),
+                    new TestCaseSupplier.TypedData(new BytesRef(date), DataType.KEYWORD, "second")
                 ),
-                new TestCaseSupplier(
-                    List.of(DataType.KEYWORD, DataType.KEYWORD),
-                    () -> new TestCaseSupplier.TestCase(
-                        List.of(
-                            new TestCaseSupplier.TypedData(new BytesRef("not a format"), DataType.KEYWORD, "first"),
-                            new TestCaseSupplier.TypedData(new BytesRef("2023-05-05"), DataType.KEYWORD, "second")
+                "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
+                DataType.DATETIME,
+                equalTo(expected_ts)
+            );
+        }));
+        cases.add(
+            new TestCaseSupplier(
+                "With Text",
+                List.of(DataType.KEYWORD, DataType.TEXT),
+                () -> new TestCaseSupplier.TestCase(
+                    List.of(
+                        new TestCaseSupplier.TypedData(new BytesRef("yyyy-MM-dd"), DataType.KEYWORD, "first"),
+                        new TestCaseSupplier.TypedData(new BytesRef("2023-05-05"), DataType.TEXT, "second")
+                    ),
+                    "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
+                    DataType.DATETIME,
+                    equalTo(1683244800000L)
+                )
+            )
+        );
+        cases.add(
+            new TestCaseSupplier(
+                "With Both Text",
+                List.of(DataType.TEXT, DataType.TEXT),
+                () -> new TestCaseSupplier.TestCase(
+                    List.of(
+                        new TestCaseSupplier.TypedData(new BytesRef("yyyy-MM-dd"), DataType.TEXT, "first"),
+                        new TestCaseSupplier.TypedData(new BytesRef("2023-05-05"), DataType.TEXT, "second")
+                    ),
+                    "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
+                    DataType.DATETIME,
+                    equalTo(1683244800000L)
+                )
+            )
+        );
+        cases.add(
+            new TestCaseSupplier(
+                "With keyword",
+                List.of(DataType.TEXT, DataType.KEYWORD),
+                () -> new TestCaseSupplier.TestCase(
+                    List.of(
+                        new TestCaseSupplier.TypedData(new BytesRef("yyyy-MM-dd"), DataType.TEXT, "first"),
+                        new TestCaseSupplier.TypedData(new BytesRef("2023-05-05"), DataType.KEYWORD, "second")
+                    ),
+                    "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
+                    DataType.DATETIME,
+                    equalTo(1683244800000L)
+                )
+            )
+        );
+        cases.add(
+            new TestCaseSupplier(
+                List.of(DataType.KEYWORD, DataType.KEYWORD),
+                () -> new TestCaseSupplier.TestCase(
+                    List.of(
+                        new TestCaseSupplier.TypedData(new BytesRef("not a format"), DataType.KEYWORD, "first"),
+                        new TestCaseSupplier.TypedData(new BytesRef("2023-05-05"), DataType.KEYWORD, "second")
 
-                        ),
-                        "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
-                        DataType.DATETIME,
-                        is(nullValue())
-                    ).withWarning("Line 1:1: evaluation of [source] failed, treating result as null. Only first 20 failures recorded.")
-                        .withWarning(
-                            "Line 1:1: java.lang.IllegalArgumentException: Invalid format: [not a format]: Unknown pattern letter: o"
-                        )
-                        .withFoldingException(
-                            InvalidArgumentException.class,
-                            "invalid date pattern for [source]: Invalid format: [not a format]: Unknown pattern letter: o"
-                        )
-                ),
-                new TestCaseSupplier(
-                    List.of(DataType.KEYWORD, DataType.KEYWORD),
-                    () -> new TestCaseSupplier.TestCase(
-                        List.of(
-                            new TestCaseSupplier.TypedData(new BytesRef("yyyy-MM-dd"), DataType.KEYWORD, "first"),
-                            new TestCaseSupplier.TypedData(new BytesRef("not a date"), DataType.KEYWORD, "second")
+                    ),
+                    "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
+                    DataType.DATETIME,
+                    is(nullValue())
+                ).withWarning("Line 1:1: evaluation of [source] failed, treating result as null. Only first 20 failures recorded.")
+                    .withWarning("Line 1:1: java.lang.IllegalArgumentException: Invalid format: [not a format]: Unknown pattern letter: o")
+                    .withFoldingException(
+                        InvalidArgumentException.class,
+                        "invalid date pattern for [source]: Invalid format: [not a format]: Unknown pattern letter: o"
+                    )
+            )
+        );
+        cases.add(
+            new TestCaseSupplier(
+                List.of(DataType.KEYWORD, DataType.KEYWORD),
+                () -> new TestCaseSupplier.TestCase(
+                    List.of(
+                        new TestCaseSupplier.TypedData(new BytesRef("yyyy-MM-dd"), DataType.KEYWORD, "first"),
+                        new TestCaseSupplier.TypedData(new BytesRef("not a date"), DataType.KEYWORD, "second")
 
-                        ),
-                        "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
-                        DataType.DATETIME,
-                        is(nullValue())
-                    ).withWarning("Line 1:1: evaluation of [source] failed, treating result as null. Only first 20 failures recorded.")
-                        .withWarning(
-                            "Line 1:1: java.lang.IllegalArgumentException: "
-                                + "failed to parse date field [not a date] with format [yyyy-MM-dd]"
-                        )
+                    ),
+                    "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
+                    DataType.DATETIME,
+                    is(nullValue())
+                ).withWarning("Line 1:1: evaluation of [source] failed, treating result as null. Only first 20 failures recorded.")
+                    .withWarning(
+                        "Line 1:1: java.lang.IllegalArgumentException: "
+                            + "failed to parse date field [not a date] with format [yyyy-MM-dd]"
+                    )
+            )
+        );
+        cases = anyNullIsNull(true, cases);
+        cases.add(
+            new TestCaseSupplier(
+                List.of(DataType.KEYWORD, DataType.KEYWORD, DataType.OBJECT),
+                () -> new TestCaseSupplier.TestCase(
+                    List.of(
+                        new TestCaseSupplier.TypedData(new BytesRef("yyyy-MM-dd"), DataType.KEYWORD, "pattern"),
+                        new TestCaseSupplier.TypedData(new BytesRef("2023-05-05"), DataType.KEYWORD, "date"),
+                        new TestCaseSupplier.TypedData(
+                            new MapExpression(
+                                Source.EMPTY,
+                                List.of(
+                                    new Literal(Source.EMPTY, new BytesRef("time_zone"), DataType.KEYWORD),
+                                    new Literal(Source.EMPTY, new BytesRef("UTC"), DataType.KEYWORD)
+                                )
+                            ),
+                            DataType.OBJECT,
+                            "options"
+                        ).forceLiteral()
+                    ),
+                    "DateParseEvaluator[val=Attribute[channel=1], formatter=Attribute[channel=0]]",
+                    DataType.DATETIME,
+                    equalTo(1683244800000L)
                 )
             )
         );
+        return parameterSuppliersFromTypedData(randomizeBytesRefsOffset(cases));
     }
 
     public void testInvalidPattern() {
@@ -156,15 +191,64 @@ public void testInvalidPattern() {
                 new DateParse(
                     Source.EMPTY,
                     new Literal(Source.EMPTY, new BytesRef(pattern), DataType.KEYWORD),
-                    field("str", DataType.KEYWORD)
+                    field("str", DataType.KEYWORD),
+                    null
                 )
             ).get(driverContext)
         );
         assertThat(e.getMessage(), startsWith("invalid date pattern for []: Invalid format: [" + pattern + "]"));
     }
 
+    public void testInvalidLocale() {
+        String pattern = "YYYY";
+        String locale = "nonexistinglocale";
+        DriverContext driverContext = driverContext();
+        IllegalArgumentException e = expectThrows(
+            IllegalArgumentException.class,
+            () -> evaluator(
+                new DateParse(
+                    Source.EMPTY,
+                    new Literal(Source.EMPTY, new BytesRef(pattern), DataType.KEYWORD),
+                    field("str", DataType.KEYWORD),
+                    new MapExpression(
+                        Source.EMPTY,
+                        List.of(
+                            new Literal(Source.EMPTY, new BytesRef("locale"), DataType.KEYWORD),
+                            new Literal(Source.EMPTY, new BytesRef(locale), DataType.KEYWORD)
+                        )
+                    )
+                )
+            ).get(driverContext)
+        );
+        assertThat(e.getMessage(), startsWith("Unknown language: " + locale));
+    }
+
+    public void testInvalidTimezone() {
+        String pattern = "YYYY";
+        String timezone = "NON-EXISTING-TIMEZONE";
+        DriverContext driverContext = driverContext();
+        IllegalArgumentException e = expectThrows(
+            IllegalArgumentException.class,
+            () -> evaluator(
+                new DateParse(
+                    Source.EMPTY,
+                    new Literal(Source.EMPTY, new BytesRef(pattern), DataType.KEYWORD),
+                    field("str", DataType.KEYWORD),
+                    new MapExpression(
+                        Source.EMPTY,
+                        List.of(
+                            new Literal(Source.EMPTY, new BytesRef("time_zone"), DataType.KEYWORD),
+                            new Literal(Source.EMPTY, new BytesRef(timezone), DataType.KEYWORD)
+                        )
+                    )
+                )
+            ).get(driverContext)
+        );
+        assertThat(e.getMessage(), startsWith("unsupported timezone [" + timezone + "]"));
+    }
+
     @Override
     protected Expression build(Source source, List<Expression> args) {
-        return new DateParse(source, args.get(0), args.size() > 1 ? args.get(1) : null);
+        return new DateParse(source, args.get(0), args.size() > 1 ? args.get(1) : null, args.size() == 3 ? args.get(2) : null);
     }
 }
diff --git a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/FoldNullTests.java b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/FoldNullTests.java
index ae30dce97ce5a..e45782dcf80ee 100644
--- a/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/FoldNullTests.java
+++ b/x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/optimizer/rules/logical/FoldNullTests.java
@@ -97,7 +97,7 @@ public void testBasicNullFolding() {
         assertNullLiteral(foldNull(new Round(EMPTY, Literal.NULL, null)));
         assertNullLiteral(foldNull(new Pow(EMPTY, Literal.NULL, Literal.NULL)));
         assertNullLiteral(foldNull(new DateFormat(EMPTY, Literal.NULL, Literal.NULL, null)));
-        assertNullLiteral(foldNull(new DateParse(EMPTY, Literal.NULL, Literal.NULL)));
+        assertNullLiteral(foldNull(new DateParse(EMPTY, Literal.NULL, Literal.NULL, NULL)));
         assertNullLiteral(foldNull(new DateTrunc(EMPTY, Literal.NULL, Literal.NULL)));
         assertNullLiteral(foldNull(new Substring(EMPTY, Literal.NULL, Literal.NULL, Literal.NULL)));
     }
