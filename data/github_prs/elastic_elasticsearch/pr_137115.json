{
  "id": 137115,
  "repository": "elastic/elasticsearch",
  "title": "[9.1] Catch exceptions from mapperService in StoreRecovery.recoverFromLocalShards (#137077)",
  "body": "Backports the following commits to 9.1:\n - Catch exceptions from mapperService in StoreRecovery.recoverFromLocalShards (#137077)",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-24T16:38:36+00:00",
  "created_at": "2025-10-24T15:33:11+00:00",
  "updated_at": "2025-10-24T16:38:59+00:00",
  "author": "bcully",
  "reviewers": [],
  "base_sha": "a63775296faf3b8d4307f766c1f75c90dd6e8c86",
  "head_sha": "d784c973c81dc80b36fd31c8e2891b4602ce5450",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "docs/changelog/137077.yaml",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "patch": "@@ -0,0 +1,5 @@\n+pr: 137077\n+summary: Catch exceptions from `mapperService` in `StoreRecovery.recoverFromLocalShards`\n+area: Recovery\n+type: bug\n+issues: []"
    },
    {
      "filename": "server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java",
      "status": "modified",
      "additions": 8,
      "deletions": 7,
      "changes": 15,
      "patch": "@@ -128,15 +128,16 @@ void recoverFromLocalShards(\n                 mappingUpdateConsumer.accept(sourceMetadata.mapping(), mappingStep);\n             }\n             mappingStep.addListener(outerListener.delegateFailure((listener, ignored) -> {\n-                indexShard.mapperService().merge(sourceMetadata, MapperService.MergeReason.MAPPING_RECOVERY);\n-                // now that the mapping is merged we can validate the index sort configuration.\n-                Sort indexSort = indexShard.getIndexSort();\n-                final boolean hasNested = indexShard.mapperService().hasNested();\n-                final boolean isSplit = sourceMetadata.getNumberOfShards() < indexShard.indexSettings().getNumberOfShards();\n-\n                 final var recoveryListener = recoveryListener(indexShard, listener);\n-                logger.debug(\"starting recovery from local shards {}\", shards);\n+\n                 try {\n+                    indexShard.mapperService().merge(sourceMetadata, MapperService.MergeReason.MAPPING_RECOVERY);\n+                    // now that the mapping is merged we can validate the index sort configuration.\n+                    Sort indexSort = indexShard.getIndexSort();\n+                    final boolean hasNested = indexShard.mapperService().hasNested();\n+                    final boolean isSplit = sourceMetadata.getNumberOfShards() < indexShard.indexSettings().getNumberOfShards();\n+\n+                    logger.debug(\"starting recovery from local shards {}\", shards);\n                     final Directory directory = indexShard.store().directory(); // don't close this directory!!\n                     final Directory[] sources = shards.stream().map(LocalShardSnapshot::getSnapshotDirectory).toArray(Directory[]::new);\n                     final long maxSeqNo = shards.stream().mapToLong(LocalShardSnapshot::maxSeqNo).max().getAsLong();"
    },
    {
      "filename": "server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "patch": "@@ -209,6 +209,8 @@\n import static org.hamcrest.Matchers.nullValue;\n import static org.hamcrest.Matchers.oneOf;\n import static org.hamcrest.Matchers.sameInstance;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.spy;\n \n /**\n  * Simple unit-test IndexShard related operations.\n@@ -3395,6 +3397,14 @@ public void testRecoverFromLocalShard() throws IOException {\n             });\n             closeShards(differentIndex);\n \n+            // check that an error from the mapper service is handled correctly\n+            final PlainActionFuture<Boolean> badMapperFuture = new PlainActionFuture<>();\n+            final IndexShard badMapper = spy(targetShard);\n+            doThrow(IllegalArgumentException.class).when(badMapper).mapperService();\n+            final BiConsumer<MappingMetadata, ActionListener<Void>> noopConsumer = (mapping, listener) -> listener.onResponse(null);\n+            badMapper.recoverFromLocalShards(noopConsumer, List.of(sourceShard), badMapperFuture);\n+            assertThrows(IndexShardRecoveryException.class, badMapperFuture::actionGet);\n+\n             final PlainActionFuture<Boolean> future = new PlainActionFuture<>();\n             targetShard.recoverFromLocalShards(mappingConsumer, Arrays.asList(sourceShard), future);\n             assertTrue(future.actionGet());"
    }
  ],
  "diff": "diff --git a/docs/changelog/137077.yaml b/docs/changelog/137077.yaml\nnew file mode 100644\nindex 0000000000000..fed7a6d1975d3\n--- /dev/null\n+++ b/docs/changelog/137077.yaml\n@@ -0,0 +1,5 @@\n+pr: 137077\n+summary: Catch exceptions from `mapperService` in `StoreRecovery.recoverFromLocalShards`\n+area: Recovery\n+type: bug\n+issues: []\ndiff --git a/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\nindex 290d0e98ef632..c003660f36e46 100644\n--- a/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\n+++ b/server/src/main/java/org/elasticsearch/index/shard/StoreRecovery.java\n@@ -128,15 +128,16 @@ void recoverFromLocalShards(\n                 mappingUpdateConsumer.accept(sourceMetadata.mapping(), mappingStep);\n             }\n             mappingStep.addListener(outerListener.delegateFailure((listener, ignored) -> {\n-                indexShard.mapperService().merge(sourceMetadata, MapperService.MergeReason.MAPPING_RECOVERY);\n-                // now that the mapping is merged we can validate the index sort configuration.\n-                Sort indexSort = indexShard.getIndexSort();\n-                final boolean hasNested = indexShard.mapperService().hasNested();\n-                final boolean isSplit = sourceMetadata.getNumberOfShards() < indexShard.indexSettings().getNumberOfShards();\n-\n                 final var recoveryListener = recoveryListener(indexShard, listener);\n-                logger.debug(\"starting recovery from local shards {}\", shards);\n+\n                 try {\n+                    indexShard.mapperService().merge(sourceMetadata, MapperService.MergeReason.MAPPING_RECOVERY);\n+                    // now that the mapping is merged we can validate the index sort configuration.\n+                    Sort indexSort = indexShard.getIndexSort();\n+                    final boolean hasNested = indexShard.mapperService().hasNested();\n+                    final boolean isSplit = sourceMetadata.getNumberOfShards() < indexShard.indexSettings().getNumberOfShards();\n+\n+                    logger.debug(\"starting recovery from local shards {}\", shards);\n                     final Directory directory = indexShard.store().directory(); // don't close this directory!!\n                     final Directory[] sources = shards.stream().map(LocalShardSnapshot::getSnapshotDirectory).toArray(Directory[]::new);\n                     final long maxSeqNo = shards.stream().mapToLong(LocalShardSnapshot::maxSeqNo).max().getAsLong();\ndiff --git a/server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java b/server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java\nindex cc682901876b6..17c406c254d6d 100644\n--- a/server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java\n+++ b/server/src/test/java/org/elasticsearch/index/shard/IndexShardTests.java\n@@ -209,6 +209,8 @@\n import static org.hamcrest.Matchers.nullValue;\n import static org.hamcrest.Matchers.oneOf;\n import static org.hamcrest.Matchers.sameInstance;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.spy;\n \n /**\n  * Simple unit-test IndexShard related operations.\n@@ -3395,6 +3397,14 @@ public void testRecoverFromLocalShard() throws IOException {\n             });\n             closeShards(differentIndex);\n \n+            // check that an error from the mapper service is handled correctly\n+            final PlainActionFuture<Boolean> badMapperFuture = new PlainActionFuture<>();\n+            final IndexShard badMapper = spy(targetShard);\n+            doThrow(IllegalArgumentException.class).when(badMapper).mapperService();\n+            final BiConsumer<MappingMetadata, ActionListener<Void>> noopConsumer = (mapping, listener) -> listener.onResponse(null);\n+            badMapper.recoverFromLocalShards(noopConsumer, List.of(sourceShard), badMapperFuture);\n+            assertThrows(IndexShardRecoveryException.class, badMapperFuture::actionGet);\n+\n             final PlainActionFuture<Boolean> future = new PlainActionFuture<>();\n             targetShard.recoverFromLocalShards(mappingConsumer, Arrays.asList(sourceShard), future);\n             assertTrue(future.actionGet());\n",
  "additions": 23,
  "deletions": 7,
  "changed_files": 3,
  "url": "https://github.com/elastic/elasticsearch/pull/137115",
  "mined_at": "2025-10-25T13:16:03.346312"
}