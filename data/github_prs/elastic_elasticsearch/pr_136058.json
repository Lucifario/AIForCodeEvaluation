{
  "id": 136058,
  "repository": "elastic/elasticsearch",
  "title": "Configurable HTTP read and connect timeouts for url based SAML metadata resolution",
  "body": "Adds two new http timeout properties for the SAML realm.",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-20T17:59:08+00:00",
  "created_at": "2025-10-06T20:46:30+00:00",
  "updated_at": "2025-10-23T16:12:43+00:00",
  "author": "ankit--sethi",
  "reviewers": [
    "slobodanadamovic"
  ],
  "base_sha": "4b89f225bc330e228d2ea38baf5da1978325bc40",
  "head_sha": "ffb4148b2b889465f7df515c21b554bc07c05ead",
  "review_comments": [
    {
      "user": "slobodanadamovic",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-09T15:07:42+00:00"
    },
    {
      "user": "slobodanadamovic",
      "state": "COMMENTED",
      "body": "I reviewed the production changes and they look good to me üëç \nI haven't got a chance yet to review the tests.\n",
      "submitted_at": "2025-10-15T15:55:38+00:00"
    },
    {
      "user": "slobodanadamovic",
      "state": "APPROVED",
      "body": "LGTM üëç ",
      "submitted_at": "2025-10-17T11:55:56+00:00"
    }
  ],
  "pr_comments": [
    {
      "user": "elasticsearchmachine",
      "body": "Hi @ankit--sethi, I've created a changelog YAML for you.",
      "created_at": "2025-10-07T14:51:59+00:00"
    },
    {
      "user": "elasticsearchmachine",
      "body": "Pinging @elastic/es-security (Team:Security)",
      "created_at": "2025-10-07T14:51:59+00:00"
    },
    {
      "user": "slobodanadamovic",
      "body": "Mentioning here so it doesn't get forgotten. As a followup, we'll need to update the docs and document the new settings.",
      "created_at": "2025-10-15T15:57:56+00:00"
    },
    {
      "user": "elasticsearchmachine",
      "body": "## üíî Backport failed\r\n| Status | Branch | Result |\r\n|:------:|:------:|:------:|\r\n| ‚úÖ |  8.19  | <img src=\"https://img.shields.io/github/pulls/detail/state/elastic/elasticsearch/136977\"> |\r\n| ‚úÖ |  [9.1](https://github.com/elastic/elasticsearch/pull/136830)  | [<img src=\"https://img.shields.io/github/pulls/detail/state/elastic/elasticsearch/136830\">](https://github.com/elastic/elasticsearch/pull/136830) |\r\n| ‚úÖ |  [9.2](https://github.com/elastic/elasticsearch/pull/136831)  | [<img src=\"https://img.shields.io/github/pulls/detail/state/elastic/elasticsearch/136831\">](https://github.com/elastic/elasticsearch/pull/136831) |\r\n\r\nYou can use [sqren/backport](https://github.com/sqren/backport) to manually backport by running `backport --upstream elastic/elasticsearch --pr 136058`",
      "created_at": "2025-10-20T18:00:45+00:00"
    }
  ],
  "files_changed": [
    {
      "filename": "docs/changelog/136058.yaml",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "patch": "@@ -0,0 +1,5 @@\n+pr: 136058\n+summary: \"Configurable HTTP read and connect timeouts for url based SAML metadata resolution\"\n+area: Security\n+type: bug\n+issues: []"
    },
    {
      "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/saml/SamlRealmSettings.java",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "patch": "@@ -63,6 +63,20 @@ public class SamlRealmSettings {\n         key -> Setting.boolSetting(key, false, Setting.Property.NodeScope)\n     );\n \n+    public static final Function<String, Setting.AffixSetting<TimeValue>> IDP_METADATA_HTTP_CONNECT_TIMEOUT = (type) -> Setting\n+        .affixKeySetting(\n+            RealmSettings.realmSettingPrefix(type),\n+            IDP_METADATA_SETTING_PREFIX + \"http.connect_timeout\",\n+            key -> Setting.timeSetting(key, TimeValue.timeValueSeconds(5), Setting.Property.NodeScope)\n+        );\n+\n+    public static final Function<String, Setting.AffixSetting<TimeValue>> IDP_METADATA_HTTP_READ_TIMEOUT = (type) -> Setting\n+        .affixKeySetting(\n+            RealmSettings.realmSettingPrefix(type),\n+            IDP_METADATA_SETTING_PREFIX + \"http.read_timeout\",\n+            key -> Setting.timeSetting(key, TimeValue.timeValueSeconds(10), Setting.Property.NodeScope)\n+        );\n+\n     public static final Function<String, Setting.AffixSetting<Boolean>> IDP_SINGLE_LOGOUT = (type) -> Setting.affixKeySetting(\n         RealmSettings.realmSettingPrefix(type),\n         \"idp.use_single_logout\",\n@@ -242,6 +256,8 @@ public static Set<Setting.AffixSetting<?>> getSettings(String type) {\n             IDP_METADATA_HTTP_REFRESH.apply(type),\n             IDP_METADATA_HTTP_MIN_REFRESH.apply(type),\n             IDP_METADATA_HTTP_FAIL_ON_ERROR.apply(type),\n+            IDP_METADATA_HTTP_CONNECT_TIMEOUT.apply(type),\n+            IDP_METADATA_HTTP_READ_TIMEOUT.apply(type),\n             IDP_SINGLE_LOGOUT.apply(type),\n             NAMEID_FORMAT.apply(type),\n             NAMEID_ALLOW_CREATE.apply(type),"
    },
    {
      "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/saml/SamlRealm.java",
      "status": "modified",
      "additions": 18,
      "deletions": 1,
      "changes": 19,
      "patch": "@@ -12,6 +12,7 @@\n import net.shibboleth.utilities.java.support.xml.BasicParserPool;\n \n import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n import org.apache.http.conn.ssl.SSLConnectionSocketFactory;\n import org.apache.http.impl.client.HttpClientBuilder;\n import org.apache.logging.log4j.LogManager;\n@@ -123,8 +124,10 @@\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.FORCE_AUTHN;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.GROUPS_ATTRIBUTE;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_ENTITY_ID;\n+import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_METADATA_HTTP_CONNECT_TIMEOUT;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_METADATA_HTTP_FAIL_ON_ERROR;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_METADATA_HTTP_MIN_REFRESH;\n+import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_METADATA_HTTP_READ_TIMEOUT;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_METADATA_HTTP_REFRESH;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_METADATA_PATH;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_SINGLE_LOGOUT;\n@@ -705,6 +708,14 @@ private static Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescripto\n         final SSLConnectionSocketFactory factory = sslProfile.connectionSocketFactory();\n         builder.setSSLSocketFactory(factory);\n \n+        TimeValue connectTimeout = config.getSetting(IDP_METADATA_HTTP_CONNECT_TIMEOUT);\n+        TimeValue readTimeout = config.getSetting(IDP_METADATA_HTTP_READ_TIMEOUT);\n+        RequestConfig requestConfig = RequestConfig.custom()\n+            .setConnectTimeout(Math.toIntExact(connectTimeout.millis()))\n+            .setSocketTimeout(Math.toIntExact(readTimeout.millis()))\n+            .build();\n+        builder.setDefaultRequestConfig(requestConfig);\n+\n         TimeValue maxRefresh = config.getSetting(IDP_METADATA_HTTP_REFRESH);\n         TimeValue minRefresh = config.getSetting(IDP_METADATA_HTTP_MIN_REFRESH);\n         if (minRefresh.compareTo(maxRefresh) > 0) {\n@@ -799,7 +810,13 @@ private static Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescripto\n         final Path path = config.env().configDir().resolve(metadataPath);\n         final FilesystemMetadataResolver resolver = new SamlFilesystemMetadataResolver(path.toFile());\n \n-        for (var httpSetting : List.of(IDP_METADATA_HTTP_REFRESH, IDP_METADATA_HTTP_MIN_REFRESH, IDP_METADATA_HTTP_FAIL_ON_ERROR)) {\n+        for (var httpSetting : List.of(\n+            IDP_METADATA_HTTP_REFRESH,\n+            IDP_METADATA_HTTP_MIN_REFRESH,\n+            IDP_METADATA_HTTP_FAIL_ON_ERROR,\n+            IDP_METADATA_HTTP_CONNECT_TIMEOUT,\n+            IDP_METADATA_HTTP_READ_TIMEOUT\n+        )) {\n             if (config.hasSetting(httpSetting.apply(config.type()))) {\n                 logger.info(\n                     \"Ignoring setting [{}] because the IdP metadata is being loaded from a file\","
    },
    {
      "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/saml/SamlRealmTests.java",
      "status": "modified",
      "additions": 106,
      "deletions": 0,
      "changes": 106,
      "patch": "@@ -1576,6 +1576,112 @@ private TestsSSLService buildTestSslService() {\n         return new TestsSSLService(TestEnvironment.newEnvironment(settings));\n     }\n \n+    public void testHttpMetadataWithCustomTimeouts() throws Exception {\n+        final Path path = getDataPath(\"idp1.xml\");\n+        final String body = Files.readString(path);\n+        TestsSSLService sslService = buildTestSslService();\n+        try (MockWebServer proxyServer = new MockWebServer(sslService.sslContext(\"xpack.security.http.ssl\"), false)) {\n+            proxyServer.start();\n+            proxyServer.enqueue(new MockResponse().setResponseCode(200).setBody(body).addHeader(\"Content-Type\", \"application/xml\"));\n+\n+            final TimeValue customConnectTimeout = TimeValue.timeValueSeconds(3);\n+            final TimeValue customReadTimeout = TimeValue.timeValueSeconds(15);\n+\n+            Tuple<RealmConfig, SSLService> config = buildConfig(\"https://localhost:\" + proxyServer.getPort(), builder -> {\n+                builder.put(\n+                    SingleSpSamlRealmSettings.getFullSettingKey(REALM_NAME, SamlRealmSettings.IDP_METADATA_HTTP_CONNECT_TIMEOUT),\n+                    customConnectTimeout.getStringRep()\n+                );\n+                builder.put(\n+                    SingleSpSamlRealmSettings.getFullSettingKey(REALM_NAME, SamlRealmSettings.IDP_METADATA_HTTP_READ_TIMEOUT),\n+                    customReadTimeout.getStringRep()\n+                );\n+            });\n+\n+            // Verify settings are correctly configured\n+            assertThat(config.v1().getSetting(SamlRealmSettings.IDP_METADATA_HTTP_CONNECT_TIMEOUT), equalTo(customConnectTimeout));\n+            assertThat(config.v1().getSetting(SamlRealmSettings.IDP_METADATA_HTTP_READ_TIMEOUT), equalTo(customReadTimeout));\n+\n+            final ResourceWatcherService watcherService = mock(ResourceWatcherService.class);\n+            Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescriptor>> tuple = SamlRealm.initializeResolver(\n+                logger,\n+                config.v1(),\n+                config.v2(),\n+                watcherService\n+            );\n+\n+            try {\n+                assertThat(proxyServer.requests().size(), greaterThanOrEqualTo(1));\n+                assertIdp1MetadataParsedCorrectly(tuple.v2().get());\n+            } finally {\n+                tuple.v1().destroy();\n+            }\n+        }\n+    }\n+\n+    public void testHttpMetadataWithDefaultTimeouts() throws Exception {\n+        final Path path = getDataPath(\"idp1.xml\");\n+        final String body = Files.readString(path);\n+        TestsSSLService sslService = buildTestSslService();\n+        try (MockWebServer proxyServer = new MockWebServer(sslService.sslContext(\"xpack.security.http.ssl\"), false)) {\n+            proxyServer.start();\n+            proxyServer.enqueue(new MockResponse().setResponseCode(200).setBody(body).addHeader(\"Content-Type\", \"application/xml\"));\n+\n+            Tuple<RealmConfig, SSLService> config = buildConfig(\"https://localhost:\" + proxyServer.getPort());\n+\n+            // Verify default timeout values are used\n+            assertThat(config.v1().getSetting(SamlRealmSettings.IDP_METADATA_HTTP_CONNECT_TIMEOUT), equalTo(TimeValue.timeValueSeconds(5)));\n+            assertThat(config.v1().getSetting(SamlRealmSettings.IDP_METADATA_HTTP_READ_TIMEOUT), equalTo(TimeValue.timeValueSeconds(10)));\n+\n+            final ResourceWatcherService watcherService = mock(ResourceWatcherService.class);\n+            Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescriptor>> tuple = SamlRealm.initializeResolver(\n+                logger,\n+                config.v1(),\n+                config.v2(),\n+                watcherService\n+            );\n+\n+            try {\n+                assertThat(proxyServer.requests().size(), greaterThanOrEqualTo(1));\n+                assertIdp1MetadataParsedCorrectly(tuple.v2().get());\n+            } finally {\n+                tuple.v1().destroy();\n+            }\n+        }\n+    }\n+\n+    public void testHttpMetadataConnectionTimeout() throws Exception {\n+        // Use a non-routable IP address to simulate connection timeout\n+        // 192.0.2.1 is reserved for documentation and will not be routable\n+        final String unreachableUrl = \"https://192.0.2.1:9999/metadata.xml\";\n+        final TimeValue shortConnectTimeout = TimeValue.timeValueMillis(100);\n+\n+        Tuple<RealmConfig, SSLService> config = buildConfig(unreachableUrl, builder -> {\n+            builder.put(\n+                SingleSpSamlRealmSettings.getFullSettingKey(REALM_NAME, SamlRealmSettings.IDP_METADATA_HTTP_CONNECT_TIMEOUT),\n+                shortConnectTimeout.getStringRep()\n+            );\n+            builder.put(SingleSpSamlRealmSettings.getFullSettingKey(REALM_NAME, SamlRealmSettings.IDP_METADATA_HTTP_FAIL_ON_ERROR), false);\n+        });\n+\n+        final ResourceWatcherService watcherService = mock(ResourceWatcherService.class);\n+\n+        // initialization should complete even though the connection fails\n+        Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescriptor>> tuple = SamlRealm.initializeResolver(\n+            logger,\n+            config.v1(),\n+            config.v2(),\n+            watcherService\n+        );\n+\n+        try {\n+            EntityDescriptor descriptor = tuple.v2().get();\n+            assertThat(descriptor, instanceOf(UnresolvedEntity.class));\n+        } finally {\n+            tuple.v1().destroy();\n+        }\n+    }\n+\n     private void assertIdp1MetadataParsedCorrectly(EntityDescriptor descriptor) {\n         try {\n             IDPSSODescriptor idpssoDescriptor = descriptor.getIDPSSODescriptor(SAMLConstants.SAML20P_NS);"
    }
  ],
  "diff": "diff --git a/docs/changelog/136058.yaml b/docs/changelog/136058.yaml\nnew file mode 100644\nindex 0000000000000..3ec09db8beabc\n--- /dev/null\n+++ b/docs/changelog/136058.yaml\n@@ -0,0 +1,5 @@\n+pr: 136058\n+summary: \"Configurable HTTP read and connect timeouts for url based SAML metadata resolution\"\n+area: Security\n+type: bug\n+issues: []\ndiff --git a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/saml/SamlRealmSettings.java b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/saml/SamlRealmSettings.java\nindex be655625523da..1c8afc234393e 100644\n--- a/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/saml/SamlRealmSettings.java\n+++ b/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/saml/SamlRealmSettings.java\n@@ -63,6 +63,20 @@ public class SamlRealmSettings {\n         key -> Setting.boolSetting(key, false, Setting.Property.NodeScope)\n     );\n \n+    public static final Function<String, Setting.AffixSetting<TimeValue>> IDP_METADATA_HTTP_CONNECT_TIMEOUT = (type) -> Setting\n+        .affixKeySetting(\n+            RealmSettings.realmSettingPrefix(type),\n+            IDP_METADATA_SETTING_PREFIX + \"http.connect_timeout\",\n+            key -> Setting.timeSetting(key, TimeValue.timeValueSeconds(5), Setting.Property.NodeScope)\n+        );\n+\n+    public static final Function<String, Setting.AffixSetting<TimeValue>> IDP_METADATA_HTTP_READ_TIMEOUT = (type) -> Setting\n+        .affixKeySetting(\n+            RealmSettings.realmSettingPrefix(type),\n+            IDP_METADATA_SETTING_PREFIX + \"http.read_timeout\",\n+            key -> Setting.timeSetting(key, TimeValue.timeValueSeconds(10), Setting.Property.NodeScope)\n+        );\n+\n     public static final Function<String, Setting.AffixSetting<Boolean>> IDP_SINGLE_LOGOUT = (type) -> Setting.affixKeySetting(\n         RealmSettings.realmSettingPrefix(type),\n         \"idp.use_single_logout\",\n@@ -242,6 +256,8 @@ public static Set<Setting.AffixSetting<?>> getSettings(String type) {\n             IDP_METADATA_HTTP_REFRESH.apply(type),\n             IDP_METADATA_HTTP_MIN_REFRESH.apply(type),\n             IDP_METADATA_HTTP_FAIL_ON_ERROR.apply(type),\n+            IDP_METADATA_HTTP_CONNECT_TIMEOUT.apply(type),\n+            IDP_METADATA_HTTP_READ_TIMEOUT.apply(type),\n             IDP_SINGLE_LOGOUT.apply(type),\n             NAMEID_FORMAT.apply(type),\n             NAMEID_ALLOW_CREATE.apply(type),\ndiff --git a/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/saml/SamlRealm.java b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/saml/SamlRealm.java\nindex 2e834ab15ef80..5cc2fa5fa2f66 100644\n--- a/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/saml/SamlRealm.java\n+++ b/x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/saml/SamlRealm.java\n@@ -12,6 +12,7 @@\n import net.shibboleth.utilities.java.support.xml.BasicParserPool;\n \n import org.apache.http.client.HttpClient;\n+import org.apache.http.client.config.RequestConfig;\n import org.apache.http.conn.ssl.SSLConnectionSocketFactory;\n import org.apache.http.impl.client.HttpClientBuilder;\n import org.apache.logging.log4j.LogManager;\n@@ -123,8 +124,10 @@\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.FORCE_AUTHN;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.GROUPS_ATTRIBUTE;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_ENTITY_ID;\n+import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_METADATA_HTTP_CONNECT_TIMEOUT;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_METADATA_HTTP_FAIL_ON_ERROR;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_METADATA_HTTP_MIN_REFRESH;\n+import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_METADATA_HTTP_READ_TIMEOUT;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_METADATA_HTTP_REFRESH;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_METADATA_PATH;\n import static org.elasticsearch.xpack.core.security.authc.saml.SamlRealmSettings.IDP_SINGLE_LOGOUT;\n@@ -705,6 +708,14 @@ private static Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescripto\n         final SSLConnectionSocketFactory factory = sslProfile.connectionSocketFactory();\n         builder.setSSLSocketFactory(factory);\n \n+        TimeValue connectTimeout = config.getSetting(IDP_METADATA_HTTP_CONNECT_TIMEOUT);\n+        TimeValue readTimeout = config.getSetting(IDP_METADATA_HTTP_READ_TIMEOUT);\n+        RequestConfig requestConfig = RequestConfig.custom()\n+            .setConnectTimeout(Math.toIntExact(connectTimeout.millis()))\n+            .setSocketTimeout(Math.toIntExact(readTimeout.millis()))\n+            .build();\n+        builder.setDefaultRequestConfig(requestConfig);\n+\n         TimeValue maxRefresh = config.getSetting(IDP_METADATA_HTTP_REFRESH);\n         TimeValue minRefresh = config.getSetting(IDP_METADATA_HTTP_MIN_REFRESH);\n         if (minRefresh.compareTo(maxRefresh) > 0) {\n@@ -799,7 +810,13 @@ private static Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescripto\n         final Path path = config.env().configDir().resolve(metadataPath);\n         final FilesystemMetadataResolver resolver = new SamlFilesystemMetadataResolver(path.toFile());\n \n-        for (var httpSetting : List.of(IDP_METADATA_HTTP_REFRESH, IDP_METADATA_HTTP_MIN_REFRESH, IDP_METADATA_HTTP_FAIL_ON_ERROR)) {\n+        for (var httpSetting : List.of(\n+            IDP_METADATA_HTTP_REFRESH,\n+            IDP_METADATA_HTTP_MIN_REFRESH,\n+            IDP_METADATA_HTTP_FAIL_ON_ERROR,\n+            IDP_METADATA_HTTP_CONNECT_TIMEOUT,\n+            IDP_METADATA_HTTP_READ_TIMEOUT\n+        )) {\n             if (config.hasSetting(httpSetting.apply(config.type()))) {\n                 logger.info(\n                     \"Ignoring setting [{}] because the IdP metadata is being loaded from a file\",\ndiff --git a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/saml/SamlRealmTests.java b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/saml/SamlRealmTests.java\nindex 600a693e46f94..e5f37a5e9de0f 100644\n--- a/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/saml/SamlRealmTests.java\n+++ b/x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/saml/SamlRealmTests.java\n@@ -1576,6 +1576,112 @@ private TestsSSLService buildTestSslService() {\n         return new TestsSSLService(TestEnvironment.newEnvironment(settings));\n     }\n \n+    public void testHttpMetadataWithCustomTimeouts() throws Exception {\n+        final Path path = getDataPath(\"idp1.xml\");\n+        final String body = Files.readString(path);\n+        TestsSSLService sslService = buildTestSslService();\n+        try (MockWebServer proxyServer = new MockWebServer(sslService.sslContext(\"xpack.security.http.ssl\"), false)) {\n+            proxyServer.start();\n+            proxyServer.enqueue(new MockResponse().setResponseCode(200).setBody(body).addHeader(\"Content-Type\", \"application/xml\"));\n+\n+            final TimeValue customConnectTimeout = TimeValue.timeValueSeconds(3);\n+            final TimeValue customReadTimeout = TimeValue.timeValueSeconds(15);\n+\n+            Tuple<RealmConfig, SSLService> config = buildConfig(\"https://localhost:\" + proxyServer.getPort(), builder -> {\n+                builder.put(\n+                    SingleSpSamlRealmSettings.getFullSettingKey(REALM_NAME, SamlRealmSettings.IDP_METADATA_HTTP_CONNECT_TIMEOUT),\n+                    customConnectTimeout.getStringRep()\n+                );\n+                builder.put(\n+                    SingleSpSamlRealmSettings.getFullSettingKey(REALM_NAME, SamlRealmSettings.IDP_METADATA_HTTP_READ_TIMEOUT),\n+                    customReadTimeout.getStringRep()\n+                );\n+            });\n+\n+            // Verify settings are correctly configured\n+            assertThat(config.v1().getSetting(SamlRealmSettings.IDP_METADATA_HTTP_CONNECT_TIMEOUT), equalTo(customConnectTimeout));\n+            assertThat(config.v1().getSetting(SamlRealmSettings.IDP_METADATA_HTTP_READ_TIMEOUT), equalTo(customReadTimeout));\n+\n+            final ResourceWatcherService watcherService = mock(ResourceWatcherService.class);\n+            Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescriptor>> tuple = SamlRealm.initializeResolver(\n+                logger,\n+                config.v1(),\n+                config.v2(),\n+                watcherService\n+            );\n+\n+            try {\n+                assertThat(proxyServer.requests().size(), greaterThanOrEqualTo(1));\n+                assertIdp1MetadataParsedCorrectly(tuple.v2().get());\n+            } finally {\n+                tuple.v1().destroy();\n+            }\n+        }\n+    }\n+\n+    public void testHttpMetadataWithDefaultTimeouts() throws Exception {\n+        final Path path = getDataPath(\"idp1.xml\");\n+        final String body = Files.readString(path);\n+        TestsSSLService sslService = buildTestSslService();\n+        try (MockWebServer proxyServer = new MockWebServer(sslService.sslContext(\"xpack.security.http.ssl\"), false)) {\n+            proxyServer.start();\n+            proxyServer.enqueue(new MockResponse().setResponseCode(200).setBody(body).addHeader(\"Content-Type\", \"application/xml\"));\n+\n+            Tuple<RealmConfig, SSLService> config = buildConfig(\"https://localhost:\" + proxyServer.getPort());\n+\n+            // Verify default timeout values are used\n+            assertThat(config.v1().getSetting(SamlRealmSettings.IDP_METADATA_HTTP_CONNECT_TIMEOUT), equalTo(TimeValue.timeValueSeconds(5)));\n+            assertThat(config.v1().getSetting(SamlRealmSettings.IDP_METADATA_HTTP_READ_TIMEOUT), equalTo(TimeValue.timeValueSeconds(10)));\n+\n+            final ResourceWatcherService watcherService = mock(ResourceWatcherService.class);\n+            Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescriptor>> tuple = SamlRealm.initializeResolver(\n+                logger,\n+                config.v1(),\n+                config.v2(),\n+                watcherService\n+            );\n+\n+            try {\n+                assertThat(proxyServer.requests().size(), greaterThanOrEqualTo(1));\n+                assertIdp1MetadataParsedCorrectly(tuple.v2().get());\n+            } finally {\n+                tuple.v1().destroy();\n+            }\n+        }\n+    }\n+\n+    public void testHttpMetadataConnectionTimeout() throws Exception {\n+        // Use a non-routable IP address to simulate connection timeout\n+        // 192.0.2.1 is reserved for documentation and will not be routable\n+        final String unreachableUrl = \"https://192.0.2.1:9999/metadata.xml\";\n+        final TimeValue shortConnectTimeout = TimeValue.timeValueMillis(100);\n+\n+        Tuple<RealmConfig, SSLService> config = buildConfig(unreachableUrl, builder -> {\n+            builder.put(\n+                SingleSpSamlRealmSettings.getFullSettingKey(REALM_NAME, SamlRealmSettings.IDP_METADATA_HTTP_CONNECT_TIMEOUT),\n+                shortConnectTimeout.getStringRep()\n+            );\n+            builder.put(SingleSpSamlRealmSettings.getFullSettingKey(REALM_NAME, SamlRealmSettings.IDP_METADATA_HTTP_FAIL_ON_ERROR), false);\n+        });\n+\n+        final ResourceWatcherService watcherService = mock(ResourceWatcherService.class);\n+\n+        // initialization should complete even though the connection fails\n+        Tuple<AbstractReloadingMetadataResolver, Supplier<EntityDescriptor>> tuple = SamlRealm.initializeResolver(\n+            logger,\n+            config.v1(),\n+            config.v2(),\n+            watcherService\n+        );\n+\n+        try {\n+            EntityDescriptor descriptor = tuple.v2().get();\n+            assertThat(descriptor, instanceOf(UnresolvedEntity.class));\n+        } finally {\n+            tuple.v1().destroy();\n+        }\n+    }\n+\n     private void assertIdp1MetadataParsedCorrectly(EntityDescriptor descriptor) {\n         try {\n             IDPSSODescriptor idpssoDescriptor = descriptor.getIDPSSODescriptor(SAMLConstants.SAML20P_NS);\n",
  "additions": 145,
  "deletions": 1,
  "changed_files": 4,
  "url": "https://github.com/elastic/elasticsearch/pull/136058",
  "mined_at": "2025-10-25T13:42:35.385140"
}