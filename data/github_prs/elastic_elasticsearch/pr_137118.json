{
  "id": 137118,
  "repository": "elastic/elasticsearch",
  "title": "[8.19] Fix mapping conflicts in clone/split/shrink APIs (#137096)",
  "body": "Backports the following commits to 8.19:\n - Fix mapping conflicts in clone/split/shrink APIs (#137096)",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-25T08:37:12+00:00",
  "created_at": "2025-10-24T15:48:37+00:00",
  "updated_at": "2025-10-25T08:37:35+00:00",
  "author": "nielsbauman",
  "reviewers": [],
  "base_sha": "fb5008a508dc277188eee418af7e0de6d7810d57",
  "head_sha": "26befef6ec267c3db7b598ced7897d4ddb97b2f7",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "docs/changelog/137096.yaml",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "patch": "@@ -0,0 +1,5 @@\n+pr: 137096\n+summary: Fix mapping conflicts in clone/split/shrink APIs\n+area: Indices APIs\n+type: bug\n+issues: []"
    },
    {
      "filename": "server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/CloneIndexIT.java",
      "status": "modified",
      "additions": 57,
      "deletions": 0,
      "changes": 57,
      "patch": "@@ -20,6 +20,7 @@\n import org.elasticsearch.index.seqno.SeqNoStats;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.index.IndexVersionUtils;\n+import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.util.List;\n@@ -203,4 +204,60 @@ public void testResizeChangeIndexSorts() {\n         });\n         assertThat(error.getMessage(), containsString(\"can't override index sort when resizing an index\"));\n     }\n+\n+    /**\n+     * Test that cloning a logsdb index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testCloneLogsdbIndexWithNonDefaultTimestamp() {\n+        // Create a logsdb index with a date_nanos @timestamp field\n+        final int numberOfReplicas = randomInt(internalCluster().numDataNodes() - 1);\n+        final var settings = indexSettings(1, numberOfReplicas).put(\"index.mode\", \"logsdb\").put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings).setMapping(\"@timestamp\", \"type=date_nanos\").get();\n+        ensureGreen();\n+\n+        // Clone the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.CLONE)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_replicas\", numberOfReplicas).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(\"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n+\n+    /**\n+     * Test that cloning a time series index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testCloneTimeSeriesIndexWithNonDefaultTimestamp() {\n+        // Create a time series index with a date_nanos @timestamp field\n+        final int numberOfReplicas = randomInt(internalCluster().numDataNodes() - 1);\n+        final var settings = indexSettings(1, numberOfReplicas).put(\"index.mode\", \"time_series\")\n+            .put(\"index.routing_path\", \"sensor_id\")\n+            .put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings)\n+            .setMapping(\"@timestamp\", \"type=date_nanos\", \"sensor_id\", \"type=keyword,time_series_dimension=true\")\n+            .get();\n+        ensureGreen();\n+\n+        // Clone the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.CLONE)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_replicas\", numberOfReplicas).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(\"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n }"
    },
    {
      "filename": "server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/ShrinkIndexIT.java",
      "status": "modified",
      "additions": 58,
      "deletions": 0,
      "changes": 58,
      "patch": "@@ -51,6 +51,7 @@\n import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.index.IndexVersionUtils;\n+import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.util.Arrays;\n@@ -608,6 +609,63 @@ public void testShrinkThenSplitWithFailedNode() throws Exception {\n         assertNoResizeSourceIndexSettings(\"splitagain\");\n     }\n \n+    /**\n+     * Tests that shrinking a logsdb index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testShrinkLogsdbIndexWithNonDefaultTimestamp() {\n+        // Create a logsdb index with a date_nanos @timestamp field\n+        final var settings = indexSettings(2, 0).put(\"index.mode\", \"logsdb\")\n+            .put(\"index.blocks.write\", true)\n+            .put(\"index.routing.allocation.require._name\", internalCluster().getRandomDataNodeName());\n+        prepareCreate(\"source\").setSettings(settings).setMapping(\"@timestamp\", \"type=date_nanos\").get();\n+        ensureGreen();\n+\n+        // Shrink the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.SHRINK)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(\"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n+\n+    /**\n+     * Tests that shrinking a time series index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testShrinkTimeSeriesIndexWithNonDefaultTimestamp() {\n+        // Create a time series index with a date_nanos @timestamp field\n+        final var settings = indexSettings(2, 0).put(\"index.mode\", \"time_series\")\n+            .put(\"index.routing_path\", \"sensor_id\")\n+            .put(\"index.routing.allocation.require._name\", internalCluster().getRandomDataNodeName())\n+            .put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings)\n+            .setMapping(\"@timestamp\", \"type=date_nanos\", \"sensor_id\", \"type=keyword,time_series_dimension=true\")\n+            .get();\n+        ensureGreen();\n+\n+        // Shrink the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.SHRINK)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(\"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n+\n     static void assertNoResizeSourceIndexSettings(final String index) {\n         ClusterStateResponse clusterStateResponse = clusterAdmin().prepareState(TEST_REQUEST_TIMEOUT)\n             .clear()"
    },
    {
      "filename": "server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/SplitIndexIT.java",
      "status": "modified",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "patch": "@@ -46,6 +46,7 @@\n import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.index.IndexVersionUtils;\n+import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.io.IOException;\n@@ -493,4 +494,31 @@ public void testCreateSplitWithIndexSort() throws Exception {\n         assertSortedSegments(\"target\", expectedIndexSort);\n         assertNoResizeSourceIndexSettings(\"target\");\n     }\n+\n+    /**\n+     * Tests that splitting a logsdb index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     * N.B.: we don't test time_series indices as split is not supported for them.\n+     */\n+    public void testSplitLogsdbIndexWithNonDefaultTimestamp() {\n+        // Create a logsdb index with a date_nanos @timestamp field\n+        final int numberOfReplicas = randomInt(internalCluster().numDataNodes() - 1);\n+        final var settings = indexSettings(1, numberOfReplicas).put(\"index.mode\", \"logsdb\").put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings).setMapping(\"@timestamp\", \"type=date_nanos\").get();\n+        ensureGreen();\n+\n+        // Split the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.SPLIT)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_shards\", 2).put(\"index.number_of_replicas\", numberOfReplicas).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(\"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n }"
    },
    {
      "filename": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java",
      "status": "modified",
      "additions": 15,
      "deletions": 14,
      "changes": 29,
      "patch": "@@ -512,11 +512,15 @@ private ClusterState applyCreateIndexWithTemporaryService(\n         assert indicesService.hasIndex(temporaryIndexMeta.getIndex()) == false\n             : Strings.format(\"Index [%s] already exists\", temporaryIndexMeta.getIndex().getName());\n         return indicesService.<ClusterState, Exception>withTempIndexService(temporaryIndexMeta, indexService -> {\n-            try {\n-                updateIndexMappingsAndBuildSortOrder(indexService, request, mappings, sourceMetadata);\n-            } catch (Exception e) {\n-                logger.log(silent ? Level.DEBUG : Level.INFO, \"failed on parsing mappings on index creation [{}]\", request.index(), e);\n-                throw e;\n+            // If we're creating the index from an existing index, we should not provide any mappings, as the new index shards will take\n+            // care of copying the mappings from the source index during recovery. Providing mappings here would cause conflicts.\n+            if (sourceMetadata == null) {\n+                try {\n+                    updateIndexMappingsAndBuildSortOrder(indexService, request, mappings);\n+                } catch (Exception e) {\n+                    logger.log(silent ? Level.DEBUG : Level.INFO, \"failed on parsing mappings on index creation [{}]\", request.index(), e);\n+                    throw e;\n+                }\n             }\n \n             final List<AliasMetadata> aliases = aliasSupplier.apply(indexService);\n@@ -1422,8 +1426,7 @@ private static IndexMetadata.Builder createIndexMetadataBuilder(\n     private static void updateIndexMappingsAndBuildSortOrder(\n         IndexService indexService,\n         CreateIndexClusterStateUpdateRequest request,\n-        List<CompressedXContent> mappings,\n-        @Nullable IndexMetadata sourceMetadata\n+        List<CompressedXContent> mappings\n     ) throws IOException {\n         MapperService mapperService = indexService.mapperService();\n         IndexMode indexMode = indexService.getIndexSettings() != null ? indexService.getIndexSettings().getMode() : IndexMode.STANDARD;\n@@ -1437,13 +1440,11 @@ private static void updateIndexMappingsAndBuildSortOrder(\n \n         indexMode.validateTimestampFieldMapping(request.dataStreamName() != null, mapperService.mappingLookup());\n \n-        if (sourceMetadata == null) {\n-            // now that the mapping is merged we can validate the index sort.\n-            // we cannot validate for index shrinking since the mapping is empty\n-            // at this point. The validation will take place later in the process\n-            // (when all shards are copied in a single place).\n-            indexService.getIndexSortSupplier().get();\n-        }\n+        // now that the mapping is merged we can validate the index sort.\n+        // we cannot validate for index shrinking since the mapping is empty\n+        // at this point. The validation will take place later in the process\n+        // (when all shards are copied in a single place).\n+        indexService.getIndexSortSupplier().get();\n     }\n \n     private static void validateActiveShardCount(ActiveShardCount waitForActiveShards, IndexMetadata indexMetadata) {"
    },
    {
      "filename": "test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "patch": "@@ -2073,6 +2073,13 @@ public String getRandomNodeName() {\n         return getNodeNameThat(Predicates.always());\n     }\n \n+    /**\n+     * @return the name of a random data node in a cluster\n+     */\n+    public String getRandomDataNodeName() {\n+        return getNodeNameThat(DiscoveryNode::canContainData);\n+    }\n+\n     /**\n      * @return the name of a random node in a cluster that match the {@code predicate}\n      */"
    }
  ],
  "diff": "diff --git a/docs/changelog/137096.yaml b/docs/changelog/137096.yaml\nnew file mode 100644\nindex 0000000000000..1b194934b0691\n--- /dev/null\n+++ b/docs/changelog/137096.yaml\n@@ -0,0 +1,5 @@\n+pr: 137096\n+summary: Fix mapping conflicts in clone/split/shrink APIs\n+area: Indices APIs\n+type: bug\n+issues: []\ndiff --git a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/CloneIndexIT.java b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/CloneIndexIT.java\nindex deb191b4f1ce2..7952a1438586e 100644\n--- a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/CloneIndexIT.java\n+++ b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/CloneIndexIT.java\n@@ -20,6 +20,7 @@\n import org.elasticsearch.index.seqno.SeqNoStats;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.index.IndexVersionUtils;\n+import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.util.List;\n@@ -203,4 +204,60 @@ public void testResizeChangeIndexSorts() {\n         });\n         assertThat(error.getMessage(), containsString(\"can't override index sort when resizing an index\"));\n     }\n+\n+    /**\n+     * Test that cloning a logsdb index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testCloneLogsdbIndexWithNonDefaultTimestamp() {\n+        // Create a logsdb index with a date_nanos @timestamp field\n+        final int numberOfReplicas = randomInt(internalCluster().numDataNodes() - 1);\n+        final var settings = indexSettings(1, numberOfReplicas).put(\"index.mode\", \"logsdb\").put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings).setMapping(\"@timestamp\", \"type=date_nanos\").get();\n+        ensureGreen();\n+\n+        // Clone the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.CLONE)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_replicas\", numberOfReplicas).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(\"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n+\n+    /**\n+     * Test that cloning a time series index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testCloneTimeSeriesIndexWithNonDefaultTimestamp() {\n+        // Create a time series index with a date_nanos @timestamp field\n+        final int numberOfReplicas = randomInt(internalCluster().numDataNodes() - 1);\n+        final var settings = indexSettings(1, numberOfReplicas).put(\"index.mode\", \"time_series\")\n+            .put(\"index.routing_path\", \"sensor_id\")\n+            .put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings)\n+            .setMapping(\"@timestamp\", \"type=date_nanos\", \"sensor_id\", \"type=keyword,time_series_dimension=true\")\n+            .get();\n+        ensureGreen();\n+\n+        // Clone the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.CLONE)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_replicas\", numberOfReplicas).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(\"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n }\ndiff --git a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/ShrinkIndexIT.java b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/ShrinkIndexIT.java\nindex 4f6d24b419595..2cd25ba308539 100644\n--- a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/ShrinkIndexIT.java\n+++ b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/ShrinkIndexIT.java\n@@ -51,6 +51,7 @@\n import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.index.IndexVersionUtils;\n+import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.util.Arrays;\n@@ -608,6 +609,63 @@ public void testShrinkThenSplitWithFailedNode() throws Exception {\n         assertNoResizeSourceIndexSettings(\"splitagain\");\n     }\n \n+    /**\n+     * Tests that shrinking a logsdb index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testShrinkLogsdbIndexWithNonDefaultTimestamp() {\n+        // Create a logsdb index with a date_nanos @timestamp field\n+        final var settings = indexSettings(2, 0).put(\"index.mode\", \"logsdb\")\n+            .put(\"index.blocks.write\", true)\n+            .put(\"index.routing.allocation.require._name\", internalCluster().getRandomDataNodeName());\n+        prepareCreate(\"source\").setSettings(settings).setMapping(\"@timestamp\", \"type=date_nanos\").get();\n+        ensureGreen();\n+\n+        // Shrink the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.SHRINK)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(\"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n+\n+    /**\n+     * Tests that shrinking a time series index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testShrinkTimeSeriesIndexWithNonDefaultTimestamp() {\n+        // Create a time series index with a date_nanos @timestamp field\n+        final var settings = indexSettings(2, 0).put(\"index.mode\", \"time_series\")\n+            .put(\"index.routing_path\", \"sensor_id\")\n+            .put(\"index.routing.allocation.require._name\", internalCluster().getRandomDataNodeName())\n+            .put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings)\n+            .setMapping(\"@timestamp\", \"type=date_nanos\", \"sensor_id\", \"type=keyword,time_series_dimension=true\")\n+            .get();\n+        ensureGreen();\n+\n+        // Shrink the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.SHRINK)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(\"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n+\n     static void assertNoResizeSourceIndexSettings(final String index) {\n         ClusterStateResponse clusterStateResponse = clusterAdmin().prepareState(TEST_REQUEST_TIMEOUT)\n             .clear()\ndiff --git a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/SplitIndexIT.java b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/SplitIndexIT.java\nindex e1bf5bce6f3ae..099efbe0d8474 100644\n--- a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/SplitIndexIT.java\n+++ b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/SplitIndexIT.java\n@@ -46,6 +46,7 @@\n import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.index.IndexVersionUtils;\n+import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.io.IOException;\n@@ -493,4 +494,31 @@ public void testCreateSplitWithIndexSort() throws Exception {\n         assertSortedSegments(\"target\", expectedIndexSort);\n         assertNoResizeSourceIndexSettings(\"target\");\n     }\n+\n+    /**\n+     * Tests that splitting a logsdb index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     * N.B.: we don't test time_series indices as split is not supported for them.\n+     */\n+    public void testSplitLogsdbIndexWithNonDefaultTimestamp() {\n+        // Create a logsdb index with a date_nanos @timestamp field\n+        final int numberOfReplicas = randomInt(internalCluster().numDataNodes() - 1);\n+        final var settings = indexSettings(1, numberOfReplicas).put(\"index.mode\", \"logsdb\").put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings).setMapping(\"@timestamp\", \"type=date_nanos\").get();\n+        ensureGreen();\n+\n+        // Split the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.SPLIT)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_shards\", 2).put(\"index.number_of_replicas\", numberOfReplicas).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(\"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n }\ndiff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java\nindex ebe4ae300e59e..81142c13a5bac 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java\n@@ -512,11 +512,15 @@ private ClusterState applyCreateIndexWithTemporaryService(\n         assert indicesService.hasIndex(temporaryIndexMeta.getIndex()) == false\n             : Strings.format(\"Index [%s] already exists\", temporaryIndexMeta.getIndex().getName());\n         return indicesService.<ClusterState, Exception>withTempIndexService(temporaryIndexMeta, indexService -> {\n-            try {\n-                updateIndexMappingsAndBuildSortOrder(indexService, request, mappings, sourceMetadata);\n-            } catch (Exception e) {\n-                logger.log(silent ? Level.DEBUG : Level.INFO, \"failed on parsing mappings on index creation [{}]\", request.index(), e);\n-                throw e;\n+            // If we're creating the index from an existing index, we should not provide any mappings, as the new index shards will take\n+            // care of copying the mappings from the source index during recovery. Providing mappings here would cause conflicts.\n+            if (sourceMetadata == null) {\n+                try {\n+                    updateIndexMappingsAndBuildSortOrder(indexService, request, mappings);\n+                } catch (Exception e) {\n+                    logger.log(silent ? Level.DEBUG : Level.INFO, \"failed on parsing mappings on index creation [{}]\", request.index(), e);\n+                    throw e;\n+                }\n             }\n \n             final List<AliasMetadata> aliases = aliasSupplier.apply(indexService);\n@@ -1422,8 +1426,7 @@ private static IndexMetadata.Builder createIndexMetadataBuilder(\n     private static void updateIndexMappingsAndBuildSortOrder(\n         IndexService indexService,\n         CreateIndexClusterStateUpdateRequest request,\n-        List<CompressedXContent> mappings,\n-        @Nullable IndexMetadata sourceMetadata\n+        List<CompressedXContent> mappings\n     ) throws IOException {\n         MapperService mapperService = indexService.mapperService();\n         IndexMode indexMode = indexService.getIndexSettings() != null ? indexService.getIndexSettings().getMode() : IndexMode.STANDARD;\n@@ -1437,13 +1440,11 @@ private static void updateIndexMappingsAndBuildSortOrder(\n \n         indexMode.validateTimestampFieldMapping(request.dataStreamName() != null, mapperService.mappingLookup());\n \n-        if (sourceMetadata == null) {\n-            // now that the mapping is merged we can validate the index sort.\n-            // we cannot validate for index shrinking since the mapping is empty\n-            // at this point. The validation will take place later in the process\n-            // (when all shards are copied in a single place).\n-            indexService.getIndexSortSupplier().get();\n-        }\n+        // now that the mapping is merged we can validate the index sort.\n+        // we cannot validate for index shrinking since the mapping is empty\n+        // at this point. The validation will take place later in the process\n+        // (when all shards are copied in a single place).\n+        indexService.getIndexSortSupplier().get();\n     }\n \n     private static void validateActiveShardCount(ActiveShardCount waitForActiveShards, IndexMetadata indexMetadata) {\ndiff --git a/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java b/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java\nindex 5510c60252140..a8785f5358be5 100644\n--- a/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java\n+++ b/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java\n@@ -2073,6 +2073,13 @@ public String getRandomNodeName() {\n         return getNodeNameThat(Predicates.always());\n     }\n \n+    /**\n+     * @return the name of a random data node in a cluster\n+     */\n+    public String getRandomDataNodeName() {\n+        return getNodeNameThat(DiscoveryNode::canContainData);\n+    }\n+\n     /**\n      * @return the name of a random node in a cluster that match the {@code predicate}\n      */\n",
  "additions": 170,
  "deletions": 14,
  "changed_files": 6,
  "url": "https://github.com/elastic/elasticsearch/pull/137118",
  "mined_at": "2025-10-25T13:11:03.144527"
}