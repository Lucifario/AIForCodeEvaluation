{
  "id": 137067,
  "repository": "elastic/elasticsearch",
  "title": "small fix - delete sample config action request to only accept one index",
  "body": "Got a comment on my delete config PR https://github.com/elastic/elasticsearch/pull/136570 after merging to update the delete action request object indices instance var to only accept a single string instead of an array. This is because the rest action class for this action will reject any requests with more than one index included and thus a full array is not needed/confusing",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-23T23:32:33+00:00",
  "created_at": "2025-10-23T20:24:19+00:00",
  "updated_at": "2025-10-23T23:32:37+00:00",
  "author": "seanzatzdev",
  "reviewers": [
    "copilot-pull-request-reviewer[bot]",
    "masseyke"
  ],
  "base_sha": "b3113833db08ec7124c7f738eabbbb5e4e08fb9d",
  "head_sha": "17074f159da370386d6c2f179e475ace162052ce",
  "review_comments": [
    {
      "user": "copilot-pull-request-reviewer[bot]",
      "state": "COMMENTED",
      "body": "## Pull Request Overview\n\nThis PR refactors the `DeleteSampleConfigurationAction.Request` class to accept only a single index instead of an array of indices, aligning with the REST API's validation that rejects requests with multiple indices.\n\n**Key changes:**\n- Changed the `indices` field from `String[]` to a single `String index`\n- Updated validation to throw `IllegalArgumentException` when multiple indices are provided\n- Simplified the test to verify the new validation behavior\n\n### Reviewed Changes\n\nCopilot reviewed 2 out of 2 changed files in this pull request and generated 1 comment.\n\n| File | Description |\n| ---- | ----------- |\n| DeleteSampleConfigurationAction.java | Converted `indices` field from array to single string, added validation to reject multiple indices, updated serialization methods |\n| TransportDeleteSampleConfigurationActionTests.java | Simplified test to verify `IllegalArgumentException` is thrown when multiple indices are provided |\n\n\n\n\n\n---\n\n<sub>**Tip:** Customize your code reviews with copilot-instructions.md. <a href=\"/elastic/elasticsearch/new/main/.github?filename=copilot-instructions.md\" class=\"Link--inTextBlock\" target=\"_blank\" rel=\"noopener noreferrer\">Create the file</a> or <a href=\"https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot\" class=\"Link--inTextBlock\" target=\"_blank\" rel=\"noopener noreferrer\">learn how to get started</a>.</sub>",
      "submitted_at": "2025-10-23T20:24:53+00:00"
    },
    {
      "user": "masseyke",
      "state": "APPROVED",
      "body": "",
      "submitted_at": "2025-10-23T21:39:00+00:00"
    }
  ],
  "pr_comments": [
    {
      "user": "elasticsearchmachine",
      "body": "Pinging @elastic/es-data-management (Team:Data Management)",
      "created_at": "2025-10-23T21:35:45+00:00"
    }
  ],
  "files_changed": [
    {
      "filename": "server/src/main/java/org/elasticsearch/action/admin/indices/sampling/DeleteSampleConfigurationAction.java",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "patch": "@@ -14,14 +14,12 @@\n import org.elasticsearch.action.support.IndicesOptions;\n import org.elasticsearch.action.support.master.AcknowledgedRequest;\n import org.elasticsearch.action.support.master.AcknowledgedResponse;\n-import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.core.Nullable;\n import org.elasticsearch.core.TimeValue;\n \n import java.io.IOException;\n-import java.util.Arrays;\n import java.util.Objects;\n \n /**\n@@ -73,7 +71,7 @@ private DeleteSampleConfigurationAction() {\n      */\n     public static class Request extends AcknowledgedRequest<Request> implements IndicesRequest.Replaceable {\n \n-        private String[] indices = Strings.EMPTY_ARRAY;\n+        private String index;\n \n         /**\n          * Constructs a new request with specified timeouts.\n@@ -93,7 +91,7 @@ public Request(@Nullable TimeValue masterNodeTimeout, @Nullable TimeValue ackTim\n          */\n         public Request(StreamInput in) throws IOException {\n             super(in);\n-            this.indices = in.readStringArray();\n+            this.index = in.readString();\n         }\n \n         /**\n@@ -109,7 +107,7 @@ public Request(StreamInput in) throws IOException {\n         @Override\n         public void writeTo(StreamOutput out) throws IOException {\n             super.writeTo(out);\n-            out.writeStringArray(indices);\n+            out.writeString(index);\n         }\n \n         /**\n@@ -124,23 +122,25 @@ public void writeTo(StreamOutput out) throws IOException {\n          */\n         @Override\n         public String[] indices() {\n-            return indices;\n+            return new String[] { index };\n         }\n \n         /**\n-         * Sets the array of index names or patterns for this request.\n+         * Sets the array of index name for this request.\n          * <p>\n-         * Specifies which indices and/or data streams should have their sampling\n-         * configurations deleted. Supports individual index names, comma-separated\n-         * lists, and wildcard patterns.\n+         * Specifies which index and/or data stream should have their sampling\n+         * configurations deleted. Supports individual index names\n          * </p>\n          *\n          * @param indices the index names or patterns to target, null will be converted to empty array\n          * @return this request instance for method chaining\n          */\n         @Override\n         public IndicesRequest indices(String... indices) {\n-            this.indices = indices == null ? Strings.EMPTY_ARRAY : indices;\n+            if (indices == null || indices.length != 1) {\n+                throw new IllegalArgumentException(\"[indices] must contain only one index\");\n+            }\n+            this.index = indices[0];\n             return this;\n         }\n \n@@ -185,7 +185,7 @@ public boolean equals(Object o) {\n             if (this == o) return true;\n             if (o == null || getClass() != o.getClass()) return false;\n             Request request = (Request) o;\n-            return Arrays.equals(indices, request.indices)\n+            return Objects.equals(index, request.index)\n                 && Objects.equals(this.masterNodeTimeout(), request.masterNodeTimeout())\n                 && Objects.equals(this.ackTimeout(), request.ackTimeout());\n         }\n@@ -201,7 +201,7 @@ public boolean equals(Object o) {\n          */\n         @Override\n         public int hashCode() {\n-            return Objects.hash(Arrays.hashCode(indices), masterNodeTimeout(), ackTimeout());\n+            return Objects.hash(index, masterNodeTimeout(), ackTimeout());\n         }\n     }\n }"
    },
    {
      "filename": "server/src/test/java/org/elasticsearch/action/admin/indices/sampling/TransportDeleteSampleConfigurationActionTests.java",
      "status": "modified",
      "additions": 5,
      "deletions": 42,
      "changes": 47,
      "patch": "@@ -325,58 +325,21 @@ public void testActionConfiguration() {\n     }\n \n     /**\n-     * Tests that multiple indices in request causes IndexNotFoundException when resolved.\n+     * Tests that multiple indices in request causes IllegalArgumentException.\n      * The action should only accept single index operations.\n      */\n-    public void testMasterOperationMultipleIndices() throws Exception {\n+    public void testMasterOperationMultipleIndices() {\n         // Setup test data\n-        ProjectId projectId = randomProjectIdOrDefault();\n         String indexName1 = randomIdentifier();\n         String indexName2 = randomIdentifier();\n         TimeValue masterNodeTimeout = randomTimeValue(100, 200);\n         TimeValue ackTimeout = randomTimeValue(100, 200);\n \n         DeleteSampleConfigurationAction.Request request = new DeleteSampleConfigurationAction.Request(masterNodeTimeout, ackTimeout);\n-        request.indices(indexName1, indexName2);\n-\n-        ClusterState clusterState = ClusterState.builder(ClusterState.EMPTY_STATE).build();\n-        Task task = mock(Task.class);\n-\n-        // Setup mocks - IndexNameExpressionResolver should throw for multiple indices\n-        IndexNotFoundException multipleIndicesException = new IndexNotFoundException(\"Multiple indices not supported\");\n-        when(indexNameExpressionResolver.concreteIndexNames(clusterState, request)).thenThrow(multipleIndicesException);\n-\n-        // Test execution with CountDownLatch to handle async operation\n-        CountDownLatch latch = new CountDownLatch(1);\n-        AtomicReference<AcknowledgedResponse> responseRef = new AtomicReference<>();\n-        AtomicReference<Exception> exceptionRef = new AtomicReference<>();\n \n-        ActionListener<AcknowledgedResponse> testListener = new ActionListener<AcknowledgedResponse>() {\n-            @Override\n-            public void onResponse(AcknowledgedResponse response) {\n-                responseRef.set(response);\n-                latch.countDown();\n-            }\n-\n-            @Override\n-            public void onFailure(Exception e) {\n-                exceptionRef.set(e);\n-                latch.countDown();\n-            }\n-        };\n-\n-        action.masterOperation(task, request, clusterState, testListener);\n-\n-        // Wait for async operation to complete\n-        assertTrue(\"Operation should complete within timeout\", latch.await(5, TimeUnit.SECONDS));\n-\n-        // Verify results\n-        assertThat(responseRef.get(), nullValue());\n-        assertThat(exceptionRef.get(), not(nullValue()));\n-        assertThat(exceptionRef.get(), sameInstance(multipleIndicesException));\n-\n-        // Verify interactions\n-        verify(indexNameExpressionResolver).concreteIndexNames(clusterState, request);\n+        // Verify that setting multiple indices throws IllegalArgumentException\n+        IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, () -> request.indices(indexName1, indexName2));\n+        assertThat(exception.getMessage(), equalTo(\"[indices] must contain only one index\"));\n     }\n \n     /**"
    }
  ],
  "diff": "diff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/DeleteSampleConfigurationAction.java b/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/DeleteSampleConfigurationAction.java\nindex 7df38cb3da494..e6b8ceaefa721 100644\n--- a/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/DeleteSampleConfigurationAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/DeleteSampleConfigurationAction.java\n@@ -14,14 +14,12 @@\n import org.elasticsearch.action.support.IndicesOptions;\n import org.elasticsearch.action.support.master.AcknowledgedRequest;\n import org.elasticsearch.action.support.master.AcknowledgedResponse;\n-import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.core.Nullable;\n import org.elasticsearch.core.TimeValue;\n \n import java.io.IOException;\n-import java.util.Arrays;\n import java.util.Objects;\n \n /**\n@@ -73,7 +71,7 @@ private DeleteSampleConfigurationAction() {\n      */\n     public static class Request extends AcknowledgedRequest<Request> implements IndicesRequest.Replaceable {\n \n-        private String[] indices = Strings.EMPTY_ARRAY;\n+        private String index;\n \n         /**\n          * Constructs a new request with specified timeouts.\n@@ -93,7 +91,7 @@ public Request(@Nullable TimeValue masterNodeTimeout, @Nullable TimeValue ackTim\n          */\n         public Request(StreamInput in) throws IOException {\n             super(in);\n-            this.indices = in.readStringArray();\n+            this.index = in.readString();\n         }\n \n         /**\n@@ -109,7 +107,7 @@ public Request(StreamInput in) throws IOException {\n         @Override\n         public void writeTo(StreamOutput out) throws IOException {\n             super.writeTo(out);\n-            out.writeStringArray(indices);\n+            out.writeString(index);\n         }\n \n         /**\n@@ -124,15 +122,14 @@ public void writeTo(StreamOutput out) throws IOException {\n          */\n         @Override\n         public String[] indices() {\n-            return indices;\n+            return new String[] { index };\n         }\n \n         /**\n-         * Sets the array of index names or patterns for this request.\n+         * Sets the array of index name for this request.\n          * <p>\n-         * Specifies which indices and/or data streams should have their sampling\n-         * configurations deleted. Supports individual index names, comma-separated\n-         * lists, and wildcard patterns.\n+         * Specifies which index and/or data stream should have their sampling\n+         * configurations deleted. Supports individual index names\n          * </p>\n          *\n          * @param indices the index names or patterns to target, null will be converted to empty array\n@@ -140,7 +137,10 @@ public String[] indices() {\n          */\n         @Override\n         public IndicesRequest indices(String... indices) {\n-            this.indices = indices == null ? Strings.EMPTY_ARRAY : indices;\n+            if (indices == null || indices.length != 1) {\n+                throw new IllegalArgumentException(\"[indices] must contain only one index\");\n+            }\n+            this.index = indices[0];\n             return this;\n         }\n \n@@ -185,7 +185,7 @@ public boolean equals(Object o) {\n             if (this == o) return true;\n             if (o == null || getClass() != o.getClass()) return false;\n             Request request = (Request) o;\n-            return Arrays.equals(indices, request.indices)\n+            return Objects.equals(index, request.index)\n                 && Objects.equals(this.masterNodeTimeout(), request.masterNodeTimeout())\n                 && Objects.equals(this.ackTimeout(), request.ackTimeout());\n         }\n@@ -201,7 +201,7 @@ public boolean equals(Object o) {\n          */\n         @Override\n         public int hashCode() {\n-            return Objects.hash(Arrays.hashCode(indices), masterNodeTimeout(), ackTimeout());\n+            return Objects.hash(index, masterNodeTimeout(), ackTimeout());\n         }\n     }\n }\ndiff --git a/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/TransportDeleteSampleConfigurationActionTests.java b/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/TransportDeleteSampleConfigurationActionTests.java\nindex aa71f9e836367..11d7b0e7a0fdf 100644\n--- a/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/TransportDeleteSampleConfigurationActionTests.java\n+++ b/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/TransportDeleteSampleConfigurationActionTests.java\n@@ -325,58 +325,21 @@ public void testActionConfiguration() {\n     }\n \n     /**\n-     * Tests that multiple indices in request causes IndexNotFoundException when resolved.\n+     * Tests that multiple indices in request causes IllegalArgumentException.\n      * The action should only accept single index operations.\n      */\n-    public void testMasterOperationMultipleIndices() throws Exception {\n+    public void testMasterOperationMultipleIndices() {\n         // Setup test data\n-        ProjectId projectId = randomProjectIdOrDefault();\n         String indexName1 = randomIdentifier();\n         String indexName2 = randomIdentifier();\n         TimeValue masterNodeTimeout = randomTimeValue(100, 200);\n         TimeValue ackTimeout = randomTimeValue(100, 200);\n \n         DeleteSampleConfigurationAction.Request request = new DeleteSampleConfigurationAction.Request(masterNodeTimeout, ackTimeout);\n-        request.indices(indexName1, indexName2);\n-\n-        ClusterState clusterState = ClusterState.builder(ClusterState.EMPTY_STATE).build();\n-        Task task = mock(Task.class);\n-\n-        // Setup mocks - IndexNameExpressionResolver should throw for multiple indices\n-        IndexNotFoundException multipleIndicesException = new IndexNotFoundException(\"Multiple indices not supported\");\n-        when(indexNameExpressionResolver.concreteIndexNames(clusterState, request)).thenThrow(multipleIndicesException);\n-\n-        // Test execution with CountDownLatch to handle async operation\n-        CountDownLatch latch = new CountDownLatch(1);\n-        AtomicReference<AcknowledgedResponse> responseRef = new AtomicReference<>();\n-        AtomicReference<Exception> exceptionRef = new AtomicReference<>();\n \n-        ActionListener<AcknowledgedResponse> testListener = new ActionListener<AcknowledgedResponse>() {\n-            @Override\n-            public void onResponse(AcknowledgedResponse response) {\n-                responseRef.set(response);\n-                latch.countDown();\n-            }\n-\n-            @Override\n-            public void onFailure(Exception e) {\n-                exceptionRef.set(e);\n-                latch.countDown();\n-            }\n-        };\n-\n-        action.masterOperation(task, request, clusterState, testListener);\n-\n-        // Wait for async operation to complete\n-        assertTrue(\"Operation should complete within timeout\", latch.await(5, TimeUnit.SECONDS));\n-\n-        // Verify results\n-        assertThat(responseRef.get(), nullValue());\n-        assertThat(exceptionRef.get(), not(nullValue()));\n-        assertThat(exceptionRef.get(), sameInstance(multipleIndicesException));\n-\n-        // Verify interactions\n-        verify(indexNameExpressionResolver).concreteIndexNames(clusterState, request);\n+        // Verify that setting multiple indices throws IllegalArgumentException\n+        IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, () -> request.indices(indexName1, indexName2));\n+        assertThat(exception.getMessage(), equalTo(\"[indices] must contain only one index\"));\n     }\n \n     /**\n",
  "additions": 18,
  "deletions": 55,
  "changed_files": 2,
  "url": "https://github.com/elastic/elasticsearch/pull/137067",
  "mined_at": "2025-10-25T13:35:21.140117"
}