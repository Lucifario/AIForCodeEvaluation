{
  "id": 136887,
  "repository": "elastic/elasticsearch",
  "title": "Include min transport version into FC response",
  "body": "This change includes min transport version into FC response (transport only).\r\nThis field can be beneficial for the consumer (such as ES|QL) that have behavior conditional on version of all indices data nodes.",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-24T09:29:24+00:00",
  "created_at": "2025-10-21T15:21:50+00:00",
  "updated_at": "2025-10-24T09:41:24+00:00",
  "author": "idegtiarenko",
  "reviewers": [
    "idegtiarenko",
    "piergm",
    "nik9000"
  ],
  "base_sha": "88d4704a9a48e0c58dcb16d7f6efac2612b12901",
  "head_sha": "fb75c5a9f71b3a1fe189ca9df66ae11d8b3e7621",
  "review_comments": [
    {
      "user": "nik9000",
      "state": "APPROVED",
      "body": "",
      "submitted_at": "2025-10-21T15:33:08+00:00"
    },
    {
      "user": "piergm",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-22T07:53:26+00:00"
    },
    {
      "user": "idegtiarenko",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-22T08:29:17+00:00"
    },
    {
      "user": "piergm",
      "state": "APPROVED",
      "body": "",
      "submitted_at": "2025-10-24T07:45:49+00:00"
    }
  ],
  "pr_comments": [
    {
      "user": "elasticsearchmachine",
      "body": "Pinging @elastic/es-search (Team:Search)",
      "created_at": "2025-10-21T15:22:16+00:00"
    },
    {
      "user": "elasticsearchmachine",
      "body": "## ðŸ’” Backport failed\nThe backport operation could not be completed due to the following error:\n```\nAn unhandled error occurred. Please consult the logs\n```\n\nYou can use [sqren/backport](https://github.com/sqren/backport) to manually backport by running `backport --upstream elastic/elasticsearch --pr 136887`",
      "created_at": "2025-10-24T09:30:28+00:00"
    }
  ],
  "files_changed": [
    {
      "filename": "server/src/internalClusterTest/java/org/elasticsearch/search/fieldcaps/CCSFieldCapabilitiesIT.java",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "patch": "@@ -10,6 +10,7 @@\n package org.elasticsearch.search.fieldcaps;\n \n import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.TransportVersion;\n import org.elasticsearch.action.fieldcaps.FieldCapabilitiesFailure;\n import org.elasticsearch.action.fieldcaps.FieldCapabilitiesResponse;\n import org.elasticsearch.client.internal.Client;\n@@ -266,4 +267,12 @@ public void testReturnAllLocal() {\n             }\n         }\n     }\n+\n+    public void testIncludesMinTransportVersion() {\n+        if (randomBoolean()) {\n+            assertAcked(client().admin().indices().prepareCreate(\"index\"));\n+        }\n+        var response = client().prepareFieldCaps(\"_all\").setFields(\"*\").get();\n+        assertThat(response.minTransportVersion(), equalTo(TransportVersion.current()));\n+    }\n }"
    },
    {
      "filename": "server/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesResponse.java",
      "status": "modified",
      "additions": 72,
      "deletions": 12,
      "changes": 84,
      "patch": "@@ -9,12 +9,14 @@\n \n package org.elasticsearch.action.fieldcaps;\n \n+import org.elasticsearch.TransportVersion;\n import org.elasticsearch.action.ActionResponse;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.collect.Iterators;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.common.xcontent.ChunkedToXContentObject;\n+import org.elasticsearch.core.Nullable;\n import org.elasticsearch.xcontent.ParseField;\n import org.elasticsearch.xcontent.ToXContent;\n \n@@ -30,6 +32,9 @@\n  * Response for {@link FieldCapabilitiesRequest} requests.\n  */\n public class FieldCapabilitiesResponse extends ActionResponse implements ChunkedToXContentObject {\n+\n+    private static final TransportVersion MIN_TRANSPORT_VERSION = TransportVersion.fromName(\"min_transport_version\");\n+\n     public static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n     public static final ParseField FIELDS_FIELD = new ParseField(\"fields\");\n     private static final ParseField FAILED_INDICES_FIELD = new ParseField(\"failed_indices\");\n@@ -39,40 +44,46 @@ public class FieldCapabilitiesResponse extends ActionResponse implements Chunked\n     private final Map<String, Map<String, FieldCapabilities>> fields;\n     private final List<FieldCapabilitiesFailure> failures;\n     private final List<FieldCapabilitiesIndexResponse> indexResponses;\n+    private final TransportVersion minTransportVersion;\n \n     public FieldCapabilitiesResponse(\n         String[] indices,\n         Map<String, Map<String, FieldCapabilities>> fields,\n         List<FieldCapabilitiesFailure> failures\n     ) {\n-        this(indices, fields, Collections.emptyList(), failures);\n+        this(indices, fields, Collections.emptyList(), failures, null);\n     }\n \n     public FieldCapabilitiesResponse(String[] indices, Map<String, Map<String, FieldCapabilities>> fields) {\n-        this(indices, fields, Collections.emptyList(), Collections.emptyList());\n+        this(indices, fields, Collections.emptyList(), Collections.emptyList(), null);\n     }\n \n     public FieldCapabilitiesResponse(List<FieldCapabilitiesIndexResponse> indexResponses, List<FieldCapabilitiesFailure> failures) {\n-        this(Strings.EMPTY_ARRAY, Collections.emptyMap(), indexResponses, failures);\n+        this(Strings.EMPTY_ARRAY, Collections.emptyMap(), indexResponses, failures, null);\n     }\n \n     private FieldCapabilitiesResponse(\n         String[] indices,\n         Map<String, Map<String, FieldCapabilities>> fields,\n         List<FieldCapabilitiesIndexResponse> indexResponses,\n-        List<FieldCapabilitiesFailure> failures\n+        List<FieldCapabilitiesFailure> failures,\n+        TransportVersion minTransportVersion\n     ) {\n         this.fields = Objects.requireNonNull(fields);\n         this.indexResponses = Objects.requireNonNull(indexResponses);\n         this.indices = indices;\n         this.failures = failures;\n+        this.minTransportVersion = minTransportVersion;\n     }\n \n     public FieldCapabilitiesResponse(StreamInput in) throws IOException {\n         this.indices = in.readStringArray();\n         this.fields = in.readMap(FieldCapabilitiesResponse::readField);\n         this.indexResponses = FieldCapabilitiesIndexResponse.readList(in);\n         this.failures = in.readCollectionAsList(FieldCapabilitiesFailure::new);\n+        this.minTransportVersion = in.getTransportVersion().supports(MIN_TRANSPORT_VERSION)\n+            ? in.readOptional(TransportVersion::readVersion)\n+            : null;\n     }\n \n     /**\n@@ -116,13 +127,20 @@ public List<FieldCapabilitiesIndexResponse> getIndexResponses() {\n     }\n \n     /**\n-     *\n      * Get the field capabilities per type for the provided {@code field}.\n      */\n     public Map<String, FieldCapabilities> getField(String field) {\n         return fields.get(field);\n     }\n \n+    /**\n+     * @return the minTransportVersion across all clusters involved in resolution\n+     */\n+    @Nullable\n+    public TransportVersion minTransportVersion() {\n+        return minTransportVersion;\n+    }\n+\n     /**\n      * Returns <code>true</code> if the provided field is a metadata field.\n      */\n@@ -144,6 +162,9 @@ public void writeTo(StreamOutput out) throws IOException {\n         out.writeMap(fields, FieldCapabilitiesResponse::writeField);\n         FieldCapabilitiesIndexResponse.writeList(out, indexResponses);\n         out.writeCollection(failures);\n+        if (out.getTransportVersion().supports(MIN_TRANSPORT_VERSION)) {\n+            out.writeOptional((Writer<TransportVersion>) (o, v) -> TransportVersion.writeVersion(v, o), minTransportVersion);\n+        }\n     }\n \n     private static void writeField(StreamOutput out, Map<String, FieldCapabilities> map) throws IOException {\n@@ -184,21 +205,60 @@ public boolean equals(Object o) {\n         return Arrays.equals(indices, that.indices)\n             && Objects.equals(fields, that.fields)\n             && Objects.equals(indexResponses, that.indexResponses)\n-            && Objects.equals(failures, that.failures);\n+            && Objects.equals(failures, that.failures)\n+            && Objects.equals(minTransportVersion, that.minTransportVersion);\n     }\n \n     @Override\n     public int hashCode() {\n-        int result = Objects.hash(fields, indexResponses, failures);\n-        result = 31 * result + Arrays.hashCode(indices);\n-        return result;\n+        return Objects.hash(fields, indexResponses, failures, minTransportVersion) * 31 + Arrays.hashCode(indices);\n     }\n \n     @Override\n     public String toString() {\n-        if (indexResponses.size() > 0) {\n-            return \"FieldCapabilitiesResponse{unmerged}\";\n+        return indexResponses.isEmpty() ? Strings.toString(this) : \"FieldCapabilitiesResponse{unmerged}\";\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static class Builder {\n+        private String[] indices = Strings.EMPTY_ARRAY;\n+        private Map<String, Map<String, FieldCapabilities>> fields = Collections.emptyMap();\n+        private List<FieldCapabilitiesIndexResponse> indexResponses = Collections.emptyList();\n+        private List<FieldCapabilitiesFailure> failures = Collections.emptyList();\n+        private TransportVersion minTransportVersion = null;\n+\n+        private Builder() {}\n+\n+        public Builder withIndices(String[] indices) {\n+            this.indices = indices;\n+            return this;\n+        }\n+\n+        public Builder withFields(Map<String, Map<String, FieldCapabilities>> fields) {\n+            this.fields = fields;\n+            return this;\n+        }\n+\n+        public Builder withIndexResponses(List<FieldCapabilitiesIndexResponse> indexResponses) {\n+            this.indexResponses = indexResponses;\n+            return this;\n+        }\n+\n+        public Builder withFailures(List<FieldCapabilitiesFailure> failures) {\n+            this.failures = failures;\n+            return this;\n+        }\n+\n+        public Builder withMinTransportVersion(TransportVersion minTransportVersion) {\n+            this.minTransportVersion = minTransportVersion;\n+            return this;\n+        }\n+\n+        public FieldCapabilitiesResponse build() {\n+            return new FieldCapabilitiesResponse(indices, fields, indexResponses, failures, minTransportVersion);\n         }\n-        return Strings.toString(this);\n     }\n }"
    },
    {
      "filename": "server/src/main/java/org/elasticsearch/action/fieldcaps/TransportFieldCapabilitiesAction.java",
      "status": "modified",
      "additions": 51,
      "deletions": 33,
      "changes": 84,
      "patch": "@@ -13,6 +13,7 @@\n import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n import org.elasticsearch.ElasticsearchTimeoutException;\n import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.TransportVersion;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.ActionListenerResponseHandler;\n import org.elasticsearch.action.ActionRunnable;\n@@ -69,6 +70,7 @@\n import java.util.Set;\n import java.util.concurrent.Executor;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.BiConsumer;\n import java.util.function.Consumer;\n import java.util.function.Function;\n@@ -144,22 +146,20 @@ private void doExecuteForked(Task task, FieldCapabilitiesRequest request, Action\n         final Executor singleThreadedExecutor = buildSingleThreadedExecutor(searchCoordinationExecutor, LOGGER);\n         assert task instanceof CancellableTask;\n         final CancellableTask fieldCapTask = (CancellableTask) task;\n-        // retrieve the initial timestamp in case the action is a cross cluster search\n+        // retrieve the initial timestamp in case the action is a cross-cluster search\n         long nowInMillis = request.nowInMillis() == null ? System.currentTimeMillis() : request.nowInMillis();\n         final ProjectState projectState = projectResolver.getProjectState(clusterService.state());\n+        final var minTransportVersion = new AtomicReference<>(clusterService.state().getMinTransportVersion());\n         final Map<String, OriginalIndices> remoteClusterIndices = transportService.getRemoteClusterService()\n             .groupIndices(request.indicesOptions(), request.indices(), request.returnLocalAll());\n         final OriginalIndices localIndices = remoteClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n-        final String[] concreteIndices;\n-        if (localIndices == null) {\n-            // in the case we have one or more remote indices but no local we don't expand to all local indices and just do remote indices\n-            concreteIndices = Strings.EMPTY_ARRAY;\n-        } else {\n-            concreteIndices = indexNameExpressionResolver.concreteIndexNames(projectState.metadata(), localIndices);\n-        }\n+        // in the case we have one or more remote indices but no local we don't expand to all local indices and just do remote indices\n+        final String[] concreteIndices = localIndices != null\n+            ? indexNameExpressionResolver.concreteIndexNames(projectState.metadata(), localIndices)\n+            : Strings.EMPTY_ARRAY;\n \n         if (concreteIndices.length == 0 && remoteClusterIndices.isEmpty()) {\n-            listener.onResponse(new FieldCapabilitiesResponse(new String[0], Collections.emptyMap()));\n+            listener.onResponse(FieldCapabilitiesResponse.builder().withMinTransportVersion(minTransportVersion.get()).build());\n             return;\n         }\n \n@@ -235,7 +235,7 @@ private void doExecuteForked(Task task, FieldCapabilitiesRequest request, Action\n             if (fieldCapTask.notifyIfCancelled(listener)) {\n                 releaseResourcesOnCancel.run();\n             } else {\n-                mergeIndexResponses(request, fieldCapTask, indexResponses, indexFailures, listener);\n+                mergeIndexResponses(request, fieldCapTask, indexResponses, indexFailures, minTransportVersion, listener);\n             }\n         })) {\n             // local cluster\n@@ -281,6 +281,12 @@ private void doExecuteForked(Task task, FieldCapabilitiesRequest request, Action\n                             handleIndexFailure.accept(RemoteClusterAware.buildRemoteIndexName(clusterAlias, index), ex);\n                         }\n                     }\n+                    minTransportVersion.accumulateAndGet(response.minTransportVersion(), (lhs, rhs) -> {\n+                        if (lhs == null || rhs == null) {\n+                            return null;\n+                        }\n+                        return TransportVersion.min(lhs, rhs);\n+                    });\n                 }, ex -> {\n                     for (String index : originalIndices.indices()) {\n                         handleIndexFailure.accept(RemoteClusterAware.buildRemoteIndexName(clusterAlias, index), ex);\n@@ -360,35 +366,41 @@ private static void mergeIndexResponses(\n         CancellableTask task,\n         Map<String, FieldCapabilitiesIndexResponse> indexResponses,\n         FailureCollector indexFailures,\n+        AtomicReference<TransportVersion> minTransportVersion,\n         ActionListener<FieldCapabilitiesResponse> listener\n     ) {\n         List<FieldCapabilitiesFailure> failures = indexFailures.build(indexResponses.keySet());\n-        if (indexResponses.size() > 0) {\n+        if (indexResponses.isEmpty() == false) {\n             if (request.isMergeResults()) {\n-                ActionListener.completeWith(listener, () -> merge(indexResponses, task, request, failures));\n+                ActionListener.completeWith(listener, () -> merge(indexResponses, task, request, failures, minTransportVersion));\n             } else {\n-                listener.onResponse(new FieldCapabilitiesResponse(new ArrayList<>(indexResponses.values()), failures));\n+                listener.onResponse(\n+                    FieldCapabilitiesResponse.builder()\n+                        .withIndexResponses(new ArrayList<>(indexResponses.values()))\n+                        .withFailures(failures)\n+                        .withMinTransportVersion(minTransportVersion.get())\n+                        .build()\n+                );\n             }\n-        } else {\n-            // we have no responses at all, maybe because of errors\n-            if (indexFailures.isEmpty() == false) {\n-                /*\n-                 * Under no circumstances are we to pass timeout errors originating from SubscribableListener as top-level errors.\n-                 * Instead, they should always be passed through the response object, as part of \"failures\".\n-                 */\n-                if (failures.stream()\n-                    .anyMatch(\n-                        failure -> failure.getException() instanceof IllegalStateException ise\n-                            && ise.getCause() instanceof ElasticsearchTimeoutException\n-                    )) {\n-                    listener.onResponse(new FieldCapabilitiesResponse(Collections.emptyList(), failures));\n-                } else {\n-                    // throw back the first exception\n-                    listener.onFailure(failures.get(0).getException());\n-                }\n+        } else if (indexFailures.isEmpty() == false) {\n+            /*\n+             * Under no circumstances are we to pass timeout errors originating from SubscribableListener as top-level errors.\n+             * Instead, they should always be passed through the response object, as part of \"failures\".\n+             */\n+            if (failures.stream()\n+                .anyMatch(\n+                    failure -> failure.getException() instanceof IllegalStateException ise\n+                        && ise.getCause() instanceof ElasticsearchTimeoutException\n+                )) {\n+                listener.onResponse(\n+                    FieldCapabilitiesResponse.builder().withFailures(failures).withMinTransportVersion(minTransportVersion.get()).build()\n+                );\n             } else {\n-                listener.onResponse(new FieldCapabilitiesResponse(Collections.emptyList(), Collections.emptyList()));\n+                // throw back the first exception\n+                listener.onFailure(failures.get(0).getException());\n             }\n+        } else {\n+            listener.onResponse(FieldCapabilitiesResponse.builder().withMinTransportVersion(minTransportVersion.get()).build());\n         }\n     }\n \n@@ -423,7 +435,8 @@ private static FieldCapabilitiesResponse merge(\n         Map<String, FieldCapabilitiesIndexResponse> indexResponsesMap,\n         CancellableTask task,\n         FieldCapabilitiesRequest request,\n-        List<FieldCapabilitiesFailure> failures\n+        List<FieldCapabilitiesFailure> failures,\n+        AtomicReference<TransportVersion> minTransportVersion\n     ) {\n         assert ThreadPool.assertCurrentThreadPool(ThreadPool.Names.SEARCH_COORDINATION); // too expensive to run this on a transport worker\n         task.ensureNotCancelled();\n@@ -464,7 +477,12 @@ private static FieldCapabilitiesResponse merge(\n                 );\n             }\n         }\n-        return new FieldCapabilitiesResponse(indices, Collections.unmodifiableMap(fields), failures);\n+        return FieldCapabilitiesResponse.builder()\n+            .withIndices(indices)\n+            .withFields(Collections.unmodifiableMap(fields))\n+            .withFailures(failures)\n+            .withMinTransportVersion(minTransportVersion.get())\n+            .build();\n     }\n \n     private static boolean shouldLogException(Exception e) {"
    },
    {
      "filename": "server/src/main/resources/transport/definitions/referable/min_transport_version.csv",
      "status": "added",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "patch": "@@ -0,0 +1 @@\n+9202000,9185004"
    },
    {
      "filename": "server/src/main/resources/transport/upper_bounds/9.2.csv",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -1 +1 @@\n-initial_9.2.1,9185003\n+min_transport_version,9185004"
    },
    {
      "filename": "server/src/main/resources/transport/upper_bounds/9.3.csv",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -1 +1 @@\n-esql_lookup_join_full_text_function,9201000\n+min_transport_version,9202000"
    }
  ],
  "diff": "diff --git a/server/src/internalClusterTest/java/org/elasticsearch/search/fieldcaps/CCSFieldCapabilitiesIT.java b/server/src/internalClusterTest/java/org/elasticsearch/search/fieldcaps/CCSFieldCapabilitiesIT.java\nindex 541fe0f869f26..650fad8a496ad 100644\n--- a/server/src/internalClusterTest/java/org/elasticsearch/search/fieldcaps/CCSFieldCapabilitiesIT.java\n+++ b/server/src/internalClusterTest/java/org/elasticsearch/search/fieldcaps/CCSFieldCapabilitiesIT.java\n@@ -10,6 +10,7 @@\n package org.elasticsearch.search.fieldcaps;\n \n import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.TransportVersion;\n import org.elasticsearch.action.fieldcaps.FieldCapabilitiesFailure;\n import org.elasticsearch.action.fieldcaps.FieldCapabilitiesResponse;\n import org.elasticsearch.client.internal.Client;\n@@ -266,4 +267,12 @@ public void testReturnAllLocal() {\n             }\n         }\n     }\n+\n+    public void testIncludesMinTransportVersion() {\n+        if (randomBoolean()) {\n+            assertAcked(client().admin().indices().prepareCreate(\"index\"));\n+        }\n+        var response = client().prepareFieldCaps(\"_all\").setFields(\"*\").get();\n+        assertThat(response.minTransportVersion(), equalTo(TransportVersion.current()));\n+    }\n }\ndiff --git a/server/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesResponse.java b/server/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesResponse.java\nindex e3fcd5bbd200d..4dd20f8db1a89 100644\n--- a/server/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesResponse.java\n+++ b/server/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesResponse.java\n@@ -9,12 +9,14 @@\n \n package org.elasticsearch.action.fieldcaps;\n \n+import org.elasticsearch.TransportVersion;\n import org.elasticsearch.action.ActionResponse;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.collect.Iterators;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.common.xcontent.ChunkedToXContentObject;\n+import org.elasticsearch.core.Nullable;\n import org.elasticsearch.xcontent.ParseField;\n import org.elasticsearch.xcontent.ToXContent;\n \n@@ -30,6 +32,9 @@\n  * Response for {@link FieldCapabilitiesRequest} requests.\n  */\n public class FieldCapabilitiesResponse extends ActionResponse implements ChunkedToXContentObject {\n+\n+    private static final TransportVersion MIN_TRANSPORT_VERSION = TransportVersion.fromName(\"min_transport_version\");\n+\n     public static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n     public static final ParseField FIELDS_FIELD = new ParseField(\"fields\");\n     private static final ParseField FAILED_INDICES_FIELD = new ParseField(\"failed_indices\");\n@@ -39,33 +44,36 @@ public class FieldCapabilitiesResponse extends ActionResponse implements Chunked\n     private final Map<String, Map<String, FieldCapabilities>> fields;\n     private final List<FieldCapabilitiesFailure> failures;\n     private final List<FieldCapabilitiesIndexResponse> indexResponses;\n+    private final TransportVersion minTransportVersion;\n \n     public FieldCapabilitiesResponse(\n         String[] indices,\n         Map<String, Map<String, FieldCapabilities>> fields,\n         List<FieldCapabilitiesFailure> failures\n     ) {\n-        this(indices, fields, Collections.emptyList(), failures);\n+        this(indices, fields, Collections.emptyList(), failures, null);\n     }\n \n     public FieldCapabilitiesResponse(String[] indices, Map<String, Map<String, FieldCapabilities>> fields) {\n-        this(indices, fields, Collections.emptyList(), Collections.emptyList());\n+        this(indices, fields, Collections.emptyList(), Collections.emptyList(), null);\n     }\n \n     public FieldCapabilitiesResponse(List<FieldCapabilitiesIndexResponse> indexResponses, List<FieldCapabilitiesFailure> failures) {\n-        this(Strings.EMPTY_ARRAY, Collections.emptyMap(), indexResponses, failures);\n+        this(Strings.EMPTY_ARRAY, Collections.emptyMap(), indexResponses, failures, null);\n     }\n \n     private FieldCapabilitiesResponse(\n         String[] indices,\n         Map<String, Map<String, FieldCapabilities>> fields,\n         List<FieldCapabilitiesIndexResponse> indexResponses,\n-        List<FieldCapabilitiesFailure> failures\n+        List<FieldCapabilitiesFailure> failures,\n+        TransportVersion minTransportVersion\n     ) {\n         this.fields = Objects.requireNonNull(fields);\n         this.indexResponses = Objects.requireNonNull(indexResponses);\n         this.indices = indices;\n         this.failures = failures;\n+        this.minTransportVersion = minTransportVersion;\n     }\n \n     public FieldCapabilitiesResponse(StreamInput in) throws IOException {\n@@ -73,6 +81,9 @@ public FieldCapabilitiesResponse(StreamInput in) throws IOException {\n         this.fields = in.readMap(FieldCapabilitiesResponse::readField);\n         this.indexResponses = FieldCapabilitiesIndexResponse.readList(in);\n         this.failures = in.readCollectionAsList(FieldCapabilitiesFailure::new);\n+        this.minTransportVersion = in.getTransportVersion().supports(MIN_TRANSPORT_VERSION)\n+            ? in.readOptional(TransportVersion::readVersion)\n+            : null;\n     }\n \n     /**\n@@ -116,13 +127,20 @@ public List<FieldCapabilitiesIndexResponse> getIndexResponses() {\n     }\n \n     /**\n-     *\n      * Get the field capabilities per type for the provided {@code field}.\n      */\n     public Map<String, FieldCapabilities> getField(String field) {\n         return fields.get(field);\n     }\n \n+    /**\n+     * @return the minTransportVersion across all clusters involved in resolution\n+     */\n+    @Nullable\n+    public TransportVersion minTransportVersion() {\n+        return minTransportVersion;\n+    }\n+\n     /**\n      * Returns <code>true</code> if the provided field is a metadata field.\n      */\n@@ -144,6 +162,9 @@ public void writeTo(StreamOutput out) throws IOException {\n         out.writeMap(fields, FieldCapabilitiesResponse::writeField);\n         FieldCapabilitiesIndexResponse.writeList(out, indexResponses);\n         out.writeCollection(failures);\n+        if (out.getTransportVersion().supports(MIN_TRANSPORT_VERSION)) {\n+            out.writeOptional((Writer<TransportVersion>) (o, v) -> TransportVersion.writeVersion(v, o), minTransportVersion);\n+        }\n     }\n \n     private static void writeField(StreamOutput out, Map<String, FieldCapabilities> map) throws IOException {\n@@ -184,21 +205,60 @@ public boolean equals(Object o) {\n         return Arrays.equals(indices, that.indices)\n             && Objects.equals(fields, that.fields)\n             && Objects.equals(indexResponses, that.indexResponses)\n-            && Objects.equals(failures, that.failures);\n+            && Objects.equals(failures, that.failures)\n+            && Objects.equals(minTransportVersion, that.minTransportVersion);\n     }\n \n     @Override\n     public int hashCode() {\n-        int result = Objects.hash(fields, indexResponses, failures);\n-        result = 31 * result + Arrays.hashCode(indices);\n-        return result;\n+        return Objects.hash(fields, indexResponses, failures, minTransportVersion) * 31 + Arrays.hashCode(indices);\n     }\n \n     @Override\n     public String toString() {\n-        if (indexResponses.size() > 0) {\n-            return \"FieldCapabilitiesResponse{unmerged}\";\n+        return indexResponses.isEmpty() ? Strings.toString(this) : \"FieldCapabilitiesResponse{unmerged}\";\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static class Builder {\n+        private String[] indices = Strings.EMPTY_ARRAY;\n+        private Map<String, Map<String, FieldCapabilities>> fields = Collections.emptyMap();\n+        private List<FieldCapabilitiesIndexResponse> indexResponses = Collections.emptyList();\n+        private List<FieldCapabilitiesFailure> failures = Collections.emptyList();\n+        private TransportVersion minTransportVersion = null;\n+\n+        private Builder() {}\n+\n+        public Builder withIndices(String[] indices) {\n+            this.indices = indices;\n+            return this;\n+        }\n+\n+        public Builder withFields(Map<String, Map<String, FieldCapabilities>> fields) {\n+            this.fields = fields;\n+            return this;\n+        }\n+\n+        public Builder withIndexResponses(List<FieldCapabilitiesIndexResponse> indexResponses) {\n+            this.indexResponses = indexResponses;\n+            return this;\n+        }\n+\n+        public Builder withFailures(List<FieldCapabilitiesFailure> failures) {\n+            this.failures = failures;\n+            return this;\n+        }\n+\n+        public Builder withMinTransportVersion(TransportVersion minTransportVersion) {\n+            this.minTransportVersion = minTransportVersion;\n+            return this;\n+        }\n+\n+        public FieldCapabilitiesResponse build() {\n+            return new FieldCapabilitiesResponse(indices, fields, indexResponses, failures, minTransportVersion);\n         }\n-        return Strings.toString(this);\n     }\n }\ndiff --git a/server/src/main/java/org/elasticsearch/action/fieldcaps/TransportFieldCapabilitiesAction.java b/server/src/main/java/org/elasticsearch/action/fieldcaps/TransportFieldCapabilitiesAction.java\nindex 1228c2d616b09..3faba2fc48f6b 100644\n--- a/server/src/main/java/org/elasticsearch/action/fieldcaps/TransportFieldCapabilitiesAction.java\n+++ b/server/src/main/java/org/elasticsearch/action/fieldcaps/TransportFieldCapabilitiesAction.java\n@@ -13,6 +13,7 @@\n import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n import org.elasticsearch.ElasticsearchTimeoutException;\n import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.TransportVersion;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.ActionListenerResponseHandler;\n import org.elasticsearch.action.ActionRunnable;\n@@ -69,6 +70,7 @@\n import java.util.Set;\n import java.util.concurrent.Executor;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.BiConsumer;\n import java.util.function.Consumer;\n import java.util.function.Function;\n@@ -144,22 +146,20 @@ private void doExecuteForked(Task task, FieldCapabilitiesRequest request, Action\n         final Executor singleThreadedExecutor = buildSingleThreadedExecutor(searchCoordinationExecutor, LOGGER);\n         assert task instanceof CancellableTask;\n         final CancellableTask fieldCapTask = (CancellableTask) task;\n-        // retrieve the initial timestamp in case the action is a cross cluster search\n+        // retrieve the initial timestamp in case the action is a cross-cluster search\n         long nowInMillis = request.nowInMillis() == null ? System.currentTimeMillis() : request.nowInMillis();\n         final ProjectState projectState = projectResolver.getProjectState(clusterService.state());\n+        final var minTransportVersion = new AtomicReference<>(clusterService.state().getMinTransportVersion());\n         final Map<String, OriginalIndices> remoteClusterIndices = transportService.getRemoteClusterService()\n             .groupIndices(request.indicesOptions(), request.indices(), request.returnLocalAll());\n         final OriginalIndices localIndices = remoteClusterIndices.remove(RemoteClusterAware.LOCAL_CLUSTER_GROUP_KEY);\n-        final String[] concreteIndices;\n-        if (localIndices == null) {\n-            // in the case we have one or more remote indices but no local we don't expand to all local indices and just do remote indices\n-            concreteIndices = Strings.EMPTY_ARRAY;\n-        } else {\n-            concreteIndices = indexNameExpressionResolver.concreteIndexNames(projectState.metadata(), localIndices);\n-        }\n+        // in the case we have one or more remote indices but no local we don't expand to all local indices and just do remote indices\n+        final String[] concreteIndices = localIndices != null\n+            ? indexNameExpressionResolver.concreteIndexNames(projectState.metadata(), localIndices)\n+            : Strings.EMPTY_ARRAY;\n \n         if (concreteIndices.length == 0 && remoteClusterIndices.isEmpty()) {\n-            listener.onResponse(new FieldCapabilitiesResponse(new String[0], Collections.emptyMap()));\n+            listener.onResponse(FieldCapabilitiesResponse.builder().withMinTransportVersion(minTransportVersion.get()).build());\n             return;\n         }\n \n@@ -235,7 +235,7 @@ private void doExecuteForked(Task task, FieldCapabilitiesRequest request, Action\n             if (fieldCapTask.notifyIfCancelled(listener)) {\n                 releaseResourcesOnCancel.run();\n             } else {\n-                mergeIndexResponses(request, fieldCapTask, indexResponses, indexFailures, listener);\n+                mergeIndexResponses(request, fieldCapTask, indexResponses, indexFailures, minTransportVersion, listener);\n             }\n         })) {\n             // local cluster\n@@ -281,6 +281,12 @@ private void doExecuteForked(Task task, FieldCapabilitiesRequest request, Action\n                             handleIndexFailure.accept(RemoteClusterAware.buildRemoteIndexName(clusterAlias, index), ex);\n                         }\n                     }\n+                    minTransportVersion.accumulateAndGet(response.minTransportVersion(), (lhs, rhs) -> {\n+                        if (lhs == null || rhs == null) {\n+                            return null;\n+                        }\n+                        return TransportVersion.min(lhs, rhs);\n+                    });\n                 }, ex -> {\n                     for (String index : originalIndices.indices()) {\n                         handleIndexFailure.accept(RemoteClusterAware.buildRemoteIndexName(clusterAlias, index), ex);\n@@ -360,35 +366,41 @@ private static void mergeIndexResponses(\n         CancellableTask task,\n         Map<String, FieldCapabilitiesIndexResponse> indexResponses,\n         FailureCollector indexFailures,\n+        AtomicReference<TransportVersion> minTransportVersion,\n         ActionListener<FieldCapabilitiesResponse> listener\n     ) {\n         List<FieldCapabilitiesFailure> failures = indexFailures.build(indexResponses.keySet());\n-        if (indexResponses.size() > 0) {\n+        if (indexResponses.isEmpty() == false) {\n             if (request.isMergeResults()) {\n-                ActionListener.completeWith(listener, () -> merge(indexResponses, task, request, failures));\n+                ActionListener.completeWith(listener, () -> merge(indexResponses, task, request, failures, minTransportVersion));\n             } else {\n-                listener.onResponse(new FieldCapabilitiesResponse(new ArrayList<>(indexResponses.values()), failures));\n+                listener.onResponse(\n+                    FieldCapabilitiesResponse.builder()\n+                        .withIndexResponses(new ArrayList<>(indexResponses.values()))\n+                        .withFailures(failures)\n+                        .withMinTransportVersion(minTransportVersion.get())\n+                        .build()\n+                );\n             }\n-        } else {\n-            // we have no responses at all, maybe because of errors\n-            if (indexFailures.isEmpty() == false) {\n-                /*\n-                 * Under no circumstances are we to pass timeout errors originating from SubscribableListener as top-level errors.\n-                 * Instead, they should always be passed through the response object, as part of \"failures\".\n-                 */\n-                if (failures.stream()\n-                    .anyMatch(\n-                        failure -> failure.getException() instanceof IllegalStateException ise\n-                            && ise.getCause() instanceof ElasticsearchTimeoutException\n-                    )) {\n-                    listener.onResponse(new FieldCapabilitiesResponse(Collections.emptyList(), failures));\n-                } else {\n-                    // throw back the first exception\n-                    listener.onFailure(failures.get(0).getException());\n-                }\n+        } else if (indexFailures.isEmpty() == false) {\n+            /*\n+             * Under no circumstances are we to pass timeout errors originating from SubscribableListener as top-level errors.\n+             * Instead, they should always be passed through the response object, as part of \"failures\".\n+             */\n+            if (failures.stream()\n+                .anyMatch(\n+                    failure -> failure.getException() instanceof IllegalStateException ise\n+                        && ise.getCause() instanceof ElasticsearchTimeoutException\n+                )) {\n+                listener.onResponse(\n+                    FieldCapabilitiesResponse.builder().withFailures(failures).withMinTransportVersion(minTransportVersion.get()).build()\n+                );\n             } else {\n-                listener.onResponse(new FieldCapabilitiesResponse(Collections.emptyList(), Collections.emptyList()));\n+                // throw back the first exception\n+                listener.onFailure(failures.get(0).getException());\n             }\n+        } else {\n+            listener.onResponse(FieldCapabilitiesResponse.builder().withMinTransportVersion(minTransportVersion.get()).build());\n         }\n     }\n \n@@ -423,7 +435,8 @@ private static FieldCapabilitiesResponse merge(\n         Map<String, FieldCapabilitiesIndexResponse> indexResponsesMap,\n         CancellableTask task,\n         FieldCapabilitiesRequest request,\n-        List<FieldCapabilitiesFailure> failures\n+        List<FieldCapabilitiesFailure> failures,\n+        AtomicReference<TransportVersion> minTransportVersion\n     ) {\n         assert ThreadPool.assertCurrentThreadPool(ThreadPool.Names.SEARCH_COORDINATION); // too expensive to run this on a transport worker\n         task.ensureNotCancelled();\n@@ -464,7 +477,12 @@ private static FieldCapabilitiesResponse merge(\n                 );\n             }\n         }\n-        return new FieldCapabilitiesResponse(indices, Collections.unmodifiableMap(fields), failures);\n+        return FieldCapabilitiesResponse.builder()\n+            .withIndices(indices)\n+            .withFields(Collections.unmodifiableMap(fields))\n+            .withFailures(failures)\n+            .withMinTransportVersion(minTransportVersion.get())\n+            .build();\n     }\n \n     private static boolean shouldLogException(Exception e) {\ndiff --git a/server/src/main/resources/transport/definitions/referable/min_transport_version.csv b/server/src/main/resources/transport/definitions/referable/min_transport_version.csv\nnew file mode 100644\nindex 0000000000000..9f305d6018a4d\n--- /dev/null\n+++ b/server/src/main/resources/transport/definitions/referable/min_transport_version.csv\n@@ -0,0 +1 @@\n+9202000,9185004\ndiff --git a/server/src/main/resources/transport/upper_bounds/9.2.csv b/server/src/main/resources/transport/upper_bounds/9.2.csv\nindex 803cdb78f8651..e3c62345bb99a 100644\n--- a/server/src/main/resources/transport/upper_bounds/9.2.csv\n+++ b/server/src/main/resources/transport/upper_bounds/9.2.csv\n@@ -1 +1 @@\n-initial_9.2.1,9185003\n+min_transport_version,9185004\ndiff --git a/server/src/main/resources/transport/upper_bounds/9.3.csv b/server/src/main/resources/transport/upper_bounds/9.3.csv\nindex 238cf894d79b4..a3e52d8099898 100644\n--- a/server/src/main/resources/transport/upper_bounds/9.3.csv\n+++ b/server/src/main/resources/transport/upper_bounds/9.3.csv\n@@ -1 +1 @@\n-esql_lookup_join_full_text_function,9201000\n+min_transport_version,9202000\n",
  "additions": 135,
  "deletions": 47,
  "changed_files": 6,
  "url": "https://github.com/elastic/elasticsearch/pull/136887",
  "mined_at": "2025-10-25T13:32:30.408010"
}