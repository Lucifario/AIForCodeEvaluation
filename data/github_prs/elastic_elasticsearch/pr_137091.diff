diff --git a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/RestrictedBuildApiService.java b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/RestrictedBuildApiService.java
index 4e9f08bc48f38..11290cb64afdb 100644
--- a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/RestrictedBuildApiService.java
+++ b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/RestrictedBuildApiService.java
@@ -61,9 +61,6 @@ private static ListMultimap<Class<?>, String> createLegacyRestTestBasePluginUsag
         map.put(LegacyRestTestBasePlugin.class, ":x-pack:plugin:eql:qa:correctness");
         map.put(LegacyRestTestBasePlugin.class, ":x-pack:plugin:eql:qa:mixed-node");
         map.put(LegacyRestTestBasePlugin.class, ":x-pack:plugin:identity-provider:qa:idp-rest-tests");
-        map.put(LegacyRestTestBasePlugin.class, ":x-pack:plugin:ilm:qa:multi-cluster");
-        map.put(LegacyRestTestBasePlugin.class, ":x-pack:plugin:ilm:qa:multi-node");
-        map.put(LegacyRestTestBasePlugin.class, ":x-pack:plugin:ilm:qa:rest");
         map.put(LegacyRestTestBasePlugin.class, ":x-pack:plugin:ml:qa:basic-multi-node");
         map.put(LegacyRestTestBasePlugin.class, ":x-pack:plugin:ml:qa:disabled");
         map.put(LegacyRestTestBasePlugin.class, ":x-pack:plugin:ml:qa:ml-with-security");
diff --git a/test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java b/test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java
index 02c823bfde6c9..c9f1b7c28c528 100644
--- a/test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java
+++ b/test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java
@@ -2552,6 +2552,7 @@ public static Optional<Version> parseLegacyVersion(String version) {
     protected static void waitForActiveLicense(final RestClient restClient) throws Exception {
         assertBusy(() -> {
             final Request request = new Request(HttpGet.METHOD_NAME, "/_xpack");
+            request.addParameter("categories", "license");
             request.setOptions(RequestOptions.DEFAULT.toBuilder());
 
             final Response response = restClient.performRequest(request);
diff --git a/x-pack/plugin/ilm/qa/multi-cluster/build.gradle b/x-pack/plugin/ilm/qa/multi-cluster/build.gradle
index eede706b5d403..a7e3d3b7515e9 100644
--- a/x-pack/plugin/ilm/qa/multi-cluster/build.gradle
+++ b/x-pack/plugin/ilm/qa/multi-cluster/build.gradle
@@ -1,62 +1,24 @@
-import org.elasticsearch.gradle.internal.test.RestIntegTestTask
-import org.elasticsearch.gradle.internal.info.BuildParams
-import static org.elasticsearch.gradle.PropertyNormalization.IGNORE_VALUE
+/*
+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
+ * or more contributor license agreements. Licensed under the Elastic License
+ * 2.0; you may not use this file except in compliance with the Elastic License
+ * 2.0.
+ */
 
-apply plugin: 'elasticsearch.internal-testclusters'
-apply plugin: 'elasticsearch.standalone-rest-test'
+apply plugin: 'elasticsearch.internal-java-rest-test'
 
 dependencies {
-  testImplementation project(':x-pack:plugin:core')
-  testImplementation project(':x-pack:plugin:ilm')
+  javaRestTestImplementation(testArtifact(project(xpackModule('core'))))
+  javaRestTestImplementation(testArtifact(project(xpackModule('ccr')), 'javaRestTest'))
+  javaRestTestImplementation project(xpackModule('ilm'))
+
+  clusterModules project(xpackModule('ilm'))
+  clusterModules project(xpackModule('ccr'))
+  clusterModules project(xpackModule('searchable-snapshots'))
+  clusterModules project(':modules:data-streams')
 }
 
-File repoDir = file("$buildDir/testclusters/repo")
-
-tasks.register('leader-cluster', RestIntegTestTask) {
-  mustRunAfter("precommit")
-    systemProperty 'tests.target_cluster', 'leader'
-    /* To support taking index snapshots, we have to set path.repo setting */
-    nonInputProperties.systemProperty 'tests.path.repo', repoDir.absolutePath
-}
-
-testClusters.matching { it.name == 'leader-cluster' }.configureEach {
-  testDistribution = 'DEFAULT'
-  setting 'path.repo', repoDir.absolutePath, IGNORE_VALUE
-  setting 'xpack.ccr.enabled', 'true'
-  setting 'xpack.security.enabled', 'false'
-  setting 'xpack.watcher.enabled', 'false'
-  setting 'xpack.ml.enabled', 'false'
-  setting 'xpack.license.self_generated.type', 'trial'
-  setting 'indices.lifecycle.poll_interval', '1000ms'
-}
-
-tasks.register('follow-cluster', RestIntegTestTask) {
-  dependsOn tasks.findByName('leader-cluster')
-  useCluster testClusters.named('leader-cluster')
-  systemProperty 'tests.target_cluster', 'follow'
-  nonInputProperties.systemProperty 'tests.leader_host',
-    "${-> testClusters."leader-cluster".getAllHttpSocketURI().get(0)}"
-  nonInputProperties.systemProperty 'tests.leader_remote_cluster_seed',
-    "${-> testClusters.'leader-cluster'.getAllTransportPortURI().get(0)}"
-  /* To support taking index snapshots, we have to set path.repo setting */
-  nonInputProperties.systemProperty 'tests.path.repo', repoDir.absolutePath
-}
-
-testClusters.matching{ it.name == 'follow-cluster' }.configureEach {
-  testDistribution = 'DEFAULT'
-  setting 'path.repo', repoDir.absolutePath, IGNORE_VALUE
-  setting 'xpack.ccr.enabled', 'true'
-  setting 'xpack.security.enabled', 'false'
-  setting 'xpack.watcher.enabled', 'false'
-  setting 'xpack.ml.enabled', 'false'
-  setting 'xpack.license.self_generated.type', 'trial'
-  setting 'indices.lifecycle.poll_interval', '1000ms'
-  setting 'cluster.remote.leader_cluster.seeds',
-    { "\"${testClusters.'leader-cluster'.getAllTransportPortURI().get(0)}\"" }, IGNORE_VALUE
-}
-
-tasks.named("check").configure { dependsOn 'follow-cluster' }
-// Security is explicitly disabled for follow-cluster and leader-cluster, do not run these in FIPS mode
-tasks.withType(Test).configureEach {
-  enabled = buildParams.inFipsJvm == false
+tasks.named("javaRestTest") {
+  // Security is explicitly disabled for follow-cluster and leader-cluster, do not run these in FIPS mode
+  buildParams.withFipsEnabledOnly(it)
 }
diff --git a/x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java b/x-pack/plugin/ilm/qa/multi-cluster/src/javaRestTest/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java
similarity index 93%
rename from x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java
rename to x-pack/plugin/ilm/qa/multi-cluster/src/javaRestTest/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java
index 0b26c0c323abe..72e59c08cb69f 100644
--- a/x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java
+++ b/x-pack/plugin/ilm/qa/multi-cluster/src/javaRestTest/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java
@@ -6,6 +6,9 @@
  */
 package org.elasticsearch.xpack.ilm;
 
+import com.carrotsearch.randomizedtesting.annotations.Name;
+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;
+
 import org.apache.http.entity.ContentType;
 import org.apache.http.entity.StringEntity;
 import org.apache.http.util.EntityUtils;
@@ -22,15 +25,20 @@
 import org.elasticsearch.common.xcontent.XContentHelper;
 import org.elasticsearch.core.TimeValue;
 import org.elasticsearch.rest.RestStatus;
+import org.elasticsearch.test.cluster.ElasticsearchCluster;
 import org.elasticsearch.xcontent.ObjectPath;
 import org.elasticsearch.xcontent.XContentBuilder;
 import org.elasticsearch.xcontent.XContentType;
 import org.elasticsearch.xcontent.json.JsonXContent;
+import org.elasticsearch.xpack.ccr.AbstractCCRRestTestCase;
 import org.elasticsearch.xpack.core.ilm.LifecycleAction;
 import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;
 import org.elasticsearch.xpack.core.ilm.Phase;
 import org.elasticsearch.xpack.core.ilm.UnfollowAction;
 import org.elasticsearch.xpack.core.ilm.WaitUntilTimeSeriesEndTimePassesStep;
+import org.junit.ClassRule;
+import org.junit.rules.RuleChain;
+import org.junit.rules.TemporaryFolder;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -50,7 +58,7 @@
 import static org.hamcrest.Matchers.notNullValue;
 import static org.hamcrest.Matchers.nullValue;
 
-public class CCRIndexLifecycleIT extends ESCCRRestTestCase {
+public class CCRIndexLifecycleIT extends AbstractCCRRestTestCase {
 
     private static final Logger LOGGER = LogManager.getLogger(CCRIndexLifecycleIT.class);
     private static final String TSDB_INDEX_TEMPLATE = """
@@ -85,18 +93,69 @@ public class CCRIndexLifecycleIT extends ESCCRRestTestCase {
             }
         }""";
 
+    public static TemporaryFolder repoDir = new TemporaryFolder();
+
+    public static ElasticsearchCluster leaderCluster = ElasticsearchCluster.local()
+        .name("leader")
+        .module("x-pack-ilm")
+        .module("x-pack-ccr")
+        .module("searchable-snapshots")
+        .module("data-streams")
+        .setting("path.repo", () -> repoDir.getRoot().getAbsolutePath())
+        .setting("xpack.ccr.enabled", "true")
+        .setting("xpack.security.enabled", "false")
+        .setting("xpack.license.self_generated.type", "trial")
+        .setting("indices.lifecycle.poll_interval", "1000ms")
+        .build();
+
+    public static ElasticsearchCluster followerCluster = ElasticsearchCluster.local()
+        .name("follower")
+        .module("x-pack-ilm")
+        .module("x-pack-ccr")
+        .module("searchable-snapshots")
+        .module("data-streams")
+        .setting("path.repo", () -> repoDir.getRoot().getAbsolutePath())
+        .setting("xpack.ccr.enabled", "true")
+        .setting("xpack.security.enabled", "false")
+        .setting("xpack.license.self_generated.type", "trial")
+        .setting("indices.lifecycle.poll_interval", "1000ms")
+        .setting("cluster.remote.leader_cluster.seeds", () -> "\"" + leaderCluster.getTransportEndpoints() + "\"")
+        .build();
+
+    @ClassRule
+    public static RuleChain ruleChain = RuleChain.outerRule(repoDir).around(leaderCluster).around(followerCluster);
+
+    public CCRIndexLifecycleIT(@Name("targetCluster") TargetCluster targetCluster) {
+        super(targetCluster);
+    }
+
+    @ParametersFactory
+    public static Iterable<Object[]> parameters() throws Exception {
+        return leaderFollower();
+    }
+
+    @Override
+    protected ElasticsearchCluster getFollowerCluster() {
+        return followerCluster;
+    }
+
+    @Override
+    protected ElasticsearchCluster getLeaderCluster() {
+        return leaderCluster;
+    }
+
     public void testBasicCCRAndILMIntegration() throws Exception {
         String indexName = "logs-1";
 
         String policyName = "basic-test";
-        if ("leader".equals(targetCluster)) {
+        if (targetCluster == TargetCluster.LEADER) {
             putILMPolicy(policyName, "50GB", null, TimeValue.timeValueHours(7 * 24));
             Settings indexSettings = indexSettings(1, 0).put("index.lifecycle.name", policyName)
                 .put("index.lifecycle.rollover_alias", "logs")
                 .build();
             createIndex(indexName, indexSettings, "", "\"logs\": { }");
             ensureGreen(indexName);
-        } else if ("follow".equals(targetCluster)) {
+        } else if (targetCluster == TargetCluster.FOLLOWER) {
             // Policy with the same name must exist in follower cluster too:
             putILMPolicy(policyName, "50GB", null, TimeValue.timeValueHours(7 * 24));
             followIndex(indexName, indexName);
@@ -133,7 +192,7 @@ public void testBasicCCRAndILMIntegration() throws Exception {
                     // ILM should have unfollowed the follower index, so the following_index setting should have been removed:
                     // (this controls whether the follow engine is used)
                     assertThat(getIndexSetting(client(), indexName, "index.xpack.ccr.following_index"), nullValue());
-                });
+                }, 30, TimeUnit.SECONDS);
             }
         } else {
             fail("unexpected target cluster [" + targetCluster + "]");
@@ -142,10 +201,10 @@ public void testBasicCCRAndILMIntegration() throws Exception {
 
     public void testCCRUnfollowDuringSnapshot() throws Exception {
         String indexName = "unfollow-test-index";
-        if ("leader".equals(targetCluster)) {
+        if (targetCluster == TargetCluster.LEADER) {
             createIndex(adminClient(), indexName, indexSettings(2, 0).build());
             ensureGreen(indexName);
-        } else if ("follow".equals(targetCluster)) {
+        } else if (targetCluster == TargetCluster.FOLLOWER) {
             createNewSingletonPolicy("unfollow-only", "hot", UnfollowAction.INSTANCE, TimeValue.ZERO);
             followIndex(indexName, indexName);
             ensureGreen(indexName);
@@ -159,7 +218,7 @@ public void testCCRUnfollowDuringSnapshot() throws Exception {
                         .field("type", "fs")
                         .startObject("settings")
                         .field("compress", randomBoolean())
-                        .field("location", System.getProperty("tests.path.repo"))
+                        .field("location", repoDir.getRoot().getAbsolutePath())
                         .field("max_snapshot_bytes_per_sec", "256b")
                         .endObject()
                         .endObject()
@@ -212,7 +271,7 @@ public void testCcrAndIlmWithRollover() throws Exception {
         String nextIndexName = "mymetrics-000002";
         String policyName = "rollover-test";
 
-        if ("leader".equals(targetCluster)) {
+        if (targetCluster == TargetCluster.LEADER) {
             // Create a policy on the leader
             putILMPolicy(policyName, null, 1, null);
             Request templateRequest = new Request("PUT", "/_index_template/my_template");
@@ -223,7 +282,7 @@ public void testCcrAndIlmWithRollover() throws Exception {
                 "{\"index_patterns\":  [\"mymetrics-*\"], \"template\":{\"settings\":  " + Strings.toString(indexSettings) + "}}"
             );
             assertOK(client().performRequest(templateRequest));
-        } else if ("follow".equals(targetCluster)) {
+        } else if (targetCluster == TargetCluster.FOLLOWER) {
             // Policy with the same name must exist in follower cluster too:
             putILMPolicy(policyName, null, 1, null);
 
@@ -327,7 +386,7 @@ public void testAliasReplicatedOnShrink() throws Exception {
         final String policyName = "shrink-test-policy";
         final int numberOfAliases = randomIntBetween(0, 4);
 
-        if ("leader".equals(targetCluster)) {
+        if (targetCluster == TargetCluster.LEADER) {
             // this policy won't exist on the leader, that's fine
             Settings indexSettings = indexSettings(3, 0).put("index.lifecycle.name", policyName).build();
             final StringBuilder aliases = new StringBuilder();
@@ -346,7 +405,7 @@ public void testAliasReplicatedOnShrink() throws Exception {
             }
             createIndex(indexName, indexSettings, "", aliases.toString());
             ensureGreen(indexName);
-        } else if ("follow".equals(targetCluster)) {
+        } else if (targetCluster == TargetCluster.FOLLOWER) {
             // Create a policy with just a Shrink action on the follower
             putShrinkOnlyPolicy(client(), policyName);
 
@@ -388,12 +447,12 @@ public void testUnfollowInjectedBeforeShrink() throws Exception {
         final String indexName = "shrink-test";
         final String policyName = "shrink-test-policy";
 
-        if ("leader".equals(targetCluster)) {
+        if (targetCluster == TargetCluster.LEADER) {
             // this policy won't exist on the leader, that's fine
             Settings indexSettings = indexSettings(3, 0).put("index.lifecycle.name", policyName).build();
             createIndex(indexName, indexSettings, "", "");
             ensureGreen(indexName);
-        } else if ("follow".equals(targetCluster)) {
+        } else if (targetCluster == TargetCluster.FOLLOWER) {
             // Create a policy with just a Shrink action on the follower
             putShrinkOnlyPolicy(client(), policyName);
 
@@ -430,14 +489,14 @@ public void testUnfollowInjectedBeforeShrink() throws Exception {
     public void testCannotShrinkLeaderIndex() throws Exception {
         String indexName = "shrink-leader-test";
         String policyName = "shrink-leader-test-policy";
-        if ("leader".equals(targetCluster)) {
+        if (targetCluster == TargetCluster.LEADER) {
             // Set up the policy and index, but don't attach the policy yet,
             // otherwise it'll proceed through shrink before we can set up the
             // follower
             putShrinkOnlyPolicy(client(), policyName);
             createIndex(indexName, indexSettings(2, 0).build(), "", "");
             ensureGreen(indexName);
-        } else if ("follow".equals(targetCluster)) {
+        } else if (targetCluster == TargetCluster.FOLLOWER) {
 
             try (RestClient leaderClient = buildLeaderClient()) {
                 // Policy with the same name must exist in follower cluster too:
@@ -502,16 +561,15 @@ public void testILMUnfollowFailsToRemoveRetentionLeases() throws Exception {
         final String followerIndex = "follower";
         final String policyName = "unfollow_only_policy";
 
-        if ("leader".equals(targetCluster)) {
+        if (targetCluster == TargetCluster.LEADER) {
             Settings indexSettings = indexSettings(1, 0).put("index.lifecycle.name", policyName) // this policy won't exist on the leader,
                                                                                                  // that's fine
                 .build();
             createIndex(leaderIndex, indexSettings, "", "");
             ensureGreen(leaderIndex);
-        } else if ("follow".equals(targetCluster)) {
+        } else if (targetCluster == TargetCluster.FOLLOWER) {
             try (RestClient leaderClient = buildLeaderClient()) {
-                String leaderRemoteClusterSeed = System.getProperty("tests.leader_remote_cluster_seed");
-                configureRemoteClusters("other_remote", leaderRemoteClusterSeed);
+                configureRemoteClusters("other_remote", leaderCluster.getTransportEndpoints());
                 assertBusy(() -> {
                     Map<?, ?> localConnection = (Map<?, ?>) toMap(client().performRequest(new Request("GET", "/_remote/info"))).get(
                         "other_remote"
@@ -576,12 +634,12 @@ public void testTsdbLeaderIndexRolloverAndSyncAfterWaitUntilEndTime() throws Exc
         String dataStream = "tsdb-index-cpu";
         String policyName = "tsdb-policy";
 
-        if ("leader".equals(targetCluster)) {
+        if (targetCluster == TargetCluster.LEADER) {
             putILMPolicy(policyName, null, 1, null);
             Request templateRequest = new Request("PUT", "/_index_template/tsdb_template");
             templateRequest.setJsonEntity(Strings.format(TSDB_INDEX_TEMPLATE, indexPattern, policyName));
             assertOK(client().performRequest(templateRequest));
-        } else if ("follow".equals(targetCluster)) {
+        } else if (targetCluster == TargetCluster.FOLLOWER) {
             // Use unfollow-only policy for follower cluster instead of regular ILM policy
             // Follower clusters should not have their own rollover actions as they are meant
             // to follow the rollover behavior of the leader index, not initiate their own rollovers
diff --git a/x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/ESCCRRestTestCase.java b/x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/ESCCRRestTestCase.java
deleted file mode 100644
index 47ad640bc906f..0000000000000
--- a/x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/ESCCRRestTestCase.java
+++ /dev/null
@@ -1,410 +0,0 @@
-/*
- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
- * or more contributor license agreements. Licensed under the Elastic License
- * 2.0; you may not use this file except in compliance with the Elastic License
- * 2.0.
- */
-
-package org.elasticsearch.xpack.ilm;
-
-/*
- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
- * or more contributor license agreements. Licensed under the Elastic License
- * 2.0; you may not use this file except in compliance with the Elastic License
- * 2.0.
- */
-
-import org.apache.http.HttpHost;
-import org.apache.http.util.EntityUtils;
-import org.elasticsearch.client.Request;
-import org.elasticsearch.client.Response;
-import org.elasticsearch.client.ResponseException;
-import org.elasticsearch.client.RestClient;
-import org.elasticsearch.cluster.metadata.DataStream;
-import org.elasticsearch.common.Strings;
-import org.elasticsearch.common.settings.Settings;
-import org.elasticsearch.common.util.LazyInitializable;
-import org.elasticsearch.common.xcontent.XContentHelper;
-import org.elasticsearch.common.xcontent.support.XContentMapValues;
-import org.elasticsearch.rest.RestStatus;
-import org.elasticsearch.test.rest.ESRestTestCase;
-import org.elasticsearch.xcontent.ToXContent;
-import org.elasticsearch.xcontent.XContentBuilder;
-import org.elasticsearch.xcontent.json.JsonXContent;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-
-import static org.elasticsearch.rest.action.search.RestSearchAction.TOTAL_HITS_AS_INT_PARAM;
-import static org.elasticsearch.xcontent.XContentFactory.jsonBuilder;
-import static org.hamcrest.Matchers.endsWith;
-import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.greaterThan;
-import static org.hamcrest.Matchers.greaterThanOrEqualTo;
-import static org.hamcrest.Matchers.hasSize;
-
-public abstract class ESCCRRestTestCase extends ESRestTestCase {
-
-    protected final String targetCluster = System.getProperty("tests.target_cluster");
-
-    @Override
-    protected boolean preserveClusterUponCompletion() {
-        return true;
-    }
-
-    protected static void index(String index, String id, Object... fields) throws IOException {
-        index(adminClient(), index, id, fields);
-    }
-
-    protected static void index(RestClient client, String index, String id, Object... fields) throws IOException {
-        XContentBuilder document = jsonBuilder().startObject();
-        for (int i = 0; i < fields.length; i += 2) {
-            document.field((String) fields[i], fields[i + 1]);
-        }
-        document.endObject();
-        final Request request = new Request("POST", "/" + index + "/_doc" + (id == null ? "" : "/" + id));
-        request.setJsonEntity(Strings.toString(document));
-        assertOK(client.performRequest(request));
-    }
-
-    protected static void resumeFollow(String followIndex) throws IOException {
-        final Request request = new Request("POST", "/" + followIndex + "/_ccr/resume_follow");
-        request.setJsonEntity("{\"read_poll_timeout\": \"10ms\"}");
-        assertOK(client().performRequest(request));
-    }
-
-    protected static void followIndex(String leaderIndex, String followIndex) throws IOException {
-        followIndex("leader_cluster", leaderIndex, followIndex);
-    }
-
-    protected static void followIndex(String leaderCluster, String leaderIndex, String followIndex) throws IOException {
-        followIndex(client(), leaderCluster, leaderIndex, followIndex);
-    }
-
-    protected static void followIndex(RestClient client, String leaderCluster, String leaderIndex, String followIndex) throws IOException {
-        followIndex(client, leaderCluster, leaderIndex, followIndex, null);
-    }
-
-    protected static void followIndex(
-        final RestClient client,
-        final String leaderCluster,
-        final String leaderIndex,
-        final String followIndex,
-        final Settings settings
-    ) throws IOException {
-        final Request request = new Request("PUT", "/" + followIndex + "/_ccr/follow?wait_for_active_shards=1");
-        try (XContentBuilder bodyBuilder = JsonXContent.contentBuilder()) {
-            bodyBuilder.startObject();
-            {
-                bodyBuilder.field("remote_cluster", leaderCluster);
-                bodyBuilder.field("leader_index", leaderIndex);
-                bodyBuilder.field("read_poll_timeout", "10ms");
-                if (settings != null) {
-                    bodyBuilder.startObject("settings");
-                    {
-                        settings.toXContent(bodyBuilder, ToXContent.EMPTY_PARAMS);
-                    }
-                    bodyBuilder.endObject();
-                }
-            }
-            bodyBuilder.endObject();
-            request.setJsonEntity(Strings.toString(bodyBuilder));
-        }
-        assertOK(client.performRequest(request));
-    }
-
-    protected static void pauseFollow(String followIndex) throws IOException {
-        pauseFollow(client(), followIndex);
-    }
-
-    protected static void pauseFollow(RestClient client, String followIndex) throws IOException {
-        assertOK(client.performRequest(new Request("POST", "/" + followIndex + "/_ccr/pause_follow")));
-    }
-
-    protected static void putAutoFollowPattern(String patternName, String remoteCluster, String indexPattern) throws IOException {
-        Request putPatternRequest = new Request("PUT", "/_ccr/auto_follow/" + patternName);
-        putPatternRequest.setJsonEntity(String.format(Locale.ROOT, """
-            {"leader_index_patterns": ["%s"], "remote_cluster": "%s"}
-            """, indexPattern, remoteCluster));
-        assertOK(client().performRequest(putPatternRequest));
-    }
-
-    protected static void deleteAutoFollowPattern(String patternName) throws IOException {
-        deleteAutoFollowPattern(client(), patternName);
-    }
-
-    protected static void deleteAutoFollowPattern(RestClient client, String patternName) throws IOException {
-        Request putPatternRequest = new Request("DELETE", "/_ccr/auto_follow/" + patternName);
-        assertOK(client.performRequest(putPatternRequest));
-    }
-
-    protected static void unfollow(String followIndex) throws IOException {
-        assertOK(client().performRequest(new Request("POST", "/" + followIndex + "/_ccr/unfollow")));
-    }
-
-    protected static void verifyDocuments(final String index, final int expectedNumDocs, final String query) throws IOException {
-        verifyDocuments(index, expectedNumDocs, query, adminClient());
-    }
-
-    protected static void verifyDocuments(final String index, final int expectedNumDocs, final String query, final RestClient client)
-        throws IOException {
-        final Request request = new Request("GET", "/" + index + "/_search");
-        request.addParameter("size", Integer.toString(expectedNumDocs));
-        request.addParameter("sort", "field:asc");
-        request.addParameter("q", query);
-        request.addParameter(TOTAL_HITS_AS_INT_PARAM, "true");
-        Map<String, ?> response = toMap(client.performRequest(request));
-
-        int numDocs = (int) XContentMapValues.extractValue("hits.total", response);
-        assertThat(index, numDocs, equalTo(expectedNumDocs));
-
-        List<?> hits = (List<?>) XContentMapValues.extractValue("hits.hits", response);
-        assertThat(hits.size(), equalTo(expectedNumDocs));
-        for (int i = 0; i < expectedNumDocs; i++) {
-            int value = (int) XContentMapValues.extractValue("_source.field", (Map<?, ?>) hits.get(i));
-            assertThat(index, i, equalTo(value));
-        }
-    }
-
-    protected static void verifyDocuments(final RestClient client, final String index, final int expectedNumDocs) throws IOException {
-        final Request request = new Request("GET", "/" + index + "/_search");
-        request.addParameter(TOTAL_HITS_AS_INT_PARAM, "true");
-        Map<String, ?> response = toMap(client.performRequest(request));
-
-        int numDocs = (int) XContentMapValues.extractValue("hits.total", response);
-        assertThat(index, numDocs, equalTo(expectedNumDocs));
-    }
-
-    protected static void verifyCcrMonitoring(final String expectedLeaderIndex, final String expectedFollowerIndex) throws IOException {
-        Request request = new Request("GET", "/.monitoring-*/_search");
-        request.setJsonEntity(String.format(Locale.ROOT, """
-            {"query": {"term": {"ccr_stats.leader_index": "%s"}}}
-            """, expectedLeaderIndex));
-        Map<String, ?> response;
-        try {
-            response = toMap(adminClient().performRequest(request));
-        } catch (ResponseException e) {
-            throw new AssertionError("error while searching", e);
-        }
-
-        int followerMaxSeqNo = 0;
-        int followerMappingVersion = 0;
-        int followerSettingsVersion = 0;
-        int followerAliasesVersion = 0;
-
-        List<?> hits = (List<?>) XContentMapValues.extractValue("hits.hits", response);
-        assertThat(hits.size(), greaterThanOrEqualTo(1));
-
-        for (int i = 0; i < hits.size(); i++) {
-            Map<?, ?> hit = (Map<?, ?>) hits.get(i);
-            String leaderIndex = (String) XContentMapValues.extractValue("_source.ccr_stats.leader_index", hit);
-            assertThat(leaderIndex, endsWith(expectedLeaderIndex));
-
-            final String followerIndex = (String) XContentMapValues.extractValue("_source.ccr_stats.follower_index", hit);
-            assertThat(followerIndex, equalTo(expectedFollowerIndex));
-
-            int foundFollowerMaxSeqNo = (int) XContentMapValues.extractValue("_source.ccr_stats.follower_max_seq_no", hit);
-            followerMaxSeqNo = Math.max(followerMaxSeqNo, foundFollowerMaxSeqNo);
-            int foundFollowerMappingVersion = (int) XContentMapValues.extractValue("_source.ccr_stats.follower_mapping_version", hit);
-            followerMappingVersion = Math.max(followerMappingVersion, foundFollowerMappingVersion);
-            int foundFollowerSettingsVersion = (int) XContentMapValues.extractValue("_source.ccr_stats.follower_settings_version", hit);
-            followerSettingsVersion = Math.max(followerSettingsVersion, foundFollowerSettingsVersion);
-            int foundFollowerAliasesVersion = (int) XContentMapValues.extractValue("_source.ccr_stats.follower_aliases_version", hit);
-            followerAliasesVersion = Math.max(followerAliasesVersion, foundFollowerAliasesVersion);
-        }
-
-        assertThat(followerMaxSeqNo, greaterThan(0));
-        assertThat(followerMappingVersion, greaterThan(0));
-        assertThat(followerSettingsVersion, greaterThan(0));
-        assertThat(followerAliasesVersion, greaterThan(0));
-    }
-
-    protected static void verifyAutoFollowMonitoring() throws IOException {
-        Request request = new Request("GET", "/.monitoring-*/_count");
-        request.setJsonEntity("""
-                {
-                  "query": {
-                    "bool" : {
-                      "filter": {
-                        "term" : { "type" : "ccr_auto_follow_stats" }
-                      },
-                      "must" : {
-                        "range" : {
-                          "ccr_auto_follow_stats.number_of_successful_follow_indices" : { "gt" : 0 }
-                        }
-                      }
-                    }
-                  }
-                }
-            """);
-        String responseEntity;
-        Map<String, ?> response;
-        try {
-            responseEntity = EntityUtils.toString(adminClient().performRequest(request).getEntity());
-            response = toMap(responseEntity);
-        } catch (ResponseException e) {
-            throw new AssertionError("error while searching", e);
-        }
-        assertNotNull(responseEntity);
-
-        final Number count = (Number) XContentMapValues.extractValue("count", response);
-        assertThat(
-            "Expected at least 1 successfully followed index but found none, count returned [" + responseEntity + ']',
-            count.longValue(),
-            greaterThanOrEqualTo(1L)
-        );
-    }
-
-    protected static Map<String, Object> toMap(Response response) throws IOException {
-        return toMap(EntityUtils.toString(response.getEntity()));
-    }
-
-    protected static Map<String, Object> toMap(String response) {
-        return XContentHelper.convertToMap(JsonXContent.jsonXContent, response, false);
-    }
-
-    protected static void ensureYellow(final String index) throws IOException {
-        ensureYellow(index, adminClient());
-    }
-
-    protected static void ensureYellow(final String index, final RestClient client) throws IOException {
-        ensureHealth(client, index, request -> {
-            request.addParameter("wait_for_status", "yellow");
-            request.addParameter("wait_for_active_shards", "1");
-            request.addParameter("wait_for_no_relocating_shards", "true");
-            // follower index can be yellow even when its primary shards are still initializing as we bootstrap them using snapshot/restore.
-            request.addParameter("wait_for_no_initializing_shards", "true");
-            request.addParameter("timeout", "5s");
-            request.addParameter("level", "shards");
-        });
-    }
-
-    protected Set<CcrNodeTask> getCcrNodeTasks() throws IOException {
-        final Request request = new Request("GET", "/_tasks");
-        request.addParameter("detailed", "true");
-        Map<String, Object> rsp1 = toMap(adminClient().performRequest(request));
-        Map<?, ?> nodes = (Map<?, ?>) rsp1.get("nodes");
-        assertThat(nodes.size(), equalTo(1));
-        Map<?, ?> node = (Map<?, ?>) nodes.values().iterator().next();
-        Map<?, ?> nodeTasks = (Map<?, ?>) node.get("tasks");
-        var ccrNodeTasks = new HashSet<CcrNodeTask>();
-        for (Map.Entry<?, ?> entry : nodeTasks.entrySet()) {
-            Map<?, ?> nodeTask = (Map<?, ?>) entry.getValue();
-            String action = (String) nodeTask.get("action");
-            if (action.startsWith("xpack/ccr/shard_follow_task")) {
-                var status = (Map<?, ?>) nodeTask.get("status");
-                ccrNodeTasks.add(
-                    new CcrNodeTask(
-                        (String) status.get("remote_cluster"),
-                        (String) status.get("leader_index"),
-                        (String) status.get("follower_index"),
-                        (Integer) status.get("shard_id")
-                    )
-                );
-            }
-        }
-        return ccrNodeTasks;
-    }
-
-    protected record CcrNodeTask(String remoteCluster, String leaderIndex, String followerIndex, int shardId) {}
-
-    protected static boolean indexExists(String index) throws IOException {
-        Response response = adminClient().performRequest(new Request("HEAD", "/" + index));
-        return RestStatus.OK.getStatus() == response.getStatusLine().getStatusCode();
-    }
-
-    protected static List<String> verifyDataStream(final RestClient client, final String name, final String... expectedBackingIndices)
-        throws IOException {
-        Request request = new Request("GET", "/_data_stream/" + name);
-        Map<String, ?> response = toMap(client.performRequest(request));
-        List<?> retrievedDataStreams = (List<?>) response.get("data_streams");
-        assertThat(retrievedDataStreams, hasSize(1));
-        List<?> actualBackingIndexItems = (List<?>) ((Map<?, ?>) retrievedDataStreams.get(0)).get("indices");
-        assertThat(actualBackingIndexItems, hasSize(expectedBackingIndices.length));
-        final List<String> actualBackingIndices = new ArrayList<>();
-        for (int i = 0; i < expectedBackingIndices.length; i++) {
-            Map<?, ?> actualBackingIndexItem = (Map<?, ?>) actualBackingIndexItems.get(i);
-            String actualBackingIndex = (String) actualBackingIndexItem.get("index_name");
-            String expectedBackingIndex = expectedBackingIndices[i];
-
-            String actualDataStreamName = actualBackingIndex.substring(5, actualBackingIndex.indexOf('-', 5));
-            String expectedDataStreamName = expectedBackingIndex.substring(5, expectedBackingIndex.indexOf('-', 5));
-            assertThat(actualDataStreamName, equalTo(expectedDataStreamName));
-
-            int actualGeneration = Integer.parseInt(actualBackingIndex.substring(actualBackingIndex.lastIndexOf('-')));
-            int expectedGeneration = Integer.parseInt(expectedBackingIndex.substring(expectedBackingIndex.lastIndexOf('-')));
-            assertThat(actualGeneration, equalTo(expectedGeneration));
-            actualBackingIndices.add(actualBackingIndex);
-        }
-        return List.copyOf(actualBackingIndices);
-    }
-
-    protected static void createAutoFollowPattern(
-        RestClient client,
-        String name,
-        String pattern,
-        String remoteCluster,
-        String followIndexPattern
-    ) throws IOException {
-        Request request = new Request("PUT", "/_ccr/auto_follow/" + name);
-        try (XContentBuilder bodyBuilder = JsonXContent.contentBuilder()) {
-            bodyBuilder.startObject();
-            {
-                bodyBuilder.array("leader_index_patterns", pattern);
-                if (followIndexPattern != null) {
-                    bodyBuilder.field("follow_index_pattern", followIndexPattern);
-                }
-                bodyBuilder.field("remote_cluster", remoteCluster);
-            }
-            bodyBuilder.endObject();
-            request.setJsonEntity(Strings.toString(bodyBuilder));
-        }
-        assertOK(client.performRequest(request));
-    }
-
-    /**
-     * Fix point in time when data stream backing index is first time queried.
-     * This is required to avoid failures when running test at midnight.
-     * (index is created for day0, but assertions are executed for day1 assuming different time based index name that does not exist)
-     */
-    private final LazyInitializable<Long, RuntimeException> time = new LazyInitializable<>(System::currentTimeMillis);
-
-    protected String backingIndexName(String dataStreamName, int generation) {
-        return DataStream.getDefaultBackingIndexName(dataStreamName, generation, time.getOrCompute());
-    }
-
-    protected RestClient buildLeaderClient() throws IOException {
-        assert "leader".equals(targetCluster) == false;
-        return buildClient(System.getProperty("tests.leader_host"));
-    }
-
-    protected RestClient buildLeaderClient(final Settings settings) throws IOException {
-        assert "leader".equals(targetCluster) == false;
-        return buildClient(System.getProperty("tests.leader_host"), settings);
-    }
-
-    protected RestClient buildMiddleClient() throws IOException {
-        assert "middle".equals(targetCluster) == false;
-        return buildClient(System.getProperty("tests.middle_host"));
-    }
-
-    private RestClient buildClient(final String url) throws IOException {
-        return buildClient(url, restAdminSettings());
-    }
-
-    private RestClient buildClient(final String url, final Settings settings) throws IOException {
-        int portSeparator = url.lastIndexOf(':');
-        HttpHost httpHost = new HttpHost(
-            url.substring(0, portSeparator),
-            Integer.parseInt(url.substring(portSeparator + 1)),
-            getProtocol()
-        );
-        return buildClient(settings, new HttpHost[] { httpHost });
-    }
-
-}
diff --git a/x-pack/plugin/ilm/qa/multi-node/build.gradle b/x-pack/plugin/ilm/qa/multi-node/build.gradle
index d420ac9effdde..714d1b20ef331 100644
--- a/x-pack/plugin/ilm/qa/multi-node/build.gradle
+++ b/x-pack/plugin/ilm/qa/multi-node/build.gradle
@@ -1,46 +1,25 @@
-import org.elasticsearch.gradle.internal.info.BuildParams
-import static org.elasticsearch.gradle.PropertyNormalization.IGNORE_VALUE
+/*
+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
+ * or more contributor license agreements. Licensed under the Elastic License
+ * 2.0; you may not use this file except in compliance with the Elastic License
+ * 2.0.
+ */
 
-apply plugin: 'elasticsearch.legacy-java-rest-test'
+apply plugin: 'elasticsearch.internal-java-rest-test'
 
 dependencies {
   javaRestTestImplementation(testArtifact(project(xpackModule('core'))))
   javaRestTestImplementation project(xpackModule('ilm'))
-}
-
-File repoDir = file("$buildDir/testclusters/repo")
-
-tasks.named("javaRestTest").configure {
-  /* To support taking index snapshots, we have to set path.repo setting */
-  nonInputProperties.systemProperty 'tests.path.repo', repoDir
-}
-
-testClusters.configureEach {
-  testDistribution = 'DEFAULT'
-  numberOfNodes = 4
 
-  setting 'path.repo', repoDir.absolutePath, IGNORE_VALUE
-  setting 'xpack.searchable.snapshot.shared_cache.size', '16MB'
-  setting 'xpack.searchable.snapshot.shared_cache.region_size', '256KB'
-  setting 'xpack.security.enabled', 'false'
-  setting 'xpack.watcher.enabled', 'false'
-  setting 'xpack.ml.enabled', 'false'
-  setting 'xpack.license.self_generated.type', 'trial'
-  setting 'indices.lifecycle.poll_interval', '1000ms'
-  setting 'logger.org.elasticsearch.xpack.core.ilm', 'TRACE'
-  setting 'logger.org.elasticsearch.xpack.ilm', 'TRACE'
-  /*
-   * In TimeSeriesLifecycleActionsIT.testWaitForSnapshotSlmExecutedBefore() we create a snapshot, then associate an ILM policy with an index, and
-   * then that policy checks if a snapshot has been started at the same millisecond or later than the policy's action's date. Since both the
-   * snapshot start time and policy are using ThreadPool.absoluteTimeInMillis(), it is possible that they get the same cached result back (it is
-   * kept for about 200 ms). The following config changes ThreadPool.absoluteTimeInMillis() to always use System.currentTimeMillis() rather than a
-   * cached time. So the policy's action date is always after the snapshot's start.
-   */
-  setting 'thread_pool.estimated_time_interval', '0'
-  setting 'time_series.poll_interval', '10m'
+  clusterModules project(xpackModule('ilm'))
+  clusterModules project(xpackModule('slm'))
+  clusterModules project(xpackModule('ccr'))
+  clusterModules project(xpackModule('downsample'))
+  clusterModules project(xpackModule('searchable-snapshots'))
+  clusterModules project(':modules:data-streams')
 }
 
-if (buildParams.inFipsJvm){
+if (buildParams.inFipsJvm) {
   // Test clusters run with security disabled
-  tasks.named("javaRestTest").configure{enabled = false }
+  tasks.named("javaRestTest").configure { enabled = false }
 }
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/IlmESRestTestCase.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/IlmESRestTestCase.java
new file mode 100644
index 0000000000000..6f8989ab65c44
--- /dev/null
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/IlmESRestTestCase.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
+ * or more contributor license agreements. Licensed under the Elastic License
+ * 2.0; you may not use this file except in compliance with the Elastic License
+ * 2.0.
+ */
+
+package org.elasticsearch.xpack;
+
+import org.elasticsearch.common.settings.SecureString;
+import org.elasticsearch.common.settings.Settings;
+import org.elasticsearch.common.util.concurrent.ThreadContext;
+import org.elasticsearch.test.cluster.ElasticsearchCluster;
+import org.elasticsearch.test.rest.ESRestTestCase;
+import org.junit.ClassRule;
+import org.junit.rules.RuleChain;
+import org.junit.rules.TemporaryFolder;
+
+public abstract class IlmESRestTestCase extends ESRestTestCase {
+    static final String USER = "user";
+    static final String PASSWORD = "x-pack-test-password";
+
+    public static TemporaryFolder repoDir = new TemporaryFolder();
+
+    public static ElasticsearchCluster cluster = ElasticsearchCluster.local()
+        .module("x-pack-ilm")
+        .module("x-pack-slm")
+        .module("x-pack-ccr")
+        .module("x-pack-downsample")
+        .module("searchable-snapshots")
+        .module("data-streams")
+        .nodes(4)
+        .setting("path.repo", () -> repoDir.getRoot().getAbsolutePath())
+        .setting("xpack.searchable.snapshot.shared_cache.size", "16MB")
+        .setting("xpack.searchable.snapshot.shared_cache.region_size", "256KB")
+        .setting("xpack.security.enabled", "false")
+        .setting("xpack.license.self_generated.type", "trial")
+        .setting("indices.lifecycle.poll_interval", "1000ms")
+        .setting("logger.org.elasticsearch.xpack.core.ilm", "TRACE")
+        .setting("logger.org.elasticsearch.xpack.ilm", "TRACE")
+        // The TRACE logs of the history store are too verbose and not useful, so we set it to INFO
+        .setting("logger.org.elasticsearch.xpack.ilm.history.ILMHistoryStore", "INFO")
+        /*
+         * In TimeSeriesLifecycleActionsIT.testWaitForSnapshotSlmExecutedBefore() we create a snapshot, then associate an ILM policy with
+         * an index, and then that policy checks if a snapshot has been started at the same millisecond or later than the policy's action's
+         * date. Since both the snapshot start time and policy are using ThreadPool.absoluteTimeInMillis(), it is possible that they get
+         * the same cached result back (it is kept for about 200 ms). The following config changes ThreadPool.absoluteTimeInMillis() to
+         * always use System.currentTimeMillis() rather than a cached time. So the policy's action date is always after the snapshot's
+         * start.
+         */
+        .setting("thread_pool.estimated_time_interval", "0")
+        .setting("time_series.poll_interval", "10m")
+        // Disable shard balancing to avoid force merges failing due to relocating shards.
+        .setting("cluster.routing.rebalance.enable", "none")
+        .user(USER, PASSWORD)
+        .build();
+
+    @ClassRule
+    public static RuleChain ruleChain = RuleChain.outerRule(repoDir).around(cluster);
+
+    protected String getTestRestCluster() {
+        return cluster.getHttpAddresses();
+    }
+
+    @Override
+    protected Settings restClientSettings() {
+        String token = basicAuthHeaderValue(USER, new SecureString(PASSWORD.toCharArray()));
+        return Settings.builder().put(super.restClientSettings()).put(ThreadContext.PREFIX + ".Authorization", token).build();
+    }
+}
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/MigrateToDataTiersIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/MigrateToDataTiersIT.java
index 811d07a436677..79e2d5441c466 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/MigrateToDataTiersIT.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/MigrateToDataTiersIT.java
@@ -23,7 +23,6 @@
 import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;
 import org.elasticsearch.test.XContentTestUtils;
 import org.elasticsearch.test.XContentTestUtils.JsonMapView;
-import org.elasticsearch.test.rest.ESRestTestCase;
 import org.elasticsearch.xpack.cluster.action.MigrateToDataTiersResponse;
 import org.elasticsearch.xpack.core.ilm.AllocateAction;
 import org.elasticsearch.xpack.core.ilm.AllocationRoutedStep;
@@ -61,7 +60,7 @@
 import static org.hamcrest.Matchers.notNullValue;
 import static org.hamcrest.Matchers.nullValue;
 
-public class MigrateToDataTiersIT extends ESRestTestCase {
+public class MigrateToDataTiersIT extends IlmESRestTestCase {
     private String index;
     private String policy;
     private String alias;
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java
index 11edfff9ee108..24b805833aa08 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java
@@ -197,26 +197,14 @@ public static void createFullPolicy(RestClient client, String policyName, TimeVa
         warmActions.put(ForceMergeAction.NAME, new ForceMergeAction(1, null));
         warmActions.put(
             AllocateAction.NAME,
-            new AllocateAction(
-                1,
-                null,
-                Map.of("_name", "javaRestTest-0,javaRestTest-1," + "javaRestTest-2," + "javaRestTest-3"),
-                null,
-                null
-            )
+            new AllocateAction(1, null, Map.of("_name", "test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3"), null, null)
         );
         warmActions.put(ShrinkAction.NAME, new ShrinkAction(1, null, false));
         Map<String, LifecycleAction> coldActions = new HashMap<>();
         coldActions.put(SetPriorityAction.NAME, new SetPriorityAction(0));
         coldActions.put(
             AllocateAction.NAME,
-            new AllocateAction(
-                0,
-                null,
-                Map.of("_name", "javaRestTest-0,javaRestTest-1," + "javaRestTest-2," + "javaRestTest-3"),
-                null,
-                null
-            )
+            new AllocateAction(0, null, Map.of("_name", "test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3"), null, null)
         );
         Map<String, Phase> phases = new HashMap<>();
         phases.put("hot", new Phase("hot", hotTime, hotActions));
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ChangePolicyForIndexIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ChangePolicyForIndexIT.java
index 370e00785e843..e16ec7d72f8e5 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ChangePolicyForIndexIT.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ChangePolicyForIndexIT.java
@@ -15,8 +15,8 @@
 import org.elasticsearch.common.Strings;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.core.TimeValue;
-import org.elasticsearch.test.rest.ESRestTestCase;
 import org.elasticsearch.xcontent.XContentBuilder;
+import org.elasticsearch.xpack.IlmESRestTestCase;
 import org.elasticsearch.xpack.core.ilm.AllocateAction;
 import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;
 import org.elasticsearch.xpack.core.ilm.LifecycleSettings;
@@ -37,7 +37,7 @@
 import static org.elasticsearch.xpack.TimeSeriesRestDriver.createNewSingletonPolicy;
 import static org.elasticsearch.xpack.TimeSeriesRestDriver.indexDocument;
 
-public class ChangePolicyForIndexIT extends ESRestTestCase {
+public class ChangePolicyForIndexIT extends IlmESRestTestCase {
 
     /**
      * This test aims to prove that an index will finish the current phase on an
@@ -94,7 +94,7 @@ public void testChangePolicyForIndex() throws Exception {
                 TimeValue.ZERO,
                 Map.of(
                     AllocateAction.NAME,
-                    new AllocateAction(1, null, Map.of("_name", "javaRestTest-0,javaRestTest-1,javaRestTest-2,javaRestTest-3"), null, null)
+                    new AllocateAction(1, null, Map.of("_name", "test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3"), null, null)
                 )
             )
         );
@@ -117,7 +117,7 @@ public void testChangePolicyForIndex() throws Exception {
         Settings settings = Settings.builder()
             .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4)
             .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)
-            .put("index.routing.allocation.include._name", "javaRestTest-0")
+            .put("index.routing.allocation.include._name", "test-cluster-0")
             .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, "alias")
             .put(LifecycleSettings.LIFECYCLE_NAME, "policy_1")
             .build();
@@ -161,10 +161,10 @@ public void testChangePolicyForIndex() throws Exception {
         // Check the index goes to the warm phase and completes
         assertBusy(() -> assertStep(indexName, PhaseCompleteStep.finalStep("warm").getKey()), 30, TimeUnit.SECONDS);
 
-        // Check index is allocated on javaRestTest-1 and javaRestTest-2 as per policy_2
+        // Check index is allocated on test-cluster-1 and test-cluster-2 as per policy_2
         Map<String, Object> indexSettings = getIndexSettingsAsMap(indexName);
         String includesAllocation = (String) indexSettings.get("index.routing.allocation.include._name");
-        assertEquals("javaRestTest-0,javaRestTest-1,javaRestTest-2,javaRestTest-3", includesAllocation);
+        assertEquals("test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3", includesAllocation);
     }
 
     public void testILMHonoursTheCachedPhaseAfterPolicyUpdate() throws Exception {
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ExplainLifecycleIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ExplainLifecycleIT.java
index 9b7262e8f9b32..95a78ec0193e4 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ExplainLifecycleIT.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ExplainLifecycleIT.java
@@ -18,8 +18,8 @@
 import org.elasticsearch.common.Strings;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.core.TimeValue;
-import org.elasticsearch.test.rest.ESRestTestCase;
 import org.elasticsearch.xcontent.XContentBuilder;
+import org.elasticsearch.xpack.IlmESRestTestCase;
 import org.elasticsearch.xpack.core.ilm.DeleteAction;
 import org.elasticsearch.xpack.core.ilm.ErrorStep;
 import org.elasticsearch.xpack.core.ilm.LifecycleAction;
@@ -52,7 +52,7 @@
 import static org.hamcrest.Matchers.notNullValue;
 import static org.hamcrest.Matchers.nullValue;
 
-public class ExplainLifecycleIT extends ESRestTestCase {
+public class ExplainLifecycleIT extends IlmESRestTestCase {
     private static final Logger logger = LogManager.getLogger(ExplainLifecycleIT.class);
     private static final String FAILED_STEP_RETRY_COUNT_FIELD = "failed_step_retry_count";
     private static final String IS_AUTO_RETRYABLE_ERROR_FIELD = "is_auto_retryable_error";
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/LifecycleLicenseIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/LifecycleLicenseIT.java
index fe00f060d5ade..fcc494e00fe4e 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/LifecycleLicenseIT.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/LifecycleLicenseIT.java
@@ -17,10 +17,10 @@
 import org.elasticsearch.core.TimeValue;
 import org.elasticsearch.license.License;
 import org.elasticsearch.license.TestUtils;
-import org.elasticsearch.test.rest.ESRestTestCase;
 import org.elasticsearch.xcontent.ToXContent;
 import org.elasticsearch.xcontent.XContentBuilder;
 import org.elasticsearch.xcontent.json.JsonXContent;
+import org.elasticsearch.xpack.IlmESRestTestCase;
 import org.elasticsearch.xpack.core.ilm.ErrorStep;
 import org.elasticsearch.xpack.core.ilm.LifecycleSettings;
 import org.elasticsearch.xpack.core.ilm.PhaseCompleteStep;
@@ -45,7 +45,7 @@
 import static org.hamcrest.Matchers.greaterThanOrEqualTo;
 import static org.hamcrest.Matchers.is;
 
-public class LifecycleLicenseIT extends ESRestTestCase {
+public class LifecycleLicenseIT extends IlmESRestTestCase {
 
     private String policy;
     private String dataStream;
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesDataStreamsIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesDataStreamsIT.java
index 0762df16722a6..1ce4a92632d36 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesDataStreamsIT.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesDataStreamsIT.java
@@ -14,8 +14,8 @@
 import org.elasticsearch.common.xcontent.XContentHelper;
 import org.elasticsearch.core.TimeValue;
 import org.elasticsearch.index.engine.EngineConfig;
-import org.elasticsearch.test.rest.ESRestTestCase;
 import org.elasticsearch.xcontent.XContentType;
+import org.elasticsearch.xpack.IlmESRestTestCase;
 import org.elasticsearch.xpack.core.ilm.CheckNotDataStreamWriteIndexStep;
 import org.elasticsearch.xpack.core.ilm.DeleteAction;
 import org.elasticsearch.xpack.core.ilm.DeleteStep;
@@ -52,7 +52,7 @@
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.oneOf;
 
-public class TimeSeriesDataStreamsIT extends ESRestTestCase {
+public class TimeSeriesDataStreamsIT extends IlmESRestTestCase {
 
     private String policyName;
     private String dataStream;
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java
index dddb07fae42c5..d69817c8640fb 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java
@@ -25,10 +25,10 @@
 import org.elasticsearch.index.engine.EngineConfig;
 import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;
 import org.elasticsearch.snapshots.SnapshotState;
-import org.elasticsearch.test.rest.ESRestTestCase;
 import org.elasticsearch.xcontent.XContentBuilder;
 import org.elasticsearch.xcontent.XContentType;
 import org.elasticsearch.xcontent.json.JsonXContent;
+import org.elasticsearch.xpack.IlmESRestTestCase;
 import org.elasticsearch.xpack.core.ilm.AllocateAction;
 import org.elasticsearch.xpack.core.ilm.DeleteAction;
 import org.elasticsearch.xpack.core.ilm.ErrorStep;
@@ -79,7 +79,7 @@
 import static org.hamcrest.Matchers.notNullValue;
 import static org.hamcrest.Matchers.nullValue;
 
-public class TimeSeriesLifecycleActionsIT extends ESRestTestCase {
+public class TimeSeriesLifecycleActionsIT extends IlmESRestTestCase {
     private static final Logger logger = LogManager.getLogger(TimeSeriesLifecycleActionsIT.class);
     private static final String FAILED_STEP_RETRY_COUNT_FIELD = "failed_step_retry_count";
 
@@ -105,7 +105,7 @@ public void testFullPolicy() throws Exception {
             Settings.builder()
                 .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 2)
                 .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)
-                .put("index.routing.allocation.include._name", "javaRestTest-0")
+                .put("index.routing.allocation.include._name", "test-cluster-0")
                 .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, alias)
         );
 
@@ -216,7 +216,7 @@ public void testAllocateOnlyAllocation() throws Exception {
             alias,
             Settings.builder().put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 2).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)
         );
-        String allocateNodeName = "javaRestTest-0,javaRestTest-1,javaRestTest-2,javaRestTest-3";
+        String allocateNodeName = "test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3";
         AllocateAction allocateAction = new AllocateAction(null, null, Map.of("_name", allocateNodeName), null, null);
         String endPhase = randomFrom("warm", "cold");
         createNewSingletonPolicy(client(), policy, endPhase, allocateAction);
@@ -441,7 +441,7 @@ public void testDeleteDuringSnapshot() throws Exception {
                     .field("type", "fs")
                     .startObject("settings")
                     .field("compress", randomBoolean())
-                    .field("location", System.getProperty("tests.path.repo"))
+                    .field("location", repoDir.getRoot().getAbsolutePath())
                     .field("max_snapshot_bytes_per_sec", "256b")
                     .endObject()
                     .endObject()
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeseriesMoveToStepIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeseriesMoveToStepIT.java
index 5a61af793d907..1951f520f98c8 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeseriesMoveToStepIT.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeseriesMoveToStepIT.java
@@ -15,7 +15,7 @@
 import org.elasticsearch.cluster.metadata.IndexMetadata;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.core.TimeValue;
-import org.elasticsearch.test.rest.ESRestTestCase;
+import org.elasticsearch.xpack.IlmESRestTestCase;
 import org.elasticsearch.xpack.core.ilm.DeleteAction;
 import org.elasticsearch.xpack.core.ilm.ForceMergeAction;
 import org.elasticsearch.xpack.core.ilm.LifecycleSettings;
@@ -39,7 +39,7 @@
 import static org.hamcrest.Matchers.containsStringIgnoringCase;
 import static org.hamcrest.Matchers.equalTo;
 
-public class TimeseriesMoveToStepIT extends ESRestTestCase {
+public class TimeseriesMoveToStepIT extends IlmESRestTestCase {
     private static final Logger logger = LogManager.getLogger(TimeseriesMoveToStepIT.class);
 
     private String policy;
@@ -64,7 +64,7 @@ public void testMoveToAllocateStep() throws Exception {
             Settings.builder()
                 .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4)
                 .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)
-                .put("index.routing.allocation.include._name", "javaRestTest-0")
+                .put("index.routing.allocation.include._name", "test-cluster-0")
                 .put(LifecycleSettings.LIFECYCLE_NAME, policy)
                 .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, "alias")
         );
@@ -102,7 +102,7 @@ public void testMoveToRolloverStep() throws Exception {
             Settings.builder()
                 .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4)
                 .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)
-                .put("index.routing.allocation.include._name", "javaRestTest-0")
+                .put("index.routing.allocation.include._name", "test-cluster-0")
                 .put(LifecycleSettings.LIFECYCLE_NAME, policy)
                 .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, alias)
         );
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/DownsampleActionIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/DownsampleActionIT.java
index 17a1ad7ed9040..c83925ae4fcd6 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/DownsampleActionIT.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/DownsampleActionIT.java
@@ -23,9 +23,9 @@
 import org.elasticsearch.index.IndexSettings;
 import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;
 import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramInterval;
-import org.elasticsearch.test.rest.ESRestTestCase;
 import org.elasticsearch.xcontent.XContentBuilder;
 import org.elasticsearch.xcontent.XContentFactory;
+import org.elasticsearch.xpack.IlmESRestTestCase;
 import org.elasticsearch.xpack.core.ilm.CheckNotDataStreamWriteIndexStep;
 import org.elasticsearch.xpack.core.ilm.DownsampleAction;
 import org.elasticsearch.xpack.core.ilm.LifecycleAction;
@@ -57,7 +57,7 @@
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.notNullValue;
 
-public class DownsampleActionIT extends ESRestTestCase {
+public class DownsampleActionIT extends IlmESRestTestCase {
 
     private String index;
     private String policy;
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ReadonlyActionIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ReadonlyActionIT.java
index ec0b685dd5bd0..6c38b54aa3b12 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ReadonlyActionIT.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ReadonlyActionIT.java
@@ -12,7 +12,7 @@
 import org.elasticsearch.common.Strings;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.core.TimeValue;
-import org.elasticsearch.test.rest.ESRestTestCase;
+import org.elasticsearch.xpack.IlmESRestTestCase;
 import org.elasticsearch.xpack.core.ilm.LifecycleAction;
 import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;
 import org.elasticsearch.xpack.core.ilm.LifecycleSettings;
@@ -34,7 +34,7 @@
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.nullValue;
 
-public class ReadonlyActionIT extends ESRestTestCase {
+public class ReadonlyActionIT extends IlmESRestTestCase {
     private static final String FAILED_STEP_RETRY_COUNT_FIELD = "failed_step_retry_count";
 
     private String policy;
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/RolloverActionIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/RolloverActionIT.java
index b12df4b43faaf..6ab8692540563 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/RolloverActionIT.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/RolloverActionIT.java
@@ -17,7 +17,7 @@
 import org.elasticsearch.core.Strings;
 import org.elasticsearch.core.TimeValue;
 import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;
-import org.elasticsearch.test.rest.ESRestTestCase;
+import org.elasticsearch.xpack.IlmESRestTestCase;
 import org.elasticsearch.xpack.core.ilm.LifecycleSettings;
 import org.elasticsearch.xpack.core.ilm.PhaseCompleteStep;
 import org.elasticsearch.xpack.core.ilm.RolloverAction;
@@ -29,6 +29,7 @@
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
 
+import static org.elasticsearch.test.ESTestCase.randomAlphaOfLength;
 import static org.elasticsearch.xpack.TimeSeriesRestDriver.createIndexWithSettings;
 import static org.elasticsearch.xpack.TimeSeriesRestDriver.createNewSingletonPolicy;
 import static org.elasticsearch.xpack.TimeSeriesRestDriver.explainIndex;
@@ -41,7 +42,7 @@
 import static org.hamcrest.Matchers.greaterThanOrEqualTo;
 import static org.hamcrest.Matchers.is;
 
-public class RolloverActionIT extends ESRestTestCase {
+public class RolloverActionIT extends IlmESRestTestCase {
 
     private static final String FAILED_STEP_RETRY_COUNT_FIELD = "failed_step_retry_count";
 
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java
index 7c9e1160bc95c..26193a82c4c3e 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java
@@ -19,9 +19,9 @@
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.xcontent.XContentHelper;
 import org.elasticsearch.core.TimeValue;
-import org.elasticsearch.test.rest.ESRestTestCase;
 import org.elasticsearch.xcontent.XContentBuilder;
 import org.elasticsearch.xcontent.XContentType;
+import org.elasticsearch.xpack.IlmESRestTestCase;
 import org.elasticsearch.xpack.core.ilm.AllocateAction;
 import org.elasticsearch.xpack.core.ilm.DeleteAction;
 import org.elasticsearch.xpack.core.ilm.ForceMergeAction;
@@ -65,7 +65,7 @@
 import static org.hamcrest.Matchers.greaterThanOrEqualTo;
 import static org.hamcrest.Matchers.is;
 
-public class SearchableSnapshotActionIT extends ESRestTestCase {
+public class SearchableSnapshotActionIT extends IlmESRestTestCase {
 
     private String policy;
     private String dataStream;
diff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ShrinkActionIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ShrinkActionIT.java
index 2fecf3c617ccd..295a5db6f6497 100644
--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ShrinkActionIT.java
+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ShrinkActionIT.java
@@ -19,9 +19,9 @@
 import org.elasticsearch.common.unit.ByteSizeValue;
 import org.elasticsearch.core.TimeValue;
 import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;
-import org.elasticsearch.test.rest.ESRestTestCase;
 import org.elasticsearch.xcontent.XContentBuilder;
 import org.elasticsearch.xcontent.json.JsonXContent;
+import org.elasticsearch.xpack.IlmESRestTestCase;
 import org.elasticsearch.xpack.core.ilm.CheckTargetShardsCountStep;
 import org.elasticsearch.xpack.core.ilm.LifecycleAction;
 import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;
@@ -56,7 +56,7 @@
 import static org.hamcrest.Matchers.notNullValue;
 import static org.hamcrest.Matchers.nullValue;
 
-public class ShrinkActionIT extends ESRestTestCase {
+public class ShrinkActionIT extends IlmESRestTestCase {
     private static final String FAILED_STEP_RETRY_COUNT_FIELD = "failed_step_retry_count";
     private static final String SHRINK_INDEX_NAME = "shrink_index_name";
 
@@ -152,7 +152,7 @@ public void testShrinkDuringSnapshot() throws Exception {
                     .field("type", "fs")
                     .startObject("settings")
                     .field("compress", randomBoolean())
-                    .field("location", System.getProperty("tests.path.repo"))
+                    .field("location", repoDir.getRoot().getAbsolutePath())
                     .field("max_snapshot_bytes_per_sec", "256b")
                     .endObject()
                     .endObject()
@@ -170,7 +170,7 @@ public void testShrinkDuringSnapshot() throws Exception {
                 .put(SETTING_NUMBER_OF_SHARDS, 2)
                 .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)
                 // required so the shrink doesn't wait on SetSingleNodeAllocateStep
-                .put(IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getKey() + "_name", "javaRestTest-0")
+                .put(IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getKey() + "_name", "test-cluster-0")
         );
         // index document so snapshot actually does something
         indexDocument(client(), index);
diff --git a/x-pack/plugin/ilm/qa/rest/build.gradle b/x-pack/plugin/ilm/qa/rest/build.gradle
index 11ce8254c8fd6..3a8a93e8325f9 100644
--- a/x-pack/plugin/ilm/qa/rest/build.gradle
+++ b/x-pack/plugin/ilm/qa/rest/build.gradle
@@ -1,9 +1,10 @@
-apply plugin: 'elasticsearch.legacy-yaml-rest-test'
-apply plugin: 'elasticsearch.legacy-yaml-rest-compat-test'
-apply plugin: 'elasticsearch.authenticated-testclusters'
+
+apply plugin: 'elasticsearch.internal-yaml-rest-test'
 
 dependencies {
-  yamlRestTestImplementation(testArtifact(project(xpackModule('core'))))
+  yamlRestTestImplementation project(':x-pack:qa')
+
+  clusterModules project(xpackModule('ilm'))
 }
 
 restResources {
@@ -12,9 +13,14 @@ restResources {
   }
 }
 
-testClusters.configureEach {
-  testDistribution = 'DEFAULT'
-  setting 'xpack.ml.enabled', 'false'
-  setting 'xpack.license.self_generated.type', 'trial'
-  setting 'xpack.security.autoconfiguration.enabled', 'false'
+configurations {
+  basicRestSpecs {
+    attributes {
+      attribute(ArtifactTypeDefinition.ARTIFACT_TYPE_ATTRIBUTE, ArtifactTypeDefinition.DIRECTORY_TYPE)
+    }
+  }
+}
+
+artifacts {
+  basicRestSpecs(new File(projectDir, "src/yamlRestTest/resources/rest-api-spec/test"))
 }
diff --git a/x-pack/plugin/ilm/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/ilm/IndexLifecycleRestIT.java b/x-pack/plugin/ilm/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/ilm/IndexLifecycleRestIT.java
index 1e7658fe7b3e1..fa4c7f8cbc1d9 100644
--- a/x-pack/plugin/ilm/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/ilm/IndexLifecycleRestIT.java
+++ b/x-pack/plugin/ilm/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/ilm/IndexLifecycleRestIT.java
@@ -15,31 +15,41 @@
 import org.elasticsearch.common.settings.SecureString;
 import org.elasticsearch.common.settings.Settings;
 import org.elasticsearch.common.util.concurrent.ThreadContext;
+import org.elasticsearch.test.cluster.ElasticsearchCluster;
 import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;
 import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;
-
-import java.util.Objects;
-
-import static org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;
+import org.junit.ClassRule;
 
 @TimeoutSuite(millis = 30 * TimeUnits.MINUTE) // as default timeout seems not enough on the jenkins VMs
 public class IndexLifecycleRestIT extends ESClientYamlSuiteTestCase {
 
-    private static final String USER = Objects.requireNonNull(System.getProperty("tests.rest.cluster.username"));
-    private static final String PASS = Objects.requireNonNull(System.getProperty("tests.rest.cluster.password"));
+    static final String USER = "user";
+    static final String PASSWORD = "x-pack-test-password";
 
-    public IndexLifecycleRestIT(@Name("yaml") ClientYamlTestCandidate testCandidate) {
-        super(testCandidate);
-    }
+    @ClassRule
+    public static ElasticsearchCluster cluster = ElasticsearchCluster.local()
+        .module("x-pack-ilm")
+        .setting("xpack.license.self_generated.type", "trial")
+        .setting("xpack.security.autoconfiguration.enabled", "false")
+        .user(USER, PASSWORD)
+        .build();
 
     @ParametersFactory
     public static Iterable<Object[]> parameters() throws Exception {
         return createParameters();
     }
 
+    public IndexLifecycleRestIT(@Name("yaml") ClientYamlTestCandidate testCandidate) {
+        super(testCandidate);
+    }
+
+    protected String getTestRestCluster() {
+        return cluster.getHttpAddresses();
+    }
+
     @Override
     protected Settings restClientSettings() {
-        String token = basicAuthHeaderValue(USER, new SecureString(PASS.toCharArray()));
+        String token = basicAuthHeaderValue(USER, new SecureString(PASSWORD.toCharArray()));
         return Settings.builder().put(super.restClientSettings()).put(ThreadContext.PREFIX + ".Authorization", token).build();
     }
 }
diff --git a/x-pack/plugin/ilm/qa/with-security/build.gradle b/x-pack/plugin/ilm/qa/with-security/build.gradle
index 94dd375c56b1b..46e4987e6b77a 100644
--- a/x-pack/plugin/ilm/qa/with-security/build.gradle
+++ b/x-pack/plugin/ilm/qa/with-security/build.gradle
@@ -2,8 +2,8 @@ apply plugin: 'elasticsearch.internal-java-rest-test'
 
 dependencies {
   javaRestTestImplementation(testArtifact(project(xpackModule('core'))))
-}
 
-tasks.named("javaRestTest").configure {
-  usesDefaultDistribution()
-}
\ No newline at end of file
+  clusterModules project(':modules:analysis-common')
+  clusterModules project(xpackModule('ilm'))
+  clusterModules project(xpackModule('ccr'))
+}
diff --git a/x-pack/plugin/ilm/qa/with-security/src/javaRestTest/java/org/elasticsearch/xpack/security/PermissionsIT.java b/x-pack/plugin/ilm/qa/with-security/src/javaRestTest/java/org/elasticsearch/xpack/security/PermissionsIT.java
index 12dede7067b03..457842adb1571 100644
--- a/x-pack/plugin/ilm/qa/with-security/src/javaRestTest/java/org/elasticsearch/xpack/security/PermissionsIT.java
+++ b/x-pack/plugin/ilm/qa/with-security/src/javaRestTest/java/org/elasticsearch/xpack/security/PermissionsIT.java
@@ -25,7 +25,6 @@
 import org.elasticsearch.rest.RestStatus;
 import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;
 import org.elasticsearch.test.cluster.ElasticsearchCluster;
-import org.elasticsearch.test.cluster.local.distribution.DistributionType;
 import org.elasticsearch.test.cluster.util.resource.Resource;
 import org.elasticsearch.test.rest.ESRestTestCase;
 import org.elasticsearch.xcontent.XContentBuilder;
@@ -53,9 +52,9 @@ public class PermissionsIT extends ESRestTestCase {
 
     @ClassRule
     public static ElasticsearchCluster cluster = ElasticsearchCluster.local()
-        .distribution(DistributionType.DEFAULT)
-        .setting("xpack.watcher.enabled", "false")
-        .setting("xpack.ml.enabled", "false")
+        .module("x-pack-ilm")
+        .module("x-pack-ccr")
+        .module("analysis-common")
         .setting("xpack.license.self_generated.type", "trial")
         .rolesFile(Resource.fromClasspath("roles.yml"))
         .setting("xpack.security.enabled", "true")
