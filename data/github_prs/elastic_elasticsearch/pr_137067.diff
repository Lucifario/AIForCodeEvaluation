diff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/DeleteSampleConfigurationAction.java b/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/DeleteSampleConfigurationAction.java
index 7df38cb3da494..e6b8ceaefa721 100644
--- a/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/DeleteSampleConfigurationAction.java
+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/DeleteSampleConfigurationAction.java
@@ -14,14 +14,12 @@
 import org.elasticsearch.action.support.IndicesOptions;
 import org.elasticsearch.action.support.master.AcknowledgedRequest;
 import org.elasticsearch.action.support.master.AcknowledgedResponse;
-import org.elasticsearch.common.Strings;
 import org.elasticsearch.common.io.stream.StreamInput;
 import org.elasticsearch.common.io.stream.StreamOutput;
 import org.elasticsearch.core.Nullable;
 import org.elasticsearch.core.TimeValue;
 
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Objects;
 
 /**
@@ -73,7 +71,7 @@ private DeleteSampleConfigurationAction() {
      */
     public static class Request extends AcknowledgedRequest<Request> implements IndicesRequest.Replaceable {
 
-        private String[] indices = Strings.EMPTY_ARRAY;
+        private String index;
 
         /**
          * Constructs a new request with specified timeouts.
@@ -93,7 +91,7 @@ public Request(@Nullable TimeValue masterNodeTimeout, @Nullable TimeValue ackTim
          */
         public Request(StreamInput in) throws IOException {
             super(in);
-            this.indices = in.readStringArray();
+            this.index = in.readString();
         }
 
         /**
@@ -109,7 +107,7 @@ public Request(StreamInput in) throws IOException {
         @Override
         public void writeTo(StreamOutput out) throws IOException {
             super.writeTo(out);
-            out.writeStringArray(indices);
+            out.writeString(index);
         }
 
         /**
@@ -124,15 +122,14 @@ public void writeTo(StreamOutput out) throws IOException {
          */
         @Override
         public String[] indices() {
-            return indices;
+            return new String[] { index };
         }
 
         /**
-         * Sets the array of index names or patterns for this request.
+         * Sets the array of index name for this request.
          * <p>
-         * Specifies which indices and/or data streams should have their sampling
-         * configurations deleted. Supports individual index names, comma-separated
-         * lists, and wildcard patterns.
+         * Specifies which index and/or data stream should have their sampling
+         * configurations deleted. Supports individual index names
          * </p>
          *
          * @param indices the index names or patterns to target, null will be converted to empty array
@@ -140,7 +137,10 @@ public String[] indices() {
          */
         @Override
         public IndicesRequest indices(String... indices) {
-            this.indices = indices == null ? Strings.EMPTY_ARRAY : indices;
+            if (indices == null || indices.length != 1) {
+                throw new IllegalArgumentException("[indices] must contain only one index");
+            }
+            this.index = indices[0];
             return this;
         }
 
@@ -185,7 +185,7 @@ public boolean equals(Object o) {
             if (this == o) return true;
             if (o == null || getClass() != o.getClass()) return false;
             Request request = (Request) o;
-            return Arrays.equals(indices, request.indices)
+            return Objects.equals(index, request.index)
                 && Objects.equals(this.masterNodeTimeout(), request.masterNodeTimeout())
                 && Objects.equals(this.ackTimeout(), request.ackTimeout());
         }
@@ -201,7 +201,7 @@ public boolean equals(Object o) {
          */
         @Override
         public int hashCode() {
-            return Objects.hash(Arrays.hashCode(indices), masterNodeTimeout(), ackTimeout());
+            return Objects.hash(index, masterNodeTimeout(), ackTimeout());
         }
     }
 }
diff --git a/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/TransportDeleteSampleConfigurationActionTests.java b/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/TransportDeleteSampleConfigurationActionTests.java
index aa71f9e836367..11d7b0e7a0fdf 100644
--- a/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/TransportDeleteSampleConfigurationActionTests.java
+++ b/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/TransportDeleteSampleConfigurationActionTests.java
@@ -325,58 +325,21 @@ public void testActionConfiguration() {
     }
 
     /**
-     * Tests that multiple indices in request causes IndexNotFoundException when resolved.
+     * Tests that multiple indices in request causes IllegalArgumentException.
      * The action should only accept single index operations.
      */
-    public void testMasterOperationMultipleIndices() throws Exception {
+    public void testMasterOperationMultipleIndices() {
         // Setup test data
-        ProjectId projectId = randomProjectIdOrDefault();
         String indexName1 = randomIdentifier();
         String indexName2 = randomIdentifier();
         TimeValue masterNodeTimeout = randomTimeValue(100, 200);
         TimeValue ackTimeout = randomTimeValue(100, 200);
 
         DeleteSampleConfigurationAction.Request request = new DeleteSampleConfigurationAction.Request(masterNodeTimeout, ackTimeout);
-        request.indices(indexName1, indexName2);
-
-        ClusterState clusterState = ClusterState.builder(ClusterState.EMPTY_STATE).build();
-        Task task = mock(Task.class);
-
-        // Setup mocks - IndexNameExpressionResolver should throw for multiple indices
-        IndexNotFoundException multipleIndicesException = new IndexNotFoundException("Multiple indices not supported");
-        when(indexNameExpressionResolver.concreteIndexNames(clusterState, request)).thenThrow(multipleIndicesException);
-
-        // Test execution with CountDownLatch to handle async operation
-        CountDownLatch latch = new CountDownLatch(1);
-        AtomicReference<AcknowledgedResponse> responseRef = new AtomicReference<>();
-        AtomicReference<Exception> exceptionRef = new AtomicReference<>();
 
-        ActionListener<AcknowledgedResponse> testListener = new ActionListener<AcknowledgedResponse>() {
-            @Override
-            public void onResponse(AcknowledgedResponse response) {
-                responseRef.set(response);
-                latch.countDown();
-            }
-
-            @Override
-            public void onFailure(Exception e) {
-                exceptionRef.set(e);
-                latch.countDown();
-            }
-        };
-
-        action.masterOperation(task, request, clusterState, testListener);
-
-        // Wait for async operation to complete
-        assertTrue("Operation should complete within timeout", latch.await(5, TimeUnit.SECONDS));
-
-        // Verify results
-        assertThat(responseRef.get(), nullValue());
-        assertThat(exceptionRef.get(), not(nullValue()));
-        assertThat(exceptionRef.get(), sameInstance(multipleIndicesException));
-
-        // Verify interactions
-        verify(indexNameExpressionResolver).concreteIndexNames(clusterState, request);
+        // Verify that setting multiple indices throws IllegalArgumentException
+        IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, () -> request.indices(indexName1, indexName2));
+        assertThat(exception.getMessage(), equalTo("[indices] must contain only one index"));
     }
 
     /**
