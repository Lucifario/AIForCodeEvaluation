{
  "id": 137091,
  "repository": "elastic/elasticsearch",
  "title": "[8.19] Migrate ILM REST tests to new test framework. (#136744)",
  "body": "# Backport\n\nThis will backport the following commits from `main` to `8.19`:\n - [Migrate ILM REST tests to new test framework. (#136744)](https://github.com/elastic/elasticsearch/pull/136744)\n\n<!--- Backport version: 10.0.1 -->\n\n### Questions ?\nPlease refer to the [Backport tool documentation](https://github.com/sorenlouv/backport)",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-24T12:01:43+00:00",
  "created_at": "2025-10-24T10:01:55+00:00",
  "updated_at": "2025-10-24T12:02:06+00:00",
  "author": "mosche",
  "reviewers": [],
  "base_sha": "89eceba7626e066e7172423310d1e0d53d722bd0",
  "head_sha": "6a5d5bda678b7d706c5c64816fb1d79802fba0cd",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/RestrictedBuildApiService.java",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "patch": "@@ -61,9 +61,6 @@ private static ListMultimap<Class<?>, String> createLegacyRestTestBasePluginUsag\n         map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:eql:qa:correctness\");\n         map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:eql:qa:mixed-node\");\n         map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:identity-provider:qa:idp-rest-tests\");\n-        map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:ilm:qa:multi-cluster\");\n-        map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:ilm:qa:multi-node\");\n-        map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:ilm:qa:rest\");\n         map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:ml:qa:basic-multi-node\");\n         map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:ml:qa:disabled\");\n         map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:ml:qa:ml-with-security\");"
    },
    {
      "filename": "test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "patch": "@@ -2552,6 +2552,7 @@ public static Optional<Version> parseLegacyVersion(String version) {\n     protected static void waitForActiveLicense(final RestClient restClient) throws Exception {\n         assertBusy(() -> {\n             final Request request = new Request(HttpGet.METHOD_NAME, \"/_xpack\");\n+            request.addParameter(\"categories\", \"license\");\n             request.setOptions(RequestOptions.DEFAULT.toBuilder());\n \n             final Response response = restClient.performRequest(request);"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-cluster/build.gradle",
      "status": "modified",
      "additions": 18,
      "deletions": 56,
      "changes": 74,
      "patch": "@@ -1,62 +1,24 @@\n-import org.elasticsearch.gradle.internal.test.RestIntegTestTask\n-import org.elasticsearch.gradle.internal.info.BuildParams\n-import static org.elasticsearch.gradle.PropertyNormalization.IGNORE_VALUE\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License\n+ * 2.0; you may not use this file except in compliance with the Elastic License\n+ * 2.0.\n+ */\n \n-apply plugin: 'elasticsearch.internal-testclusters'\n-apply plugin: 'elasticsearch.standalone-rest-test'\n+apply plugin: 'elasticsearch.internal-java-rest-test'\n \n dependencies {\n-  testImplementation project(':x-pack:plugin:core')\n-  testImplementation project(':x-pack:plugin:ilm')\n+  javaRestTestImplementation(testArtifact(project(xpackModule('core'))))\n+  javaRestTestImplementation(testArtifact(project(xpackModule('ccr')), 'javaRestTest'))\n+  javaRestTestImplementation project(xpackModule('ilm'))\n+\n+  clusterModules project(xpackModule('ilm'))\n+  clusterModules project(xpackModule('ccr'))\n+  clusterModules project(xpackModule('searchable-snapshots'))\n+  clusterModules project(':modules:data-streams')\n }\n \n-File repoDir = file(\"$buildDir/testclusters/repo\")\n-\n-tasks.register('leader-cluster', RestIntegTestTask) {\n-  mustRunAfter(\"precommit\")\n-    systemProperty 'tests.target_cluster', 'leader'\n-    /* To support taking index snapshots, we have to set path.repo setting */\n-    nonInputProperties.systemProperty 'tests.path.repo', repoDir.absolutePath\n-}\n-\n-testClusters.matching { it.name == 'leader-cluster' }.configureEach {\n-  testDistribution = 'DEFAULT'\n-  setting 'path.repo', repoDir.absolutePath, IGNORE_VALUE\n-  setting 'xpack.ccr.enabled', 'true'\n-  setting 'xpack.security.enabled', 'false'\n-  setting 'xpack.watcher.enabled', 'false'\n-  setting 'xpack.ml.enabled', 'false'\n-  setting 'xpack.license.self_generated.type', 'trial'\n-  setting 'indices.lifecycle.poll_interval', '1000ms'\n-}\n-\n-tasks.register('follow-cluster', RestIntegTestTask) {\n-  dependsOn tasks.findByName('leader-cluster')\n-  useCluster testClusters.named('leader-cluster')\n-  systemProperty 'tests.target_cluster', 'follow'\n-  nonInputProperties.systemProperty 'tests.leader_host',\n-    \"${-> testClusters.\"leader-cluster\".getAllHttpSocketURI().get(0)}\"\n-  nonInputProperties.systemProperty 'tests.leader_remote_cluster_seed',\n-    \"${-> testClusters.'leader-cluster'.getAllTransportPortURI().get(0)}\"\n-  /* To support taking index snapshots, we have to set path.repo setting */\n-  nonInputProperties.systemProperty 'tests.path.repo', repoDir.absolutePath\n-}\n-\n-testClusters.matching{ it.name == 'follow-cluster' }.configureEach {\n-  testDistribution = 'DEFAULT'\n-  setting 'path.repo', repoDir.absolutePath, IGNORE_VALUE\n-  setting 'xpack.ccr.enabled', 'true'\n-  setting 'xpack.security.enabled', 'false'\n-  setting 'xpack.watcher.enabled', 'false'\n-  setting 'xpack.ml.enabled', 'false'\n-  setting 'xpack.license.self_generated.type', 'trial'\n-  setting 'indices.lifecycle.poll_interval', '1000ms'\n-  setting 'cluster.remote.leader_cluster.seeds',\n-    { \"\\\"${testClusters.'leader-cluster'.getAllTransportPortURI().get(0)}\\\"\" }, IGNORE_VALUE\n-}\n-\n-tasks.named(\"check\").configure { dependsOn 'follow-cluster' }\n-// Security is explicitly disabled for follow-cluster and leader-cluster, do not run these in FIPS mode\n-tasks.withType(Test).configureEach {\n-  enabled = buildParams.inFipsJvm == false\n+tasks.named(\"javaRestTest\") {\n+  // Security is explicitly disabled for follow-cluster and leader-cluster, do not run these in FIPS mode\n+  buildParams.withFipsEnabledOnly(it)\n }"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-cluster/src/javaRestTest/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java",
      "status": "renamed",
      "additions": 79,
      "deletions": 21,
      "changes": 100,
      "patch": "@@ -6,6 +6,9 @@\n  */\n package org.elasticsearch.xpack.ilm;\n \n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n import org.apache.http.entity.ContentType;\n import org.apache.http.entity.StringEntity;\n import org.apache.http.util.EntityUtils;\n@@ -22,15 +25,20 @@\n import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.cluster.ElasticsearchCluster;\n import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.XContentType;\n import org.elasticsearch.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.ccr.AbstractCCRRestTestCase;\n import org.elasticsearch.xpack.core.ilm.LifecycleAction;\n import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n import org.elasticsearch.xpack.core.ilm.Phase;\n import org.elasticsearch.xpack.core.ilm.UnfollowAction;\n import org.elasticsearch.xpack.core.ilm.WaitUntilTimeSeriesEndTimePassesStep;\n+import org.junit.ClassRule;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n \n import java.io.IOException;\n import java.io.InputStream;\n@@ -50,7 +58,7 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class CCRIndexLifecycleIT extends ESCCRRestTestCase {\n+public class CCRIndexLifecycleIT extends AbstractCCRRestTestCase {\n \n     private static final Logger LOGGER = LogManager.getLogger(CCRIndexLifecycleIT.class);\n     private static final String TSDB_INDEX_TEMPLATE = \"\"\"\n@@ -85,18 +93,69 @@ public class CCRIndexLifecycleIT extends ESCCRRestTestCase {\n             }\n         }\"\"\";\n \n+    public static TemporaryFolder repoDir = new TemporaryFolder();\n+\n+    public static ElasticsearchCluster leaderCluster = ElasticsearchCluster.local()\n+        .name(\"leader\")\n+        .module(\"x-pack-ilm\")\n+        .module(\"x-pack-ccr\")\n+        .module(\"searchable-snapshots\")\n+        .module(\"data-streams\")\n+        .setting(\"path.repo\", () -> repoDir.getRoot().getAbsolutePath())\n+        .setting(\"xpack.ccr.enabled\", \"true\")\n+        .setting(\"xpack.security.enabled\", \"false\")\n+        .setting(\"xpack.license.self_generated.type\", \"trial\")\n+        .setting(\"indices.lifecycle.poll_interval\", \"1000ms\")\n+        .build();\n+\n+    public static ElasticsearchCluster followerCluster = ElasticsearchCluster.local()\n+        .name(\"follower\")\n+        .module(\"x-pack-ilm\")\n+        .module(\"x-pack-ccr\")\n+        .module(\"searchable-snapshots\")\n+        .module(\"data-streams\")\n+        .setting(\"path.repo\", () -> repoDir.getRoot().getAbsolutePath())\n+        .setting(\"xpack.ccr.enabled\", \"true\")\n+        .setting(\"xpack.security.enabled\", \"false\")\n+        .setting(\"xpack.license.self_generated.type\", \"trial\")\n+        .setting(\"indices.lifecycle.poll_interval\", \"1000ms\")\n+        .setting(\"cluster.remote.leader_cluster.seeds\", () -> \"\\\"\" + leaderCluster.getTransportEndpoints() + \"\\\"\")\n+        .build();\n+\n+    @ClassRule\n+    public static RuleChain ruleChain = RuleChain.outerRule(repoDir).around(leaderCluster).around(followerCluster);\n+\n+    public CCRIndexLifecycleIT(@Name(\"targetCluster\") TargetCluster targetCluster) {\n+        super(targetCluster);\n+    }\n+\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        return leaderFollower();\n+    }\n+\n+    @Override\n+    protected ElasticsearchCluster getFollowerCluster() {\n+        return followerCluster;\n+    }\n+\n+    @Override\n+    protected ElasticsearchCluster getLeaderCluster() {\n+        return leaderCluster;\n+    }\n+\n     public void testBasicCCRAndILMIntegration() throws Exception {\n         String indexName = \"logs-1\";\n \n         String policyName = \"basic-test\";\n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             putILMPolicy(policyName, \"50GB\", null, TimeValue.timeValueHours(7 * 24));\n             Settings indexSettings = indexSettings(1, 0).put(\"index.lifecycle.name\", policyName)\n                 .put(\"index.lifecycle.rollover_alias\", \"logs\")\n                 .build();\n             createIndex(indexName, indexSettings, \"\", \"\\\"logs\\\": { }\");\n             ensureGreen(indexName);\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             // Policy with the same name must exist in follower cluster too:\n             putILMPolicy(policyName, \"50GB\", null, TimeValue.timeValueHours(7 * 24));\n             followIndex(indexName, indexName);\n@@ -133,7 +192,7 @@ public void testBasicCCRAndILMIntegration() throws Exception {\n                     // ILM should have unfollowed the follower index, so the following_index setting should have been removed:\n                     // (this controls whether the follow engine is used)\n                     assertThat(getIndexSetting(client(), indexName, \"index.xpack.ccr.following_index\"), nullValue());\n-                });\n+                }, 30, TimeUnit.SECONDS);\n             }\n         } else {\n             fail(\"unexpected target cluster [\" + targetCluster + \"]\");\n@@ -142,10 +201,10 @@ public void testBasicCCRAndILMIntegration() throws Exception {\n \n     public void testCCRUnfollowDuringSnapshot() throws Exception {\n         String indexName = \"unfollow-test-index\";\n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             createIndex(adminClient(), indexName, indexSettings(2, 0).build());\n             ensureGreen(indexName);\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             createNewSingletonPolicy(\"unfollow-only\", \"hot\", UnfollowAction.INSTANCE, TimeValue.ZERO);\n             followIndex(indexName, indexName);\n             ensureGreen(indexName);\n@@ -159,7 +218,7 @@ public void testCCRUnfollowDuringSnapshot() throws Exception {\n                         .field(\"type\", \"fs\")\n                         .startObject(\"settings\")\n                         .field(\"compress\", randomBoolean())\n-                        .field(\"location\", System.getProperty(\"tests.path.repo\"))\n+                        .field(\"location\", repoDir.getRoot().getAbsolutePath())\n                         .field(\"max_snapshot_bytes_per_sec\", \"256b\")\n                         .endObject()\n                         .endObject()\n@@ -212,7 +271,7 @@ public void testCcrAndIlmWithRollover() throws Exception {\n         String nextIndexName = \"mymetrics-000002\";\n         String policyName = \"rollover-test\";\n \n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             // Create a policy on the leader\n             putILMPolicy(policyName, null, 1, null);\n             Request templateRequest = new Request(\"PUT\", \"/_index_template/my_template\");\n@@ -223,7 +282,7 @@ public void testCcrAndIlmWithRollover() throws Exception {\n                 \"{\\\"index_patterns\\\":  [\\\"mymetrics-*\\\"], \\\"template\\\":{\\\"settings\\\":  \" + Strings.toString(indexSettings) + \"}}\"\n             );\n             assertOK(client().performRequest(templateRequest));\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             // Policy with the same name must exist in follower cluster too:\n             putILMPolicy(policyName, null, 1, null);\n \n@@ -327,7 +386,7 @@ public void testAliasReplicatedOnShrink() throws Exception {\n         final String policyName = \"shrink-test-policy\";\n         final int numberOfAliases = randomIntBetween(0, 4);\n \n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             // this policy won't exist on the leader, that's fine\n             Settings indexSettings = indexSettings(3, 0).put(\"index.lifecycle.name\", policyName).build();\n             final StringBuilder aliases = new StringBuilder();\n@@ -346,7 +405,7 @@ public void testAliasReplicatedOnShrink() throws Exception {\n             }\n             createIndex(indexName, indexSettings, \"\", aliases.toString());\n             ensureGreen(indexName);\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             // Create a policy with just a Shrink action on the follower\n             putShrinkOnlyPolicy(client(), policyName);\n \n@@ -388,12 +447,12 @@ public void testUnfollowInjectedBeforeShrink() throws Exception {\n         final String indexName = \"shrink-test\";\n         final String policyName = \"shrink-test-policy\";\n \n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             // this policy won't exist on the leader, that's fine\n             Settings indexSettings = indexSettings(3, 0).put(\"index.lifecycle.name\", policyName).build();\n             createIndex(indexName, indexSettings, \"\", \"\");\n             ensureGreen(indexName);\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             // Create a policy with just a Shrink action on the follower\n             putShrinkOnlyPolicy(client(), policyName);\n \n@@ -430,14 +489,14 @@ public void testUnfollowInjectedBeforeShrink() throws Exception {\n     public void testCannotShrinkLeaderIndex() throws Exception {\n         String indexName = \"shrink-leader-test\";\n         String policyName = \"shrink-leader-test-policy\";\n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             // Set up the policy and index, but don't attach the policy yet,\n             // otherwise it'll proceed through shrink before we can set up the\n             // follower\n             putShrinkOnlyPolicy(client(), policyName);\n             createIndex(indexName, indexSettings(2, 0).build(), \"\", \"\");\n             ensureGreen(indexName);\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n \n             try (RestClient leaderClient = buildLeaderClient()) {\n                 // Policy with the same name must exist in follower cluster too:\n@@ -502,16 +561,15 @@ public void testILMUnfollowFailsToRemoveRetentionLeases() throws Exception {\n         final String followerIndex = \"follower\";\n         final String policyName = \"unfollow_only_policy\";\n \n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             Settings indexSettings = indexSettings(1, 0).put(\"index.lifecycle.name\", policyName) // this policy won't exist on the leader,\n                                                                                                  // that's fine\n                 .build();\n             createIndex(leaderIndex, indexSettings, \"\", \"\");\n             ensureGreen(leaderIndex);\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             try (RestClient leaderClient = buildLeaderClient()) {\n-                String leaderRemoteClusterSeed = System.getProperty(\"tests.leader_remote_cluster_seed\");\n-                configureRemoteClusters(\"other_remote\", leaderRemoteClusterSeed);\n+                configureRemoteClusters(\"other_remote\", leaderCluster.getTransportEndpoints());\n                 assertBusy(() -> {\n                     Map<?, ?> localConnection = (Map<?, ?>) toMap(client().performRequest(new Request(\"GET\", \"/_remote/info\"))).get(\n                         \"other_remote\"\n@@ -576,12 +634,12 @@ public void testTsdbLeaderIndexRolloverAndSyncAfterWaitUntilEndTime() throws Exc\n         String dataStream = \"tsdb-index-cpu\";\n         String policyName = \"tsdb-policy\";\n \n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             putILMPolicy(policyName, null, 1, null);\n             Request templateRequest = new Request(\"PUT\", \"/_index_template/tsdb_template\");\n             templateRequest.setJsonEntity(Strings.format(TSDB_INDEX_TEMPLATE, indexPattern, policyName));\n             assertOK(client().performRequest(templateRequest));\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             // Use unfollow-only policy for follower cluster instead of regular ILM policy\n             // Follower clusters should not have their own rollover actions as they are meant\n             // to follow the rollover behavior of the leader index, not initiate their own rollovers"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/ESCCRRestTestCase.java",
      "status": "removed",
      "additions": 0,
      "deletions": 410,
      "changes": 410,
      "patch": "@@ -1,410 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License\n- * 2.0; you may not use this file except in compliance with the Elastic License\n- * 2.0.\n- */\n-\n-package org.elasticsearch.xpack.ilm;\n-\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License\n- * 2.0; you may not use this file except in compliance with the Elastic License\n- * 2.0.\n- */\n-\n-import org.apache.http.HttpHost;\n-import org.apache.http.util.EntityUtils;\n-import org.elasticsearch.client.Request;\n-import org.elasticsearch.client.Response;\n-import org.elasticsearch.client.ResponseException;\n-import org.elasticsearch.client.RestClient;\n-import org.elasticsearch.cluster.metadata.DataStream;\n-import org.elasticsearch.common.Strings;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.common.util.LazyInitializable;\n-import org.elasticsearch.common.xcontent.XContentHelper;\n-import org.elasticsearch.common.xcontent.support.XContentMapValues;\n-import org.elasticsearch.rest.RestStatus;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n-import org.elasticsearch.xcontent.ToXContent;\n-import org.elasticsearch.xcontent.XContentBuilder;\n-import org.elasticsearch.xcontent.json.JsonXContent;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import static org.elasticsearch.rest.action.search.RestSearchAction.TOTAL_HITS_AS_INT_PARAM;\n-import static org.elasticsearch.xcontent.XContentFactory.jsonBuilder;\n-import static org.hamcrest.Matchers.endsWith;\n-import static org.hamcrest.Matchers.equalTo;\n-import static org.hamcrest.Matchers.greaterThan;\n-import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n-import static org.hamcrest.Matchers.hasSize;\n-\n-public abstract class ESCCRRestTestCase extends ESRestTestCase {\n-\n-    protected final String targetCluster = System.getProperty(\"tests.target_cluster\");\n-\n-    @Override\n-    protected boolean preserveClusterUponCompletion() {\n-        return true;\n-    }\n-\n-    protected static void index(String index, String id, Object... fields) throws IOException {\n-        index(adminClient(), index, id, fields);\n-    }\n-\n-    protected static void index(RestClient client, String index, String id, Object... fields) throws IOException {\n-        XContentBuilder document = jsonBuilder().startObject();\n-        for (int i = 0; i < fields.length; i += 2) {\n-            document.field((String) fields[i], fields[i + 1]);\n-        }\n-        document.endObject();\n-        final Request request = new Request(\"POST\", \"/\" + index + \"/_doc\" + (id == null ? \"\" : \"/\" + id));\n-        request.setJsonEntity(Strings.toString(document));\n-        assertOK(client.performRequest(request));\n-    }\n-\n-    protected static void resumeFollow(String followIndex) throws IOException {\n-        final Request request = new Request(\"POST\", \"/\" + followIndex + \"/_ccr/resume_follow\");\n-        request.setJsonEntity(\"{\\\"read_poll_timeout\\\": \\\"10ms\\\"}\");\n-        assertOK(client().performRequest(request));\n-    }\n-\n-    protected static void followIndex(String leaderIndex, String followIndex) throws IOException {\n-        followIndex(\"leader_cluster\", leaderIndex, followIndex);\n-    }\n-\n-    protected static void followIndex(String leaderCluster, String leaderIndex, String followIndex) throws IOException {\n-        followIndex(client(), leaderCluster, leaderIndex, followIndex);\n-    }\n-\n-    protected static void followIndex(RestClient client, String leaderCluster, String leaderIndex, String followIndex) throws IOException {\n-        followIndex(client, leaderCluster, leaderIndex, followIndex, null);\n-    }\n-\n-    protected static void followIndex(\n-        final RestClient client,\n-        final String leaderCluster,\n-        final String leaderIndex,\n-        final String followIndex,\n-        final Settings settings\n-    ) throws IOException {\n-        final Request request = new Request(\"PUT\", \"/\" + followIndex + \"/_ccr/follow?wait_for_active_shards=1\");\n-        try (XContentBuilder bodyBuilder = JsonXContent.contentBuilder()) {\n-            bodyBuilder.startObject();\n-            {\n-                bodyBuilder.field(\"remote_cluster\", leaderCluster);\n-                bodyBuilder.field(\"leader_index\", leaderIndex);\n-                bodyBuilder.field(\"read_poll_timeout\", \"10ms\");\n-                if (settings != null) {\n-                    bodyBuilder.startObject(\"settings\");\n-                    {\n-                        settings.toXContent(bodyBuilder, ToXContent.EMPTY_PARAMS);\n-                    }\n-                    bodyBuilder.endObject();\n-                }\n-            }\n-            bodyBuilder.endObject();\n-            request.setJsonEntity(Strings.toString(bodyBuilder));\n-        }\n-        assertOK(client.performRequest(request));\n-    }\n-\n-    protected static void pauseFollow(String followIndex) throws IOException {\n-        pauseFollow(client(), followIndex);\n-    }\n-\n-    protected static void pauseFollow(RestClient client, String followIndex) throws IOException {\n-        assertOK(client.performRequest(new Request(\"POST\", \"/\" + followIndex + \"/_ccr/pause_follow\")));\n-    }\n-\n-    protected static void putAutoFollowPattern(String patternName, String remoteCluster, String indexPattern) throws IOException {\n-        Request putPatternRequest = new Request(\"PUT\", \"/_ccr/auto_follow/\" + patternName);\n-        putPatternRequest.setJsonEntity(String.format(Locale.ROOT, \"\"\"\n-            {\"leader_index_patterns\": [\"%s\"], \"remote_cluster\": \"%s\"}\n-            \"\"\", indexPattern, remoteCluster));\n-        assertOK(client().performRequest(putPatternRequest));\n-    }\n-\n-    protected static void deleteAutoFollowPattern(String patternName) throws IOException {\n-        deleteAutoFollowPattern(client(), patternName);\n-    }\n-\n-    protected static void deleteAutoFollowPattern(RestClient client, String patternName) throws IOException {\n-        Request putPatternRequest = new Request(\"DELETE\", \"/_ccr/auto_follow/\" + patternName);\n-        assertOK(client.performRequest(putPatternRequest));\n-    }\n-\n-    protected static void unfollow(String followIndex) throws IOException {\n-        assertOK(client().performRequest(new Request(\"POST\", \"/\" + followIndex + \"/_ccr/unfollow\")));\n-    }\n-\n-    protected static void verifyDocuments(final String index, final int expectedNumDocs, final String query) throws IOException {\n-        verifyDocuments(index, expectedNumDocs, query, adminClient());\n-    }\n-\n-    protected static void verifyDocuments(final String index, final int expectedNumDocs, final String query, final RestClient client)\n-        throws IOException {\n-        final Request request = new Request(\"GET\", \"/\" + index + \"/_search\");\n-        request.addParameter(\"size\", Integer.toString(expectedNumDocs));\n-        request.addParameter(\"sort\", \"field:asc\");\n-        request.addParameter(\"q\", query);\n-        request.addParameter(TOTAL_HITS_AS_INT_PARAM, \"true\");\n-        Map<String, ?> response = toMap(client.performRequest(request));\n-\n-        int numDocs = (int) XContentMapValues.extractValue(\"hits.total\", response);\n-        assertThat(index, numDocs, equalTo(expectedNumDocs));\n-\n-        List<?> hits = (List<?>) XContentMapValues.extractValue(\"hits.hits\", response);\n-        assertThat(hits.size(), equalTo(expectedNumDocs));\n-        for (int i = 0; i < expectedNumDocs; i++) {\n-            int value = (int) XContentMapValues.extractValue(\"_source.field\", (Map<?, ?>) hits.get(i));\n-            assertThat(index, i, equalTo(value));\n-        }\n-    }\n-\n-    protected static void verifyDocuments(final RestClient client, final String index, final int expectedNumDocs) throws IOException {\n-        final Request request = new Request(\"GET\", \"/\" + index + \"/_search\");\n-        request.addParameter(TOTAL_HITS_AS_INT_PARAM, \"true\");\n-        Map<String, ?> response = toMap(client.performRequest(request));\n-\n-        int numDocs = (int) XContentMapValues.extractValue(\"hits.total\", response);\n-        assertThat(index, numDocs, equalTo(expectedNumDocs));\n-    }\n-\n-    protected static void verifyCcrMonitoring(final String expectedLeaderIndex, final String expectedFollowerIndex) throws IOException {\n-        Request request = new Request(\"GET\", \"/.monitoring-*/_search\");\n-        request.setJsonEntity(String.format(Locale.ROOT, \"\"\"\n-            {\"query\": {\"term\": {\"ccr_stats.leader_index\": \"%s\"}}}\n-            \"\"\", expectedLeaderIndex));\n-        Map<String, ?> response;\n-        try {\n-            response = toMap(adminClient().performRequest(request));\n-        } catch (ResponseException e) {\n-            throw new AssertionError(\"error while searching\", e);\n-        }\n-\n-        int followerMaxSeqNo = 0;\n-        int followerMappingVersion = 0;\n-        int followerSettingsVersion = 0;\n-        int followerAliasesVersion = 0;\n-\n-        List<?> hits = (List<?>) XContentMapValues.extractValue(\"hits.hits\", response);\n-        assertThat(hits.size(), greaterThanOrEqualTo(1));\n-\n-        for (int i = 0; i < hits.size(); i++) {\n-            Map<?, ?> hit = (Map<?, ?>) hits.get(i);\n-            String leaderIndex = (String) XContentMapValues.extractValue(\"_source.ccr_stats.leader_index\", hit);\n-            assertThat(leaderIndex, endsWith(expectedLeaderIndex));\n-\n-            final String followerIndex = (String) XContentMapValues.extractValue(\"_source.ccr_stats.follower_index\", hit);\n-            assertThat(followerIndex, equalTo(expectedFollowerIndex));\n-\n-            int foundFollowerMaxSeqNo = (int) XContentMapValues.extractValue(\"_source.ccr_stats.follower_max_seq_no\", hit);\n-            followerMaxSeqNo = Math.max(followerMaxSeqNo, foundFollowerMaxSeqNo);\n-            int foundFollowerMappingVersion = (int) XContentMapValues.extractValue(\"_source.ccr_stats.follower_mapping_version\", hit);\n-            followerMappingVersion = Math.max(followerMappingVersion, foundFollowerMappingVersion);\n-            int foundFollowerSettingsVersion = (int) XContentMapValues.extractValue(\"_source.ccr_stats.follower_settings_version\", hit);\n-            followerSettingsVersion = Math.max(followerSettingsVersion, foundFollowerSettingsVersion);\n-            int foundFollowerAliasesVersion = (int) XContentMapValues.extractValue(\"_source.ccr_stats.follower_aliases_version\", hit);\n-            followerAliasesVersion = Math.max(followerAliasesVersion, foundFollowerAliasesVersion);\n-        }\n-\n-        assertThat(followerMaxSeqNo, greaterThan(0));\n-        assertThat(followerMappingVersion, greaterThan(0));\n-        assertThat(followerSettingsVersion, greaterThan(0));\n-        assertThat(followerAliasesVersion, greaterThan(0));\n-    }\n-\n-    protected static void verifyAutoFollowMonitoring() throws IOException {\n-        Request request = new Request(\"GET\", \"/.monitoring-*/_count\");\n-        request.setJsonEntity(\"\"\"\n-                {\n-                  \"query\": {\n-                    \"bool\" : {\n-                      \"filter\": {\n-                        \"term\" : { \"type\" : \"ccr_auto_follow_stats\" }\n-                      },\n-                      \"must\" : {\n-                        \"range\" : {\n-                          \"ccr_auto_follow_stats.number_of_successful_follow_indices\" : { \"gt\" : 0 }\n-                        }\n-                      }\n-                    }\n-                  }\n-                }\n-            \"\"\");\n-        String responseEntity;\n-        Map<String, ?> response;\n-        try {\n-            responseEntity = EntityUtils.toString(adminClient().performRequest(request).getEntity());\n-            response = toMap(responseEntity);\n-        } catch (ResponseException e) {\n-            throw new AssertionError(\"error while searching\", e);\n-        }\n-        assertNotNull(responseEntity);\n-\n-        final Number count = (Number) XContentMapValues.extractValue(\"count\", response);\n-        assertThat(\n-            \"Expected at least 1 successfully followed index but found none, count returned [\" + responseEntity + ']',\n-            count.longValue(),\n-            greaterThanOrEqualTo(1L)\n-        );\n-    }\n-\n-    protected static Map<String, Object> toMap(Response response) throws IOException {\n-        return toMap(EntityUtils.toString(response.getEntity()));\n-    }\n-\n-    protected static Map<String, Object> toMap(String response) {\n-        return XContentHelper.convertToMap(JsonXContent.jsonXContent, response, false);\n-    }\n-\n-    protected static void ensureYellow(final String index) throws IOException {\n-        ensureYellow(index, adminClient());\n-    }\n-\n-    protected static void ensureYellow(final String index, final RestClient client) throws IOException {\n-        ensureHealth(client, index, request -> {\n-            request.addParameter(\"wait_for_status\", \"yellow\");\n-            request.addParameter(\"wait_for_active_shards\", \"1\");\n-            request.addParameter(\"wait_for_no_relocating_shards\", \"true\");\n-            // follower index can be yellow even when its primary shards are still initializing as we bootstrap them using snapshot/restore.\n-            request.addParameter(\"wait_for_no_initializing_shards\", \"true\");\n-            request.addParameter(\"timeout\", \"5s\");\n-            request.addParameter(\"level\", \"shards\");\n-        });\n-    }\n-\n-    protected Set<CcrNodeTask> getCcrNodeTasks() throws IOException {\n-        final Request request = new Request(\"GET\", \"/_tasks\");\n-        request.addParameter(\"detailed\", \"true\");\n-        Map<String, Object> rsp1 = toMap(adminClient().performRequest(request));\n-        Map<?, ?> nodes = (Map<?, ?>) rsp1.get(\"nodes\");\n-        assertThat(nodes.size(), equalTo(1));\n-        Map<?, ?> node = (Map<?, ?>) nodes.values().iterator().next();\n-        Map<?, ?> nodeTasks = (Map<?, ?>) node.get(\"tasks\");\n-        var ccrNodeTasks = new HashSet<CcrNodeTask>();\n-        for (Map.Entry<?, ?> entry : nodeTasks.entrySet()) {\n-            Map<?, ?> nodeTask = (Map<?, ?>) entry.getValue();\n-            String action = (String) nodeTask.get(\"action\");\n-            if (action.startsWith(\"xpack/ccr/shard_follow_task\")) {\n-                var status = (Map<?, ?>) nodeTask.get(\"status\");\n-                ccrNodeTasks.add(\n-                    new CcrNodeTask(\n-                        (String) status.get(\"remote_cluster\"),\n-                        (String) status.get(\"leader_index\"),\n-                        (String) status.get(\"follower_index\"),\n-                        (Integer) status.get(\"shard_id\")\n-                    )\n-                );\n-            }\n-        }\n-        return ccrNodeTasks;\n-    }\n-\n-    protected record CcrNodeTask(String remoteCluster, String leaderIndex, String followerIndex, int shardId) {}\n-\n-    protected static boolean indexExists(String index) throws IOException {\n-        Response response = adminClient().performRequest(new Request(\"HEAD\", \"/\" + index));\n-        return RestStatus.OK.getStatus() == response.getStatusLine().getStatusCode();\n-    }\n-\n-    protected static List<String> verifyDataStream(final RestClient client, final String name, final String... expectedBackingIndices)\n-        throws IOException {\n-        Request request = new Request(\"GET\", \"/_data_stream/\" + name);\n-        Map<String, ?> response = toMap(client.performRequest(request));\n-        List<?> retrievedDataStreams = (List<?>) response.get(\"data_streams\");\n-        assertThat(retrievedDataStreams, hasSize(1));\n-        List<?> actualBackingIndexItems = (List<?>) ((Map<?, ?>) retrievedDataStreams.get(0)).get(\"indices\");\n-        assertThat(actualBackingIndexItems, hasSize(expectedBackingIndices.length));\n-        final List<String> actualBackingIndices = new ArrayList<>();\n-        for (int i = 0; i < expectedBackingIndices.length; i++) {\n-            Map<?, ?> actualBackingIndexItem = (Map<?, ?>) actualBackingIndexItems.get(i);\n-            String actualBackingIndex = (String) actualBackingIndexItem.get(\"index_name\");\n-            String expectedBackingIndex = expectedBackingIndices[i];\n-\n-            String actualDataStreamName = actualBackingIndex.substring(5, actualBackingIndex.indexOf('-', 5));\n-            String expectedDataStreamName = expectedBackingIndex.substring(5, expectedBackingIndex.indexOf('-', 5));\n-            assertThat(actualDataStreamName, equalTo(expectedDataStreamName));\n-\n-            int actualGeneration = Integer.parseInt(actualBackingIndex.substring(actualBackingIndex.lastIndexOf('-')));\n-            int expectedGeneration = Integer.parseInt(expectedBackingIndex.substring(expectedBackingIndex.lastIndexOf('-')));\n-            assertThat(actualGeneration, equalTo(expectedGeneration));\n-            actualBackingIndices.add(actualBackingIndex);\n-        }\n-        return List.copyOf(actualBackingIndices);\n-    }\n-\n-    protected static void createAutoFollowPattern(\n-        RestClient client,\n-        String name,\n-        String pattern,\n-        String remoteCluster,\n-        String followIndexPattern\n-    ) throws IOException {\n-        Request request = new Request(\"PUT\", \"/_ccr/auto_follow/\" + name);\n-        try (XContentBuilder bodyBuilder = JsonXContent.contentBuilder()) {\n-            bodyBuilder.startObject();\n-            {\n-                bodyBuilder.array(\"leader_index_patterns\", pattern);\n-                if (followIndexPattern != null) {\n-                    bodyBuilder.field(\"follow_index_pattern\", followIndexPattern);\n-                }\n-                bodyBuilder.field(\"remote_cluster\", remoteCluster);\n-            }\n-            bodyBuilder.endObject();\n-            request.setJsonEntity(Strings.toString(bodyBuilder));\n-        }\n-        assertOK(client.performRequest(request));\n-    }\n-\n-    /**\n-     * Fix point in time when data stream backing index is first time queried.\n-     * This is required to avoid failures when running test at midnight.\n-     * (index is created for day0, but assertions are executed for day1 assuming different time based index name that does not exist)\n-     */\n-    private final LazyInitializable<Long, RuntimeException> time = new LazyInitializable<>(System::currentTimeMillis);\n-\n-    protected String backingIndexName(String dataStreamName, int generation) {\n-        return DataStream.getDefaultBackingIndexName(dataStreamName, generation, time.getOrCompute());\n-    }\n-\n-    protected RestClient buildLeaderClient() throws IOException {\n-        assert \"leader\".equals(targetCluster) == false;\n-        return buildClient(System.getProperty(\"tests.leader_host\"));\n-    }\n-\n-    protected RestClient buildLeaderClient(final Settings settings) throws IOException {\n-        assert \"leader\".equals(targetCluster) == false;\n-        return buildClient(System.getProperty(\"tests.leader_host\"), settings);\n-    }\n-\n-    protected RestClient buildMiddleClient() throws IOException {\n-        assert \"middle\".equals(targetCluster) == false;\n-        return buildClient(System.getProperty(\"tests.middle_host\"));\n-    }\n-\n-    private RestClient buildClient(final String url) throws IOException {\n-        return buildClient(url, restAdminSettings());\n-    }\n-\n-    private RestClient buildClient(final String url, final Settings settings) throws IOException {\n-        int portSeparator = url.lastIndexOf(':');\n-        HttpHost httpHost = new HttpHost(\n-            url.substring(0, portSeparator),\n-            Integer.parseInt(url.substring(portSeparator + 1)),\n-            getProtocol()\n-        );\n-        return buildClient(settings, new HttpHost[] { httpHost });\n-    }\n-\n-}"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/build.gradle",
      "status": "modified",
      "additions": 15,
      "deletions": 36,
      "changes": 51,
      "patch": "@@ -1,46 +1,25 @@\n-import org.elasticsearch.gradle.internal.info.BuildParams\n-import static org.elasticsearch.gradle.PropertyNormalization.IGNORE_VALUE\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License\n+ * 2.0; you may not use this file except in compliance with the Elastic License\n+ * 2.0.\n+ */\n \n-apply plugin: 'elasticsearch.legacy-java-rest-test'\n+apply plugin: 'elasticsearch.internal-java-rest-test'\n \n dependencies {\n   javaRestTestImplementation(testArtifact(project(xpackModule('core'))))\n   javaRestTestImplementation project(xpackModule('ilm'))\n-}\n-\n-File repoDir = file(\"$buildDir/testclusters/repo\")\n-\n-tasks.named(\"javaRestTest\").configure {\n-  /* To support taking index snapshots, we have to set path.repo setting */\n-  nonInputProperties.systemProperty 'tests.path.repo', repoDir\n-}\n-\n-testClusters.configureEach {\n-  testDistribution = 'DEFAULT'\n-  numberOfNodes = 4\n \n-  setting 'path.repo', repoDir.absolutePath, IGNORE_VALUE\n-  setting 'xpack.searchable.snapshot.shared_cache.size', '16MB'\n-  setting 'xpack.searchable.snapshot.shared_cache.region_size', '256KB'\n-  setting 'xpack.security.enabled', 'false'\n-  setting 'xpack.watcher.enabled', 'false'\n-  setting 'xpack.ml.enabled', 'false'\n-  setting 'xpack.license.self_generated.type', 'trial'\n-  setting 'indices.lifecycle.poll_interval', '1000ms'\n-  setting 'logger.org.elasticsearch.xpack.core.ilm', 'TRACE'\n-  setting 'logger.org.elasticsearch.xpack.ilm', 'TRACE'\n-  /*\n-   * In TimeSeriesLifecycleActionsIT.testWaitForSnapshotSlmExecutedBefore() we create a snapshot, then associate an ILM policy with an index, and\n-   * then that policy checks if a snapshot has been started at the same millisecond or later than the policy's action's date. Since both the\n-   * snapshot start time and policy are using ThreadPool.absoluteTimeInMillis(), it is possible that they get the same cached result back (it is\n-   * kept for about 200 ms). The following config changes ThreadPool.absoluteTimeInMillis() to always use System.currentTimeMillis() rather than a\n-   * cached time. So the policy's action date is always after the snapshot's start.\n-   */\n-  setting 'thread_pool.estimated_time_interval', '0'\n-  setting 'time_series.poll_interval', '10m'\n+  clusterModules project(xpackModule('ilm'))\n+  clusterModules project(xpackModule('slm'))\n+  clusterModules project(xpackModule('ccr'))\n+  clusterModules project(xpackModule('downsample'))\n+  clusterModules project(xpackModule('searchable-snapshots'))\n+  clusterModules project(':modules:data-streams')\n }\n \n-if (buildParams.inFipsJvm){\n+if (buildParams.inFipsJvm) {\n   // Test clusters run with security disabled\n-  tasks.named(\"javaRestTest\").configure{enabled = false }\n+  tasks.named(\"javaRestTest\").configure { enabled = false }\n }"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/IlmESRestTestCase.java",
      "status": "added",
      "additions": 70,
      "deletions": 0,
      "changes": 70,
      "patch": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License\n+ * 2.0; you may not use this file except in compliance with the Elastic License\n+ * 2.0.\n+ */\n+\n+package org.elasticsearch.xpack;\n+\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.test.cluster.ElasticsearchCluster;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.junit.ClassRule;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class IlmESRestTestCase extends ESRestTestCase {\n+    static final String USER = \"user\";\n+    static final String PASSWORD = \"x-pack-test-password\";\n+\n+    public static TemporaryFolder repoDir = new TemporaryFolder();\n+\n+    public static ElasticsearchCluster cluster = ElasticsearchCluster.local()\n+        .module(\"x-pack-ilm\")\n+        .module(\"x-pack-slm\")\n+        .module(\"x-pack-ccr\")\n+        .module(\"x-pack-downsample\")\n+        .module(\"searchable-snapshots\")\n+        .module(\"data-streams\")\n+        .nodes(4)\n+        .setting(\"path.repo\", () -> repoDir.getRoot().getAbsolutePath())\n+        .setting(\"xpack.searchable.snapshot.shared_cache.size\", \"16MB\")\n+        .setting(\"xpack.searchable.snapshot.shared_cache.region_size\", \"256KB\")\n+        .setting(\"xpack.security.enabled\", \"false\")\n+        .setting(\"xpack.license.self_generated.type\", \"trial\")\n+        .setting(\"indices.lifecycle.poll_interval\", \"1000ms\")\n+        .setting(\"logger.org.elasticsearch.xpack.core.ilm\", \"TRACE\")\n+        .setting(\"logger.org.elasticsearch.xpack.ilm\", \"TRACE\")\n+        // The TRACE logs of the history store are too verbose and not useful, so we set it to INFO\n+        .setting(\"logger.org.elasticsearch.xpack.ilm.history.ILMHistoryStore\", \"INFO\")\n+        /*\n+         * In TimeSeriesLifecycleActionsIT.testWaitForSnapshotSlmExecutedBefore() we create a snapshot, then associate an ILM policy with\n+         * an index, and then that policy checks if a snapshot has been started at the same millisecond or later than the policy's action's\n+         * date. Since both the snapshot start time and policy are using ThreadPool.absoluteTimeInMillis(), it is possible that they get\n+         * the same cached result back (it is kept for about 200 ms). The following config changes ThreadPool.absoluteTimeInMillis() to\n+         * always use System.currentTimeMillis() rather than a cached time. So the policy's action date is always after the snapshot's\n+         * start.\n+         */\n+        .setting(\"thread_pool.estimated_time_interval\", \"0\")\n+        .setting(\"time_series.poll_interval\", \"10m\")\n+        // Disable shard balancing to avoid force merges failing due to relocating shards.\n+        .setting(\"cluster.routing.rebalance.enable\", \"none\")\n+        .user(USER, PASSWORD)\n+        .build();\n+\n+    @ClassRule\n+    public static RuleChain ruleChain = RuleChain.outerRule(repoDir).around(cluster);\n+\n+    protected String getTestRestCluster() {\n+        return cluster.getHttpAddresses();\n+    }\n+\n+    @Override\n+    protected Settings restClientSettings() {\n+        String token = basicAuthHeaderValue(USER, new SecureString(PASSWORD.toCharArray()));\n+        return Settings.builder().put(super.restClientSettings()).put(ThreadContext.PREFIX + \".Authorization\", token).build();\n+    }\n+}"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/MigrateToDataTiersIT.java",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "patch": "@@ -23,7 +23,6 @@\n import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;\n import org.elasticsearch.test.XContentTestUtils;\n import org.elasticsearch.test.XContentTestUtils.JsonMapView;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xpack.cluster.action.MigrateToDataTiersResponse;\n import org.elasticsearch.xpack.core.ilm.AllocateAction;\n import org.elasticsearch.xpack.core.ilm.AllocationRoutedStep;\n@@ -61,7 +60,7 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class MigrateToDataTiersIT extends ESRestTestCase {\n+public class MigrateToDataTiersIT extends IlmESRestTestCase {\n     private String index;\n     private String policy;\n     private String alias;"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java",
      "status": "modified",
      "additions": 2,
      "deletions": 14,
      "changes": 16,
      "patch": "@@ -197,26 +197,14 @@ public static void createFullPolicy(RestClient client, String policyName, TimeVa\n         warmActions.put(ForceMergeAction.NAME, new ForceMergeAction(1, null));\n         warmActions.put(\n             AllocateAction.NAME,\n-            new AllocateAction(\n-                1,\n-                null,\n-                Map.of(\"_name\", \"javaRestTest-0,javaRestTest-1,\" + \"javaRestTest-2,\" + \"javaRestTest-3\"),\n-                null,\n-                null\n-            )\n+            new AllocateAction(1, null, Map.of(\"_name\", \"test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3\"), null, null)\n         );\n         warmActions.put(ShrinkAction.NAME, new ShrinkAction(1, null, false));\n         Map<String, LifecycleAction> coldActions = new HashMap<>();\n         coldActions.put(SetPriorityAction.NAME, new SetPriorityAction(0));\n         coldActions.put(\n             AllocateAction.NAME,\n-            new AllocateAction(\n-                0,\n-                null,\n-                Map.of(\"_name\", \"javaRestTest-0,javaRestTest-1,\" + \"javaRestTest-2,\" + \"javaRestTest-3\"),\n-                null,\n-                null\n-            )\n+            new AllocateAction(0, null, Map.of(\"_name\", \"test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3\"), null, null)\n         );\n         Map<String, Phase> phases = new HashMap<>();\n         phases.put(\"hot\", new Phase(\"hot\", hotTime, hotActions));"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ChangePolicyForIndexIT.java",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "patch": "@@ -15,8 +15,8 @@\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.core.TimeValue;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.AllocateAction;\n import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n@@ -37,7 +37,7 @@\n import static org.elasticsearch.xpack.TimeSeriesRestDriver.createNewSingletonPolicy;\n import static org.elasticsearch.xpack.TimeSeriesRestDriver.indexDocument;\n \n-public class ChangePolicyForIndexIT extends ESRestTestCase {\n+public class ChangePolicyForIndexIT extends IlmESRestTestCase {\n \n     /**\n      * This test aims to prove that an index will finish the current phase on an\n@@ -94,7 +94,7 @@ public void testChangePolicyForIndex() throws Exception {\n                 TimeValue.ZERO,\n                 Map.of(\n                     AllocateAction.NAME,\n-                    new AllocateAction(1, null, Map.of(\"_name\", \"javaRestTest-0,javaRestTest-1,javaRestTest-2,javaRestTest-3\"), null, null)\n+                    new AllocateAction(1, null, Map.of(\"_name\", \"test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3\"), null, null)\n                 )\n             )\n         );\n@@ -117,7 +117,7 @@ public void testChangePolicyForIndex() throws Exception {\n         Settings settings = Settings.builder()\n             .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4)\n             .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n-            .put(\"index.routing.allocation.include._name\", \"javaRestTest-0\")\n+            .put(\"index.routing.allocation.include._name\", \"test-cluster-0\")\n             .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, \"alias\")\n             .put(LifecycleSettings.LIFECYCLE_NAME, \"policy_1\")\n             .build();\n@@ -161,10 +161,10 @@ public void testChangePolicyForIndex() throws Exception {\n         // Check the index goes to the warm phase and completes\n         assertBusy(() -> assertStep(indexName, PhaseCompleteStep.finalStep(\"warm\").getKey()), 30, TimeUnit.SECONDS);\n \n-        // Check index is allocated on javaRestTest-1 and javaRestTest-2 as per policy_2\n+        // Check index is allocated on test-cluster-1 and test-cluster-2 as per policy_2\n         Map<String, Object> indexSettings = getIndexSettingsAsMap(indexName);\n         String includesAllocation = (String) indexSettings.get(\"index.routing.allocation.include._name\");\n-        assertEquals(\"javaRestTest-0,javaRestTest-1,javaRestTest-2,javaRestTest-3\", includesAllocation);\n+        assertEquals(\"test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3\", includesAllocation);\n     }\n \n     public void testILMHonoursTheCachedPhaseAfterPolicyUpdate() throws Exception {"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ExplainLifecycleIT.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "patch": "@@ -18,8 +18,8 @@\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.core.TimeValue;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.DeleteAction;\n import org.elasticsearch.xpack.core.ilm.ErrorStep;\n import org.elasticsearch.xpack.core.ilm.LifecycleAction;\n@@ -52,7 +52,7 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class ExplainLifecycleIT extends ESRestTestCase {\n+public class ExplainLifecycleIT extends IlmESRestTestCase {\n     private static final Logger logger = LogManager.getLogger(ExplainLifecycleIT.class);\n     private static final String FAILED_STEP_RETRY_COUNT_FIELD = \"failed_step_retry_count\";\n     private static final String IS_AUTO_RETRYABLE_ERROR_FIELD = \"is_auto_retryable_error\";"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/LifecycleLicenseIT.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "patch": "@@ -17,10 +17,10 @@\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.license.License;\n import org.elasticsearch.license.TestUtils;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.ToXContent;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.ErrorStep;\n import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n import org.elasticsearch.xpack.core.ilm.PhaseCompleteStep;\n@@ -45,7 +45,7 @@\n import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n import static org.hamcrest.Matchers.is;\n \n-public class LifecycleLicenseIT extends ESRestTestCase {\n+public class LifecycleLicenseIT extends IlmESRestTestCase {\n \n     private String policy;\n     private String dataStream;"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesDataStreamsIT.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "patch": "@@ -14,8 +14,8 @@\n import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.index.engine.EngineConfig;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentType;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.CheckNotDataStreamWriteIndexStep;\n import org.elasticsearch.xpack.core.ilm.DeleteAction;\n import org.elasticsearch.xpack.core.ilm.DeleteStep;\n@@ -52,7 +52,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.oneOf;\n \n-public class TimeSeriesDataStreamsIT extends ESRestTestCase {\n+public class TimeSeriesDataStreamsIT extends IlmESRestTestCase {\n \n     private String policyName;\n     private String dataStream;"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "patch": "@@ -25,10 +25,10 @@\n import org.elasticsearch.index.engine.EngineConfig;\n import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;\n import org.elasticsearch.snapshots.SnapshotState;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.XContentType;\n import org.elasticsearch.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.AllocateAction;\n import org.elasticsearch.xpack.core.ilm.DeleteAction;\n import org.elasticsearch.xpack.core.ilm.ErrorStep;\n@@ -79,7 +79,7 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class TimeSeriesLifecycleActionsIT extends ESRestTestCase {\n+public class TimeSeriesLifecycleActionsIT extends IlmESRestTestCase {\n     private static final Logger logger = LogManager.getLogger(TimeSeriesLifecycleActionsIT.class);\n     private static final String FAILED_STEP_RETRY_COUNT_FIELD = \"failed_step_retry_count\";\n \n@@ -105,7 +105,7 @@ public void testFullPolicy() throws Exception {\n             Settings.builder()\n                 .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 2)\n                 .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n-                .put(\"index.routing.allocation.include._name\", \"javaRestTest-0\")\n+                .put(\"index.routing.allocation.include._name\", \"test-cluster-0\")\n                 .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, alias)\n         );\n \n@@ -216,7 +216,7 @@ public void testAllocateOnlyAllocation() throws Exception {\n             alias,\n             Settings.builder().put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 2).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n         );\n-        String allocateNodeName = \"javaRestTest-0,javaRestTest-1,javaRestTest-2,javaRestTest-3\";\n+        String allocateNodeName = \"test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3\";\n         AllocateAction allocateAction = new AllocateAction(null, null, Map.of(\"_name\", allocateNodeName), null, null);\n         String endPhase = randomFrom(\"warm\", \"cold\");\n         createNewSingletonPolicy(client(), policy, endPhase, allocateAction);\n@@ -441,7 +441,7 @@ public void testDeleteDuringSnapshot() throws Exception {\n                     .field(\"type\", \"fs\")\n                     .startObject(\"settings\")\n                     .field(\"compress\", randomBoolean())\n-                    .field(\"location\", System.getProperty(\"tests.path.repo\"))\n+                    .field(\"location\", repoDir.getRoot().getAbsolutePath())\n                     .field(\"max_snapshot_bytes_per_sec\", \"256b\")\n                     .endObject()\n                     .endObject()"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeseriesMoveToStepIT.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "patch": "@@ -15,7 +15,7 @@\n import org.elasticsearch.cluster.metadata.IndexMetadata;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.core.TimeValue;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.DeleteAction;\n import org.elasticsearch.xpack.core.ilm.ForceMergeAction;\n import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n@@ -39,7 +39,7 @@\n import static org.hamcrest.Matchers.containsStringIgnoringCase;\n import static org.hamcrest.Matchers.equalTo;\n \n-public class TimeseriesMoveToStepIT extends ESRestTestCase {\n+public class TimeseriesMoveToStepIT extends IlmESRestTestCase {\n     private static final Logger logger = LogManager.getLogger(TimeseriesMoveToStepIT.class);\n \n     private String policy;\n@@ -64,7 +64,7 @@ public void testMoveToAllocateStep() throws Exception {\n             Settings.builder()\n                 .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4)\n                 .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n-                .put(\"index.routing.allocation.include._name\", \"javaRestTest-0\")\n+                .put(\"index.routing.allocation.include._name\", \"test-cluster-0\")\n                 .put(LifecycleSettings.LIFECYCLE_NAME, policy)\n                 .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, \"alias\")\n         );\n@@ -102,7 +102,7 @@ public void testMoveToRolloverStep() throws Exception {\n             Settings.builder()\n                 .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4)\n                 .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n-                .put(\"index.routing.allocation.include._name\", \"javaRestTest-0\")\n+                .put(\"index.routing.allocation.include._name\", \"test-cluster-0\")\n                 .put(LifecycleSettings.LIFECYCLE_NAME, policy)\n                 .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, alias)\n         );"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/DownsampleActionIT.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "patch": "@@ -23,9 +23,9 @@\n import org.elasticsearch.index.IndexSettings;\n import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;\n import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramInterval;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.XContentFactory;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.CheckNotDataStreamWriteIndexStep;\n import org.elasticsearch.xpack.core.ilm.DownsampleAction;\n import org.elasticsearch.xpack.core.ilm.LifecycleAction;\n@@ -57,7 +57,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.notNullValue;\n \n-public class DownsampleActionIT extends ESRestTestCase {\n+public class DownsampleActionIT extends IlmESRestTestCase {\n \n     private String index;\n     private String policy;"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ReadonlyActionIT.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "patch": "@@ -12,7 +12,7 @@\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.core.TimeValue;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.LifecycleAction;\n import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n@@ -34,7 +34,7 @@\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class ReadonlyActionIT extends ESRestTestCase {\n+public class ReadonlyActionIT extends IlmESRestTestCase {\n     private static final String FAILED_STEP_RETRY_COUNT_FIELD = \"failed_step_retry_count\";\n \n     private String policy;"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/RolloverActionIT.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "patch": "@@ -17,7 +17,7 @@\n import org.elasticsearch.core.Strings;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n import org.elasticsearch.xpack.core.ilm.PhaseCompleteStep;\n import org.elasticsearch.xpack.core.ilm.RolloverAction;\n@@ -29,6 +29,7 @@\n import java.util.Map;\n import java.util.concurrent.TimeUnit;\n \n+import static org.elasticsearch.test.ESTestCase.randomAlphaOfLength;\n import static org.elasticsearch.xpack.TimeSeriesRestDriver.createIndexWithSettings;\n import static org.elasticsearch.xpack.TimeSeriesRestDriver.createNewSingletonPolicy;\n import static org.elasticsearch.xpack.TimeSeriesRestDriver.explainIndex;\n@@ -41,7 +42,7 @@\n import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n import static org.hamcrest.Matchers.is;\n \n-public class RolloverActionIT extends ESRestTestCase {\n+public class RolloverActionIT extends IlmESRestTestCase {\n \n     private static final String FAILED_STEP_RETRY_COUNT_FIELD = \"failed_step_retry_count\";\n "
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "patch": "@@ -19,9 +19,9 @@\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.core.TimeValue;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.XContentType;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.AllocateAction;\n import org.elasticsearch.xpack.core.ilm.DeleteAction;\n import org.elasticsearch.xpack.core.ilm.ForceMergeAction;\n@@ -65,7 +65,7 @@\n import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n import static org.hamcrest.Matchers.is;\n \n-public class SearchableSnapshotActionIT extends ESRestTestCase {\n+public class SearchableSnapshotActionIT extends IlmESRestTestCase {\n \n     private String policy;\n     private String dataStream;"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ShrinkActionIT.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "patch": "@@ -19,9 +19,9 @@\n import org.elasticsearch.common.unit.ByteSizeValue;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.CheckTargetShardsCountStep;\n import org.elasticsearch.xpack.core.ilm.LifecycleAction;\n import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n@@ -56,7 +56,7 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class ShrinkActionIT extends ESRestTestCase {\n+public class ShrinkActionIT extends IlmESRestTestCase {\n     private static final String FAILED_STEP_RETRY_COUNT_FIELD = \"failed_step_retry_count\";\n     private static final String SHRINK_INDEX_NAME = \"shrink_index_name\";\n \n@@ -152,7 +152,7 @@ public void testShrinkDuringSnapshot() throws Exception {\n                     .field(\"type\", \"fs\")\n                     .startObject(\"settings\")\n                     .field(\"compress\", randomBoolean())\n-                    .field(\"location\", System.getProperty(\"tests.path.repo\"))\n+                    .field(\"location\", repoDir.getRoot().getAbsolutePath())\n                     .field(\"max_snapshot_bytes_per_sec\", \"256b\")\n                     .endObject()\n                     .endObject()\n@@ -170,7 +170,7 @@ public void testShrinkDuringSnapshot() throws Exception {\n                 .put(SETTING_NUMBER_OF_SHARDS, 2)\n                 .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n                 // required so the shrink doesn't wait on SetSingleNodeAllocateStep\n-                .put(IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getKey() + \"_name\", \"javaRestTest-0\")\n+                .put(IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getKey() + \"_name\", \"test-cluster-0\")\n         );\n         // index document so snapshot actually does something\n         indexDocument(client(), index);"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/rest/build.gradle",
      "status": "modified",
      "additions": 15,
      "deletions": 9,
      "changes": 24,
      "patch": "@@ -1,9 +1,10 @@\n-apply plugin: 'elasticsearch.legacy-yaml-rest-test'\n-apply plugin: 'elasticsearch.legacy-yaml-rest-compat-test'\n-apply plugin: 'elasticsearch.authenticated-testclusters'\n+\n+apply plugin: 'elasticsearch.internal-yaml-rest-test'\n \n dependencies {\n-  yamlRestTestImplementation(testArtifact(project(xpackModule('core'))))\n+  yamlRestTestImplementation project(':x-pack:qa')\n+\n+  clusterModules project(xpackModule('ilm'))\n }\n \n restResources {\n@@ -12,9 +13,14 @@ restResources {\n   }\n }\n \n-testClusters.configureEach {\n-  testDistribution = 'DEFAULT'\n-  setting 'xpack.ml.enabled', 'false'\n-  setting 'xpack.license.self_generated.type', 'trial'\n-  setting 'xpack.security.autoconfiguration.enabled', 'false'\n+configurations {\n+  basicRestSpecs {\n+    attributes {\n+      attribute(ArtifactTypeDefinition.ARTIFACT_TYPE_ATTRIBUTE, ArtifactTypeDefinition.DIRECTORY_TYPE)\n+    }\n+  }\n+}\n+\n+artifacts {\n+  basicRestSpecs(new File(projectDir, \"src/yamlRestTest/resources/rest-api-spec/test\"))\n }"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/ilm/IndexLifecycleRestIT.java",
      "status": "modified",
      "additions": 20,
      "deletions": 10,
      "changes": 30,
      "patch": "@@ -15,31 +15,41 @@\n import org.elasticsearch.common.settings.SecureString;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.test.cluster.ElasticsearchCluster;\n import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n-\n-import java.util.Objects;\n-\n-import static org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;\n+import org.junit.ClassRule;\n \n @TimeoutSuite(millis = 30 * TimeUnits.MINUTE) // as default timeout seems not enough on the jenkins VMs\n public class IndexLifecycleRestIT extends ESClientYamlSuiteTestCase {\n \n-    private static final String USER = Objects.requireNonNull(System.getProperty(\"tests.rest.cluster.username\"));\n-    private static final String PASS = Objects.requireNonNull(System.getProperty(\"tests.rest.cluster.password\"));\n+    static final String USER = \"user\";\n+    static final String PASSWORD = \"x-pack-test-password\";\n \n-    public IndexLifecycleRestIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n-        super(testCandidate);\n-    }\n+    @ClassRule\n+    public static ElasticsearchCluster cluster = ElasticsearchCluster.local()\n+        .module(\"x-pack-ilm\")\n+        .setting(\"xpack.license.self_generated.type\", \"trial\")\n+        .setting(\"xpack.security.autoconfiguration.enabled\", \"false\")\n+        .user(USER, PASSWORD)\n+        .build();\n \n     @ParametersFactory\n     public static Iterable<Object[]> parameters() throws Exception {\n         return createParameters();\n     }\n \n+    public IndexLifecycleRestIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    protected String getTestRestCluster() {\n+        return cluster.getHttpAddresses();\n+    }\n+\n     @Override\n     protected Settings restClientSettings() {\n-        String token = basicAuthHeaderValue(USER, new SecureString(PASS.toCharArray()));\n+        String token = basicAuthHeaderValue(USER, new SecureString(PASSWORD.toCharArray()));\n         return Settings.builder().put(super.restClientSettings()).put(ThreadContext.PREFIX + \".Authorization\", token).build();\n     }\n }"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/with-security/build.gradle",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "patch": "@@ -2,8 +2,8 @@ apply plugin: 'elasticsearch.internal-java-rest-test'\n \n dependencies {\n   javaRestTestImplementation(testArtifact(project(xpackModule('core'))))\n-}\n \n-tasks.named(\"javaRestTest\").configure {\n-  usesDefaultDistribution()\n-}\n\\ No newline at end of file\n+  clusterModules project(':modules:analysis-common')\n+  clusterModules project(xpackModule('ilm'))\n+  clusterModules project(xpackModule('ccr'))\n+}"
    },
    {
      "filename": "x-pack/plugin/ilm/qa/with-security/src/javaRestTest/java/org/elasticsearch/xpack/security/PermissionsIT.java",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "patch": "@@ -25,7 +25,6 @@\n import org.elasticsearch.rest.RestStatus;\n import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;\n import org.elasticsearch.test.cluster.ElasticsearchCluster;\n-import org.elasticsearch.test.cluster.local.distribution.DistributionType;\n import org.elasticsearch.test.cluster.util.resource.Resource;\n import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n@@ -53,9 +52,9 @@ public class PermissionsIT extends ESRestTestCase {\n \n     @ClassRule\n     public static ElasticsearchCluster cluster = ElasticsearchCluster.local()\n-        .distribution(DistributionType.DEFAULT)\n-        .setting(\"xpack.watcher.enabled\", \"false\")\n-        .setting(\"xpack.ml.enabled\", \"false\")\n+        .module(\"x-pack-ilm\")\n+        .module(\"x-pack-ccr\")\n+        .module(\"analysis-common\")\n         .setting(\"xpack.license.self_generated.type\", \"trial\")\n         .rolesFile(Resource.fromClasspath(\"roles.yml\"))\n         .setting(\"xpack.security.enabled\", \"true\")"
    }
  ],
  "diff": "diff --git a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/RestrictedBuildApiService.java b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/RestrictedBuildApiService.java\nindex 4e9f08bc48f38..11290cb64afdb 100644\n--- a/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/RestrictedBuildApiService.java\n+++ b/build-tools-internal/src/main/java/org/elasticsearch/gradle/internal/RestrictedBuildApiService.java\n@@ -61,9 +61,6 @@ private static ListMultimap<Class<?>, String> createLegacyRestTestBasePluginUsag\n         map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:eql:qa:correctness\");\n         map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:eql:qa:mixed-node\");\n         map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:identity-provider:qa:idp-rest-tests\");\n-        map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:ilm:qa:multi-cluster\");\n-        map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:ilm:qa:multi-node\");\n-        map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:ilm:qa:rest\");\n         map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:ml:qa:basic-multi-node\");\n         map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:ml:qa:disabled\");\n         map.put(LegacyRestTestBasePlugin.class, \":x-pack:plugin:ml:qa:ml-with-security\");\ndiff --git a/test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java b/test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java\nindex 02c823bfde6c9..c9f1b7c28c528 100644\n--- a/test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java\n+++ b/test/framework/src/main/java/org/elasticsearch/test/rest/ESRestTestCase.java\n@@ -2552,6 +2552,7 @@ public static Optional<Version> parseLegacyVersion(String version) {\n     protected static void waitForActiveLicense(final RestClient restClient) throws Exception {\n         assertBusy(() -> {\n             final Request request = new Request(HttpGet.METHOD_NAME, \"/_xpack\");\n+            request.addParameter(\"categories\", \"license\");\n             request.setOptions(RequestOptions.DEFAULT.toBuilder());\n \n             final Response response = restClient.performRequest(request);\ndiff --git a/x-pack/plugin/ilm/qa/multi-cluster/build.gradle b/x-pack/plugin/ilm/qa/multi-cluster/build.gradle\nindex eede706b5d403..a7e3d3b7515e9 100644\n--- a/x-pack/plugin/ilm/qa/multi-cluster/build.gradle\n+++ b/x-pack/plugin/ilm/qa/multi-cluster/build.gradle\n@@ -1,62 +1,24 @@\n-import org.elasticsearch.gradle.internal.test.RestIntegTestTask\n-import org.elasticsearch.gradle.internal.info.BuildParams\n-import static org.elasticsearch.gradle.PropertyNormalization.IGNORE_VALUE\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License\n+ * 2.0; you may not use this file except in compliance with the Elastic License\n+ * 2.0.\n+ */\n \n-apply plugin: 'elasticsearch.internal-testclusters'\n-apply plugin: 'elasticsearch.standalone-rest-test'\n+apply plugin: 'elasticsearch.internal-java-rest-test'\n \n dependencies {\n-  testImplementation project(':x-pack:plugin:core')\n-  testImplementation project(':x-pack:plugin:ilm')\n+  javaRestTestImplementation(testArtifact(project(xpackModule('core'))))\n+  javaRestTestImplementation(testArtifact(project(xpackModule('ccr')), 'javaRestTest'))\n+  javaRestTestImplementation project(xpackModule('ilm'))\n+\n+  clusterModules project(xpackModule('ilm'))\n+  clusterModules project(xpackModule('ccr'))\n+  clusterModules project(xpackModule('searchable-snapshots'))\n+  clusterModules project(':modules:data-streams')\n }\n \n-File repoDir = file(\"$buildDir/testclusters/repo\")\n-\n-tasks.register('leader-cluster', RestIntegTestTask) {\n-  mustRunAfter(\"precommit\")\n-    systemProperty 'tests.target_cluster', 'leader'\n-    /* To support taking index snapshots, we have to set path.repo setting */\n-    nonInputProperties.systemProperty 'tests.path.repo', repoDir.absolutePath\n-}\n-\n-testClusters.matching { it.name == 'leader-cluster' }.configureEach {\n-  testDistribution = 'DEFAULT'\n-  setting 'path.repo', repoDir.absolutePath, IGNORE_VALUE\n-  setting 'xpack.ccr.enabled', 'true'\n-  setting 'xpack.security.enabled', 'false'\n-  setting 'xpack.watcher.enabled', 'false'\n-  setting 'xpack.ml.enabled', 'false'\n-  setting 'xpack.license.self_generated.type', 'trial'\n-  setting 'indices.lifecycle.poll_interval', '1000ms'\n-}\n-\n-tasks.register('follow-cluster', RestIntegTestTask) {\n-  dependsOn tasks.findByName('leader-cluster')\n-  useCluster testClusters.named('leader-cluster')\n-  systemProperty 'tests.target_cluster', 'follow'\n-  nonInputProperties.systemProperty 'tests.leader_host',\n-    \"${-> testClusters.\"leader-cluster\".getAllHttpSocketURI().get(0)}\"\n-  nonInputProperties.systemProperty 'tests.leader_remote_cluster_seed',\n-    \"${-> testClusters.'leader-cluster'.getAllTransportPortURI().get(0)}\"\n-  /* To support taking index snapshots, we have to set path.repo setting */\n-  nonInputProperties.systemProperty 'tests.path.repo', repoDir.absolutePath\n-}\n-\n-testClusters.matching{ it.name == 'follow-cluster' }.configureEach {\n-  testDistribution = 'DEFAULT'\n-  setting 'path.repo', repoDir.absolutePath, IGNORE_VALUE\n-  setting 'xpack.ccr.enabled', 'true'\n-  setting 'xpack.security.enabled', 'false'\n-  setting 'xpack.watcher.enabled', 'false'\n-  setting 'xpack.ml.enabled', 'false'\n-  setting 'xpack.license.self_generated.type', 'trial'\n-  setting 'indices.lifecycle.poll_interval', '1000ms'\n-  setting 'cluster.remote.leader_cluster.seeds',\n-    { \"\\\"${testClusters.'leader-cluster'.getAllTransportPortURI().get(0)}\\\"\" }, IGNORE_VALUE\n-}\n-\n-tasks.named(\"check\").configure { dependsOn 'follow-cluster' }\n-// Security is explicitly disabled for follow-cluster and leader-cluster, do not run these in FIPS mode\n-tasks.withType(Test).configureEach {\n-  enabled = buildParams.inFipsJvm == false\n+tasks.named(\"javaRestTest\") {\n+  // Security is explicitly disabled for follow-cluster and leader-cluster, do not run these in FIPS mode\n+  buildParams.withFipsEnabledOnly(it)\n }\ndiff --git a/x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java b/x-pack/plugin/ilm/qa/multi-cluster/src/javaRestTest/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java\nsimilarity index 93%\nrename from x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java\nrename to x-pack/plugin/ilm/qa/multi-cluster/src/javaRestTest/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java\nindex 0b26c0c323abe..72e59c08cb69f 100644\n--- a/x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-cluster/src/javaRestTest/java/org/elasticsearch/xpack/ilm/CCRIndexLifecycleIT.java\n@@ -6,6 +6,9 @@\n  */\n package org.elasticsearch.xpack.ilm;\n \n+import com.carrotsearch.randomizedtesting.annotations.Name;\n+import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;\n+\n import org.apache.http.entity.ContentType;\n import org.apache.http.entity.StringEntity;\n import org.apache.http.util.EntityUtils;\n@@ -22,15 +25,20 @@\n import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.cluster.ElasticsearchCluster;\n import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.XContentType;\n import org.elasticsearch.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.ccr.AbstractCCRRestTestCase;\n import org.elasticsearch.xpack.core.ilm.LifecycleAction;\n import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n import org.elasticsearch.xpack.core.ilm.Phase;\n import org.elasticsearch.xpack.core.ilm.UnfollowAction;\n import org.elasticsearch.xpack.core.ilm.WaitUntilTimeSeriesEndTimePassesStep;\n+import org.junit.ClassRule;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n \n import java.io.IOException;\n import java.io.InputStream;\n@@ -50,7 +58,7 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class CCRIndexLifecycleIT extends ESCCRRestTestCase {\n+public class CCRIndexLifecycleIT extends AbstractCCRRestTestCase {\n \n     private static final Logger LOGGER = LogManager.getLogger(CCRIndexLifecycleIT.class);\n     private static final String TSDB_INDEX_TEMPLATE = \"\"\"\n@@ -85,18 +93,69 @@ public class CCRIndexLifecycleIT extends ESCCRRestTestCase {\n             }\n         }\"\"\";\n \n+    public static TemporaryFolder repoDir = new TemporaryFolder();\n+\n+    public static ElasticsearchCluster leaderCluster = ElasticsearchCluster.local()\n+        .name(\"leader\")\n+        .module(\"x-pack-ilm\")\n+        .module(\"x-pack-ccr\")\n+        .module(\"searchable-snapshots\")\n+        .module(\"data-streams\")\n+        .setting(\"path.repo\", () -> repoDir.getRoot().getAbsolutePath())\n+        .setting(\"xpack.ccr.enabled\", \"true\")\n+        .setting(\"xpack.security.enabled\", \"false\")\n+        .setting(\"xpack.license.self_generated.type\", \"trial\")\n+        .setting(\"indices.lifecycle.poll_interval\", \"1000ms\")\n+        .build();\n+\n+    public static ElasticsearchCluster followerCluster = ElasticsearchCluster.local()\n+        .name(\"follower\")\n+        .module(\"x-pack-ilm\")\n+        .module(\"x-pack-ccr\")\n+        .module(\"searchable-snapshots\")\n+        .module(\"data-streams\")\n+        .setting(\"path.repo\", () -> repoDir.getRoot().getAbsolutePath())\n+        .setting(\"xpack.ccr.enabled\", \"true\")\n+        .setting(\"xpack.security.enabled\", \"false\")\n+        .setting(\"xpack.license.self_generated.type\", \"trial\")\n+        .setting(\"indices.lifecycle.poll_interval\", \"1000ms\")\n+        .setting(\"cluster.remote.leader_cluster.seeds\", () -> \"\\\"\" + leaderCluster.getTransportEndpoints() + \"\\\"\")\n+        .build();\n+\n+    @ClassRule\n+    public static RuleChain ruleChain = RuleChain.outerRule(repoDir).around(leaderCluster).around(followerCluster);\n+\n+    public CCRIndexLifecycleIT(@Name(\"targetCluster\") TargetCluster targetCluster) {\n+        super(targetCluster);\n+    }\n+\n+    @ParametersFactory\n+    public static Iterable<Object[]> parameters() throws Exception {\n+        return leaderFollower();\n+    }\n+\n+    @Override\n+    protected ElasticsearchCluster getFollowerCluster() {\n+        return followerCluster;\n+    }\n+\n+    @Override\n+    protected ElasticsearchCluster getLeaderCluster() {\n+        return leaderCluster;\n+    }\n+\n     public void testBasicCCRAndILMIntegration() throws Exception {\n         String indexName = \"logs-1\";\n \n         String policyName = \"basic-test\";\n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             putILMPolicy(policyName, \"50GB\", null, TimeValue.timeValueHours(7 * 24));\n             Settings indexSettings = indexSettings(1, 0).put(\"index.lifecycle.name\", policyName)\n                 .put(\"index.lifecycle.rollover_alias\", \"logs\")\n                 .build();\n             createIndex(indexName, indexSettings, \"\", \"\\\"logs\\\": { }\");\n             ensureGreen(indexName);\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             // Policy with the same name must exist in follower cluster too:\n             putILMPolicy(policyName, \"50GB\", null, TimeValue.timeValueHours(7 * 24));\n             followIndex(indexName, indexName);\n@@ -133,7 +192,7 @@ public void testBasicCCRAndILMIntegration() throws Exception {\n                     // ILM should have unfollowed the follower index, so the following_index setting should have been removed:\n                     // (this controls whether the follow engine is used)\n                     assertThat(getIndexSetting(client(), indexName, \"index.xpack.ccr.following_index\"), nullValue());\n-                });\n+                }, 30, TimeUnit.SECONDS);\n             }\n         } else {\n             fail(\"unexpected target cluster [\" + targetCluster + \"]\");\n@@ -142,10 +201,10 @@ public void testBasicCCRAndILMIntegration() throws Exception {\n \n     public void testCCRUnfollowDuringSnapshot() throws Exception {\n         String indexName = \"unfollow-test-index\";\n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             createIndex(adminClient(), indexName, indexSettings(2, 0).build());\n             ensureGreen(indexName);\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             createNewSingletonPolicy(\"unfollow-only\", \"hot\", UnfollowAction.INSTANCE, TimeValue.ZERO);\n             followIndex(indexName, indexName);\n             ensureGreen(indexName);\n@@ -159,7 +218,7 @@ public void testCCRUnfollowDuringSnapshot() throws Exception {\n                         .field(\"type\", \"fs\")\n                         .startObject(\"settings\")\n                         .field(\"compress\", randomBoolean())\n-                        .field(\"location\", System.getProperty(\"tests.path.repo\"))\n+                        .field(\"location\", repoDir.getRoot().getAbsolutePath())\n                         .field(\"max_snapshot_bytes_per_sec\", \"256b\")\n                         .endObject()\n                         .endObject()\n@@ -212,7 +271,7 @@ public void testCcrAndIlmWithRollover() throws Exception {\n         String nextIndexName = \"mymetrics-000002\";\n         String policyName = \"rollover-test\";\n \n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             // Create a policy on the leader\n             putILMPolicy(policyName, null, 1, null);\n             Request templateRequest = new Request(\"PUT\", \"/_index_template/my_template\");\n@@ -223,7 +282,7 @@ public void testCcrAndIlmWithRollover() throws Exception {\n                 \"{\\\"index_patterns\\\":  [\\\"mymetrics-*\\\"], \\\"template\\\":{\\\"settings\\\":  \" + Strings.toString(indexSettings) + \"}}\"\n             );\n             assertOK(client().performRequest(templateRequest));\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             // Policy with the same name must exist in follower cluster too:\n             putILMPolicy(policyName, null, 1, null);\n \n@@ -327,7 +386,7 @@ public void testAliasReplicatedOnShrink() throws Exception {\n         final String policyName = \"shrink-test-policy\";\n         final int numberOfAliases = randomIntBetween(0, 4);\n \n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             // this policy won't exist on the leader, that's fine\n             Settings indexSettings = indexSettings(3, 0).put(\"index.lifecycle.name\", policyName).build();\n             final StringBuilder aliases = new StringBuilder();\n@@ -346,7 +405,7 @@ public void testAliasReplicatedOnShrink() throws Exception {\n             }\n             createIndex(indexName, indexSettings, \"\", aliases.toString());\n             ensureGreen(indexName);\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             // Create a policy with just a Shrink action on the follower\n             putShrinkOnlyPolicy(client(), policyName);\n \n@@ -388,12 +447,12 @@ public void testUnfollowInjectedBeforeShrink() throws Exception {\n         final String indexName = \"shrink-test\";\n         final String policyName = \"shrink-test-policy\";\n \n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             // this policy won't exist on the leader, that's fine\n             Settings indexSettings = indexSettings(3, 0).put(\"index.lifecycle.name\", policyName).build();\n             createIndex(indexName, indexSettings, \"\", \"\");\n             ensureGreen(indexName);\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             // Create a policy with just a Shrink action on the follower\n             putShrinkOnlyPolicy(client(), policyName);\n \n@@ -430,14 +489,14 @@ public void testUnfollowInjectedBeforeShrink() throws Exception {\n     public void testCannotShrinkLeaderIndex() throws Exception {\n         String indexName = \"shrink-leader-test\";\n         String policyName = \"shrink-leader-test-policy\";\n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             // Set up the policy and index, but don't attach the policy yet,\n             // otherwise it'll proceed through shrink before we can set up the\n             // follower\n             putShrinkOnlyPolicy(client(), policyName);\n             createIndex(indexName, indexSettings(2, 0).build(), \"\", \"\");\n             ensureGreen(indexName);\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n \n             try (RestClient leaderClient = buildLeaderClient()) {\n                 // Policy with the same name must exist in follower cluster too:\n@@ -502,16 +561,15 @@ public void testILMUnfollowFailsToRemoveRetentionLeases() throws Exception {\n         final String followerIndex = \"follower\";\n         final String policyName = \"unfollow_only_policy\";\n \n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             Settings indexSettings = indexSettings(1, 0).put(\"index.lifecycle.name\", policyName) // this policy won't exist on the leader,\n                                                                                                  // that's fine\n                 .build();\n             createIndex(leaderIndex, indexSettings, \"\", \"\");\n             ensureGreen(leaderIndex);\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             try (RestClient leaderClient = buildLeaderClient()) {\n-                String leaderRemoteClusterSeed = System.getProperty(\"tests.leader_remote_cluster_seed\");\n-                configureRemoteClusters(\"other_remote\", leaderRemoteClusterSeed);\n+                configureRemoteClusters(\"other_remote\", leaderCluster.getTransportEndpoints());\n                 assertBusy(() -> {\n                     Map<?, ?> localConnection = (Map<?, ?>) toMap(client().performRequest(new Request(\"GET\", \"/_remote/info\"))).get(\n                         \"other_remote\"\n@@ -576,12 +634,12 @@ public void testTsdbLeaderIndexRolloverAndSyncAfterWaitUntilEndTime() throws Exc\n         String dataStream = \"tsdb-index-cpu\";\n         String policyName = \"tsdb-policy\";\n \n-        if (\"leader\".equals(targetCluster)) {\n+        if (targetCluster == TargetCluster.LEADER) {\n             putILMPolicy(policyName, null, 1, null);\n             Request templateRequest = new Request(\"PUT\", \"/_index_template/tsdb_template\");\n             templateRequest.setJsonEntity(Strings.format(TSDB_INDEX_TEMPLATE, indexPattern, policyName));\n             assertOK(client().performRequest(templateRequest));\n-        } else if (\"follow\".equals(targetCluster)) {\n+        } else if (targetCluster == TargetCluster.FOLLOWER) {\n             // Use unfollow-only policy for follower cluster instead of regular ILM policy\n             // Follower clusters should not have their own rollover actions as they are meant\n             // to follow the rollover behavior of the leader index, not initiate their own rollovers\ndiff --git a/x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/ESCCRRestTestCase.java b/x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/ESCCRRestTestCase.java\ndeleted file mode 100644\nindex 47ad640bc906f..0000000000000\n--- a/x-pack/plugin/ilm/qa/multi-cluster/src/test/java/org/elasticsearch/xpack/ilm/ESCCRRestTestCase.java\n+++ /dev/null\n@@ -1,410 +0,0 @@\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License\n- * 2.0; you may not use this file except in compliance with the Elastic License\n- * 2.0.\n- */\n-\n-package org.elasticsearch.xpack.ilm;\n-\n-/*\n- * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n- * or more contributor license agreements. Licensed under the Elastic License\n- * 2.0; you may not use this file except in compliance with the Elastic License\n- * 2.0.\n- */\n-\n-import org.apache.http.HttpHost;\n-import org.apache.http.util.EntityUtils;\n-import org.elasticsearch.client.Request;\n-import org.elasticsearch.client.Response;\n-import org.elasticsearch.client.ResponseException;\n-import org.elasticsearch.client.RestClient;\n-import org.elasticsearch.cluster.metadata.DataStream;\n-import org.elasticsearch.common.Strings;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.common.util.LazyInitializable;\n-import org.elasticsearch.common.xcontent.XContentHelper;\n-import org.elasticsearch.common.xcontent.support.XContentMapValues;\n-import org.elasticsearch.rest.RestStatus;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n-import org.elasticsearch.xcontent.ToXContent;\n-import org.elasticsearch.xcontent.XContentBuilder;\n-import org.elasticsearch.xcontent.json.JsonXContent;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import static org.elasticsearch.rest.action.search.RestSearchAction.TOTAL_HITS_AS_INT_PARAM;\n-import static org.elasticsearch.xcontent.XContentFactory.jsonBuilder;\n-import static org.hamcrest.Matchers.endsWith;\n-import static org.hamcrest.Matchers.equalTo;\n-import static org.hamcrest.Matchers.greaterThan;\n-import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n-import static org.hamcrest.Matchers.hasSize;\n-\n-public abstract class ESCCRRestTestCase extends ESRestTestCase {\n-\n-    protected final String targetCluster = System.getProperty(\"tests.target_cluster\");\n-\n-    @Override\n-    protected boolean preserveClusterUponCompletion() {\n-        return true;\n-    }\n-\n-    protected static void index(String index, String id, Object... fields) throws IOException {\n-        index(adminClient(), index, id, fields);\n-    }\n-\n-    protected static void index(RestClient client, String index, String id, Object... fields) throws IOException {\n-        XContentBuilder document = jsonBuilder().startObject();\n-        for (int i = 0; i < fields.length; i += 2) {\n-            document.field((String) fields[i], fields[i + 1]);\n-        }\n-        document.endObject();\n-        final Request request = new Request(\"POST\", \"/\" + index + \"/_doc\" + (id == null ? \"\" : \"/\" + id));\n-        request.setJsonEntity(Strings.toString(document));\n-        assertOK(client.performRequest(request));\n-    }\n-\n-    protected static void resumeFollow(String followIndex) throws IOException {\n-        final Request request = new Request(\"POST\", \"/\" + followIndex + \"/_ccr/resume_follow\");\n-        request.setJsonEntity(\"{\\\"read_poll_timeout\\\": \\\"10ms\\\"}\");\n-        assertOK(client().performRequest(request));\n-    }\n-\n-    protected static void followIndex(String leaderIndex, String followIndex) throws IOException {\n-        followIndex(\"leader_cluster\", leaderIndex, followIndex);\n-    }\n-\n-    protected static void followIndex(String leaderCluster, String leaderIndex, String followIndex) throws IOException {\n-        followIndex(client(), leaderCluster, leaderIndex, followIndex);\n-    }\n-\n-    protected static void followIndex(RestClient client, String leaderCluster, String leaderIndex, String followIndex) throws IOException {\n-        followIndex(client, leaderCluster, leaderIndex, followIndex, null);\n-    }\n-\n-    protected static void followIndex(\n-        final RestClient client,\n-        final String leaderCluster,\n-        final String leaderIndex,\n-        final String followIndex,\n-        final Settings settings\n-    ) throws IOException {\n-        final Request request = new Request(\"PUT\", \"/\" + followIndex + \"/_ccr/follow?wait_for_active_shards=1\");\n-        try (XContentBuilder bodyBuilder = JsonXContent.contentBuilder()) {\n-            bodyBuilder.startObject();\n-            {\n-                bodyBuilder.field(\"remote_cluster\", leaderCluster);\n-                bodyBuilder.field(\"leader_index\", leaderIndex);\n-                bodyBuilder.field(\"read_poll_timeout\", \"10ms\");\n-                if (settings != null) {\n-                    bodyBuilder.startObject(\"settings\");\n-                    {\n-                        settings.toXContent(bodyBuilder, ToXContent.EMPTY_PARAMS);\n-                    }\n-                    bodyBuilder.endObject();\n-                }\n-            }\n-            bodyBuilder.endObject();\n-            request.setJsonEntity(Strings.toString(bodyBuilder));\n-        }\n-        assertOK(client.performRequest(request));\n-    }\n-\n-    protected static void pauseFollow(String followIndex) throws IOException {\n-        pauseFollow(client(), followIndex);\n-    }\n-\n-    protected static void pauseFollow(RestClient client, String followIndex) throws IOException {\n-        assertOK(client.performRequest(new Request(\"POST\", \"/\" + followIndex + \"/_ccr/pause_follow\")));\n-    }\n-\n-    protected static void putAutoFollowPattern(String patternName, String remoteCluster, String indexPattern) throws IOException {\n-        Request putPatternRequest = new Request(\"PUT\", \"/_ccr/auto_follow/\" + patternName);\n-        putPatternRequest.setJsonEntity(String.format(Locale.ROOT, \"\"\"\n-            {\"leader_index_patterns\": [\"%s\"], \"remote_cluster\": \"%s\"}\n-            \"\"\", indexPattern, remoteCluster));\n-        assertOK(client().performRequest(putPatternRequest));\n-    }\n-\n-    protected static void deleteAutoFollowPattern(String patternName) throws IOException {\n-        deleteAutoFollowPattern(client(), patternName);\n-    }\n-\n-    protected static void deleteAutoFollowPattern(RestClient client, String patternName) throws IOException {\n-        Request putPatternRequest = new Request(\"DELETE\", \"/_ccr/auto_follow/\" + patternName);\n-        assertOK(client.performRequest(putPatternRequest));\n-    }\n-\n-    protected static void unfollow(String followIndex) throws IOException {\n-        assertOK(client().performRequest(new Request(\"POST\", \"/\" + followIndex + \"/_ccr/unfollow\")));\n-    }\n-\n-    protected static void verifyDocuments(final String index, final int expectedNumDocs, final String query) throws IOException {\n-        verifyDocuments(index, expectedNumDocs, query, adminClient());\n-    }\n-\n-    protected static void verifyDocuments(final String index, final int expectedNumDocs, final String query, final RestClient client)\n-        throws IOException {\n-        final Request request = new Request(\"GET\", \"/\" + index + \"/_search\");\n-        request.addParameter(\"size\", Integer.toString(expectedNumDocs));\n-        request.addParameter(\"sort\", \"field:asc\");\n-        request.addParameter(\"q\", query);\n-        request.addParameter(TOTAL_HITS_AS_INT_PARAM, \"true\");\n-        Map<String, ?> response = toMap(client.performRequest(request));\n-\n-        int numDocs = (int) XContentMapValues.extractValue(\"hits.total\", response);\n-        assertThat(index, numDocs, equalTo(expectedNumDocs));\n-\n-        List<?> hits = (List<?>) XContentMapValues.extractValue(\"hits.hits\", response);\n-        assertThat(hits.size(), equalTo(expectedNumDocs));\n-        for (int i = 0; i < expectedNumDocs; i++) {\n-            int value = (int) XContentMapValues.extractValue(\"_source.field\", (Map<?, ?>) hits.get(i));\n-            assertThat(index, i, equalTo(value));\n-        }\n-    }\n-\n-    protected static void verifyDocuments(final RestClient client, final String index, final int expectedNumDocs) throws IOException {\n-        final Request request = new Request(\"GET\", \"/\" + index + \"/_search\");\n-        request.addParameter(TOTAL_HITS_AS_INT_PARAM, \"true\");\n-        Map<String, ?> response = toMap(client.performRequest(request));\n-\n-        int numDocs = (int) XContentMapValues.extractValue(\"hits.total\", response);\n-        assertThat(index, numDocs, equalTo(expectedNumDocs));\n-    }\n-\n-    protected static void verifyCcrMonitoring(final String expectedLeaderIndex, final String expectedFollowerIndex) throws IOException {\n-        Request request = new Request(\"GET\", \"/.monitoring-*/_search\");\n-        request.setJsonEntity(String.format(Locale.ROOT, \"\"\"\n-            {\"query\": {\"term\": {\"ccr_stats.leader_index\": \"%s\"}}}\n-            \"\"\", expectedLeaderIndex));\n-        Map<String, ?> response;\n-        try {\n-            response = toMap(adminClient().performRequest(request));\n-        } catch (ResponseException e) {\n-            throw new AssertionError(\"error while searching\", e);\n-        }\n-\n-        int followerMaxSeqNo = 0;\n-        int followerMappingVersion = 0;\n-        int followerSettingsVersion = 0;\n-        int followerAliasesVersion = 0;\n-\n-        List<?> hits = (List<?>) XContentMapValues.extractValue(\"hits.hits\", response);\n-        assertThat(hits.size(), greaterThanOrEqualTo(1));\n-\n-        for (int i = 0; i < hits.size(); i++) {\n-            Map<?, ?> hit = (Map<?, ?>) hits.get(i);\n-            String leaderIndex = (String) XContentMapValues.extractValue(\"_source.ccr_stats.leader_index\", hit);\n-            assertThat(leaderIndex, endsWith(expectedLeaderIndex));\n-\n-            final String followerIndex = (String) XContentMapValues.extractValue(\"_source.ccr_stats.follower_index\", hit);\n-            assertThat(followerIndex, equalTo(expectedFollowerIndex));\n-\n-            int foundFollowerMaxSeqNo = (int) XContentMapValues.extractValue(\"_source.ccr_stats.follower_max_seq_no\", hit);\n-            followerMaxSeqNo = Math.max(followerMaxSeqNo, foundFollowerMaxSeqNo);\n-            int foundFollowerMappingVersion = (int) XContentMapValues.extractValue(\"_source.ccr_stats.follower_mapping_version\", hit);\n-            followerMappingVersion = Math.max(followerMappingVersion, foundFollowerMappingVersion);\n-            int foundFollowerSettingsVersion = (int) XContentMapValues.extractValue(\"_source.ccr_stats.follower_settings_version\", hit);\n-            followerSettingsVersion = Math.max(followerSettingsVersion, foundFollowerSettingsVersion);\n-            int foundFollowerAliasesVersion = (int) XContentMapValues.extractValue(\"_source.ccr_stats.follower_aliases_version\", hit);\n-            followerAliasesVersion = Math.max(followerAliasesVersion, foundFollowerAliasesVersion);\n-        }\n-\n-        assertThat(followerMaxSeqNo, greaterThan(0));\n-        assertThat(followerMappingVersion, greaterThan(0));\n-        assertThat(followerSettingsVersion, greaterThan(0));\n-        assertThat(followerAliasesVersion, greaterThan(0));\n-    }\n-\n-    protected static void verifyAutoFollowMonitoring() throws IOException {\n-        Request request = new Request(\"GET\", \"/.monitoring-*/_count\");\n-        request.setJsonEntity(\"\"\"\n-                {\n-                  \"query\": {\n-                    \"bool\" : {\n-                      \"filter\": {\n-                        \"term\" : { \"type\" : \"ccr_auto_follow_stats\" }\n-                      },\n-                      \"must\" : {\n-                        \"range\" : {\n-                          \"ccr_auto_follow_stats.number_of_successful_follow_indices\" : { \"gt\" : 0 }\n-                        }\n-                      }\n-                    }\n-                  }\n-                }\n-            \"\"\");\n-        String responseEntity;\n-        Map<String, ?> response;\n-        try {\n-            responseEntity = EntityUtils.toString(adminClient().performRequest(request).getEntity());\n-            response = toMap(responseEntity);\n-        } catch (ResponseException e) {\n-            throw new AssertionError(\"error while searching\", e);\n-        }\n-        assertNotNull(responseEntity);\n-\n-        final Number count = (Number) XContentMapValues.extractValue(\"count\", response);\n-        assertThat(\n-            \"Expected at least 1 successfully followed index but found none, count returned [\" + responseEntity + ']',\n-            count.longValue(),\n-            greaterThanOrEqualTo(1L)\n-        );\n-    }\n-\n-    protected static Map<String, Object> toMap(Response response) throws IOException {\n-        return toMap(EntityUtils.toString(response.getEntity()));\n-    }\n-\n-    protected static Map<String, Object> toMap(String response) {\n-        return XContentHelper.convertToMap(JsonXContent.jsonXContent, response, false);\n-    }\n-\n-    protected static void ensureYellow(final String index) throws IOException {\n-        ensureYellow(index, adminClient());\n-    }\n-\n-    protected static void ensureYellow(final String index, final RestClient client) throws IOException {\n-        ensureHealth(client, index, request -> {\n-            request.addParameter(\"wait_for_status\", \"yellow\");\n-            request.addParameter(\"wait_for_active_shards\", \"1\");\n-            request.addParameter(\"wait_for_no_relocating_shards\", \"true\");\n-            // follower index can be yellow even when its primary shards are still initializing as we bootstrap them using snapshot/restore.\n-            request.addParameter(\"wait_for_no_initializing_shards\", \"true\");\n-            request.addParameter(\"timeout\", \"5s\");\n-            request.addParameter(\"level\", \"shards\");\n-        });\n-    }\n-\n-    protected Set<CcrNodeTask> getCcrNodeTasks() throws IOException {\n-        final Request request = new Request(\"GET\", \"/_tasks\");\n-        request.addParameter(\"detailed\", \"true\");\n-        Map<String, Object> rsp1 = toMap(adminClient().performRequest(request));\n-        Map<?, ?> nodes = (Map<?, ?>) rsp1.get(\"nodes\");\n-        assertThat(nodes.size(), equalTo(1));\n-        Map<?, ?> node = (Map<?, ?>) nodes.values().iterator().next();\n-        Map<?, ?> nodeTasks = (Map<?, ?>) node.get(\"tasks\");\n-        var ccrNodeTasks = new HashSet<CcrNodeTask>();\n-        for (Map.Entry<?, ?> entry : nodeTasks.entrySet()) {\n-            Map<?, ?> nodeTask = (Map<?, ?>) entry.getValue();\n-            String action = (String) nodeTask.get(\"action\");\n-            if (action.startsWith(\"xpack/ccr/shard_follow_task\")) {\n-                var status = (Map<?, ?>) nodeTask.get(\"status\");\n-                ccrNodeTasks.add(\n-                    new CcrNodeTask(\n-                        (String) status.get(\"remote_cluster\"),\n-                        (String) status.get(\"leader_index\"),\n-                        (String) status.get(\"follower_index\"),\n-                        (Integer) status.get(\"shard_id\")\n-                    )\n-                );\n-            }\n-        }\n-        return ccrNodeTasks;\n-    }\n-\n-    protected record CcrNodeTask(String remoteCluster, String leaderIndex, String followerIndex, int shardId) {}\n-\n-    protected static boolean indexExists(String index) throws IOException {\n-        Response response = adminClient().performRequest(new Request(\"HEAD\", \"/\" + index));\n-        return RestStatus.OK.getStatus() == response.getStatusLine().getStatusCode();\n-    }\n-\n-    protected static List<String> verifyDataStream(final RestClient client, final String name, final String... expectedBackingIndices)\n-        throws IOException {\n-        Request request = new Request(\"GET\", \"/_data_stream/\" + name);\n-        Map<String, ?> response = toMap(client.performRequest(request));\n-        List<?> retrievedDataStreams = (List<?>) response.get(\"data_streams\");\n-        assertThat(retrievedDataStreams, hasSize(1));\n-        List<?> actualBackingIndexItems = (List<?>) ((Map<?, ?>) retrievedDataStreams.get(0)).get(\"indices\");\n-        assertThat(actualBackingIndexItems, hasSize(expectedBackingIndices.length));\n-        final List<String> actualBackingIndices = new ArrayList<>();\n-        for (int i = 0; i < expectedBackingIndices.length; i++) {\n-            Map<?, ?> actualBackingIndexItem = (Map<?, ?>) actualBackingIndexItems.get(i);\n-            String actualBackingIndex = (String) actualBackingIndexItem.get(\"index_name\");\n-            String expectedBackingIndex = expectedBackingIndices[i];\n-\n-            String actualDataStreamName = actualBackingIndex.substring(5, actualBackingIndex.indexOf('-', 5));\n-            String expectedDataStreamName = expectedBackingIndex.substring(5, expectedBackingIndex.indexOf('-', 5));\n-            assertThat(actualDataStreamName, equalTo(expectedDataStreamName));\n-\n-            int actualGeneration = Integer.parseInt(actualBackingIndex.substring(actualBackingIndex.lastIndexOf('-')));\n-            int expectedGeneration = Integer.parseInt(expectedBackingIndex.substring(expectedBackingIndex.lastIndexOf('-')));\n-            assertThat(actualGeneration, equalTo(expectedGeneration));\n-            actualBackingIndices.add(actualBackingIndex);\n-        }\n-        return List.copyOf(actualBackingIndices);\n-    }\n-\n-    protected static void createAutoFollowPattern(\n-        RestClient client,\n-        String name,\n-        String pattern,\n-        String remoteCluster,\n-        String followIndexPattern\n-    ) throws IOException {\n-        Request request = new Request(\"PUT\", \"/_ccr/auto_follow/\" + name);\n-        try (XContentBuilder bodyBuilder = JsonXContent.contentBuilder()) {\n-            bodyBuilder.startObject();\n-            {\n-                bodyBuilder.array(\"leader_index_patterns\", pattern);\n-                if (followIndexPattern != null) {\n-                    bodyBuilder.field(\"follow_index_pattern\", followIndexPattern);\n-                }\n-                bodyBuilder.field(\"remote_cluster\", remoteCluster);\n-            }\n-            bodyBuilder.endObject();\n-            request.setJsonEntity(Strings.toString(bodyBuilder));\n-        }\n-        assertOK(client.performRequest(request));\n-    }\n-\n-    /**\n-     * Fix point in time when data stream backing index is first time queried.\n-     * This is required to avoid failures when running test at midnight.\n-     * (index is created for day0, but assertions are executed for day1 assuming different time based index name that does not exist)\n-     */\n-    private final LazyInitializable<Long, RuntimeException> time = new LazyInitializable<>(System::currentTimeMillis);\n-\n-    protected String backingIndexName(String dataStreamName, int generation) {\n-        return DataStream.getDefaultBackingIndexName(dataStreamName, generation, time.getOrCompute());\n-    }\n-\n-    protected RestClient buildLeaderClient() throws IOException {\n-        assert \"leader\".equals(targetCluster) == false;\n-        return buildClient(System.getProperty(\"tests.leader_host\"));\n-    }\n-\n-    protected RestClient buildLeaderClient(final Settings settings) throws IOException {\n-        assert \"leader\".equals(targetCluster) == false;\n-        return buildClient(System.getProperty(\"tests.leader_host\"), settings);\n-    }\n-\n-    protected RestClient buildMiddleClient() throws IOException {\n-        assert \"middle\".equals(targetCluster) == false;\n-        return buildClient(System.getProperty(\"tests.middle_host\"));\n-    }\n-\n-    private RestClient buildClient(final String url) throws IOException {\n-        return buildClient(url, restAdminSettings());\n-    }\n-\n-    private RestClient buildClient(final String url, final Settings settings) throws IOException {\n-        int portSeparator = url.lastIndexOf(':');\n-        HttpHost httpHost = new HttpHost(\n-            url.substring(0, portSeparator),\n-            Integer.parseInt(url.substring(portSeparator + 1)),\n-            getProtocol()\n-        );\n-        return buildClient(settings, new HttpHost[] { httpHost });\n-    }\n-\n-}\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/build.gradle b/x-pack/plugin/ilm/qa/multi-node/build.gradle\nindex d420ac9effdde..714d1b20ef331 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/build.gradle\n+++ b/x-pack/plugin/ilm/qa/multi-node/build.gradle\n@@ -1,46 +1,25 @@\n-import org.elasticsearch.gradle.internal.info.BuildParams\n-import static org.elasticsearch.gradle.PropertyNormalization.IGNORE_VALUE\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License\n+ * 2.0; you may not use this file except in compliance with the Elastic License\n+ * 2.0.\n+ */\n \n-apply plugin: 'elasticsearch.legacy-java-rest-test'\n+apply plugin: 'elasticsearch.internal-java-rest-test'\n \n dependencies {\n   javaRestTestImplementation(testArtifact(project(xpackModule('core'))))\n   javaRestTestImplementation project(xpackModule('ilm'))\n-}\n-\n-File repoDir = file(\"$buildDir/testclusters/repo\")\n-\n-tasks.named(\"javaRestTest\").configure {\n-  /* To support taking index snapshots, we have to set path.repo setting */\n-  nonInputProperties.systemProperty 'tests.path.repo', repoDir\n-}\n-\n-testClusters.configureEach {\n-  testDistribution = 'DEFAULT'\n-  numberOfNodes = 4\n \n-  setting 'path.repo', repoDir.absolutePath, IGNORE_VALUE\n-  setting 'xpack.searchable.snapshot.shared_cache.size', '16MB'\n-  setting 'xpack.searchable.snapshot.shared_cache.region_size', '256KB'\n-  setting 'xpack.security.enabled', 'false'\n-  setting 'xpack.watcher.enabled', 'false'\n-  setting 'xpack.ml.enabled', 'false'\n-  setting 'xpack.license.self_generated.type', 'trial'\n-  setting 'indices.lifecycle.poll_interval', '1000ms'\n-  setting 'logger.org.elasticsearch.xpack.core.ilm', 'TRACE'\n-  setting 'logger.org.elasticsearch.xpack.ilm', 'TRACE'\n-  /*\n-   * In TimeSeriesLifecycleActionsIT.testWaitForSnapshotSlmExecutedBefore() we create a snapshot, then associate an ILM policy with an index, and\n-   * then that policy checks if a snapshot has been started at the same millisecond or later than the policy's action's date. Since both the\n-   * snapshot start time and policy are using ThreadPool.absoluteTimeInMillis(), it is possible that they get the same cached result back (it is\n-   * kept for about 200 ms). The following config changes ThreadPool.absoluteTimeInMillis() to always use System.currentTimeMillis() rather than a\n-   * cached time. So the policy's action date is always after the snapshot's start.\n-   */\n-  setting 'thread_pool.estimated_time_interval', '0'\n-  setting 'time_series.poll_interval', '10m'\n+  clusterModules project(xpackModule('ilm'))\n+  clusterModules project(xpackModule('slm'))\n+  clusterModules project(xpackModule('ccr'))\n+  clusterModules project(xpackModule('downsample'))\n+  clusterModules project(xpackModule('searchable-snapshots'))\n+  clusterModules project(':modules:data-streams')\n }\n \n-if (buildParams.inFipsJvm){\n+if (buildParams.inFipsJvm) {\n   // Test clusters run with security disabled\n-  tasks.named(\"javaRestTest\").configure{enabled = false }\n+  tasks.named(\"javaRestTest\").configure { enabled = false }\n }\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/IlmESRestTestCase.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/IlmESRestTestCase.java\nnew file mode 100644\nindex 0000000000000..6f8989ab65c44\n--- /dev/null\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/IlmESRestTestCase.java\n@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License\n+ * 2.0; you may not use this file except in compliance with the Elastic License\n+ * 2.0.\n+ */\n+\n+package org.elasticsearch.xpack;\n+\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.test.cluster.ElasticsearchCluster;\n+import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.junit.ClassRule;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+public abstract class IlmESRestTestCase extends ESRestTestCase {\n+    static final String USER = \"user\";\n+    static final String PASSWORD = \"x-pack-test-password\";\n+\n+    public static TemporaryFolder repoDir = new TemporaryFolder();\n+\n+    public static ElasticsearchCluster cluster = ElasticsearchCluster.local()\n+        .module(\"x-pack-ilm\")\n+        .module(\"x-pack-slm\")\n+        .module(\"x-pack-ccr\")\n+        .module(\"x-pack-downsample\")\n+        .module(\"searchable-snapshots\")\n+        .module(\"data-streams\")\n+        .nodes(4)\n+        .setting(\"path.repo\", () -> repoDir.getRoot().getAbsolutePath())\n+        .setting(\"xpack.searchable.snapshot.shared_cache.size\", \"16MB\")\n+        .setting(\"xpack.searchable.snapshot.shared_cache.region_size\", \"256KB\")\n+        .setting(\"xpack.security.enabled\", \"false\")\n+        .setting(\"xpack.license.self_generated.type\", \"trial\")\n+        .setting(\"indices.lifecycle.poll_interval\", \"1000ms\")\n+        .setting(\"logger.org.elasticsearch.xpack.core.ilm\", \"TRACE\")\n+        .setting(\"logger.org.elasticsearch.xpack.ilm\", \"TRACE\")\n+        // The TRACE logs of the history store are too verbose and not useful, so we set it to INFO\n+        .setting(\"logger.org.elasticsearch.xpack.ilm.history.ILMHistoryStore\", \"INFO\")\n+        /*\n+         * In TimeSeriesLifecycleActionsIT.testWaitForSnapshotSlmExecutedBefore() we create a snapshot, then associate an ILM policy with\n+         * an index, and then that policy checks if a snapshot has been started at the same millisecond or later than the policy's action's\n+         * date. Since both the snapshot start time and policy are using ThreadPool.absoluteTimeInMillis(), it is possible that they get\n+         * the same cached result back (it is kept for about 200 ms). The following config changes ThreadPool.absoluteTimeInMillis() to\n+         * always use System.currentTimeMillis() rather than a cached time. So the policy's action date is always after the snapshot's\n+         * start.\n+         */\n+        .setting(\"thread_pool.estimated_time_interval\", \"0\")\n+        .setting(\"time_series.poll_interval\", \"10m\")\n+        // Disable shard balancing to avoid force merges failing due to relocating shards.\n+        .setting(\"cluster.routing.rebalance.enable\", \"none\")\n+        .user(USER, PASSWORD)\n+        .build();\n+\n+    @ClassRule\n+    public static RuleChain ruleChain = RuleChain.outerRule(repoDir).around(cluster);\n+\n+    protected String getTestRestCluster() {\n+        return cluster.getHttpAddresses();\n+    }\n+\n+    @Override\n+    protected Settings restClientSettings() {\n+        String token = basicAuthHeaderValue(USER, new SecureString(PASSWORD.toCharArray()));\n+        return Settings.builder().put(super.restClientSettings()).put(ThreadContext.PREFIX + \".Authorization\", token).build();\n+    }\n+}\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/MigrateToDataTiersIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/MigrateToDataTiersIT.java\nindex 811d07a436677..79e2d5441c466 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/MigrateToDataTiersIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/MigrateToDataTiersIT.java\n@@ -23,7 +23,6 @@\n import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;\n import org.elasticsearch.test.XContentTestUtils;\n import org.elasticsearch.test.XContentTestUtils.JsonMapView;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xpack.cluster.action.MigrateToDataTiersResponse;\n import org.elasticsearch.xpack.core.ilm.AllocateAction;\n import org.elasticsearch.xpack.core.ilm.AllocationRoutedStep;\n@@ -61,7 +60,7 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class MigrateToDataTiersIT extends ESRestTestCase {\n+public class MigrateToDataTiersIT extends IlmESRestTestCase {\n     private String index;\n     private String policy;\n     private String alias;\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java\nindex 11edfff9ee108..24b805833aa08 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/TimeSeriesRestDriver.java\n@@ -197,26 +197,14 @@ public static void createFullPolicy(RestClient client, String policyName, TimeVa\n         warmActions.put(ForceMergeAction.NAME, new ForceMergeAction(1, null));\n         warmActions.put(\n             AllocateAction.NAME,\n-            new AllocateAction(\n-                1,\n-                null,\n-                Map.of(\"_name\", \"javaRestTest-0,javaRestTest-1,\" + \"javaRestTest-2,\" + \"javaRestTest-3\"),\n-                null,\n-                null\n-            )\n+            new AllocateAction(1, null, Map.of(\"_name\", \"test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3\"), null, null)\n         );\n         warmActions.put(ShrinkAction.NAME, new ShrinkAction(1, null, false));\n         Map<String, LifecycleAction> coldActions = new HashMap<>();\n         coldActions.put(SetPriorityAction.NAME, new SetPriorityAction(0));\n         coldActions.put(\n             AllocateAction.NAME,\n-            new AllocateAction(\n-                0,\n-                null,\n-                Map.of(\"_name\", \"javaRestTest-0,javaRestTest-1,\" + \"javaRestTest-2,\" + \"javaRestTest-3\"),\n-                null,\n-                null\n-            )\n+            new AllocateAction(0, null, Map.of(\"_name\", \"test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3\"), null, null)\n         );\n         Map<String, Phase> phases = new HashMap<>();\n         phases.put(\"hot\", new Phase(\"hot\", hotTime, hotActions));\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ChangePolicyForIndexIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ChangePolicyForIndexIT.java\nindex 370e00785e843..e16ec7d72f8e5 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ChangePolicyForIndexIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ChangePolicyForIndexIT.java\n@@ -15,8 +15,8 @@\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.core.TimeValue;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.AllocateAction;\n import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n@@ -37,7 +37,7 @@\n import static org.elasticsearch.xpack.TimeSeriesRestDriver.createNewSingletonPolicy;\n import static org.elasticsearch.xpack.TimeSeriesRestDriver.indexDocument;\n \n-public class ChangePolicyForIndexIT extends ESRestTestCase {\n+public class ChangePolicyForIndexIT extends IlmESRestTestCase {\n \n     /**\n      * This test aims to prove that an index will finish the current phase on an\n@@ -94,7 +94,7 @@ public void testChangePolicyForIndex() throws Exception {\n                 TimeValue.ZERO,\n                 Map.of(\n                     AllocateAction.NAME,\n-                    new AllocateAction(1, null, Map.of(\"_name\", \"javaRestTest-0,javaRestTest-1,javaRestTest-2,javaRestTest-3\"), null, null)\n+                    new AllocateAction(1, null, Map.of(\"_name\", \"test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3\"), null, null)\n                 )\n             )\n         );\n@@ -117,7 +117,7 @@ public void testChangePolicyForIndex() throws Exception {\n         Settings settings = Settings.builder()\n             .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4)\n             .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n-            .put(\"index.routing.allocation.include._name\", \"javaRestTest-0\")\n+            .put(\"index.routing.allocation.include._name\", \"test-cluster-0\")\n             .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, \"alias\")\n             .put(LifecycleSettings.LIFECYCLE_NAME, \"policy_1\")\n             .build();\n@@ -161,10 +161,10 @@ public void testChangePolicyForIndex() throws Exception {\n         // Check the index goes to the warm phase and completes\n         assertBusy(() -> assertStep(indexName, PhaseCompleteStep.finalStep(\"warm\").getKey()), 30, TimeUnit.SECONDS);\n \n-        // Check index is allocated on javaRestTest-1 and javaRestTest-2 as per policy_2\n+        // Check index is allocated on test-cluster-1 and test-cluster-2 as per policy_2\n         Map<String, Object> indexSettings = getIndexSettingsAsMap(indexName);\n         String includesAllocation = (String) indexSettings.get(\"index.routing.allocation.include._name\");\n-        assertEquals(\"javaRestTest-0,javaRestTest-1,javaRestTest-2,javaRestTest-3\", includesAllocation);\n+        assertEquals(\"test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3\", includesAllocation);\n     }\n \n     public void testILMHonoursTheCachedPhaseAfterPolicyUpdate() throws Exception {\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ExplainLifecycleIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ExplainLifecycleIT.java\nindex 9b7262e8f9b32..95a78ec0193e4 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ExplainLifecycleIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/ExplainLifecycleIT.java\n@@ -18,8 +18,8 @@\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.core.TimeValue;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.DeleteAction;\n import org.elasticsearch.xpack.core.ilm.ErrorStep;\n import org.elasticsearch.xpack.core.ilm.LifecycleAction;\n@@ -52,7 +52,7 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class ExplainLifecycleIT extends ESRestTestCase {\n+public class ExplainLifecycleIT extends IlmESRestTestCase {\n     private static final Logger logger = LogManager.getLogger(ExplainLifecycleIT.class);\n     private static final String FAILED_STEP_RETRY_COUNT_FIELD = \"failed_step_retry_count\";\n     private static final String IS_AUTO_RETRYABLE_ERROR_FIELD = \"is_auto_retryable_error\";\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/LifecycleLicenseIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/LifecycleLicenseIT.java\nindex fe00f060d5ade..fcc494e00fe4e 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/LifecycleLicenseIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/LifecycleLicenseIT.java\n@@ -17,10 +17,10 @@\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.license.License;\n import org.elasticsearch.license.TestUtils;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.ToXContent;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.ErrorStep;\n import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n import org.elasticsearch.xpack.core.ilm.PhaseCompleteStep;\n@@ -45,7 +45,7 @@\n import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n import static org.hamcrest.Matchers.is;\n \n-public class LifecycleLicenseIT extends ESRestTestCase {\n+public class LifecycleLicenseIT extends IlmESRestTestCase {\n \n     private String policy;\n     private String dataStream;\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesDataStreamsIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesDataStreamsIT.java\nindex 0762df16722a6..1ce4a92632d36 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesDataStreamsIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesDataStreamsIT.java\n@@ -14,8 +14,8 @@\n import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.index.engine.EngineConfig;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentType;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.CheckNotDataStreamWriteIndexStep;\n import org.elasticsearch.xpack.core.ilm.DeleteAction;\n import org.elasticsearch.xpack.core.ilm.DeleteStep;\n@@ -52,7 +52,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.oneOf;\n \n-public class TimeSeriesDataStreamsIT extends ESRestTestCase {\n+public class TimeSeriesDataStreamsIT extends IlmESRestTestCase {\n \n     private String policyName;\n     private String dataStream;\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java\nindex dddb07fae42c5..d69817c8640fb 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeSeriesLifecycleActionsIT.java\n@@ -25,10 +25,10 @@\n import org.elasticsearch.index.engine.EngineConfig;\n import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;\n import org.elasticsearch.snapshots.SnapshotState;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.XContentType;\n import org.elasticsearch.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.AllocateAction;\n import org.elasticsearch.xpack.core.ilm.DeleteAction;\n import org.elasticsearch.xpack.core.ilm.ErrorStep;\n@@ -79,7 +79,7 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class TimeSeriesLifecycleActionsIT extends ESRestTestCase {\n+public class TimeSeriesLifecycleActionsIT extends IlmESRestTestCase {\n     private static final Logger logger = LogManager.getLogger(TimeSeriesLifecycleActionsIT.class);\n     private static final String FAILED_STEP_RETRY_COUNT_FIELD = \"failed_step_retry_count\";\n \n@@ -105,7 +105,7 @@ public void testFullPolicy() throws Exception {\n             Settings.builder()\n                 .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 2)\n                 .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n-                .put(\"index.routing.allocation.include._name\", \"javaRestTest-0\")\n+                .put(\"index.routing.allocation.include._name\", \"test-cluster-0\")\n                 .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, alias)\n         );\n \n@@ -216,7 +216,7 @@ public void testAllocateOnlyAllocation() throws Exception {\n             alias,\n             Settings.builder().put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 2).put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n         );\n-        String allocateNodeName = \"javaRestTest-0,javaRestTest-1,javaRestTest-2,javaRestTest-3\";\n+        String allocateNodeName = \"test-cluster-0,test-cluster-1,test-cluster-2,test-cluster-3\";\n         AllocateAction allocateAction = new AllocateAction(null, null, Map.of(\"_name\", allocateNodeName), null, null);\n         String endPhase = randomFrom(\"warm\", \"cold\");\n         createNewSingletonPolicy(client(), policy, endPhase, allocateAction);\n@@ -441,7 +441,7 @@ public void testDeleteDuringSnapshot() throws Exception {\n                     .field(\"type\", \"fs\")\n                     .startObject(\"settings\")\n                     .field(\"compress\", randomBoolean())\n-                    .field(\"location\", System.getProperty(\"tests.path.repo\"))\n+                    .field(\"location\", repoDir.getRoot().getAbsolutePath())\n                     .field(\"max_snapshot_bytes_per_sec\", \"256b\")\n                     .endObject()\n                     .endObject()\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeseriesMoveToStepIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeseriesMoveToStepIT.java\nindex 5a61af793d907..1951f520f98c8 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeseriesMoveToStepIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/TimeseriesMoveToStepIT.java\n@@ -15,7 +15,7 @@\n import org.elasticsearch.cluster.metadata.IndexMetadata;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.core.TimeValue;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.DeleteAction;\n import org.elasticsearch.xpack.core.ilm.ForceMergeAction;\n import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n@@ -39,7 +39,7 @@\n import static org.hamcrest.Matchers.containsStringIgnoringCase;\n import static org.hamcrest.Matchers.equalTo;\n \n-public class TimeseriesMoveToStepIT extends ESRestTestCase {\n+public class TimeseriesMoveToStepIT extends IlmESRestTestCase {\n     private static final Logger logger = LogManager.getLogger(TimeseriesMoveToStepIT.class);\n \n     private String policy;\n@@ -64,7 +64,7 @@ public void testMoveToAllocateStep() throws Exception {\n             Settings.builder()\n                 .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4)\n                 .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n-                .put(\"index.routing.allocation.include._name\", \"javaRestTest-0\")\n+                .put(\"index.routing.allocation.include._name\", \"test-cluster-0\")\n                 .put(LifecycleSettings.LIFECYCLE_NAME, policy)\n                 .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, \"alias\")\n         );\n@@ -102,7 +102,7 @@ public void testMoveToRolloverStep() throws Exception {\n             Settings.builder()\n                 .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 4)\n                 .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n-                .put(\"index.routing.allocation.include._name\", \"javaRestTest-0\")\n+                .put(\"index.routing.allocation.include._name\", \"test-cluster-0\")\n                 .put(LifecycleSettings.LIFECYCLE_NAME, policy)\n                 .put(RolloverAction.LIFECYCLE_ROLLOVER_ALIAS, alias)\n         );\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/DownsampleActionIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/DownsampleActionIT.java\nindex 17a1ad7ed9040..c83925ae4fcd6 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/DownsampleActionIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/DownsampleActionIT.java\n@@ -23,9 +23,9 @@\n import org.elasticsearch.index.IndexSettings;\n import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;\n import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramInterval;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.XContentFactory;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.CheckNotDataStreamWriteIndexStep;\n import org.elasticsearch.xpack.core.ilm.DownsampleAction;\n import org.elasticsearch.xpack.core.ilm.LifecycleAction;\n@@ -57,7 +57,7 @@\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.notNullValue;\n \n-public class DownsampleActionIT extends ESRestTestCase {\n+public class DownsampleActionIT extends IlmESRestTestCase {\n \n     private String index;\n     private String policy;\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ReadonlyActionIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ReadonlyActionIT.java\nindex ec0b685dd5bd0..6c38b54aa3b12 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ReadonlyActionIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ReadonlyActionIT.java\n@@ -12,7 +12,7 @@\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.core.TimeValue;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.LifecycleAction;\n import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n@@ -34,7 +34,7 @@\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class ReadonlyActionIT extends ESRestTestCase {\n+public class ReadonlyActionIT extends IlmESRestTestCase {\n     private static final String FAILED_STEP_RETRY_COUNT_FIELD = \"failed_step_retry_count\";\n \n     private String policy;\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/RolloverActionIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/RolloverActionIT.java\nindex b12df4b43faaf..6ab8692540563 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/RolloverActionIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/RolloverActionIT.java\n@@ -17,7 +17,7 @@\n import org.elasticsearch.core.Strings;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.LifecycleSettings;\n import org.elasticsearch.xpack.core.ilm.PhaseCompleteStep;\n import org.elasticsearch.xpack.core.ilm.RolloverAction;\n@@ -29,6 +29,7 @@\n import java.util.Map;\n import java.util.concurrent.TimeUnit;\n \n+import static org.elasticsearch.test.ESTestCase.randomAlphaOfLength;\n import static org.elasticsearch.xpack.TimeSeriesRestDriver.createIndexWithSettings;\n import static org.elasticsearch.xpack.TimeSeriesRestDriver.createNewSingletonPolicy;\n import static org.elasticsearch.xpack.TimeSeriesRestDriver.explainIndex;\n@@ -41,7 +42,7 @@\n import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n import static org.hamcrest.Matchers.is;\n \n-public class RolloverActionIT extends ESRestTestCase {\n+public class RolloverActionIT extends IlmESRestTestCase {\n \n     private static final String FAILED_STEP_RETRY_COUNT_FIELD = \"failed_step_retry_count\";\n \ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java\nindex 7c9e1160bc95c..26193a82c4c3e 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/SearchableSnapshotActionIT.java\n@@ -19,9 +19,9 @@\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.xcontent.XContentHelper;\n import org.elasticsearch.core.TimeValue;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.XContentType;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.AllocateAction;\n import org.elasticsearch.xpack.core.ilm.DeleteAction;\n import org.elasticsearch.xpack.core.ilm.ForceMergeAction;\n@@ -65,7 +65,7 @@\n import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n import static org.hamcrest.Matchers.is;\n \n-public class SearchableSnapshotActionIT extends ESRestTestCase {\n+public class SearchableSnapshotActionIT extends IlmESRestTestCase {\n \n     private String policy;\n     private String dataStream;\ndiff --git a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ShrinkActionIT.java b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ShrinkActionIT.java\nindex 2fecf3c617ccd..295a5db6f6497 100644\n--- a/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ShrinkActionIT.java\n+++ b/x-pack/plugin/ilm/qa/multi-node/src/javaRestTest/java/org/elasticsearch/xpack/ilm/actions/ShrinkActionIT.java\n@@ -19,9 +19,9 @@\n import org.elasticsearch.common.unit.ByteSizeValue;\n import org.elasticsearch.core.TimeValue;\n import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;\n-import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n import org.elasticsearch.xcontent.json.JsonXContent;\n+import org.elasticsearch.xpack.IlmESRestTestCase;\n import org.elasticsearch.xpack.core.ilm.CheckTargetShardsCountStep;\n import org.elasticsearch.xpack.core.ilm.LifecycleAction;\n import org.elasticsearch.xpack.core.ilm.LifecyclePolicy;\n@@ -56,7 +56,7 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n \n-public class ShrinkActionIT extends ESRestTestCase {\n+public class ShrinkActionIT extends IlmESRestTestCase {\n     private static final String FAILED_STEP_RETRY_COUNT_FIELD = \"failed_step_retry_count\";\n     private static final String SHRINK_INDEX_NAME = \"shrink_index_name\";\n \n@@ -152,7 +152,7 @@ public void testShrinkDuringSnapshot() throws Exception {\n                     .field(\"type\", \"fs\")\n                     .startObject(\"settings\")\n                     .field(\"compress\", randomBoolean())\n-                    .field(\"location\", System.getProperty(\"tests.path.repo\"))\n+                    .field(\"location\", repoDir.getRoot().getAbsolutePath())\n                     .field(\"max_snapshot_bytes_per_sec\", \"256b\")\n                     .endObject()\n                     .endObject()\n@@ -170,7 +170,7 @@ public void testShrinkDuringSnapshot() throws Exception {\n                 .put(SETTING_NUMBER_OF_SHARDS, 2)\n                 .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n                 // required so the shrink doesn't wait on SetSingleNodeAllocateStep\n-                .put(IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getKey() + \"_name\", \"javaRestTest-0\")\n+                .put(IndexMetadata.INDEX_ROUTING_REQUIRE_GROUP_SETTING.getKey() + \"_name\", \"test-cluster-0\")\n         );\n         // index document so snapshot actually does something\n         indexDocument(client(), index);\ndiff --git a/x-pack/plugin/ilm/qa/rest/build.gradle b/x-pack/plugin/ilm/qa/rest/build.gradle\nindex 11ce8254c8fd6..3a8a93e8325f9 100644\n--- a/x-pack/plugin/ilm/qa/rest/build.gradle\n+++ b/x-pack/plugin/ilm/qa/rest/build.gradle\n@@ -1,9 +1,10 @@\n-apply plugin: 'elasticsearch.legacy-yaml-rest-test'\n-apply plugin: 'elasticsearch.legacy-yaml-rest-compat-test'\n-apply plugin: 'elasticsearch.authenticated-testclusters'\n+\n+apply plugin: 'elasticsearch.internal-yaml-rest-test'\n \n dependencies {\n-  yamlRestTestImplementation(testArtifact(project(xpackModule('core'))))\n+  yamlRestTestImplementation project(':x-pack:qa')\n+\n+  clusterModules project(xpackModule('ilm'))\n }\n \n restResources {\n@@ -12,9 +13,14 @@ restResources {\n   }\n }\n \n-testClusters.configureEach {\n-  testDistribution = 'DEFAULT'\n-  setting 'xpack.ml.enabled', 'false'\n-  setting 'xpack.license.self_generated.type', 'trial'\n-  setting 'xpack.security.autoconfiguration.enabled', 'false'\n+configurations {\n+  basicRestSpecs {\n+    attributes {\n+      attribute(ArtifactTypeDefinition.ARTIFACT_TYPE_ATTRIBUTE, ArtifactTypeDefinition.DIRECTORY_TYPE)\n+    }\n+  }\n+}\n+\n+artifacts {\n+  basicRestSpecs(new File(projectDir, \"src/yamlRestTest/resources/rest-api-spec/test\"))\n }\ndiff --git a/x-pack/plugin/ilm/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/ilm/IndexLifecycleRestIT.java b/x-pack/plugin/ilm/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/ilm/IndexLifecycleRestIT.java\nindex 1e7658fe7b3e1..fa4c7f8cbc1d9 100644\n--- a/x-pack/plugin/ilm/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/ilm/IndexLifecycleRestIT.java\n+++ b/x-pack/plugin/ilm/qa/rest/src/yamlRestTest/java/org/elasticsearch/xpack/ilm/IndexLifecycleRestIT.java\n@@ -15,31 +15,41 @@\n import org.elasticsearch.common.settings.SecureString;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.test.cluster.ElasticsearchCluster;\n import org.elasticsearch.test.rest.yaml.ClientYamlTestCandidate;\n import org.elasticsearch.test.rest.yaml.ESClientYamlSuiteTestCase;\n-\n-import java.util.Objects;\n-\n-import static org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken.basicAuthHeaderValue;\n+import org.junit.ClassRule;\n \n @TimeoutSuite(millis = 30 * TimeUnits.MINUTE) // as default timeout seems not enough on the jenkins VMs\n public class IndexLifecycleRestIT extends ESClientYamlSuiteTestCase {\n \n-    private static final String USER = Objects.requireNonNull(System.getProperty(\"tests.rest.cluster.username\"));\n-    private static final String PASS = Objects.requireNonNull(System.getProperty(\"tests.rest.cluster.password\"));\n+    static final String USER = \"user\";\n+    static final String PASSWORD = \"x-pack-test-password\";\n \n-    public IndexLifecycleRestIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n-        super(testCandidate);\n-    }\n+    @ClassRule\n+    public static ElasticsearchCluster cluster = ElasticsearchCluster.local()\n+        .module(\"x-pack-ilm\")\n+        .setting(\"xpack.license.self_generated.type\", \"trial\")\n+        .setting(\"xpack.security.autoconfiguration.enabled\", \"false\")\n+        .user(USER, PASSWORD)\n+        .build();\n \n     @ParametersFactory\n     public static Iterable<Object[]> parameters() throws Exception {\n         return createParameters();\n     }\n \n+    public IndexLifecycleRestIT(@Name(\"yaml\") ClientYamlTestCandidate testCandidate) {\n+        super(testCandidate);\n+    }\n+\n+    protected String getTestRestCluster() {\n+        return cluster.getHttpAddresses();\n+    }\n+\n     @Override\n     protected Settings restClientSettings() {\n-        String token = basicAuthHeaderValue(USER, new SecureString(PASS.toCharArray()));\n+        String token = basicAuthHeaderValue(USER, new SecureString(PASSWORD.toCharArray()));\n         return Settings.builder().put(super.restClientSettings()).put(ThreadContext.PREFIX + \".Authorization\", token).build();\n     }\n }\ndiff --git a/x-pack/plugin/ilm/qa/with-security/build.gradle b/x-pack/plugin/ilm/qa/with-security/build.gradle\nindex 94dd375c56b1b..46e4987e6b77a 100644\n--- a/x-pack/plugin/ilm/qa/with-security/build.gradle\n+++ b/x-pack/plugin/ilm/qa/with-security/build.gradle\n@@ -2,8 +2,8 @@ apply plugin: 'elasticsearch.internal-java-rest-test'\n \n dependencies {\n   javaRestTestImplementation(testArtifact(project(xpackModule('core'))))\n-}\n \n-tasks.named(\"javaRestTest\").configure {\n-  usesDefaultDistribution()\n-}\n\\ No newline at end of file\n+  clusterModules project(':modules:analysis-common')\n+  clusterModules project(xpackModule('ilm'))\n+  clusterModules project(xpackModule('ccr'))\n+}\ndiff --git a/x-pack/plugin/ilm/qa/with-security/src/javaRestTest/java/org/elasticsearch/xpack/security/PermissionsIT.java b/x-pack/plugin/ilm/qa/with-security/src/javaRestTest/java/org/elasticsearch/xpack/security/PermissionsIT.java\nindex 12dede7067b03..457842adb1571 100644\n--- a/x-pack/plugin/ilm/qa/with-security/src/javaRestTest/java/org/elasticsearch/xpack/security/PermissionsIT.java\n+++ b/x-pack/plugin/ilm/qa/with-security/src/javaRestTest/java/org/elasticsearch/xpack/security/PermissionsIT.java\n@@ -25,7 +25,6 @@\n import org.elasticsearch.rest.RestStatus;\n import org.elasticsearch.rest.action.admin.indices.RestPutIndexTemplateAction;\n import org.elasticsearch.test.cluster.ElasticsearchCluster;\n-import org.elasticsearch.test.cluster.local.distribution.DistributionType;\n import org.elasticsearch.test.cluster.util.resource.Resource;\n import org.elasticsearch.test.rest.ESRestTestCase;\n import org.elasticsearch.xcontent.XContentBuilder;\n@@ -53,9 +52,9 @@ public class PermissionsIT extends ESRestTestCase {\n \n     @ClassRule\n     public static ElasticsearchCluster cluster = ElasticsearchCluster.local()\n-        .distribution(DistributionType.DEFAULT)\n-        .setting(\"xpack.watcher.enabled\", \"false\")\n-        .setting(\"xpack.ml.enabled\", \"false\")\n+        .module(\"x-pack-ilm\")\n+        .module(\"x-pack-ccr\")\n+        .module(\"analysis-common\")\n         .setting(\"xpack.license.self_generated.type\", \"trial\")\n         .rolesFile(Resource.fromClasspath(\"roles.yml\"))\n         .setting(\"xpack.security.enabled\", \"true\")\n",
  "additions": 262,
  "deletions": 602,
  "changed_files": 24,
  "url": "https://github.com/elastic/elasticsearch/pull/137091",
  "mined_at": "2025-10-25T13:25:43.527777"
}