{
  "id": 137096,
  "repository": "elastic/elasticsearch",
  "title": "Fix mapping conflicts in clone/split/shrink APIs",
  "body": "If an index is in either `logsdb` or `time_series` mode and specifies a non-default `@timestamp` type mapping (e.g. `date_nanos`), using the clone, split, or shrink API will result in shards that are unable to initialize/recover due to the following mapping conflict:\r\n```\r\nCaused by: java.lang.IllegalArgumentException: mapper [@timestamp] cannot be changed from type [date] to [date_nanos]\r\n\tat org.elasticsearch.index.mapper.FieldMapper.checkIncomingMergeType(FieldMapper.java:419)\r\n\tat org.elasticsearch.index.mapper.FieldMapper.merge(FieldMapper.java:399)\r\n\tat org.elasticsearch.index.mapper.FieldMapper.merge(FieldMapper.java:63)\r\n\tat org.elasticsearch.index.mapper.ObjectMapper$MergeResult.buildMergedMappers(ObjectMapper.java:738)\r\n\tat org.elasticsearch.index.mapper.ObjectMapper$MergeResult.build(ObjectMapper.java:664)\r\n\tat org.elasticsearch.index.mapper.RootObjectMapper.merge(RootObjectMapper.java:249)\r\n\tat org.elasticsearch.index.mapper.Mapping.merge(Mapping.java:173)\r\n\tat org.elasticsearch.index.mapper.MapperService.mergeMappings(MapperService.java:684)\r\n\tat org.elasticsearch.index.mapper.MapperService.mergeMappings(MapperService.java:651)\r\n\tat org.elasticsearch.index.mapper.MapperService.doMerge(MapperService.java:599)\r\n\tat org.elasticsearch.index.mapper.MapperService.merge(MapperService.java:584)\r\n\tat org.elasticsearch.index.mapper.MapperService.merge(MapperService.java:436)\r\n\tat org.elasticsearch.index.shard.StoreRecovery.lambda$recoverFromLocalShards$5(StoreRecovery.java:131)\r\n```\r\nAs of #133954, the `searchable_snapshot` ILM action makes use of the clone API by default - if the index has more than `0` replicas - and will thus also run into this issue.",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-24T15:47:21+00:00",
  "created_at": "2025-10-24T11:33:58+00:00",
  "updated_at": "2025-10-24T15:48:46+00:00",
  "author": "nielsbauman",
  "reviewers": [
    "nielsbauman",
    "henningandersen",
    "mattc58",
    "masseyke"
  ],
  "base_sha": "ef9199d2436e5fa2b225850afd0e918a1af1227d",
  "head_sha": "5278988ddd282c1cc4db5ca3f089627e7e34cf85",
  "review_comments": [
    {
      "user": "nielsbauman",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-24T13:08:01+00:00"
    },
    {
      "user": "masseyke",
      "state": "APPROVED",
      "body": "LGTM",
      "submitted_at": "2025-10-24T13:55:20+00:00"
    },
    {
      "user": "mattc58",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-24T13:57:41+00:00"
    },
    {
      "user": "henningandersen",
      "state": "APPROVED",
      "body": "LGTM.",
      "submitted_at": "2025-10-24T14:10:01+00:00"
    },
    {
      "user": "nielsbauman",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-24T14:42:58+00:00"
    }
  ],
  "pr_comments": [
    {
      "user": "elasticsearchmachine",
      "body": "Pinging @elastic/es-data-management (Team:Data Management)",
      "created_at": "2025-10-24T11:34:23+00:00"
    },
    {
      "user": "elasticsearchmachine",
      "body": "Hi @nielsbauman, I've created a changelog YAML for you.",
      "created_at": "2025-10-24T11:34:47+00:00"
    },
    {
      "user": "masseyke",
      "body": "Niels shared this outside of the ticket but it was very useful. The following will crash a server without this fix if assertions are enabled:\r\n```\r\nPUT my-source\r\n{\r\n    \"settings\": {\r\n        \"index.mode\": \"logsdb\",\r\n        \"index.blocks.write\": true,\r\n        \"index.number_of_replicas\": 1\r\n    },\r\n    \"mappings\": {\r\n        \"properties\": {\r\n            \"@timestamp\": {\r\n                \"type\": \"date_nanos\"\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nPOST my-source/_clone/my-target?timeout=5s\r\n```\r\n",
      "created_at": "2025-10-24T13:56:34+00:00"
    },
    {
      "user": "elasticsearchmachine",
      "body": "## ðŸ’š Backport successful\n| Status | Branch | Result |\n|:------:|:------:|:------:|\n| âœ… |  [9.2](https://github.com/elastic/elasticsearch/pull/137117)  | [<img src=\"https://img.shields.io/github/pulls/detail/state/elastic/elasticsearch/137117\">](https://github.com/elastic/elasticsearch/pull/137117) |\n| âœ… |  [8.19](https://github.com/elastic/elasticsearch/pull/137118)  | [<img src=\"https://img.shields.io/github/pulls/detail/state/elastic/elasticsearch/137118\">](https://github.com/elastic/elasticsearch/pull/137118) |",
      "created_at": "2025-10-24T15:48:46+00:00"
    }
  ],
  "files_changed": [
    {
      "filename": "docs/changelog/137096.yaml",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "patch": "@@ -0,0 +1,5 @@\n+pr: 137096\n+summary: Fix mapping conflicts in clone/split/shrink APIs\n+area: Indices APIs\n+type: bug\n+issues: []"
    },
    {
      "filename": "server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/CloneIndexIT.java",
      "status": "modified",
      "additions": 57,
      "deletions": 0,
      "changes": 57,
      "patch": "@@ -20,6 +20,7 @@\n import org.elasticsearch.index.seqno.SeqNoStats;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.index.IndexVersionUtils;\n+import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.util.List;\n@@ -203,4 +204,60 @@ public void testResizeChangeIndexSorts() {\n         });\n         assertThat(error.getMessage(), containsString(\"can't override index sort when resizing an index\"));\n     }\n+\n+    /**\n+     * Test that cloning a logsdb index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testCloneLogsdbIndexWithNonDefaultTimestamp() {\n+        // Create a logsdb index with a date_nanos @timestamp field\n+        final int numberOfReplicas = randomInt(internalCluster().numDataNodes() - 1);\n+        final var settings = indexSettings(1, numberOfReplicas).put(\"index.mode\", \"logsdb\").put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings).setMapping(\"@timestamp\", \"type=date_nanos\").get();\n+        ensureGreen();\n+\n+        // Clone the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.CLONE)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_replicas\", numberOfReplicas).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(TEST_REQUEST_TIMEOUT, \"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n+\n+    /**\n+     * Test that cloning a time series index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testCloneTimeSeriesIndexWithNonDefaultTimestamp() {\n+        // Create a time series index with a date_nanos @timestamp field\n+        final int numberOfReplicas = randomInt(internalCluster().numDataNodes() - 1);\n+        final var settings = indexSettings(1, numberOfReplicas).put(\"index.mode\", \"time_series\")\n+            .put(\"index.routing_path\", \"sensor_id\")\n+            .put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings)\n+            .setMapping(\"@timestamp\", \"type=date_nanos\", \"sensor_id\", \"type=keyword,time_series_dimension=true\")\n+            .get();\n+        ensureGreen();\n+\n+        // Clone the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.CLONE)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_replicas\", numberOfReplicas).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(TEST_REQUEST_TIMEOUT, \"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n }"
    },
    {
      "filename": "server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/ShrinkIndexIT.java",
      "status": "modified",
      "additions": 58,
      "deletions": 0,
      "changes": 58,
      "patch": "@@ -51,6 +51,7 @@\n import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.index.IndexVersionUtils;\n+import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.util.Arrays;\n@@ -614,6 +615,63 @@ public void testShrinkThenSplitWithFailedNode() throws Exception {\n         assertNoResizeSourceIndexSettings(\"splitagain\");\n     }\n \n+    /**\n+     * Tests that shrinking a logsdb index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testShrinkLogsdbIndexWithNonDefaultTimestamp() {\n+        // Create a logsdb index with a date_nanos @timestamp field\n+        final var settings = indexSettings(2, 0).put(\"index.mode\", \"logsdb\")\n+            .put(\"index.blocks.write\", true)\n+            .put(\"index.routing.allocation.require._name\", internalCluster().getRandomDataNodeName());\n+        prepareCreate(\"source\").setSettings(settings).setMapping(\"@timestamp\", \"type=date_nanos\").get();\n+        ensureGreen();\n+\n+        // Shrink the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.SHRINK)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(TEST_REQUEST_TIMEOUT, \"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n+\n+    /**\n+     * Tests that shrinking a time series index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testShrinkTimeSeriesIndexWithNonDefaultTimestamp() {\n+        // Create a time series index with a date_nanos @timestamp field\n+        final var settings = indexSettings(2, 0).put(\"index.mode\", \"time_series\")\n+            .put(\"index.routing_path\", \"sensor_id\")\n+            .put(\"index.routing.allocation.require._name\", internalCluster().getRandomDataNodeName())\n+            .put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings)\n+            .setMapping(\"@timestamp\", \"type=date_nanos\", \"sensor_id\", \"type=keyword,time_series_dimension=true\")\n+            .get();\n+        ensureGreen();\n+\n+        // Shrink the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.SHRINK)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(TEST_REQUEST_TIMEOUT, \"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n+\n     static void assertNoResizeSourceIndexSettings(final String index) {\n         ClusterStateResponse clusterStateResponse = clusterAdmin().prepareState(TEST_REQUEST_TIMEOUT)\n             .clear()"
    },
    {
      "filename": "server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/SplitIndexIT.java",
      "status": "modified",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "patch": "@@ -46,6 +46,7 @@\n import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.index.IndexVersionUtils;\n+import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.io.IOException;\n@@ -496,4 +497,31 @@ public void testCreateSplitWithIndexSort() throws Exception {\n         assertSortedSegments(\"target\", expectedIndexSort);\n         assertNoResizeSourceIndexSettings(\"target\");\n     }\n+\n+    /**\n+     * Tests that splitting a logsdb index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     * N.B.: we don't test time_series indices as split is not supported for them.\n+     */\n+    public void testSplitLogsdbIndexWithNonDefaultTimestamp() {\n+        // Create a logsdb index with a date_nanos @timestamp field\n+        final int numberOfReplicas = randomInt(internalCluster().numDataNodes() - 1);\n+        final var settings = indexSettings(1, numberOfReplicas).put(\"index.mode\", \"logsdb\").put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings).setMapping(\"@timestamp\", \"type=date_nanos\").get();\n+        ensureGreen();\n+\n+        // Split the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.SPLIT)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_shards\", 2).put(\"index.number_of_replicas\", numberOfReplicas).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(TEST_REQUEST_TIMEOUT, \"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n }"
    },
    {
      "filename": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java",
      "status": "modified",
      "additions": 15,
      "deletions": 14,
      "changes": 29,
      "patch": "@@ -543,11 +543,15 @@ private ClusterState applyCreateIndexWithTemporaryService(\n         assert indicesService.hasIndex(temporaryIndexMeta.getIndex()) == false\n             : Strings.format(\"Index [%s] already exists\", temporaryIndexMeta.getIndex().getName());\n         return indicesService.<ClusterState, Exception>withTempIndexService(temporaryIndexMeta, indexService -> {\n-            try {\n-                updateIndexMappingsAndBuildSortOrder(indexService, request, mappings, sourceMetadata);\n-            } catch (Exception e) {\n-                logger.log(silent ? Level.DEBUG : Level.INFO, \"failed on parsing mappings on index creation [{}]\", request.index(), e);\n-                throw e;\n+            // If we're creating the index from an existing index, we should not provide any mappings, as the new index shards will take\n+            // care of copying the mappings from the source index during recovery. Providing mappings here would cause conflicts.\n+            if (sourceMetadata == null) {\n+                try {\n+                    updateIndexMappingsAndBuildSortOrder(indexService, request, mappings);\n+                } catch (Exception e) {\n+                    logger.log(silent ? Level.DEBUG : Level.INFO, \"failed on parsing mappings on index creation [{}]\", request.index(), e);\n+                    throw e;\n+                }\n             }\n \n             final List<AliasMetadata> aliases = aliasSupplier.apply(indexService);\n@@ -1550,8 +1554,7 @@ private static IndexMetadata.Builder createIndexMetadataBuilder(\n     private static void updateIndexMappingsAndBuildSortOrder(\n         IndexService indexService,\n         CreateIndexClusterStateUpdateRequest request,\n-        List<CompressedXContent> mappings,\n-        @Nullable IndexMetadata sourceMetadata\n+        List<CompressedXContent> mappings\n     ) throws IOException {\n         MapperService mapperService = indexService.mapperService();\n         IndexMode indexMode = indexService.getIndexSettings() != null ? indexService.getIndexSettings().getMode() : IndexMode.STANDARD;\n@@ -1565,13 +1568,11 @@ private static void updateIndexMappingsAndBuildSortOrder(\n \n         indexMode.validateTimestampFieldMapping(request.dataStreamName() != null, mapperService.mappingLookup());\n \n-        if (sourceMetadata == null) {\n-            // now that the mapping is merged we can validate the index sort.\n-            // we cannot validate for index shrinking since the mapping is empty\n-            // at this point. The validation will take place later in the process\n-            // (when all shards are copied in a single place).\n-            indexService.getIndexSortSupplier().get();\n-        }\n+        // now that the mapping is merged we can validate the index sort.\n+        // we cannot validate for index shrinking since the mapping is empty\n+        // at this point. The validation will take place later in the process\n+        // (when all shards are copied in a single place).\n+        indexService.getIndexSortSupplier().get();\n     }\n \n     private static void validateActiveShardCount(ActiveShardCount waitForActiveShards, IndexMetadata indexMetadata) {"
    },
    {
      "filename": "test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "patch": "@@ -2114,6 +2114,13 @@ public String getRandomNodeName() {\n         return getNodeNameThat(Predicates.always());\n     }\n \n+    /**\n+     * @return the name of a random data node in a cluster\n+     */\n+    public String getRandomDataNodeName() {\n+        return getNodeNameThat(DiscoveryNode::canContainData);\n+    }\n+\n     /**\n      * @return the name of a random node in a cluster that match the {@code predicate}\n      */"
    }
  ],
  "diff": "diff --git a/docs/changelog/137096.yaml b/docs/changelog/137096.yaml\nnew file mode 100644\nindex 0000000000000..1b194934b0691\n--- /dev/null\n+++ b/docs/changelog/137096.yaml\n@@ -0,0 +1,5 @@\n+pr: 137096\n+summary: Fix mapping conflicts in clone/split/shrink APIs\n+area: Indices APIs\n+type: bug\n+issues: []\ndiff --git a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/CloneIndexIT.java b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/CloneIndexIT.java\nindex 92049978c4bf2..654a1393aa146 100644\n--- a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/CloneIndexIT.java\n+++ b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/CloneIndexIT.java\n@@ -20,6 +20,7 @@\n import org.elasticsearch.index.seqno.SeqNoStats;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.index.IndexVersionUtils;\n+import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.util.List;\n@@ -203,4 +204,60 @@ public void testResizeChangeIndexSorts() {\n         });\n         assertThat(error.getMessage(), containsString(\"can't override index sort when resizing an index\"));\n     }\n+\n+    /**\n+     * Test that cloning a logsdb index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testCloneLogsdbIndexWithNonDefaultTimestamp() {\n+        // Create a logsdb index with a date_nanos @timestamp field\n+        final int numberOfReplicas = randomInt(internalCluster().numDataNodes() - 1);\n+        final var settings = indexSettings(1, numberOfReplicas).put(\"index.mode\", \"logsdb\").put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings).setMapping(\"@timestamp\", \"type=date_nanos\").get();\n+        ensureGreen();\n+\n+        // Clone the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.CLONE)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_replicas\", numberOfReplicas).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(TEST_REQUEST_TIMEOUT, \"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n+\n+    /**\n+     * Test that cloning a time series index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testCloneTimeSeriesIndexWithNonDefaultTimestamp() {\n+        // Create a time series index with a date_nanos @timestamp field\n+        final int numberOfReplicas = randomInt(internalCluster().numDataNodes() - 1);\n+        final var settings = indexSettings(1, numberOfReplicas).put(\"index.mode\", \"time_series\")\n+            .put(\"index.routing_path\", \"sensor_id\")\n+            .put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings)\n+            .setMapping(\"@timestamp\", \"type=date_nanos\", \"sensor_id\", \"type=keyword,time_series_dimension=true\")\n+            .get();\n+        ensureGreen();\n+\n+        // Clone the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.CLONE)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_replicas\", numberOfReplicas).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(TEST_REQUEST_TIMEOUT, \"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n }\ndiff --git a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/ShrinkIndexIT.java b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/ShrinkIndexIT.java\nindex 3d8b90c5797ce..31831f7eb6fe5 100644\n--- a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/ShrinkIndexIT.java\n+++ b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/ShrinkIndexIT.java\n@@ -51,6 +51,7 @@\n import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.index.IndexVersionUtils;\n+import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.util.Arrays;\n@@ -614,6 +615,63 @@ public void testShrinkThenSplitWithFailedNode() throws Exception {\n         assertNoResizeSourceIndexSettings(\"splitagain\");\n     }\n \n+    /**\n+     * Tests that shrinking a logsdb index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testShrinkLogsdbIndexWithNonDefaultTimestamp() {\n+        // Create a logsdb index with a date_nanos @timestamp field\n+        final var settings = indexSettings(2, 0).put(\"index.mode\", \"logsdb\")\n+            .put(\"index.blocks.write\", true)\n+            .put(\"index.routing.allocation.require._name\", internalCluster().getRandomDataNodeName());\n+        prepareCreate(\"source\").setSettings(settings).setMapping(\"@timestamp\", \"type=date_nanos\").get();\n+        ensureGreen();\n+\n+        // Shrink the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.SHRINK)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(TEST_REQUEST_TIMEOUT, \"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n+\n+    /**\n+     * Tests that shrinking a time series index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     */\n+    public void testShrinkTimeSeriesIndexWithNonDefaultTimestamp() {\n+        // Create a time series index with a date_nanos @timestamp field\n+        final var settings = indexSettings(2, 0).put(\"index.mode\", \"time_series\")\n+            .put(\"index.routing_path\", \"sensor_id\")\n+            .put(\"index.routing.allocation.require._name\", internalCluster().getRandomDataNodeName())\n+            .put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings)\n+            .setMapping(\"@timestamp\", \"type=date_nanos\", \"sensor_id\", \"type=keyword,time_series_dimension=true\")\n+            .get();\n+        ensureGreen();\n+\n+        // Shrink the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.SHRINK)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_shards\", 1).put(\"index.number_of_replicas\", 0).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(TEST_REQUEST_TIMEOUT, \"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n+\n     static void assertNoResizeSourceIndexSettings(final String index) {\n         ClusterStateResponse clusterStateResponse = clusterAdmin().prepareState(TEST_REQUEST_TIMEOUT)\n             .clear()\ndiff --git a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/SplitIndexIT.java b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/SplitIndexIT.java\nindex 5a483df773097..5055430310703 100644\n--- a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/SplitIndexIT.java\n+++ b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/create/SplitIndexIT.java\n@@ -46,6 +46,7 @@\n import org.elasticsearch.indices.IndicesService;\n import org.elasticsearch.test.ESIntegTestCase;\n import org.elasticsearch.test.index.IndexVersionUtils;\n+import org.elasticsearch.xcontent.ObjectPath;\n import org.elasticsearch.xcontent.XContentType;\n \n import java.io.IOException;\n@@ -496,4 +497,31 @@ public void testCreateSplitWithIndexSort() throws Exception {\n         assertSortedSegments(\"target\", expectedIndexSort);\n         assertNoResizeSourceIndexSettings(\"target\");\n     }\n+\n+    /**\n+     * Tests that splitting a logsdb index with a non-default timestamp mapping doesn't result in any mapping conflicts.\n+     * N.B.: we don't test time_series indices as split is not supported for them.\n+     */\n+    public void testSplitLogsdbIndexWithNonDefaultTimestamp() {\n+        // Create a logsdb index with a date_nanos @timestamp field\n+        final int numberOfReplicas = randomInt(internalCluster().numDataNodes() - 1);\n+        final var settings = indexSettings(1, numberOfReplicas).put(\"index.mode\", \"logsdb\").put(\"index.blocks.write\", true);\n+        prepareCreate(\"source\").setSettings(settings).setMapping(\"@timestamp\", \"type=date_nanos\").get();\n+        ensureGreen();\n+\n+        // Split the index\n+        indicesAdmin().prepareResizeIndex(\"source\", \"target\")\n+            .setResizeType(ResizeType.SPLIT)\n+            // We need to explicitly set the number of replicas in case the source has 0 replicas and the cluster has only 1 data node\n+            .setSettings(Settings.builder().put(\"index.number_of_shards\", 2).put(\"index.number_of_replicas\", numberOfReplicas).build())\n+            .get();\n+\n+        // Verify that the target index has the correct @timestamp mapping\n+        final var targetMappings = indicesAdmin().prepareGetMappings(TEST_REQUEST_TIMEOUT, \"target\").get();\n+        assertThat(\n+            ObjectPath.eval(\"properties.@timestamp.type\", targetMappings.mappings().get(\"target\").getSourceAsMap()),\n+            equalTo(\"date_nanos\")\n+        );\n+        ensureGreen();\n+    }\n }\ndiff --git a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java\nindex 4e8632ca18657..44bf6b93c014f 100644\n--- a/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java\n+++ b/server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java\n@@ -543,11 +543,15 @@ private ClusterState applyCreateIndexWithTemporaryService(\n         assert indicesService.hasIndex(temporaryIndexMeta.getIndex()) == false\n             : Strings.format(\"Index [%s] already exists\", temporaryIndexMeta.getIndex().getName());\n         return indicesService.<ClusterState, Exception>withTempIndexService(temporaryIndexMeta, indexService -> {\n-            try {\n-                updateIndexMappingsAndBuildSortOrder(indexService, request, mappings, sourceMetadata);\n-            } catch (Exception e) {\n-                logger.log(silent ? Level.DEBUG : Level.INFO, \"failed on parsing mappings on index creation [{}]\", request.index(), e);\n-                throw e;\n+            // If we're creating the index from an existing index, we should not provide any mappings, as the new index shards will take\n+            // care of copying the mappings from the source index during recovery. Providing mappings here would cause conflicts.\n+            if (sourceMetadata == null) {\n+                try {\n+                    updateIndexMappingsAndBuildSortOrder(indexService, request, mappings);\n+                } catch (Exception e) {\n+                    logger.log(silent ? Level.DEBUG : Level.INFO, \"failed on parsing mappings on index creation [{}]\", request.index(), e);\n+                    throw e;\n+                }\n             }\n \n             final List<AliasMetadata> aliases = aliasSupplier.apply(indexService);\n@@ -1550,8 +1554,7 @@ private static IndexMetadata.Builder createIndexMetadataBuilder(\n     private static void updateIndexMappingsAndBuildSortOrder(\n         IndexService indexService,\n         CreateIndexClusterStateUpdateRequest request,\n-        List<CompressedXContent> mappings,\n-        @Nullable IndexMetadata sourceMetadata\n+        List<CompressedXContent> mappings\n     ) throws IOException {\n         MapperService mapperService = indexService.mapperService();\n         IndexMode indexMode = indexService.getIndexSettings() != null ? indexService.getIndexSettings().getMode() : IndexMode.STANDARD;\n@@ -1565,13 +1568,11 @@ private static void updateIndexMappingsAndBuildSortOrder(\n \n         indexMode.validateTimestampFieldMapping(request.dataStreamName() != null, mapperService.mappingLookup());\n \n-        if (sourceMetadata == null) {\n-            // now that the mapping is merged we can validate the index sort.\n-            // we cannot validate for index shrinking since the mapping is empty\n-            // at this point. The validation will take place later in the process\n-            // (when all shards are copied in a single place).\n-            indexService.getIndexSortSupplier().get();\n-        }\n+        // now that the mapping is merged we can validate the index sort.\n+        // we cannot validate for index shrinking since the mapping is empty\n+        // at this point. The validation will take place later in the process\n+        // (when all shards are copied in a single place).\n+        indexService.getIndexSortSupplier().get();\n     }\n \n     private static void validateActiveShardCount(ActiveShardCount waitForActiveShards, IndexMetadata indexMetadata) {\ndiff --git a/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java b/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java\nindex 9e13105994de6..59bf3fddf13ba 100644\n--- a/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java\n+++ b/test/framework/src/main/java/org/elasticsearch/test/InternalTestCluster.java\n@@ -2114,6 +2114,13 @@ public String getRandomNodeName() {\n         return getNodeNameThat(Predicates.always());\n     }\n \n+    /**\n+     * @return the name of a random data node in a cluster\n+     */\n+    public String getRandomDataNodeName() {\n+        return getNodeNameThat(DiscoveryNode::canContainData);\n+    }\n+\n     /**\n      * @return the name of a random node in a cluster that match the {@code predicate}\n      */\n",
  "additions": 170,
  "deletions": 14,
  "changed_files": 6,
  "url": "https://github.com/elastic/elasticsearch/pull/137096",
  "mined_at": "2025-10-25T13:17:18.545276"
}