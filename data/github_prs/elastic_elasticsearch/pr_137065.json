{
  "id": 137065,
  "repository": "elastic/elasticsearch",
  "title": "add get all action for sampling configs",
  "body": "adds the get endpoint for all sampling configs; e.g.\r\n```\r\nGET /_sample/config\r\n\r\nreturns:\r\n\r\n[\r\n  {\r\n    \"index\": \"logs\",\r\n    \"configuration:\r\n    {\r\n      \"rate\": \"5%\",\r\n      \"if\": \"ctx?.network?.name == 'Guest'\"\r\n    }\r\n  },\r\n  {\r\n    \"index\": \"my-index\",\r\n    \"configuration:\r\n    {\r\n      \"rate\": \"25%\"\r\n    }\r\n  }\r\n]\r\n```",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-24T21:38:29+00:00",
  "created_at": "2025-10-23T20:06:38+00:00",
  "updated_at": "2025-10-24T21:38:38+00:00",
  "author": "seanzatzdev",
  "reviewers": [
    "copilot-pull-request-reviewer[bot]",
    "seanzatzdev",
    "masseyke"
  ],
  "base_sha": "4a5355184ef7e1fa4d48a6c851ca02e5c204a388",
  "head_sha": "43d4ce4356e41774d7029e22eb112e7ede4e6e95",
  "review_comments": [
    {
      "user": "copilot-pull-request-reviewer[bot]",
      "state": "COMMENTED",
      "body": "## Pull Request Overview\n\nThis PR adds a new GET endpoint `/_sample/config` to retrieve all sampling configurations across the cluster. The endpoint returns an array of objects containing index names and their associated sampling configurations.\n\n**Key changes:**\n- Introduced `GetAllSampleConfigurationAction` with request/response classes supporting cluster-wide configuration retrieval\n- Added transport and REST handlers for the new action\n- Implemented comprehensive test coverage including unit, integration, and YAML REST tests\n\n### Reviewed Changes\n\nCopilot reviewed 10 out of 10 changed files in this pull request and generated 2 comments.\n\n<details>\n<summary>Show a summary per file</summary>\n\n| File | Description |\r\n| ---- | ----------- |\r\n| `GetAllSampleConfigurationAction.java` | Defines the action type, request/response classes with serialization and XContent support |\r\n| `TransportGetAllSampleConfigurationAction.java` | Implements transport layer logic to retrieve all sampling configurations from cluster metadata |\r\n| `RestGetAllSampleConfigurationAction.java` | REST handler mapping GET `/_sample/config` to the transport action |\r\n| `ActionModule.java` | Registers the new action and REST handler |\r\n| `Constants.java` | Adds the new action privilege string |\r\n| `GetAllSampleConfigurationActionRequestTests.java` | Unit tests for request serialization and task creation |\r\n| `GetAllSampleConfigurationActionResponseTests.java` | Unit tests for response serialization with mutation testing |\r\n| `GetAllSampleConfigurationActionIT.java` | Integration tests covering various scenarios |\r\n| `10_basic.yml` | YAML REST API tests |\r\n| `indices.get_all_sample_configuration.json` | REST API specification |\n</details>\n\n\n\n\n\n\n---\n\n<sub>**Tip:** Customize your code reviews with copilot-instructions.md. <a href=\"/elastic/elasticsearch/new/main/.github?filename=copilot-instructions.md\" class=\"Link--inTextBlock\" target=\"_blank\" rel=\"noopener noreferrer\">Create the file</a> or <a href=\"https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot\" class=\"Link--inTextBlock\" target=\"_blank\" rel=\"noopener noreferrer\">learn how to get started</a>.</sub>",
      "submitted_at": "2025-10-23T20:07:19+00:00"
    },
    {
      "user": "masseyke",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-23T21:48:14+00:00"
    },
    {
      "user": "masseyke",
      "state": "APPROVED",
      "body": "Looks good to me, with the exception of the unreachable test code I commented on.",
      "submitted_at": "2025-10-23T21:51:53+00:00"
    },
    {
      "user": "seanzatzdev",
      "state": "COMMENTED",
      "body": "",
      "submitted_at": "2025-10-23T23:34:10+00:00"
    }
  ],
  "pr_comments": [
    {
      "user": "elasticsearchmachine",
      "body": "Pinging @elastic/es-data-management (Team:Data Management)",
      "created_at": "2025-10-23T20:12:36+00:00"
    },
    {
      "user": "seanzatzdev",
      "body": "Looks like the yaml rest tests are all getting \"connection refused\" for some reason, not sure what that's about but seems like it must be a wider problem since all of the yaml tests i didnt touch are getting it",
      "created_at": "2025-10-23T21:16:40+00:00"
    }
  ],
  "files_changed": [
    {
      "filename": "rest-api-spec/src/main/resources/rest-api-spec/api/indices.get_all_sample_configuration.json",
      "status": "added",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "patch": "@@ -0,0 +1,32 @@\n+{\n+  \"indices.get_all_sample_configuration\": {\n+    \"documentation\": {\n+      \"url\": \"https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-indices-get-all-sample-configuration\",\n+      \"description\": \"Get sampling configurations for all indices and data streams\"\n+    },\n+    \"stability\": \"experimental\",\n+    \"visibility\": \"public\",\n+    \"headers\": {\n+      \"accept\": [\n+        \"application/json\"\n+      ]\n+    },\n+    \"url\": {\n+      \"paths\": [\n+        {\n+          \"path\": \"/_sample/config\",\n+          \"methods\": [\n+            \"GET\"\n+          ]\n+        }\n+      ]\n+    },\n+    \"params\": {\n+      \"master_timeout\": {\n+        \"type\": \"time\",\n+        \"description\": \"Timeout for connection to master node\"\n+      }\n+    }\n+  }\n+}\n+"
    },
    {
      "filename": "rest-api-spec/src/yamlRestTest/resources/rest-api-spec/test/indices.get_all_sample_configuration/10_basic.yml",
      "status": "added",
      "additions": 254,
      "deletions": 0,
      "changes": 254,
      "patch": "@@ -0,0 +1,254 @@\n+---\n+setup:\n+  - requires:\n+      cluster_features: [ \"random_sampling\" ]\n+      reason: requires feature 'random_sampling' to get random samples\n+\n+---\n+teardown:\n+  - do:\n+      indices.delete:\n+        index: \"*test*\"\n+        ignore_unavailable: true\n+        allow_no_indices: true\n+\n+---\n+\"Get all sampling configurations with no configurations\":\n+  - do:\n+      indices.create:\n+        index: test-no-config-index-1\n+\n+  - do:\n+      indices.create:\n+        index: test-no-config-index-2\n+\n+  - do:\n+      indices.get_all_sample_configuration: {}\n+\n+  # Should return an empty array\n+  - length: { $body: 0 }\n+\n+---\n+\"Get all sampling configurations with single configuration\":\n+  - do:\n+      indices.create:\n+        index: test-single-config-index\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-single-config-index\n+        body:\n+          rate: 0.5\n+          max_samples: 100\n+          max_size: \"10mb\"\n+          time_to_live: \"1h\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  - length: { $body: 1 }\n+  - match: { 0.index: \"test-single-config-index\" }\n+  - match: { 0.configuration.rate: 0.5 }\n+  - match: { 0.configuration.max_samples: 100 }\n+  - match: { 0.configuration.max_size: \"10mb\" }\n+  - match: { 0.configuration.time_to_live: \"1h\" }\n+\n+---\n+\"Get all sampling configurations with multiple configurations\":\n+  - do:\n+      indices.create:\n+        index: test-multi-config-index-1\n+\n+  - do:\n+      indices.create:\n+        index: test-multi-config-index-2\n+\n+  - do:\n+      indices.create:\n+        index: test-multi-config-index-3\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-multi-config-index-1\n+        body:\n+          rate: 0.3\n+          max_samples: 50\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-multi-config-index-2\n+        body:\n+          rate: 0.7\n+          max_samples: 200\n+          max_size: \"20mb\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-multi-config-index-3\n+        body:\n+          rate: 1.0\n+          if: \"ctx?.field == 'sample_me'\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  - length: { $body: 3 }\n+  # Note: Array order may vary, so we just verify all 3 configurations exist\n+  - is_true: 0.index\n+  - is_true: 0.configuration\n+  - is_true: 1.index\n+  - is_true: 1.configuration\n+  - is_true: 2.index\n+  - is_true: 2.configuration\n+\n+---\n+\"Get all sampling configurations with mixed indices\":\n+  - do:\n+      indices.create:\n+        index: test-mixed-configured-1\n+\n+  - do:\n+      indices.create:\n+        index: test-mixed-unconfigured\n+\n+  - do:\n+      indices.create:\n+        index: test-mixed-configured-2\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-mixed-configured-1\n+        body:\n+          rate: 0.4\n+          max_samples: 75\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-mixed-configured-2\n+        body:\n+          rate: 0.6\n+          time_to_live: \"2h\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  # Should only return configured indices (2 items)\n+  - length: { $body: 2 }\n+  - is_true: 0.index\n+  - is_true: 0.configuration\n+  - is_true: 1.index\n+  - is_true: 1.configuration\n+\n+---\n+\"Get all sampling configurations after update\":\n+  - do:\n+      indices.create:\n+        index: test-update-all-index\n+\n+  # Set initial configuration\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-update-all-index\n+        body:\n+          rate: 0.2\n+          max_samples: 30\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  - length: { $body: 1 }\n+  - match: { 0.index: \"test-update-all-index\" }\n+  - match: { 0.configuration.rate: 0.2 }\n+  - match: { 0.configuration.max_samples: 30 }\n+\n+  # Update configuration\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-update-all-index\n+        body:\n+          rate: 0.9\n+          max_samples: 150\n+          max_size: \"15mb\"\n+\n+  - match: { acknowledged: true }\n+\n+  # Verify updated configuration in get all\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  - length: { $body: 1 }\n+  - match: { 0.index: \"test-update-all-index\" }\n+  - match: { 0.configuration.rate: 0.9 }\n+  - match: { 0.configuration.max_samples: 150 }\n+  - match: { 0.configuration.max_size: \"15mb\" }\n+\n+---\n+\"Get all sampling configurations after deletion\":\n+  - do:\n+      indices.create:\n+        index: test-delete-all-index-1\n+\n+  - do:\n+      indices.create:\n+        index: test-delete-all-index-2\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-delete-all-index-1\n+        body:\n+          rate: 0.5\n+          max_samples: 100\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-delete-all-index-2\n+        body:\n+          rate: 0.8\n+          max_samples: 200\n+\n+  - match: { acknowledged: true }\n+\n+  # Verify both configurations exist\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  - length: { $body: 2 }\n+\n+  # Delete one configuration\n+  - do:\n+      indices.delete_sample_configuration:\n+        index: test-delete-all-index-1\n+\n+  - match: { acknowledged: true }\n+\n+  # Verify only one configuration remains\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  - length: { $body: 1 }\n+  - match: { 0.index: \"test-delete-all-index-2\" }\n+  - match: { 0.configuration.rate: 0.8 }\n+  - match: { 0.configuration.max_samples: 200 }"
    },
    {
      "filename": "server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationActionIT.java",
      "status": "added",
      "additions": 253,
      "deletions": 0,
      "changes": 253,
      "patch": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.action.admin.indices.sampling;\n+\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.core.TimeValue;\n+import org.elasticsearch.ingest.SamplingService;\n+import org.elasticsearch.test.ESIntegTestCase;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.anEmptyMap;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasEntry;\n+import static org.hamcrest.Matchers.hasKey;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+public class GetAllSampleConfigurationActionIT extends ESIntegTestCase {\n+\n+    public void testGetAllSampleConfigurationsWithNoConfigurations() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        // Create some indices without sampling configurations\n+        int numIndices = randomIntBetween(1, 3);\n+        for (int i = 0; i < numIndices; i++) {\n+            createIndex(randomIdentifier());\n+        }\n+\n+        // Get all configurations - should return empty map\n+        GetAllSampleConfigurationAction.Response response = getAllSamplingConfigurations();\n+\n+        assertThat(\"Response should not be null\", response, notNullValue());\n+        assertThat(\"Configuration map should be empty\", response.getIndexToSamplingConfigMap(), is(anEmptyMap()));\n+    }\n+\n+    public void testGetAllSampleConfigurationsWithSingleConfiguration() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        String indexName = randomIdentifier();\n+        createIndex(indexName);\n+\n+        // Create a sampling configuration\n+        SamplingConfiguration config = randomSamplingConfiguration();\n+        putSamplingConfiguration(indexName, config);\n+\n+        // Get all configurations\n+        GetAllSampleConfigurationAction.Response response = getAllSamplingConfigurations();\n+\n+        assertThat(\"Response should not be null\", response, notNullValue());\n+        Map<String, SamplingConfiguration> configMap = response.getIndexToSamplingConfigMap();\n+        assertThat(\"Configuration map should not be empty\", configMap, not(anEmptyMap()));\n+        assertThat(\"Configuration map should contain the index\", configMap, hasKey(indexName));\n+        assertThat(\"Configuration should match\", configMap.get(indexName), equalTo(config));\n+    }\n+\n+    public void testGetAllSampleConfigurationsWithMultipleConfigurations() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        // Create multiple indices with sampling configurations\n+        int numIndices = randomIntBetween(2, 5);\n+        Map<String, SamplingConfiguration> expectedConfigs = new HashMap<>();\n+\n+        for (int i = 0; i < numIndices; i++) {\n+            String indexName = randomIdentifier();\n+            createIndex(indexName);\n+            SamplingConfiguration config = randomSamplingConfiguration();\n+            putSamplingConfiguration(indexName, config);\n+            expectedConfigs.put(indexName, config);\n+        }\n+\n+        // Get all configurations\n+        GetAllSampleConfigurationAction.Response response = getAllSamplingConfigurations();\n+\n+        assertThat(\"Response should not be null\", response, notNullValue());\n+        Map<String, SamplingConfiguration> configMap = response.getIndexToSamplingConfigMap();\n+        assertThat(\"Configuration map should have correct size\", configMap.size(), equalTo(expectedConfigs.size()));\n+\n+        // Verify each configuration matches\n+        for (Map.Entry<String, SamplingConfiguration> entry : expectedConfigs.entrySet()) {\n+            assertThat(\"Configuration map should contain index: \" + entry.getKey(), configMap, hasEntry(entry.getKey(), entry.getValue()));\n+        }\n+    }\n+\n+    public void testGetAllSampleConfigurationsWithMixedIndices() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        // Create some indices with configurations\n+        int numConfiguredIndices = randomIntBetween(1, 3);\n+        Map<String, SamplingConfiguration> expectedConfigs = new HashMap<>();\n+\n+        for (int i = 0; i < numConfiguredIndices; i++) {\n+            String indexName = randomIdentifier();\n+            createIndex(indexName);\n+            SamplingConfiguration config = randomSamplingConfiguration();\n+            putSamplingConfiguration(indexName, config);\n+            expectedConfigs.put(indexName, config);\n+        }\n+\n+        // Create some indices without configurations\n+        int numUnconfiguredIndices = randomIntBetween(1, 3);\n+        for (int i = 0; i < numUnconfiguredIndices; i++) {\n+            createIndex(randomIdentifier());\n+        }\n+\n+        // Get all configurations - should only return configured indices\n+        GetAllSampleConfigurationAction.Response response = getAllSamplingConfigurations();\n+\n+        assertThat(\"Response should not be null\", response, notNullValue());\n+        Map<String, SamplingConfiguration> configMap = response.getIndexToSamplingConfigMap();\n+        assertThat(\"Configuration map should only contain configured indices\", configMap.size(), equalTo(expectedConfigs.size()));\n+\n+        // Verify each configuration matches\n+        for (Map.Entry<String, SamplingConfiguration> entry : expectedConfigs.entrySet()) {\n+            assertThat(\"Configuration map should contain index: \" + entry.getKey(), configMap, hasEntry(entry.getKey(), entry.getValue()));\n+        }\n+    }\n+\n+    public void testGetAllSampleConfigurationsAfterUpdate() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        String indexName = randomIdentifier();\n+        createIndex(indexName);\n+\n+        // Create initial configuration\n+        SamplingConfiguration initialConfig = randomSamplingConfiguration();\n+        putSamplingConfiguration(indexName, initialConfig);\n+\n+        // Get all configurations - should have initial config\n+        GetAllSampleConfigurationAction.Response response1 = getAllSamplingConfigurations();\n+        assertThat(\"Initial configuration should match\", response1.getIndexToSamplingConfigMap().get(indexName), equalTo(initialConfig));\n+\n+        // Update with new configuration\n+        SamplingConfiguration updatedConfig = randomSamplingConfiguration();\n+        putSamplingConfiguration(indexName, updatedConfig);\n+\n+        // Get all configurations - should have updated config\n+        GetAllSampleConfigurationAction.Response response2 = getAllSamplingConfigurations();\n+        assertThat(\"Updated configuration should match\", response2.getIndexToSamplingConfigMap().get(indexName), equalTo(updatedConfig));\n+    }\n+\n+    public void testGetAllSampleConfigurationsAfterDeletion() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        // Create two indices with configurations\n+        String index1 = randomIdentifier();\n+        String index2 = randomIdentifier();\n+        createIndex(index1);\n+        createIndex(index2);\n+\n+        SamplingConfiguration config1 = randomSamplingConfiguration();\n+        SamplingConfiguration config2 = randomSamplingConfiguration();\n+        putSamplingConfiguration(index1, config1);\n+        putSamplingConfiguration(index2, config2);\n+\n+        // Get all configurations - should have both\n+        GetAllSampleConfigurationAction.Response response1 = getAllSamplingConfigurations();\n+        assertThat(\"Should have two configurations\", response1.getIndexToSamplingConfigMap().size(), equalTo(2));\n+\n+        // Delete one configuration\n+        deleteSamplingConfiguration(index1);\n+\n+        // Get all configurations - should only have one\n+        GetAllSampleConfigurationAction.Response response2 = getAllSamplingConfigurations();\n+        Map<String, SamplingConfiguration> configMap = response2.getIndexToSamplingConfigMap();\n+        assertThat(\"Should have one configuration\", configMap.size(), equalTo(1));\n+        assertThat(\"Should not contain deleted index\", configMap, not(hasKey(index1)));\n+        assertThat(\"Should contain remaining index\", configMap, hasEntry(index2, config2));\n+    }\n+\n+    public void testGetAllSampleConfigurationsPersistsAcrossClusterStateUpdates() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        // Create indices with sampling configurations\n+        int numIndices = randomIntBetween(2, 4);\n+        Map<String, SamplingConfiguration> expectedConfigs = new HashMap<>();\n+\n+        for (int i = 0; i < numIndices; i++) {\n+            String indexName = randomIdentifier();\n+            createIndex(indexName);\n+            SamplingConfiguration config = randomSamplingConfiguration();\n+            putSamplingConfiguration(indexName, config);\n+            expectedConfigs.put(indexName, config);\n+        }\n+\n+        // Get initial configurations\n+        GetAllSampleConfigurationAction.Response response1 = getAllSamplingConfigurations();\n+        assertThat(\"Initial configurations should match\", response1.getIndexToSamplingConfigMap(), equalTo(expectedConfigs));\n+\n+        // Trigger cluster state updates by creating additional indices\n+        int numDummyIndices = randomIntBetween(2, 5);\n+        for (int i = 0; i < numDummyIndices; i++) {\n+            createIndex(randomIdentifier());\n+        }\n+\n+        // Get configurations again after cluster state changes\n+        GetAllSampleConfigurationAction.Response response2 = getAllSamplingConfigurations();\n+        assertThat(\n+            \"Configurations should persist after cluster state changes\",\n+            response2.getIndexToSamplingConfigMap(),\n+            equalTo(expectedConfigs)\n+        );\n+    }\n+\n+    private SamplingConfiguration randomSamplingConfiguration() {\n+        return new SamplingConfiguration(\n+            randomDoubleBetween(0.1, 1.0, true),\n+            randomBoolean() ? randomIntBetween(1, SamplingConfiguration.MAX_SAMPLES_LIMIT) : null,\n+            randomBoolean() ? ByteSizeValue.ofGb(randomLongBetween(1, SamplingConfiguration.MAX_SIZE_LIMIT_GIGABYTES)) : null,\n+            randomBoolean() ? randomValidTimeValue() : null,\n+            randomBoolean() ? randomAlphaOfLengthBetween(5, 30) : null\n+        );\n+    }\n+\n+    private void putSamplingConfiguration(String indexName, SamplingConfiguration config) {\n+        PutSampleConfigurationAction.Request putRequest = new PutSampleConfigurationAction.Request(\n+            config,\n+            randomValidTimeValue(),\n+            randomValidTimeValue()\n+        );\n+        putRequest.indices(indexName);\n+        client().execute(PutSampleConfigurationAction.INSTANCE, putRequest).actionGet();\n+        ensureGreen();\n+    }\n+\n+    private void deleteSamplingConfiguration(String indexName) {\n+        DeleteSampleConfigurationAction.Request deleteRequest = new DeleteSampleConfigurationAction.Request(\n+            randomValidTimeValue(),\n+            randomValidTimeValue()\n+        );\n+        deleteRequest.indices(indexName);\n+        client().execute(DeleteSampleConfigurationAction.INSTANCE, deleteRequest).actionGet();\n+        ensureGreen();\n+    }\n+\n+    private GetAllSampleConfigurationAction.Response getAllSamplingConfigurations() {\n+        GetAllSampleConfigurationAction.Request request = new GetAllSampleConfigurationAction.Request(randomValidTimeValue());\n+        return client().execute(GetAllSampleConfigurationAction.INSTANCE, request).actionGet();\n+    }\n+\n+    private TimeValue randomValidTimeValue() {\n+        return TimeValue.timeValueDays(randomIntBetween(10, 20));\n+    }\n+}"
    },
    {
      "filename": "server/src/main/java/org/elasticsearch/action/ActionModule.java",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "patch": "@@ -128,16 +128,19 @@\n import org.elasticsearch.action.admin.indices.rollover.RolloverAction;\n import org.elasticsearch.action.admin.indices.rollover.TransportRolloverAction;\n import org.elasticsearch.action.admin.indices.sampling.DeleteSampleConfigurationAction;\n+import org.elasticsearch.action.admin.indices.sampling.GetAllSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.GetSampleAction;\n import org.elasticsearch.action.admin.indices.sampling.GetSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.GetSampleStatsAction;\n import org.elasticsearch.action.admin.indices.sampling.PutSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.RestDeleteSampleConfigurationAction;\n+import org.elasticsearch.action.admin.indices.sampling.RestGetAllSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.RestGetSampleAction;\n import org.elasticsearch.action.admin.indices.sampling.RestGetSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.RestGetSampleStatsAction;\n import org.elasticsearch.action.admin.indices.sampling.RestPutSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.TransportDeleteSampleConfigurationAction;\n+import org.elasticsearch.action.admin.indices.sampling.TransportGetAllSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.TransportGetSampleAction;\n import org.elasticsearch.action.admin.indices.sampling.TransportGetSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.TransportGetSampleStatsAction;\n@@ -835,6 +838,7 @@ public <Request extends ActionRequest, Response extends ActionResponse> void reg\n             actions.register(GetSampleStatsAction.INSTANCE, TransportGetSampleStatsAction.class);\n             actions.register(DeleteSampleConfigurationAction.INSTANCE, TransportDeleteSampleConfigurationAction.class);\n             actions.register(GetSampleConfigurationAction.INSTANCE, TransportGetSampleConfigurationAction.class);\n+            actions.register(GetAllSampleConfigurationAction.INSTANCE, TransportGetAllSampleConfigurationAction.class);\n         }\n \n         return unmodifiableMap(actions.getRegistry());\n@@ -1071,6 +1075,7 @@ public void initRestHandlers(Supplier<DiscoveryNodes> nodesInCluster, Predicate<\n             registerHandler.accept(new RestGetSampleStatsAction());\n             registerHandler.accept(new RestDeleteSampleConfigurationAction());\n             registerHandler.accept(new RestGetSampleConfigurationAction());\n+            registerHandler.accept(new RestGetAllSampleConfigurationAction());\n         }\n     }\n "
    },
    {
      "filename": "server/src/main/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationAction.java",
      "status": "added",
      "additions": 206,
      "deletions": 0,
      "changes": 206,
      "patch": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.action.admin.indices.sampling;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.local.LocalClusterStateRequest;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ChunkedToXContentObject;\n+import org.elasticsearch.core.Nullable;\n+import org.elasticsearch.core.TimeValue;\n+import org.elasticsearch.tasks.CancellableTask;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.xcontent.ToXContent;\n+import org.elasticsearch.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Action type for retrieving all sampling configurations for cluster indices.\n+ * <p>\n+ * This action allows clients to get all sampling configurations\n+ * that have been set. This action\n+ * targets all indices and returns any existing configurations in a structured format.\n+ * </p>\n+ * The response format matches:\n+ *  <pre>\n+ * [\n+ * {\n+ *  \"index\": \"logs\",\n+ *  \"configuration\": {\n+ *      \"rate\": \".5\",\n+ *      \"if\": \"ctx?.network?.name == 'Guest'\"\n+ *  }\n+ * },\n+ * {\n+ *  \"index\": \"logsTwo\",\n+ *  \"configuration\": {\n+ *      \"rate\": \".75\"\n+ *  }\n+ * },\n+ * ]\n+ *  </pre>\n+ *\n+ * @see SamplingConfiguration\n+ * @see PutSampleConfigurationAction\n+ */\n+public class GetAllSampleConfigurationAction extends ActionType<GetAllSampleConfigurationAction.Response> {\n+\n+    /**\n+     * Singleton instance of the GetAllSampleConfigurationAction.\n+     * This provides a shared reference to the action type throughout the application.\n+     */\n+    public static final GetAllSampleConfigurationAction INSTANCE = new GetAllSampleConfigurationAction();\n+\n+    /**\n+     * The name identifier for this action type used in the transport layer.\n+     */\n+    public static final String NAME = \"indices:monitor/sample/config/get_all\";\n+\n+    private GetAllSampleConfigurationAction() {\n+        super(NAME);\n+    }\n+\n+    /**\n+     * Request object for getting all sampling configurations in a cluster.\n+     */\n+    public static class Request extends LocalClusterStateRequest implements IndicesRequest.Replaceable {\n+        /**\n+         * Constructs a new request.\n+         *\n+         * @param masterNodeTimeout the timeout for master node operations, or null for default\n+         */\n+        public Request(@Nullable TimeValue masterNodeTimeout) {\n+            super(masterNodeTimeout);\n+        }\n+\n+        /**\n+         * Constructs a new request by deserializing from a StreamInput.\n+         *\n+         * @param in the stream input to read from\n+         * @throws IOException if an I/O error occurs during deserialization\n+         */\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+        }\n+\n+        @Override\n+        public String[] indices() {\n+            // This action reads from cluster state metadata (SamplingMetadata), not from indices directly.\n+            // The IndicesRequest implementation is required for security authorization checks.\n+            return new String[] { \"*\" };\n+        }\n+\n+        @Override\n+        public IndicesOptions indicesOptions() {\n+            return IndicesOptions.LENIENT_EXPAND_OPEN;\n+        }\n+\n+        @Override\n+        public boolean includeDataStreams() {\n+            return true;\n+        }\n+\n+        @Override\n+        public Request indices(String... indices) {\n+            // This is a get-all operation, so we don't support changing the indices\n+            return this;\n+        }\n+\n+        @Override\n+        public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {\n+            return new CancellableTask(id, type, action, \"executing \" + action, parentTaskId, headers);\n+        }\n+    }\n+\n+    /**\n+     * Response object containing an index to sampling configuration map.\n+     * <p>\n+     * This response contains a map from index names to their associated sampling configurations.\n+     * The response is designed to match the expected JSON format with an array containing\n+     * objects with \"index\" and \"configuration\" fields.\n+     * </p>\n+     */\n+    public static class Response extends ActionResponse implements ChunkedToXContentObject {\n+        private final Map<String, SamplingConfiguration> indexToSamplingConfigMap;\n+\n+        /**\n+         * Constructs a new Response with the given index to sampling configuration map.\n+         *\n+         * @param indexToSamplingConfigMap the index to sampling configuration map\n+         */\n+        public Response(Map<String, SamplingConfiguration> indexToSamplingConfigMap) {\n+            this.indexToSamplingConfigMap = indexToSamplingConfigMap;\n+        }\n+\n+        /**\n+         * Constructs a new Response by deserializing from a StreamInput.\n+         *\n+         * @param in the stream input to read from\n+         * @throws IOException if an I/O error occurs during deserialization\n+         */\n+        public Response(StreamInput in) throws IOException {\n+            this.indexToSamplingConfigMap = in.readMap(StreamInput::readString, SamplingConfiguration::new);\n+        }\n+\n+        /**\n+         * Gets the index to sampling configuration map.\n+         *\n+         * @return the index to sampling configuration map, or an empty map if none exist\n+         */\n+        public Map<String, SamplingConfiguration> getIndexToSamplingConfigMap() {\n+            return indexToSamplingConfigMap == null ? Map.of() : indexToSamplingConfigMap;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeMap(indexToSamplingConfigMap, StreamOutput::writeString, (o, v) -> v.writeTo(o));\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Response that = (Response) o;\n+            return indexToSamplingConfigMap.equals(that.indexToSamplingConfigMap);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(indexToSamplingConfigMap);\n+        }\n+\n+        @Override\n+        public Iterator<? extends ToXContent> toXContentChunked(ToXContent.Params params) {\n+            return Collections.singletonList((ToXContent) (builder, p) -> toXContent(builder, params)).iterator();\n+        }\n+\n+        private XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {\n+            builder.startArray();\n+            for (Map.Entry<String, SamplingConfiguration> entry : indexToSamplingConfigMap.entrySet()) {\n+                builder.startObject();\n+                builder.field(\"index\", entry.getKey());\n+                builder.field(\"configuration\", entry.getValue());\n+                builder.endObject();\n+            }\n+            builder.endArray();\n+            return builder;\n+        }\n+    }\n+}"
    },
    {
      "filename": "server/src/main/java/org/elasticsearch/action/admin/indices/sampling/RestGetAllSampleConfigurationAction.java",
      "status": "added",
      "additions": 76,
      "deletions": 0,
      "changes": 76,
      "patch": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.action.admin.indices.sampling;\n+\n+import org.elasticsearch.client.internal.node.NodeClient;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.Scope;\n+import org.elasticsearch.rest.ServerlessScope;\n+import org.elasticsearch.rest.action.RestCancellableNodeClient;\n+import org.elasticsearch.rest.action.RestRefCountedChunkedToXContentListener;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+import static org.elasticsearch.rest.RestUtils.getMasterNodeTimeout;\n+\n+/**\n+ * REST action for getting all sampling configurations for indices.\n+ * <p>\n+ * Handles GET requests to /_sample/config endpoint and delegates\n+ * to the GetAllSampleConfigurationAction transport action.\n+ * </p>\n+ *\n+ * <p>Example usage:</p>\n+ * GET /_sample/config\n+ * returns\n+ * [\n+ * {\n+ *  \"index\": \"logs\",\n+ *  \"configuration\": {\n+ *      \"rate\": \".5\",\n+ *      \"if\": \"ctx?.network?.name == 'Guest'\"\n+ *  }\n+ * },\n+ * {\n+ *  \"index\": \"logsTwo\",\n+ *  \"configuration\": {\n+ *      \"rate\": \".75\"\n+ *  }\n+ * },\n+ * ]\n+ */\n+@ServerlessScope(Scope.INTERNAL)\n+public class RestGetAllSampleConfigurationAction extends BaseRestHandler {\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(new Route(GET, \"/_sample/config\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"get_all_sample_configuration_action\";\n+    }\n+\n+    @Override\n+    public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {\n+        GetAllSampleConfigurationAction.Request getRequest = new GetAllSampleConfigurationAction.Request(getMasterNodeTimeout(request));\n+\n+        return channel -> new RestCancellableNodeClient(client, request.getHttpChannel()).execute(\n+            GetAllSampleConfigurationAction.INSTANCE,\n+            getRequest,\n+            new RestRefCountedChunkedToXContentListener<>(channel)\n+        );\n+    }\n+\n+}"
    },
    {
      "filename": "server/src/main/java/org/elasticsearch/action/admin/indices/sampling/TransportGetAllSampleConfigurationAction.java",
      "status": "added",
      "additions": 119,
      "deletions": 0,
      "changes": 119,
      "patch": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.action.admin.indices.sampling;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.local.TransportLocalProjectMetadataAction;\n+import org.elasticsearch.cluster.ProjectState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.ProjectMetadata;\n+import org.elasticsearch.cluster.project.ProjectResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.injection.guice.Inject;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.util.Map;\n+\n+/**\n+ * Transport action for retrieving all existing sampling configurations.\n+ * <p>\n+ * This action retrieves the sampling configurations from the project metadata's custom sampling metadata.\n+ * </p>\n+ */\n+public class TransportGetAllSampleConfigurationAction extends TransportLocalProjectMetadataAction<\n+    GetAllSampleConfigurationAction.Request,\n+    GetAllSampleConfigurationAction.Response> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportGetAllSampleConfigurationAction.class);\n+\n+    /**\n+     * Constructs a new TransportGetAllSampleConfigurationAction.\n+     *\n+     * @param actionFilters the action filters to apply\n+     * @param transportService the transport service\n+     * @param clusterService the cluster service\n+     * @param projectResolver the project resolver\n+     */\n+    @Inject\n+    public TransportGetAllSampleConfigurationAction(\n+        ActionFilters actionFilters,\n+        TransportService transportService,\n+        ClusterService clusterService,\n+        ProjectResolver projectResolver\n+    ) {\n+        super(\n+            GetAllSampleConfigurationAction.NAME,\n+            actionFilters,\n+            transportService.getTaskManager(),\n+            clusterService,\n+            EsExecutors.DIRECT_EXECUTOR_SERVICE,\n+            projectResolver\n+        );\n+    }\n+\n+    /**\n+     * Executes the get all sampling configuration operation against the local cluster state.\n+     * <p>\n+     * Retrieves all sampling configuration from the project metadata.\n+     * Returns empty map if no sampling metadata exists or if no configurations are set.\n+     * </p>\n+     *\n+     * @param task the task executing this operation\n+     * @param request the get sampling configuration request containing the index name\n+     * @param state the current project state\n+     * @param listener the listener to notify with the response or failure\n+     */\n+    @Override\n+    protected void localClusterStateOperation(\n+        Task task,\n+        GetAllSampleConfigurationAction.Request request,\n+        ProjectState state,\n+        ActionListener<GetAllSampleConfigurationAction.Response> listener\n+    ) {\n+        ProjectMetadata projectMetadata = state.metadata();\n+\n+        if (projectMetadata == null) {\n+            logger.debug(\"No project metadata found\");\n+            listener.onResponse(new GetAllSampleConfigurationAction.Response(Map.of()));\n+            return;\n+        }\n+\n+        SamplingMetadata samplingMetadata = projectMetadata.custom(SamplingMetadata.TYPE);\n+        if (samplingMetadata == null) {\n+            logger.debug(\"No sampling metadata found\");\n+            listener.onResponse(new GetAllSampleConfigurationAction.Response(Map.of()));\n+            return;\n+        }\n+\n+        Map<String, SamplingConfiguration> indexToSampleConfigMap = samplingMetadata.getIndexToSamplingConfigMap();\n+        logger.debug(\"Retrieved sampling configurations\");\n+        listener.onResponse(\n+            new GetAllSampleConfigurationAction.Response(indexToSampleConfigMap == null ? Map.of() : indexToSampleConfigMap)\n+        );\n+    }\n+\n+    /**\n+     * Checks for cluster blocks that would prevent this operation from executing.\n+     *\n+     * @param request the get sampling configuration request\n+     * @param state the current project state\n+     * @return a cluster block exception if the operation is blocked, null otherwise\n+     */\n+    @Override\n+    protected ClusterBlockException checkBlock(GetAllSampleConfigurationAction.Request request, ProjectState state) {\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ);\n+    }\n+}"
    },
    {
      "filename": "server/src/test/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationActionRequestTests.java",
      "status": "added",
      "additions": 58,
      "deletions": 0,
      "changes": 58,
      "patch": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.action.admin.indices.sampling;\n+\n+import org.elasticsearch.core.TimeValue;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+public class GetAllSampleConfigurationActionRequestTests extends ESTestCase {\n+\n+    protected GetAllSampleConfigurationAction.Request createTestInstance() {\n+        return new GetAllSampleConfigurationAction.Request(randomBoundedTimeValue());\n+    }\n+\n+    public void testGettersAndSetters() {\n+        TimeValue timeout = randomBoundedTimeValue();\n+        GetAllSampleConfigurationAction.Request request = new GetAllSampleConfigurationAction.Request(timeout);\n+\n+        assertThat(request.masterTimeout(), equalTo(timeout));\n+    }\n+\n+    public void testCreateTaskReturnsCancellableTask() {\n+        GetAllSampleConfigurationAction.Request request = createTestInstance();\n+\n+        long taskId = randomLong();\n+        String type = randomAlphaOfLength(10);\n+        String action = GetAllSampleConfigurationAction.NAME;\n+        TaskId parentTaskId = new TaskId(randomAlphaOfLength(10), randomLong());\n+        Map<String, String> headers = Map.of(\"header1\", \"value1\");\n+\n+        Task task = request.createTask(taskId, type, action, parentTaskId, headers);\n+\n+        assertThat(task, notNullValue());\n+        assertThat(task, instanceOf(org.elasticsearch.tasks.CancellableTask.class));\n+        assertThat(task.getId(), equalTo(taskId));\n+        assertThat(task.getType(), equalTo(type));\n+        assertThat(task.getAction(), equalTo(action));\n+        assertThat(task.getParentTaskId(), equalTo(parentTaskId));\n+    }\n+\n+    private TimeValue randomBoundedTimeValue() {\n+        return TimeValue.timeValueSeconds(randomIntBetween(5, 10));\n+    }\n+}"
    },
    {
      "filename": "server/src/test/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationActionResponseTests.java",
      "status": "added",
      "additions": 89,
      "deletions": 0,
      "changes": 89,
      "patch": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.action.admin.indices.sampling;\n+\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.core.TimeValue;\n+import org.elasticsearch.test.AbstractWireSerializingTestCase;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class GetAllSampleConfigurationActionResponseTests extends AbstractWireSerializingTestCase<\n+    GetAllSampleConfigurationAction.Response> {\n+\n+    @Override\n+    protected Writeable.Reader<GetAllSampleConfigurationAction.Response> instanceReader() {\n+        return GetAllSampleConfigurationAction.Response::new;\n+    }\n+\n+    @Override\n+    protected GetAllSampleConfigurationAction.Response createTestInstance() {\n+        int numIndices = randomIntBetween(0, 10);\n+        Map<String, SamplingConfiguration> indexToConfigMap = new HashMap<>();\n+        for (int i = 0; i < numIndices; i++) {\n+            String indexName = randomAlphaOfLengthBetween(1, 20);\n+            SamplingConfiguration config = createRandomSamplingConfiguration();\n+            indexToConfigMap.put(indexName, config);\n+        }\n+        return new GetAllSampleConfigurationAction.Response(indexToConfigMap);\n+    }\n+\n+    @Override\n+    protected GetAllSampleConfigurationAction.Response mutateInstance(GetAllSampleConfigurationAction.Response instance) {\n+        Map<String, SamplingConfiguration> originalMap = instance.getIndexToSamplingConfigMap();\n+        Map<String, SamplingConfiguration> mutatedMap = new HashMap<>(originalMap);\n+\n+        if (mutatedMap.isEmpty()) {\n+            // If empty, add a new entry\n+            mutatedMap.put(randomAlphaOfLengthBetween(1, 20), createRandomSamplingConfiguration());\n+        } else {\n+            // Otherwise, randomly mutate the map\n+            return switch (randomIntBetween(0, 2)) {\n+                case 0 -> {\n+                    // Add a new index\n+                    String newIndex = randomValueOtherThanMany(mutatedMap::containsKey, () -> randomAlphaOfLengthBetween(1, 20));\n+                    mutatedMap.put(newIndex, createRandomSamplingConfiguration());\n+                    yield new GetAllSampleConfigurationAction.Response(mutatedMap);\n+                }\n+                case 1 -> {\n+                    // Remove an index\n+                    String keyToRemove = randomFrom(mutatedMap.keySet());\n+                    mutatedMap.remove(keyToRemove);\n+                    yield new GetAllSampleConfigurationAction.Response(mutatedMap);\n+                }\n+                case 2 -> {\n+                    // Modify a configuration\n+                    String keyToModify = randomFrom(mutatedMap.keySet());\n+                    SamplingConfiguration newConfig = randomValueOtherThan(\n+                        mutatedMap.get(keyToModify),\n+                        this::createRandomSamplingConfiguration\n+                    );\n+                    mutatedMap.put(keyToModify, newConfig);\n+                    yield new GetAllSampleConfigurationAction.Response(mutatedMap);\n+                }\n+                default -> throw new IllegalStateException(\"Invalid mutation case\");\n+            };\n+        }\n+\n+        return new GetAllSampleConfigurationAction.Response(mutatedMap);\n+    }\n+\n+    private SamplingConfiguration createRandomSamplingConfiguration() {\n+        return new SamplingConfiguration(\n+            randomDoubleBetween(0.1, 1.0, true),\n+            randomBoolean() ? randomIntBetween(1, 1000) : null,\n+            randomBoolean() ? ByteSizeValue.ofMb(randomIntBetween(1, 100)) : null,\n+            randomBoolean() ? TimeValue.timeValueMinutes(randomIntBetween(1, 60)) : null,\n+            randomBoolean() ? \"ctx?.field == 'test'\" : null\n+        );\n+    }\n+}"
    },
    {
      "filename": "x-pack/plugin/security/qa/operator-privileges-tests/src/javaRestTest/java/org/elasticsearch/xpack/security/operator/Constants.java",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "patch": "@@ -663,6 +663,7 @@ public class Constants {\n         \"indices:admin/sample/config/update\",\n         \"indices:admin/sample/stats\",\n         \"indices:admin/sample/config/delete\",\n-        \"indices:monitor/sample/config/get\"\n+        \"indices:monitor/sample/config/get\",\n+        \"indices:monitor/sample/config/get_all\"\n     ).filter(Objects::nonNull).collect(Collectors.toUnmodifiableSet());\n }"
    }
  ],
  "diff": "diff --git a/rest-api-spec/src/main/resources/rest-api-spec/api/indices.get_all_sample_configuration.json b/rest-api-spec/src/main/resources/rest-api-spec/api/indices.get_all_sample_configuration.json\nnew file mode 100644\nindex 0000000000000..be2a582df0069\n--- /dev/null\n+++ b/rest-api-spec/src/main/resources/rest-api-spec/api/indices.get_all_sample_configuration.json\n@@ -0,0 +1,32 @@\n+{\n+  \"indices.get_all_sample_configuration\": {\n+    \"documentation\": {\n+      \"url\": \"https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-indices-get-all-sample-configuration\",\n+      \"description\": \"Get sampling configurations for all indices and data streams\"\n+    },\n+    \"stability\": \"experimental\",\n+    \"visibility\": \"public\",\n+    \"headers\": {\n+      \"accept\": [\n+        \"application/json\"\n+      ]\n+    },\n+    \"url\": {\n+      \"paths\": [\n+        {\n+          \"path\": \"/_sample/config\",\n+          \"methods\": [\n+            \"GET\"\n+          ]\n+        }\n+      ]\n+    },\n+    \"params\": {\n+      \"master_timeout\": {\n+        \"type\": \"time\",\n+        \"description\": \"Timeout for connection to master node\"\n+      }\n+    }\n+  }\n+}\n+\ndiff --git a/rest-api-spec/src/yamlRestTest/resources/rest-api-spec/test/indices.get_all_sample_configuration/10_basic.yml b/rest-api-spec/src/yamlRestTest/resources/rest-api-spec/test/indices.get_all_sample_configuration/10_basic.yml\nnew file mode 100644\nindex 0000000000000..7a74daa6a5177\n--- /dev/null\n+++ b/rest-api-spec/src/yamlRestTest/resources/rest-api-spec/test/indices.get_all_sample_configuration/10_basic.yml\n@@ -0,0 +1,254 @@\n+---\n+setup:\n+  - requires:\n+      cluster_features: [ \"random_sampling\" ]\n+      reason: requires feature 'random_sampling' to get random samples\n+\n+---\n+teardown:\n+  - do:\n+      indices.delete:\n+        index: \"*test*\"\n+        ignore_unavailable: true\n+        allow_no_indices: true\n+\n+---\n+\"Get all sampling configurations with no configurations\":\n+  - do:\n+      indices.create:\n+        index: test-no-config-index-1\n+\n+  - do:\n+      indices.create:\n+        index: test-no-config-index-2\n+\n+  - do:\n+      indices.get_all_sample_configuration: {}\n+\n+  # Should return an empty array\n+  - length: { $body: 0 }\n+\n+---\n+\"Get all sampling configurations with single configuration\":\n+  - do:\n+      indices.create:\n+        index: test-single-config-index\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-single-config-index\n+        body:\n+          rate: 0.5\n+          max_samples: 100\n+          max_size: \"10mb\"\n+          time_to_live: \"1h\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  - length: { $body: 1 }\n+  - match: { 0.index: \"test-single-config-index\" }\n+  - match: { 0.configuration.rate: 0.5 }\n+  - match: { 0.configuration.max_samples: 100 }\n+  - match: { 0.configuration.max_size: \"10mb\" }\n+  - match: { 0.configuration.time_to_live: \"1h\" }\n+\n+---\n+\"Get all sampling configurations with multiple configurations\":\n+  - do:\n+      indices.create:\n+        index: test-multi-config-index-1\n+\n+  - do:\n+      indices.create:\n+        index: test-multi-config-index-2\n+\n+  - do:\n+      indices.create:\n+        index: test-multi-config-index-3\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-multi-config-index-1\n+        body:\n+          rate: 0.3\n+          max_samples: 50\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-multi-config-index-2\n+        body:\n+          rate: 0.7\n+          max_samples: 200\n+          max_size: \"20mb\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-multi-config-index-3\n+        body:\n+          rate: 1.0\n+          if: \"ctx?.field == 'sample_me'\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  - length: { $body: 3 }\n+  # Note: Array order may vary, so we just verify all 3 configurations exist\n+  - is_true: 0.index\n+  - is_true: 0.configuration\n+  - is_true: 1.index\n+  - is_true: 1.configuration\n+  - is_true: 2.index\n+  - is_true: 2.configuration\n+\n+---\n+\"Get all sampling configurations with mixed indices\":\n+  - do:\n+      indices.create:\n+        index: test-mixed-configured-1\n+\n+  - do:\n+      indices.create:\n+        index: test-mixed-unconfigured\n+\n+  - do:\n+      indices.create:\n+        index: test-mixed-configured-2\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-mixed-configured-1\n+        body:\n+          rate: 0.4\n+          max_samples: 75\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-mixed-configured-2\n+        body:\n+          rate: 0.6\n+          time_to_live: \"2h\"\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  # Should only return configured indices (2 items)\n+  - length: { $body: 2 }\n+  - is_true: 0.index\n+  - is_true: 0.configuration\n+  - is_true: 1.index\n+  - is_true: 1.configuration\n+\n+---\n+\"Get all sampling configurations after update\":\n+  - do:\n+      indices.create:\n+        index: test-update-all-index\n+\n+  # Set initial configuration\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-update-all-index\n+        body:\n+          rate: 0.2\n+          max_samples: 30\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  - length: { $body: 1 }\n+  - match: { 0.index: \"test-update-all-index\" }\n+  - match: { 0.configuration.rate: 0.2 }\n+  - match: { 0.configuration.max_samples: 30 }\n+\n+  # Update configuration\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-update-all-index\n+        body:\n+          rate: 0.9\n+          max_samples: 150\n+          max_size: \"15mb\"\n+\n+  - match: { acknowledged: true }\n+\n+  # Verify updated configuration in get all\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  - length: { $body: 1 }\n+  - match: { 0.index: \"test-update-all-index\" }\n+  - match: { 0.configuration.rate: 0.9 }\n+  - match: { 0.configuration.max_samples: 150 }\n+  - match: { 0.configuration.max_size: \"15mb\" }\n+\n+---\n+\"Get all sampling configurations after deletion\":\n+  - do:\n+      indices.create:\n+        index: test-delete-all-index-1\n+\n+  - do:\n+      indices.create:\n+        index: test-delete-all-index-2\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-delete-all-index-1\n+        body:\n+          rate: 0.5\n+          max_samples: 100\n+\n+  - match: { acknowledged: true }\n+\n+  - do:\n+      indices.put_sample_configuration:\n+        index: test-delete-all-index-2\n+        body:\n+          rate: 0.8\n+          max_samples: 200\n+\n+  - match: { acknowledged: true }\n+\n+  # Verify both configurations exist\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  - length: { $body: 2 }\n+\n+  # Delete one configuration\n+  - do:\n+      indices.delete_sample_configuration:\n+        index: test-delete-all-index-1\n+\n+  - match: { acknowledged: true }\n+\n+  # Verify only one configuration remains\n+  - do:\n+      indices.get_all_sample_configuration:\n+        human: true\n+\n+  - length: { $body: 1 }\n+  - match: { 0.index: \"test-delete-all-index-2\" }\n+  - match: { 0.configuration.rate: 0.8 }\n+  - match: { 0.configuration.max_samples: 200 }\ndiff --git a/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationActionIT.java b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationActionIT.java\nnew file mode 100644\nindex 0000000000000..5cd3085e2eb60\n--- /dev/null\n+++ b/server/src/internalClusterTest/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationActionIT.java\n@@ -0,0 +1,253 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.action.admin.indices.sampling;\n+\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.core.TimeValue;\n+import org.elasticsearch.ingest.SamplingService;\n+import org.elasticsearch.test.ESIntegTestCase;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.anEmptyMap;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasEntry;\n+import static org.hamcrest.Matchers.hasKey;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+public class GetAllSampleConfigurationActionIT extends ESIntegTestCase {\n+\n+    public void testGetAllSampleConfigurationsWithNoConfigurations() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        // Create some indices without sampling configurations\n+        int numIndices = randomIntBetween(1, 3);\n+        for (int i = 0; i < numIndices; i++) {\n+            createIndex(randomIdentifier());\n+        }\n+\n+        // Get all configurations - should return empty map\n+        GetAllSampleConfigurationAction.Response response = getAllSamplingConfigurations();\n+\n+        assertThat(\"Response should not be null\", response, notNullValue());\n+        assertThat(\"Configuration map should be empty\", response.getIndexToSamplingConfigMap(), is(anEmptyMap()));\n+    }\n+\n+    public void testGetAllSampleConfigurationsWithSingleConfiguration() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        String indexName = randomIdentifier();\n+        createIndex(indexName);\n+\n+        // Create a sampling configuration\n+        SamplingConfiguration config = randomSamplingConfiguration();\n+        putSamplingConfiguration(indexName, config);\n+\n+        // Get all configurations\n+        GetAllSampleConfigurationAction.Response response = getAllSamplingConfigurations();\n+\n+        assertThat(\"Response should not be null\", response, notNullValue());\n+        Map<String, SamplingConfiguration> configMap = response.getIndexToSamplingConfigMap();\n+        assertThat(\"Configuration map should not be empty\", configMap, not(anEmptyMap()));\n+        assertThat(\"Configuration map should contain the index\", configMap, hasKey(indexName));\n+        assertThat(\"Configuration should match\", configMap.get(indexName), equalTo(config));\n+    }\n+\n+    public void testGetAllSampleConfigurationsWithMultipleConfigurations() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        // Create multiple indices with sampling configurations\n+        int numIndices = randomIntBetween(2, 5);\n+        Map<String, SamplingConfiguration> expectedConfigs = new HashMap<>();\n+\n+        for (int i = 0; i < numIndices; i++) {\n+            String indexName = randomIdentifier();\n+            createIndex(indexName);\n+            SamplingConfiguration config = randomSamplingConfiguration();\n+            putSamplingConfiguration(indexName, config);\n+            expectedConfigs.put(indexName, config);\n+        }\n+\n+        // Get all configurations\n+        GetAllSampleConfigurationAction.Response response = getAllSamplingConfigurations();\n+\n+        assertThat(\"Response should not be null\", response, notNullValue());\n+        Map<String, SamplingConfiguration> configMap = response.getIndexToSamplingConfigMap();\n+        assertThat(\"Configuration map should have correct size\", configMap.size(), equalTo(expectedConfigs.size()));\n+\n+        // Verify each configuration matches\n+        for (Map.Entry<String, SamplingConfiguration> entry : expectedConfigs.entrySet()) {\n+            assertThat(\"Configuration map should contain index: \" + entry.getKey(), configMap, hasEntry(entry.getKey(), entry.getValue()));\n+        }\n+    }\n+\n+    public void testGetAllSampleConfigurationsWithMixedIndices() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        // Create some indices with configurations\n+        int numConfiguredIndices = randomIntBetween(1, 3);\n+        Map<String, SamplingConfiguration> expectedConfigs = new HashMap<>();\n+\n+        for (int i = 0; i < numConfiguredIndices; i++) {\n+            String indexName = randomIdentifier();\n+            createIndex(indexName);\n+            SamplingConfiguration config = randomSamplingConfiguration();\n+            putSamplingConfiguration(indexName, config);\n+            expectedConfigs.put(indexName, config);\n+        }\n+\n+        // Create some indices without configurations\n+        int numUnconfiguredIndices = randomIntBetween(1, 3);\n+        for (int i = 0; i < numUnconfiguredIndices; i++) {\n+            createIndex(randomIdentifier());\n+        }\n+\n+        // Get all configurations - should only return configured indices\n+        GetAllSampleConfigurationAction.Response response = getAllSamplingConfigurations();\n+\n+        assertThat(\"Response should not be null\", response, notNullValue());\n+        Map<String, SamplingConfiguration> configMap = response.getIndexToSamplingConfigMap();\n+        assertThat(\"Configuration map should only contain configured indices\", configMap.size(), equalTo(expectedConfigs.size()));\n+\n+        // Verify each configuration matches\n+        for (Map.Entry<String, SamplingConfiguration> entry : expectedConfigs.entrySet()) {\n+            assertThat(\"Configuration map should contain index: \" + entry.getKey(), configMap, hasEntry(entry.getKey(), entry.getValue()));\n+        }\n+    }\n+\n+    public void testGetAllSampleConfigurationsAfterUpdate() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        String indexName = randomIdentifier();\n+        createIndex(indexName);\n+\n+        // Create initial configuration\n+        SamplingConfiguration initialConfig = randomSamplingConfiguration();\n+        putSamplingConfiguration(indexName, initialConfig);\n+\n+        // Get all configurations - should have initial config\n+        GetAllSampleConfigurationAction.Response response1 = getAllSamplingConfigurations();\n+        assertThat(\"Initial configuration should match\", response1.getIndexToSamplingConfigMap().get(indexName), equalTo(initialConfig));\n+\n+        // Update with new configuration\n+        SamplingConfiguration updatedConfig = randomSamplingConfiguration();\n+        putSamplingConfiguration(indexName, updatedConfig);\n+\n+        // Get all configurations - should have updated config\n+        GetAllSampleConfigurationAction.Response response2 = getAllSamplingConfigurations();\n+        assertThat(\"Updated configuration should match\", response2.getIndexToSamplingConfigMap().get(indexName), equalTo(updatedConfig));\n+    }\n+\n+    public void testGetAllSampleConfigurationsAfterDeletion() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        // Create two indices with configurations\n+        String index1 = randomIdentifier();\n+        String index2 = randomIdentifier();\n+        createIndex(index1);\n+        createIndex(index2);\n+\n+        SamplingConfiguration config1 = randomSamplingConfiguration();\n+        SamplingConfiguration config2 = randomSamplingConfiguration();\n+        putSamplingConfiguration(index1, config1);\n+        putSamplingConfiguration(index2, config2);\n+\n+        // Get all configurations - should have both\n+        GetAllSampleConfigurationAction.Response response1 = getAllSamplingConfigurations();\n+        assertThat(\"Should have two configurations\", response1.getIndexToSamplingConfigMap().size(), equalTo(2));\n+\n+        // Delete one configuration\n+        deleteSamplingConfiguration(index1);\n+\n+        // Get all configurations - should only have one\n+        GetAllSampleConfigurationAction.Response response2 = getAllSamplingConfigurations();\n+        Map<String, SamplingConfiguration> configMap = response2.getIndexToSamplingConfigMap();\n+        assertThat(\"Should have one configuration\", configMap.size(), equalTo(1));\n+        assertThat(\"Should not contain deleted index\", configMap, not(hasKey(index1)));\n+        assertThat(\"Should contain remaining index\", configMap, hasEntry(index2, config2));\n+    }\n+\n+    public void testGetAllSampleConfigurationsPersistsAcrossClusterStateUpdates() {\n+        assumeTrue(\"Requires the sampling feature flag to be enabled\", SamplingService.RANDOM_SAMPLING_FEATURE_FLAG);\n+\n+        // Create indices with sampling configurations\n+        int numIndices = randomIntBetween(2, 4);\n+        Map<String, SamplingConfiguration> expectedConfigs = new HashMap<>();\n+\n+        for (int i = 0; i < numIndices; i++) {\n+            String indexName = randomIdentifier();\n+            createIndex(indexName);\n+            SamplingConfiguration config = randomSamplingConfiguration();\n+            putSamplingConfiguration(indexName, config);\n+            expectedConfigs.put(indexName, config);\n+        }\n+\n+        // Get initial configurations\n+        GetAllSampleConfigurationAction.Response response1 = getAllSamplingConfigurations();\n+        assertThat(\"Initial configurations should match\", response1.getIndexToSamplingConfigMap(), equalTo(expectedConfigs));\n+\n+        // Trigger cluster state updates by creating additional indices\n+        int numDummyIndices = randomIntBetween(2, 5);\n+        for (int i = 0; i < numDummyIndices; i++) {\n+            createIndex(randomIdentifier());\n+        }\n+\n+        // Get configurations again after cluster state changes\n+        GetAllSampleConfigurationAction.Response response2 = getAllSamplingConfigurations();\n+        assertThat(\n+            \"Configurations should persist after cluster state changes\",\n+            response2.getIndexToSamplingConfigMap(),\n+            equalTo(expectedConfigs)\n+        );\n+    }\n+\n+    private SamplingConfiguration randomSamplingConfiguration() {\n+        return new SamplingConfiguration(\n+            randomDoubleBetween(0.1, 1.0, true),\n+            randomBoolean() ? randomIntBetween(1, SamplingConfiguration.MAX_SAMPLES_LIMIT) : null,\n+            randomBoolean() ? ByteSizeValue.ofGb(randomLongBetween(1, SamplingConfiguration.MAX_SIZE_LIMIT_GIGABYTES)) : null,\n+            randomBoolean() ? randomValidTimeValue() : null,\n+            randomBoolean() ? randomAlphaOfLengthBetween(5, 30) : null\n+        );\n+    }\n+\n+    private void putSamplingConfiguration(String indexName, SamplingConfiguration config) {\n+        PutSampleConfigurationAction.Request putRequest = new PutSampleConfigurationAction.Request(\n+            config,\n+            randomValidTimeValue(),\n+            randomValidTimeValue()\n+        );\n+        putRequest.indices(indexName);\n+        client().execute(PutSampleConfigurationAction.INSTANCE, putRequest).actionGet();\n+        ensureGreen();\n+    }\n+\n+    private void deleteSamplingConfiguration(String indexName) {\n+        DeleteSampleConfigurationAction.Request deleteRequest = new DeleteSampleConfigurationAction.Request(\n+            randomValidTimeValue(),\n+            randomValidTimeValue()\n+        );\n+        deleteRequest.indices(indexName);\n+        client().execute(DeleteSampleConfigurationAction.INSTANCE, deleteRequest).actionGet();\n+        ensureGreen();\n+    }\n+\n+    private GetAllSampleConfigurationAction.Response getAllSamplingConfigurations() {\n+        GetAllSampleConfigurationAction.Request request = new GetAllSampleConfigurationAction.Request(randomValidTimeValue());\n+        return client().execute(GetAllSampleConfigurationAction.INSTANCE, request).actionGet();\n+    }\n+\n+    private TimeValue randomValidTimeValue() {\n+        return TimeValue.timeValueDays(randomIntBetween(10, 20));\n+    }\n+}\ndiff --git a/server/src/main/java/org/elasticsearch/action/ActionModule.java b/server/src/main/java/org/elasticsearch/action/ActionModule.java\nindex dc26766c8f0ad..14d9afe7cf9fa 100644\n--- a/server/src/main/java/org/elasticsearch/action/ActionModule.java\n+++ b/server/src/main/java/org/elasticsearch/action/ActionModule.java\n@@ -128,16 +128,19 @@\n import org.elasticsearch.action.admin.indices.rollover.RolloverAction;\n import org.elasticsearch.action.admin.indices.rollover.TransportRolloverAction;\n import org.elasticsearch.action.admin.indices.sampling.DeleteSampleConfigurationAction;\n+import org.elasticsearch.action.admin.indices.sampling.GetAllSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.GetSampleAction;\n import org.elasticsearch.action.admin.indices.sampling.GetSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.GetSampleStatsAction;\n import org.elasticsearch.action.admin.indices.sampling.PutSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.RestDeleteSampleConfigurationAction;\n+import org.elasticsearch.action.admin.indices.sampling.RestGetAllSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.RestGetSampleAction;\n import org.elasticsearch.action.admin.indices.sampling.RestGetSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.RestGetSampleStatsAction;\n import org.elasticsearch.action.admin.indices.sampling.RestPutSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.TransportDeleteSampleConfigurationAction;\n+import org.elasticsearch.action.admin.indices.sampling.TransportGetAllSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.TransportGetSampleAction;\n import org.elasticsearch.action.admin.indices.sampling.TransportGetSampleConfigurationAction;\n import org.elasticsearch.action.admin.indices.sampling.TransportGetSampleStatsAction;\n@@ -835,6 +838,7 @@ public <Request extends ActionRequest, Response extends ActionResponse> void reg\n             actions.register(GetSampleStatsAction.INSTANCE, TransportGetSampleStatsAction.class);\n             actions.register(DeleteSampleConfigurationAction.INSTANCE, TransportDeleteSampleConfigurationAction.class);\n             actions.register(GetSampleConfigurationAction.INSTANCE, TransportGetSampleConfigurationAction.class);\n+            actions.register(GetAllSampleConfigurationAction.INSTANCE, TransportGetAllSampleConfigurationAction.class);\n         }\n \n         return unmodifiableMap(actions.getRegistry());\n@@ -1071,6 +1075,7 @@ public void initRestHandlers(Supplier<DiscoveryNodes> nodesInCluster, Predicate<\n             registerHandler.accept(new RestGetSampleStatsAction());\n             registerHandler.accept(new RestDeleteSampleConfigurationAction());\n             registerHandler.accept(new RestGetSampleConfigurationAction());\n+            registerHandler.accept(new RestGetAllSampleConfigurationAction());\n         }\n     }\n \ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationAction.java b/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationAction.java\nnew file mode 100644\nindex 0000000000000..0d3d641661342\n--- /dev/null\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationAction.java\n@@ -0,0 +1,206 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.action.admin.indices.sampling;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.action.ActionType;\n+import org.elasticsearch.action.IndicesRequest;\n+import org.elasticsearch.action.support.IndicesOptions;\n+import org.elasticsearch.action.support.local.LocalClusterStateRequest;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.xcontent.ChunkedToXContentObject;\n+import org.elasticsearch.core.Nullable;\n+import org.elasticsearch.core.TimeValue;\n+import org.elasticsearch.tasks.CancellableTask;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.xcontent.ToXContent;\n+import org.elasticsearch.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * Action type for retrieving all sampling configurations for cluster indices.\n+ * <p>\n+ * This action allows clients to get all sampling configurations\n+ * that have been set. This action\n+ * targets all indices and returns any existing configurations in a structured format.\n+ * </p>\n+ * The response format matches:\n+ *  <pre>\n+ * [\n+ * {\n+ *  \"index\": \"logs\",\n+ *  \"configuration\": {\n+ *      \"rate\": \".5\",\n+ *      \"if\": \"ctx?.network?.name == 'Guest'\"\n+ *  }\n+ * },\n+ * {\n+ *  \"index\": \"logsTwo\",\n+ *  \"configuration\": {\n+ *      \"rate\": \".75\"\n+ *  }\n+ * },\n+ * ]\n+ *  </pre>\n+ *\n+ * @see SamplingConfiguration\n+ * @see PutSampleConfigurationAction\n+ */\n+public class GetAllSampleConfigurationAction extends ActionType<GetAllSampleConfigurationAction.Response> {\n+\n+    /**\n+     * Singleton instance of the GetAllSampleConfigurationAction.\n+     * This provides a shared reference to the action type throughout the application.\n+     */\n+    public static final GetAllSampleConfigurationAction INSTANCE = new GetAllSampleConfigurationAction();\n+\n+    /**\n+     * The name identifier for this action type used in the transport layer.\n+     */\n+    public static final String NAME = \"indices:monitor/sample/config/get_all\";\n+\n+    private GetAllSampleConfigurationAction() {\n+        super(NAME);\n+    }\n+\n+    /**\n+     * Request object for getting all sampling configurations in a cluster.\n+     */\n+    public static class Request extends LocalClusterStateRequest implements IndicesRequest.Replaceable {\n+        /**\n+         * Constructs a new request.\n+         *\n+         * @param masterNodeTimeout the timeout for master node operations, or null for default\n+         */\n+        public Request(@Nullable TimeValue masterNodeTimeout) {\n+            super(masterNodeTimeout);\n+        }\n+\n+        /**\n+         * Constructs a new request by deserializing from a StreamInput.\n+         *\n+         * @param in the stream input to read from\n+         * @throws IOException if an I/O error occurs during deserialization\n+         */\n+        public Request(StreamInput in) throws IOException {\n+            super(in);\n+        }\n+\n+        @Override\n+        public String[] indices() {\n+            // This action reads from cluster state metadata (SamplingMetadata), not from indices directly.\n+            // The IndicesRequest implementation is required for security authorization checks.\n+            return new String[] { \"*\" };\n+        }\n+\n+        @Override\n+        public IndicesOptions indicesOptions() {\n+            return IndicesOptions.LENIENT_EXPAND_OPEN;\n+        }\n+\n+        @Override\n+        public boolean includeDataStreams() {\n+            return true;\n+        }\n+\n+        @Override\n+        public Request indices(String... indices) {\n+            // This is a get-all operation, so we don't support changing the indices\n+            return this;\n+        }\n+\n+        @Override\n+        public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {\n+            return new CancellableTask(id, type, action, \"executing \" + action, parentTaskId, headers);\n+        }\n+    }\n+\n+    /**\n+     * Response object containing an index to sampling configuration map.\n+     * <p>\n+     * This response contains a map from index names to their associated sampling configurations.\n+     * The response is designed to match the expected JSON format with an array containing\n+     * objects with \"index\" and \"configuration\" fields.\n+     * </p>\n+     */\n+    public static class Response extends ActionResponse implements ChunkedToXContentObject {\n+        private final Map<String, SamplingConfiguration> indexToSamplingConfigMap;\n+\n+        /**\n+         * Constructs a new Response with the given index to sampling configuration map.\n+         *\n+         * @param indexToSamplingConfigMap the index to sampling configuration map\n+         */\n+        public Response(Map<String, SamplingConfiguration> indexToSamplingConfigMap) {\n+            this.indexToSamplingConfigMap = indexToSamplingConfigMap;\n+        }\n+\n+        /**\n+         * Constructs a new Response by deserializing from a StreamInput.\n+         *\n+         * @param in the stream input to read from\n+         * @throws IOException if an I/O error occurs during deserialization\n+         */\n+        public Response(StreamInput in) throws IOException {\n+            this.indexToSamplingConfigMap = in.readMap(StreamInput::readString, SamplingConfiguration::new);\n+        }\n+\n+        /**\n+         * Gets the index to sampling configuration map.\n+         *\n+         * @return the index to sampling configuration map, or an empty map if none exist\n+         */\n+        public Map<String, SamplingConfiguration> getIndexToSamplingConfigMap() {\n+            return indexToSamplingConfigMap == null ? Map.of() : indexToSamplingConfigMap;\n+        }\n+\n+        @Override\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeMap(indexToSamplingConfigMap, StreamOutput::writeString, (o, v) -> v.writeTo(o));\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Response that = (Response) o;\n+            return indexToSamplingConfigMap.equals(that.indexToSamplingConfigMap);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(indexToSamplingConfigMap);\n+        }\n+\n+        @Override\n+        public Iterator<? extends ToXContent> toXContentChunked(ToXContent.Params params) {\n+            return Collections.singletonList((ToXContent) (builder, p) -> toXContent(builder, params)).iterator();\n+        }\n+\n+        private XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {\n+            builder.startArray();\n+            for (Map.Entry<String, SamplingConfiguration> entry : indexToSamplingConfigMap.entrySet()) {\n+                builder.startObject();\n+                builder.field(\"index\", entry.getKey());\n+                builder.field(\"configuration\", entry.getValue());\n+                builder.endObject();\n+            }\n+            builder.endArray();\n+            return builder;\n+        }\n+    }\n+}\ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/RestGetAllSampleConfigurationAction.java b/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/RestGetAllSampleConfigurationAction.java\nnew file mode 100644\nindex 0000000000000..b9b6519e18a3f\n--- /dev/null\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/RestGetAllSampleConfigurationAction.java\n@@ -0,0 +1,76 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.action.admin.indices.sampling;\n+\n+import org.elasticsearch.client.internal.node.NodeClient;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.Scope;\n+import org.elasticsearch.rest.ServerlessScope;\n+import org.elasticsearch.rest.action.RestCancellableNodeClient;\n+import org.elasticsearch.rest.action.RestRefCountedChunkedToXContentListener;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+import static org.elasticsearch.rest.RestUtils.getMasterNodeTimeout;\n+\n+/**\n+ * REST action for getting all sampling configurations for indices.\n+ * <p>\n+ * Handles GET requests to /_sample/config endpoint and delegates\n+ * to the GetAllSampleConfigurationAction transport action.\n+ * </p>\n+ *\n+ * <p>Example usage:</p>\n+ * GET /_sample/config\n+ * returns\n+ * [\n+ * {\n+ *  \"index\": \"logs\",\n+ *  \"configuration\": {\n+ *      \"rate\": \".5\",\n+ *      \"if\": \"ctx?.network?.name == 'Guest'\"\n+ *  }\n+ * },\n+ * {\n+ *  \"index\": \"logsTwo\",\n+ *  \"configuration\": {\n+ *      \"rate\": \".75\"\n+ *  }\n+ * },\n+ * ]\n+ */\n+@ServerlessScope(Scope.INTERNAL)\n+public class RestGetAllSampleConfigurationAction extends BaseRestHandler {\n+\n+    @Override\n+    public List<Route> routes() {\n+        return List.of(new Route(GET, \"/_sample/config\"));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"get_all_sample_configuration_action\";\n+    }\n+\n+    @Override\n+    public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {\n+        GetAllSampleConfigurationAction.Request getRequest = new GetAllSampleConfigurationAction.Request(getMasterNodeTimeout(request));\n+\n+        return channel -> new RestCancellableNodeClient(client, request.getHttpChannel()).execute(\n+            GetAllSampleConfigurationAction.INSTANCE,\n+            getRequest,\n+            new RestRefCountedChunkedToXContentListener<>(channel)\n+        );\n+    }\n+\n+}\ndiff --git a/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/TransportGetAllSampleConfigurationAction.java b/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/TransportGetAllSampleConfigurationAction.java\nnew file mode 100644\nindex 0000000000000..088ac19dc76c3\n--- /dev/null\n+++ b/server/src/main/java/org/elasticsearch/action/admin/indices/sampling/TransportGetAllSampleConfigurationAction.java\n@@ -0,0 +1,119 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.action.admin.indices.sampling;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.local.TransportLocalProjectMetadataAction;\n+import org.elasticsearch.cluster.ProjectState;\n+import org.elasticsearch.cluster.block.ClusterBlockException;\n+import org.elasticsearch.cluster.block.ClusterBlockLevel;\n+import org.elasticsearch.cluster.metadata.ProjectMetadata;\n+import org.elasticsearch.cluster.project.ProjectResolver;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.util.concurrent.EsExecutors;\n+import org.elasticsearch.injection.guice.Inject;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+\n+import java.util.Map;\n+\n+/**\n+ * Transport action for retrieving all existing sampling configurations.\n+ * <p>\n+ * This action retrieves the sampling configurations from the project metadata's custom sampling metadata.\n+ * </p>\n+ */\n+public class TransportGetAllSampleConfigurationAction extends TransportLocalProjectMetadataAction<\n+    GetAllSampleConfigurationAction.Request,\n+    GetAllSampleConfigurationAction.Response> {\n+\n+    private static final Logger logger = LogManager.getLogger(TransportGetAllSampleConfigurationAction.class);\n+\n+    /**\n+     * Constructs a new TransportGetAllSampleConfigurationAction.\n+     *\n+     * @param actionFilters the action filters to apply\n+     * @param transportService the transport service\n+     * @param clusterService the cluster service\n+     * @param projectResolver the project resolver\n+     */\n+    @Inject\n+    public TransportGetAllSampleConfigurationAction(\n+        ActionFilters actionFilters,\n+        TransportService transportService,\n+        ClusterService clusterService,\n+        ProjectResolver projectResolver\n+    ) {\n+        super(\n+            GetAllSampleConfigurationAction.NAME,\n+            actionFilters,\n+            transportService.getTaskManager(),\n+            clusterService,\n+            EsExecutors.DIRECT_EXECUTOR_SERVICE,\n+            projectResolver\n+        );\n+    }\n+\n+    /**\n+     * Executes the get all sampling configuration operation against the local cluster state.\n+     * <p>\n+     * Retrieves all sampling configuration from the project metadata.\n+     * Returns empty map if no sampling metadata exists or if no configurations are set.\n+     * </p>\n+     *\n+     * @param task the task executing this operation\n+     * @param request the get sampling configuration request containing the index name\n+     * @param state the current project state\n+     * @param listener the listener to notify with the response or failure\n+     */\n+    @Override\n+    protected void localClusterStateOperation(\n+        Task task,\n+        GetAllSampleConfigurationAction.Request request,\n+        ProjectState state,\n+        ActionListener<GetAllSampleConfigurationAction.Response> listener\n+    ) {\n+        ProjectMetadata projectMetadata = state.metadata();\n+\n+        if (projectMetadata == null) {\n+            logger.debug(\"No project metadata found\");\n+            listener.onResponse(new GetAllSampleConfigurationAction.Response(Map.of()));\n+            return;\n+        }\n+\n+        SamplingMetadata samplingMetadata = projectMetadata.custom(SamplingMetadata.TYPE);\n+        if (samplingMetadata == null) {\n+            logger.debug(\"No sampling metadata found\");\n+            listener.onResponse(new GetAllSampleConfigurationAction.Response(Map.of()));\n+            return;\n+        }\n+\n+        Map<String, SamplingConfiguration> indexToSampleConfigMap = samplingMetadata.getIndexToSamplingConfigMap();\n+        logger.debug(\"Retrieved sampling configurations\");\n+        listener.onResponse(\n+            new GetAllSampleConfigurationAction.Response(indexToSampleConfigMap == null ? Map.of() : indexToSampleConfigMap)\n+        );\n+    }\n+\n+    /**\n+     * Checks for cluster blocks that would prevent this operation from executing.\n+     *\n+     * @param request the get sampling configuration request\n+     * @param state the current project state\n+     * @return a cluster block exception if the operation is blocked, null otherwise\n+     */\n+    @Override\n+    protected ClusterBlockException checkBlock(GetAllSampleConfigurationAction.Request request, ProjectState state) {\n+        return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ);\n+    }\n+}\ndiff --git a/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationActionRequestTests.java b/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationActionRequestTests.java\nnew file mode 100644\nindex 0000000000000..0df0d8a8c482a\n--- /dev/null\n+++ b/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationActionRequestTests.java\n@@ -0,0 +1,58 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.action.admin.indices.sampling;\n+\n+import org.elasticsearch.core.TimeValue;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.tasks.TaskId;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+public class GetAllSampleConfigurationActionRequestTests extends ESTestCase {\n+\n+    protected GetAllSampleConfigurationAction.Request createTestInstance() {\n+        return new GetAllSampleConfigurationAction.Request(randomBoundedTimeValue());\n+    }\n+\n+    public void testGettersAndSetters() {\n+        TimeValue timeout = randomBoundedTimeValue();\n+        GetAllSampleConfigurationAction.Request request = new GetAllSampleConfigurationAction.Request(timeout);\n+\n+        assertThat(request.masterTimeout(), equalTo(timeout));\n+    }\n+\n+    public void testCreateTaskReturnsCancellableTask() {\n+        GetAllSampleConfigurationAction.Request request = createTestInstance();\n+\n+        long taskId = randomLong();\n+        String type = randomAlphaOfLength(10);\n+        String action = GetAllSampleConfigurationAction.NAME;\n+        TaskId parentTaskId = new TaskId(randomAlphaOfLength(10), randomLong());\n+        Map<String, String> headers = Map.of(\"header1\", \"value1\");\n+\n+        Task task = request.createTask(taskId, type, action, parentTaskId, headers);\n+\n+        assertThat(task, notNullValue());\n+        assertThat(task, instanceOf(org.elasticsearch.tasks.CancellableTask.class));\n+        assertThat(task.getId(), equalTo(taskId));\n+        assertThat(task.getType(), equalTo(type));\n+        assertThat(task.getAction(), equalTo(action));\n+        assertThat(task.getParentTaskId(), equalTo(parentTaskId));\n+    }\n+\n+    private TimeValue randomBoundedTimeValue() {\n+        return TimeValue.timeValueSeconds(randomIntBetween(5, 10));\n+    }\n+}\ndiff --git a/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationActionResponseTests.java b/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationActionResponseTests.java\nnew file mode 100644\nindex 0000000000000..ce93824c6b6c7\n--- /dev/null\n+++ b/server/src/test/java/org/elasticsearch/action/admin/indices/sampling/GetAllSampleConfigurationActionResponseTests.java\n@@ -0,0 +1,89 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+\n+package org.elasticsearch.action.admin.indices.sampling;\n+\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.unit.ByteSizeValue;\n+import org.elasticsearch.core.TimeValue;\n+import org.elasticsearch.test.AbstractWireSerializingTestCase;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class GetAllSampleConfigurationActionResponseTests extends AbstractWireSerializingTestCase<\n+    GetAllSampleConfigurationAction.Response> {\n+\n+    @Override\n+    protected Writeable.Reader<GetAllSampleConfigurationAction.Response> instanceReader() {\n+        return GetAllSampleConfigurationAction.Response::new;\n+    }\n+\n+    @Override\n+    protected GetAllSampleConfigurationAction.Response createTestInstance() {\n+        int numIndices = randomIntBetween(0, 10);\n+        Map<String, SamplingConfiguration> indexToConfigMap = new HashMap<>();\n+        for (int i = 0; i < numIndices; i++) {\n+            String indexName = randomAlphaOfLengthBetween(1, 20);\n+            SamplingConfiguration config = createRandomSamplingConfiguration();\n+            indexToConfigMap.put(indexName, config);\n+        }\n+        return new GetAllSampleConfigurationAction.Response(indexToConfigMap);\n+    }\n+\n+    @Override\n+    protected GetAllSampleConfigurationAction.Response mutateInstance(GetAllSampleConfigurationAction.Response instance) {\n+        Map<String, SamplingConfiguration> originalMap = instance.getIndexToSamplingConfigMap();\n+        Map<String, SamplingConfiguration> mutatedMap = new HashMap<>(originalMap);\n+\n+        if (mutatedMap.isEmpty()) {\n+            // If empty, add a new entry\n+            mutatedMap.put(randomAlphaOfLengthBetween(1, 20), createRandomSamplingConfiguration());\n+        } else {\n+            // Otherwise, randomly mutate the map\n+            return switch (randomIntBetween(0, 2)) {\n+                case 0 -> {\n+                    // Add a new index\n+                    String newIndex = randomValueOtherThanMany(mutatedMap::containsKey, () -> randomAlphaOfLengthBetween(1, 20));\n+                    mutatedMap.put(newIndex, createRandomSamplingConfiguration());\n+                    yield new GetAllSampleConfigurationAction.Response(mutatedMap);\n+                }\n+                case 1 -> {\n+                    // Remove an index\n+                    String keyToRemove = randomFrom(mutatedMap.keySet());\n+                    mutatedMap.remove(keyToRemove);\n+                    yield new GetAllSampleConfigurationAction.Response(mutatedMap);\n+                }\n+                case 2 -> {\n+                    // Modify a configuration\n+                    String keyToModify = randomFrom(mutatedMap.keySet());\n+                    SamplingConfiguration newConfig = randomValueOtherThan(\n+                        mutatedMap.get(keyToModify),\n+                        this::createRandomSamplingConfiguration\n+                    );\n+                    mutatedMap.put(keyToModify, newConfig);\n+                    yield new GetAllSampleConfigurationAction.Response(mutatedMap);\n+                }\n+                default -> throw new IllegalStateException(\"Invalid mutation case\");\n+            };\n+        }\n+\n+        return new GetAllSampleConfigurationAction.Response(mutatedMap);\n+    }\n+\n+    private SamplingConfiguration createRandomSamplingConfiguration() {\n+        return new SamplingConfiguration(\n+            randomDoubleBetween(0.1, 1.0, true),\n+            randomBoolean() ? randomIntBetween(1, 1000) : null,\n+            randomBoolean() ? ByteSizeValue.ofMb(randomIntBetween(1, 100)) : null,\n+            randomBoolean() ? TimeValue.timeValueMinutes(randomIntBetween(1, 60)) : null,\n+            randomBoolean() ? \"ctx?.field == 'test'\" : null\n+        );\n+    }\n+}\ndiff --git a/x-pack/plugin/security/qa/operator-privileges-tests/src/javaRestTest/java/org/elasticsearch/xpack/security/operator/Constants.java b/x-pack/plugin/security/qa/operator-privileges-tests/src/javaRestTest/java/org/elasticsearch/xpack/security/operator/Constants.java\nindex 477212d87a4e7..89a47a9e070d0 100644\n--- a/x-pack/plugin/security/qa/operator-privileges-tests/src/javaRestTest/java/org/elasticsearch/xpack/security/operator/Constants.java\n+++ b/x-pack/plugin/security/qa/operator-privileges-tests/src/javaRestTest/java/org/elasticsearch/xpack/security/operator/Constants.java\n@@ -663,6 +663,7 @@ public class Constants {\n         \"indices:admin/sample/config/update\",\n         \"indices:admin/sample/stats\",\n         \"indices:admin/sample/config/delete\",\n-        \"indices:monitor/sample/config/get\"\n+        \"indices:monitor/sample/config/get\",\n+        \"indices:monitor/sample/config/get_all\"\n     ).filter(Objects::nonNull).collect(Collectors.toUnmodifiableSet());\n }\n",
  "additions": 1094,
  "deletions": 1,
  "changed_files": 10,
  "url": "https://github.com/elastic/elasticsearch/pull/137065",
  "mined_at": "2025-10-25T13:12:43.691829"
}