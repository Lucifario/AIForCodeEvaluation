{
  "id": 1235,
  "repository": "apache/commons-lang",
  "title": "Reimplement RandomStringUtils on top of SecureRandom#getInstanceStrong()",
  "body": "The previous implementation used  ThreadLocalRandom#current()",
  "state": "closed",
  "merged": true,
  "merged_at": "2024-07-06T13:25:20+00:00",
  "created_at": "2024-06-13T21:06:39+00:00",
  "updated_at": "2025-08-14T14:39:37+00:00",
  "author": "garydgregory",
  "reviewers": [],
  "base_sha": "e1c374bf505646178e29c361a6889ff69e83be6e",
  "head_sha": "9b938913065ddaa5d36db3e8bcb3187bebcec843",
  "review_comments": [],
  "pr_comments": [
    {
      "user": "codecov-commenter",
      "body": "## [Codecov](https://app.codecov.io/gh/apache/commons-lang/pull/1235?dropdown=coverage&src=pr&el=h1&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=apache) Report\nAttention: Patch coverage is `60.00000%` with `2 lines` in your changes missing coverage. Please review.\n> Project coverage is 92.52%. Comparing base [(`f962e7b`)](https://app.codecov.io/gh/apache/commons-lang/commit/f962e7b65457640a15db9970487cc858176bd511?dropdown=coverage&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=apache) to head [(`23cb811`)](https://app.codecov.io/gh/apache/commons-lang/commit/23cb81109d589b6e415c161be6e37023ab29109d?dropdown=coverage&el=desc&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=apache).\n> Report is 248 commits behind head on master.\n\n| [Files](https://app.codecov.io/gh/apache/commons-lang/pull/1235?dropdown=coverage&src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=apache) | Patch % | Lines |\n|---|---|---|\n| [...va/org/apache/commons/lang3/RandomStringUtils.java](https://app.codecov.io/gh/apache/commons-lang/pull/1235?src=pr&el=tree&filepath=src%2Fmain%2Fjava%2Forg%2Fapache%2Fcommons%2Flang3%2FRandomStringUtils.java&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=apache#diff-c3JjL21haW4vamF2YS9vcmcvYXBhY2hlL2NvbW1vbnMvbGFuZzMvUmFuZG9tU3RyaW5nVXRpbHMuamF2YQ==) | 60.00% | [2 Missing :warning: ](https://app.codecov.io/gh/apache/commons-lang/pull/1235?src=pr&el=tree&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=apache) |\n\n<details><summary>Additional details and impacted files</summary>\n\n\n```diff\n@@             Coverage Diff              @@\n##             master    #1235      +/-   ##\n============================================\n+ Coverage     92.07%   92.52%   +0.44%     \n- Complexity     7587     7757     +170     \n============================================\n  Files           200      200              \n  Lines         15844    15894      +50     \n  Branches       2890     2819      -71     \n============================================\n+ Hits          14589    14706     +117     \n+ Misses          682      650      -32     \n+ Partials        573      538      -35     \n```\n\n\n\n</details>\n\n[:umbrella: View full report in Codecov by Sentry](https://app.codecov.io/gh/apache/commons-lang/pull/1235?dropdown=coverage&src=pr&el=continue&utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=apache).   \n:loudspeaker: Have feedback on the report? [Share it here](https://about.codecov.io/codecov-pr-comment-feedback/?utm_medium=referral&utm_source=github&utm_content=comment&utm_campaign=pr+comments&utm_term=apache).\n",
      "created_at": "2024-06-13T21:09:57+00:00"
    },
    {
      "user": "psteitz",
      "body": "SecureRandoms take a lot longer to initialize, which will slow down the loading of this class, which may impact performance for users who don't care about cryptographic security of the generated text.  Where does the crypto security requirement come from?  We already direct users elsewhere for more sophisticated use cases.  In [math] now I guess in rng, we used to provide separate impls so users who just wanted random text did not have to pay for the overhead of SecureRandom.",
      "created_at": "2024-06-13T21:40:39+00:00"
    },
    {
      "user": "hyandell",
      "body": "This came from a conversation Gary and I were having on Slack (which I need to take to dev@). \r\n\r\nResearching with a colleague in my dayjob (@fabrice102), the number of use cases of RandomStringUtils that are ignoring the documentation of the class appears much higher than the number of use cases that are my original 2000s intention of do testing. Really feels like we need to take the road less desirable here.\r\n\r\nHaving an alternative for the apparant minority who want speed over security feels good too. Something that doesn't kick off the SecureRandom initializing.",
      "created_at": "2024-06-13T21:55:02+00:00"
    },
    {
      "user": "psteitz",
      "body": "I would expect the number of users who want / need cryptographic security to be tiny.  So why make that the default behavior?  I have not benchmarked recent JDKs, but it used to be a *lot* slower.  I remember tomcat ripping out some SecureRandom uses for performance reasons.  And it also kind of gives me the willies that the instance is initialized (the most expensive part) in a static initializer.",
      "created_at": "2024-06-14T02:39:10+00:00"
    },
    {
      "user": "garydgregory",
      "body": "Hi @psteitz \r\n\r\nNote that is it only initialized on demand.\r\n\r\nCC: @hyandell ",
      "created_at": "2024-06-14T02:57:16+00:00"
    },
    {
      "user": "psteitz",
      "body": "How is that, @garydgregory?  Doesn't getInstanceStrong initialize the instance?  I thought it blocked waiting for /dev/random.  Blocking in class initialization could be problematic.  Or am I misreading the code or missing something?",
      "created_at": "2024-06-14T03:39:03+00:00"
    },
    {
      "user": "aherbert",
      "body": "I believe @psteitz is correct that the initialisation of SecureRandom can be slow and potentially blocking. The way it is done in Commons RNG and the JDK source code for SplittableRandom (when it is configured for secure seeding via system properties) is to use the default constructor:\r\n```java\r\nSecureRandom rng = new SecureRandom();\r\n```\r\nSee [The Right Way to Use SecureRandom](https://tersesystems.com/blog/2015/12/17/the-right-way-to-use-securerandom/).\r\n\r\nA less intrusive modification to this PR would be a similar mechanism to the JDK seeding RNG routine where the source of seeding randomness is chosen based on system properties. But you still have to decide whether the default is secure or non-secure.\r\n\r\nNote: A StringSampler implementation was discussed under RNG 54. There is a table showing some relative performance of Lang and Text here: [RNG-54 comment 2](https://issues.apache.org/jira/browse/RNG-54?focusedCommentId=16582795&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-16582795). Currently String sampling is not implemented in RNG although the ticket remains open.\r\n\r\nFor fast random strings it is optimal to use a power of 2 alphabet. But this limits use cases to just outputting random junk text. I presume the case for SecureRandom is for password/salt generation. In this context a power of 2 alphabet is restrictive and a method using a uniform [0, n) choice for each character of alphabet size n is requied. There are samplers in RNG that will outperform use of `nextInt(n)` by precomputing the modulus `Integer.MAX_VALUE % n` which is used to avoid statistical bias from a random integer. The performance gain is negligible on a slow base RNG such as SecureRandom. From memory, we did testing in RNG using the JDK 9 SecureRandom (which added more cryptographic methods) and it was 2 orders of magnitude slower than a typical pseudo-RNG. This was done in a GSoC project and was not merged to the master branch. Repeating benchmarks using some of the framework in the RNG JMH project would be trivial.\r\n",
      "created_at": "2024-06-14T06:47:09+00:00"
    },
    {
      "user": "garydgregory",
      "body": "> How is that, @garydgregory? Doesn't getInstanceStrong initialize the instance? I thought it blocked waiting for /dev/random. Blocking in class initialization could be problematic. Or am I misreading the code or missing something?\r\n\r\nHello @psteitz \r\nThe SecureRandom is only initialized if the thread local's initial value supplier lamba is called which only happens when the thread local's get() method is called which only happens when one of the random() methods in this class is called.",
      "created_at": "2024-06-14T10:41:41+00:00"
    },
    {
      "user": "aherbert",
      "body": "Using ThreadLocal still has a potential blocking call when a random method is invoked.",
      "created_at": "2024-06-14T10:44:53+00:00"
    },
    {
      "user": "garydgregory",
      "body": "> Using ThreadLocal still has a potential blocking call when a random method is invoked.\r\n\r\nHi @aherbert,\r\nWhere do you see ThreadLocal documented as blocking on a get() call?",
      "created_at": "2024-06-14T11:26:53+00:00"
    },
    {
      "user": "aherbert",
      "body": "Sorry, clarification: It is the _first call_ to ThreadLocal.get() that may block on the instantiation of the SecureRandom (depending on how it is created). After that each thread has a SecureRandom and will be fine.",
      "created_at": "2024-06-14T11:42:49+00:00"
    },
    {
      "user": "fabrice102",
      "body": "I tried to research the risk of blocking when instantiating SecureRandom.\r\n\r\nTL;DR: On modern OSes and common platforms, blocking is unlikely, unless the program is called very early in the boot process or (maybe but unlikely) just after boot finishes. Even then, blocking would only happen the first time a method from  RandomStringUtils  is called. Other calls to methods of RandomStringUtils in the same thread or other threads would not block. In all cases, if RandomStringUtils is not used, this PR has no performance impact on any system.\r\n\r\nOn Unix, the [default SUN cryptographic providers](https://github.com/openjdk/jdk/blob/8464ce6db5cbd5d50ac2a2bcba905b7255f510f5/src/java.base/unix/classes/sun/security/provider/NativePRNG.java) SUN/NativePRNG (obtained when using new SecureRandom() to instantiate SecureRandom) and SUN/NativePRNGBlocking (obtained when using SecureRandom.getInstanceStrong()) appear to be using /dev/urandom and /dev/random respectively.\r\n\r\nOn [modern Linux kernels](https://lwn.net/Articles/808575/) ([5.6](https://lwn.net/Articles/811230/) or newer, 5.6 has been released in 2020), the only time /dev/random would block is if the system never got enough entropy to initialize the randomness pool. In particular, only the first thread making calls to RandomStringUtils may block. Furthermore, on most commonly used systems, the [CPU Jitter source entropy](https://lwn.net/Articles/884875/) would initialize /dev/random less than 1s after boot. So on commonly-used modern Linux systems, there should be virtually no performance impact at initialization of SecureRandom.\r\n\r\nSince at least 2016 (most likely even before that), FreeBSD and macOS [seem to](https://github.com/briansmith/ring/issues/316#issuecomment-257479426) have identical /dev/urandom and /dev/random . In addition, /dev/random blocks only on initialization like on modern linux kernels. But I could not find a first-party source confirming this.\r\n\r\nAt least since [OpenBSD 6.3](https://man.openbsd.org/OpenBSD-6.3/random.4) (released in 2018), /dev/urandom and /dev/random are the same and never block.\r\n\r\nI did not check what happens on Windows in details. I could not find significant complaints about Windows SecureRandom blocking. It is possible it never blocks.\r\n",
      "created_at": "2024-06-14T16:56:07+00:00"
    },
    {
      "user": "psteitz",
      "body": "We used to have a mailing list where we discussed changes like this.  Sorry for the snarky comment, but this is a good discussion that will be hard to follow for anyone researching what led to this change.  With no threading, we can't really separate the issues either, which are 0) init performance cost and potential to block waiting for entropy (great analysis @fabrice102 , could be no longer an issue for most users) 1) gen time performance cost 2) whether it might be better to create SecureRandomStringUtils or otherwise support fast generation without cyrptographic security.",
      "created_at": "2024-06-14T17:35:26+00:00"
    },
    {
      "user": "fabrice102",
      "body": "Thanks @psteitz ! I am not sure where is the best place to post the following comment. If you think itâ€™s more appropriate to post it to the mailing list, let me know and I will post it there.\r\n\r\nTo address the point \"1) gen time performance cost\", Iâ€™ve written some optimizations on top of the current PR: https://github.com/garydgregory/commons-lang/pull/2\r\n\r\nBenchmarking using JMH with JDK 8 on an AWS c6a.xlarge instance with cryptographic providers SUN/NativePRNG, SUN/SHA1PRNG, [ACCP](https://github.com/corretto/amazon-corretto-crypto-provider) 1.6, and [ACCP](https://github.com/corretto/amazon-corretto-crypto-provider) 2.3, we have the following results. Compared to the current state (with the default java.util.Random/ThreadLocalRandom number generator), when any of the above SecureRandom is used with the optimized code, the time to generate random alphabetic, alphanumeric, and numeric strings of at least 16 characters is less than three times slower (and sometimes even 5x faster). For 4-character strings, we observe a slow-down of at most 8x.\r\n\r\nIf the optimized RandomStringUtils is called concurrently in multiple threads, the SUN/NativePrng SecureRandom implementation (the default on Linux) may be slower as calls are serialized (due to access to/dev/random. This seems an unlikely scenario in practice. In addition, switching to ACCP 2 for SecureRandom would fix the performance issue in that case.",
      "created_at": "2024-06-14T23:13:32+00:00"
    },
    {
      "user": "psteitz",
      "body": "On Fri, Jun 14, 2024 at 4:13â€¯PM Fabrice Benhamouda ***@***.***>\r\nwrote:\r\n\r\n> Thanks @psteitz <https://github.com/psteitz> ! I am not sure where is the\r\n> best place to post the following comment. If you think itâ€™s more\r\n> appropriate to post it to the mailing list, let me know and I will post it\r\n> there.\r\n>\r\n> To address the point \"1) gen time performance cost\", Iâ€™ve written some\r\n> optimizations on top of the current PR: garydgregory#2\r\n> <https://github.com/garydgregory/commons-lang/pull/2>\r\n>\r\n> Benchmarking using JMH with JDK 8 on an AWS c6a.xlarge instance with\r\n> cryptographic providers SUN/NativePRNG, SUN/SHA1PRNG, ACCP\r\n> <https://github.com/corretto/amazon-corretto-crypto-provider> 1.6, and\r\n> ACCP <https://github.com/corretto/amazon-corretto-crypto-provider> 2.3,\r\n> we have the following results. Compared to the current state (with the\r\n> default java.util.Random/ThreadLocalRandom number generator), when any of\r\n> the above SecureRandom is used with the optimized code, the time to\r\n> generate random alphabetic, alphanumeric, and numeric strings of at least\r\n> 16 characters is less than three times slower (and sometimes even 5x\r\n> faster). For 4-character strings, we observe a slow-down of at most 8x.\r\n>\r\n> If the optimized RandomStringUtils is called concurrently in multiple\r\n> threads, the SUN/NativePrng SecureRandom implementation (the default on\r\n> Linux) may be slower as calls are serialized (due to access to/dev/random.\r\n>\r\nThis is the use case I would be most concerned with.  Many web applications\r\nuse this class in multi-threaded app server settings.  I would not use the\r\nclass in web apps after this change for that reason.  If we do make the\r\nchange, we should make it clear in the class javadoc that it is using\r\nSecureRandom and prone to occasional stalls.\r\n\r\nSince there was no discussion about why this change is being made, I will\r\nask again why it is being proposed.  The only rationale that I can see is\r\nthat somehow some users are using the class to generate things that should\r\nbe cryptographically secure, like passwords or hash salt, so to protect\r\nthese users, we make all other users take a potential performance hit.\r\nMuch better, IMO, would be to make the recommended improvements in\r\nperformance to the vanilla Random-based impl and add a new class or somehow\r\nshoehorn in a secure impl for users that want / need that.\r\n\r\nPhil\r\n\r\nThis seems an unlikely scenario in practice. In addition, switching to ACCP\r\n2 for SecureRandom would fix the performance issue in that case.\r\n\r\n> â€”\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/apache/commons-lang/pull/1235#issuecomment-2168869983>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AALJJ2W2FHEF7BLURVCM3HDZHN2LFAVCNFSM6AAAAABJJE3MF6VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDCNRYHA3DSOJYGM>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n",
      "created_at": "2024-06-15T19:38:52+00:00"
    },
    {
      "user": "garydgregory",
      "body": "Hi Phil,\r\n\r\nPlease see the Commons security list. Are you not subscribed? You should be\r\nsince you are on the PMC. I did not want to copy paste the info Hen Y\r\nbrought up with me separately just in case.\r\n\r\nGary\r\n\r\nOn Sat, Jun 15, 2024, 3:39â€¯PM Phil Steitz ***@***.***> wrote:\r\n\r\n> On Fri, Jun 14, 2024 at 4:13â€¯PM Fabrice Benhamouda ***@***.***>\r\n> wrote:\r\n>\r\n> > Thanks @psteitz <https://github.com/psteitz> ! I am not sure where is\r\n> the\r\n> > best place to post the following comment. If you think itâ€™s more\r\n> > appropriate to post it to the mailing list, let me know and I will post\r\n> it\r\n> > there.\r\n> >\r\n> > To address the point \"1) gen time performance cost\", Iâ€™ve written some\r\n> > optimizations on top of the current PR: garydgregory#2\r\n> > <https://github.com/garydgregory/commons-lang/pull/2>\r\n> >\r\n> > Benchmarking using JMH with JDK 8 on an AWS c6a.xlarge instance with\r\n> > cryptographic providers SUN/NativePRNG, SUN/SHA1PRNG, ACCP\r\n> > <https://github.com/corretto/amazon-corretto-crypto-provider> 1.6, and\r\n> > ACCP <https://github.com/corretto/amazon-corretto-crypto-provider> 2.3,\r\n> > we have the following results. Compared to the current state (with the\r\n> > default java.util.Random/ThreadLocalRandom number generator), when any\r\n> of\r\n> > the above SecureRandom is used with the optimized code, the time to\r\n> > generate random alphabetic, alphanumeric, and numeric strings of at\r\n> least\r\n> > 16 characters is less than three times slower (and sometimes even 5x\r\n> > faster). For 4-character strings, we observe a slow-down of at most 8x.\r\n> >\r\n> > If the optimized RandomStringUtils is called concurrently in multiple\r\n> > threads, the SUN/NativePrng SecureRandom implementation (the default on\r\n> > Linux) may be slower as calls are serialized (due to access\r\n> to/dev/random.\r\n> >\r\n> This is the use case I would be most concerned with. Many web applications\r\n> use this class in multi-threaded app server settings. I would not use the\r\n> class in web apps after this change for that reason. If we do make the\r\n> change, we should make it clear in the class javadoc that it is using\r\n> SecureRandom and prone to occasional stalls.\r\n>\r\n> Since there was no discussion about why this change is being made, I will\r\n> ask again why it is being proposed. The only rationale that I can see is\r\n> that somehow some users are using the class to generate things that should\r\n> be cryptographically secure, like passwords or hash salt, so to protect\r\n> these users, we make all other users take a potential performance hit.\r\n> Much better, IMO, would be to make the recommended improvements in\r\n> performance to the vanilla Random-based impl and add a new class or\r\n> somehow\r\n> shoehorn in a secure impl for users that want / need that.\r\n>\r\n> Phil\r\n>\r\n> This seems an unlikely scenario in practice. In addition, switching to\r\n> ACCP\r\n> 2 for SecureRandom would fix the performance issue in that case.\r\n>\r\n> > â€”\r\n> > Reply to this email directly, view it on GitHub\r\n> > <\r\n> https://github.com/apache/commons-lang/pull/1235#issuecomment-2168869983>,\r\n>\r\n> > or unsubscribe\r\n> > <\r\n> https://github.com/notifications/unsubscribe-auth/AALJJ2W2FHEF7BLURVCM3HDZHN2LFAVCNFSM6AAAAABJJE3MF6VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDCNRYHA3DSOJYGM>\r\n>\r\n> > .\r\n> > You are receiving this because you were mentioned.Message ID:\r\n> > ***@***.***>\r\n> >\r\n>\r\n> â€”\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/apache/commons-lang/pull/1235#issuecomment-2170593780>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAJB6N3KLMPFPDVOYS4VLFTZHSJ6FAVCNFSM6AAAAABJJE3MF6VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDCNZQGU4TGNZYGA>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n",
      "created_at": "2024-06-15T19:56:23+00:00"
    },
    {
      "user": "fabrice102",
      "body": "> > If the optimized RandomStringUtils is called concurrently in multiple threads, the SUN/NativePrng SecureRandom implementation (the default on Linux) may be slower as calls are serialized (due to access to/dev/random.\r\n>\r\n> This is the use case I would be most concerned with. Many web applications use this class in multi-threaded app server settings.\r\n\r\nTo clarify, the case where there may be a slow-down is the following: \r\n\r\nMultiple threads concurrently, at the same time, call `RandomStringUtils.random`.\r\n\r\nGeneration of a random 16-alphanumerical-character string takes less than 1us on the test machine (c6a.xlarge). (And with a non-optimized implementation using the default `SUN.NativePRNG` provider, this takes less than 3.5us.) For the vast majority of web applications, I believe this should amount to a negligible percentage of the total CPU time used to answer the query. This in turn would mean that there should be no noticeable slow-down due to concurrency in this context: it would be very rare that `RandomStringUtils.random` is called concurrently at the same time by two threads answering two different web queries.",
      "created_at": "2024-06-15T22:07:18+00:00"
    },
    {
      "user": "nvsnvikram",
      "body": "Thanks @psteitz for raising issues with this PR. We are using RandomStringUtils to generate a string for a non secure use. We just need unique strings and this change made our code to block /dev/random where there was not enough entropy. Some of our code took forever to run after this change and we had to force downgrade to previous version. I would hope that there would be an implementation that uses a semi-secure or non-secure random to generate a string as that would be our requirement.",
      "created_at": "2024-07-19T23:30:47+00:00"
    },
    {
      "user": "garydgregory",
      "body": "@nvsnvikram \r\nYou can use the lower level API that takes a Random argument that pass it an implementation that's as weak/insecure as you wish ðŸ˜‰",
      "created_at": "2024-07-19T23:42:51+00:00"
    },
    {
      "user": "nvsnvikram",
      "body": "thanks. we will have to change our code to use that but should be fine.",
      "created_at": "2024-07-20T00:28:38+00:00"
    },
    {
      "user": "garydgregory",
      "body": "I'll experiment with a more friendly API on my end...",
      "created_at": "2024-07-20T00:44:13+00:00"
    },
    {
      "user": "garydgregory",
      "body": "Here is a solution to provide support for both secure and insecure modes : https://github.com/apache/commons-lang/pull/1250\r\n",
      "created_at": "2024-07-20T13:00:19+00:00"
    },
    {
      "user": "knoobie",
      "body": "Just fyi: I've seen our builds taking 4-16 hours after this change instead of typical 30min in a Jenkins dedicated Docker env where we heavily use RandomStringUtils to generate arbitrary 100-200 character strings in tests. ",
      "created_at": "2024-07-31T05:45:35+00:00"
    },
    {
      "user": "garydgregory",
      "body": "I will push out a new release candidate today hopefully where you can call .insecure() to get the old faster and insecure implementation. Right now you can test with 3.16.0-SNAPSHOT.",
      "created_at": "2024-07-31T10:23:34+00:00"
    },
    {
      "user": "HelloDhero",
      "body": "SecureRandom.getInstanceStrong() in RandomUtils while use NativePRNGBlocking default \r\nit cause blocked  ",
      "created_at": "2024-08-13T04:25:45+00:00"
    },
    {
      "user": "HelloDhero",
      "body": "I don't think you to change the implementation of Random. If this package is used by other components, it will cause a chain reaction",
      "created_at": "2024-08-13T12:47:47+00:00"
    },
    {
      "user": "HelloDhero",
      "body": "> The previous implementation used ThreadLocalRandom#current()\r\n\r\nOpen a discussion about this issue?",
      "created_at": "2024-08-19T01:09:55+00:00"
    },
    {
      "user": "HelloDhero",
      "body": "![WechatIMG81](https://github.com/user-attachments/assets/53cf025f-4e0a-4b17-9492-e939f24cab2c)\r\n",
      "created_at": "2024-08-19T01:30:34+00:00"
    },
    {
      "user": "HelloDhero",
      "body": "@garydgregory ",
      "created_at": "2024-08-19T01:31:29+00:00"
    },
    {
      "user": "garydgregory",
      "body": "This is currently being discussed on an internal (private) mailing list.\r\n\r\nGary\r\n\r\nOn Sun, Aug 18, 2024 at 9:31â€¯PM HelloDhero ***@***.***> wrote:\r\n\r\n> @garydgregory <https://github.com/garydgregory>\r\n>\r\n> â€”\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/apache/commons-lang/pull/1235#issuecomment-2295505112>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAJB6NYBTE37KJ4CCGSZ623ZSFDIRAVCNFSM6AAAAABJJE3MF6VHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEOJVGUYDKMJRGI>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n",
      "created_at": "2024-08-19T02:17:55+00:00"
    },
    {
      "user": "fabrice102",
      "body": "@knoobie and @HelloDHero, you reported important slow-down following the changes in this PR. What OS/kernel are your systems using? In particular, do they use pre-5.6 Linux kernel?\r\n\r\nIf this is the case, the issue is most likely that `/dev/random` (used by the default `SecureRandom.getInstanceStrong()`) can block at any time on pre-5.6 Linux kernel (see https://github.com/apache/commons-lang/pull/1235#issuecomment-2168423879). \r\n\r\nIn that case, switching to `new SecureRandom()` instead of `SecureRandom.getInstanceStrong()` would most likely solve the issue. Doing so may slightly decrease security in Linux, if the code is executed just after boot and before enough entropy is gathered. But this is a very unlikely case and I personally think it is a good trade-off.\r\n\r\nA temporary workaround may be to add `SUN/NativePRNG` to the list of strong randomness sources, by changing the [Security property securerandom.strongAlgorithms.](https://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html#getInstanceStrong--).This is assuming none of your code relies on the fact that `SecureRandom.getInstanceStrong()` uses `/dev/random`.",
      "created_at": "2024-08-19T20:36:16+00:00"
    },
    {
      "user": "HelloDhero",
      "body": "Modifying the securerandom.strongAlgorithms configuration in a production environment is not a good practice, and we should avoid this situation at the code level",
      "created_at": "2024-08-20T01:34:14+00:00"
    },
    {
      "user": "knoobie",
      "body": "@fabrice102 CentOS7 / Kernel 3.10.0-1160.114.2.el7.x86_64 - so your comment about \"pre-5.6\" Linux Kernel might be correct. Even tho they are probably still widely spread with RHEL 7 and 8 also using pre-5.6 Kernels.",
      "created_at": "2024-08-20T06:37:21+00:00"
    },
    {
      "user": "garydgregory",
      "body": "FYI: You can experiment now with git master and [3.17.0-SNAPSHOT builds](https://repository.apache.org/content/repositories/snapshots/) to get:\r\n\r\nRandom[String]Utils.secure() now uses SecureRandom() instead of SecureRandom.getInstanceStrong()\r\n\r\n- RandomStringUtils.secure() now uses SecureRandom() instead of SecureRandom.getInstanceStrong()\r\n- RandomUtils.secure() now uses SecureRandom() instead of SecureRandom.getInstanceStrong()\r\n- Add RandomStringUtils.secureStrong()\r\n- Add RandomUtils.secureStrong()\r\n",
      "created_at": "2024-08-20T12:09:52+00:00"
    },
    {
      "user": "alex91ar",
      "body": "Well if anyone s feeling generous: bc1qrjv23a92uyqrptlkc9mc77w83344k4v37pem7f",
      "created_at": "2025-08-14T14:39:37+00:00"
    }
  ],
  "files_changed": [
    {
      "filename": "src/main/java/org/apache/commons/lang3/CachedRandomBits.java",
      "status": "added",
      "additions": 101,
      "deletions": 0,
      "changes": 101,
      "patch": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.util.Objects;\n+import java.util.Random;\n+\n+/**\n+ * Generates random integers of specific bit length.\n+ *\n+ * <p>\n+ * It is more efficient than calling Random.nextInt(1 << nbBits). It uses a cache of cacheSize random bytes that it replenishes when it gets empty. This is\n+ * especially beneficial for SecureRandom Drbg implementations, which incur a constant cost at each randomness generation.\n+ * </p>\n+ *\n+ * <p>\n+ * Used internally by RandomStringUtils.\n+ * </p>\n+ *\n+ * <p>\n+ * #NotThreadSafe#\n+ * </p>\n+ */\n+final class CachedRandomBits {\n+\n+    private final Random random;\n+\n+    private final byte[] cache;\n+\n+    /**\n+     * Index of the next bit in the cache to be used.\n+     *\n+     * <ul>\n+     * <li>bitIndex=0 means the cache is fully random and none of the bits have been used yet.</li>\n+     * <li>bitIndex=1 means that only the LSB of cache[0] has been used and all other bits can be used.</li>\n+     * <li>bitIndex=8 means that only the 8 bits of cache[0] has been used.</li>\n+     * </ul>\n+     */\n+    private int bitIndex;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param cacheSize number of bytes cached (only affects performance)\n+     * @param random random source\n+     */\n+    CachedRandomBits(final int cacheSize, final Random random) {\n+        if (cacheSize <= 0) {\n+            throw new IllegalArgumentException(\"cacheSize must be positive\");\n+        }\n+        this.cache = new byte[cacheSize];\n+        this.random = Objects.requireNonNull(random, \"random\");\n+        this.random.nextBytes(this.cache);\n+        this.bitIndex = 0;\n+    }\n+\n+    /**\n+     * Generates a random integer with the specified number of bits.\n+     *\n+     * @param bits number of bits to generate, MUST be between 1 and 32\n+     * @return random integer with {@code bits} bits\n+     */\n+    public int nextBits(final int bits) {\n+        if (bits > 32 || bits <= 0) {\n+            throw new IllegalArgumentException(\"number of bits must be between 1 and 32\");\n+        }\n+        int result = 0;\n+        int generatedBits = 0; // number of generated bits up to now\n+        while (generatedBits < bits) {\n+            if (bitIndex >> 3 >= cache.length) {\n+                // we exhausted the number of bits in the cache\n+                // this should only happen if the bitIndex is exactly matching the cache length\n+                assert bitIndex == cache.length * 8;\n+                random.nextBytes(cache);\n+                bitIndex = 0;\n+            }\n+            // generatedBitsInIteration is the number of bits that we will generate\n+            // in this iteration of the while loop\n+            int generatedBitsInIteration = Math.min(8 - (bitIndex & 0x7), bits - generatedBits);\n+            result = result << generatedBitsInIteration;\n+            result |= (cache[bitIndex >> 3] >> (bitIndex & 0x7)) & ((1 << generatedBitsInIteration) - 1);\n+            generatedBits += generatedBitsInIteration;\n+            bitIndex += generatedBitsInIteration;\n+        }\n+        return result;\n+    }\n+}"
    },
    {
      "filename": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java",
      "status": "modified",
      "additions": 99,
      "deletions": 28,
      "changes": 127,
      "patch": "@@ -16,44 +16,64 @@\n  */\n package org.apache.commons.lang3;\n \n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n import java.util.Random;\n import java.util.concurrent.ThreadLocalRandom;\n \n+import org.apache.commons.lang3.exception.UncheckedException;\n+\n /**\n  * Generates random {@link String}s.\n+ * <p>\n+ * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n+ * </p>\n+ * <p>\n+ * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n+ * </p>\n+ * <p>\n+ * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n+ * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n+ * instead.\n+ * </p>\n+ * <p>\n+ * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n+ * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n+ * </p>\n+ * <p>\n+ * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n+ * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n+ * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n+ * surrogate.\n+ * </p>\n+ * <p>\n+ * #ThreadSafe#\n+ * </p>\n  *\n- * <p><b>Caveat: Instances of {@link Random}, upon which the implementation of this\n- * class relies, are not cryptographically secure.</b></p>\n- *\n- * <p>RandomStringUtils is intended for simple use cases. For more advanced\n- * use cases consider using Apache Commons Text's\n- * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n- * RandomStringGenerator</a> instead.</p>\n- *\n- * <p>The Apache Commons project provides\n- * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation, that may be\n- * a better choice for applications with more stringent requirements\n- * (performance and/or correctness).</p>\n- *\n- * <p>Note that <em>private high surrogate</em> characters are ignored.\n- * These are Unicode characters that fall between the values 56192 (db80)\n- * and 56319 (dbff) as we don't know how to handle them.\n- * High and low surrogates are correctly dealt with - that is if a\n- * high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f)\n- * then it is followed by a low surrogate. If a low surrogate is chosen,\n- * 56320 (dc00) to 57343 (dfff) then it is placed after a randomly\n- * chosen high surrogate.</p>\n- *\n- * <p>#ThreadSafe#</p>\n  * @since 1.0\n  */\n public class RandomStringUtils {\n \n-    private static ThreadLocalRandom random() {\n-        return ThreadLocalRandom.current();\n+    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SecureRandom.getInstanceStrong();\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new UncheckedException(e);\n+        }\n+    });\n+\n+    private static SecureRandom random() {\n+        return RANDOM.get();\n     }\n \n-    // Random\n+    private static final char[] ALPHANUMERICAL_CHARS = {\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n+    };\n+\n     /**\n      * Creates a random string whose length is the number of characters\n      * specified.\n@@ -214,6 +234,42 @@ public static String random(int count, int start, int end, final boolean letters\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n         }\n \n+        if (end > Character.MAX_CODE_POINT) {\n+            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n+            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n+            end = Character.MAX_CODE_POINT;\n+        }\n+\n+        // Optimize generation of full alphanumerical characters\n+        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n+        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n+        // Instead we can pick directly from the right set of 62 characters, which requires\n+        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n+        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n+            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n+        }\n+\n+        // Optimize start and end when filtering by letters and/or numbers:\n+        // The range provided may be too large since we filter anyway afterward.\n+        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n+        // since it is possible the range start/end excludes some of the letters/numbers,\n+        // e.g., it is possible that start already is '1' when numbers = true, and start\n+        // needs to stay equal to '1' in that case.\n+        if (chars == null) {\n+            if (letters && numbers) {\n+                start = Math.max('0', start);\n+                end = Math.min('z' + 1, end);\n+            } else if (numbers) {\n+                // just numbers, no letters\n+                start = Math.max('0', start);\n+                end = Math.min('9' + 1, end);\n+            } else if (letters) {\n+                // just letters, no numbers\n+                start = Math.max('A', start);\n+                end = Math.min('z' + 1, end);\n+            }\n+        }\n+\n         final int zeroDigitAscii = 48;\n         final int firstLetterAscii = 65;\n \n@@ -225,11 +281,26 @@ public static String random(int count, int start, int end, final boolean letters\n \n         final StringBuilder builder = new StringBuilder(count);\n         final int gap = end - start;\n+        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n+        // The size of the cache we use is an heuristic:\n+        // about twice the number of bytes required if no rejection\n+        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n+        // of randomness as well as the probability of rejection. It is however not easy to know\n+        // those values programmatically for the general case.\n+        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n \n         while (count-- != 0) {\n+            // Generate a random value between start (included) and end (excluded)\n+            final int randomValue = arb.nextBits(gapBits) + start;\n+            // Rejection sampling if value too large\n+            if (randomValue >= end) {\n+                count++;\n+                continue;\n+            }\n+\n             final int codePoint;\n             if (chars == null) {\n-                codePoint = random.nextInt(gap) + start;\n+                codePoint = randomValue;\n \n                 switch (Character.getType(codePoint)) {\n                 case Character.UNASSIGNED:\n@@ -240,7 +311,7 @@ public static String random(int count, int start, int end, final boolean letters\n                 }\n \n             } else {\n-                codePoint = chars[random.nextInt(gap) + start];\n+                codePoint = chars[randomValue];\n             }\n \n             final int numberOfChars = Character.charCount(codePoint);"
    },
    {
      "filename": "src/test/java/org/apache/commons/lang3/CachedRandomBitsTest.java",
      "status": "added",
      "additions": 96,
      "deletions": 0,
      "changes": 96,
      "patch": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.Objects;\n+import java.util.Random;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+/**\n+ * Tests {@link CachedRandomBits}.\n+ */\n+public class CachedRandomBitsTest {\n+\n+    /** MockRandom mocks a Random class nextBytes to use a specific list of outputs */\n+    private static class MockRandom extends Random {\n+\n+        private static final long serialVersionUID = 1L;\n+        private final byte[] outputs;\n+        private int index;\n+\n+        MockRandom(final byte[] outputs) {\n+            super();\n+            this.outputs = outputs.clone();\n+            this.index = 0;\n+        }\n+\n+        @Override\n+        public void nextBytes(byte[] bytes) {\n+            Objects.requireNonNull(bytes, \"bytes\");\n+            if (index + bytes.length > outputs.length) {\n+                throw new IllegalStateException(\"Not enough outputs given in MockRandom\");\n+            }\n+            System.arraycopy(outputs, index, bytes, 0, bytes.length);\n+            index += bytes.length;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 32})\n+    public void testNext(int cacheSize) {\n+        MockRandom random = new MockRandom(new byte[]{\n+                0x11, 0x12, 0x13, 0x25,\n+                (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0xff,\n+                0x55, 0x44, 0x12, 0x34,\n+                0x56, 0x78, 0x00, 0x00,\n+                0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x00, 0x00, 0x00,\n+        });\n+\n+        CachedRandomBits arb = new CachedRandomBits(cacheSize, random);\n+\n+        assertThrows(IllegalArgumentException.class, () -> arb.nextBits(0));\n+        assertThrows(IllegalArgumentException.class, () -> arb.nextBits(33));\n+\n+        assertEquals(0x11, arb.nextBits(8));\n+        assertEquals(0x12, arb.nextBits(8));\n+        assertEquals(0x1325, arb.nextBits(16));\n+\n+        assertEquals(0xabcdefff, arb.nextBits(32));\n+\n+        assertEquals(0x5, arb.nextBits(4));\n+        assertEquals(0x1, arb.nextBits(1));\n+        assertEquals(0x0, arb.nextBits(1));\n+        assertEquals(0x1, arb.nextBits(2));\n+\n+        assertEquals(0x4, arb.nextBits(6));\n+\n+        assertEquals(0x40000000 | (0x12345600 >> 2) | 0x38, arb.nextBits(32));\n+\n+        assertEquals(1, arb.nextBits(1));\n+        assertEquals(0, arb.nextBits(1));\n+        assertEquals(0, arb.nextBits(9));\n+        assertEquals(0, arb.nextBits(31));\n+    }\n+}"
    },
    {
      "filename": "src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java",
      "status": "modified",
      "additions": 25,
      "deletions": 0,
      "changes": 25,
      "patch": "@@ -27,6 +27,7 @@\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n import static org.junit.jupiter.api.Assertions.fail;\n \n import java.lang.reflect.Constructor;\n@@ -518,4 +519,28 @@ public void testRandomStringUtilsHomog() {\n         // critical value: from scipy.stats import chi2; chi2(2).isf(1e-5)\n         assertThat(\"test homogeneity -- will fail about 1 in 100,000 times\", chiSquare(expected, counts), lessThan(23.025850929940457d));\n     }\n+\n+    /**\n+     * Test {@code RandomStringUtils.random} works appropriately when chars specified.\n+     */\n+    @Test\n+    void testRandomWithChars() {\n+        final char[] digitChars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n+\n+        String r1, r2, r3;\n+\n+        r1 = RandomStringUtils.random(50, 0, 0, true, true, digitChars);\n+        assertEquals(50, r1.length(), \"randomNumeric(50)\");\n+        for (int i = 0; i < r1.length(); i++) {\n+            assertTrue(\n+                    Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i)),\n+                    \"r1 contains numeric\");\n+        }\n+        r2 = RandomStringUtils.randomNumeric(50);\n+        assertNotEquals(r1, r2);\n+\n+        r3 = RandomStringUtils.random(50, 0, 0, true, true, digitChars);\n+        assertNotEquals(r1, r3);\n+        assertNotEquals(r2, r3);\n+    }\n }"
    }
  ],
  "diff": "diff --git a/src/main/java/org/apache/commons/lang3/CachedRandomBits.java b/src/main/java/org/apache/commons/lang3/CachedRandomBits.java\nnew file mode 100644\nindex 00000000000..78d0b458c8a\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/CachedRandomBits.java\n@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.util.Objects;\n+import java.util.Random;\n+\n+/**\n+ * Generates random integers of specific bit length.\n+ *\n+ * <p>\n+ * It is more efficient than calling Random.nextInt(1 << nbBits). It uses a cache of cacheSize random bytes that it replenishes when it gets empty. This is\n+ * especially beneficial for SecureRandom Drbg implementations, which incur a constant cost at each randomness generation.\n+ * </p>\n+ *\n+ * <p>\n+ * Used internally by RandomStringUtils.\n+ * </p>\n+ *\n+ * <p>\n+ * #NotThreadSafe#\n+ * </p>\n+ */\n+final class CachedRandomBits {\n+\n+    private final Random random;\n+\n+    private final byte[] cache;\n+\n+    /**\n+     * Index of the next bit in the cache to be used.\n+     *\n+     * <ul>\n+     * <li>bitIndex=0 means the cache is fully random and none of the bits have been used yet.</li>\n+     * <li>bitIndex=1 means that only the LSB of cache[0] has been used and all other bits can be used.</li>\n+     * <li>bitIndex=8 means that only the 8 bits of cache[0] has been used.</li>\n+     * </ul>\n+     */\n+    private int bitIndex;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param cacheSize number of bytes cached (only affects performance)\n+     * @param random random source\n+     */\n+    CachedRandomBits(final int cacheSize, final Random random) {\n+        if (cacheSize <= 0) {\n+            throw new IllegalArgumentException(\"cacheSize must be positive\");\n+        }\n+        this.cache = new byte[cacheSize];\n+        this.random = Objects.requireNonNull(random, \"random\");\n+        this.random.nextBytes(this.cache);\n+        this.bitIndex = 0;\n+    }\n+\n+    /**\n+     * Generates a random integer with the specified number of bits.\n+     *\n+     * @param bits number of bits to generate, MUST be between 1 and 32\n+     * @return random integer with {@code bits} bits\n+     */\n+    public int nextBits(final int bits) {\n+        if (bits > 32 || bits <= 0) {\n+            throw new IllegalArgumentException(\"number of bits must be between 1 and 32\");\n+        }\n+        int result = 0;\n+        int generatedBits = 0; // number of generated bits up to now\n+        while (generatedBits < bits) {\n+            if (bitIndex >> 3 >= cache.length) {\n+                // we exhausted the number of bits in the cache\n+                // this should only happen if the bitIndex is exactly matching the cache length\n+                assert bitIndex == cache.length * 8;\n+                random.nextBytes(cache);\n+                bitIndex = 0;\n+            }\n+            // generatedBitsInIteration is the number of bits that we will generate\n+            // in this iteration of the while loop\n+            int generatedBitsInIteration = Math.min(8 - (bitIndex & 0x7), bits - generatedBits);\n+            result = result << generatedBitsInIteration;\n+            result |= (cache[bitIndex >> 3] >> (bitIndex & 0x7)) & ((1 << generatedBitsInIteration) - 1);\n+            generatedBits += generatedBitsInIteration;\n+            bitIndex += generatedBitsInIteration;\n+        }\n+        return result;\n+    }\n+}\ndiff --git a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\nindex 9a05d74e598..419e5f0c552 100644\n--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n@@ -16,44 +16,64 @@\n  */\n package org.apache.commons.lang3;\n \n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n import java.util.Random;\n import java.util.concurrent.ThreadLocalRandom;\n \n+import org.apache.commons.lang3.exception.UncheckedException;\n+\n /**\n  * Generates random {@link String}s.\n+ * <p>\n+ * Starting in version 3.15.0, this classes uses {@link SecureRandom#getInstanceStrong()}.\n+ * </p>\n+ * <p>\n+ * Before version 3.15.0, this classes used {@link ThreadLocalRandom#current()}, which was NOT cryptographically secure.\n+ * </p>\n+ * <p>\n+ * RandomStringUtils is intended for simple use cases. For more advanced use cases consider using Apache Commons Text's\n+ * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\"> RandomStringGenerator</a>\n+ * instead.\n+ * </p>\n+ * <p>\n+ * The Apache Commons project provides <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation,\n+ * that may be a better choice for applications with more stringent requirements (performance and/or correctness).\n+ * </p>\n+ * <p>\n+ * Note that <em>private high surrogate</em> characters are ignored. These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as\n+ * we don't know how to handle them. High and low surrogates are correctly dealt with - that is if a high surrogate is randomly chosen, 55296 (d800) to 56191\n+ * (db7f) then it is followed by a low surrogate. If a low surrogate is chosen, 56320 (dc00) to 57343 (dfff) then it is placed after a randomly chosen high\n+ * surrogate.\n+ * </p>\n+ * <p>\n+ * #ThreadSafe#\n+ * </p>\n  *\n- * <p><b>Caveat: Instances of {@link Random}, upon which the implementation of this\n- * class relies, are not cryptographically secure.</b></p>\n- *\n- * <p>RandomStringUtils is intended for simple use cases. For more advanced\n- * use cases consider using Apache Commons Text's\n- * <a href=\"https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/RandomStringGenerator.html\">\n- * RandomStringGenerator</a> instead.</p>\n- *\n- * <p>The Apache Commons project provides\n- * <a href=\"https://commons.apache.org/proper/commons-rng/\">Commons RNG</a> dedicated to pseudo-random number generation, that may be\n- * a better choice for applications with more stringent requirements\n- * (performance and/or correctness).</p>\n- *\n- * <p>Note that <em>private high surrogate</em> characters are ignored.\n- * These are Unicode characters that fall between the values 56192 (db80)\n- * and 56319 (dbff) as we don't know how to handle them.\n- * High and low surrogates are correctly dealt with - that is if a\n- * high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f)\n- * then it is followed by a low surrogate. If a low surrogate is chosen,\n- * 56320 (dc00) to 57343 (dfff) then it is placed after a randomly\n- * chosen high surrogate.</p>\n- *\n- * <p>#ThreadSafe#</p>\n  * @since 1.0\n  */\n public class RandomStringUtils {\n \n-    private static ThreadLocalRandom random() {\n-        return ThreadLocalRandom.current();\n+    private static final ThreadLocal<SecureRandom> RANDOM = ThreadLocal.withInitial(() -> {\n+        try {\n+            return SecureRandom.getInstanceStrong();\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new UncheckedException(e);\n+        }\n+    });\n+\n+    private static SecureRandom random() {\n+        return RANDOM.get();\n     }\n \n-    // Random\n+    private static final char[] ALPHANUMERICAL_CHARS = {\n+            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n+    };\n+\n     /**\n      * Creates a random string whose length is the number of characters\n      * specified.\n@@ -214,6 +234,42 @@ public static String random(int count, int start, int end, final boolean letters\n             throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n         }\n \n+        if (end > Character.MAX_CODE_POINT) {\n+            // Technically, it should be `Character.MAX_CODE_POINT+1` as `end` is excluded\n+            // But the character `Character.MAX_CODE_POINT` is private use, so it would anyway be excluded\n+            end = Character.MAX_CODE_POINT;\n+        }\n+\n+        // Optimize generation of full alphanumerical characters\n+        // Normally, we would need to pick a 7-bit integer, since gap = 'z' - '0' + 1 = 75 > 64\n+        // In turn, this would make us reject the sampling with probability 1 - 62 / 2^7 > 1 / 2\n+        // Instead we can pick directly from the right set of 62 characters, which requires\n+        // picking a 6-bit integer and only rejecting with probability 2 / 64 = 1 / 32\n+        if (chars == null && letters && numbers && start <= '0' && end >= 'z' + 1) {\n+            return random(count, 0, 0, false, false, ALPHANUMERICAL_CHARS, random);\n+        }\n+\n+        // Optimize start and end when filtering by letters and/or numbers:\n+        // The range provided may be too large since we filter anyway afterward.\n+        // Note the use of Math.min/max (as opposed to setting start to '0' for example),\n+        // since it is possible the range start/end excludes some of the letters/numbers,\n+        // e.g., it is possible that start already is '1' when numbers = true, and start\n+        // needs to stay equal to '1' in that case.\n+        if (chars == null) {\n+            if (letters && numbers) {\n+                start = Math.max('0', start);\n+                end = Math.min('z' + 1, end);\n+            } else if (numbers) {\n+                // just numbers, no letters\n+                start = Math.max('0', start);\n+                end = Math.min('9' + 1, end);\n+            } else if (letters) {\n+                // just letters, no numbers\n+                start = Math.max('A', start);\n+                end = Math.min('z' + 1, end);\n+            }\n+        }\n+\n         final int zeroDigitAscii = 48;\n         final int firstLetterAscii = 65;\n \n@@ -225,11 +281,26 @@ public static String random(int count, int start, int end, final boolean letters\n \n         final StringBuilder builder = new StringBuilder(count);\n         final int gap = end - start;\n+        final int gapBits = Integer.SIZE - Integer.numberOfLeadingZeros(gap);\n+        // The size of the cache we use is an heuristic:\n+        // about twice the number of bytes required if no rejection\n+        // Ideally the cache size depends on multiple factor, including the cost of generating x bytes\n+        // of randomness as well as the probability of rejection. It is however not easy to know\n+        // those values programmatically for the general case.\n+        final CachedRandomBits arb = new CachedRandomBits((count * gapBits + 3) / 5 + 10, random);\n \n         while (count-- != 0) {\n+            // Generate a random value between start (included) and end (excluded)\n+            final int randomValue = arb.nextBits(gapBits) + start;\n+            // Rejection sampling if value too large\n+            if (randomValue >= end) {\n+                count++;\n+                continue;\n+            }\n+\n             final int codePoint;\n             if (chars == null) {\n-                codePoint = random.nextInt(gap) + start;\n+                codePoint = randomValue;\n \n                 switch (Character.getType(codePoint)) {\n                 case Character.UNASSIGNED:\n@@ -240,7 +311,7 @@ public static String random(int count, int start, int end, final boolean letters\n                 }\n \n             } else {\n-                codePoint = chars[random.nextInt(gap) + start];\n+                codePoint = chars[randomValue];\n             }\n \n             final int numberOfChars = Character.charCount(codePoint);\ndiff --git a/src/test/java/org/apache/commons/lang3/CachedRandomBitsTest.java b/src/test/java/org/apache/commons/lang3/CachedRandomBitsTest.java\nnew file mode 100644\nindex 00000000000..6f8c8c9510a\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/CachedRandomBitsTest.java\n@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.Objects;\n+import java.util.Random;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+/**\n+ * Tests {@link CachedRandomBits}.\n+ */\n+public class CachedRandomBitsTest {\n+\n+    /** MockRandom mocks a Random class nextBytes to use a specific list of outputs */\n+    private static class MockRandom extends Random {\n+\n+        private static final long serialVersionUID = 1L;\n+        private final byte[] outputs;\n+        private int index;\n+\n+        MockRandom(final byte[] outputs) {\n+            super();\n+            this.outputs = outputs.clone();\n+            this.index = 0;\n+        }\n+\n+        @Override\n+        public void nextBytes(byte[] bytes) {\n+            Objects.requireNonNull(bytes, \"bytes\");\n+            if (index + bytes.length > outputs.length) {\n+                throw new IllegalStateException(\"Not enough outputs given in MockRandom\");\n+            }\n+            System.arraycopy(outputs, index, bytes, 0, bytes.length);\n+            index += bytes.length;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 32})\n+    public void testNext(int cacheSize) {\n+        MockRandom random = new MockRandom(new byte[]{\n+                0x11, 0x12, 0x13, 0x25,\n+                (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0xff,\n+                0x55, 0x44, 0x12, 0x34,\n+                0x56, 0x78, 0x00, 0x00,\n+                0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x00, 0x00, 0x00,\n+        });\n+\n+        CachedRandomBits arb = new CachedRandomBits(cacheSize, random);\n+\n+        assertThrows(IllegalArgumentException.class, () -> arb.nextBits(0));\n+        assertThrows(IllegalArgumentException.class, () -> arb.nextBits(33));\n+\n+        assertEquals(0x11, arb.nextBits(8));\n+        assertEquals(0x12, arb.nextBits(8));\n+        assertEquals(0x1325, arb.nextBits(16));\n+\n+        assertEquals(0xabcdefff, arb.nextBits(32));\n+\n+        assertEquals(0x5, arb.nextBits(4));\n+        assertEquals(0x1, arb.nextBits(1));\n+        assertEquals(0x0, arb.nextBits(1));\n+        assertEquals(0x1, arb.nextBits(2));\n+\n+        assertEquals(0x4, arb.nextBits(6));\n+\n+        assertEquals(0x40000000 | (0x12345600 >> 2) | 0x38, arb.nextBits(32));\n+\n+        assertEquals(1, arb.nextBits(1));\n+        assertEquals(0, arb.nextBits(1));\n+        assertEquals(0, arb.nextBits(9));\n+        assertEquals(0, arb.nextBits(31));\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java b/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java\nindex b4b8d6caeae..876a0d1463a 100644\n--- a/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/RandomStringUtilsTest.java\n@@ -27,6 +27,7 @@\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n import static org.junit.jupiter.api.Assertions.fail;\n \n import java.lang.reflect.Constructor;\n@@ -518,4 +519,28 @@ public void testRandomStringUtilsHomog() {\n         // critical value: from scipy.stats import chi2; chi2(2).isf(1e-5)\n         assertThat(\"test homogeneity -- will fail about 1 in 100,000 times\", chiSquare(expected, counts), lessThan(23.025850929940457d));\n     }\n+\n+    /**\n+     * Test {@code RandomStringUtils.random} works appropriately when chars specified.\n+     */\n+    @Test\n+    void testRandomWithChars() {\n+        final char[] digitChars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\n+\n+        String r1, r2, r3;\n+\n+        r1 = RandomStringUtils.random(50, 0, 0, true, true, digitChars);\n+        assertEquals(50, r1.length(), \"randomNumeric(50)\");\n+        for (int i = 0; i < r1.length(); i++) {\n+            assertTrue(\n+                    Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i)),\n+                    \"r1 contains numeric\");\n+        }\n+        r2 = RandomStringUtils.randomNumeric(50);\n+        assertNotEquals(r1, r2);\n+\n+        r3 = RandomStringUtils.random(50, 0, 0, true, true, digitChars);\n+        assertNotEquals(r1, r3);\n+        assertNotEquals(r2, r3);\n+    }\n }\n",
  "additions": 321,
  "deletions": 28,
  "changed_files": 4,
  "url": "https://github.com/apache/commons-lang/pull/1235",
  "mined_at": "2025-10-25T12:47:45.443831"
}