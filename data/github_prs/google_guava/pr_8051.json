{
  "id": 8051,
  "repository": "google/guava",
  "title": "Further rework `ImmutableSet.copyOf` handling of `EnumSet` after https://github.com/google/guava/commit/83869af96382246da6ff99cb029ef59ba684f592.",
  "body": "Further rework `ImmutableSet.copyOf` handling of `EnumSet` after https://github.com/google/guava/commit/83869af96382246da6ff99cb029ef59ba684f592.\n\nI had thought (here _and_ during the review of https://github.com/google/guava/commit/6ab30067225eb1dd64e14aebdd0aec7f72739483): \"Oh, maybe we could simplify this code because we don't _build under_ Java 8 anymore.\" But it looks like the problem we'd encountered was a problem with Java 8 _and higher_, not a problem that _went away after_ Java 8. (I found history in cl/98448037 and the threads linked from the review discussion there.) And I suspect that Java 8 is in the right. (Not that the code is \"unsafe,\" just that we're doing things that look like they deserve the `unchecked` warnings that we're getting.)\n\nIt's possible that cl/98448037 went unnecessarily far in _also_ changing `ImmutableEnumSet` itself, after which we undid that part https://github.com/google/guava/commit/6ab30067225eb1dd64e14aebdd0aec7f72739483. Now I'm back for `ImmutableSet.copyOf` itself, with goals like:\n- improve the suppression comment\n- localize the suppression\n- reduce diffs between mainline and backport\n- maybe prefer `unchecked` warnings over `rawtypes` warnings, as the latter seem to have given us more trouble before (as in https://github.com/google/guava/commit/6ab30067225eb1dd64e14aebdd0aec7f72739483)\n\nI'd originally intended to accomplish this by performing an unchecked cast to a set with arbitrary enum type (`Set<TimeUnit>`), operating on that, and then casting back to `ImmutableSet<E>` at the end. (`TimeUnit` wouldn't show up anywhere in the class file except in the local-variable table.) But after I got that working, I decided to ask Gemini, and it pointed out that we can do plenty with a wildcarded `EnumSet<?>`. I wonder if that approach didn't work at some point in the past, like when we actually did build under Java 8? Maybe I'm about to unwittingly break GWT/Eclipse? (If we encounter a problem specifically with `clone()`, I've had good results sticking with `EnumSet.copyOf` as an alternative.)\n\nRELNOTES=n/a\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-11T14:54:07+00:00",
  "created_at": "2025-10-10T18:52:06+00:00",
  "updated_at": "2025-10-11T14:54:07+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "80cfdaa808a018f69781ca0e7315d202218ee258",
  "head_sha": "06b6f4b0c571fd5f12976833b302345789b2526e",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava/src/com/google/common/collect/ImmutableSet.java",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "patch": "@@ -262,11 +262,6 @@ static int chooseTableSize(int setSize) {\n    * @throws NullPointerException if any of {@code elements} is null\n    * @since 7.0 (source-compatible since 2.0)\n    */\n-  // This the best we could do to get copyOfEnumSet to compile in the mainline.\n-  // The suppression also covers the cast to E[], discussed below.\n-  // In the backport, we don't have those cases and thus don't need this suppression.\n-  // We keep it to minimize diffs.\n-  @SuppressWarnings(\"unchecked\")\n   public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {\n     /*\n      * TODO(lowasser): consider checking for ImmutableAsList here"
    },
    {
      "filename": "guava/src/com/google/common/collect/ImmutableSet.java",
      "status": "modified",
      "additions": 10,
      "deletions": 11,
      "changes": 21,
      "patch": "@@ -169,11 +169,6 @@ public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... ot\n    * @throws NullPointerException if any of {@code elements} is null\n    * @since 7.0 (source-compatible since 2.0)\n    */\n-  // This the best we could do to get copyOfEnumSet to compile in the mainline.\n-  // The suppression also covers the cast to E[], discussed below.\n-  // In the backport, we don't have those cases and thus don't need this suppression.\n-  // We keep it to minimize diffs.\n-  @SuppressWarnings(\"unchecked\")\n   public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {\n     /*\n      * TODO(lowasser): consider checking for ImmutableAsList here\n@@ -187,7 +182,15 @@ public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {\n         return set;\n       }\n     } else if (elements instanceof EnumSet) {\n-      return copyOfEnumSet((EnumSet<?>) elements);\n+      EnumSet<?> clone = ((EnumSet<?>) elements).clone();\n+      ImmutableSet<?> untypedResult = ImmutableEnumSet.asImmutable(clone);\n+      /*\n+       * The result has the same type argument we started with. We just couldn't express EnumSet<E>\n+       * or ImmutableEnumSet<E> along the way because our own <E> isn't <E extends Enum<E>>.\n+       */\n+      @SuppressWarnings(\"unchecked\")\n+      ImmutableSet<E> result = (ImmutableSet<E>) untypedResult;\n+      return result;\n     }\n \n     if (elements.isEmpty()) {\n@@ -196,6 +199,7 @@ public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {\n     }\n     // Collection<E>.toArray() is required to contain only E instances, and all we do is read them.\n     // TODO(cpovirk): Consider using Object[] anyway.\n+    @SuppressWarnings(\"unchecked\")\n     E[] array = (E[]) elements.toArray();\n     /*\n      * For a Set, we guess that it contains no duplicates. That's just a guess for purpose of\n@@ -270,11 +274,6 @@ private static <E> ImmutableSet<E> fromArrayWithExpectedSize(E[] elements, int e\n     }\n   }\n \n-  @SuppressWarnings(\"rawtypes\") // necessary to compile against Java 8\n-  private static ImmutableSet copyOfEnumSet(EnumSet<?> enumSet) {\n-    return ImmutableEnumSet.asImmutable(EnumSet.copyOf(enumSet));\n-  }\n-\n   ImmutableSet() {}\n \n   /** Returns {@code true} if the {@code hashCode()} method runs quickly. */"
    }
  ],
  "diff": "diff --git a/android/guava/src/com/google/common/collect/ImmutableSet.java b/android/guava/src/com/google/common/collect/ImmutableSet.java\nindex 98722999c64b..e355478c4f77 100644\n--- a/android/guava/src/com/google/common/collect/ImmutableSet.java\n+++ b/android/guava/src/com/google/common/collect/ImmutableSet.java\n@@ -262,11 +262,6 @@ static int chooseTableSize(int setSize) {\n    * @throws NullPointerException if any of {@code elements} is null\n    * @since 7.0 (source-compatible since 2.0)\n    */\n-  // This the best we could do to get copyOfEnumSet to compile in the mainline.\n-  // The suppression also covers the cast to E[], discussed below.\n-  // In the backport, we don't have those cases and thus don't need this suppression.\n-  // We keep it to minimize diffs.\n-  @SuppressWarnings(\"unchecked\")\n   public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {\n     /*\n      * TODO(lowasser): consider checking for ImmutableAsList here\ndiff --git a/guava/src/com/google/common/collect/ImmutableSet.java b/guava/src/com/google/common/collect/ImmutableSet.java\nindex 7a6ba99d14d5..5cc6b4469041 100644\n--- a/guava/src/com/google/common/collect/ImmutableSet.java\n+++ b/guava/src/com/google/common/collect/ImmutableSet.java\n@@ -169,11 +169,6 @@ public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... ot\n    * @throws NullPointerException if any of {@code elements} is null\n    * @since 7.0 (source-compatible since 2.0)\n    */\n-  // This the best we could do to get copyOfEnumSet to compile in the mainline.\n-  // The suppression also covers the cast to E[], discussed below.\n-  // In the backport, we don't have those cases and thus don't need this suppression.\n-  // We keep it to minimize diffs.\n-  @SuppressWarnings(\"unchecked\")\n   public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {\n     /*\n      * TODO(lowasser): consider checking for ImmutableAsList here\n@@ -187,7 +182,15 @@ public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {\n         return set;\n       }\n     } else if (elements instanceof EnumSet) {\n-      return copyOfEnumSet((EnumSet<?>) elements);\n+      EnumSet<?> clone = ((EnumSet<?>) elements).clone();\n+      ImmutableSet<?> untypedResult = ImmutableEnumSet.asImmutable(clone);\n+      /*\n+       * The result has the same type argument we started with. We just couldn't express EnumSet<E>\n+       * or ImmutableEnumSet<E> along the way because our own <E> isn't <E extends Enum<E>>.\n+       */\n+      @SuppressWarnings(\"unchecked\")\n+      ImmutableSet<E> result = (ImmutableSet<E>) untypedResult;\n+      return result;\n     }\n \n     if (elements.isEmpty()) {\n@@ -196,6 +199,7 @@ public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {\n     }\n     // Collection<E>.toArray() is required to contain only E instances, and all we do is read them.\n     // TODO(cpovirk): Consider using Object[] anyway.\n+    @SuppressWarnings(\"unchecked\")\n     E[] array = (E[]) elements.toArray();\n     /*\n      * For a Set, we guess that it contains no duplicates. That's just a guess for purpose of\n@@ -270,11 +274,6 @@ private static <E> ImmutableSet<E> fromArrayWithExpectedSize(E[] elements, int e\n     }\n   }\n \n-  @SuppressWarnings(\"rawtypes\") // necessary to compile against Java 8\n-  private static ImmutableSet copyOfEnumSet(EnumSet<?> enumSet) {\n-    return ImmutableEnumSet.asImmutable(EnumSet.copyOf(enumSet));\n-  }\n-\n   ImmutableSet() {}\n \n   /** Returns {@code true} if the {@code hashCode()} method runs quickly. */\n",
  "additions": 10,
  "deletions": 16,
  "changed_files": 2,
  "url": "https://github.com/google/guava/pull/8051",
  "mined_at": "2025-10-25T12:49:31.003943"
}