{
  "id": 8045,
  "repository": "google/guava",
  "title": "Create an `asNetwork()` view for `Graph` and `ValueGraph`.",
  "body": "Create an `asNetwork()` view for `Graph` and `ValueGraph`.\n\nRELNOTES=`graph`: Added an `asNetwork()` view to `Graph` and `ValueGraph`.\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-07T15:57:09+00:00",
  "created_at": "2025-10-07T14:34:04+00:00",
  "updated_at": "2025-10-07T15:57:10+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "b53231b06e83e23ed1f0a84ad5becd5cf6d120a0",
  "head_sha": "909c593c61a656c2d70f0f9bd1cb0e5cdf43a556",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "patch": "@@ -121,6 +121,17 @@ static <N> void validateGraph(Graph<N> graph) {\n     int edgeStart = graphString.indexOf(\"edges:\");\n     String nodeString = graphString.substring(nodeStart, edgeStart);\n \n+    Network<N, EndpointPair<N>> asNetwork = graph.asNetwork();\n+    // Don't call AbstractNetworkTest.validateNetwork(asNetwork).  Mutual recursion.\n+    assertThat(graph.nodes()).isEqualTo(asNetwork.nodes());\n+    assertThat(graph.edges()).hasSize(asNetwork.edges().size());\n+    assertThat(graph.nodeOrder()).isEqualTo(asNetwork.nodeOrder());\n+    assertThat(graph.isDirected()).isEqualTo(asNetwork.isDirected());\n+    assertThat(graph.allowsSelfLoops()).isEqualTo(asNetwork.allowsSelfLoops());\n+    assertThat(asNetwork.edgeOrder()).isEqualTo(ElementOrder.unordered());\n+    assertThat(asNetwork.allowsParallelEdges()).isFalse();\n+    assertThat(asNetwork.asGraph()).isEqualTo(graph);\n+\n     Set<EndpointPair<N>> allEndpointPairs = new HashSet<>();\n \n     for (N node : sanityCheckSet(graph.nodes())) {"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/graph/ValueGraphTest.java",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "patch": "@@ -58,6 +58,17 @@ public void validateGraphState() {\n     assertThat(graph.isDirected()).isEqualTo(asGraph.isDirected());\n     assertThat(graph.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n \n+    Network<Integer, EndpointPair<Integer>> asNetwork = graph.asNetwork();\n+    AbstractNetworkTest.validateNetwork(asNetwork);\n+    assertThat(graph.nodes()).isEqualTo(asNetwork.nodes());\n+    assertThat(graph.edges()).hasSize(asNetwork.edges().size());\n+    assertThat(graph.nodeOrder()).isEqualTo(asNetwork.nodeOrder());\n+    assertThat(graph.isDirected()).isEqualTo(asNetwork.isDirected());\n+    assertThat(graph.allowsSelfLoops()).isEqualTo(asNetwork.allowsSelfLoops());\n+    assertThat(asNetwork.edgeOrder()).isEqualTo(ElementOrder.unordered());\n+    assertThat(asNetwork.allowsParallelEdges()).isFalse();\n+    assertThat(asNetwork.asGraph()).isEqualTo(graph.asGraph());\n+\n     for (Integer node : graph.nodes()) {\n       assertThat(graph.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n       assertThat(graph.predecessors(node)).isEqualTo(asGraph.predecessors(node));"
    },
    {
      "filename": "android/guava/src/com/google/common/graph/AbstractBaseGraph.java",
      "status": "modified",
      "additions": 132,
      "deletions": 1,
      "changes": 133,
      "patch": "@@ -108,7 +108,7 @@ public Set<EndpointPair<N>> incidentEdges(N node) {\n     checkNotNull(node);\n     checkArgument(nodes().contains(node), \"Node %s is not an element of this graph.\", node);\n     IncidentEdgeSet<N> incident =\n-        new IncidentEdgeSet<N>(this, node) {\n+        new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.BOTH) {\n           @Override\n           public UnmodifiableIterator<EndpointPair<N>> iterator() {\n             if (graph.isDirected()) {\n@@ -172,6 +172,137 @@ public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n     return nodes().contains(nodeU) && successors(nodeU).contains(nodeV);\n   }\n \n+  @Override\n+  public Network<N, EndpointPair<N>> asNetwork() {\n+    return new AbstractNetwork<N, EndpointPair<N>>() {\n+      @Override\n+      public Set<N> nodes() {\n+        return AbstractBaseGraph.this.nodes();\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> edges() {\n+        return AbstractBaseGraph.this.edges();\n+      }\n+\n+      @Override\n+      public Graph<N> asGraph() {\n+        if (AbstractBaseGraph.this instanceof Graph) {\n+          return (Graph<N>) AbstractBaseGraph.this;\n+        } else if (AbstractBaseGraph.this instanceof ValueGraph) {\n+          return ((ValueGraph<N, ?>) AbstractBaseGraph.this).asGraph();\n+        }\n+        throw new UnsupportedOperationException(\n+            \"Unexpected graph type: \" + AbstractBaseGraph.this.getClass());\n+      }\n+\n+      @Override\n+      public boolean isDirected() {\n+        return AbstractBaseGraph.this.isDirected();\n+      }\n+\n+      @Override\n+      public boolean allowsParallelEdges() {\n+        return false; // Graph doesn't allow parallel edges\n+      }\n+\n+      @Override\n+      public boolean allowsSelfLoops() {\n+        return AbstractBaseGraph.this.allowsSelfLoops();\n+      }\n+\n+      @Override\n+      public ElementOrder<N> nodeOrder() {\n+        return AbstractBaseGraph.this.nodeOrder();\n+      }\n+\n+      @Override\n+      public ElementOrder<EndpointPair<N>> edgeOrder() {\n+        return ElementOrder.unordered(); // Graph doesn't define edge order\n+      }\n+\n+      @Override\n+      public Set<N> adjacentNodes(N node) {\n+        return AbstractBaseGraph.this.adjacentNodes(node);\n+      }\n+\n+      @Override\n+      public Set<N> predecessors(N node) {\n+        return AbstractBaseGraph.this.predecessors(node);\n+      }\n+\n+      @Override\n+      public Set<N> successors(N node) {\n+        return AbstractBaseGraph.this.successors(node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> incidentEdges(N node) {\n+        return AbstractBaseGraph.this.incidentEdges(node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> inEdges(N node) {\n+        checkNotNull(node);\n+        checkArgument(nodes().contains(node));\n+        IncidentEdgeSet<N> incident =\n+            new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.INCOMING) {\n+              @Override\n+              public UnmodifiableIterator<EndpointPair<N>> iterator() {\n+                return Iterators.unmodifiableIterator(\n+                    Iterators.transform(\n+                        graph.predecessors(node).iterator(),\n+                        (N predecessor) ->\n+                            graph.isDirected()\n+                                ? EndpointPair.ordered(predecessor, node)\n+                                : EndpointPair.unordered(predecessor, node)));\n+              }\n+            };\n+        return nodeInvalidatableSet(incident, node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> outEdges(N node) {\n+        checkNotNull(node);\n+        checkArgument(nodes().contains(node));\n+        IncidentEdgeSet<N> incident =\n+            new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.OUTGOING) {\n+              @Override\n+              public UnmodifiableIterator<EndpointPair<N>> iterator() {\n+                return Iterators.unmodifiableIterator(\n+                    Iterators.transform(\n+                        graph.successors(node).iterator(),\n+                        (N successor) ->\n+                            graph.isDirected()\n+                                ? EndpointPair.ordered(node, successor)\n+                                : EndpointPair.unordered(node, successor)));\n+              }\n+            };\n+        return nodeInvalidatableSet(incident, node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> adjacentEdges(EndpointPair<N> edge) {\n+        checkArgument(edges().contains(edge));\n+        N nodeU = edge.nodeU();\n+        N nodeV = edge.nodeV();\n+        Set<EndpointPair<N>> endpointPairIncidentEdges =\n+            Sets.union(incidentEdges(nodeU), incidentEdges(nodeV));\n+        return nodePairInvalidatableSet(\n+            Sets.difference(endpointPairIncidentEdges, ImmutableSet.of(edge)), nodeU, nodeV);\n+      }\n+\n+      @Override\n+      public EndpointPair<N> incidentNodes(EndpointPair<N> edge) {\n+        checkArgument(edges().contains(edge));\n+        return edge;\n+      }\n+\n+      // Don't override the existing edge[s]Connecting() or *degree() AbstractNetwork\n+      // implementations; they call in/outEdges() and should be fine.\n+    };\n+  }\n+\n   /**\n    * Throws {@code IllegalArgumentException} if the ordering of {@code endpoints} is not compatible\n    * with the directionality of this graph."
    },
    {
      "filename": "android/guava/src/com/google/common/graph/ArchetypeGraph.java",
      "status": "added",
      "additions": 191,
      "deletions": 0,
      "changes": 191,
      "patch": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright (C) 2017 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.common.graph;\n+\n+import java.util.Set;\n+\n+/**\n+ * A non-public interface for the methods shared between {@link Graph}, {@link ValueGraph}, and\n+ * {@link Network}.\n+ *\n+ * @author Joshua O'Madadhain\n+ * @param <N> Node parameter type\n+ */\n+interface ArchetypeGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n+  //\n+  // Graph-level accessors\n+  //\n+\n+  /** Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}. */\n+  Set<N> nodes();\n+\n+  //\n+  // Graph properties\n+  //\n+\n+  /**\n+   * Returns true if the edges in this graph are directed. Directed edges connect a {@link\n+   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n+   * undirected edges connect a pair of nodes to each other.\n+   */\n+  boolean isDirected();\n+\n+  /**\n+   * Returns true if this graph allows self-loops (edges that connect a node to itself). Attempting\n+   * to add a self-loop to a graph that does not allow them will throw an {@link\n+   * IllegalArgumentException}.\n+   */\n+  boolean allowsSelfLoops();\n+\n+  /** Returns the order of iteration for the elements of {@link #nodes()}. */\n+  ElementOrder<N> nodeOrder();\n+\n+  //\n+  // Element-level accessors\n+  //\n+\n+  /**\n+   * Returns a live view of the nodes which have an incident edge in common with {@code node} in\n+   * this graph.\n+   *\n+   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.\n+   *\n+   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n+   * {@code view} returned by this method will be invalidated, and will throw {@code\n+   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n+   *\n+   * <ul>\n+   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n+   *       involving {@code view} will throw)\n+   *   <li>{@code hashCode()} does not throw\n+   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n+   *       behavior is undefined\n+   * </ul>\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  Set<N> adjacentNodes(N node);\n+\n+  /**\n+   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n+   * traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n+   *\n+   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n+   *\n+   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n+   * {@code view} returned by this method will be invalidated, and will throw {@code\n+   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n+   *\n+   * <ul>\n+   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n+   *       involving {@code view} will throw)\n+   *   <li>{@code hashCode()} does not throw\n+   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n+   *       behavior is undefined\n+   * </ul>\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  @Override\n+  Set<N> predecessors(N node);\n+\n+  /**\n+   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n+   * traversing {@code node}'s outgoing edges in the direction (if any) of the edge.\n+   *\n+   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n+   *\n+   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n+   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.\n+   *\n+   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n+   * {@code view} returned by this method will be invalidated, and will throw {@code\n+   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n+   *\n+   * <ul>\n+   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n+   *       involving {@code view} will throw)\n+   *   <li>{@code hashCode()} does not throw\n+   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n+   *       behavior is undefined\n+   * </ul>\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  @Override\n+  Set<N> successors(N node);\n+\n+  /**\n+   * Returns the count of {@code node}'s incident edges, counting self-loops twice (equivalently,\n+   * the number of times an edge touches {@code node}).\n+   *\n+   * <p>For directed graphs, this is equal to {@code inDegree(node) + outDegree(node)}.\n+   *\n+   * <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of\n+   * self-loops incident to {@code node}).\n+   *\n+   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  int degree(N node);\n+\n+  /**\n+   * Returns the count of {@code node}'s incoming edges (equal to {@code predecessors(node).size()})\n+   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n+   *\n+   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  int inDegree(N node);\n+\n+  /**\n+   * Returns the count of {@code node}'s outgoing edges (equal to {@code successors(node).size()})\n+   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n+   *\n+   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  int outDegree(N node);\n+\n+  /**\n+   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n+   * equivalent to {@code nodes().contains(nodeU) && successors(nodeU).contains(nodeV)}.\n+   *\n+   * <p>In an undirected graph, this is equal to {@code hasEdgeConnecting(nodeV, nodeU)}.\n+   *\n+   * @since 23.0\n+   */\n+  boolean hasEdgeConnecting(N nodeU, N nodeV);\n+\n+  /**\n+   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n+   * any, specified by {@code endpoints}). This is equivalent to {@code\n+   * edges().contains(endpoints)}.\n+   *\n+   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n+   * endpoints are unordered; it simply returns false. This is for consistency with the behavior of\n+   * {@link Collection#contains(Object)} (which does not generally throw if the object cannot be\n+   * present in the collection), and the desire to have this method's behavior be compatible with\n+   * {@code edges().contains(endpoints)}.\n+   *\n+   * @since 27.1\n+   */\n+  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n+}"
    },
    {
      "filename": "android/guava/src/com/google/common/graph/BaseGraph.java",
      "status": "modified",
      "additions": 13,
      "deletions": 156,
      "changes": 169,
      "patch": "@@ -24,38 +24,14 @@\n  * @author James Sexton\n  * @param <N> Node parameter type\n  */\n-interface BaseGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n+interface BaseGraph<N> extends ArchetypeGraph<N> {\n   //\n   // Graph-level accessors\n   //\n \n-  /** Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}. */\n-  Set<N> nodes();\n-\n   /** Returns all edges in this graph. */\n   Set<EndpointPair<N>> edges();\n \n-  //\n-  // Graph properties\n-  //\n-\n-  /**\n-   * Returns true if the edges in this graph are directed. Directed edges connect a {@link\n-   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n-   * undirected edges connect a pair of nodes to each other.\n-   */\n-  boolean isDirected();\n-\n-  /**\n-   * Returns true if this graph allows self-loops (edges that connect a node to itself). Attempting\n-   * to add a self-loop to a graph that does not allow them will throw an {@link\n-   * IllegalArgumentException}.\n-   */\n-  boolean allowsSelfLoops();\n-\n-  /** Returns the order of iteration for the elements of {@link #nodes()}. */\n-  ElementOrder<N> nodeOrder();\n-\n   /**\n    * Returns an {@link ElementOrder} that specifies the order of iteration for the elements of\n    * {@link #edges()}, {@link #adjacentNodes(Object)}, {@link #predecessors(Object)}, {@link\n@@ -65,80 +41,21 @@ interface BaseGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n    */\n   ElementOrder<N> incidentEdgeOrder();\n \n-  //\n-  // Element-level accessors\n-  //\n-\n-  /**\n-   * Returns a live view of the nodes which have an incident edge in common with {@code node} in\n-   * this graph.\n-   *\n-   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n-   *       involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  Set<N> adjacentNodes(N node);\n-\n   /**\n-   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n-   * traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n-   *       involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   * Returns a live view of this graph as a {@link Network} whose edges {@code E} are {@code\n+   * EndpointPair<N>} objects (that is, a {@code Network<N, EndpointPair<N>>}). The resulting {@code\n+   * Network}'s edge-oriented methods (such as {@code inEdges()}) will return views transformed from\n+   * the corresponding node-oriented methods (such as {@code predecessors()}).\n+   *\n+   * <p>This capability facilitates writing implementations of <a\n+   * href=\"https://github.com/google/guava/wiki/GraphsExplained#graph-types-for-algorithms\">edge-oriented\n+   * code</a>.\n    */\n-  @Override\n-  Set<N> predecessors(N node);\n+  Network<N, EndpointPair<N>> asNetwork();\n \n-  /**\n-   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n-   * traversing {@code node}'s outgoing edges in the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n-   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.\n-   *\n-   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n-   *       involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  @Override\n-  Set<N> successors(N node);\n+  //\n+  // Element-level accessors\n+  //\n \n   /**\n    * Returns a live view of the edges in this graph whose endpoints include {@code node}.\n@@ -161,64 +78,4 @@ interface BaseGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n    * @since 24.0\n    */\n   Set<EndpointPair<N>> incidentEdges(N node);\n-\n-  /**\n-   * Returns the count of {@code node}'s incident edges, counting self-loops twice (equivalently,\n-   * the number of times an edge touches {@code node}).\n-   *\n-   * <p>For directed graphs, this is equal to {@code inDegree(node) + outDegree(node)}.\n-   *\n-   * <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of\n-   * self-loops incident to {@code node}).\n-   *\n-   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  int degree(N node);\n-\n-  /**\n-   * Returns the count of {@code node}'s incoming edges (equal to {@code predecessors(node).size()})\n-   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n-   *\n-   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  int inDegree(N node);\n-\n-  /**\n-   * Returns the count of {@code node}'s outgoing edges (equal to {@code successors(node).size()})\n-   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n-   *\n-   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  int outDegree(N node);\n-\n-  /**\n-   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n-   * equivalent to {@code nodes().contains(nodeU) && successors(nodeU).contains(nodeV)}.\n-   *\n-   * <p>In an undirected graph, this is equal to {@code hasEdgeConnecting(nodeV, nodeU)}.\n-   *\n-   * @since 23.0\n-   */\n-  boolean hasEdgeConnecting(N nodeU, N nodeV);\n-\n-  /**\n-   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n-   * any, specified by {@code endpoints}). This is equivalent to {@code\n-   * edges().contains(endpoints)}.\n-   *\n-   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n-   * endpoints are unordered; it simply returns false. This is for consistency with the behavior of\n-   * {@link Collection#contains(Object)} (which does not generally throw if the object cannot be\n-   * present in the collection), and the desire to have this method's behavior be compatible with\n-   * {@code edges().contains(endpoints)}.\n-   *\n-   * @since 27.1\n-   */\n-  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n }"
    },
    {
      "filename": "android/guava/src/com/google/common/graph/Graphs.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -366,7 +366,7 @@ public Set<N> successors(N node) {\n \n     @Override\n     public Set<EndpointPair<N>> incidentEdges(N node) {\n-      return new IncidentEdgeSet<N>(this, node) {\n+      return new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.BOTH) {\n         @Override\n         public Iterator<EndpointPair<N>> iterator() {\n           return Iterators.transform("
    },
    {
      "filename": "android/guava/src/com/google/common/graph/IncidentEdgeSet.java",
      "status": "modified",
      "additions": 44,
      "deletions": 14,
      "changes": 58,
      "patch": "@@ -16,6 +16,7 @@\n \n package com.google.common.graph;\n \n+import com.google.common.collect.ImmutableSet;\n import java.util.AbstractSet;\n import java.util.Set;\n import org.jspecify.annotations.Nullable;\n@@ -26,11 +27,19 @@\n  */\n abstract class IncidentEdgeSet<N> extends AbstractSet<EndpointPair<N>> {\n   final N node;\n-  final BaseGraph<N> graph;\n+  final ArchetypeGraph<N> graph;\n+  final EdgeType edgeType;\n \n-  IncidentEdgeSet(BaseGraph<N> graph, N node) {\n+  enum EdgeType {\n+    INCOMING, // incoming incident edges only\n+    OUTGOING, // outgoing incident edges only\n+    BOTH // both incoming and outgoing incident edges\n+  }\n+\n+  IncidentEdgeSet(ArchetypeGraph<N> graph, N node, EdgeType edgeType) {\n     this.graph = graph;\n     this.node = node;\n+    this.edgeType = edgeType;\n   }\n \n   @Override\n@@ -41,9 +50,9 @@ public boolean remove(@Nullable Object o) {\n   @Override\n   public int size() {\n     if (graph.isDirected()) {\n-      return graph.inDegree(node)\n-          + graph.outDegree(node)\n-          - (graph.successors(node).contains(node) ? 1 : 0);\n+      return predecessorsOrEmpty(node).size()\n+          + successorsOrEmpty(node).size()\n+          - (edgeType == EdgeType.BOTH && predecessorsOrEmpty(node).contains(node) ? 1 : 0);\n     } else {\n       return graph.adjacentNodes(node).size();\n     }\n@@ -56,19 +65,16 @@ public boolean contains(@Nullable Object obj) {\n     }\n     EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n \n-    if (graph.isDirected()) {\n-      if (!endpointPair.isOrdered()) {\n-        return false;\n-      }\n+    if (graph.isDirected() != endpointPair.isOrdered()) {\n+      return false;\n+    }\n \n+    if (graph.isDirected()) {\n       Object source = endpointPair.source();\n       Object target = endpointPair.target();\n-      return (node.equals(source) && graph.successors(node).contains(target))\n-          || (node.equals(target) && graph.predecessors(node).contains(source));\n+      return (node.equals(source) && successorsOrEmpty(node).contains(target))\n+          || (node.equals(target) && predecessorsOrEmpty(node).contains(source));\n     } else {\n-      if (endpointPair.isOrdered()) {\n-        return false;\n-      }\n       Set<N> adjacent = graph.adjacentNodes(node);\n       Object nodeU = endpointPair.nodeU();\n       Object nodeV = endpointPair.nodeV();\n@@ -77,4 +83,28 @@ public boolean contains(@Nullable Object obj) {\n           || (node.equals(nodeU) && adjacent.contains(nodeV));\n     }\n   }\n+\n+  /**\n+   * Returns the predecessors of the given node, or an empty set if this set does not represent\n+   * incoming edges.\n+   */\n+  private Set<N> predecessorsOrEmpty(N node) {\n+    if (edgeType == EdgeType.INCOMING || edgeType == EdgeType.BOTH) {\n+      return graph.predecessors(node);\n+    } else {\n+      return ImmutableSet.of();\n+    }\n+  }\n+\n+  /**\n+   * Returns the successors of the given node, or an empty set if this set does not represent\n+   * outgoing edges.\n+   */\n+  private Set<N> successorsOrEmpty(N node) {\n+    if (edgeType == EdgeType.OUTGOING || edgeType == EdgeType.BOTH) {\n+      return graph.successors(node);\n+    } else {\n+      return ImmutableSet.of();\n+    }\n+  }\n }"
    },
    {
      "filename": "android/guava/src/com/google/common/graph/Network.java",
      "status": "modified",
      "additions": 6,
      "deletions": 84,
      "changes": 90,
      "patch": "@@ -105,14 +105,11 @@\n  */\n @Beta\n @DoNotMock(\"Use NetworkBuilder to create a real instance\")\n-public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n+public interface Network<N, E> extends ArchetypeGraph<N> {\n   //\n   // Network-level accessors\n   //\n \n-  /** Returns all nodes in this network, in the order specified by {@link #nodeOrder()}. */\n-  Set<N> nodes();\n-\n   /** Returns all edges in this network, in the order specified by {@link #edgeOrder()}. */\n   Set<E> edges();\n \n@@ -130,99 +127,19 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n   // Network properties\n   //\n \n-  /**\n-   * Returns true if the edges in this network are directed. Directed edges connect a {@link\n-   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n-   * undirected edges connect a pair of nodes to each other.\n-   */\n-  boolean isDirected();\n-\n   /**\n    * Returns true if this network allows parallel edges. Attempting to add a parallel edge to a\n    * network that does not allow them will throw an {@link IllegalArgumentException}.\n    */\n   boolean allowsParallelEdges();\n \n-  /**\n-   * Returns true if this network allows self-loops (edges that connect a node to itself).\n-   * Attempting to add a self-loop to a network that does not allow them will throw an {@link\n-   * IllegalArgumentException}.\n-   */\n-  boolean allowsSelfLoops();\n-\n-  /** Returns the order of iteration for the elements of {@link #nodes()}. */\n-  ElementOrder<N> nodeOrder();\n-\n   /** Returns the order of iteration for the elements of {@link #edges()}. */\n   ElementOrder<E> edgeOrder();\n \n   //\n   // Element-level accessors\n   //\n \n-  /**\n-   * Returns a live view of the nodes which have an incident edge in common with {@code node} in\n-   * this network.\n-   *\n-   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the network after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}\n-   *       expression involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this network\n-   */\n-  Set<N> adjacentNodes(N node);\n-\n-  /**\n-   * Returns a live view of all nodes in this network adjacent to {@code node} which can be reached\n-   * by traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected network, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the network after this method is called, the {@code Set}\n-   * returned by this method will be invalidated, and will throw {@code IllegalStateException} if it\n-   * is accessed in any way.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this network\n-   */\n-  @Override\n-  Set<N> predecessors(N node);\n-\n-  /**\n-   * Returns a live view of all nodes in this network adjacent to {@code node} which can be reached\n-   * by traversing {@code node}'s outgoing edges in the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected network, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n-   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.\n-   *\n-   * <p>If {@code node} is removed from the network after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}\n-   *       expression involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this network\n-   */\n-  @Override\n-  Set<N> successors(N node);\n-\n   /**\n    * Returns a live view of the edges whose {@link #incidentNodes(Object) incident nodes} in this\n    * network include {@code node}.\n@@ -307,6 +224,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @throws IllegalArgumentException if {@code node} is not an element of this network\n    */\n+  @Override\n   int degree(N node);\n \n   /**\n@@ -317,6 +235,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @throws IllegalArgumentException if {@code node} is not an element of this network\n    */\n+  @Override\n   int inDegree(N node);\n \n   /**\n@@ -327,6 +246,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @throws IllegalArgumentException if {@code node} is not an element of this network\n    */\n+  @Override\n   int outDegree(N node);\n \n   /**\n@@ -452,6 +372,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @since 23.0\n    */\n+  @Override\n   boolean hasEdgeConnecting(N nodeU, N nodeV);\n \n   /**\n@@ -465,6 +386,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @since 27.1\n    */\n+  @Override\n   boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n \n   //"
    },
    {
      "filename": "android/guava/src/com/google/common/graph/StandardValueGraph.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -119,7 +119,7 @@ public Set<N> successors(N node) {\n   public Set<EndpointPair<N>> incidentEdges(N node) {\n     GraphConnections<N, V> connections = checkedConnections(node);\n     IncidentEdgeSet<N> incident =\n-        new IncidentEdgeSet<N>(this, node) {\n+        new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.BOTH) {\n           @Override\n           public Iterator<EndpointPair<N>> iterator() {\n             return connections.incidentEdgeIterator(node);"
    },
    {
      "filename": "guava-tests/test/com/google/common/graph/AbstractGraphTest.java",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "patch": "@@ -121,6 +121,17 @@ static <N> void validateGraph(Graph<N> graph) {\n     int edgeStart = graphString.indexOf(\"edges:\");\n     String nodeString = graphString.substring(nodeStart, edgeStart);\n \n+    Network<N, EndpointPair<N>> asNetwork = graph.asNetwork();\n+    // Don't call AbstractNetworkTest.validateNetwork(asNetwork).  Mutual recursion.\n+    assertThat(graph.nodes()).isEqualTo(asNetwork.nodes());\n+    assertThat(graph.edges()).hasSize(asNetwork.edges().size());\n+    assertThat(graph.nodeOrder()).isEqualTo(asNetwork.nodeOrder());\n+    assertThat(graph.isDirected()).isEqualTo(asNetwork.isDirected());\n+    assertThat(graph.allowsSelfLoops()).isEqualTo(asNetwork.allowsSelfLoops());\n+    assertThat(asNetwork.edgeOrder()).isEqualTo(ElementOrder.unordered());\n+    assertThat(asNetwork.allowsParallelEdges()).isFalse();\n+    assertThat(asNetwork.asGraph()).isEqualTo(graph);\n+\n     Set<EndpointPair<N>> allEndpointPairs = new HashSet<>();\n \n     for (N node : sanityCheckSet(graph.nodes())) {"
    },
    {
      "filename": "guava-tests/test/com/google/common/graph/ValueGraphTest.java",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "patch": "@@ -58,6 +58,17 @@ public void validateGraphState() {\n     assertThat(graph.isDirected()).isEqualTo(asGraph.isDirected());\n     assertThat(graph.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n \n+    Network<Integer, EndpointPair<Integer>> asNetwork = graph.asNetwork();\n+    AbstractNetworkTest.validateNetwork(asNetwork);\n+    assertThat(graph.nodes()).isEqualTo(asNetwork.nodes());\n+    assertThat(graph.edges()).hasSize(asNetwork.edges().size());\n+    assertThat(graph.nodeOrder()).isEqualTo(asNetwork.nodeOrder());\n+    assertThat(graph.isDirected()).isEqualTo(asNetwork.isDirected());\n+    assertThat(graph.allowsSelfLoops()).isEqualTo(asNetwork.allowsSelfLoops());\n+    assertThat(asNetwork.edgeOrder()).isEqualTo(ElementOrder.unordered());\n+    assertThat(asNetwork.allowsParallelEdges()).isFalse();\n+    assertThat(asNetwork.asGraph()).isEqualTo(graph.asGraph());\n+\n     for (Integer node : graph.nodes()) {\n       assertThat(graph.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n       assertThat(graph.predecessors(node)).isEqualTo(asGraph.predecessors(node));"
    },
    {
      "filename": "guava/src/com/google/common/graph/AbstractBaseGraph.java",
      "status": "modified",
      "additions": 132,
      "deletions": 1,
      "changes": 133,
      "patch": "@@ -108,7 +108,7 @@ public Set<EndpointPair<N>> incidentEdges(N node) {\n     checkNotNull(node);\n     checkArgument(nodes().contains(node), \"Node %s is not an element of this graph.\", node);\n     IncidentEdgeSet<N> incident =\n-        new IncidentEdgeSet<N>(this, node) {\n+        new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.BOTH) {\n           @Override\n           public UnmodifiableIterator<EndpointPair<N>> iterator() {\n             if (graph.isDirected()) {\n@@ -172,6 +172,137 @@ public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n     return nodes().contains(nodeU) && successors(nodeU).contains(nodeV);\n   }\n \n+  @Override\n+  public Network<N, EndpointPair<N>> asNetwork() {\n+    return new AbstractNetwork<N, EndpointPair<N>>() {\n+      @Override\n+      public Set<N> nodes() {\n+        return AbstractBaseGraph.this.nodes();\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> edges() {\n+        return AbstractBaseGraph.this.edges();\n+      }\n+\n+      @Override\n+      public Graph<N> asGraph() {\n+        if (AbstractBaseGraph.this instanceof Graph) {\n+          return (Graph<N>) AbstractBaseGraph.this;\n+        } else if (AbstractBaseGraph.this instanceof ValueGraph) {\n+          return ((ValueGraph<N, ?>) AbstractBaseGraph.this).asGraph();\n+        }\n+        throw new UnsupportedOperationException(\n+            \"Unexpected graph type: \" + AbstractBaseGraph.this.getClass());\n+      }\n+\n+      @Override\n+      public boolean isDirected() {\n+        return AbstractBaseGraph.this.isDirected();\n+      }\n+\n+      @Override\n+      public boolean allowsParallelEdges() {\n+        return false; // Graph doesn't allow parallel edges\n+      }\n+\n+      @Override\n+      public boolean allowsSelfLoops() {\n+        return AbstractBaseGraph.this.allowsSelfLoops();\n+      }\n+\n+      @Override\n+      public ElementOrder<N> nodeOrder() {\n+        return AbstractBaseGraph.this.nodeOrder();\n+      }\n+\n+      @Override\n+      public ElementOrder<EndpointPair<N>> edgeOrder() {\n+        return ElementOrder.unordered(); // Graph doesn't define edge order\n+      }\n+\n+      @Override\n+      public Set<N> adjacentNodes(N node) {\n+        return AbstractBaseGraph.this.adjacentNodes(node);\n+      }\n+\n+      @Override\n+      public Set<N> predecessors(N node) {\n+        return AbstractBaseGraph.this.predecessors(node);\n+      }\n+\n+      @Override\n+      public Set<N> successors(N node) {\n+        return AbstractBaseGraph.this.successors(node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> incidentEdges(N node) {\n+        return AbstractBaseGraph.this.incidentEdges(node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> inEdges(N node) {\n+        checkNotNull(node);\n+        checkArgument(nodes().contains(node));\n+        IncidentEdgeSet<N> incident =\n+            new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.INCOMING) {\n+              @Override\n+              public UnmodifiableIterator<EndpointPair<N>> iterator() {\n+                return Iterators.unmodifiableIterator(\n+                    Iterators.transform(\n+                        graph.predecessors(node).iterator(),\n+                        (N predecessor) ->\n+                            graph.isDirected()\n+                                ? EndpointPair.ordered(predecessor, node)\n+                                : EndpointPair.unordered(predecessor, node)));\n+              }\n+            };\n+        return nodeInvalidatableSet(incident, node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> outEdges(N node) {\n+        checkNotNull(node);\n+        checkArgument(nodes().contains(node));\n+        IncidentEdgeSet<N> incident =\n+            new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.OUTGOING) {\n+              @Override\n+              public UnmodifiableIterator<EndpointPair<N>> iterator() {\n+                return Iterators.unmodifiableIterator(\n+                    Iterators.transform(\n+                        graph.successors(node).iterator(),\n+                        (N successor) ->\n+                            graph.isDirected()\n+                                ? EndpointPair.ordered(node, successor)\n+                                : EndpointPair.unordered(node, successor)));\n+              }\n+            };\n+        return nodeInvalidatableSet(incident, node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> adjacentEdges(EndpointPair<N> edge) {\n+        checkArgument(edges().contains(edge));\n+        N nodeU = edge.nodeU();\n+        N nodeV = edge.nodeV();\n+        Set<EndpointPair<N>> endpointPairIncidentEdges =\n+            Sets.union(incidentEdges(nodeU), incidentEdges(nodeV));\n+        return nodePairInvalidatableSet(\n+            Sets.difference(endpointPairIncidentEdges, ImmutableSet.of(edge)), nodeU, nodeV);\n+      }\n+\n+      @Override\n+      public EndpointPair<N> incidentNodes(EndpointPair<N> edge) {\n+        checkArgument(edges().contains(edge));\n+        return edge;\n+      }\n+\n+      // Don't override the existing edge[s]Connecting() or *degree() AbstractNetwork\n+      // implementations; they call in/outEdges() and should be fine.\n+    };\n+  }\n+\n   /**\n    * Throws {@code IllegalArgumentException} if the ordering of {@code endpoints} is not compatible\n    * with the directionality of this graph."
    },
    {
      "filename": "guava/src/com/google/common/graph/ArchetypeGraph.java",
      "status": "added",
      "additions": 191,
      "deletions": 0,
      "changes": 191,
      "patch": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright (C) 2017 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.common.graph;\n+\n+import java.util.Set;\n+\n+/**\n+ * A non-public interface for the methods shared between {@link Graph}, {@link ValueGraph}, and\n+ * {@link Network}.\n+ *\n+ * @author Joshua O'Madadhain\n+ * @param <N> Node parameter type\n+ */\n+interface ArchetypeGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n+  //\n+  // Graph-level accessors\n+  //\n+\n+  /** Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}. */\n+  Set<N> nodes();\n+\n+  //\n+  // Graph properties\n+  //\n+\n+  /**\n+   * Returns true if the edges in this graph are directed. Directed edges connect a {@link\n+   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n+   * undirected edges connect a pair of nodes to each other.\n+   */\n+  boolean isDirected();\n+\n+  /**\n+   * Returns true if this graph allows self-loops (edges that connect a node to itself). Attempting\n+   * to add a self-loop to a graph that does not allow them will throw an {@link\n+   * IllegalArgumentException}.\n+   */\n+  boolean allowsSelfLoops();\n+\n+  /** Returns the order of iteration for the elements of {@link #nodes()}. */\n+  ElementOrder<N> nodeOrder();\n+\n+  //\n+  // Element-level accessors\n+  //\n+\n+  /**\n+   * Returns a live view of the nodes which have an incident edge in common with {@code node} in\n+   * this graph.\n+   *\n+   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.\n+   *\n+   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n+   * {@code view} returned by this method will be invalidated, and will throw {@code\n+   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n+   *\n+   * <ul>\n+   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n+   *       involving {@code view} will throw)\n+   *   <li>{@code hashCode()} does not throw\n+   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n+   *       behavior is undefined\n+   * </ul>\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  Set<N> adjacentNodes(N node);\n+\n+  /**\n+   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n+   * traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n+   *\n+   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n+   *\n+   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n+   * {@code view} returned by this method will be invalidated, and will throw {@code\n+   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n+   *\n+   * <ul>\n+   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n+   *       involving {@code view} will throw)\n+   *   <li>{@code hashCode()} does not throw\n+   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n+   *       behavior is undefined\n+   * </ul>\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  @Override\n+  Set<N> predecessors(N node);\n+\n+  /**\n+   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n+   * traversing {@code node}'s outgoing edges in the direction (if any) of the edge.\n+   *\n+   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n+   *\n+   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n+   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.\n+   *\n+   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n+   * {@code view} returned by this method will be invalidated, and will throw {@code\n+   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n+   *\n+   * <ul>\n+   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n+   *       involving {@code view} will throw)\n+   *   <li>{@code hashCode()} does not throw\n+   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n+   *       behavior is undefined\n+   * </ul>\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  @Override\n+  Set<N> successors(N node);\n+\n+  /**\n+   * Returns the count of {@code node}'s incident edges, counting self-loops twice (equivalently,\n+   * the number of times an edge touches {@code node}).\n+   *\n+   * <p>For directed graphs, this is equal to {@code inDegree(node) + outDegree(node)}.\n+   *\n+   * <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of\n+   * self-loops incident to {@code node}).\n+   *\n+   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  int degree(N node);\n+\n+  /**\n+   * Returns the count of {@code node}'s incoming edges (equal to {@code predecessors(node).size()})\n+   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n+   *\n+   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  int inDegree(N node);\n+\n+  /**\n+   * Returns the count of {@code node}'s outgoing edges (equal to {@code successors(node).size()})\n+   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n+   *\n+   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  int outDegree(N node);\n+\n+  /**\n+   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n+   * equivalent to {@code nodes().contains(nodeU) && successors(nodeU).contains(nodeV)}.\n+   *\n+   * <p>In an undirected graph, this is equal to {@code hasEdgeConnecting(nodeV, nodeU)}.\n+   *\n+   * @since 23.0\n+   */\n+  boolean hasEdgeConnecting(N nodeU, N nodeV);\n+\n+  /**\n+   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n+   * any, specified by {@code endpoints}). This is equivalent to {@code\n+   * edges().contains(endpoints)}.\n+   *\n+   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n+   * endpoints are unordered; it simply returns false. This is for consistency with the behavior of\n+   * {@link Collection#contains(Object)} (which does not generally throw if the object cannot be\n+   * present in the collection), and the desire to have this method's behavior be compatible with\n+   * {@code edges().contains(endpoints)}.\n+   *\n+   * @since 27.1\n+   */\n+  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n+}"
    },
    {
      "filename": "guava/src/com/google/common/graph/BaseGraph.java",
      "status": "modified",
      "additions": 13,
      "deletions": 156,
      "changes": 169,
      "patch": "@@ -24,38 +24,14 @@\n  * @author James Sexton\n  * @param <N> Node parameter type\n  */\n-interface BaseGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n+interface BaseGraph<N> extends ArchetypeGraph<N> {\n   //\n   // Graph-level accessors\n   //\n \n-  /** Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}. */\n-  Set<N> nodes();\n-\n   /** Returns all edges in this graph. */\n   Set<EndpointPair<N>> edges();\n \n-  //\n-  // Graph properties\n-  //\n-\n-  /**\n-   * Returns true if the edges in this graph are directed. Directed edges connect a {@link\n-   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n-   * undirected edges connect a pair of nodes to each other.\n-   */\n-  boolean isDirected();\n-\n-  /**\n-   * Returns true if this graph allows self-loops (edges that connect a node to itself). Attempting\n-   * to add a self-loop to a graph that does not allow them will throw an {@link\n-   * IllegalArgumentException}.\n-   */\n-  boolean allowsSelfLoops();\n-\n-  /** Returns the order of iteration for the elements of {@link #nodes()}. */\n-  ElementOrder<N> nodeOrder();\n-\n   /**\n    * Returns an {@link ElementOrder} that specifies the order of iteration for the elements of\n    * {@link #edges()}, {@link #adjacentNodes(Object)}, {@link #predecessors(Object)}, {@link\n@@ -65,80 +41,21 @@ interface BaseGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n    */\n   ElementOrder<N> incidentEdgeOrder();\n \n-  //\n-  // Element-level accessors\n-  //\n-\n-  /**\n-   * Returns a live view of the nodes which have an incident edge in common with {@code node} in\n-   * this graph.\n-   *\n-   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n-   *       involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  Set<N> adjacentNodes(N node);\n-\n   /**\n-   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n-   * traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n-   *       involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   * Returns a live view of this graph as a {@link Network} whose edges {@code E} are {@code\n+   * EndpointPair<N>} objects (that is, a {@code Network<N, EndpointPair<N>>}). The resulting {@code\n+   * Network}'s edge-oriented methods (such as {@code inEdges()}) will return views transformed from\n+   * the corresponding node-oriented methods (such as {@code predecessors()}).\n+   *\n+   * <p>This capability facilitates writing implementations of <a\n+   * href=\"https://github.com/google/guava/wiki/GraphsExplained#graph-types-for-algorithms\">edge-oriented\n+   * code</a>.\n    */\n-  @Override\n-  Set<N> predecessors(N node);\n+  Network<N, EndpointPair<N>> asNetwork();\n \n-  /**\n-   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n-   * traversing {@code node}'s outgoing edges in the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n-   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.\n-   *\n-   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n-   *       involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  @Override\n-  Set<N> successors(N node);\n+  //\n+  // Element-level accessors\n+  //\n \n   /**\n    * Returns a live view of the edges in this graph whose endpoints include {@code node}.\n@@ -161,64 +78,4 @@ interface BaseGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n    * @since 24.0\n    */\n   Set<EndpointPair<N>> incidentEdges(N node);\n-\n-  /**\n-   * Returns the count of {@code node}'s incident edges, counting self-loops twice (equivalently,\n-   * the number of times an edge touches {@code node}).\n-   *\n-   * <p>For directed graphs, this is equal to {@code inDegree(node) + outDegree(node)}.\n-   *\n-   * <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of\n-   * self-loops incident to {@code node}).\n-   *\n-   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  int degree(N node);\n-\n-  /**\n-   * Returns the count of {@code node}'s incoming edges (equal to {@code predecessors(node).size()})\n-   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n-   *\n-   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  int inDegree(N node);\n-\n-  /**\n-   * Returns the count of {@code node}'s outgoing edges (equal to {@code successors(node).size()})\n-   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n-   *\n-   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  int outDegree(N node);\n-\n-  /**\n-   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n-   * equivalent to {@code nodes().contains(nodeU) && successors(nodeU).contains(nodeV)}.\n-   *\n-   * <p>In an undirected graph, this is equal to {@code hasEdgeConnecting(nodeV, nodeU)}.\n-   *\n-   * @since 23.0\n-   */\n-  boolean hasEdgeConnecting(N nodeU, N nodeV);\n-\n-  /**\n-   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n-   * any, specified by {@code endpoints}). This is equivalent to {@code\n-   * edges().contains(endpoints)}.\n-   *\n-   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n-   * endpoints are unordered; it simply returns false. This is for consistency with the behavior of\n-   * {@link Collection#contains(Object)} (which does not generally throw if the object cannot be\n-   * present in the collection), and the desire to have this method's behavior be compatible with\n-   * {@code edges().contains(endpoints)}.\n-   *\n-   * @since 27.1\n-   */\n-  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n }"
    },
    {
      "filename": "guava/src/com/google/common/graph/Graphs.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -367,7 +367,7 @@ public Set<N> successors(N node) {\n \n     @Override\n     public Set<EndpointPair<N>> incidentEdges(N node) {\n-      return new IncidentEdgeSet<N>(this, node) {\n+      return new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.BOTH) {\n         @Override\n         public Iterator<EndpointPair<N>> iterator() {\n           return Iterators.transform("
    },
    {
      "filename": "guava/src/com/google/common/graph/IncidentEdgeSet.java",
      "status": "modified",
      "additions": 44,
      "deletions": 14,
      "changes": 58,
      "patch": "@@ -16,6 +16,7 @@\n \n package com.google.common.graph;\n \n+import com.google.common.collect.ImmutableSet;\n import java.util.AbstractSet;\n import java.util.Set;\n import org.jspecify.annotations.Nullable;\n@@ -26,11 +27,19 @@\n  */\n abstract class IncidentEdgeSet<N> extends AbstractSet<EndpointPair<N>> {\n   final N node;\n-  final BaseGraph<N> graph;\n+  final ArchetypeGraph<N> graph;\n+  final EdgeType edgeType;\n \n-  IncidentEdgeSet(BaseGraph<N> graph, N node) {\n+  enum EdgeType {\n+    INCOMING, // incoming incident edges only\n+    OUTGOING, // outgoing incident edges only\n+    BOTH // both incoming and outgoing incident edges\n+  }\n+\n+  IncidentEdgeSet(ArchetypeGraph<N> graph, N node, EdgeType edgeType) {\n     this.graph = graph;\n     this.node = node;\n+    this.edgeType = edgeType;\n   }\n \n   @Override\n@@ -41,9 +50,9 @@ public boolean remove(@Nullable Object o) {\n   @Override\n   public int size() {\n     if (graph.isDirected()) {\n-      return graph.inDegree(node)\n-          + graph.outDegree(node)\n-          - (graph.successors(node).contains(node) ? 1 : 0);\n+      return predecessorsOrEmpty(node).size()\n+          + successorsOrEmpty(node).size()\n+          - (edgeType == EdgeType.BOTH && predecessorsOrEmpty(node).contains(node) ? 1 : 0);\n     } else {\n       return graph.adjacentNodes(node).size();\n     }\n@@ -56,19 +65,16 @@ public boolean contains(@Nullable Object obj) {\n     }\n     EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n \n-    if (graph.isDirected()) {\n-      if (!endpointPair.isOrdered()) {\n-        return false;\n-      }\n+    if (graph.isDirected() != endpointPair.isOrdered()) {\n+      return false;\n+    }\n \n+    if (graph.isDirected()) {\n       Object source = endpointPair.source();\n       Object target = endpointPair.target();\n-      return (node.equals(source) && graph.successors(node).contains(target))\n-          || (node.equals(target) && graph.predecessors(node).contains(source));\n+      return (node.equals(source) && successorsOrEmpty(node).contains(target))\n+          || (node.equals(target) && predecessorsOrEmpty(node).contains(source));\n     } else {\n-      if (endpointPair.isOrdered()) {\n-        return false;\n-      }\n       Set<N> adjacent = graph.adjacentNodes(node);\n       Object nodeU = endpointPair.nodeU();\n       Object nodeV = endpointPair.nodeV();\n@@ -77,4 +83,28 @@ public boolean contains(@Nullable Object obj) {\n           || (node.equals(nodeU) && adjacent.contains(nodeV));\n     }\n   }\n+\n+  /**\n+   * Returns the predecessors of the given node, or an empty set if this set does not represent\n+   * incoming edges.\n+   */\n+  private Set<N> predecessorsOrEmpty(N node) {\n+    if (edgeType == EdgeType.INCOMING || edgeType == EdgeType.BOTH) {\n+      return graph.predecessors(node);\n+    } else {\n+      return ImmutableSet.of();\n+    }\n+  }\n+\n+  /**\n+   * Returns the successors of the given node, or an empty set if this set does not represent\n+   * outgoing edges.\n+   */\n+  private Set<N> successorsOrEmpty(N node) {\n+    if (edgeType == EdgeType.OUTGOING || edgeType == EdgeType.BOTH) {\n+      return graph.successors(node);\n+    } else {\n+      return ImmutableSet.of();\n+    }\n+  }\n }"
    },
    {
      "filename": "guava/src/com/google/common/graph/Network.java",
      "status": "modified",
      "additions": 6,
      "deletions": 84,
      "changes": 90,
      "patch": "@@ -106,14 +106,11 @@\n  */\n @Beta\n @DoNotMock(\"Use NetworkBuilder to create a real instance\")\n-public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n+public interface Network<N, E> extends ArchetypeGraph<N> {\n   //\n   // Network-level accessors\n   //\n \n-  /** Returns all nodes in this network, in the order specified by {@link #nodeOrder()}. */\n-  Set<N> nodes();\n-\n   /** Returns all edges in this network, in the order specified by {@link #edgeOrder()}. */\n   Set<E> edges();\n \n@@ -131,99 +128,19 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n   // Network properties\n   //\n \n-  /**\n-   * Returns true if the edges in this network are directed. Directed edges connect a {@link\n-   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n-   * undirected edges connect a pair of nodes to each other.\n-   */\n-  boolean isDirected();\n-\n   /**\n    * Returns true if this network allows parallel edges. Attempting to add a parallel edge to a\n    * network that does not allow them will throw an {@link IllegalArgumentException}.\n    */\n   boolean allowsParallelEdges();\n \n-  /**\n-   * Returns true if this network allows self-loops (edges that connect a node to itself).\n-   * Attempting to add a self-loop to a network that does not allow them will throw an {@link\n-   * IllegalArgumentException}.\n-   */\n-  boolean allowsSelfLoops();\n-\n-  /** Returns the order of iteration for the elements of {@link #nodes()}. */\n-  ElementOrder<N> nodeOrder();\n-\n   /** Returns the order of iteration for the elements of {@link #edges()}. */\n   ElementOrder<E> edgeOrder();\n \n   //\n   // Element-level accessors\n   //\n \n-  /**\n-   * Returns a live view of the nodes which have an incident edge in common with {@code node} in\n-   * this graph.\n-   *\n-   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the network after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}\n-   *       expression involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this network\n-   */\n-  Set<N> adjacentNodes(N node);\n-\n-  /**\n-   * Returns a live view of all nodes in this network adjacent to {@code node} which can be reached\n-   * by traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected network, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the network after this method is called, the {@code Set}\n-   * returned by this method will be invalidated, and will throw {@code IllegalStateException} if it\n-   * is accessed in any way.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this network\n-   */\n-  @Override\n-  Set<N> predecessors(N node);\n-\n-  /**\n-   * Returns a live view of all nodes in this network adjacent to {@code node} which can be reached\n-   * by traversing {@code node}'s outgoing edges in the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected network, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n-   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.\n-   *\n-   * <p>If {@code node} is removed from the network after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}\n-   *       expression involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this network\n-   */\n-  @Override\n-  Set<N> successors(N node);\n-\n   /**\n    * Returns a live view of the edges whose {@link #incidentNodes(Object) incident nodes} in this\n    * network include {@code node}.\n@@ -308,6 +225,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @throws IllegalArgumentException if {@code node} is not an element of this network\n    */\n+   @Override\n   int degree(N node);\n \n   /**\n@@ -318,6 +236,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @throws IllegalArgumentException if {@code node} is not an element of this network\n    */\n+  @Override\n   int inDegree(N node);\n \n   /**\n@@ -328,6 +247,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @throws IllegalArgumentException if {@code node} is not an element of this network\n    */\n+  @Override\n   int outDegree(N node);\n \n   /**\n@@ -482,6 +402,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @since 23.0\n    */\n+  @Override\n   boolean hasEdgeConnecting(N nodeU, N nodeV);\n \n   /**\n@@ -495,6 +416,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @since 27.1\n    */\n+   @Override\n   boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n \n   //"
    },
    {
      "filename": "guava/src/com/google/common/graph/StandardValueGraph.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -119,7 +119,7 @@ public Set<N> successors(N node) {\n   public Set<EndpointPair<N>> incidentEdges(N node) {\n     GraphConnections<N, V> connections = checkedConnections(node);\n     IncidentEdgeSet<N> incident =\n-        new IncidentEdgeSet<N>(this, node) {\n+        new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.BOTH) {\n           @Override\n           public Iterator<EndpointPair<N>> iterator() {\n             return connections.incidentEdgeIterator(node);"
    }
  ],
  "diff": "diff --git a/android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java b/android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java\nindex bcf9cf6d7680..071b040d8e9b 100644\n--- a/android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java\n+++ b/android/guava-tests/test/com/google/common/graph/AbstractGraphTest.java\n@@ -121,6 +121,17 @@ static <N> void validateGraph(Graph<N> graph) {\n     int edgeStart = graphString.indexOf(\"edges:\");\n     String nodeString = graphString.substring(nodeStart, edgeStart);\n \n+    Network<N, EndpointPair<N>> asNetwork = graph.asNetwork();\n+    // Don't call AbstractNetworkTest.validateNetwork(asNetwork).  Mutual recursion.\n+    assertThat(graph.nodes()).isEqualTo(asNetwork.nodes());\n+    assertThat(graph.edges()).hasSize(asNetwork.edges().size());\n+    assertThat(graph.nodeOrder()).isEqualTo(asNetwork.nodeOrder());\n+    assertThat(graph.isDirected()).isEqualTo(asNetwork.isDirected());\n+    assertThat(graph.allowsSelfLoops()).isEqualTo(asNetwork.allowsSelfLoops());\n+    assertThat(asNetwork.edgeOrder()).isEqualTo(ElementOrder.unordered());\n+    assertThat(asNetwork.allowsParallelEdges()).isFalse();\n+    assertThat(asNetwork.asGraph()).isEqualTo(graph);\n+\n     Set<EndpointPair<N>> allEndpointPairs = new HashSet<>();\n \n     for (N node : sanityCheckSet(graph.nodes())) {\ndiff --git a/android/guava-tests/test/com/google/common/graph/ValueGraphTest.java b/android/guava-tests/test/com/google/common/graph/ValueGraphTest.java\nindex b549a392c1fc..94dbafd74215 100644\n--- a/android/guava-tests/test/com/google/common/graph/ValueGraphTest.java\n+++ b/android/guava-tests/test/com/google/common/graph/ValueGraphTest.java\n@@ -58,6 +58,17 @@ public void validateGraphState() {\n     assertThat(graph.isDirected()).isEqualTo(asGraph.isDirected());\n     assertThat(graph.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n \n+    Network<Integer, EndpointPair<Integer>> asNetwork = graph.asNetwork();\n+    AbstractNetworkTest.validateNetwork(asNetwork);\n+    assertThat(graph.nodes()).isEqualTo(asNetwork.nodes());\n+    assertThat(graph.edges()).hasSize(asNetwork.edges().size());\n+    assertThat(graph.nodeOrder()).isEqualTo(asNetwork.nodeOrder());\n+    assertThat(graph.isDirected()).isEqualTo(asNetwork.isDirected());\n+    assertThat(graph.allowsSelfLoops()).isEqualTo(asNetwork.allowsSelfLoops());\n+    assertThat(asNetwork.edgeOrder()).isEqualTo(ElementOrder.unordered());\n+    assertThat(asNetwork.allowsParallelEdges()).isFalse();\n+    assertThat(asNetwork.asGraph()).isEqualTo(graph.asGraph());\n+\n     for (Integer node : graph.nodes()) {\n       assertThat(graph.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n       assertThat(graph.predecessors(node)).isEqualTo(asGraph.predecessors(node));\ndiff --git a/android/guava/src/com/google/common/graph/AbstractBaseGraph.java b/android/guava/src/com/google/common/graph/AbstractBaseGraph.java\nindex 9ce3838947b8..c1ec51da5c5a 100644\n--- a/android/guava/src/com/google/common/graph/AbstractBaseGraph.java\n+++ b/android/guava/src/com/google/common/graph/AbstractBaseGraph.java\n@@ -108,7 +108,7 @@ public Set<EndpointPair<N>> incidentEdges(N node) {\n     checkNotNull(node);\n     checkArgument(nodes().contains(node), \"Node %s is not an element of this graph.\", node);\n     IncidentEdgeSet<N> incident =\n-        new IncidentEdgeSet<N>(this, node) {\n+        new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.BOTH) {\n           @Override\n           public UnmodifiableIterator<EndpointPair<N>> iterator() {\n             if (graph.isDirected()) {\n@@ -172,6 +172,137 @@ public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n     return nodes().contains(nodeU) && successors(nodeU).contains(nodeV);\n   }\n \n+  @Override\n+  public Network<N, EndpointPair<N>> asNetwork() {\n+    return new AbstractNetwork<N, EndpointPair<N>>() {\n+      @Override\n+      public Set<N> nodes() {\n+        return AbstractBaseGraph.this.nodes();\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> edges() {\n+        return AbstractBaseGraph.this.edges();\n+      }\n+\n+      @Override\n+      public Graph<N> asGraph() {\n+        if (AbstractBaseGraph.this instanceof Graph) {\n+          return (Graph<N>) AbstractBaseGraph.this;\n+        } else if (AbstractBaseGraph.this instanceof ValueGraph) {\n+          return ((ValueGraph<N, ?>) AbstractBaseGraph.this).asGraph();\n+        }\n+        throw new UnsupportedOperationException(\n+            \"Unexpected graph type: \" + AbstractBaseGraph.this.getClass());\n+      }\n+\n+      @Override\n+      public boolean isDirected() {\n+        return AbstractBaseGraph.this.isDirected();\n+      }\n+\n+      @Override\n+      public boolean allowsParallelEdges() {\n+        return false; // Graph doesn't allow parallel edges\n+      }\n+\n+      @Override\n+      public boolean allowsSelfLoops() {\n+        return AbstractBaseGraph.this.allowsSelfLoops();\n+      }\n+\n+      @Override\n+      public ElementOrder<N> nodeOrder() {\n+        return AbstractBaseGraph.this.nodeOrder();\n+      }\n+\n+      @Override\n+      public ElementOrder<EndpointPair<N>> edgeOrder() {\n+        return ElementOrder.unordered(); // Graph doesn't define edge order\n+      }\n+\n+      @Override\n+      public Set<N> adjacentNodes(N node) {\n+        return AbstractBaseGraph.this.adjacentNodes(node);\n+      }\n+\n+      @Override\n+      public Set<N> predecessors(N node) {\n+        return AbstractBaseGraph.this.predecessors(node);\n+      }\n+\n+      @Override\n+      public Set<N> successors(N node) {\n+        return AbstractBaseGraph.this.successors(node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> incidentEdges(N node) {\n+        return AbstractBaseGraph.this.incidentEdges(node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> inEdges(N node) {\n+        checkNotNull(node);\n+        checkArgument(nodes().contains(node));\n+        IncidentEdgeSet<N> incident =\n+            new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.INCOMING) {\n+              @Override\n+              public UnmodifiableIterator<EndpointPair<N>> iterator() {\n+                return Iterators.unmodifiableIterator(\n+                    Iterators.transform(\n+                        graph.predecessors(node).iterator(),\n+                        (N predecessor) ->\n+                            graph.isDirected()\n+                                ? EndpointPair.ordered(predecessor, node)\n+                                : EndpointPair.unordered(predecessor, node)));\n+              }\n+            };\n+        return nodeInvalidatableSet(incident, node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> outEdges(N node) {\n+        checkNotNull(node);\n+        checkArgument(nodes().contains(node));\n+        IncidentEdgeSet<N> incident =\n+            new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.OUTGOING) {\n+              @Override\n+              public UnmodifiableIterator<EndpointPair<N>> iterator() {\n+                return Iterators.unmodifiableIterator(\n+                    Iterators.transform(\n+                        graph.successors(node).iterator(),\n+                        (N successor) ->\n+                            graph.isDirected()\n+                                ? EndpointPair.ordered(node, successor)\n+                                : EndpointPair.unordered(node, successor)));\n+              }\n+            };\n+        return nodeInvalidatableSet(incident, node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> adjacentEdges(EndpointPair<N> edge) {\n+        checkArgument(edges().contains(edge));\n+        N nodeU = edge.nodeU();\n+        N nodeV = edge.nodeV();\n+        Set<EndpointPair<N>> endpointPairIncidentEdges =\n+            Sets.union(incidentEdges(nodeU), incidentEdges(nodeV));\n+        return nodePairInvalidatableSet(\n+            Sets.difference(endpointPairIncidentEdges, ImmutableSet.of(edge)), nodeU, nodeV);\n+      }\n+\n+      @Override\n+      public EndpointPair<N> incidentNodes(EndpointPair<N> edge) {\n+        checkArgument(edges().contains(edge));\n+        return edge;\n+      }\n+\n+      // Don't override the existing edge[s]Connecting() or *degree() AbstractNetwork\n+      // implementations; they call in/outEdges() and should be fine.\n+    };\n+  }\n+\n   /**\n    * Throws {@code IllegalArgumentException} if the ordering of {@code endpoints} is not compatible\n    * with the directionality of this graph.\ndiff --git a/android/guava/src/com/google/common/graph/ArchetypeGraph.java b/android/guava/src/com/google/common/graph/ArchetypeGraph.java\nnew file mode 100644\nindex 000000000000..bbbefe6103d7\n--- /dev/null\n+++ b/android/guava/src/com/google/common/graph/ArchetypeGraph.java\n@@ -0,0 +1,191 @@\n+/*\n+ * Copyright (C) 2017 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.common.graph;\n+\n+import java.util.Set;\n+\n+/**\n+ * A non-public interface for the methods shared between {@link Graph}, {@link ValueGraph}, and\n+ * {@link Network}.\n+ *\n+ * @author Joshua O'Madadhain\n+ * @param <N> Node parameter type\n+ */\n+interface ArchetypeGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n+  //\n+  // Graph-level accessors\n+  //\n+\n+  /** Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}. */\n+  Set<N> nodes();\n+\n+  //\n+  // Graph properties\n+  //\n+\n+  /**\n+   * Returns true if the edges in this graph are directed. Directed edges connect a {@link\n+   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n+   * undirected edges connect a pair of nodes to each other.\n+   */\n+  boolean isDirected();\n+\n+  /**\n+   * Returns true if this graph allows self-loops (edges that connect a node to itself). Attempting\n+   * to add a self-loop to a graph that does not allow them will throw an {@link\n+   * IllegalArgumentException}.\n+   */\n+  boolean allowsSelfLoops();\n+\n+  /** Returns the order of iteration for the elements of {@link #nodes()}. */\n+  ElementOrder<N> nodeOrder();\n+\n+  //\n+  // Element-level accessors\n+  //\n+\n+  /**\n+   * Returns a live view of the nodes which have an incident edge in common with {@code node} in\n+   * this graph.\n+   *\n+   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.\n+   *\n+   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n+   * {@code view} returned by this method will be invalidated, and will throw {@code\n+   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n+   *\n+   * <ul>\n+   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n+   *       involving {@code view} will throw)\n+   *   <li>{@code hashCode()} does not throw\n+   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n+   *       behavior is undefined\n+   * </ul>\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  Set<N> adjacentNodes(N node);\n+\n+  /**\n+   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n+   * traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n+   *\n+   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n+   *\n+   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n+   * {@code view} returned by this method will be invalidated, and will throw {@code\n+   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n+   *\n+   * <ul>\n+   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n+   *       involving {@code view} will throw)\n+   *   <li>{@code hashCode()} does not throw\n+   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n+   *       behavior is undefined\n+   * </ul>\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  @Override\n+  Set<N> predecessors(N node);\n+\n+  /**\n+   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n+   * traversing {@code node}'s outgoing edges in the direction (if any) of the edge.\n+   *\n+   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n+   *\n+   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n+   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.\n+   *\n+   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n+   * {@code view} returned by this method will be invalidated, and will throw {@code\n+   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n+   *\n+   * <ul>\n+   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n+   *       involving {@code view} will throw)\n+   *   <li>{@code hashCode()} does not throw\n+   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n+   *       behavior is undefined\n+   * </ul>\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  @Override\n+  Set<N> successors(N node);\n+\n+  /**\n+   * Returns the count of {@code node}'s incident edges, counting self-loops twice (equivalently,\n+   * the number of times an edge touches {@code node}).\n+   *\n+   * <p>For directed graphs, this is equal to {@code inDegree(node) + outDegree(node)}.\n+   *\n+   * <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of\n+   * self-loops incident to {@code node}).\n+   *\n+   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  int degree(N node);\n+\n+  /**\n+   * Returns the count of {@code node}'s incoming edges (equal to {@code predecessors(node).size()})\n+   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n+   *\n+   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  int inDegree(N node);\n+\n+  /**\n+   * Returns the count of {@code node}'s outgoing edges (equal to {@code successors(node).size()})\n+   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n+   *\n+   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  int outDegree(N node);\n+\n+  /**\n+   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n+   * equivalent to {@code nodes().contains(nodeU) && successors(nodeU).contains(nodeV)}.\n+   *\n+   * <p>In an undirected graph, this is equal to {@code hasEdgeConnecting(nodeV, nodeU)}.\n+   *\n+   * @since 23.0\n+   */\n+  boolean hasEdgeConnecting(N nodeU, N nodeV);\n+\n+  /**\n+   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n+   * any, specified by {@code endpoints}). This is equivalent to {@code\n+   * edges().contains(endpoints)}.\n+   *\n+   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n+   * endpoints are unordered; it simply returns false. This is for consistency with the behavior of\n+   * {@link Collection#contains(Object)} (which does not generally throw if the object cannot be\n+   * present in the collection), and the desire to have this method's behavior be compatible with\n+   * {@code edges().contains(endpoints)}.\n+   *\n+   * @since 27.1\n+   */\n+  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n+}\ndiff --git a/android/guava/src/com/google/common/graph/BaseGraph.java b/android/guava/src/com/google/common/graph/BaseGraph.java\nindex a451989e712b..4d41f389f81a 100644\n--- a/android/guava/src/com/google/common/graph/BaseGraph.java\n+++ b/android/guava/src/com/google/common/graph/BaseGraph.java\n@@ -24,38 +24,14 @@\n  * @author James Sexton\n  * @param <N> Node parameter type\n  */\n-interface BaseGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n+interface BaseGraph<N> extends ArchetypeGraph<N> {\n   //\n   // Graph-level accessors\n   //\n \n-  /** Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}. */\n-  Set<N> nodes();\n-\n   /** Returns all edges in this graph. */\n   Set<EndpointPair<N>> edges();\n \n-  //\n-  // Graph properties\n-  //\n-\n-  /**\n-   * Returns true if the edges in this graph are directed. Directed edges connect a {@link\n-   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n-   * undirected edges connect a pair of nodes to each other.\n-   */\n-  boolean isDirected();\n-\n-  /**\n-   * Returns true if this graph allows self-loops (edges that connect a node to itself). Attempting\n-   * to add a self-loop to a graph that does not allow them will throw an {@link\n-   * IllegalArgumentException}.\n-   */\n-  boolean allowsSelfLoops();\n-\n-  /** Returns the order of iteration for the elements of {@link #nodes()}. */\n-  ElementOrder<N> nodeOrder();\n-\n   /**\n    * Returns an {@link ElementOrder} that specifies the order of iteration for the elements of\n    * {@link #edges()}, {@link #adjacentNodes(Object)}, {@link #predecessors(Object)}, {@link\n@@ -65,80 +41,21 @@ interface BaseGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n    */\n   ElementOrder<N> incidentEdgeOrder();\n \n-  //\n-  // Element-level accessors\n-  //\n-\n-  /**\n-   * Returns a live view of the nodes which have an incident edge in common with {@code node} in\n-   * this graph.\n-   *\n-   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n-   *       involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  Set<N> adjacentNodes(N node);\n-\n   /**\n-   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n-   * traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n-   *       involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   * Returns a live view of this graph as a {@link Network} whose edges {@code E} are {@code\n+   * EndpointPair<N>} objects (that is, a {@code Network<N, EndpointPair<N>>}). The resulting {@code\n+   * Network}'s edge-oriented methods (such as {@code inEdges()}) will return views transformed from\n+   * the corresponding node-oriented methods (such as {@code predecessors()}).\n+   *\n+   * <p>This capability facilitates writing implementations of <a\n+   * href=\"https://github.com/google/guava/wiki/GraphsExplained#graph-types-for-algorithms\">edge-oriented\n+   * code</a>.\n    */\n-  @Override\n-  Set<N> predecessors(N node);\n+  Network<N, EndpointPair<N>> asNetwork();\n \n-  /**\n-   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n-   * traversing {@code node}'s outgoing edges in the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n-   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.\n-   *\n-   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n-   *       involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  @Override\n-  Set<N> successors(N node);\n+  //\n+  // Element-level accessors\n+  //\n \n   /**\n    * Returns a live view of the edges in this graph whose endpoints include {@code node}.\n@@ -161,64 +78,4 @@ interface BaseGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n    * @since 24.0\n    */\n   Set<EndpointPair<N>> incidentEdges(N node);\n-\n-  /**\n-   * Returns the count of {@code node}'s incident edges, counting self-loops twice (equivalently,\n-   * the number of times an edge touches {@code node}).\n-   *\n-   * <p>For directed graphs, this is equal to {@code inDegree(node) + outDegree(node)}.\n-   *\n-   * <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of\n-   * self-loops incident to {@code node}).\n-   *\n-   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  int degree(N node);\n-\n-  /**\n-   * Returns the count of {@code node}'s incoming edges (equal to {@code predecessors(node).size()})\n-   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n-   *\n-   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  int inDegree(N node);\n-\n-  /**\n-   * Returns the count of {@code node}'s outgoing edges (equal to {@code successors(node).size()})\n-   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n-   *\n-   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  int outDegree(N node);\n-\n-  /**\n-   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n-   * equivalent to {@code nodes().contains(nodeU) && successors(nodeU).contains(nodeV)}.\n-   *\n-   * <p>In an undirected graph, this is equal to {@code hasEdgeConnecting(nodeV, nodeU)}.\n-   *\n-   * @since 23.0\n-   */\n-  boolean hasEdgeConnecting(N nodeU, N nodeV);\n-\n-  /**\n-   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n-   * any, specified by {@code endpoints}). This is equivalent to {@code\n-   * edges().contains(endpoints)}.\n-   *\n-   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n-   * endpoints are unordered; it simply returns false. This is for consistency with the behavior of\n-   * {@link Collection#contains(Object)} (which does not generally throw if the object cannot be\n-   * present in the collection), and the desire to have this method's behavior be compatible with\n-   * {@code edges().contains(endpoints)}.\n-   *\n-   * @since 27.1\n-   */\n-  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n }\ndiff --git a/android/guava/src/com/google/common/graph/Graphs.java b/android/guava/src/com/google/common/graph/Graphs.java\nindex ead5bdc90f87..fd24df13fe85 100644\n--- a/android/guava/src/com/google/common/graph/Graphs.java\n+++ b/android/guava/src/com/google/common/graph/Graphs.java\n@@ -366,7 +366,7 @@ public Set<N> successors(N node) {\n \n     @Override\n     public Set<EndpointPair<N>> incidentEdges(N node) {\n-      return new IncidentEdgeSet<N>(this, node) {\n+      return new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.BOTH) {\n         @Override\n         public Iterator<EndpointPair<N>> iterator() {\n           return Iterators.transform(\ndiff --git a/android/guava/src/com/google/common/graph/IncidentEdgeSet.java b/android/guava/src/com/google/common/graph/IncidentEdgeSet.java\nindex 19e882e0e84b..50153d8d24f9 100644\n--- a/android/guava/src/com/google/common/graph/IncidentEdgeSet.java\n+++ b/android/guava/src/com/google/common/graph/IncidentEdgeSet.java\n@@ -16,6 +16,7 @@\n \n package com.google.common.graph;\n \n+import com.google.common.collect.ImmutableSet;\n import java.util.AbstractSet;\n import java.util.Set;\n import org.jspecify.annotations.Nullable;\n@@ -26,11 +27,19 @@\n  */\n abstract class IncidentEdgeSet<N> extends AbstractSet<EndpointPair<N>> {\n   final N node;\n-  final BaseGraph<N> graph;\n+  final ArchetypeGraph<N> graph;\n+  final EdgeType edgeType;\n \n-  IncidentEdgeSet(BaseGraph<N> graph, N node) {\n+  enum EdgeType {\n+    INCOMING, // incoming incident edges only\n+    OUTGOING, // outgoing incident edges only\n+    BOTH // both incoming and outgoing incident edges\n+  }\n+\n+  IncidentEdgeSet(ArchetypeGraph<N> graph, N node, EdgeType edgeType) {\n     this.graph = graph;\n     this.node = node;\n+    this.edgeType = edgeType;\n   }\n \n   @Override\n@@ -41,9 +50,9 @@ public boolean remove(@Nullable Object o) {\n   @Override\n   public int size() {\n     if (graph.isDirected()) {\n-      return graph.inDegree(node)\n-          + graph.outDegree(node)\n-          - (graph.successors(node).contains(node) ? 1 : 0);\n+      return predecessorsOrEmpty(node).size()\n+          + successorsOrEmpty(node).size()\n+          - (edgeType == EdgeType.BOTH && predecessorsOrEmpty(node).contains(node) ? 1 : 0);\n     } else {\n       return graph.adjacentNodes(node).size();\n     }\n@@ -56,19 +65,16 @@ public boolean contains(@Nullable Object obj) {\n     }\n     EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n \n-    if (graph.isDirected()) {\n-      if (!endpointPair.isOrdered()) {\n-        return false;\n-      }\n+    if (graph.isDirected() != endpointPair.isOrdered()) {\n+      return false;\n+    }\n \n+    if (graph.isDirected()) {\n       Object source = endpointPair.source();\n       Object target = endpointPair.target();\n-      return (node.equals(source) && graph.successors(node).contains(target))\n-          || (node.equals(target) && graph.predecessors(node).contains(source));\n+      return (node.equals(source) && successorsOrEmpty(node).contains(target))\n+          || (node.equals(target) && predecessorsOrEmpty(node).contains(source));\n     } else {\n-      if (endpointPair.isOrdered()) {\n-        return false;\n-      }\n       Set<N> adjacent = graph.adjacentNodes(node);\n       Object nodeU = endpointPair.nodeU();\n       Object nodeV = endpointPair.nodeV();\n@@ -77,4 +83,28 @@ public boolean contains(@Nullable Object obj) {\n           || (node.equals(nodeU) && adjacent.contains(nodeV));\n     }\n   }\n+\n+  /**\n+   * Returns the predecessors of the given node, or an empty set if this set does not represent\n+   * incoming edges.\n+   */\n+  private Set<N> predecessorsOrEmpty(N node) {\n+    if (edgeType == EdgeType.INCOMING || edgeType == EdgeType.BOTH) {\n+      return graph.predecessors(node);\n+    } else {\n+      return ImmutableSet.of();\n+    }\n+  }\n+\n+  /**\n+   * Returns the successors of the given node, or an empty set if this set does not represent\n+   * outgoing edges.\n+   */\n+  private Set<N> successorsOrEmpty(N node) {\n+    if (edgeType == EdgeType.OUTGOING || edgeType == EdgeType.BOTH) {\n+      return graph.successors(node);\n+    } else {\n+      return ImmutableSet.of();\n+    }\n+  }\n }\ndiff --git a/android/guava/src/com/google/common/graph/Network.java b/android/guava/src/com/google/common/graph/Network.java\nindex 1368c4a062d7..42fec77e34d5 100644\n--- a/android/guava/src/com/google/common/graph/Network.java\n+++ b/android/guava/src/com/google/common/graph/Network.java\n@@ -105,14 +105,11 @@\n  */\n @Beta\n @DoNotMock(\"Use NetworkBuilder to create a real instance\")\n-public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n+public interface Network<N, E> extends ArchetypeGraph<N> {\n   //\n   // Network-level accessors\n   //\n \n-  /** Returns all nodes in this network, in the order specified by {@link #nodeOrder()}. */\n-  Set<N> nodes();\n-\n   /** Returns all edges in this network, in the order specified by {@link #edgeOrder()}. */\n   Set<E> edges();\n \n@@ -130,29 +127,12 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n   // Network properties\n   //\n \n-  /**\n-   * Returns true if the edges in this network are directed. Directed edges connect a {@link\n-   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n-   * undirected edges connect a pair of nodes to each other.\n-   */\n-  boolean isDirected();\n-\n   /**\n    * Returns true if this network allows parallel edges. Attempting to add a parallel edge to a\n    * network that does not allow them will throw an {@link IllegalArgumentException}.\n    */\n   boolean allowsParallelEdges();\n \n-  /**\n-   * Returns true if this network allows self-loops (edges that connect a node to itself).\n-   * Attempting to add a self-loop to a network that does not allow them will throw an {@link\n-   * IllegalArgumentException}.\n-   */\n-  boolean allowsSelfLoops();\n-\n-  /** Returns the order of iteration for the elements of {@link #nodes()}. */\n-  ElementOrder<N> nodeOrder();\n-\n   /** Returns the order of iteration for the elements of {@link #edges()}. */\n   ElementOrder<E> edgeOrder();\n \n@@ -160,69 +140,6 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n   // Element-level accessors\n   //\n \n-  /**\n-   * Returns a live view of the nodes which have an incident edge in common with {@code node} in\n-   * this network.\n-   *\n-   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the network after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}\n-   *       expression involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this network\n-   */\n-  Set<N> adjacentNodes(N node);\n-\n-  /**\n-   * Returns a live view of all nodes in this network adjacent to {@code node} which can be reached\n-   * by traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected network, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the network after this method is called, the {@code Set}\n-   * returned by this method will be invalidated, and will throw {@code IllegalStateException} if it\n-   * is accessed in any way.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this network\n-   */\n-  @Override\n-  Set<N> predecessors(N node);\n-\n-  /**\n-   * Returns a live view of all nodes in this network adjacent to {@code node} which can be reached\n-   * by traversing {@code node}'s outgoing edges in the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected network, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n-   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.\n-   *\n-   * <p>If {@code node} is removed from the network after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}\n-   *       expression involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this network\n-   */\n-  @Override\n-  Set<N> successors(N node);\n-\n   /**\n    * Returns a live view of the edges whose {@link #incidentNodes(Object) incident nodes} in this\n    * network include {@code node}.\n@@ -307,6 +224,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @throws IllegalArgumentException if {@code node} is not an element of this network\n    */\n+  @Override\n   int degree(N node);\n \n   /**\n@@ -317,6 +235,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @throws IllegalArgumentException if {@code node} is not an element of this network\n    */\n+  @Override\n   int inDegree(N node);\n \n   /**\n@@ -327,6 +246,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @throws IllegalArgumentException if {@code node} is not an element of this network\n    */\n+  @Override\n   int outDegree(N node);\n \n   /**\n@@ -452,6 +372,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @since 23.0\n    */\n+  @Override\n   boolean hasEdgeConnecting(N nodeU, N nodeV);\n \n   /**\n@@ -465,6 +386,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @since 27.1\n    */\n+  @Override\n   boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n \n   //\ndiff --git a/android/guava/src/com/google/common/graph/StandardValueGraph.java b/android/guava/src/com/google/common/graph/StandardValueGraph.java\nindex 568f0f63274d..12a5183d1827 100644\n--- a/android/guava/src/com/google/common/graph/StandardValueGraph.java\n+++ b/android/guava/src/com/google/common/graph/StandardValueGraph.java\n@@ -119,7 +119,7 @@ public Set<N> successors(N node) {\n   public Set<EndpointPair<N>> incidentEdges(N node) {\n     GraphConnections<N, V> connections = checkedConnections(node);\n     IncidentEdgeSet<N> incident =\n-        new IncidentEdgeSet<N>(this, node) {\n+        new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.BOTH) {\n           @Override\n           public Iterator<EndpointPair<N>> iterator() {\n             return connections.incidentEdgeIterator(node);\ndiff --git a/guava-tests/test/com/google/common/graph/AbstractGraphTest.java b/guava-tests/test/com/google/common/graph/AbstractGraphTest.java\nindex bcf9cf6d7680..071b040d8e9b 100644\n--- a/guava-tests/test/com/google/common/graph/AbstractGraphTest.java\n+++ b/guava-tests/test/com/google/common/graph/AbstractGraphTest.java\n@@ -121,6 +121,17 @@ static <N> void validateGraph(Graph<N> graph) {\n     int edgeStart = graphString.indexOf(\"edges:\");\n     String nodeString = graphString.substring(nodeStart, edgeStart);\n \n+    Network<N, EndpointPair<N>> asNetwork = graph.asNetwork();\n+    // Don't call AbstractNetworkTest.validateNetwork(asNetwork).  Mutual recursion.\n+    assertThat(graph.nodes()).isEqualTo(asNetwork.nodes());\n+    assertThat(graph.edges()).hasSize(asNetwork.edges().size());\n+    assertThat(graph.nodeOrder()).isEqualTo(asNetwork.nodeOrder());\n+    assertThat(graph.isDirected()).isEqualTo(asNetwork.isDirected());\n+    assertThat(graph.allowsSelfLoops()).isEqualTo(asNetwork.allowsSelfLoops());\n+    assertThat(asNetwork.edgeOrder()).isEqualTo(ElementOrder.unordered());\n+    assertThat(asNetwork.allowsParallelEdges()).isFalse();\n+    assertThat(asNetwork.asGraph()).isEqualTo(graph);\n+\n     Set<EndpointPair<N>> allEndpointPairs = new HashSet<>();\n \n     for (N node : sanityCheckSet(graph.nodes())) {\ndiff --git a/guava-tests/test/com/google/common/graph/ValueGraphTest.java b/guava-tests/test/com/google/common/graph/ValueGraphTest.java\nindex b71db5d0be99..e13d0662ed34 100644\n--- a/guava-tests/test/com/google/common/graph/ValueGraphTest.java\n+++ b/guava-tests/test/com/google/common/graph/ValueGraphTest.java\n@@ -58,6 +58,17 @@ public void validateGraphState() {\n     assertThat(graph.isDirected()).isEqualTo(asGraph.isDirected());\n     assertThat(graph.allowsSelfLoops()).isEqualTo(asGraph.allowsSelfLoops());\n \n+    Network<Integer, EndpointPair<Integer>> asNetwork = graph.asNetwork();\n+    AbstractNetworkTest.validateNetwork(asNetwork);\n+    assertThat(graph.nodes()).isEqualTo(asNetwork.nodes());\n+    assertThat(graph.edges()).hasSize(asNetwork.edges().size());\n+    assertThat(graph.nodeOrder()).isEqualTo(asNetwork.nodeOrder());\n+    assertThat(graph.isDirected()).isEqualTo(asNetwork.isDirected());\n+    assertThat(graph.allowsSelfLoops()).isEqualTo(asNetwork.allowsSelfLoops());\n+    assertThat(asNetwork.edgeOrder()).isEqualTo(ElementOrder.unordered());\n+    assertThat(asNetwork.allowsParallelEdges()).isFalse();\n+    assertThat(asNetwork.asGraph()).isEqualTo(graph.asGraph());\n+\n     for (Integer node : graph.nodes()) {\n       assertThat(graph.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));\n       assertThat(graph.predecessors(node)).isEqualTo(asGraph.predecessors(node));\ndiff --git a/guava/src/com/google/common/graph/AbstractBaseGraph.java b/guava/src/com/google/common/graph/AbstractBaseGraph.java\nindex 9ce3838947b8..c1ec51da5c5a 100644\n--- a/guava/src/com/google/common/graph/AbstractBaseGraph.java\n+++ b/guava/src/com/google/common/graph/AbstractBaseGraph.java\n@@ -108,7 +108,7 @@ public Set<EndpointPair<N>> incidentEdges(N node) {\n     checkNotNull(node);\n     checkArgument(nodes().contains(node), \"Node %s is not an element of this graph.\", node);\n     IncidentEdgeSet<N> incident =\n-        new IncidentEdgeSet<N>(this, node) {\n+        new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.BOTH) {\n           @Override\n           public UnmodifiableIterator<EndpointPair<N>> iterator() {\n             if (graph.isDirected()) {\n@@ -172,6 +172,137 @@ public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n     return nodes().contains(nodeU) && successors(nodeU).contains(nodeV);\n   }\n \n+  @Override\n+  public Network<N, EndpointPair<N>> asNetwork() {\n+    return new AbstractNetwork<N, EndpointPair<N>>() {\n+      @Override\n+      public Set<N> nodes() {\n+        return AbstractBaseGraph.this.nodes();\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> edges() {\n+        return AbstractBaseGraph.this.edges();\n+      }\n+\n+      @Override\n+      public Graph<N> asGraph() {\n+        if (AbstractBaseGraph.this instanceof Graph) {\n+          return (Graph<N>) AbstractBaseGraph.this;\n+        } else if (AbstractBaseGraph.this instanceof ValueGraph) {\n+          return ((ValueGraph<N, ?>) AbstractBaseGraph.this).asGraph();\n+        }\n+        throw new UnsupportedOperationException(\n+            \"Unexpected graph type: \" + AbstractBaseGraph.this.getClass());\n+      }\n+\n+      @Override\n+      public boolean isDirected() {\n+        return AbstractBaseGraph.this.isDirected();\n+      }\n+\n+      @Override\n+      public boolean allowsParallelEdges() {\n+        return false; // Graph doesn't allow parallel edges\n+      }\n+\n+      @Override\n+      public boolean allowsSelfLoops() {\n+        return AbstractBaseGraph.this.allowsSelfLoops();\n+      }\n+\n+      @Override\n+      public ElementOrder<N> nodeOrder() {\n+        return AbstractBaseGraph.this.nodeOrder();\n+      }\n+\n+      @Override\n+      public ElementOrder<EndpointPair<N>> edgeOrder() {\n+        return ElementOrder.unordered(); // Graph doesn't define edge order\n+      }\n+\n+      @Override\n+      public Set<N> adjacentNodes(N node) {\n+        return AbstractBaseGraph.this.adjacentNodes(node);\n+      }\n+\n+      @Override\n+      public Set<N> predecessors(N node) {\n+        return AbstractBaseGraph.this.predecessors(node);\n+      }\n+\n+      @Override\n+      public Set<N> successors(N node) {\n+        return AbstractBaseGraph.this.successors(node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> incidentEdges(N node) {\n+        return AbstractBaseGraph.this.incidentEdges(node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> inEdges(N node) {\n+        checkNotNull(node);\n+        checkArgument(nodes().contains(node));\n+        IncidentEdgeSet<N> incident =\n+            new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.INCOMING) {\n+              @Override\n+              public UnmodifiableIterator<EndpointPair<N>> iterator() {\n+                return Iterators.unmodifiableIterator(\n+                    Iterators.transform(\n+                        graph.predecessors(node).iterator(),\n+                        (N predecessor) ->\n+                            graph.isDirected()\n+                                ? EndpointPair.ordered(predecessor, node)\n+                                : EndpointPair.unordered(predecessor, node)));\n+              }\n+            };\n+        return nodeInvalidatableSet(incident, node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> outEdges(N node) {\n+        checkNotNull(node);\n+        checkArgument(nodes().contains(node));\n+        IncidentEdgeSet<N> incident =\n+            new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.OUTGOING) {\n+              @Override\n+              public UnmodifiableIterator<EndpointPair<N>> iterator() {\n+                return Iterators.unmodifiableIterator(\n+                    Iterators.transform(\n+                        graph.successors(node).iterator(),\n+                        (N successor) ->\n+                            graph.isDirected()\n+                                ? EndpointPair.ordered(node, successor)\n+                                : EndpointPair.unordered(node, successor)));\n+              }\n+            };\n+        return nodeInvalidatableSet(incident, node);\n+      }\n+\n+      @Override\n+      public Set<EndpointPair<N>> adjacentEdges(EndpointPair<N> edge) {\n+        checkArgument(edges().contains(edge));\n+        N nodeU = edge.nodeU();\n+        N nodeV = edge.nodeV();\n+        Set<EndpointPair<N>> endpointPairIncidentEdges =\n+            Sets.union(incidentEdges(nodeU), incidentEdges(nodeV));\n+        return nodePairInvalidatableSet(\n+            Sets.difference(endpointPairIncidentEdges, ImmutableSet.of(edge)), nodeU, nodeV);\n+      }\n+\n+      @Override\n+      public EndpointPair<N> incidentNodes(EndpointPair<N> edge) {\n+        checkArgument(edges().contains(edge));\n+        return edge;\n+      }\n+\n+      // Don't override the existing edge[s]Connecting() or *degree() AbstractNetwork\n+      // implementations; they call in/outEdges() and should be fine.\n+    };\n+  }\n+\n   /**\n    * Throws {@code IllegalArgumentException} if the ordering of {@code endpoints} is not compatible\n    * with the directionality of this graph.\ndiff --git a/guava/src/com/google/common/graph/ArchetypeGraph.java b/guava/src/com/google/common/graph/ArchetypeGraph.java\nnew file mode 100644\nindex 000000000000..bbbefe6103d7\n--- /dev/null\n+++ b/guava/src/com/google/common/graph/ArchetypeGraph.java\n@@ -0,0 +1,191 @@\n+/*\n+ * Copyright (C) 2017 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.common.graph;\n+\n+import java.util.Set;\n+\n+/**\n+ * A non-public interface for the methods shared between {@link Graph}, {@link ValueGraph}, and\n+ * {@link Network}.\n+ *\n+ * @author Joshua O'Madadhain\n+ * @param <N> Node parameter type\n+ */\n+interface ArchetypeGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n+  //\n+  // Graph-level accessors\n+  //\n+\n+  /** Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}. */\n+  Set<N> nodes();\n+\n+  //\n+  // Graph properties\n+  //\n+\n+  /**\n+   * Returns true if the edges in this graph are directed. Directed edges connect a {@link\n+   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n+   * undirected edges connect a pair of nodes to each other.\n+   */\n+  boolean isDirected();\n+\n+  /**\n+   * Returns true if this graph allows self-loops (edges that connect a node to itself). Attempting\n+   * to add a self-loop to a graph that does not allow them will throw an {@link\n+   * IllegalArgumentException}.\n+   */\n+  boolean allowsSelfLoops();\n+\n+  /** Returns the order of iteration for the elements of {@link #nodes()}. */\n+  ElementOrder<N> nodeOrder();\n+\n+  //\n+  // Element-level accessors\n+  //\n+\n+  /**\n+   * Returns a live view of the nodes which have an incident edge in common with {@code node} in\n+   * this graph.\n+   *\n+   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.\n+   *\n+   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n+   * {@code view} returned by this method will be invalidated, and will throw {@code\n+   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n+   *\n+   * <ul>\n+   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n+   *       involving {@code view} will throw)\n+   *   <li>{@code hashCode()} does not throw\n+   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n+   *       behavior is undefined\n+   * </ul>\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  Set<N> adjacentNodes(N node);\n+\n+  /**\n+   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n+   * traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n+   *\n+   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n+   *\n+   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n+   * {@code view} returned by this method will be invalidated, and will throw {@code\n+   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n+   *\n+   * <ul>\n+   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n+   *       involving {@code view} will throw)\n+   *   <li>{@code hashCode()} does not throw\n+   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n+   *       behavior is undefined\n+   * </ul>\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  @Override\n+  Set<N> predecessors(N node);\n+\n+  /**\n+   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n+   * traversing {@code node}'s outgoing edges in the direction (if any) of the edge.\n+   *\n+   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n+   *\n+   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n+   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.\n+   *\n+   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n+   * {@code view} returned by this method will be invalidated, and will throw {@code\n+   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n+   *\n+   * <ul>\n+   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n+   *       involving {@code view} will throw)\n+   *   <li>{@code hashCode()} does not throw\n+   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n+   *       behavior is undefined\n+   * </ul>\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  @Override\n+  Set<N> successors(N node);\n+\n+  /**\n+   * Returns the count of {@code node}'s incident edges, counting self-loops twice (equivalently,\n+   * the number of times an edge touches {@code node}).\n+   *\n+   * <p>For directed graphs, this is equal to {@code inDegree(node) + outDegree(node)}.\n+   *\n+   * <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of\n+   * self-loops incident to {@code node}).\n+   *\n+   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  int degree(N node);\n+\n+  /**\n+   * Returns the count of {@code node}'s incoming edges (equal to {@code predecessors(node).size()})\n+   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n+   *\n+   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  int inDegree(N node);\n+\n+  /**\n+   * Returns the count of {@code node}'s outgoing edges (equal to {@code successors(node).size()})\n+   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n+   *\n+   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n+   *\n+   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   */\n+  int outDegree(N node);\n+\n+  /**\n+   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n+   * equivalent to {@code nodes().contains(nodeU) && successors(nodeU).contains(nodeV)}.\n+   *\n+   * <p>In an undirected graph, this is equal to {@code hasEdgeConnecting(nodeV, nodeU)}.\n+   *\n+   * @since 23.0\n+   */\n+  boolean hasEdgeConnecting(N nodeU, N nodeV);\n+\n+  /**\n+   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n+   * any, specified by {@code endpoints}). This is equivalent to {@code\n+   * edges().contains(endpoints)}.\n+   *\n+   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n+   * endpoints are unordered; it simply returns false. This is for consistency with the behavior of\n+   * {@link Collection#contains(Object)} (which does not generally throw if the object cannot be\n+   * present in the collection), and the desire to have this method's behavior be compatible with\n+   * {@code edges().contains(endpoints)}.\n+   *\n+   * @since 27.1\n+   */\n+  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n+}\ndiff --git a/guava/src/com/google/common/graph/BaseGraph.java b/guava/src/com/google/common/graph/BaseGraph.java\nindex a451989e712b..4d41f389f81a 100644\n--- a/guava/src/com/google/common/graph/BaseGraph.java\n+++ b/guava/src/com/google/common/graph/BaseGraph.java\n@@ -24,38 +24,14 @@\n  * @author James Sexton\n  * @param <N> Node parameter type\n  */\n-interface BaseGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n+interface BaseGraph<N> extends ArchetypeGraph<N> {\n   //\n   // Graph-level accessors\n   //\n \n-  /** Returns all nodes in this graph, in the order specified by {@link #nodeOrder()}. */\n-  Set<N> nodes();\n-\n   /** Returns all edges in this graph. */\n   Set<EndpointPair<N>> edges();\n \n-  //\n-  // Graph properties\n-  //\n-\n-  /**\n-   * Returns true if the edges in this graph are directed. Directed edges connect a {@link\n-   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n-   * undirected edges connect a pair of nodes to each other.\n-   */\n-  boolean isDirected();\n-\n-  /**\n-   * Returns true if this graph allows self-loops (edges that connect a node to itself). Attempting\n-   * to add a self-loop to a graph that does not allow them will throw an {@link\n-   * IllegalArgumentException}.\n-   */\n-  boolean allowsSelfLoops();\n-\n-  /** Returns the order of iteration for the elements of {@link #nodes()}. */\n-  ElementOrder<N> nodeOrder();\n-\n   /**\n    * Returns an {@link ElementOrder} that specifies the order of iteration for the elements of\n    * {@link #edges()}, {@link #adjacentNodes(Object)}, {@link #predecessors(Object)}, {@link\n@@ -65,80 +41,21 @@ interface BaseGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n    */\n   ElementOrder<N> incidentEdgeOrder();\n \n-  //\n-  // Element-level accessors\n-  //\n-\n-  /**\n-   * Returns a live view of the nodes which have an incident edge in common with {@code node} in\n-   * this graph.\n-   *\n-   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n-   *       involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  Set<N> adjacentNodes(N node);\n-\n   /**\n-   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n-   * traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n-   *       involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n+   * Returns a live view of this graph as a {@link Network} whose edges {@code E} are {@code\n+   * EndpointPair<N>} objects (that is, a {@code Network<N, EndpointPair<N>>}). The resulting {@code\n+   * Network}'s edge-oriented methods (such as {@code inEdges()}) will return views transformed from\n+   * the corresponding node-oriented methods (such as {@code predecessors()}).\n+   *\n+   * <p>This capability facilitates writing implementations of <a\n+   * href=\"https://github.com/google/guava/wiki/GraphsExplained#graph-types-for-algorithms\">edge-oriented\n+   * code</a>.\n    */\n-  @Override\n-  Set<N> predecessors(N node);\n+  Network<N, EndpointPair<N>> asNetwork();\n \n-  /**\n-   * Returns a live view of all nodes in this graph adjacent to {@code node} which can be reached by\n-   * traversing {@code node}'s outgoing edges in the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected graph, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n-   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.\n-   *\n-   * <p>If {@code node} is removed from the graph after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other `equals()` expression\n-   *       involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the graph after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  @Override\n-  Set<N> successors(N node);\n+  //\n+  // Element-level accessors\n+  //\n \n   /**\n    * Returns a live view of the edges in this graph whose endpoints include {@code node}.\n@@ -161,64 +78,4 @@ interface BaseGraph<N> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n    * @since 24.0\n    */\n   Set<EndpointPair<N>> incidentEdges(N node);\n-\n-  /**\n-   * Returns the count of {@code node}'s incident edges, counting self-loops twice (equivalently,\n-   * the number of times an edge touches {@code node}).\n-   *\n-   * <p>For directed graphs, this is equal to {@code inDegree(node) + outDegree(node)}.\n-   *\n-   * <p>For undirected graphs, this is equal to {@code incidentEdges(node).size()} + (number of\n-   * self-loops incident to {@code node}).\n-   *\n-   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  int degree(N node);\n-\n-  /**\n-   * Returns the count of {@code node}'s incoming edges (equal to {@code predecessors(node).size()})\n-   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n-   *\n-   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  int inDegree(N node);\n-\n-  /**\n-   * Returns the count of {@code node}'s outgoing edges (equal to {@code successors(node).size()})\n-   * in a directed graph. In an undirected graph, returns the {@link #degree(Object)}.\n-   *\n-   * <p>If the count is greater than {@code Integer.MAX_VALUE}, returns {@code Integer.MAX_VALUE}.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this graph\n-   */\n-  int outDegree(N node);\n-\n-  /**\n-   * Returns true if there is an edge that directly connects {@code nodeU} to {@code nodeV}. This is\n-   * equivalent to {@code nodes().contains(nodeU) && successors(nodeU).contains(nodeV)}.\n-   *\n-   * <p>In an undirected graph, this is equal to {@code hasEdgeConnecting(nodeV, nodeU)}.\n-   *\n-   * @since 23.0\n-   */\n-  boolean hasEdgeConnecting(N nodeU, N nodeV);\n-\n-  /**\n-   * Returns true if there is an edge that directly connects {@code endpoints} (in the order, if\n-   * any, specified by {@code endpoints}). This is equivalent to {@code\n-   * edges().contains(endpoints)}.\n-   *\n-   * <p>Unlike the other {@code EndpointPair}-accepting methods, this method does not throw if the\n-   * endpoints are unordered; it simply returns false. This is for consistency with the behavior of\n-   * {@link Collection#contains(Object)} (which does not generally throw if the object cannot be\n-   * present in the collection), and the desire to have this method's behavior be compatible with\n-   * {@code edges().contains(endpoints)}.\n-   *\n-   * @since 27.1\n-   */\n-  boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n }\ndiff --git a/guava/src/com/google/common/graph/Graphs.java b/guava/src/com/google/common/graph/Graphs.java\nindex ee54e392c1de..4966ed62b30d 100644\n--- a/guava/src/com/google/common/graph/Graphs.java\n+++ b/guava/src/com/google/common/graph/Graphs.java\n@@ -367,7 +367,7 @@ public Set<N> successors(N node) {\n \n     @Override\n     public Set<EndpointPair<N>> incidentEdges(N node) {\n-      return new IncidentEdgeSet<N>(this, node) {\n+      return new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.BOTH) {\n         @Override\n         public Iterator<EndpointPair<N>> iterator() {\n           return Iterators.transform(\ndiff --git a/guava/src/com/google/common/graph/IncidentEdgeSet.java b/guava/src/com/google/common/graph/IncidentEdgeSet.java\nindex 19e882e0e84b..50153d8d24f9 100644\n--- a/guava/src/com/google/common/graph/IncidentEdgeSet.java\n+++ b/guava/src/com/google/common/graph/IncidentEdgeSet.java\n@@ -16,6 +16,7 @@\n \n package com.google.common.graph;\n \n+import com.google.common.collect.ImmutableSet;\n import java.util.AbstractSet;\n import java.util.Set;\n import org.jspecify.annotations.Nullable;\n@@ -26,11 +27,19 @@\n  */\n abstract class IncidentEdgeSet<N> extends AbstractSet<EndpointPair<N>> {\n   final N node;\n-  final BaseGraph<N> graph;\n+  final ArchetypeGraph<N> graph;\n+  final EdgeType edgeType;\n \n-  IncidentEdgeSet(BaseGraph<N> graph, N node) {\n+  enum EdgeType {\n+    INCOMING, // incoming incident edges only\n+    OUTGOING, // outgoing incident edges only\n+    BOTH // both incoming and outgoing incident edges\n+  }\n+\n+  IncidentEdgeSet(ArchetypeGraph<N> graph, N node, EdgeType edgeType) {\n     this.graph = graph;\n     this.node = node;\n+    this.edgeType = edgeType;\n   }\n \n   @Override\n@@ -41,9 +50,9 @@ public boolean remove(@Nullable Object o) {\n   @Override\n   public int size() {\n     if (graph.isDirected()) {\n-      return graph.inDegree(node)\n-          + graph.outDegree(node)\n-          - (graph.successors(node).contains(node) ? 1 : 0);\n+      return predecessorsOrEmpty(node).size()\n+          + successorsOrEmpty(node).size()\n+          - (edgeType == EdgeType.BOTH && predecessorsOrEmpty(node).contains(node) ? 1 : 0);\n     } else {\n       return graph.adjacentNodes(node).size();\n     }\n@@ -56,19 +65,16 @@ public boolean contains(@Nullable Object obj) {\n     }\n     EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n \n-    if (graph.isDirected()) {\n-      if (!endpointPair.isOrdered()) {\n-        return false;\n-      }\n+    if (graph.isDirected() != endpointPair.isOrdered()) {\n+      return false;\n+    }\n \n+    if (graph.isDirected()) {\n       Object source = endpointPair.source();\n       Object target = endpointPair.target();\n-      return (node.equals(source) && graph.successors(node).contains(target))\n-          || (node.equals(target) && graph.predecessors(node).contains(source));\n+      return (node.equals(source) && successorsOrEmpty(node).contains(target))\n+          || (node.equals(target) && predecessorsOrEmpty(node).contains(source));\n     } else {\n-      if (endpointPair.isOrdered()) {\n-        return false;\n-      }\n       Set<N> adjacent = graph.adjacentNodes(node);\n       Object nodeU = endpointPair.nodeU();\n       Object nodeV = endpointPair.nodeV();\n@@ -77,4 +83,28 @@ public boolean contains(@Nullable Object obj) {\n           || (node.equals(nodeU) && adjacent.contains(nodeV));\n     }\n   }\n+\n+  /**\n+   * Returns the predecessors of the given node, or an empty set if this set does not represent\n+   * incoming edges.\n+   */\n+  private Set<N> predecessorsOrEmpty(N node) {\n+    if (edgeType == EdgeType.INCOMING || edgeType == EdgeType.BOTH) {\n+      return graph.predecessors(node);\n+    } else {\n+      return ImmutableSet.of();\n+    }\n+  }\n+\n+  /**\n+   * Returns the successors of the given node, or an empty set if this set does not represent\n+   * outgoing edges.\n+   */\n+  private Set<N> successorsOrEmpty(N node) {\n+    if (edgeType == EdgeType.OUTGOING || edgeType == EdgeType.BOTH) {\n+      return graph.successors(node);\n+    } else {\n+      return ImmutableSet.of();\n+    }\n+  }\n }\ndiff --git a/guava/src/com/google/common/graph/Network.java b/guava/src/com/google/common/graph/Network.java\nindex 80c4d5c135b5..a87bc6c6cd54 100644\n--- a/guava/src/com/google/common/graph/Network.java\n+++ b/guava/src/com/google/common/graph/Network.java\n@@ -106,14 +106,11 @@\n  */\n @Beta\n @DoNotMock(\"Use NetworkBuilder to create a real instance\")\n-public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFunction<N> {\n+public interface Network<N, E> extends ArchetypeGraph<N> {\n   //\n   // Network-level accessors\n   //\n \n-  /** Returns all nodes in this network, in the order specified by {@link #nodeOrder()}. */\n-  Set<N> nodes();\n-\n   /** Returns all edges in this network, in the order specified by {@link #edgeOrder()}. */\n   Set<E> edges();\n \n@@ -131,29 +128,12 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n   // Network properties\n   //\n \n-  /**\n-   * Returns true if the edges in this network are directed. Directed edges connect a {@link\n-   * EndpointPair#source() source node} to a {@link EndpointPair#target() target node}, while\n-   * undirected edges connect a pair of nodes to each other.\n-   */\n-  boolean isDirected();\n-\n   /**\n    * Returns true if this network allows parallel edges. Attempting to add a parallel edge to a\n    * network that does not allow them will throw an {@link IllegalArgumentException}.\n    */\n   boolean allowsParallelEdges();\n \n-  /**\n-   * Returns true if this network allows self-loops (edges that connect a node to itself).\n-   * Attempting to add a self-loop to a network that does not allow them will throw an {@link\n-   * IllegalArgumentException}.\n-   */\n-  boolean allowsSelfLoops();\n-\n-  /** Returns the order of iteration for the elements of {@link #nodes()}. */\n-  ElementOrder<N> nodeOrder();\n-\n   /** Returns the order of iteration for the elements of {@link #edges()}. */\n   ElementOrder<E> edgeOrder();\n \n@@ -161,69 +141,6 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n   // Element-level accessors\n   //\n \n-  /**\n-   * Returns a live view of the nodes which have an incident edge in common with {@code node} in\n-   * this graph.\n-   *\n-   * <p>This is equal to the union of {@link #predecessors(Object)} and {@link #successors(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the network after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}\n-   *       expression involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this network\n-   */\n-  Set<N> adjacentNodes(N node);\n-\n-  /**\n-   * Returns a live view of all nodes in this network adjacent to {@code node} which can be reached\n-   * by traversing {@code node}'s incoming edges <i>against</i> the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected network, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>If {@code node} is removed from the network after this method is called, the {@code Set}\n-   * returned by this method will be invalidated, and will throw {@code IllegalStateException} if it\n-   * is accessed in any way.\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this network\n-   */\n-  @Override\n-  Set<N> predecessors(N node);\n-\n-  /**\n-   * Returns a live view of all nodes in this network adjacent to {@code node} which can be reached\n-   * by traversing {@code node}'s outgoing edges in the direction (if any) of the edge.\n-   *\n-   * <p>In an undirected network, this is equivalent to {@link #adjacentNodes(Object)}.\n-   *\n-   * <p>This is <i>not</i> the same as \"all nodes reachable from {@code node} by following outgoing\n-   * edges\". For that functionality, see {@link Graphs#reachableNodes(Graph, Object)}.\n-   *\n-   * <p>If {@code node} is removed from the network after this method is called, the {@code Set}\n-   * {@code view} returned by this method will be invalidated, and will throw {@code\n-   * IllegalStateException} if it is accessed in any way, with the following exceptions:\n-   *\n-   * <ul>\n-   *   <li>{@code view.equals(view)} evaluates to {@code true} (but any other {@code equals()}\n-   *       expression involving {@code view} will throw)\n-   *   <li>{@code hashCode()} does not throw\n-   *   <li>if {@code node} is re-added to the network after having been removed, {@code view}'s\n-   *       behavior is undefined\n-   * </ul>\n-   *\n-   * @throws IllegalArgumentException if {@code node} is not an element of this network\n-   */\n-  @Override\n-  Set<N> successors(N node);\n-\n   /**\n    * Returns a live view of the edges whose {@link #incidentNodes(Object) incident nodes} in this\n    * network include {@code node}.\n@@ -308,6 +225,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @throws IllegalArgumentException if {@code node} is not an element of this network\n    */\n+   @Override\n   int degree(N node);\n \n   /**\n@@ -318,6 +236,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @throws IllegalArgumentException if {@code node} is not an element of this network\n    */\n+  @Override\n   int inDegree(N node);\n \n   /**\n@@ -328,6 +247,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @throws IllegalArgumentException if {@code node} is not an element of this network\n    */\n+  @Override\n   int outDegree(N node);\n \n   /**\n@@ -482,6 +402,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @since 23.0\n    */\n+  @Override\n   boolean hasEdgeConnecting(N nodeU, N nodeV);\n \n   /**\n@@ -495,6 +416,7 @@ public interface Network<N, E> extends SuccessorsFunction<N>, PredecessorsFuncti\n    *\n    * @since 27.1\n    */\n+   @Override\n   boolean hasEdgeConnecting(EndpointPair<N> endpoints);\n \n   //\ndiff --git a/guava/src/com/google/common/graph/StandardValueGraph.java b/guava/src/com/google/common/graph/StandardValueGraph.java\nindex 568f0f63274d..12a5183d1827 100644\n--- a/guava/src/com/google/common/graph/StandardValueGraph.java\n+++ b/guava/src/com/google/common/graph/StandardValueGraph.java\n@@ -119,7 +119,7 @@ public Set<N> successors(N node) {\n   public Set<EndpointPair<N>> incidentEdges(N node) {\n     GraphConnections<N, V> connections = checkedConnections(node);\n     IncidentEdgeSet<N> incident =\n-        new IncidentEdgeSet<N>(this, node) {\n+        new IncidentEdgeSet<N>(this, node, IncidentEdgeSet.EdgeType.BOTH) {\n           @Override\n           public Iterator<EndpointPair<N>> iterator() {\n             return connections.incidentEdgeIterator(node);\n",
  "additions": 820,
  "deletions": 514,
  "changed_files": 18,
  "url": "https://github.com/google/guava/pull/8045",
  "mined_at": "2025-10-25T12:50:29.920213"
}