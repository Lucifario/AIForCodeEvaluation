{
  "id": 8031,
  "repository": "google/guava",
  "title": "Call `Thread.stop` reflectively, and fix `MonitorTestCase` to fail in case of an `uncaughtThrowable`.",
  "body": "Call `Thread.stop` reflectively, and fix `MonitorTestCase` to fail in case of an `uncaughtThrowable`.\n\nUnder Java 26, `Thread.stop` is disappearing entirely. We've already seen that it began throwing `UnsupportedOperationException` in Java 20. But for testing under older versions of Java in our open-source repo, it's potentially still useful. (It's probably _not_ useful for Android tests, even [under Marshmallow](https://cs.android.com/android/platform/superproject/+/android-6.0.1_r81:libcore/libart/src/main/java/java/lang/Thread.java;l=1077-1079,1087-1089;drc=3a2414f45502454bdf0a4ff28f50682f72e4f435).)\n\n(Compare https://github.com/google/guava/commit/388e0980dd0c5ad1a407e53c90eb83df44bec31b for `Thread.suspend` and `resume`.)\n\nWhile dealing with that, I thought more about the fact that `TestThread.tearDown` has been throwing `UnsupportedOperationException` under recent Java versions. That means that it doesn't continue on to try to `join()` a thread that might hang forever (good), but it also means that it never gets to check for `uncaughtThrowable` (bad). I addressed that by putting `stop()` and `join()` in a `try`-`catch`.\n\nBut even beyond that, once `TestThread` _does_ check for `uncaughtThrowable` and throw when it finds one, the `AssertionError` would still be being ignored, just as the `UnsupportedOperationException` from `stop()` was being ignored. That happens because `MonitorTestCase` passes `true` for the `suppressThrows` parameter of `TearDownStack`. Oops. I've removed `true` so that we now get [the default behavior, `false`](https://github.com/google/guava/blob/9a179fc66b79c47e5f5d0c59bceb7162e5d2abe2/guava-testlib/src/com/google/common/testing/TearDownStack.java#L53). That would have led to failures back when we were letting the exception from `stop()` propagate, but now it is safe. Thankfully, it doesn't reveal any previously hidden cases in which we had an `uncaughtThrowable`.\n\nRELNOTES=n/a\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-09-29T18:37:47+00:00",
  "created_at": "2025-09-29T18:12:31+00:00",
  "updated_at": "2025-09-29T18:37:48+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "3c0e7045d246aeafa2a12a21c72eb76aa1876768",
  "head_sha": "ae5e4d6f12ba92f90ace3f3d8ade76e0a52d8c24",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava-tests/test/com/google/common/util/concurrent/MonitorTestCase.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -50,7 +50,7 @@ public void setSatisfied(boolean satisfied) {\n \n   private final boolean interruptible;\n   private Monitor monitor;\n-  private final TearDownStack tearDownStack = new TearDownStack(true);\n+  private final TearDownStack tearDownStack = new TearDownStack();\n   private TestThread<Monitor> thread1;\n   private TestThread<Monitor> thread2;\n "
    },
    {
      "filename": "android/guava-tests/test/com/google/common/util/concurrent/TestThread.java",
      "status": "modified",
      "additions": 18,
      "deletions": 7,
      "changes": 25,
      "patch": "@@ -68,15 +68,26 @@ public TestThread(L lockLikeObject, String threadName) {\n     start();\n   }\n \n-  // Thread.stop() is okay because all threads started by a test are dying at the end of the test,\n-  // so there is no object state put at risk by stopping the threads abruptly. In some cases a test\n-  // may put a thread into an uninterruptible operation intentionally, so there is no other way to\n-  // clean up these threads.\n-  @SuppressWarnings(\"deprecation\")\n+  /*\n+   * TODO: b/318391980 - Once we test only under Java 20 and higher, avoid calling Thread.stop. As\n+   * of Java 20, it always throws an exception, and as of Java 26, the method does not even exist.\n+   * For now, we continue using it to clean up under older JDKs.\n+   *\n+   * Our usages should at least be *relatively* safe: Typically, threads started by a test are dying\n+   * at the end of the test, so there is no object state put at risk by stopping the threads\n+   * abruptly. In other cases, a test may put a thread into an uninterruptible operation\n+   * intentionally, so there is no other way to clean up these threads. (The better solution,\n+   * though, would be to run the tests that use TestThread in separate VMs so that their threads\n+   * don't hang around during other tests.)\n+   */\n   @Override\n   public void tearDown() throws Exception {\n-    stop();\n-    join();\n+    try {\n+      Thread.class.getMethod(\"stop\").invoke(this);\n+      join();\n+    } catch (ReflectiveOperationException e) {\n+      // stop() threw or did not exist. Don't join() the thread, which might hang forever.\n+    }\n \n     if (uncaughtThrowable != null) {\n       throw new AssertionError(\"Uncaught throwable in \" + getName(), uncaughtThrowable);"
    },
    {
      "filename": "guava-tests/test/com/google/common/util/concurrent/MonitorTestCase.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -50,7 +50,7 @@ public void setSatisfied(boolean satisfied) {\n \n   private final boolean interruptible;\n   private Monitor monitor;\n-  private final TearDownStack tearDownStack = new TearDownStack(true);\n+  private final TearDownStack tearDownStack = new TearDownStack();\n   private TestThread<Monitor> thread1;\n   private TestThread<Monitor> thread2;\n "
    },
    {
      "filename": "guava-tests/test/com/google/common/util/concurrent/TestThread.java",
      "status": "modified",
      "additions": 18,
      "deletions": 7,
      "changes": 25,
      "patch": "@@ -68,15 +68,26 @@ public TestThread(L lockLikeObject, String threadName) {\n     start();\n   }\n \n-  // Thread.stop() is okay because all threads started by a test are dying at the end of the test,\n-  // so there is no object state put at risk by stopping the threads abruptly. In some cases a test\n-  // may put a thread into an uninterruptible operation intentionally, so there is no other way to\n-  // clean up these threads.\n-  @SuppressWarnings(\"deprecation\")\n+  /*\n+   * TODO: b/318391980 - Once we test only under Java 20 and higher, avoid calling Thread.stop. As\n+   * of Java 20, it always throws an exception, and as of Java 26, the method does not even exist.\n+   * For now, we continue using it to clean up under older JDKs.\n+   *\n+   * Our usages should at least be *relatively* safe: Typically, threads started by a test are dying\n+   * at the end of the test, so there is no object state put at risk by stopping the threads\n+   * abruptly. In other cases, a test may put a thread into an uninterruptible operation\n+   * intentionally, so there is no other way to clean up these threads. (The better solution,\n+   * though, would be to run the tests that use TestThread in separate VMs so that their threads\n+   * don't hang around during other tests.)\n+   */\n   @Override\n   public void tearDown() throws Exception {\n-    stop();\n-    join();\n+    try {\n+      Thread.class.getMethod(\"stop\").invoke(this);\n+      join();\n+    } catch (ReflectiveOperationException e) {\n+      // stop() threw or did not exist. Don't join() the thread, which might hang forever.\n+    }\n \n     if (uncaughtThrowable != null) {\n       throw new AssertionError(\"Uncaught throwable in \" + getName(), uncaughtThrowable);"
    }
  ],
  "diff": "diff --git a/android/guava-tests/test/com/google/common/util/concurrent/MonitorTestCase.java b/android/guava-tests/test/com/google/common/util/concurrent/MonitorTestCase.java\nindex 88299c24c217..ba64f4724c27 100644\n--- a/android/guava-tests/test/com/google/common/util/concurrent/MonitorTestCase.java\n+++ b/android/guava-tests/test/com/google/common/util/concurrent/MonitorTestCase.java\n@@ -50,7 +50,7 @@ public void setSatisfied(boolean satisfied) {\n \n   private final boolean interruptible;\n   private Monitor monitor;\n-  private final TearDownStack tearDownStack = new TearDownStack(true);\n+  private final TearDownStack tearDownStack = new TearDownStack();\n   private TestThread<Monitor> thread1;\n   private TestThread<Monitor> thread2;\n \ndiff --git a/android/guava-tests/test/com/google/common/util/concurrent/TestThread.java b/android/guava-tests/test/com/google/common/util/concurrent/TestThread.java\nindex e183f5b69f07..d2fffefc41b2 100644\n--- a/android/guava-tests/test/com/google/common/util/concurrent/TestThread.java\n+++ b/android/guava-tests/test/com/google/common/util/concurrent/TestThread.java\n@@ -68,15 +68,26 @@ public TestThread(L lockLikeObject, String threadName) {\n     start();\n   }\n \n-  // Thread.stop() is okay because all threads started by a test are dying at the end of the test,\n-  // so there is no object state put at risk by stopping the threads abruptly. In some cases a test\n-  // may put a thread into an uninterruptible operation intentionally, so there is no other way to\n-  // clean up these threads.\n-  @SuppressWarnings(\"deprecation\")\n+  /*\n+   * TODO: b/318391980 - Once we test only under Java 20 and higher, avoid calling Thread.stop. As\n+   * of Java 20, it always throws an exception, and as of Java 26, the method does not even exist.\n+   * For now, we continue using it to clean up under older JDKs.\n+   *\n+   * Our usages should at least be *relatively* safe: Typically, threads started by a test are dying\n+   * at the end of the test, so there is no object state put at risk by stopping the threads\n+   * abruptly. In other cases, a test may put a thread into an uninterruptible operation\n+   * intentionally, so there is no other way to clean up these threads. (The better solution,\n+   * though, would be to run the tests that use TestThread in separate VMs so that their threads\n+   * don't hang around during other tests.)\n+   */\n   @Override\n   public void tearDown() throws Exception {\n-    stop();\n-    join();\n+    try {\n+      Thread.class.getMethod(\"stop\").invoke(this);\n+      join();\n+    } catch (ReflectiveOperationException e) {\n+      // stop() threw or did not exist. Don't join() the thread, which might hang forever.\n+    }\n \n     if (uncaughtThrowable != null) {\n       throw new AssertionError(\"Uncaught throwable in \" + getName(), uncaughtThrowable);\ndiff --git a/guava-tests/test/com/google/common/util/concurrent/MonitorTestCase.java b/guava-tests/test/com/google/common/util/concurrent/MonitorTestCase.java\nindex 317b858c10c4..b1ea51a7c4f9 100644\n--- a/guava-tests/test/com/google/common/util/concurrent/MonitorTestCase.java\n+++ b/guava-tests/test/com/google/common/util/concurrent/MonitorTestCase.java\n@@ -50,7 +50,7 @@ public void setSatisfied(boolean satisfied) {\n \n   private final boolean interruptible;\n   private Monitor monitor;\n-  private final TearDownStack tearDownStack = new TearDownStack(true);\n+  private final TearDownStack tearDownStack = new TearDownStack();\n   private TestThread<Monitor> thread1;\n   private TestThread<Monitor> thread2;\n \ndiff --git a/guava-tests/test/com/google/common/util/concurrent/TestThread.java b/guava-tests/test/com/google/common/util/concurrent/TestThread.java\nindex e183f5b69f07..d2fffefc41b2 100644\n--- a/guava-tests/test/com/google/common/util/concurrent/TestThread.java\n+++ b/guava-tests/test/com/google/common/util/concurrent/TestThread.java\n@@ -68,15 +68,26 @@ public TestThread(L lockLikeObject, String threadName) {\n     start();\n   }\n \n-  // Thread.stop() is okay because all threads started by a test are dying at the end of the test,\n-  // so there is no object state put at risk by stopping the threads abruptly. In some cases a test\n-  // may put a thread into an uninterruptible operation intentionally, so there is no other way to\n-  // clean up these threads.\n-  @SuppressWarnings(\"deprecation\")\n+  /*\n+   * TODO: b/318391980 - Once we test only under Java 20 and higher, avoid calling Thread.stop. As\n+   * of Java 20, it always throws an exception, and as of Java 26, the method does not even exist.\n+   * For now, we continue using it to clean up under older JDKs.\n+   *\n+   * Our usages should at least be *relatively* safe: Typically, threads started by a test are dying\n+   * at the end of the test, so there is no object state put at risk by stopping the threads\n+   * abruptly. In other cases, a test may put a thread into an uninterruptible operation\n+   * intentionally, so there is no other way to clean up these threads. (The better solution,\n+   * though, would be to run the tests that use TestThread in separate VMs so that their threads\n+   * don't hang around during other tests.)\n+   */\n   @Override\n   public void tearDown() throws Exception {\n-    stop();\n-    join();\n+    try {\n+      Thread.class.getMethod(\"stop\").invoke(this);\n+      join();\n+    } catch (ReflectiveOperationException e) {\n+      // stop() threw or did not exist. Don't join() the thread, which might hang forever.\n+    }\n \n     if (uncaughtThrowable != null) {\n       throw new AssertionError(\"Uncaught throwable in \" + getName(), uncaughtThrowable);\n",
  "additions": 38,
  "deletions": 16,
  "changed_files": 4,
  "url": "https://github.com/google/guava/pull/8031",
  "mined_at": "2025-10-25T12:54:14.552067"
}