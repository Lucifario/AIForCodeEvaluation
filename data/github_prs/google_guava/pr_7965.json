{
  "id": 7965,
  "repository": "google/guava",
  "title": "Belatedly tweak `reflect` comments and implementation for dropping support for Java 6 and 7.",
  "body": "Belatedly tweak `reflect` comments and implementation for dropping support for Java 6 and 7.\n\nWe're still constrained by Android.\n\nRELNOTES=n/a\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-09-03T14:03:19+00:00",
  "created_at": "2025-09-03T03:24:15+00:00",
  "updated_at": "2025-09-03T14:03:20+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "f24fd70aa8379f520774b2d842323eae81802835",
  "head_sha": "b08ccaa8a98bbb45f1a6f05b010483f69eccaa51",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava/src/com/google/common/reflect/TypeResolver.java",
      "status": "modified",
      "additions": 9,
      "deletions": 8,
      "changes": 17,
      "patch": "@@ -331,17 +331,18 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n         Type[] resolvedBounds = new TypeResolver(forDependants).resolveTypes(bounds);\n         /*\n          * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's\n-         * just one problem: Starting with JDK 7u51, the JDK TypeVariable's equals() method doesn't\n-         * recognize instances of our TypeVariable implementation. This is a problem because users\n-         * compare TypeVariables from the JDK against TypeVariables returned by TypeResolver. To\n-         * work with all JDK versions, TypeResolver must return the appropriate TypeVariable\n-         * implementation in each of the three possible cases:\n+         * just one problem: Under all the JDK versions that we support (though *not* under\n+         * Android), the built-in TypeVariable's equals() method doesn't recognize instances of our\n+         * TypeVariable implementation. This is a problem because users compare TypeVariables from\n+         * the JDK against TypeVariables returned by TypeResolver. To work with all JDK versions,\n+         * TypeResolver must return the appropriate TypeVariable implementation in each of the three\n+         * possible cases:\n          *\n-         * 1. Prior to JDK 7u51, the JDK TypeVariable implementation interoperates with ours.\n+         * 1. Under Android, the built-in TypeVariable implementation interoperates with ours.\n          * Therefore, we can always create our own TypeVariable.\n          *\n-         * 2. Starting with JDK 7u51, the JDK TypeVariable implementations does not interoperate\n-         * with ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n+         * 2. Under the JDK, the built-in TypeVariable implementation does not interoperate with\n+         * ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n          *\n          * 2a. If the resolved types are identical to the original types, then we can return the\n          * original, identical JDK TypeVariable. By doing so, we sidestep the problem entirely."
    },
    {
      "filename": "android/guava/src/com/google/common/reflect/Types.java",
      "status": "modified",
      "additions": 38,
      "deletions": 29,
      "changes": 67,
      "patch": "@@ -324,30 +324,31 @@ private static <D extends GenericDeclaration> TypeVariable<D> newTypeVariableImp\n   }\n \n   /**\n-   * Invocation handler to work around a compatibility problem between Java 7 and Java 8.\n+   * Invocation handler to work around a compatibility problem between Android and Java.\n    *\n    * <p>Java 8 introduced a new method {@code getAnnotatedBounds()} in the {@link TypeVariable}\n-   * interface, whose return type {@code AnnotatedType[]} is also new in Java 8. That means that we\n-   * cannot implement that interface in source code in a way that will compile on both Java 7 and\n-   * Java 8. If we include the {@code getAnnotatedBounds()} method then its return type means it\n-   * won't compile on Java 7, while if we don't include the method then the compiler will complain\n-   * that an abstract method is unimplemented. So instead we use a dynamic proxy to get an\n-   * implementation. If the method being called on the {@code TypeVariable} instance has the same\n-   * name as one of the public methods of {@link TypeVariableImpl}, the proxy calls the same method\n-   * on its instance of {@code TypeVariableImpl}. Otherwise it throws {@link\n-   * UnsupportedOperationException}; this should only apply to {@code getAnnotatedBounds()}. This\n-   * does mean that users on Java 8 who obtain an instance of {@code TypeVariable} from {@link\n-   * TypeResolver#resolveType} will not be able to call {@code getAnnotatedBounds()} on it, but that\n-   * should hopefully be rare.\n+   * interface, whose return type {@code AnnotatedType[]} is also new in Java 8. As of 2025, Android\n+   * has not added {@link AnnotatedType}. That means that we cannot implement that interface in\n+   * source code in a way that will compile on both Java and Android. If we include the {@code\n+   * getAnnotatedBounds()} method, then its return type means it won't compile on Android, while if\n+   * we don't include the method, then the compiler will complain that an abstract method is\n+   * unimplemented. So instead we use a dynamic proxy to get an implementation. If the method being\n+   * called on the {@code TypeVariable} instance has the same name as one of the public methods of\n+   * {@link TypeVariableImpl}, the proxy calls the same method on its instance of {@code\n+   * TypeVariableImpl}. Otherwise it throws {@link UnsupportedOperationException}; this should only\n+   * apply to {@code getAnnotatedBounds()}. This does mean that users on Java who obtain an instance\n+   * of {@code TypeVariable} from {@link TypeResolver#resolveType} will not be able to call {@code\n+   * getAnnotatedBounds()} on it, but that should hopefully be rare.\n    *\n-   * <p>TODO(b/147144588): We are currently also missing the methods inherited from {@link\n+   * <p>TODO: b/147144588 - We are currently also missing the methods inherited from {@link\n    * AnnotatedElement}, which {@code TypeVariable} began to extend only in Java 8. Those methods\n-   * refer only to types present in Java 7, so we could implement them in {@code TypeVariableImpl}\n-   * today. (We could probably then make {@code TypeVariableImpl} implement {@code AnnotatedElement}\n-   * so that we get partial compile-time checking.)\n+   * refer only to types present under Android, so we could implement them in {@code\n+   * TypeVariableImpl} today. (We could probably then make {@code TypeVariableImpl} implement {@code\n+   * AnnotatedElement} so that we get partial compile-time checking.)\n    *\n-   * <p>This workaround should be removed at a distant future time when we no longer support Java\n-   * versions earlier than 8.\n+   * <p>This workaround should be removed at a distant future time when <a\n+   * href=\"https://issuetracker.google.com/issues/115932459\">Android supports {@code\n+   * AnnotatedType}</a>.\n    */\n   @SuppressWarnings(\"removal\") // b/318391980\n   private static final class TypeVariableInvocationHandler implements InvocationHandler {\n@@ -539,7 +540,10 @@ static Class<?> getArrayClass(Class<?> componentType) {\n     return Array.newInstance(componentType, 0).getClass();\n   }\n \n-  // TODO(benyu): Once behavior is the same for all Java versions we support, delete this.\n+  /*\n+   * TODO(benyu): Once behavior is the same for all Java (and Android) versions we support, delete\n+   * this. It is possible that one or both of JAVA6 and JAVA7 have become unnecessary already.\n+   */\n   enum JavaVersion {\n     JAVA6 {\n       @Override\n@@ -585,16 +589,18 @@ Type usedInGenericType(Type type) {\n         return JAVA7.usedInGenericType(type);\n       }\n \n+      /*\n+       * We use this only when getTypeName is available.\n+       *\n+       * Well, really, we use this when we think we're running under Java 8, as determined by some\n+       * logic in the static initializer, which does not check for getTypeName specifically. We\n+       * should really validate that it works as desired for all Android versions that we support.\n+       */\n+      @IgnoreJRERequirement\n+      @SuppressWarnings(\"AndroidJdkLibsChecker\")\n       @Override\n       String typeName(Type type) {\n-        try {\n-          Method getTypeName = Type.class.getMethod(\"getTypeName\");\n-          return (String) getTypeName.invoke(type);\n-        } catch (NoSuchMethodException e) {\n-          throw new AssertionError(\"Type.getTypeName should be available in Java 8\");\n-        } catch (InvocationTargetException | IllegalAccessException e) {\n-          throw new RuntimeException(e);\n-        }\n+        return type.getTypeName();\n       }\n     },\n     JAVA9 {\n@@ -608,9 +614,11 @@ Type usedInGenericType(Type type) {\n         return JAVA8.usedInGenericType(type);\n       }\n \n+      @IgnoreJRERequirement\n+      @SuppressWarnings(\"AndroidJdkLibsChecker\") // as discussed under JAVA8.typeName\n       @Override\n       String typeName(Type type) {\n-        return JAVA8.typeName(type);\n+        return type.getTypeName();\n       }\n \n       @Override\n@@ -622,6 +630,7 @@ boolean jdkTypeDuplicatesOwnerName() {\n     static final JavaVersion CURRENT;\n \n     static {\n+      // Under Android, TypeVariable does not implement AnnotatedElement even under recent versions.\n       if (AnnotatedElement.class.isAssignableFrom(TypeVariable.class)) {\n         if (new TypeCapture<Entry<String, int[][]>>() {}.capture()\n             .toString()"
    },
    {
      "filename": "guava/src/com/google/common/reflect/TypeResolver.java",
      "status": "modified",
      "additions": 9,
      "deletions": 8,
      "changes": 17,
      "patch": "@@ -331,17 +331,18 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n         Type[] resolvedBounds = new TypeResolver(forDependants).resolveTypes(bounds);\n         /*\n          * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's\n-         * just one problem: Starting with JDK 7u51, the JDK TypeVariable's equals() method doesn't\n-         * recognize instances of our TypeVariable implementation. This is a problem because users\n-         * compare TypeVariables from the JDK against TypeVariables returned by TypeResolver. To\n-         * work with all JDK versions, TypeResolver must return the appropriate TypeVariable\n-         * implementation in each of the three possible cases:\n+         * just one problem: Under all the JDK versions that we support (though *not* under\n+         * Android), the built-in TypeVariable's equals() method doesn't recognize instances of our\n+         * TypeVariable implementation. This is a problem because users compare TypeVariables from\n+         * the JDK against TypeVariables returned by TypeResolver. To work with all JDK versions,\n+         * TypeResolver must return the appropriate TypeVariable implementation in each of the three\n+         * possible cases:\n          *\n-         * 1. Prior to JDK 7u51, the JDK TypeVariable implementation interoperates with ours.\n+         * 1. Under Android, the built-in TypeVariable implementation interoperates with ours.\n          * Therefore, we can always create our own TypeVariable.\n          *\n-         * 2. Starting with JDK 7u51, the JDK TypeVariable implementations does not interoperate\n-         * with ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n+         * 2. Under the JDK, the built-in TypeVariable implementation does not interoperate with\n+         * ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n          *\n          * 2a. If the resolved types are identical to the original types, then we can return the\n          * original, identical JDK TypeVariable. By doing so, we sidestep the problem entirely."
    },
    {
      "filename": "guava/src/com/google/common/reflect/Types.java",
      "status": "modified",
      "additions": 36,
      "deletions": 29,
      "changes": 65,
      "patch": "@@ -324,30 +324,31 @@ private static <D extends GenericDeclaration> TypeVariable<D> newTypeVariableImp\n   }\n \n   /**\n-   * Invocation handler to work around a compatibility problem between Java 7 and Java 8.\n+   * Invocation handler to work around a compatibility problem between Android and Java.\n    *\n    * <p>Java 8 introduced a new method {@code getAnnotatedBounds()} in the {@link TypeVariable}\n-   * interface, whose return type {@code AnnotatedType[]} is also new in Java 8. That means that we\n-   * cannot implement that interface in source code in a way that will compile on both Java 7 and\n-   * Java 8. If we include the {@code getAnnotatedBounds()} method then its return type means it\n-   * won't compile on Java 7, while if we don't include the method then the compiler will complain\n-   * that an abstract method is unimplemented. So instead we use a dynamic proxy to get an\n-   * implementation. If the method being called on the {@code TypeVariable} instance has the same\n-   * name as one of the public methods of {@link TypeVariableImpl}, the proxy calls the same method\n-   * on its instance of {@code TypeVariableImpl}. Otherwise it throws {@link\n-   * UnsupportedOperationException}; this should only apply to {@code getAnnotatedBounds()}. This\n-   * does mean that users on Java 8 who obtain an instance of {@code TypeVariable} from {@link\n-   * TypeResolver#resolveType} will not be able to call {@code getAnnotatedBounds()} on it, but that\n-   * should hopefully be rare.\n+   * interface, whose return type {@code AnnotatedType[]} is also new in Java 8. As of 2025, Android\n+   * has not added {@link AnnotatedType}. That means that we cannot implement that interface in\n+   * source code in a way that will compile on both Java and Android. If we include the {@code\n+   * getAnnotatedBounds()} method, then its return type means it won't compile on Android, while if\n+   * we don't include the method, then the compiler will complain that an abstract method is\n+   * unimplemented. So instead we use a dynamic proxy to get an implementation. If the method being\n+   * called on the {@code TypeVariable} instance has the same name as one of the public methods of\n+   * {@link TypeVariableImpl}, the proxy calls the same method on its instance of {@code\n+   * TypeVariableImpl}. Otherwise it throws {@link UnsupportedOperationException}; this should only\n+   * apply to {@code getAnnotatedBounds()}. This does mean that users on Java who obtain an instance\n+   * of {@code TypeVariable} from {@link TypeResolver#resolveType} will not be able to call {@code\n+   * getAnnotatedBounds()} on it, but that should hopefully be rare.\n    *\n-   * <p>TODO(b/147144588): We are currently also missing the methods inherited from {@link\n+   * <p>TODO: b/147144588 - We are currently also missing the methods inherited from {@link\n    * AnnotatedElement}, which {@code TypeVariable} began to extend only in Java 8. Those methods\n-   * refer only to types present in Java 7, so we could implement them in {@code TypeVariableImpl}\n-   * today. (We could probably then make {@code TypeVariableImpl} implement {@code AnnotatedElement}\n-   * so that we get partial compile-time checking.)\n+   * refer only to types present under Android, so we could implement them in {@code\n+   * TypeVariableImpl} today. (We could probably then make {@code TypeVariableImpl} implement {@code\n+   * AnnotatedElement} so that we get partial compile-time checking.)\n    *\n-   * <p>This workaround should be removed at a distant future time when we no longer support Java\n-   * versions earlier than 8.\n+   * <p>This workaround should be removed at a distant future time when <a\n+   * href=\"https://issuetracker.google.com/issues/115932459\">Android supports {@code\n+   * AnnotatedType}</a>.\n    */\n   @SuppressWarnings(\"removal\") // b/318391980\n   private static final class TypeVariableInvocationHandler implements InvocationHandler {\n@@ -539,7 +540,10 @@ static Class<?> getArrayClass(Class<?> componentType) {\n     return Array.newInstance(componentType, 0).getClass();\n   }\n \n-  // TODO(benyu): Once behavior is the same for all Java versions we support, delete this.\n+  /*\n+   * TODO(benyu): Once behavior is the same for all Java (and Android) versions we support, delete\n+   * this. It is possible that one or both of JAVA6 and JAVA7 have become unnecessary already.\n+   */\n   enum JavaVersion {\n     JAVA6 {\n       @Override\n@@ -585,16 +589,17 @@ Type usedInGenericType(Type type) {\n         return JAVA7.usedInGenericType(type);\n       }\n \n+      /*\n+       * We use this only when getTypeName is available.\n+       *\n+       * Well, really, we use this when we think we're running under Java 8, as determined by some\n+       * logic in the static initializer, which does not check for getTypeName specifically. We\n+       * should really validate that it works as desired for all Android versions that we support.\n+       */\n+      @SuppressWarnings(\"AndroidJdkLibsChecker\")\n       @Override\n       String typeName(Type type) {\n-        try {\n-          Method getTypeName = Type.class.getMethod(\"getTypeName\");\n-          return (String) getTypeName.invoke(type);\n-        } catch (NoSuchMethodException e) {\n-          throw new AssertionError(\"Type.getTypeName should be available in Java 8\");\n-        } catch (InvocationTargetException | IllegalAccessException e) {\n-          throw new RuntimeException(e);\n-        }\n+        return type.getTypeName();\n       }\n     },\n     JAVA9 {\n@@ -608,9 +613,10 @@ Type usedInGenericType(Type type) {\n         return JAVA8.usedInGenericType(type);\n       }\n \n+      @SuppressWarnings(\"AndroidJdkLibsChecker\") // as discussed under JAVA8.typeName\n       @Override\n       String typeName(Type type) {\n-        return JAVA8.typeName(type);\n+        return type.getTypeName();\n       }\n \n       @Override\n@@ -622,6 +628,7 @@ boolean jdkTypeDuplicatesOwnerName() {\n     static final JavaVersion CURRENT;\n \n     static {\n+      // Under Android, TypeVariable does not implement AnnotatedElement even under recent versions.\n       if (AnnotatedElement.class.isAssignableFrom(TypeVariable.class)) {\n         if (new TypeCapture<Entry<String, int[][]>>() {}.capture()\n             .toString()"
    }
  ],
  "diff": "diff --git a/android/guava/src/com/google/common/reflect/TypeResolver.java b/android/guava/src/com/google/common/reflect/TypeResolver.java\nindex f348362f1c03..2055c4340d12 100644\n--- a/android/guava/src/com/google/common/reflect/TypeResolver.java\n+++ b/android/guava/src/com/google/common/reflect/TypeResolver.java\n@@ -331,17 +331,18 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n         Type[] resolvedBounds = new TypeResolver(forDependants).resolveTypes(bounds);\n         /*\n          * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's\n-         * just one problem: Starting with JDK 7u51, the JDK TypeVariable's equals() method doesn't\n-         * recognize instances of our TypeVariable implementation. This is a problem because users\n-         * compare TypeVariables from the JDK against TypeVariables returned by TypeResolver. To\n-         * work with all JDK versions, TypeResolver must return the appropriate TypeVariable\n-         * implementation in each of the three possible cases:\n+         * just one problem: Under all the JDK versions that we support (though *not* under\n+         * Android), the built-in TypeVariable's equals() method doesn't recognize instances of our\n+         * TypeVariable implementation. This is a problem because users compare TypeVariables from\n+         * the JDK against TypeVariables returned by TypeResolver. To work with all JDK versions,\n+         * TypeResolver must return the appropriate TypeVariable implementation in each of the three\n+         * possible cases:\n          *\n-         * 1. Prior to JDK 7u51, the JDK TypeVariable implementation interoperates with ours.\n+         * 1. Under Android, the built-in TypeVariable implementation interoperates with ours.\n          * Therefore, we can always create our own TypeVariable.\n          *\n-         * 2. Starting with JDK 7u51, the JDK TypeVariable implementations does not interoperate\n-         * with ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n+         * 2. Under the JDK, the built-in TypeVariable implementation does not interoperate with\n+         * ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n          *\n          * 2a. If the resolved types are identical to the original types, then we can return the\n          * original, identical JDK TypeVariable. By doing so, we sidestep the problem entirely.\ndiff --git a/android/guava/src/com/google/common/reflect/Types.java b/android/guava/src/com/google/common/reflect/Types.java\nindex e45ac4639fce..0122104712f8 100644\n--- a/android/guava/src/com/google/common/reflect/Types.java\n+++ b/android/guava/src/com/google/common/reflect/Types.java\n@@ -324,30 +324,31 @@ private static <D extends GenericDeclaration> TypeVariable<D> newTypeVariableImp\n   }\n \n   /**\n-   * Invocation handler to work around a compatibility problem between Java 7 and Java 8.\n+   * Invocation handler to work around a compatibility problem between Android and Java.\n    *\n    * <p>Java 8 introduced a new method {@code getAnnotatedBounds()} in the {@link TypeVariable}\n-   * interface, whose return type {@code AnnotatedType[]} is also new in Java 8. That means that we\n-   * cannot implement that interface in source code in a way that will compile on both Java 7 and\n-   * Java 8. If we include the {@code getAnnotatedBounds()} method then its return type means it\n-   * won't compile on Java 7, while if we don't include the method then the compiler will complain\n-   * that an abstract method is unimplemented. So instead we use a dynamic proxy to get an\n-   * implementation. If the method being called on the {@code TypeVariable} instance has the same\n-   * name as one of the public methods of {@link TypeVariableImpl}, the proxy calls the same method\n-   * on its instance of {@code TypeVariableImpl}. Otherwise it throws {@link\n-   * UnsupportedOperationException}; this should only apply to {@code getAnnotatedBounds()}. This\n-   * does mean that users on Java 8 who obtain an instance of {@code TypeVariable} from {@link\n-   * TypeResolver#resolveType} will not be able to call {@code getAnnotatedBounds()} on it, but that\n-   * should hopefully be rare.\n+   * interface, whose return type {@code AnnotatedType[]} is also new in Java 8. As of 2025, Android\n+   * has not added {@link AnnotatedType}. That means that we cannot implement that interface in\n+   * source code in a way that will compile on both Java and Android. If we include the {@code\n+   * getAnnotatedBounds()} method, then its return type means it won't compile on Android, while if\n+   * we don't include the method, then the compiler will complain that an abstract method is\n+   * unimplemented. So instead we use a dynamic proxy to get an implementation. If the method being\n+   * called on the {@code TypeVariable} instance has the same name as one of the public methods of\n+   * {@link TypeVariableImpl}, the proxy calls the same method on its instance of {@code\n+   * TypeVariableImpl}. Otherwise it throws {@link UnsupportedOperationException}; this should only\n+   * apply to {@code getAnnotatedBounds()}. This does mean that users on Java who obtain an instance\n+   * of {@code TypeVariable} from {@link TypeResolver#resolveType} will not be able to call {@code\n+   * getAnnotatedBounds()} on it, but that should hopefully be rare.\n    *\n-   * <p>TODO(b/147144588): We are currently also missing the methods inherited from {@link\n+   * <p>TODO: b/147144588 - We are currently also missing the methods inherited from {@link\n    * AnnotatedElement}, which {@code TypeVariable} began to extend only in Java 8. Those methods\n-   * refer only to types present in Java 7, so we could implement them in {@code TypeVariableImpl}\n-   * today. (We could probably then make {@code TypeVariableImpl} implement {@code AnnotatedElement}\n-   * so that we get partial compile-time checking.)\n+   * refer only to types present under Android, so we could implement them in {@code\n+   * TypeVariableImpl} today. (We could probably then make {@code TypeVariableImpl} implement {@code\n+   * AnnotatedElement} so that we get partial compile-time checking.)\n    *\n-   * <p>This workaround should be removed at a distant future time when we no longer support Java\n-   * versions earlier than 8.\n+   * <p>This workaround should be removed at a distant future time when <a\n+   * href=\"https://issuetracker.google.com/issues/115932459\">Android supports {@code\n+   * AnnotatedType}</a>.\n    */\n   @SuppressWarnings(\"removal\") // b/318391980\n   private static final class TypeVariableInvocationHandler implements InvocationHandler {\n@@ -539,7 +540,10 @@ static Class<?> getArrayClass(Class<?> componentType) {\n     return Array.newInstance(componentType, 0).getClass();\n   }\n \n-  // TODO(benyu): Once behavior is the same for all Java versions we support, delete this.\n+  /*\n+   * TODO(benyu): Once behavior is the same for all Java (and Android) versions we support, delete\n+   * this. It is possible that one or both of JAVA6 and JAVA7 have become unnecessary already.\n+   */\n   enum JavaVersion {\n     JAVA6 {\n       @Override\n@@ -585,16 +589,18 @@ Type usedInGenericType(Type type) {\n         return JAVA7.usedInGenericType(type);\n       }\n \n+      /*\n+       * We use this only when getTypeName is available.\n+       *\n+       * Well, really, we use this when we think we're running under Java 8, as determined by some\n+       * logic in the static initializer, which does not check for getTypeName specifically. We\n+       * should really validate that it works as desired for all Android versions that we support.\n+       */\n+      @IgnoreJRERequirement\n+      @SuppressWarnings(\"AndroidJdkLibsChecker\")\n       @Override\n       String typeName(Type type) {\n-        try {\n-          Method getTypeName = Type.class.getMethod(\"getTypeName\");\n-          return (String) getTypeName.invoke(type);\n-        } catch (NoSuchMethodException e) {\n-          throw new AssertionError(\"Type.getTypeName should be available in Java 8\");\n-        } catch (InvocationTargetException | IllegalAccessException e) {\n-          throw new RuntimeException(e);\n-        }\n+        return type.getTypeName();\n       }\n     },\n     JAVA9 {\n@@ -608,9 +614,11 @@ Type usedInGenericType(Type type) {\n         return JAVA8.usedInGenericType(type);\n       }\n \n+      @IgnoreJRERequirement\n+      @SuppressWarnings(\"AndroidJdkLibsChecker\") // as discussed under JAVA8.typeName\n       @Override\n       String typeName(Type type) {\n-        return JAVA8.typeName(type);\n+        return type.getTypeName();\n       }\n \n       @Override\n@@ -622,6 +630,7 @@ boolean jdkTypeDuplicatesOwnerName() {\n     static final JavaVersion CURRENT;\n \n     static {\n+      // Under Android, TypeVariable does not implement AnnotatedElement even under recent versions.\n       if (AnnotatedElement.class.isAssignableFrom(TypeVariable.class)) {\n         if (new TypeCapture<Entry<String, int[][]>>() {}.capture()\n             .toString()\ndiff --git a/guava/src/com/google/common/reflect/TypeResolver.java b/guava/src/com/google/common/reflect/TypeResolver.java\nindex f348362f1c03..2055c4340d12 100644\n--- a/guava/src/com/google/common/reflect/TypeResolver.java\n+++ b/guava/src/com/google/common/reflect/TypeResolver.java\n@@ -331,17 +331,18 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n         Type[] resolvedBounds = new TypeResolver(forDependants).resolveTypes(bounds);\n         /*\n          * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's\n-         * just one problem: Starting with JDK 7u51, the JDK TypeVariable's equals() method doesn't\n-         * recognize instances of our TypeVariable implementation. This is a problem because users\n-         * compare TypeVariables from the JDK against TypeVariables returned by TypeResolver. To\n-         * work with all JDK versions, TypeResolver must return the appropriate TypeVariable\n-         * implementation in each of the three possible cases:\n+         * just one problem: Under all the JDK versions that we support (though *not* under\n+         * Android), the built-in TypeVariable's equals() method doesn't recognize instances of our\n+         * TypeVariable implementation. This is a problem because users compare TypeVariables from\n+         * the JDK against TypeVariables returned by TypeResolver. To work with all JDK versions,\n+         * TypeResolver must return the appropriate TypeVariable implementation in each of the three\n+         * possible cases:\n          *\n-         * 1. Prior to JDK 7u51, the JDK TypeVariable implementation interoperates with ours.\n+         * 1. Under Android, the built-in TypeVariable implementation interoperates with ours.\n          * Therefore, we can always create our own TypeVariable.\n          *\n-         * 2. Starting with JDK 7u51, the JDK TypeVariable implementations does not interoperate\n-         * with ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n+         * 2. Under the JDK, the built-in TypeVariable implementation does not interoperate with\n+         * ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n          *\n          * 2a. If the resolved types are identical to the original types, then we can return the\n          * original, identical JDK TypeVariable. By doing so, we sidestep the problem entirely.\ndiff --git a/guava/src/com/google/common/reflect/Types.java b/guava/src/com/google/common/reflect/Types.java\nindex e45ac4639fce..209369d017a4 100644\n--- a/guava/src/com/google/common/reflect/Types.java\n+++ b/guava/src/com/google/common/reflect/Types.java\n@@ -324,30 +324,31 @@ private static <D extends GenericDeclaration> TypeVariable<D> newTypeVariableImp\n   }\n \n   /**\n-   * Invocation handler to work around a compatibility problem between Java 7 and Java 8.\n+   * Invocation handler to work around a compatibility problem between Android and Java.\n    *\n    * <p>Java 8 introduced a new method {@code getAnnotatedBounds()} in the {@link TypeVariable}\n-   * interface, whose return type {@code AnnotatedType[]} is also new in Java 8. That means that we\n-   * cannot implement that interface in source code in a way that will compile on both Java 7 and\n-   * Java 8. If we include the {@code getAnnotatedBounds()} method then its return type means it\n-   * won't compile on Java 7, while if we don't include the method then the compiler will complain\n-   * that an abstract method is unimplemented. So instead we use a dynamic proxy to get an\n-   * implementation. If the method being called on the {@code TypeVariable} instance has the same\n-   * name as one of the public methods of {@link TypeVariableImpl}, the proxy calls the same method\n-   * on its instance of {@code TypeVariableImpl}. Otherwise it throws {@link\n-   * UnsupportedOperationException}; this should only apply to {@code getAnnotatedBounds()}. This\n-   * does mean that users on Java 8 who obtain an instance of {@code TypeVariable} from {@link\n-   * TypeResolver#resolveType} will not be able to call {@code getAnnotatedBounds()} on it, but that\n-   * should hopefully be rare.\n+   * interface, whose return type {@code AnnotatedType[]} is also new in Java 8. As of 2025, Android\n+   * has not added {@link AnnotatedType}. That means that we cannot implement that interface in\n+   * source code in a way that will compile on both Java and Android. If we include the {@code\n+   * getAnnotatedBounds()} method, then its return type means it won't compile on Android, while if\n+   * we don't include the method, then the compiler will complain that an abstract method is\n+   * unimplemented. So instead we use a dynamic proxy to get an implementation. If the method being\n+   * called on the {@code TypeVariable} instance has the same name as one of the public methods of\n+   * {@link TypeVariableImpl}, the proxy calls the same method on its instance of {@code\n+   * TypeVariableImpl}. Otherwise it throws {@link UnsupportedOperationException}; this should only\n+   * apply to {@code getAnnotatedBounds()}. This does mean that users on Java who obtain an instance\n+   * of {@code TypeVariable} from {@link TypeResolver#resolveType} will not be able to call {@code\n+   * getAnnotatedBounds()} on it, but that should hopefully be rare.\n    *\n-   * <p>TODO(b/147144588): We are currently also missing the methods inherited from {@link\n+   * <p>TODO: b/147144588 - We are currently also missing the methods inherited from {@link\n    * AnnotatedElement}, which {@code TypeVariable} began to extend only in Java 8. Those methods\n-   * refer only to types present in Java 7, so we could implement them in {@code TypeVariableImpl}\n-   * today. (We could probably then make {@code TypeVariableImpl} implement {@code AnnotatedElement}\n-   * so that we get partial compile-time checking.)\n+   * refer only to types present under Android, so we could implement them in {@code\n+   * TypeVariableImpl} today. (We could probably then make {@code TypeVariableImpl} implement {@code\n+   * AnnotatedElement} so that we get partial compile-time checking.)\n    *\n-   * <p>This workaround should be removed at a distant future time when we no longer support Java\n-   * versions earlier than 8.\n+   * <p>This workaround should be removed at a distant future time when <a\n+   * href=\"https://issuetracker.google.com/issues/115932459\">Android supports {@code\n+   * AnnotatedType}</a>.\n    */\n   @SuppressWarnings(\"removal\") // b/318391980\n   private static final class TypeVariableInvocationHandler implements InvocationHandler {\n@@ -539,7 +540,10 @@ static Class<?> getArrayClass(Class<?> componentType) {\n     return Array.newInstance(componentType, 0).getClass();\n   }\n \n-  // TODO(benyu): Once behavior is the same for all Java versions we support, delete this.\n+  /*\n+   * TODO(benyu): Once behavior is the same for all Java (and Android) versions we support, delete\n+   * this. It is possible that one or both of JAVA6 and JAVA7 have become unnecessary already.\n+   */\n   enum JavaVersion {\n     JAVA6 {\n       @Override\n@@ -585,16 +589,17 @@ Type usedInGenericType(Type type) {\n         return JAVA7.usedInGenericType(type);\n       }\n \n+      /*\n+       * We use this only when getTypeName is available.\n+       *\n+       * Well, really, we use this when we think we're running under Java 8, as determined by some\n+       * logic in the static initializer, which does not check for getTypeName specifically. We\n+       * should really validate that it works as desired for all Android versions that we support.\n+       */\n+      @SuppressWarnings(\"AndroidJdkLibsChecker\")\n       @Override\n       String typeName(Type type) {\n-        try {\n-          Method getTypeName = Type.class.getMethod(\"getTypeName\");\n-          return (String) getTypeName.invoke(type);\n-        } catch (NoSuchMethodException e) {\n-          throw new AssertionError(\"Type.getTypeName should be available in Java 8\");\n-        } catch (InvocationTargetException | IllegalAccessException e) {\n-          throw new RuntimeException(e);\n-        }\n+        return type.getTypeName();\n       }\n     },\n     JAVA9 {\n@@ -608,9 +613,10 @@ Type usedInGenericType(Type type) {\n         return JAVA8.usedInGenericType(type);\n       }\n \n+      @SuppressWarnings(\"AndroidJdkLibsChecker\") // as discussed under JAVA8.typeName\n       @Override\n       String typeName(Type type) {\n-        return JAVA8.typeName(type);\n+        return type.getTypeName();\n       }\n \n       @Override\n@@ -622,6 +628,7 @@ boolean jdkTypeDuplicatesOwnerName() {\n     static final JavaVersion CURRENT;\n \n     static {\n+      // Under Android, TypeVariable does not implement AnnotatedElement even under recent versions.\n       if (AnnotatedElement.class.isAssignableFrom(TypeVariable.class)) {\n         if (new TypeCapture<Entry<String, int[][]>>() {}.capture()\n             .toString()\n",
  "additions": 92,
  "deletions": 74,
  "changed_files": 4,
  "url": "https://github.com/google/guava/pull/7965",
  "mined_at": "2025-10-25T13:06:07.464229"
}