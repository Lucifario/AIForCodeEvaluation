{
  "id": 7979,
  "repository": "google/guava",
  "title": "Revise references to Android versions before our currently supported minimum (API Level 23).",
  "body": "Revise references to Android versions before our currently supported minimum (API Level 23).\n\nPlus, update docs and internals of `ClosingFuture` to reflect that even Android has supported `AutoCloseable` since cl/631389672.\n\nRELNOTES=n/a\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-09-11T13:51:33+00:00",
  "created_at": "2025-09-11T13:27:34+00:00",
  "updated_at": "2025-09-11T13:51:34+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "7fc3290d0ede02d2b1a9ff3356583e937ee999a7",
  "head_sha": "ce759791080a009572bc2496af44b7f4894dc1e4",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -226,7 +226,7 @@ private static boolean unsafeComparatorAvailable() {\n        *\n        * A note on exception types:\n        *\n-       * Android API level 10 throws ExceptionInInitializerError the first time and\n+       * Android API level 23 throws ExceptionInInitializerError the first time and\n        * ClassNotFoundException thereafter.\n        *\n        * Android API level 26 and JVM8 both let our Error propagate directly the first time and"
    },
    {
      "filename": "android/guava/src/com/google/common/base/Stopwatch.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -86,7 +86,7 @@\n  * Stopwatch.createStarted(\n  *      new Ticker() {\n  *        public long read() {\n- *          return android.os.SystemClock.elapsedRealtimeNanos(); // requires API Level 17\n+ *          return android.os.SystemClock.elapsedRealtimeNanos();\n  *        }\n  *      });\n  * }"
    },
    {
      "filename": "android/guava/src/com/google/common/util/concurrent/ClosingFuture.java",
      "status": "modified",
      "additions": 9,
      "deletions": 26,
      "changes": 35,
      "patch": "@@ -48,7 +48,6 @@\n import com.google.errorprone.annotations.CanIgnoreReturnValue;\n import com.google.errorprone.annotations.DoNotMock;\n import com.google.j2objc.annotations.RetainedWith;\n-import java.io.Closeable;\n import java.util.IdentityHashMap;\n import java.util.Map;\n import java.util.concurrent.Callable;\n@@ -210,23 +209,15 @@ public static final class DeferredCloser {\n     /**\n      * Captures an object to be closed when a {@link ClosingFuture} pipeline is done.\n      *\n-     * <p>For users of the {@code -jre} flavor of Guava, the object can be any {@code\n-     * AutoCloseable}. For users of the {@code -android} flavor, the object must be a {@code\n-     * Closeable}. (For more about the flavors, see <a\n-     * href=\"https://github.com/google/guava#adding-guava-to-your-build\">Adding Guava to your\n-     * build</a>.)\n-     *\n      * <p>Be careful when targeting an older SDK than you are building against (most commonly when\n      * building for Android): Ensure that any object you pass implements the interface not just in\n      * your current SDK version but also at the oldest version you support. For example, <a\n-     * href=\"https://developer.android.com/sdk/api_diff/16/\">API Level 16</a> is the first version\n-     * in which {@code Cursor} is {@code Closeable}. To support older versions, pass a wrapper\n-     * {@code Closeable} with a method reference like {@code cursor::close}.\n-     *\n-     * <p>Note that this method is still binary-compatible between flavors because the erasure of\n-     * its parameter type is {@code Object}, not {@code AutoCloseable} or {@code Closeable}.\n+     * href=\"https://developer.android.com/sdk/api_diff/28/changes/android.media.MediaDrm#android.media.MediaDrm.close_added()\">API\n+     * Level 28</a> is the first version in which {@code MediaDrm} is {@code AutoCloseable}. To\n+     * support older versions, pass a wrapper {@code AutoCloseable} with a method reference like\n+     * {@code mediaDrm::release}.\n      *\n-     * @param closeable the object to be closed (see notes above)\n+     * @param closeable the object to be closed\n      * @param closingExecutor the object will be closed on this executor\n      * @return the first argument\n      */\n@@ -440,7 +431,7 @@ public String toString() {\n    * Starts a {@link ClosingFuture} pipeline with a {@link ListenableFuture}.\n    *\n    * <p>{@code future}'s value will not be closed when the pipeline is done even if {@code V}\n-   * implements {@link Closeable}. In order to start a pipeline with a value that will be closed\n+   * implements {@link AutoCloseable}. In order to start a pipeline with a value that will be closed\n    * when the pipeline is done, use {@link #submit(ClosingCallable, Executor)} instead.\n    */\n   public static <V extends @Nullable Object> ClosingFuture<V> from(ListenableFuture<V> future) {\n@@ -741,7 +732,7 @@ public String toString() {\n    *\n    * // Result.writeRowsToOutputStreamFuture() returns a ListenableFuture that resolves to the\n    * // number of written rows. openOutputFile() returns a FileOutputStream (which implements\n-   * // Closeable).\n+   * // AutoCloseable).\n    * ClosingFuture<Integer> rowsFuture2 =\n    *     queryFuture.transformAsync(\n    *         (closer, result) -> {\n@@ -803,7 +794,7 @@ public String toString() {\n    * meets these conditions:\n    *\n    * <ul>\n-   *   <li>It does not need to capture any {@link Closeable} objects by calling {@link\n+   *   <li>It does not need to capture any {@link AutoCloseable} objects by calling {@link\n    *       DeferredCloser#eventuallyClose(Object, Executor)}.\n    *   <li>It returns a {@link ListenableFuture}.\n    * </ul>\n@@ -2121,14 +2112,6 @@ private static void closeQuietly(@Nullable AutoCloseable closeable, Executor exe\n             try {\n               closeable.close();\n             } catch (Exception e) {\n-              /*\n-               * In guava-jre, any kind of Exception may be thrown because `closeable` has type\n-               * `AutoCloseable`.\n-               *\n-               * In guava-android, the only kinds of Exception that may be thrown are\n-               * RuntimeException and IOException because `closeable` has type `Closeable`—except\n-               * that we have to account for sneaky checked exception.\n-               */\n               restoreInterruptIfIsInterruptedException(e);\n               logger.get().log(WARNING, \"thrown by close()\", e);\n             }\n@@ -2160,7 +2143,7 @@ private boolean compareAndUpdateState(State oldState, State newState) {\n \n   // TODO(dpb): Should we use a pair of ArrayLists instead of an IdentityHashMap?\n   private static final class CloseableList extends IdentityHashMap<AutoCloseable, Executor>\n-      implements Closeable {\n+      implements AutoCloseable {\n     private final DeferredCloser closer = new DeferredCloser(this);\n     private volatile boolean closed;\n     private volatile @Nullable CountDownLatch whenClosed;"
    },
    {
      "filename": "guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -227,7 +227,7 @@ private static boolean unsafeComparatorAvailable() {\n        *\n        * A note on exception types:\n        *\n-       * Android API level 10 throws ExceptionInInitializerError the first time and\n+       * Android API level 23 throws ExceptionInInitializerError the first time and\n        * ClassNotFoundException thereafter.\n        *\n        * Android API level 26 and JVM8 both let our Error propagate directly the first time and"
    },
    {
      "filename": "guava/src/com/google/common/base/Stopwatch.java",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "patch": "@@ -86,7 +86,7 @@\n  * Stopwatch.createStarted(\n  *      new Ticker() {\n  *        public long read() {\n- *          return android.os.SystemClock.elapsedRealtimeNanos(); // requires API Level 17\n+ *          return android.os.SystemClock.elapsedRealtimeNanos();\n  *        }\n  *      });\n  * }"
    },
    {
      "filename": "guava/src/com/google/common/util/concurrent/ClosingFuture.java",
      "status": "modified",
      "additions": 9,
      "deletions": 26,
      "changes": 35,
      "patch": "@@ -48,7 +48,6 @@\n import com.google.errorprone.annotations.CanIgnoreReturnValue;\n import com.google.errorprone.annotations.DoNotMock;\n import com.google.j2objc.annotations.RetainedWith;\n-import java.io.Closeable;\n import java.util.IdentityHashMap;\n import java.util.Map;\n import java.util.concurrent.Callable;\n@@ -210,23 +209,15 @@ public static final class DeferredCloser {\n     /**\n      * Captures an object to be closed when a {@link ClosingFuture} pipeline is done.\n      *\n-     * <p>For users of the {@code -jre} flavor of Guava, the object can be any {@code\n-     * AutoCloseable}. For users of the {@code -android} flavor, the object must be a {@code\n-     * Closeable}. (For more about the flavors, see <a\n-     * href=\"https://github.com/google/guava#adding-guava-to-your-build\">Adding Guava to your\n-     * build</a>.)\n-     *\n      * <p>Be careful when targeting an older SDK than you are building against (most commonly when\n      * building for Android): Ensure that any object you pass implements the interface not just in\n      * your current SDK version but also at the oldest version you support. For example, <a\n-     * href=\"https://developer.android.com/sdk/api_diff/16/\">API Level 16</a> is the first version\n-     * in which {@code Cursor} is {@code Closeable}. To support older versions, pass a wrapper\n-     * {@code Closeable} with a method reference like {@code cursor::close}.\n-     *\n-     * <p>Note that this method is still binary-compatible between flavors because the erasure of\n-     * its parameter type is {@code Object}, not {@code AutoCloseable} or {@code Closeable}.\n+     * href=\"https://developer.android.com/sdk/api_diff/28/changes/android.media.MediaDrm#android.media.MediaDrm.close_added()\">API\n+     * Level 28</a> is the first version in which {@code MediaDrm} is {@code AutoCloseable}. To\n+     * support older versions, pass a wrapper {@code AutoCloseable} with a method reference like\n+     * {@code mediaDrm::release}.\n      *\n-     * @param closeable the object to be closed (see notes above)\n+     * @param closeable the object to be closed\n      * @param closingExecutor the object will be closed on this executor\n      * @return the first argument\n      */\n@@ -445,7 +436,7 @@ public String toString() {\n    * Starts a {@link ClosingFuture} pipeline with a {@link ListenableFuture}.\n    *\n    * <p>{@code future}'s value will not be closed when the pipeline is done even if {@code V}\n-   * implements {@link Closeable}. In order to start a pipeline with a value that will be closed\n+   * implements {@link AutoCloseable}. In order to start a pipeline with a value that will be closed\n    * when the pipeline is done, use {@link #submit(ClosingCallable, Executor)} instead.\n    */\n   public static <V extends @Nullable Object> ClosingFuture<V> from(ListenableFuture<V> future) {\n@@ -746,7 +737,7 @@ public String toString() {\n    *\n    * // Result.writeRowsToOutputStreamFuture() returns a ListenableFuture that resolves to the\n    * // number of written rows. openOutputFile() returns a FileOutputStream (which implements\n-   * // Closeable).\n+   * // AutoCloseable).\n    * ClosingFuture<Integer> rowsFuture2 =\n    *     queryFuture.transformAsync(\n    *         (closer, result) -> {\n@@ -808,7 +799,7 @@ public String toString() {\n    * meets these conditions:\n    *\n    * <ul>\n-   *   <li>It does not need to capture any {@link Closeable} objects by calling {@link\n+   *   <li>It does not need to capture any {@link AutoCloseable} objects by calling {@link\n    *       DeferredCloser#eventuallyClose(Object, Executor)}.\n    *   <li>It returns a {@link ListenableFuture}.\n    * </ul>\n@@ -2136,14 +2127,6 @@ private static void closeQuietly(@Nullable AutoCloseable closeable, Executor exe\n             try {\n               closeable.close();\n             } catch (Exception e) {\n-              /*\n-               * In guava-jre, any kind of Exception may be thrown because `closeable` has type\n-               * `AutoCloseable`.\n-               *\n-               * In guava-android, the only kinds of Exception that may be thrown are\n-               * RuntimeException and IOException because `closeable` has type `Closeable`—except\n-               * that we have to account for sneaky checked exception.\n-               */\n               restoreInterruptIfIsInterruptedException(e);\n               logger.get().log(WARNING, \"thrown by close()\", e);\n             }\n@@ -2175,7 +2158,7 @@ private boolean compareAndUpdateState(State oldState, State newState) {\n \n   // TODO(dpb): Should we use a pair of ArrayLists instead of an IdentityHashMap?\n   private static final class CloseableList extends IdentityHashMap<AutoCloseable, Executor>\n-      implements Closeable {\n+      implements AutoCloseable {\n     private final DeferredCloser closer = new DeferredCloser(this);\n     private volatile boolean closed;\n     private volatile @Nullable CountDownLatch whenClosed;"
    }
  ],
  "diff": "diff --git a/android/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java b/android/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java\nindex 05c727e44bed..091d9f28a6bd 100644\n--- a/android/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java\n+++ b/android/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java\n@@ -226,7 +226,7 @@ private static boolean unsafeComparatorAvailable() {\n        *\n        * A note on exception types:\n        *\n-       * Android API level 10 throws ExceptionInInitializerError the first time and\n+       * Android API level 23 throws ExceptionInInitializerError the first time and\n        * ClassNotFoundException thereafter.\n        *\n        * Android API level 26 and JVM8 both let our Error propagate directly the first time and\ndiff --git a/android/guava/src/com/google/common/base/Stopwatch.java b/android/guava/src/com/google/common/base/Stopwatch.java\nindex 1f5cb2cebd39..dd01826e83d0 100644\n--- a/android/guava/src/com/google/common/base/Stopwatch.java\n+++ b/android/guava/src/com/google/common/base/Stopwatch.java\n@@ -86,7 +86,7 @@\n  * Stopwatch.createStarted(\n  *      new Ticker() {\n  *        public long read() {\n- *          return android.os.SystemClock.elapsedRealtimeNanos(); // requires API Level 17\n+ *          return android.os.SystemClock.elapsedRealtimeNanos();\n  *        }\n  *      });\n  * }\ndiff --git a/android/guava/src/com/google/common/util/concurrent/ClosingFuture.java b/android/guava/src/com/google/common/util/concurrent/ClosingFuture.java\nindex 98aab964a96d..1b010ec0adab 100644\n--- a/android/guava/src/com/google/common/util/concurrent/ClosingFuture.java\n+++ b/android/guava/src/com/google/common/util/concurrent/ClosingFuture.java\n@@ -48,7 +48,6 @@\n import com.google.errorprone.annotations.CanIgnoreReturnValue;\n import com.google.errorprone.annotations.DoNotMock;\n import com.google.j2objc.annotations.RetainedWith;\n-import java.io.Closeable;\n import java.util.IdentityHashMap;\n import java.util.Map;\n import java.util.concurrent.Callable;\n@@ -210,23 +209,15 @@ public static final class DeferredCloser {\n     /**\n      * Captures an object to be closed when a {@link ClosingFuture} pipeline is done.\n      *\n-     * <p>For users of the {@code -jre} flavor of Guava, the object can be any {@code\n-     * AutoCloseable}. For users of the {@code -android} flavor, the object must be a {@code\n-     * Closeable}. (For more about the flavors, see <a\n-     * href=\"https://github.com/google/guava#adding-guava-to-your-build\">Adding Guava to your\n-     * build</a>.)\n-     *\n      * <p>Be careful when targeting an older SDK than you are building against (most commonly when\n      * building for Android): Ensure that any object you pass implements the interface not just in\n      * your current SDK version but also at the oldest version you support. For example, <a\n-     * href=\"https://developer.android.com/sdk/api_diff/16/\">API Level 16</a> is the first version\n-     * in which {@code Cursor} is {@code Closeable}. To support older versions, pass a wrapper\n-     * {@code Closeable} with a method reference like {@code cursor::close}.\n-     *\n-     * <p>Note that this method is still binary-compatible between flavors because the erasure of\n-     * its parameter type is {@code Object}, not {@code AutoCloseable} or {@code Closeable}.\n+     * href=\"https://developer.android.com/sdk/api_diff/28/changes/android.media.MediaDrm#android.media.MediaDrm.close_added()\">API\n+     * Level 28</a> is the first version in which {@code MediaDrm} is {@code AutoCloseable}. To\n+     * support older versions, pass a wrapper {@code AutoCloseable} with a method reference like\n+     * {@code mediaDrm::release}.\n      *\n-     * @param closeable the object to be closed (see notes above)\n+     * @param closeable the object to be closed\n      * @param closingExecutor the object will be closed on this executor\n      * @return the first argument\n      */\n@@ -440,7 +431,7 @@ public String toString() {\n    * Starts a {@link ClosingFuture} pipeline with a {@link ListenableFuture}.\n    *\n    * <p>{@code future}'s value will not be closed when the pipeline is done even if {@code V}\n-   * implements {@link Closeable}. In order to start a pipeline with a value that will be closed\n+   * implements {@link AutoCloseable}. In order to start a pipeline with a value that will be closed\n    * when the pipeline is done, use {@link #submit(ClosingCallable, Executor)} instead.\n    */\n   public static <V extends @Nullable Object> ClosingFuture<V> from(ListenableFuture<V> future) {\n@@ -741,7 +732,7 @@ public String toString() {\n    *\n    * // Result.writeRowsToOutputStreamFuture() returns a ListenableFuture that resolves to the\n    * // number of written rows. openOutputFile() returns a FileOutputStream (which implements\n-   * // Closeable).\n+   * // AutoCloseable).\n    * ClosingFuture<Integer> rowsFuture2 =\n    *     queryFuture.transformAsync(\n    *         (closer, result) -> {\n@@ -803,7 +794,7 @@ public String toString() {\n    * meets these conditions:\n    *\n    * <ul>\n-   *   <li>It does not need to capture any {@link Closeable} objects by calling {@link\n+   *   <li>It does not need to capture any {@link AutoCloseable} objects by calling {@link\n    *       DeferredCloser#eventuallyClose(Object, Executor)}.\n    *   <li>It returns a {@link ListenableFuture}.\n    * </ul>\n@@ -2121,14 +2112,6 @@ private static void closeQuietly(@Nullable AutoCloseable closeable, Executor exe\n             try {\n               closeable.close();\n             } catch (Exception e) {\n-              /*\n-               * In guava-jre, any kind of Exception may be thrown because `closeable` has type\n-               * `AutoCloseable`.\n-               *\n-               * In guava-android, the only kinds of Exception that may be thrown are\n-               * RuntimeException and IOException because `closeable` has type `Closeable`—except\n-               * that we have to account for sneaky checked exception.\n-               */\n               restoreInterruptIfIsInterruptedException(e);\n               logger.get().log(WARNING, \"thrown by close()\", e);\n             }\n@@ -2160,7 +2143,7 @@ private boolean compareAndUpdateState(State oldState, State newState) {\n \n   // TODO(dpb): Should we use a pair of ArrayLists instead of an IdentityHashMap?\n   private static final class CloseableList extends IdentityHashMap<AutoCloseable, Executor>\n-      implements Closeable {\n+      implements AutoCloseable {\n     private final DeferredCloser closer = new DeferredCloser(this);\n     private volatile boolean closed;\n     private volatile @Nullable CountDownLatch whenClosed;\ndiff --git a/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java b/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java\nindex e50f1b1e969c..fa511774aa2e 100644\n--- a/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java\n+++ b/guava-tests/test/com/google/common/primitives/UnsignedBytesTest.java\n@@ -227,7 +227,7 @@ private static boolean unsafeComparatorAvailable() {\n        *\n        * A note on exception types:\n        *\n-       * Android API level 10 throws ExceptionInInitializerError the first time and\n+       * Android API level 23 throws ExceptionInInitializerError the first time and\n        * ClassNotFoundException thereafter.\n        *\n        * Android API level 26 and JVM8 both let our Error propagate directly the first time and\ndiff --git a/guava/src/com/google/common/base/Stopwatch.java b/guava/src/com/google/common/base/Stopwatch.java\nindex 8ca352b536e8..d46ef81747ae 100644\n--- a/guava/src/com/google/common/base/Stopwatch.java\n+++ b/guava/src/com/google/common/base/Stopwatch.java\n@@ -86,7 +86,7 @@\n  * Stopwatch.createStarted(\n  *      new Ticker() {\n  *        public long read() {\n- *          return android.os.SystemClock.elapsedRealtimeNanos(); // requires API Level 17\n+ *          return android.os.SystemClock.elapsedRealtimeNanos();\n  *        }\n  *      });\n  * }\ndiff --git a/guava/src/com/google/common/util/concurrent/ClosingFuture.java b/guava/src/com/google/common/util/concurrent/ClosingFuture.java\nindex 551930381b11..435740ccadf5 100644\n--- a/guava/src/com/google/common/util/concurrent/ClosingFuture.java\n+++ b/guava/src/com/google/common/util/concurrent/ClosingFuture.java\n@@ -48,7 +48,6 @@\n import com.google.errorprone.annotations.CanIgnoreReturnValue;\n import com.google.errorprone.annotations.DoNotMock;\n import com.google.j2objc.annotations.RetainedWith;\n-import java.io.Closeable;\n import java.util.IdentityHashMap;\n import java.util.Map;\n import java.util.concurrent.Callable;\n@@ -210,23 +209,15 @@ public static final class DeferredCloser {\n     /**\n      * Captures an object to be closed when a {@link ClosingFuture} pipeline is done.\n      *\n-     * <p>For users of the {@code -jre} flavor of Guava, the object can be any {@code\n-     * AutoCloseable}. For users of the {@code -android} flavor, the object must be a {@code\n-     * Closeable}. (For more about the flavors, see <a\n-     * href=\"https://github.com/google/guava#adding-guava-to-your-build\">Adding Guava to your\n-     * build</a>.)\n-     *\n      * <p>Be careful when targeting an older SDK than you are building against (most commonly when\n      * building for Android): Ensure that any object you pass implements the interface not just in\n      * your current SDK version but also at the oldest version you support. For example, <a\n-     * href=\"https://developer.android.com/sdk/api_diff/16/\">API Level 16</a> is the first version\n-     * in which {@code Cursor} is {@code Closeable}. To support older versions, pass a wrapper\n-     * {@code Closeable} with a method reference like {@code cursor::close}.\n-     *\n-     * <p>Note that this method is still binary-compatible between flavors because the erasure of\n-     * its parameter type is {@code Object}, not {@code AutoCloseable} or {@code Closeable}.\n+     * href=\"https://developer.android.com/sdk/api_diff/28/changes/android.media.MediaDrm#android.media.MediaDrm.close_added()\">API\n+     * Level 28</a> is the first version in which {@code MediaDrm} is {@code AutoCloseable}. To\n+     * support older versions, pass a wrapper {@code AutoCloseable} with a method reference like\n+     * {@code mediaDrm::release}.\n      *\n-     * @param closeable the object to be closed (see notes above)\n+     * @param closeable the object to be closed\n      * @param closingExecutor the object will be closed on this executor\n      * @return the first argument\n      */\n@@ -445,7 +436,7 @@ public String toString() {\n    * Starts a {@link ClosingFuture} pipeline with a {@link ListenableFuture}.\n    *\n    * <p>{@code future}'s value will not be closed when the pipeline is done even if {@code V}\n-   * implements {@link Closeable}. In order to start a pipeline with a value that will be closed\n+   * implements {@link AutoCloseable}. In order to start a pipeline with a value that will be closed\n    * when the pipeline is done, use {@link #submit(ClosingCallable, Executor)} instead.\n    */\n   public static <V extends @Nullable Object> ClosingFuture<V> from(ListenableFuture<V> future) {\n@@ -746,7 +737,7 @@ public String toString() {\n    *\n    * // Result.writeRowsToOutputStreamFuture() returns a ListenableFuture that resolves to the\n    * // number of written rows. openOutputFile() returns a FileOutputStream (which implements\n-   * // Closeable).\n+   * // AutoCloseable).\n    * ClosingFuture<Integer> rowsFuture2 =\n    *     queryFuture.transformAsync(\n    *         (closer, result) -> {\n@@ -808,7 +799,7 @@ public String toString() {\n    * meets these conditions:\n    *\n    * <ul>\n-   *   <li>It does not need to capture any {@link Closeable} objects by calling {@link\n+   *   <li>It does not need to capture any {@link AutoCloseable} objects by calling {@link\n    *       DeferredCloser#eventuallyClose(Object, Executor)}.\n    *   <li>It returns a {@link ListenableFuture}.\n    * </ul>\n@@ -2136,14 +2127,6 @@ private static void closeQuietly(@Nullable AutoCloseable closeable, Executor exe\n             try {\n               closeable.close();\n             } catch (Exception e) {\n-              /*\n-               * In guava-jre, any kind of Exception may be thrown because `closeable` has type\n-               * `AutoCloseable`.\n-               *\n-               * In guava-android, the only kinds of Exception that may be thrown are\n-               * RuntimeException and IOException because `closeable` has type `Closeable`—except\n-               * that we have to account for sneaky checked exception.\n-               */\n               restoreInterruptIfIsInterruptedException(e);\n               logger.get().log(WARNING, \"thrown by close()\", e);\n             }\n@@ -2175,7 +2158,7 @@ private boolean compareAndUpdateState(State oldState, State newState) {\n \n   // TODO(dpb): Should we use a pair of ArrayLists instead of an IdentityHashMap?\n   private static final class CloseableList extends IdentityHashMap<AutoCloseable, Executor>\n-      implements Closeable {\n+      implements AutoCloseable {\n     private final DeferredCloser closer = new DeferredCloser(this);\n     private volatile boolean closed;\n     private volatile @Nullable CountDownLatch whenClosed;\n",
  "additions": 22,
  "deletions": 56,
  "changed_files": 6,
  "url": "https://github.com/google/guava/pull/7979",
  "mined_at": "2025-10-25T13:04:11.414333"
}