diff --git a/android/guava-tests/test/com/google/common/collect/IteratorsTest.java b/android/guava-tests/test/com/google/common/collect/IteratorsTest.java
index b1d09dbbe296..bb7fbb44fde4 100644
--- a/android/guava-tests/test/com/google/common/collect/IteratorsTest.java
+++ b/android/guava-tests/test/com/google/common/collect/IteratorsTest.java
@@ -61,6 +61,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.ConcurrentModificationException;
 import java.util.Enumeration;
 import java.util.Iterator;
@@ -68,6 +69,7 @@
 import java.util.List;
 import java.util.ListIterator;
 import java.util.NoSuchElementException;
+import java.util.Objects;
 import java.util.RandomAccess;
 import java.util.Set;
 import java.util.Vector;
@@ -1546,4 +1548,74 @@ public void testPeekingIteratorShortCircuit() {
     assertSame(peek, Iterators.peekingIterator(peek));
     assertSame(peek, Iterators.peekingIterator((Iterator<String>) peek));
   }
+
+  public void testMergeSorted_stable_issue5773Example() {
+    ImmutableList<TestDatum> left = ImmutableList.of(new TestDatum("B", 1), new TestDatum("C", 1));
+    ImmutableList<TestDatum> right = ImmutableList.of(new TestDatum("A", 2), new TestDatum("C", 2));
+
+    Comparator<TestDatum> comparator = Comparator.comparing(d -> d.letter);
+
+    // When elements compare as equal (both C's have same letter), our merge should always return C1
+    // before C2, since C1 is from the first iterator.
+
+    Iterator<TestDatum> merged =
+        Iterators.mergeSorted(ImmutableList.of(left.iterator(), right.iterator()), comparator);
+
+    ImmutableList<TestDatum> result = ImmutableList.copyOf(merged);
+
+    assertThat(result)
+        .containsExactly(
+            new TestDatum("A", 2),
+            new TestDatum("B", 1),
+            new TestDatum("C", 1),
+            new TestDatum("C", 2));
+  }
+
+  public void testMergeSorted_stable_allEqual() {
+    ImmutableList<TestDatum> first = ImmutableList.of(new TestDatum("A", 1), new TestDatum("A", 2));
+    ImmutableList<TestDatum> second =
+        ImmutableList.of(new TestDatum("A", 3), new TestDatum("A", 4));
+
+    Comparator<TestDatum> comparator = Comparator.comparing(d -> d.letter);
+    Iterator<TestDatum> merged =
+        Iterators.mergeSorted(ImmutableList.of(first.iterator(), second.iterator()), comparator);
+
+    ImmutableList<TestDatum> result = ImmutableList.copyOf(merged);
+
+    assertThat(result)
+        .containsExactly(
+            new TestDatum("A", 1),
+            new TestDatum("A", 2),
+            new TestDatum("A", 3),
+            new TestDatum("A", 4));
+  }
+
+  private static final class TestDatum {
+    final String letter;
+    final int number;
+
+    TestDatum(String letter, int number) {
+      this.letter = letter;
+      this.number = number;
+    }
+
+    @Override
+    public String toString() {
+      return letter + number;
+    }
+
+    @Override
+    public boolean equals(@Nullable Object o) {
+      if (!(o instanceof TestDatum)) {
+        return false;
+      }
+      TestDatum other = (TestDatum) o;
+      return letter.equals(other.letter) && number == other.number;
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(letter, number);
+    }
+  }
 }
diff --git a/guava-tests/test/com/google/common/collect/IteratorsTest.java b/guava-tests/test/com/google/common/collect/IteratorsTest.java
index b1d09dbbe296..bb7fbb44fde4 100644
--- a/guava-tests/test/com/google/common/collect/IteratorsTest.java
+++ b/guava-tests/test/com/google/common/collect/IteratorsTest.java
@@ -61,6 +61,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.ConcurrentModificationException;
 import java.util.Enumeration;
 import java.util.Iterator;
@@ -68,6 +69,7 @@
 import java.util.List;
 import java.util.ListIterator;
 import java.util.NoSuchElementException;
+import java.util.Objects;
 import java.util.RandomAccess;
 import java.util.Set;
 import java.util.Vector;
@@ -1546,4 +1548,74 @@ public void testPeekingIteratorShortCircuit() {
     assertSame(peek, Iterators.peekingIterator(peek));
     assertSame(peek, Iterators.peekingIterator((Iterator<String>) peek));
   }
+
+  public void testMergeSorted_stable_issue5773Example() {
+    ImmutableList<TestDatum> left = ImmutableList.of(new TestDatum("B", 1), new TestDatum("C", 1));
+    ImmutableList<TestDatum> right = ImmutableList.of(new TestDatum("A", 2), new TestDatum("C", 2));
+
+    Comparator<TestDatum> comparator = Comparator.comparing(d -> d.letter);
+
+    // When elements compare as equal (both C's have same letter), our merge should always return C1
+    // before C2, since C1 is from the first iterator.
+
+    Iterator<TestDatum> merged =
+        Iterators.mergeSorted(ImmutableList.of(left.iterator(), right.iterator()), comparator);
+
+    ImmutableList<TestDatum> result = ImmutableList.copyOf(merged);
+
+    assertThat(result)
+        .containsExactly(
+            new TestDatum("A", 2),
+            new TestDatum("B", 1),
+            new TestDatum("C", 1),
+            new TestDatum("C", 2));
+  }
+
+  public void testMergeSorted_stable_allEqual() {
+    ImmutableList<TestDatum> first = ImmutableList.of(new TestDatum("A", 1), new TestDatum("A", 2));
+    ImmutableList<TestDatum> second =
+        ImmutableList.of(new TestDatum("A", 3), new TestDatum("A", 4));
+
+    Comparator<TestDatum> comparator = Comparator.comparing(d -> d.letter);
+    Iterator<TestDatum> merged =
+        Iterators.mergeSorted(ImmutableList.of(first.iterator(), second.iterator()), comparator);
+
+    ImmutableList<TestDatum> result = ImmutableList.copyOf(merged);
+
+    assertThat(result)
+        .containsExactly(
+            new TestDatum("A", 1),
+            new TestDatum("A", 2),
+            new TestDatum("A", 3),
+            new TestDatum("A", 4));
+  }
+
+  private static final class TestDatum {
+    final String letter;
+    final int number;
+
+    TestDatum(String letter, int number) {
+      this.letter = letter;
+      this.number = number;
+    }
+
+    @Override
+    public String toString() {
+      return letter + number;
+    }
+
+    @Override
+    public boolean equals(@Nullable Object o) {
+      if (!(o instanceof TestDatum)) {
+        return false;
+      }
+      TestDatum other = (TestDatum) o;
+      return letter.equals(other.letter) && number == other.number;
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(letter, number);
+    }
+  }
 }
