{
  "id": 8048,
  "repository": "google/guava",
  "title": "Restore some `@link` tags and associated imports that were removed in cl/305727790.",
  "body": "Restore some `@link` tags and associated imports that were removed in cl/305727790.\n\n(Also, newly link to `Executor` from `MoreExecutors`.)\n\nRELNOTES=n/a\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-08T18:55:39+00:00",
  "created_at": "2025-10-08T18:28:43+00:00",
  "updated_at": "2025-10-08T18:55:40+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "96584e9a02891e100e6149be4cc361886db9019c",
  "head_sha": "82ce359b7a82503c0607673af6ee7bdcaa27966b",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava/src/com/google/common/base/Stopwatch.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "patch": "@@ -38,7 +38,7 @@\n  *\n  * <p>In contrast, <i>wall time</i> is a reading of \"now\" as given by a method like\n  * {@link System#currentTimeMillis()}, best represented as an {@link java.time.Instant}. Such values\n- * <i>can</i> be subtracted to obtain a {@code Duration} (such as by {@code Duration.between}), but\n+ * <i>can</i> be subtracted to obtain a {@link Duration} (such as by {@link Duration#between}), but\n  * doing so does <i>not</i> give a reliable measurement of elapsed time, because wall time readings\n  * are inherently approximate, routinely affected by periodic clock corrections. Because this class\n  * (by default) uses {@link System#nanoTime}, it is unaffected by these changes.\n@@ -209,7 +209,7 @@ private long elapsedNanos() {\n    *\n    * <p>It is generally not a good idea to use an ambiguous, unitless {@code long} to represent\n    * elapsed time. Therefore, we recommend using {@link #elapsed()} instead, which returns a\n-   * strongly-typed {@code Duration} instance.\n+   * strongly-typed {@link Duration} instance.\n    *\n    * @since 14.0 (since 10.0 as {@code elapsedTime()})\n    */"
    },
    {
      "filename": "android/guava/src/com/google/common/cache/CacheBuilder.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "patch": "@@ -93,8 +93,9 @@\n  *   <li>least-recently-used eviction when a maximum size is exceeded (note that the cache is\n  *       divided into segments, each of which does LRU internally)\n  *   <li>time-based expiration of entries, measured since last access or last write\n- *   <li>keys automatically wrapped in {@code WeakReference}\n- *   <li>values automatically wrapped in {@code WeakReference} or {@code SoftReference}\n+ *   <li>keys automatically wrapped in {@linkplain WeakReference weak} references\n+ *   <li>values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain\n+ *       SoftReference soft} references\n  *   <li>notification of evicted (or otherwise removed) entries\n  *   <li>accumulation of cache access statistics\n  * </ul>"
    },
    {
      "filename": "android/guava/src/com/google/common/util/concurrent/MoreExecutors.java",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "patch": "@@ -52,13 +52,14 @@\n import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n import org.jspecify.annotations.Nullable;\n \n /**\n- * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link ExecutorService},\n- * and {@link java.util.concurrent.ThreadFactory}.\n+ * Factory and utility methods for {@link Executor}, {@link ExecutorService}, and {@link\n+ * ThreadFactory}.\n  *\n  * @author Eric Fellheimer\n  * @author Kyle Littlefield\n@@ -303,11 +304,10 @@ private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n \n   /**\n    * Creates an executor service that runs each task in the thread that invokes {@code\n-   * execute/submit}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}. This applies both to\n-   * individually submitted tasks and to collections of tasks submitted via {@code invokeAll} or\n-   * {@code invokeAny}. In the latter case, tasks will run serially on the calling thread. Tasks are\n-   * run to completion before a {@code Future} is returned to the caller (unless the executor has\n-   * been shutdown).\n+   * execute/submit}, as in {@link CallerRunsPolicy} This applies both to individually submitted\n+   * tasks and to collections of tasks submitted via {@code invokeAll} or {@code invokeAny}. In the\n+   * latter case, tasks will run serially on the calling thread. Tasks are run to completion before\n+   * a {@code Future} is returned to the caller (unless the executor has been shutdown).\n    *\n    * <p>Although all tasks are immediately executed in the thread that submitted the task, this\n    * {@code ExecutorService} imposes a small locking overhead on each task submission in order to\n@@ -334,7 +334,7 @@ public static ListeningExecutorService newDirectExecutorService() {\n \n   /**\n    * Returns an {@link Executor} that runs each task in the thread that invokes {@link\n-   * Executor#execute execute}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}.\n+   * Executor#execute execute}, as in {@link CallerRunsPolicy}.\n    *\n    * <p>This executor is appropriate for tasks that are lightweight and not deeply chained.\n    * Inappropriate {@code directExecutor} usage can cause problems, and these problems can be"
    },
    {
      "filename": "guava/src/com/google/common/base/Stopwatch.java",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "patch": "@@ -38,7 +38,7 @@\n  *\n  * <p>In contrast, <i>wall time</i> is a reading of \"now\" as given by a method like\n  * {@link System#currentTimeMillis()}, best represented as an {@link java.time.Instant}. Such values\n- * <i>can</i> be subtracted to obtain a {@code Duration} (such as by {@code Duration.between}), but\n+ * <i>can</i> be subtracted to obtain a {@link Duration} (such as by {@link Duration#between}), but\n  * doing so does <i>not</i> give a reliable measurement of elapsed time, because wall time readings\n  * are inherently approximate, routinely affected by periodic clock corrections. Because this class\n  * (by default) uses {@link System#nanoTime}, it is unaffected by these changes.\n@@ -209,7 +209,7 @@ private long elapsedNanos() {\n    *\n    * <p>It is generally not a good idea to use an ambiguous, unitless {@code long} to represent\n    * elapsed time. Therefore, we recommend using {@link #elapsed()} instead, which returns a\n-   * strongly-typed {@code Duration} instance.\n+   * strongly-typed {@link Duration} instance.\n    *\n    * @since 14.0 (since 10.0 as {@code elapsedTime()})\n    */"
    },
    {
      "filename": "guava/src/com/google/common/cache/CacheBuilder.java",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "patch": "@@ -93,8 +93,9 @@\n  *   <li>least-recently-used eviction when a maximum size is exceeded (note that the cache is\n  *       divided into segments, each of which does LRU internally)\n  *   <li>time-based expiration of entries, measured since last access or last write\n- *   <li>keys automatically wrapped in {@code WeakReference}\n- *   <li>values automatically wrapped in {@code WeakReference} or {@code SoftReference}\n+ *   <li>keys automatically wrapped in {@linkplain WeakReference weak} references\n+ *   <li>values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain\n+ *       SoftReference soft} references\n  *   <li>notification of evicted (or otherwise removed) entries\n  *   <li>accumulation of cache access statistics\n  * </ul>"
    },
    {
      "filename": "guava/src/com/google/common/util/concurrent/MoreExecutors.java",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "patch": "@@ -52,13 +52,14 @@\n import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n import org.jspecify.annotations.Nullable;\n \n /**\n- * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link ExecutorService},\n- * and {@link java.util.concurrent.ThreadFactory}.\n+ * Factory and utility methods for {@link Executor}, {@link ExecutorService}, and {@link\n+ * ThreadFactory}.\n  *\n  * @author Eric Fellheimer\n  * @author Kyle Littlefield\n@@ -300,11 +301,10 @@ private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n \n   /**\n    * Creates an executor service that runs each task in the thread that invokes {@code\n-   * execute/submit}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}. This applies both to\n-   * individually submitted tasks and to collections of tasks submitted via {@code invokeAll} or\n-   * {@code invokeAny}. In the latter case, tasks will run serially on the calling thread. Tasks are\n-   * run to completion before a {@code Future} is returned to the caller (unless the executor has\n-   * been shutdown).\n+   * execute/submit}, as in {@link CallerRunsPolicy} This applies both to individually submitted\n+   * tasks and to collections of tasks submitted via {@code invokeAll} or {@code invokeAny}. In the\n+   * latter case, tasks will run serially on the calling thread. Tasks are run to completion before\n+   * a {@code Future} is returned to the caller (unless the executor has been shutdown).\n    *\n    * <p>Although all tasks are immediately executed in the thread that submitted the task, this\n    * {@code ExecutorService} imposes a small locking overhead on each task submission in order to\n@@ -331,7 +331,7 @@ public static ListeningExecutorService newDirectExecutorService() {\n \n   /**\n    * Returns an {@link Executor} that runs each task in the thread that invokes {@link\n-   * Executor#execute execute}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}.\n+   * Executor#execute execute}, as in {@link CallerRunsPolicy}.\n    *\n    * <p>This executor is appropriate for tasks that are lightweight and not deeply chained.\n    * Inappropriate {@code directExecutor} usage can cause problems, and these problems can be"
    }
  ],
  "diff": "diff --git a/android/guava/src/com/google/common/base/Stopwatch.java b/android/guava/src/com/google/common/base/Stopwatch.java\nindex dd01826e83d0..b954d7b583a6 100644\n--- a/android/guava/src/com/google/common/base/Stopwatch.java\n+++ b/android/guava/src/com/google/common/base/Stopwatch.java\n@@ -38,7 +38,7 @@\n  *\n  * <p>In contrast, <i>wall time</i> is a reading of \"now\" as given by a method like\n  * {@link System#currentTimeMillis()}, best represented as an {@link java.time.Instant}. Such values\n- * <i>can</i> be subtracted to obtain a {@code Duration} (such as by {@code Duration.between}), but\n+ * <i>can</i> be subtracted to obtain a {@link Duration} (such as by {@link Duration#between}), but\n  * doing so does <i>not</i> give a reliable measurement of elapsed time, because wall time readings\n  * are inherently approximate, routinely affected by periodic clock corrections. Because this class\n  * (by default) uses {@link System#nanoTime}, it is unaffected by these changes.\n@@ -209,7 +209,7 @@ private long elapsedNanos() {\n    *\n    * <p>It is generally not a good idea to use an ambiguous, unitless {@code long} to represent\n    * elapsed time. Therefore, we recommend using {@link #elapsed()} instead, which returns a\n-   * strongly-typed {@code Duration} instance.\n+   * strongly-typed {@link Duration} instance.\n    *\n    * @since 14.0 (since 10.0 as {@code elapsedTime()})\n    */\ndiff --git a/android/guava/src/com/google/common/cache/CacheBuilder.java b/android/guava/src/com/google/common/cache/CacheBuilder.java\nindex 477873ab57fa..012cc2e6be5b 100644\n--- a/android/guava/src/com/google/common/cache/CacheBuilder.java\n+++ b/android/guava/src/com/google/common/cache/CacheBuilder.java\n@@ -93,8 +93,9 @@\n  *   <li>least-recently-used eviction when a maximum size is exceeded (note that the cache is\n  *       divided into segments, each of which does LRU internally)\n  *   <li>time-based expiration of entries, measured since last access or last write\n- *   <li>keys automatically wrapped in {@code WeakReference}\n- *   <li>values automatically wrapped in {@code WeakReference} or {@code SoftReference}\n+ *   <li>keys automatically wrapped in {@linkplain WeakReference weak} references\n+ *   <li>values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain\n+ *       SoftReference soft} references\n  *   <li>notification of evicted (or otherwise removed) entries\n  *   <li>accumulation of cache access statistics\n  * </ul>\ndiff --git a/android/guava/src/com/google/common/util/concurrent/MoreExecutors.java b/android/guava/src/com/google/common/util/concurrent/MoreExecutors.java\nindex ce961604e1c3..672edf69354b 100644\n--- a/android/guava/src/com/google/common/util/concurrent/MoreExecutors.java\n+++ b/android/guava/src/com/google/common/util/concurrent/MoreExecutors.java\n@@ -52,13 +52,14 @@\n import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n import org.jspecify.annotations.Nullable;\n \n /**\n- * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link ExecutorService},\n- * and {@link java.util.concurrent.ThreadFactory}.\n+ * Factory and utility methods for {@link Executor}, {@link ExecutorService}, and {@link\n+ * ThreadFactory}.\n  *\n  * @author Eric Fellheimer\n  * @author Kyle Littlefield\n@@ -303,11 +304,10 @@ private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n \n   /**\n    * Creates an executor service that runs each task in the thread that invokes {@code\n-   * execute/submit}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}. This applies both to\n-   * individually submitted tasks and to collections of tasks submitted via {@code invokeAll} or\n-   * {@code invokeAny}. In the latter case, tasks will run serially on the calling thread. Tasks are\n-   * run to completion before a {@code Future} is returned to the caller (unless the executor has\n-   * been shutdown).\n+   * execute/submit}, as in {@link CallerRunsPolicy} This applies both to individually submitted\n+   * tasks and to collections of tasks submitted via {@code invokeAll} or {@code invokeAny}. In the\n+   * latter case, tasks will run serially on the calling thread. Tasks are run to completion before\n+   * a {@code Future} is returned to the caller (unless the executor has been shutdown).\n    *\n    * <p>Although all tasks are immediately executed in the thread that submitted the task, this\n    * {@code ExecutorService} imposes a small locking overhead on each task submission in order to\n@@ -334,7 +334,7 @@ public static ListeningExecutorService newDirectExecutorService() {\n \n   /**\n    * Returns an {@link Executor} that runs each task in the thread that invokes {@link\n-   * Executor#execute execute}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}.\n+   * Executor#execute execute}, as in {@link CallerRunsPolicy}.\n    *\n    * <p>This executor is appropriate for tasks that are lightweight and not deeply chained.\n    * Inappropriate {@code directExecutor} usage can cause problems, and these problems can be\ndiff --git a/guava/src/com/google/common/base/Stopwatch.java b/guava/src/com/google/common/base/Stopwatch.java\nindex d46ef81747ae..f66dadf7b543 100644\n--- a/guava/src/com/google/common/base/Stopwatch.java\n+++ b/guava/src/com/google/common/base/Stopwatch.java\n@@ -38,7 +38,7 @@\n  *\n  * <p>In contrast, <i>wall time</i> is a reading of \"now\" as given by a method like\n  * {@link System#currentTimeMillis()}, best represented as an {@link java.time.Instant}. Such values\n- * <i>can</i> be subtracted to obtain a {@code Duration} (such as by {@code Duration.between}), but\n+ * <i>can</i> be subtracted to obtain a {@link Duration} (such as by {@link Duration#between}), but\n  * doing so does <i>not</i> give a reliable measurement of elapsed time, because wall time readings\n  * are inherently approximate, routinely affected by periodic clock corrections. Because this class\n  * (by default) uses {@link System#nanoTime}, it is unaffected by these changes.\n@@ -209,7 +209,7 @@ private long elapsedNanos() {\n    *\n    * <p>It is generally not a good idea to use an ambiguous, unitless {@code long} to represent\n    * elapsed time. Therefore, we recommend using {@link #elapsed()} instead, which returns a\n-   * strongly-typed {@code Duration} instance.\n+   * strongly-typed {@link Duration} instance.\n    *\n    * @since 14.0 (since 10.0 as {@code elapsedTime()})\n    */\ndiff --git a/guava/src/com/google/common/cache/CacheBuilder.java b/guava/src/com/google/common/cache/CacheBuilder.java\nindex 414a4b6034d3..262dabb0dfd0 100644\n--- a/guava/src/com/google/common/cache/CacheBuilder.java\n+++ b/guava/src/com/google/common/cache/CacheBuilder.java\n@@ -93,8 +93,9 @@\n  *   <li>least-recently-used eviction when a maximum size is exceeded (note that the cache is\n  *       divided into segments, each of which does LRU internally)\n  *   <li>time-based expiration of entries, measured since last access or last write\n- *   <li>keys automatically wrapped in {@code WeakReference}\n- *   <li>values automatically wrapped in {@code WeakReference} or {@code SoftReference}\n+ *   <li>keys automatically wrapped in {@linkplain WeakReference weak} references\n+ *   <li>values automatically wrapped in {@linkplain WeakReference weak} or {@linkplain\n+ *       SoftReference soft} references\n  *   <li>notification of evicted (or otherwise removed) entries\n  *   <li>accumulation of cache access statistics\n  * </ul>\ndiff --git a/guava/src/com/google/common/util/concurrent/MoreExecutors.java b/guava/src/com/google/common/util/concurrent/MoreExecutors.java\nindex 8fceb0a21eb4..d1147df5f571 100644\n--- a/guava/src/com/google/common/util/concurrent/MoreExecutors.java\n+++ b/guava/src/com/google/common/util/concurrent/MoreExecutors.java\n@@ -52,13 +52,14 @@\n import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n import org.jspecify.annotations.Nullable;\n \n /**\n- * Factory and utility methods for {@link java.util.concurrent.Executor}, {@link ExecutorService},\n- * and {@link java.util.concurrent.ThreadFactory}.\n+ * Factory and utility methods for {@link Executor}, {@link ExecutorService}, and {@link\n+ * ThreadFactory}.\n  *\n  * @author Eric Fellheimer\n  * @author Kyle Littlefield\n@@ -300,11 +301,10 @@ private static void useDaemonThreadFactory(ThreadPoolExecutor executor) {\n \n   /**\n    * Creates an executor service that runs each task in the thread that invokes {@code\n-   * execute/submit}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}. This applies both to\n-   * individually submitted tasks and to collections of tasks submitted via {@code invokeAll} or\n-   * {@code invokeAny}. In the latter case, tasks will run serially on the calling thread. Tasks are\n-   * run to completion before a {@code Future} is returned to the caller (unless the executor has\n-   * been shutdown).\n+   * execute/submit}, as in {@link CallerRunsPolicy} This applies both to individually submitted\n+   * tasks and to collections of tasks submitted via {@code invokeAll} or {@code invokeAny}. In the\n+   * latter case, tasks will run serially on the calling thread. Tasks are run to completion before\n+   * a {@code Future} is returned to the caller (unless the executor has been shutdown).\n    *\n    * <p>Although all tasks are immediately executed in the thread that submitted the task, this\n    * {@code ExecutorService} imposes a small locking overhead on each task submission in order to\n@@ -331,7 +331,7 @@ public static ListeningExecutorService newDirectExecutorService() {\n \n   /**\n    * Returns an {@link Executor} that runs each task in the thread that invokes {@link\n-   * Executor#execute execute}, as in {@code ThreadPoolExecutor.CallerRunsPolicy}.\n+   * Executor#execute execute}, as in {@link CallerRunsPolicy}.\n    *\n    * <p>This executor is appropriate for tasks that are lightweight and not deeply chained.\n    * Inappropriate {@code directExecutor} usage can cause problems, and these problems can be\n",
  "additions": 26,
  "deletions": 24,
  "changed_files": 6,
  "url": "https://github.com/google/guava/pull/8048",
  "mined_at": "2025-10-25T12:50:03.566275"
}