{
  "id": 7951,
  "repository": "google/guava",
  "title": "Delete BinaryTreeTraverserBenchmark.",
  "body": "Delete BinaryTreeTraverserBenchmark.\n\nRELNOTES=n/a\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-09-23T18:39:11+00:00",
  "created_at": "2025-08-25T16:21:45+00:00",
  "updated_at": "2025-09-23T18:39:12+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "643b5e801de308c1fcad6f4ebbf9436b99b22cd9",
  "head_sha": "f827e52534ba44f6796b1c0e69313c757bc0701e",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java",
      "status": "removed",
      "additions": 0,
      "deletions": 173,
      "changes": 173,
      "patch": "@@ -1,173 +0,0 @@\n-/*\n- * Copyright (C) 2012 The Guava Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package com.google.common.collect;\n-\n-import com.google.caliper.BeforeExperiment;\n-import com.google.caliper.Benchmark;\n-import com.google.caliper.Param;\n-import com.google.common.base.Optional;\n-import com.google.common.primitives.Ints;\n-import java.util.List;\n-import java.util.Random;\n-import org.jspecify.annotations.NullUnmarked;\n-\n-/**\n- * Benchmarks for the {@code TreeTraverser} operations on binary trees.\n- *\n- * @author Louis Wasserman\n- */\n-@NullUnmarked\n-public class BinaryTreeTraverserBenchmark {\n-  private static class BinaryNode {\n-    final int x;\n-    final Optional<BinaryNode> left;\n-    final Optional<BinaryNode> right;\n-\n-    BinaryNode(int x, Optional<BinaryNode> left, Optional<BinaryNode> right) {\n-      this.x = x;\n-      this.left = left;\n-      this.right = right;\n-    }\n-  }\n-\n-  enum Topology {\n-    BALANCED {\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        if (size == 0) {\n-          return Optional.absent();\n-        } else {\n-          int leftChildSize = (size - 1) / 2;\n-          int rightChildSize = size - 1 - leftChildSize;\n-          return Optional.of(\n-              new BinaryNode(\n-                  rng.nextInt(), createTree(leftChildSize, rng), createTree(rightChildSize, rng)));\n-        }\n-      }\n-    },\n-    ALL_LEFT {\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        Optional<BinaryNode> root = Optional.absent();\n-        for (int i = 0; i < size; i++) {\n-          root = Optional.of(new BinaryNode(rng.nextInt(), root, Optional.<BinaryNode>absent()));\n-        }\n-        return root;\n-      }\n-    },\n-    ALL_RIGHT {\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        Optional<BinaryNode> root = Optional.absent();\n-        for (int i = 0; i < size; i++) {\n-          root = Optional.of(new BinaryNode(rng.nextInt(), Optional.<BinaryNode>absent(), root));\n-        }\n-        return root;\n-      }\n-    },\n-    RANDOM {\n-      /**\n-       * Generates a tree with topology selected uniformly at random from the topologies of binary\n-       * trees of the specified size.\n-       */\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        int[] keys = new int[size];\n-        for (int i = 0; i < size; i++) {\n-          keys[i] = rng.nextInt();\n-        }\n-        return createTreap(Ints.asList(keys));\n-      }\n-\n-      // See http://en.wikipedia.org/wiki/Treap for details on the algorithm.\n-      private Optional<BinaryNode> createTreap(List<Integer> keys) {\n-        if (keys.isEmpty()) {\n-          return Optional.absent();\n-        }\n-        int minIndex = 0;\n-        for (int i = 1; i < keys.size(); i++) {\n-          if (keys.get(i) < keys.get(minIndex)) {\n-            minIndex = i;\n-          }\n-        }\n-        Optional<BinaryNode> leftChild = createTreap(keys.subList(0, minIndex));\n-        Optional<BinaryNode> rightChild = createTreap(keys.subList(minIndex + 1, keys.size()));\n-        return Optional.of(new BinaryNode(keys.get(minIndex), leftChild, rightChild));\n-      }\n-    };\n-\n-    abstract Optional<BinaryNode> createTree(int size, Random rng);\n-  }\n-\n-  private static final TreeTraverser<BinaryNode> VIEWER =\n-      new TreeTraverser<BinaryNode>() {\n-        @Override\n-        public Iterable<BinaryNode> children(BinaryNode root) {\n-          return Optional.presentInstances(ImmutableList.of(root.left, root.right));\n-        }\n-      };\n-\n-  enum Traversal {\n-    PRE_ORDER {\n-      @Override\n-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {\n-        return viewer.preOrderTraversal(root);\n-      }\n-    },\n-    POST_ORDER {\n-      @Override\n-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {\n-        return viewer.postOrderTraversal(root);\n-      }\n-    },\n-    BREADTH_FIRST {\n-      @Override\n-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {\n-        return viewer.breadthFirstTraversal(root);\n-      }\n-    };\n-\n-    abstract <T> Iterable<T> view(T root, TreeTraverser<T> viewer);\n-  }\n-\n-  private Iterable<BinaryNode> view;\n-\n-  @Param Topology topology;\n-\n-  @Param({\"1\", \"100\", \"10000\", \"1000000\"})\n-  int size;\n-\n-  @Param Traversal traversal;\n-\n-  @Param({\"1234\"})\n-  SpecialRandom rng;\n-\n-  @BeforeExperiment\n-  void setUp() {\n-    this.view = traversal.view(topology.createTree(size, rng).get(), VIEWER);\n-  }\n-\n-  @Benchmark\n-  int traversal(int reps) {\n-    int tmp = 0;\n-\n-    for (int i = 0; i < reps; i++) {\n-      for (BinaryNode node : view) {\n-        tmp += node.x;\n-      }\n-    }\n-    return tmp;\n-  }\n-}"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/collect/TreeTraverserTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "patch": "@@ -29,10 +29,12 @@\n /**\n  * Tests for {@code TreeTraverser}.\n  *\n+ * @deprecated Use {@link com.google.common.graph.Traverser} instead.\n  * @author Louis Wasserman\n  */\n @GwtCompatible\n @NullMarked\n+@Deprecated // Use com.google.common.graph.Traverser instead.\n public class TreeTraverserTest extends TestCase {\n   private static class Node {\n     final char value;"
    },
    {
      "filename": "android/guava/src/com/google/common/collect/TreeTraverser.java",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "patch": "@@ -69,13 +69,14 @@\n  *     their equivalent on the result of {@code Traverser.forTree(tree)} where {@code tree}\n  *     implements {@code SuccessorsFunction}, which has a similar API as {@link #children} or can be\n  *     the same lambda function as passed into {@link #using(Function)}.\n- *     <p>This class is scheduled to be removed in October 2019.\n  */\n-// TODO(b/68134636): Remove by 2019-10\n+// This class is now only available externally for backwards compatibility; it should not be used\n+// internally (hence the package-private visibility and @Deprecated annotation).\n @Deprecated\n @Beta\n @GwtCompatible\n-public abstract class TreeTraverser<T> {\n+public\n+abstract class TreeTraverser<T> {\n   /** Constructor for use by subclasses. */\n   public TreeTraverser() {}\n "
    },
    {
      "filename": "guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java",
      "status": "removed",
      "additions": 0,
      "deletions": 173,
      "changes": 173,
      "patch": "@@ -1,173 +0,0 @@\n-/*\n- * Copyright (C) 2012 The Guava Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package com.google.common.collect;\n-\n-import com.google.caliper.BeforeExperiment;\n-import com.google.caliper.Benchmark;\n-import com.google.caliper.Param;\n-import com.google.common.base.Optional;\n-import com.google.common.primitives.Ints;\n-import java.util.List;\n-import java.util.Random;\n-import org.jspecify.annotations.NullUnmarked;\n-\n-/**\n- * Benchmarks for the {@code TreeTraverser} operations on binary trees.\n- *\n- * @author Louis Wasserman\n- */\n-@NullUnmarked\n-public class BinaryTreeTraverserBenchmark {\n-  private static class BinaryNode {\n-    final int x;\n-    final Optional<BinaryNode> left;\n-    final Optional<BinaryNode> right;\n-\n-    BinaryNode(int x, Optional<BinaryNode> left, Optional<BinaryNode> right) {\n-      this.x = x;\n-      this.left = left;\n-      this.right = right;\n-    }\n-  }\n-\n-  enum Topology {\n-    BALANCED {\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        if (size == 0) {\n-          return Optional.absent();\n-        } else {\n-          int leftChildSize = (size - 1) / 2;\n-          int rightChildSize = size - 1 - leftChildSize;\n-          return Optional.of(\n-              new BinaryNode(\n-                  rng.nextInt(), createTree(leftChildSize, rng), createTree(rightChildSize, rng)));\n-        }\n-      }\n-    },\n-    ALL_LEFT {\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        Optional<BinaryNode> root = Optional.absent();\n-        for (int i = 0; i < size; i++) {\n-          root = Optional.of(new BinaryNode(rng.nextInt(), root, Optional.<BinaryNode>absent()));\n-        }\n-        return root;\n-      }\n-    },\n-    ALL_RIGHT {\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        Optional<BinaryNode> root = Optional.absent();\n-        for (int i = 0; i < size; i++) {\n-          root = Optional.of(new BinaryNode(rng.nextInt(), Optional.<BinaryNode>absent(), root));\n-        }\n-        return root;\n-      }\n-    },\n-    RANDOM {\n-      /**\n-       * Generates a tree with topology selected uniformly at random from the topologies of binary\n-       * trees of the specified size.\n-       */\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        int[] keys = new int[size];\n-        for (int i = 0; i < size; i++) {\n-          keys[i] = rng.nextInt();\n-        }\n-        return createTreap(Ints.asList(keys));\n-      }\n-\n-      // See http://en.wikipedia.org/wiki/Treap for details on the algorithm.\n-      private Optional<BinaryNode> createTreap(List<Integer> keys) {\n-        if (keys.isEmpty()) {\n-          return Optional.absent();\n-        }\n-        int minIndex = 0;\n-        for (int i = 1; i < keys.size(); i++) {\n-          if (keys.get(i) < keys.get(minIndex)) {\n-            minIndex = i;\n-          }\n-        }\n-        Optional<BinaryNode> leftChild = createTreap(keys.subList(0, minIndex));\n-        Optional<BinaryNode> rightChild = createTreap(keys.subList(minIndex + 1, keys.size()));\n-        return Optional.of(new BinaryNode(keys.get(minIndex), leftChild, rightChild));\n-      }\n-    };\n-\n-    abstract Optional<BinaryNode> createTree(int size, Random rng);\n-  }\n-\n-  private static final TreeTraverser<BinaryNode> VIEWER =\n-      new TreeTraverser<BinaryNode>() {\n-        @Override\n-        public Iterable<BinaryNode> children(BinaryNode root) {\n-          return Optional.presentInstances(ImmutableList.of(root.left, root.right));\n-        }\n-      };\n-\n-  enum Traversal {\n-    PRE_ORDER {\n-      @Override\n-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {\n-        return viewer.preOrderTraversal(root);\n-      }\n-    },\n-    POST_ORDER {\n-      @Override\n-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {\n-        return viewer.postOrderTraversal(root);\n-      }\n-    },\n-    BREADTH_FIRST {\n-      @Override\n-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {\n-        return viewer.breadthFirstTraversal(root);\n-      }\n-    };\n-\n-    abstract <T> Iterable<T> view(T root, TreeTraverser<T> viewer);\n-  }\n-\n-  private Iterable<BinaryNode> view;\n-\n-  @Param Topology topology;\n-\n-  @Param({\"1\", \"100\", \"10000\", \"1000000\"})\n-  int size;\n-\n-  @Param Traversal traversal;\n-\n-  @Param({\"1234\"})\n-  SpecialRandom rng;\n-\n-  @BeforeExperiment\n-  void setUp() {\n-    this.view = traversal.view(topology.createTree(size, rng).get(), VIEWER);\n-  }\n-\n-  @Benchmark\n-  int traversal(int reps) {\n-    int tmp = 0;\n-\n-    for (int i = 0; i < reps; i++) {\n-      for (BinaryNode node : view) {\n-        tmp += node.x;\n-      }\n-    }\n-    return tmp;\n-  }\n-}"
    },
    {
      "filename": "guava-tests/test/com/google/common/collect/TreeTraverserTest.java",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "patch": "@@ -29,10 +29,12 @@\n /**\n  * Tests for {@code TreeTraverser}.\n  *\n+ * @deprecated Use {@link com.google.common.graph.Traverser} instead.\n  * @author Louis Wasserman\n  */\n @GwtCompatible\n @NullMarked\n+@Deprecated // Use com.google.common.graph.Traverser instead.\n public class TreeTraverserTest extends TestCase {\n   private static class Node {\n     final char value;"
    },
    {
      "filename": "guava/src/com/google/common/collect/TreeTraverser.java",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "patch": "@@ -70,13 +70,14 @@\n  *     their equivalent on the result of {@code Traverser.forTree(tree)} where {@code tree}\n  *     implements {@code SuccessorsFunction}, which has a similar API as {@link #children} or can be\n  *     the same lambda function as passed into {@link #using(Function)}.\n- *     <p>This class is scheduled to be removed in October 2019.\n  */\n-// TODO(b/68134636): Remove by 2019-10\n+// This class is now only available externally for backwards compatibility; it should not be used\n+// internally (hence the package-private visibility and @Deprecated annotation).\n @Deprecated\n @Beta\n @GwtCompatible\n-public abstract class TreeTraverser<T> {\n+public\n+abstract class TreeTraverser<T> {\n   /** Constructor for use by subclasses. */\n   public TreeTraverser() {}\n "
    },
    {
      "filename": "refactorings/TraverserRewrite.java",
      "status": "removed",
      "additions": 0,
      "deletions": 103,
      "changes": 103,
      "patch": "@@ -1,103 +0,0 @@\n-/*\n- * Copyright (C) 2017 The Guava Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-import com.google.common.collect.TreeTraverser;\n-import com.google.common.graph.Traverser;\n-import com.google.errorprone.refaster.annotation.AfterTemplate;\n-import com.google.errorprone.refaster.annotation.BeforeTemplate;\n-import com.google.errorprone.refaster.annotation.Placeholder;\n-\n-/**\n- * Refaster rules to rewrite usages of {@code com.google.common.collect.TreeTraverser} in terms of\n- * {@code com.google.common.graph.Traverser}.\n- */\n-@SuppressWarnings(\"DefaultPackage\")\n-public class TraverserRewrite {\n-  abstract class TreeTraverserPreOrder<N> {\n-    @Placeholder\n-    abstract Iterable<N> getChildren(N node);\n-\n-    @BeforeTemplate\n-    Iterable<N> before1(N root) {\n-      return TreeTraverser.using((N node) -> getChildren(node)).preOrderTraversal(root);\n-    }\n-\n-    @BeforeTemplate\n-    Iterable<N> before2(N root) {\n-      return new TreeTraverser<N>() {\n-        @Override\n-        public Iterable<N> children(N node) {\n-          return getChildren(node);\n-        }\n-      }.preOrderTraversal(root);\n-    }\n-\n-    @AfterTemplate\n-    Iterable<N> after(N root) {\n-      return Traverser.forTree((N node) -> getChildren(node)).depthFirstPreOrder(root);\n-    }\n-  }\n-\n-  abstract class TreeTraverserPostOrder<N> {\n-    @Placeholder\n-    abstract Iterable<N> getChildren(N node);\n-\n-    @BeforeTemplate\n-    Iterable<N> before1(N root) {\n-      return TreeTraverser.using((N node) -> getChildren(node)).postOrderTraversal(root);\n-    }\n-\n-    @BeforeTemplate\n-    Iterable<N> before2(N root) {\n-      return new TreeTraverser<N>() {\n-        @Override\n-        public Iterable<N> children(N node) {\n-          return getChildren(node);\n-        }\n-      }.postOrderTraversal(root);\n-    }\n-\n-    @AfterTemplate\n-    Iterable<N> after(N root) {\n-      return Traverser.forTree((N node) -> getChildren(node)).depthFirstPostOrder(root);\n-    }\n-  }\n-\n-  abstract class TreeTraverserBreadthFirst<N> {\n-    @Placeholder\n-    abstract Iterable<N> getChildren(N node);\n-\n-    @BeforeTemplate\n-    Iterable<N> before1(N root) {\n-      return TreeTraverser.using((N node) -> getChildren(node)).breadthFirstTraversal(root);\n-    }\n-\n-    @BeforeTemplate\n-    Iterable<N> before2(N root) {\n-      return new TreeTraverser<N>() {\n-        @Override\n-        public Iterable<N> children(N node) {\n-          return getChildren(node);\n-        }\n-      }.breadthFirstTraversal(root);\n-    }\n-\n-    @AfterTemplate\n-    Iterable<N> after(N root) {\n-      return Traverser.forTree((N node) -> getChildren(node)).breadthFirst(root);\n-    }\n-  }\n-}"
    }
  ],
  "diff": "diff --git a/android/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java b/android/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java\ndeleted file mode 100644\nindex 76e04fddfc81..000000000000\n--- a/android/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java\n+++ /dev/null\n@@ -1,173 +0,0 @@\n-/*\n- * Copyright (C) 2012 The Guava Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package com.google.common.collect;\n-\n-import com.google.caliper.BeforeExperiment;\n-import com.google.caliper.Benchmark;\n-import com.google.caliper.Param;\n-import com.google.common.base.Optional;\n-import com.google.common.primitives.Ints;\n-import java.util.List;\n-import java.util.Random;\n-import org.jspecify.annotations.NullUnmarked;\n-\n-/**\n- * Benchmarks for the {@code TreeTraverser} operations on binary trees.\n- *\n- * @author Louis Wasserman\n- */\n-@NullUnmarked\n-public class BinaryTreeTraverserBenchmark {\n-  private static class BinaryNode {\n-    final int x;\n-    final Optional<BinaryNode> left;\n-    final Optional<BinaryNode> right;\n-\n-    BinaryNode(int x, Optional<BinaryNode> left, Optional<BinaryNode> right) {\n-      this.x = x;\n-      this.left = left;\n-      this.right = right;\n-    }\n-  }\n-\n-  enum Topology {\n-    BALANCED {\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        if (size == 0) {\n-          return Optional.absent();\n-        } else {\n-          int leftChildSize = (size - 1) / 2;\n-          int rightChildSize = size - 1 - leftChildSize;\n-          return Optional.of(\n-              new BinaryNode(\n-                  rng.nextInt(), createTree(leftChildSize, rng), createTree(rightChildSize, rng)));\n-        }\n-      }\n-    },\n-    ALL_LEFT {\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        Optional<BinaryNode> root = Optional.absent();\n-        for (int i = 0; i < size; i++) {\n-          root = Optional.of(new BinaryNode(rng.nextInt(), root, Optional.<BinaryNode>absent()));\n-        }\n-        return root;\n-      }\n-    },\n-    ALL_RIGHT {\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        Optional<BinaryNode> root = Optional.absent();\n-        for (int i = 0; i < size; i++) {\n-          root = Optional.of(new BinaryNode(rng.nextInt(), Optional.<BinaryNode>absent(), root));\n-        }\n-        return root;\n-      }\n-    },\n-    RANDOM {\n-      /**\n-       * Generates a tree with topology selected uniformly at random from the topologies of binary\n-       * trees of the specified size.\n-       */\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        int[] keys = new int[size];\n-        for (int i = 0; i < size; i++) {\n-          keys[i] = rng.nextInt();\n-        }\n-        return createTreap(Ints.asList(keys));\n-      }\n-\n-      // See http://en.wikipedia.org/wiki/Treap for details on the algorithm.\n-      private Optional<BinaryNode> createTreap(List<Integer> keys) {\n-        if (keys.isEmpty()) {\n-          return Optional.absent();\n-        }\n-        int minIndex = 0;\n-        for (int i = 1; i < keys.size(); i++) {\n-          if (keys.get(i) < keys.get(minIndex)) {\n-            minIndex = i;\n-          }\n-        }\n-        Optional<BinaryNode> leftChild = createTreap(keys.subList(0, minIndex));\n-        Optional<BinaryNode> rightChild = createTreap(keys.subList(minIndex + 1, keys.size()));\n-        return Optional.of(new BinaryNode(keys.get(minIndex), leftChild, rightChild));\n-      }\n-    };\n-\n-    abstract Optional<BinaryNode> createTree(int size, Random rng);\n-  }\n-\n-  private static final TreeTraverser<BinaryNode> VIEWER =\n-      new TreeTraverser<BinaryNode>() {\n-        @Override\n-        public Iterable<BinaryNode> children(BinaryNode root) {\n-          return Optional.presentInstances(ImmutableList.of(root.left, root.right));\n-        }\n-      };\n-\n-  enum Traversal {\n-    PRE_ORDER {\n-      @Override\n-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {\n-        return viewer.preOrderTraversal(root);\n-      }\n-    },\n-    POST_ORDER {\n-      @Override\n-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {\n-        return viewer.postOrderTraversal(root);\n-      }\n-    },\n-    BREADTH_FIRST {\n-      @Override\n-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {\n-        return viewer.breadthFirstTraversal(root);\n-      }\n-    };\n-\n-    abstract <T> Iterable<T> view(T root, TreeTraverser<T> viewer);\n-  }\n-\n-  private Iterable<BinaryNode> view;\n-\n-  @Param Topology topology;\n-\n-  @Param({\"1\", \"100\", \"10000\", \"1000000\"})\n-  int size;\n-\n-  @Param Traversal traversal;\n-\n-  @Param({\"1234\"})\n-  SpecialRandom rng;\n-\n-  @BeforeExperiment\n-  void setUp() {\n-    this.view = traversal.view(topology.createTree(size, rng).get(), VIEWER);\n-  }\n-\n-  @Benchmark\n-  int traversal(int reps) {\n-    int tmp = 0;\n-\n-    for (int i = 0; i < reps; i++) {\n-      for (BinaryNode node : view) {\n-        tmp += node.x;\n-      }\n-    }\n-    return tmp;\n-  }\n-}\ndiff --git a/android/guava-tests/test/com/google/common/collect/TreeTraverserTest.java b/android/guava-tests/test/com/google/common/collect/TreeTraverserTest.java\nindex 4dc03d65bdb6..428650e42f81 100644\n--- a/android/guava-tests/test/com/google/common/collect/TreeTraverserTest.java\n+++ b/android/guava-tests/test/com/google/common/collect/TreeTraverserTest.java\n@@ -29,10 +29,12 @@\n /**\n  * Tests for {@code TreeTraverser}.\n  *\n+ * @deprecated Use {@link com.google.common.graph.Traverser} instead.\n  * @author Louis Wasserman\n  */\n @GwtCompatible\n @NullMarked\n+@Deprecated // Use com.google.common.graph.Traverser instead.\n public class TreeTraverserTest extends TestCase {\n   private static class Node {\n     final char value;\ndiff --git a/android/guava/src/com/google/common/collect/TreeTraverser.java b/android/guava/src/com/google/common/collect/TreeTraverser.java\nindex acdca30bd4a0..bcffbc16bab6 100644\n--- a/android/guava/src/com/google/common/collect/TreeTraverser.java\n+++ b/android/guava/src/com/google/common/collect/TreeTraverser.java\n@@ -69,13 +69,14 @@\n  *     their equivalent on the result of {@code Traverser.forTree(tree)} where {@code tree}\n  *     implements {@code SuccessorsFunction}, which has a similar API as {@link #children} or can be\n  *     the same lambda function as passed into {@link #using(Function)}.\n- *     <p>This class is scheduled to be removed in October 2019.\n  */\n-// TODO(b/68134636): Remove by 2019-10\n+// This class is now only available externally for backwards compatibility; it should not be used\n+// internally (hence the package-private visibility and @Deprecated annotation).\n @Deprecated\n @Beta\n @GwtCompatible\n-public abstract class TreeTraverser<T> {\n+public\n+abstract class TreeTraverser<T> {\n   /** Constructor for use by subclasses. */\n   public TreeTraverser() {}\n \ndiff --git a/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java b/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java\ndeleted file mode 100644\nindex 76e04fddfc81..000000000000\n--- a/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java\n+++ /dev/null\n@@ -1,173 +0,0 @@\n-/*\n- * Copyright (C) 2012 The Guava Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-\n-package com.google.common.collect;\n-\n-import com.google.caliper.BeforeExperiment;\n-import com.google.caliper.Benchmark;\n-import com.google.caliper.Param;\n-import com.google.common.base.Optional;\n-import com.google.common.primitives.Ints;\n-import java.util.List;\n-import java.util.Random;\n-import org.jspecify.annotations.NullUnmarked;\n-\n-/**\n- * Benchmarks for the {@code TreeTraverser} operations on binary trees.\n- *\n- * @author Louis Wasserman\n- */\n-@NullUnmarked\n-public class BinaryTreeTraverserBenchmark {\n-  private static class BinaryNode {\n-    final int x;\n-    final Optional<BinaryNode> left;\n-    final Optional<BinaryNode> right;\n-\n-    BinaryNode(int x, Optional<BinaryNode> left, Optional<BinaryNode> right) {\n-      this.x = x;\n-      this.left = left;\n-      this.right = right;\n-    }\n-  }\n-\n-  enum Topology {\n-    BALANCED {\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        if (size == 0) {\n-          return Optional.absent();\n-        } else {\n-          int leftChildSize = (size - 1) / 2;\n-          int rightChildSize = size - 1 - leftChildSize;\n-          return Optional.of(\n-              new BinaryNode(\n-                  rng.nextInt(), createTree(leftChildSize, rng), createTree(rightChildSize, rng)));\n-        }\n-      }\n-    },\n-    ALL_LEFT {\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        Optional<BinaryNode> root = Optional.absent();\n-        for (int i = 0; i < size; i++) {\n-          root = Optional.of(new BinaryNode(rng.nextInt(), root, Optional.<BinaryNode>absent()));\n-        }\n-        return root;\n-      }\n-    },\n-    ALL_RIGHT {\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        Optional<BinaryNode> root = Optional.absent();\n-        for (int i = 0; i < size; i++) {\n-          root = Optional.of(new BinaryNode(rng.nextInt(), Optional.<BinaryNode>absent(), root));\n-        }\n-        return root;\n-      }\n-    },\n-    RANDOM {\n-      /**\n-       * Generates a tree with topology selected uniformly at random from the topologies of binary\n-       * trees of the specified size.\n-       */\n-      @Override\n-      Optional<BinaryNode> createTree(int size, Random rng) {\n-        int[] keys = new int[size];\n-        for (int i = 0; i < size; i++) {\n-          keys[i] = rng.nextInt();\n-        }\n-        return createTreap(Ints.asList(keys));\n-      }\n-\n-      // See http://en.wikipedia.org/wiki/Treap for details on the algorithm.\n-      private Optional<BinaryNode> createTreap(List<Integer> keys) {\n-        if (keys.isEmpty()) {\n-          return Optional.absent();\n-        }\n-        int minIndex = 0;\n-        for (int i = 1; i < keys.size(); i++) {\n-          if (keys.get(i) < keys.get(minIndex)) {\n-            minIndex = i;\n-          }\n-        }\n-        Optional<BinaryNode> leftChild = createTreap(keys.subList(0, minIndex));\n-        Optional<BinaryNode> rightChild = createTreap(keys.subList(minIndex + 1, keys.size()));\n-        return Optional.of(new BinaryNode(keys.get(minIndex), leftChild, rightChild));\n-      }\n-    };\n-\n-    abstract Optional<BinaryNode> createTree(int size, Random rng);\n-  }\n-\n-  private static final TreeTraverser<BinaryNode> VIEWER =\n-      new TreeTraverser<BinaryNode>() {\n-        @Override\n-        public Iterable<BinaryNode> children(BinaryNode root) {\n-          return Optional.presentInstances(ImmutableList.of(root.left, root.right));\n-        }\n-      };\n-\n-  enum Traversal {\n-    PRE_ORDER {\n-      @Override\n-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {\n-        return viewer.preOrderTraversal(root);\n-      }\n-    },\n-    POST_ORDER {\n-      @Override\n-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {\n-        return viewer.postOrderTraversal(root);\n-      }\n-    },\n-    BREADTH_FIRST {\n-      @Override\n-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {\n-        return viewer.breadthFirstTraversal(root);\n-      }\n-    };\n-\n-    abstract <T> Iterable<T> view(T root, TreeTraverser<T> viewer);\n-  }\n-\n-  private Iterable<BinaryNode> view;\n-\n-  @Param Topology topology;\n-\n-  @Param({\"1\", \"100\", \"10000\", \"1000000\"})\n-  int size;\n-\n-  @Param Traversal traversal;\n-\n-  @Param({\"1234\"})\n-  SpecialRandom rng;\n-\n-  @BeforeExperiment\n-  void setUp() {\n-    this.view = traversal.view(topology.createTree(size, rng).get(), VIEWER);\n-  }\n-\n-  @Benchmark\n-  int traversal(int reps) {\n-    int tmp = 0;\n-\n-    for (int i = 0; i < reps; i++) {\n-      for (BinaryNode node : view) {\n-        tmp += node.x;\n-      }\n-    }\n-    return tmp;\n-  }\n-}\ndiff --git a/guava-tests/test/com/google/common/collect/TreeTraverserTest.java b/guava-tests/test/com/google/common/collect/TreeTraverserTest.java\nindex bcb8daae8826..5b6694ad666b 100644\n--- a/guava-tests/test/com/google/common/collect/TreeTraverserTest.java\n+++ b/guava-tests/test/com/google/common/collect/TreeTraverserTest.java\n@@ -29,10 +29,12 @@\n /**\n  * Tests for {@code TreeTraverser}.\n  *\n+ * @deprecated Use {@link com.google.common.graph.Traverser} instead.\n  * @author Louis Wasserman\n  */\n @GwtCompatible\n @NullMarked\n+@Deprecated // Use com.google.common.graph.Traverser instead.\n public class TreeTraverserTest extends TestCase {\n   private static class Node {\n     final char value;\ndiff --git a/guava/src/com/google/common/collect/TreeTraverser.java b/guava/src/com/google/common/collect/TreeTraverser.java\nindex e2cbf8de9b55..0db81f55b5df 100644\n--- a/guava/src/com/google/common/collect/TreeTraverser.java\n+++ b/guava/src/com/google/common/collect/TreeTraverser.java\n@@ -70,13 +70,14 @@\n  *     their equivalent on the result of {@code Traverser.forTree(tree)} where {@code tree}\n  *     implements {@code SuccessorsFunction}, which has a similar API as {@link #children} or can be\n  *     the same lambda function as passed into {@link #using(Function)}.\n- *     <p>This class is scheduled to be removed in October 2019.\n  */\n-// TODO(b/68134636): Remove by 2019-10\n+// This class is now only available externally for backwards compatibility; it should not be used\n+// internally (hence the package-private visibility and @Deprecated annotation).\n @Deprecated\n @Beta\n @GwtCompatible\n-public abstract class TreeTraverser<T> {\n+public\n+abstract class TreeTraverser<T> {\n   /** Constructor for use by subclasses. */\n   public TreeTraverser() {}\n \ndiff --git a/refactorings/TraverserRewrite.java b/refactorings/TraverserRewrite.java\ndeleted file mode 100644\nindex 74e068462d00..000000000000\n--- a/refactorings/TraverserRewrite.java\n+++ /dev/null\n@@ -1,103 +0,0 @@\n-/*\n- * Copyright (C) 2017 The Guava Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-import com.google.common.collect.TreeTraverser;\n-import com.google.common.graph.Traverser;\n-import com.google.errorprone.refaster.annotation.AfterTemplate;\n-import com.google.errorprone.refaster.annotation.BeforeTemplate;\n-import com.google.errorprone.refaster.annotation.Placeholder;\n-\n-/**\n- * Refaster rules to rewrite usages of {@code com.google.common.collect.TreeTraverser} in terms of\n- * {@code com.google.common.graph.Traverser}.\n- */\n-@SuppressWarnings(\"DefaultPackage\")\n-public class TraverserRewrite {\n-  abstract class TreeTraverserPreOrder<N> {\n-    @Placeholder\n-    abstract Iterable<N> getChildren(N node);\n-\n-    @BeforeTemplate\n-    Iterable<N> before1(N root) {\n-      return TreeTraverser.using((N node) -> getChildren(node)).preOrderTraversal(root);\n-    }\n-\n-    @BeforeTemplate\n-    Iterable<N> before2(N root) {\n-      return new TreeTraverser<N>() {\n-        @Override\n-        public Iterable<N> children(N node) {\n-          return getChildren(node);\n-        }\n-      }.preOrderTraversal(root);\n-    }\n-\n-    @AfterTemplate\n-    Iterable<N> after(N root) {\n-      return Traverser.forTree((N node) -> getChildren(node)).depthFirstPreOrder(root);\n-    }\n-  }\n-\n-  abstract class TreeTraverserPostOrder<N> {\n-    @Placeholder\n-    abstract Iterable<N> getChildren(N node);\n-\n-    @BeforeTemplate\n-    Iterable<N> before1(N root) {\n-      return TreeTraverser.using((N node) -> getChildren(node)).postOrderTraversal(root);\n-    }\n-\n-    @BeforeTemplate\n-    Iterable<N> before2(N root) {\n-      return new TreeTraverser<N>() {\n-        @Override\n-        public Iterable<N> children(N node) {\n-          return getChildren(node);\n-        }\n-      }.postOrderTraversal(root);\n-    }\n-\n-    @AfterTemplate\n-    Iterable<N> after(N root) {\n-      return Traverser.forTree((N node) -> getChildren(node)).depthFirstPostOrder(root);\n-    }\n-  }\n-\n-  abstract class TreeTraverserBreadthFirst<N> {\n-    @Placeholder\n-    abstract Iterable<N> getChildren(N node);\n-\n-    @BeforeTemplate\n-    Iterable<N> before1(N root) {\n-      return TreeTraverser.using((N node) -> getChildren(node)).breadthFirstTraversal(root);\n-    }\n-\n-    @BeforeTemplate\n-    Iterable<N> before2(N root) {\n-      return new TreeTraverser<N>() {\n-        @Override\n-        public Iterable<N> children(N node) {\n-          return getChildren(node);\n-        }\n-      }.breadthFirstTraversal(root);\n-    }\n-\n-    @AfterTemplate\n-    Iterable<N> after(N root) {\n-      return Traverser.forTree((N node) -> getChildren(node)).breadthFirst(root);\n-    }\n-  }\n-}\n",
  "additions": 12,
  "deletions": 455,
  "changed_files": 7,
  "url": "https://github.com/google/guava/pull/7951",
  "mined_at": "2025-10-25T12:55:59.206140"
}