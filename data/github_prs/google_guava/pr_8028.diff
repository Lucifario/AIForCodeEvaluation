diff --git a/android/guava-tests/test/com/google/common/cache/AbstractCacheTest.java b/android/guava-tests/test/com/google/common/cache/AbstractCacheTest.java
index f803fccedfe7..6a1fc772cf57 100644
--- a/android/guava-tests/test/com/google/common/cache/AbstractCacheTest.java
+++ b/android/guava-tests/test/com/google/common/cache/AbstractCacheTest.java
@@ -21,7 +21,6 @@
 import com.google.common.cache.AbstractCache.SimpleStatsCounter;
 import com.google.common.cache.AbstractCache.StatsCounter;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
@@ -47,11 +46,11 @@ public void testGetIfPresent() {
           }
         };
 
-    assertNull(cache.getIfPresent(new Object()));
+    assertThat(cache.getIfPresent(new Object())).isNull();
 
     Object newValue = new Object();
     valueRef.set(newValue);
-    assertSame(newValue, cache.getIfPresent(new Object()));
+    assertThat(cache.getIfPresent(new Object())).isSameInstanceAs(newValue);
   }
 
   public void testGetAllPresent_empty() {
@@ -63,7 +62,7 @@ public void testGetAllPresent_empty() {
           }
         };
 
-    assertEquals(ImmutableMap.of(), cache.getAllPresent(ImmutableList.of(new Object())));
+    assertThat(cache.getAllPresent(ImmutableList.of(new Object()))).isEmpty();
   }
 
   public void testGetAllPresent_cached() {
@@ -77,9 +76,8 @@ public void testGetAllPresent_cached() {
           }
         };
 
-    assertEquals(
-        ImmutableMap.of(cachedKey, cachedValue),
-        cache.getAllPresent(ImmutableList.of(cachedKey, new Object())));
+    assertThat(cache.getAllPresent(ImmutableList.of(cachedKey, new Object())))
+        .containsExactly(cachedKey, cachedValue);
   }
 
   public void testInvalidateAll() {
@@ -99,23 +97,23 @@ public void invalidate(Object key) {
 
     List<Integer> toInvalidate = ImmutableList.of(1, 2, 3, 4);
     cache.invalidateAll(toInvalidate);
-    assertEquals(toInvalidate, invalidated);
+    assertThat(invalidated).isEqualTo(toInvalidate);
   }
 
   public void testEmptySimpleStats() {
     StatsCounter counter = new SimpleStatsCounter();
     CacheStats stats = counter.snapshot();
-    assertEquals(0, stats.requestCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
     assertThat(stats.hitRate()).isEqualTo(1.0);
-    assertEquals(0, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(0);
     assertThat(stats.missRate()).isEqualTo(0.0);
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.loadCount());
-    assertEquals(0, stats.totalLoadTime());
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.loadCount()).isEqualTo(0);
+    assertThat(stats.totalLoadTime()).isEqualTo(0);
     assertThat(stats.averageLoadPenalty()).isEqualTo(0.0);
-    assertEquals(0, stats.evictionCount());
+    assertThat(stats.evictionCount()).isEqualTo(0);
   }
 
   public void testSingleSimpleStats() {
@@ -137,18 +135,18 @@ public void testSingleSimpleStats() {
     }
     CacheStats stats = counter.snapshot();
     int requestCount = 11 + 23;
-    assertEquals(requestCount, stats.requestCount());
-    assertEquals(11, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(requestCount);
+    assertThat(stats.hitCount()).isEqualTo(11);
     assertThat(stats.hitRate()).isEqualTo(11.0 / requestCount);
     int missCount = 23;
-    assertEquals(missCount, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(missCount);
     assertThat(stats.missRate()).isEqualTo(((double) missCount) / requestCount);
-    assertEquals(13, stats.loadSuccessCount());
-    assertEquals(17, stats.loadExceptionCount());
-    assertEquals(13 + 17, stats.loadCount());
-    assertEquals(214, stats.totalLoadTime());
+    assertThat(stats.loadSuccessCount()).isEqualTo(13);
+    assertThat(stats.loadExceptionCount()).isEqualTo(17);
+    assertThat(stats.loadCount()).isEqualTo(13 + 17);
+    assertThat(stats.totalLoadTime()).isEqualTo(214);
     assertThat(stats.averageLoadPenalty()).isEqualTo(214.0 / (13 + 17));
-    assertEquals(27, stats.evictionCount());
+    assertThat(stats.evictionCount()).isEqualTo(27);
   }
 
   public void testSimpleStatsOverflow() {
@@ -156,7 +154,7 @@ public void testSimpleStatsOverflow() {
     counter.recordLoadSuccess(Long.MAX_VALUE);
     counter.recordLoadSuccess(1);
     CacheStats stats = counter.snapshot();
-    assertEquals(Long.MAX_VALUE, stats.totalLoadTime());
+    assertThat(stats.totalLoadTime()).isEqualTo(Long.MAX_VALUE);
   }
 
   public void testSimpleStatsIncrementBy() {
@@ -201,6 +199,6 @@ public void testSimpleStatsIncrementBy() {
     }
 
     counter1.incrementBy(counter2);
-    assertEquals(new CacheStats(38, 60, 44, 54, totalLoadTime, 66), counter1.snapshot());
+    assertThat(counter1.snapshot()).isEqualTo(new CacheStats(38, 60, 44, 54, totalLoadTime, 66));
   }
 }
diff --git a/android/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java b/android/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java
index 6548982acc49..85b37bf24ed6 100644
--- a/android/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java
+++ b/android/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java
@@ -61,7 +61,7 @@ public Object get(Object key) throws ExecutionException {
 
     Object newValue = new Object();
     valueRef.set(newValue);
-    assertSame(newValue, cache.getUnchecked(new Object()));
+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);
   }
 
   public void testGetUnchecked_unchecked() {
@@ -90,7 +90,7 @@ public Object get(Object key) throws ExecutionException {
 
     Object newValue = new Object();
     valueRef.set(newValue);
-    assertSame(newValue, cache.getUnchecked(new Object()));
+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);
   }
 
   public void testGetUnchecked_error() {
@@ -119,7 +119,7 @@ public Object get(Object key) throws ExecutionException {
 
     Object newValue = new Object();
     valueRef.set(newValue);
-    assertSame(newValue, cache.getUnchecked(new Object()));
+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);
   }
 
   public void testGetUnchecked_otherThrowable() {
@@ -148,6 +148,6 @@ public Object get(Object key) throws ExecutionException {
 
     Object newValue = new Object();
     valueRef.set(newValue);
-    assertSame(newValue, cache.getUnchecked(new Object()));
+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);
   }
 }
diff --git a/android/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java b/android/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java
index 20cfb8311aff..116d6e66327f 100644
--- a/android/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java
+++ b/android/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java
@@ -16,6 +16,7 @@
 
 package com.google.common.cache;
 
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 import com.google.common.annotations.GwtCompatible;
@@ -31,8 +32,11 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ExecutionException;
-import junit.framework.TestCase;
 import org.jspecify.annotations.NullUnmarked;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 /**
  * Test suite for {@link CacheBuilder}. TODO(cpovirk): merge into CacheBuilderTest?
@@ -41,18 +45,18 @@
  */
 @GwtCompatible
 @NullUnmarked
-public class CacheBuilderGwtTest extends TestCase {
+@RunWith(JUnit4.class)
+public class CacheBuilderGwtTest {
 
   private FakeTicker fakeTicker;
 
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-
+  @Before
+  public void setUp() {
     fakeTicker = new FakeTicker();
   }
 
-  public void testLoader() throws ExecutionException {
+  @Test
+  public void loader() throws ExecutionException {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();
 
     Callable<Integer> loader =
@@ -67,19 +71,20 @@ public Integer call() throws Exception {
 
     cache.put(0, 10);
 
-    assertEquals(Integer.valueOf(10), cache.get(0, loader));
-    assertEquals(Integer.valueOf(1), cache.get(20, loader));
-    assertEquals(Integer.valueOf(2), cache.get(34, loader));
+    assertThat(cache.get(0, loader)).isEqualTo(10);
+    assertThat(cache.get(20, loader)).isEqualTo(1);
+    assertThat(cache.get(34, loader)).isEqualTo(2);
 
     cache.invalidate(0);
-    assertEquals(Integer.valueOf(3), cache.get(0, loader));
+    assertThat(cache.get(0, loader)).isEqualTo(3);
 
     cache.put(0, 10);
     cache.invalidateAll();
-    assertEquals(Integer.valueOf(4), cache.get(0, loader));
+    assertThat(cache.get(0, loader)).isEqualTo(4);
   }
 
-  public void testSizeConstraint() {
+  @Test
+  public void sizeConstraint() {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().maximumSize(4).build();
 
     cache.put(1, 10);
@@ -88,22 +93,24 @@ public void testSizeConstraint() {
     cache.put(4, 40);
     cache.put(5, 50);
 
-    assertEquals(null, cache.getIfPresent(10));
+    assertThat(cache.getIfPresent(10)).isNull();
     // Order required to remove dependence on access order / write order constraint.
-    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));
-    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));
-    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));
+    assertThat(cache.getIfPresent(2)).isEqualTo(20);
+    assertThat(cache.getIfPresent(3)).isEqualTo(30);
+    assertThat(cache.getIfPresent(4)).isEqualTo(40);
+    assertThat(cache.getIfPresent(5)).isEqualTo(50);
 
     cache.put(1, 10);
-    assertEquals(Integer.valueOf(10), cache.getIfPresent(1));
-    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));
-    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));
-    assertEquals(null, cache.getIfPresent(2));
+    assertThat(cache.getIfPresent(1)).isEqualTo(10);
+    assertThat(cache.getIfPresent(3)).isEqualTo(30);
+    assertThat(cache.getIfPresent(4)).isEqualTo(40);
+    assertThat(cache.getIfPresent(5)).isEqualTo(50);
+    assertThat(cache.getIfPresent(2)).isNull();
   }
 
-  public void testLoadingCache() throws ExecutionException {
+  @SuppressWarnings({"deprecation", "LoadingCacheApply"})
+  @Test
+  public void loadingCache() throws ExecutionException {
     CacheLoader<Integer, Integer> loader =
         new CacheLoader<Integer, Integer>() {
           int i = 0;
@@ -120,17 +127,18 @@ public Integer load(Integer key) throws Exception {
 
     Map<Integer, Integer> map = cache.getAll(ImmutableList.of(10, 20, 30, 54, 443, 1));
 
-    assertEquals(Integer.valueOf(20), map.get(10));
-    assertEquals(Integer.valueOf(0), map.get(20));
-    assertEquals(Integer.valueOf(1), map.get(30));
-    assertEquals(Integer.valueOf(2), map.get(54));
-    assertEquals(Integer.valueOf(3), map.get(443));
-    assertEquals(Integer.valueOf(4), map.get(1));
-    assertEquals(Integer.valueOf(5), cache.get(6));
-    assertEquals(Integer.valueOf(6), cache.apply(7));
+    assertThat(map).containsEntry(10, 20);
+    assertThat(map).containsEntry(20, 0);
+    assertThat(map).containsEntry(30, 1);
+    assertThat(map).containsEntry(54, 2);
+    assertThat(map).containsEntry(443, 3);
+    assertThat(map).containsEntry(1, 4);
+    assertThat(cache.get(6)).isEqualTo(5);
+    assertThat(cache.apply(7)).isEqualTo(6);
   }
 
-  public void testExpireAfterAccess() {
+  @Test
+  public void expireAfterAccess() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterAccess(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -138,14 +146,15 @@ public void testExpireAfterAccess() {
     cache.put(2, 30);
 
     fakeTicker.advance(999, MILLISECONDS);
-    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));
+    assertThat(cache.getIfPresent(2)).isEqualTo(30);
     fakeTicker.advance(1, MILLISECONDS);
-    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));
+    assertThat(cache.getIfPresent(2)).isEqualTo(30);
     fakeTicker.advance(1000, MILLISECONDS);
-    assertEquals(null, cache.getIfPresent(0));
+    assertThat(cache.getIfPresent(0)).isNull();
   }
 
-  public void testExpireAfterWrite() {
+  @Test
+  public void expireAfterWrite() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -154,23 +163,24 @@ public void testExpireAfterWrite() {
     cache.put(4, 2);
 
     fakeTicker.advance(999, MILLISECONDS);
-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));
-    assertEquals(Integer.valueOf(2), cache.getIfPresent(4));
+    assertThat(cache.getIfPresent(10)).isEqualTo(100);
+    assertThat(cache.getIfPresent(20)).isEqualTo(200);
+    assertThat(cache.getIfPresent(4)).isEqualTo(2);
 
     fakeTicker.advance(2, MILLISECONDS);
-    assertEquals(null, cache.getIfPresent(10));
-    assertEquals(null, cache.getIfPresent(20));
-    assertEquals(null, cache.getIfPresent(4));
+    assertThat(cache.getIfPresent(10)).isNull();
+    assertThat(cache.getIfPresent(20)).isNull();
+    assertThat(cache.getIfPresent(4)).isNull();
 
     cache.put(10, 20);
-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));
+    assertThat(cache.getIfPresent(10)).isEqualTo(20);
 
     fakeTicker.advance(1000, MILLISECONDS);
-    assertEquals(null, cache.getIfPresent(10));
+    assertThat(cache.getIfPresent(10)).isNull();
   }
 
-  public void testExpireAfterWriteAndAccess() {
+  @Test
+  public void expireAfterWriteAndAccess() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder()
             .expireAfterWrite(1000, MILLISECONDS)
@@ -183,26 +193,28 @@ public void testExpireAfterWriteAndAccess() {
     cache.put(4, 2);
 
     fakeTicker.advance(499, MILLISECONDS);
-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));
+    assertThat(cache.getIfPresent(10)).isEqualTo(100);
+    assertThat(cache.getIfPresent(20)).isEqualTo(200);
 
     fakeTicker.advance(2, MILLISECONDS);
-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));
-    assertEquals(null, cache.getIfPresent(4));
+    assertThat(cache.getIfPresent(10)).isEqualTo(100);
+    assertThat(cache.getIfPresent(20)).isEqualTo(200);
+    assertThat(cache.getIfPresent(4)).isNull();
 
     fakeTicker.advance(499, MILLISECONDS);
-    assertEquals(null, cache.getIfPresent(10));
-    assertEquals(null, cache.getIfPresent(20));
+    assertThat(cache.getIfPresent(10)).isNull();
+    assertThat(cache.getIfPresent(20)).isNull();
 
     cache.put(10, 20);
-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));
+    assertThat(cache.getIfPresent(10)).isEqualTo(20);
 
     fakeTicker.advance(500, MILLISECONDS);
-    assertEquals(null, cache.getIfPresent(10));
+    assertThat(cache.getIfPresent(10)).isNull();
   }
 
-  public void testMapMethods() {
+  @SuppressWarnings("ContainsEntryAfterGetInteger") // we are testing our implementation of Map.get
+  @Test
+  public void mapMethods() {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();
 
     ConcurrentMap<Integer, Integer> asMap = cache.asMap();
@@ -213,38 +225,39 @@ public void testMapMethods() {
     asMap.replace(2, 79);
     asMap.replace(3, 60);
 
-    assertEquals(null, cache.getIfPresent(3));
-    assertEquals(null, asMap.get(3));
+    assertThat(cache.getIfPresent(3)).isNull();
+    assertThat(asMap.get(3)).isNull();
 
-    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));
-    assertEquals(Integer.valueOf(79), asMap.get(2));
+    assertThat(cache.getIfPresent(2)).isEqualTo(79);
+    assertThat(asMap.get(2)).isEqualTo(79);
 
     asMap.replace(10, 100, 50);
     asMap.replace(2, 52, 99);
 
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(50), asMap.get(10));
-    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));
-    assertEquals(Integer.valueOf(79), asMap.get(2));
+    assertThat(cache.getIfPresent(10)).isEqualTo(50);
+    assertThat(asMap.get(10)).isEqualTo(50);
+    assertThat(cache.getIfPresent(2)).isEqualTo(79);
+    assertThat(asMap.get(2)).isEqualTo(79);
 
     asMap.remove(10, 100);
     asMap.remove(2, 79);
 
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(50), asMap.get(10));
-    assertEquals(null, cache.getIfPresent(2));
-    assertEquals(null, asMap.get(2));
+    assertThat(cache.getIfPresent(10)).isEqualTo(50);
+    assertThat(asMap.get(10)).isEqualTo(50);
+    assertThat(cache.getIfPresent(2)).isNull();
+    assertThat(asMap.get(2)).isNull();
 
     asMap.putIfAbsent(2, 20);
     asMap.putIfAbsent(10, 20);
 
-    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));
-    assertEquals(Integer.valueOf(20), asMap.get(2));
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(50), asMap.get(10));
+    assertThat(cache.getIfPresent(2)).isEqualTo(20);
+    assertThat(asMap.get(2)).isEqualTo(20);
+    assertThat(cache.getIfPresent(10)).isEqualTo(50);
+    assertThat(asMap.get(10)).isEqualTo(50);
   }
 
-  public void testRemovalListener() {
+  @Test
+  public void removalListener() {
     int[] stats = new int[4];
 
     RemovalListener<Integer, Integer> countingListener =
@@ -303,30 +316,32 @@ public void onRemoval(RemovalNotification<Integer, Integer> notification) {
 
     cache.invalidateAll();
 
-    assertEquals(2, stats[0]);
-    assertEquals(2, stats[1]);
-    assertEquals(4, stats[2]);
-    assertEquals(3, stats[3]);
+    assertThat(stats[0]).isEqualTo(2);
+    assertThat(stats[1]).isEqualTo(2);
+    assertThat(stats[2]).isEqualTo(4);
+    assertThat(stats[3]).isEqualTo(3);
   }
 
-  public void testPutAll() {
+  @Test
+  public void putAll() {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();
 
     cache.putAll(ImmutableMap.of(10, 20, 30, 50, 60, 90));
 
-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(30));
-    assertEquals(Integer.valueOf(90), cache.getIfPresent(60));
+    assertThat(cache.getIfPresent(10)).isEqualTo(20);
+    assertThat(cache.getIfPresent(30)).isEqualTo(50);
+    assertThat(cache.getIfPresent(60)).isEqualTo(90);
 
     cache.asMap().putAll(ImmutableMap.of(10, 50, 30, 20, 60, 70, 5, 5));
 
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(20), cache.getIfPresent(30));
-    assertEquals(Integer.valueOf(70), cache.getIfPresent(60));
-    assertEquals(Integer.valueOf(5), cache.getIfPresent(5));
+    assertThat(cache.getIfPresent(10)).isEqualTo(50);
+    assertThat(cache.getIfPresent(30)).isEqualTo(20);
+    assertThat(cache.getIfPresent(60)).isEqualTo(70);
+    assertThat(cache.getIfPresent(5)).isEqualTo(5);
   }
 
-  public void testInvalidate() {
+  @Test
+  public void invalidate() {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();
 
     cache.put(654, 2675);
@@ -335,12 +350,13 @@ public void testInvalidate() {
 
     cache.invalidate(654);
 
-    assertFalse(cache.asMap().containsKey(654));
-    assertTrue(cache.asMap().containsKey(2456));
-    assertTrue(cache.asMap().containsKey(2));
+    assertThat(cache.asMap().containsKey(654)).isFalse();
+    assertThat(cache.asMap().containsKey(2456)).isTrue();
+    assertThat(cache.asMap().containsKey(2)).isTrue();
   }
 
-  public void testInvalidateAll() {
+  @Test
+  public void invalidateAll() {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();
 
     cache.put(654, 2675);
@@ -348,9 +364,9 @@ public void testInvalidateAll() {
     cache.put(2, 15);
 
     cache.invalidateAll();
-    assertFalse(cache.asMap().containsKey(654));
-    assertFalse(cache.asMap().containsKey(2456));
-    assertFalse(cache.asMap().containsKey(2));
+    assertThat(cache.asMap().containsKey(654)).isFalse();
+    assertThat(cache.asMap().containsKey(2456)).isFalse();
+    assertThat(cache.asMap().containsKey(2)).isFalse();
 
     cache.put(654, 2675);
     cache.put(2456, 56);
@@ -359,13 +375,14 @@ public void testInvalidateAll() {
 
     cache.invalidateAll(ImmutableSet.of(1, 2));
 
-    assertFalse(cache.asMap().containsKey(1));
-    assertFalse(cache.asMap().containsKey(2));
-    assertTrue(cache.asMap().containsKey(654));
-    assertTrue(cache.asMap().containsKey(2456));
+    assertThat(cache.asMap().containsKey(1)).isFalse();
+    assertThat(cache.asMap().containsKey(2)).isFalse();
+    assertThat(cache.asMap().containsKey(654)).isTrue();
+    assertThat(cache.asMap().containsKey(2456)).isTrue();
   }
 
-  public void testAsMap_containsValue() {
+  @Test
+  public void asMap_containsValue() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(20000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -376,12 +393,15 @@ public void testAsMap_containsValue() {
 
     fakeTicker.advance(10001, MILLISECONDS);
 
-    assertTrue(cache.asMap().containsValue(15));
-    assertTrue(cache.asMap().containsValue(56));
-    assertFalse(cache.asMap().containsValue(2675));
+    assertThat(cache.asMap().containsValue(15)).isTrue();
+    assertThat(cache.asMap().containsValue(56)).isTrue();
+    assertThat(cache.asMap().containsValue(2675)).isFalse();
   }
 
-  public void testAsMap_containsKey() {
+  // we are testing our implementation of Map.containsKey
+  @SuppressWarnings("ContainsEntryAfterGetInteger")
+  @Test
+  public void asMap_containsKey() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(20000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -392,12 +412,15 @@ public void testAsMap_containsKey() {
 
     fakeTicker.advance(10001, MILLISECONDS);
 
-    assertTrue(cache.asMap().containsKey(2));
-    assertTrue(cache.asMap().containsKey(2456));
-    assertFalse(cache.asMap().containsKey(654));
+    assertThat(cache.asMap().containsKey(2)).isTrue();
+    assertThat(cache.asMap().containsKey(2456)).isTrue();
+    assertThat(cache.asMap().containsKey(654)).isFalse();
   }
 
-  public void testAsMapValues_contains() {
+  // we are testing our implementation of Map.values().contains
+  @SuppressWarnings("ValuesContainsValue")
+  @Test
+  public void asMapValues_contains() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -408,12 +431,13 @@ public void testAsMapValues_contains() {
 
     fakeTicker.advance(501, MILLISECONDS);
 
-    assertTrue(cache.asMap().values().contains(22));
-    assertTrue(cache.asMap().values().contains(10));
-    assertFalse(cache.asMap().values().contains(20));
+    assertThat(cache.asMap().values().contains(22)).isTrue();
+    assertThat(cache.asMap().values().contains(10)).isTrue();
+    assertThat(cache.asMap().values().contains(20)).isFalse();
   }
 
-  public void testAsMapKeySet() {
+  @Test
+  public void asMapKeySet() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -426,10 +450,11 @@ public void testAsMapKeySet() {
 
     Set<Integer> foundKeys = new HashSet<>(cache.asMap().keySet());
 
-    assertEquals(ImmutableSet.of(20, 5), foundKeys);
+    assertThat(foundKeys).containsExactly(20, 5);
   }
 
-  public void testAsMapKeySet_contains() {
+  @Test
+  public void asMapKeySet_contains() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -440,12 +465,13 @@ public void testAsMapKeySet_contains() {
 
     fakeTicker.advance(501, MILLISECONDS);
 
-    assertTrue(cache.asMap().keySet().contains(20));
-    assertTrue(cache.asMap().keySet().contains(5));
-    assertFalse(cache.asMap().keySet().contains(10));
+    assertThat(cache.asMap().keySet().contains(20)).isTrue();
+    assertThat(cache.asMap().keySet().contains(5)).isTrue();
+    assertThat(cache.asMap().keySet().contains(10)).isFalse();
   }
 
-  public void testAsMapEntrySet() {
+  @Test
+  public void asMapEntrySet() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -460,10 +486,11 @@ public void testAsMapEntrySet() {
     for (Entry<Integer, Integer> current : cache.asMap().entrySet()) {
       sum += current.getKey() + current.getValue();
     }
-    assertEquals(57, sum);
+    assertThat(sum).isEqualTo(57);
   }
 
-  public void testAsMapValues_iteratorRemove() {
+  @Test
+  public void asMapValues_iteratorRemove() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -472,6 +499,6 @@ public void testAsMapValues_iteratorRemove() {
     iterator.next();
     iterator.remove();
 
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
   }
 }
diff --git a/android/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java b/android/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java
index 670275b08252..7948e82f89f3 100644
--- a/android/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java
+++ b/android/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java
@@ -18,6 +18,8 @@
 
 import static com.google.common.cache.CacheBuilderSpec.parse;
 import static com.google.common.cache.TestingWeighers.constantWeigher;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.util.concurrent.TimeUnit.DAYS;
 import static java.util.concurrent.TimeUnit.HOURS;
 import static java.util.concurrent.TimeUnit.MINUTES;
@@ -40,27 +42,27 @@
 public class CacheBuilderSpecTest extends TestCase {
   public void testParse_empty() {
     CacheBuilderSpec spec = parse("");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(CacheBuilder.newBuilder(), CacheBuilder.from(spec));
   }
 
   public void testParse_initialCapacity() {
     CacheBuilderSpec spec = parse("initialCapacity=10");
-    assertEquals(10, spec.initialCapacity.intValue());
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isEqualTo(10);
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().initialCapacity(10), CacheBuilder.from(spec));
   }
@@ -72,13 +74,13 @@ public void testParse_initialCapacityRepeated() {
 
   public void testParse_maximumSize() {
     CacheBuilderSpec spec = parse("maximumSize=9000");
-    assertNull(spec.initialCapacity);
-    assertEquals(9000, spec.maximumSize.longValue());
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isEqualTo(9000L);
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().maximumSize(9000), CacheBuilder.from(spec));
   }
@@ -89,13 +91,13 @@ public void testParse_maximumSizeRepeated() {
 
   public void testParse_maximumWeight() {
     CacheBuilderSpec spec = parse("maximumWeight=9000");
-    assertNull(spec.initialCapacity);
-    assertEquals(9000, spec.maximumWeight.longValue());
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumWeight).isEqualTo(9000L);
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().maximumWeight(9000), CacheBuilder.from(spec));
   }
@@ -110,14 +112,14 @@ public void testParse_maximumSizeAndMaximumWeight() {
 
   public void testParse_concurrencyLevel() {
     CacheBuilderSpec spec = parse("concurrencyLevel=32");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertEquals(32, spec.concurrencyLevel.intValue());
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isEqualTo(32);
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().concurrencyLevel(32), CacheBuilder.from(spec));
   }
@@ -129,14 +131,14 @@ public void testParse_concurrencyLevelRepeated() {
 
   public void testParse_weakKeys() {
     CacheBuilderSpec spec = parse("weakKeys");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertEquals(Strength.WEAK, spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().weakKeys(), CacheBuilder.from(spec));
   }
 
@@ -150,14 +152,14 @@ public void testParse_repeatedKeyStrength() {
 
   public void testParse_softValues() {
     CacheBuilderSpec spec = parse("softValues");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertEquals(Strength.SOFT, spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isEqualTo(Strength.SOFT);
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().softValues(), CacheBuilder.from(spec));
   }
 
@@ -167,14 +169,14 @@ public void testParse_softValuesCannotHaveValue() {
 
   public void testParse_weakValues() {
     CacheBuilderSpec spec = parse("weakValues");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertEquals(Strength.WEAK, spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isEqualTo(Strength.WEAK);
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().weakValues(), CacheBuilder.from(spec));
   }
 
@@ -194,39 +196,39 @@ public void testParse_repeatedValueStrength() {
 
   public void testParse_writeExpirationDays() {
     CacheBuilderSpec spec = parse("expireAfterWrite=10d");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertEquals(DAYS, spec.writeExpirationTimeUnit);
-    assertEquals(10L, spec.writeExpirationDuration);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(DAYS);
+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterWrite(10L, DAYS), CacheBuilder.from(spec));
   }
 
   public void testParse_writeExpirationHours() {
     CacheBuilderSpec spec = parse("expireAfterWrite=150h");
-    assertEquals(HOURS, spec.writeExpirationTimeUnit);
-    assertEquals(150L, spec.writeExpirationDuration);
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(HOURS);
+    assertThat(spec.writeExpirationDuration).isEqualTo(150L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterWrite(150L, HOURS), CacheBuilder.from(spec));
   }
 
   public void testParse_writeExpirationMinutes() {
     CacheBuilderSpec spec = parse("expireAfterWrite=10m");
-    assertEquals(MINUTES, spec.writeExpirationTimeUnit);
-    assertEquals(10L, spec.writeExpirationDuration);
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(MINUTES);
+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterWrite(10L, MINUTES), CacheBuilder.from(spec));
   }
 
   public void testParse_writeExpirationSeconds() {
     CacheBuilderSpec spec = parse("expireAfterWrite=10s");
-    assertEquals(SECONDS, spec.writeExpirationTimeUnit);
-    assertEquals(10L, spec.writeExpirationDuration);
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(SECONDS);
+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterWrite(10L, SECONDS), CacheBuilder.from(spec));
   }
@@ -238,39 +240,39 @@ public void testParse_writeExpirationRepeated() {
 
   public void testParse_accessExpirationDays() {
     CacheBuilderSpec spec = parse("expireAfterAccess=10d");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertEquals(DAYS, spec.accessExpirationTimeUnit);
-    assertEquals(10L, spec.accessExpirationDuration);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(DAYS);
+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterAccess(10L, DAYS), CacheBuilder.from(spec));
   }
 
   public void testParse_accessExpirationHours() {
     CacheBuilderSpec spec = parse("expireAfterAccess=150h");
-    assertEquals(HOURS, spec.accessExpirationTimeUnit);
-    assertEquals(150L, spec.accessExpirationDuration);
+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(HOURS);
+    assertThat(spec.accessExpirationDuration).isEqualTo(150L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterAccess(150L, HOURS), CacheBuilder.from(spec));
   }
 
   public void testParse_accessExpirationMinutes() {
     CacheBuilderSpec spec = parse("expireAfterAccess=10m");
-    assertEquals(MINUTES, spec.accessExpirationTimeUnit);
-    assertEquals(10L, spec.accessExpirationDuration);
+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(MINUTES);
+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterAccess(10L, MINUTES), CacheBuilder.from(spec));
   }
 
   public void testParse_accessExpirationSeconds() {
     CacheBuilderSpec spec = parse("expireAfterAccess=10s");
-    assertEquals(SECONDS, spec.accessExpirationTimeUnit);
-    assertEquals(10L, spec.accessExpirationDuration);
+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(SECONDS);
+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterAccess(10L, SECONDS), CacheBuilder.from(spec));
   }
@@ -282,7 +284,7 @@ public void testParse_accessExpirationRepeated() {
 
   public void testParse_recordStats() {
     CacheBuilderSpec spec = parse("recordStats");
-    assertTrue(spec.recordStats);
+    assertThat(spec.recordStats).isTrue();
     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().recordStats(), CacheBuilder.from(spec));
   }
 
@@ -296,10 +298,10 @@ public void testParse_recordStatsRepeated() {
 
   public void testParse_accessExpirationAndWriteExpiration() {
     CacheBuilderSpec spec = parse("expireAfterAccess=10s,expireAfterWrite=9m");
-    assertEquals(MINUTES, spec.writeExpirationTimeUnit);
-    assertEquals(9L, spec.writeExpirationDuration);
-    assertEquals(SECONDS, spec.accessExpirationTimeUnit);
-    assertEquals(10L, spec.accessExpirationDuration);
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(MINUTES);
+    assertThat(spec.writeExpirationDuration).isEqualTo(9L);
+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(SECONDS);
+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterAccess(10L, SECONDS).expireAfterWrite(9L, MINUTES),
         CacheBuilder.from(spec));
@@ -310,16 +312,16 @@ public void testParse_multipleKeys() {
         parse(
             "initialCapacity=10,maximumSize=20,concurrencyLevel=30,"
                 + "weakKeys,weakValues,expireAfterAccess=10m,expireAfterWrite=1h");
-    assertEquals(10, spec.initialCapacity.intValue());
-    assertEquals(20, spec.maximumSize.intValue());
-    assertNull(spec.maximumWeight);
-    assertEquals(30, spec.concurrencyLevel.intValue());
-    assertEquals(Strength.WEAK, spec.keyStrength);
-    assertEquals(Strength.WEAK, spec.valueStrength);
-    assertEquals(HOURS, spec.writeExpirationTimeUnit);
-    assertEquals(MINUTES, spec.accessExpirationTimeUnit);
-    assertEquals(1L, spec.writeExpirationDuration);
-    assertEquals(10L, spec.accessExpirationDuration);
+    assertThat(spec.initialCapacity).isEqualTo(10);
+    assertThat(spec.maximumSize).isEqualTo(20);
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isEqualTo(30);
+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);
+    assertThat(spec.valueStrength).isEqualTo(Strength.WEAK);
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(HOURS);
+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(MINUTES);
+    assertThat(spec.writeExpirationDuration).isEqualTo(1L);
+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);
     CacheBuilder<?, ?> expected =
         CacheBuilder.newBuilder()
             .initialCapacity(10)
@@ -337,15 +339,15 @@ public void testParse_whitespaceAllowed() {
         parse(
             " initialCapacity=10,\nmaximumSize=20,\t\r"
                 + "weakKeys \t ,softValues \n , \r  expireAfterWrite \t =  15s\n\n");
-    assertEquals(10, spec.initialCapacity.intValue());
-    assertEquals(20, spec.maximumSize.intValue());
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertEquals(Strength.WEAK, spec.keyStrength);
-    assertEquals(Strength.SOFT, spec.valueStrength);
-    assertEquals(SECONDS, spec.writeExpirationTimeUnit);
-    assertEquals(15L, spec.writeExpirationDuration);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isEqualTo(10);
+    assertThat(spec.maximumSize).isEqualTo(20);
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);
+    assertThat(spec.valueStrength).isEqualTo(Strength.SOFT);
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(SECONDS);
+    assertThat(spec.writeExpirationDuration).isEqualTo(15L);
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     CacheBuilder<?, ?> expected =
         CacheBuilder.newBuilder()
             .initialCapacity(10)
@@ -424,9 +426,9 @@ public void testDisableCaching() {
     Object value = new Object();
     LoadingCache<Object, Object> cache =
         builder.build(CacheLoader.from(Suppliers.ofInstance(value)));
-    assertSame(value, cache.getUnchecked(key));
-    assertEquals(0, cache.size());
-    assertFalse(cache.asMap().containsKey(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);
+    assertThat(cache.size()).isEqualTo(0);
+    assertThat(cache.asMap().containsKey(key)).isFalse();
   }
 
   public void testCacheBuilderFrom_string() {
@@ -445,22 +447,41 @@ public void testCacheBuilderFrom_string() {
     assertCacheBuilderEquivalence(expected, fromString);
   }
 
-  private static void assertCacheBuilderEquivalence(CacheBuilder<?, ?> a, CacheBuilder<?, ?> b) {
-    assertEquals("concurrencyLevel", a.concurrencyLevel, b.concurrencyLevel);
-    assertEquals("expireAfterAccessNanos", a.expireAfterAccessNanos, b.expireAfterAccessNanos);
-    assertEquals("expireAfterWriteNanos", a.expireAfterWriteNanos, b.expireAfterWriteNanos);
-    assertEquals("initialCapacity", a.initialCapacity, b.initialCapacity);
-    assertEquals("maximumSize", a.maximumSize, b.maximumSize);
-    assertEquals("maximumWeight", a.maximumWeight, b.maximumWeight);
-    assertEquals("refreshNanos", a.refreshNanos, b.refreshNanos);
-    assertEquals("keyEquivalence", a.keyEquivalence, b.keyEquivalence);
-    assertEquals("keyStrength", a.keyStrength, b.keyStrength);
-    assertEquals("removalListener", a.removalListener, b.removalListener);
-    assertEquals("weigher", a.weigher, b.weigher);
-    assertEquals("valueEquivalence", a.valueEquivalence, b.valueEquivalence);
-    assertEquals("valueStrength", a.valueStrength, b.valueStrength);
-    assertEquals("statsCounterSupplier", a.statsCounterSupplier, b.statsCounterSupplier);
-    assertEquals("ticker", a.ticker, b.ticker);
-    assertEquals("recordStats", a.isRecordingStats(), b.isRecordingStats());
+  private static void assertCacheBuilderEquivalence(
+      CacheBuilder<?, ?> expected, CacheBuilder<?, ?> actual) {
+    assertWithMessage("concurrencyLevel")
+        .that(actual.concurrencyLevel)
+        .isEqualTo(expected.concurrencyLevel);
+    assertWithMessage("expireAfterAccessNanos")
+        .that(actual.expireAfterAccessNanos)
+        .isEqualTo(expected.expireAfterAccessNanos);
+    assertWithMessage("expireAfterWriteNanos")
+        .that(actual.expireAfterWriteNanos)
+        .isEqualTo(expected.expireAfterWriteNanos);
+    assertWithMessage("initialCapacity")
+        .that(actual.initialCapacity)
+        .isEqualTo(expected.initialCapacity);
+    assertWithMessage("maximumSize").that(actual.maximumSize).isEqualTo(expected.maximumSize);
+    assertWithMessage("maximumWeight").that(actual.maximumWeight).isEqualTo(expected.maximumWeight);
+    assertWithMessage("refreshNanos").that(actual.refreshNanos).isEqualTo(expected.refreshNanos);
+    assertWithMessage("keyEquivalence")
+        .that(actual.keyEquivalence)
+        .isEqualTo(expected.keyEquivalence);
+    assertWithMessage("keyStrength").that(actual.keyStrength).isEqualTo(expected.keyStrength);
+    assertWithMessage("removalListener")
+        .that(actual.removalListener)
+        .isEqualTo(expected.removalListener);
+    assertWithMessage("weigher").that(actual.weigher).isEqualTo(expected.weigher);
+    assertWithMessage("valueEquivalence")
+        .that(actual.valueEquivalence)
+        .isEqualTo(expected.valueEquivalence);
+    assertWithMessage("valueStrength").that(actual.valueStrength).isEqualTo(expected.valueStrength);
+    assertWithMessage("statsCounterSupplier")
+        .that(actual.statsCounterSupplier)
+        .isEqualTo(expected.statsCounterSupplier);
+    assertWithMessage("ticker").that(actual.ticker).isEqualTo(expected.ticker);
+    assertWithMessage("recordStats")
+        .that(actual.isRecordingStats())
+        .isEqualTo(expected.isRecordingStats());
   }
 }
diff --git a/android/guava-tests/test/com/google/common/cache/CacheBuilderTest.java b/android/guava-tests/test/com/google/common/cache/CacheBuilderTest.java
index d7ec57c94565..cbc2e6b4ed11 100644
--- a/android/guava-tests/test/com/google/common/cache/CacheBuilderTest.java
+++ b/android/guava-tests/test/com/google/common/cache/CacheBuilderTest.java
@@ -24,6 +24,7 @@
 import static com.google.common.cache.TestingRemovalListeners.queuingRemovalListener;
 import static com.google.common.cache.TestingWeighers.constantWeigher;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.util.concurrent.Executors.newFixedThreadPool;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
@@ -63,8 +64,8 @@ public void testNewBuilder() {
     LoadingCache<String, Integer> cache =
         CacheBuilder.newBuilder().removalListener(countingRemovalListener()).build(loader);
 
-    assertEquals(Integer.valueOf(1), cache.getUnchecked("one"));
-    assertEquals(1, cache.size());
+    assertThat(cache.getUnchecked("one")).isEqualTo(1);
+    assertThat(cache.size()).isEqualTo(1);
   }
 
   public void testInitialCapacity_negative() {
@@ -83,10 +84,10 @@ public void testInitialCapacity_small() {
     LocalCache<?, ?> map = CacheTesting.toLocalCache(cache);
 
     assertThat(map.segments).hasLength(4);
-    assertEquals(2, map.segments[0].table.length());
-    assertEquals(2, map.segments[1].table.length());
-    assertEquals(2, map.segments[2].table.length());
-    assertEquals(2, map.segments[3].table.length());
+    assertThat(map.segments[0].table.length()).isEqualTo(2);
+    assertThat(map.segments[1].table.length()).isEqualTo(2);
+    assertThat(map.segments[2].table.length()).isEqualTo(2);
+    assertThat(map.segments[3].table.length()).isEqualTo(2);
   }
 
   @GwtIncompatible // CacheTesting
@@ -96,10 +97,10 @@ public void testInitialCapacity_smallest() {
 
     assertThat(map.segments).hasLength(4);
     // 1 is as low as it goes, not 0. it feels dirty to know this/test this.
-    assertEquals(1, map.segments[0].table.length());
-    assertEquals(1, map.segments[1].table.length());
-    assertEquals(1, map.segments[2].table.length());
-    assertEquals(1, map.segments[3].table.length());
+    assertThat(map.segments[0].table.length()).isEqualTo(1);
+    assertThat(map.segments[1].table.length()).isEqualTo(1);
+    assertThat(map.segments[2].table.length()).isEqualTo(1);
+    assertThat(map.segments[3].table.length()).isEqualTo(1);
   }
 
   public void testInitialCapacity_large() {
@@ -328,7 +329,7 @@ public void testRemovalListener_setTwice() {
   }
 
   public void testValuesIsNotASet() {
-    assertFalse(CacheBuilder.newBuilder().build().asMap().values() instanceof Set);
+    assertThat(CacheBuilder.newBuilder().build().asMap().values() instanceof Set).isFalse();
   }
 
   @GwtIncompatible // CacheTesting
@@ -336,11 +337,11 @@ public void testNullCache() {
     CountingRemovalListener<Object, Object> listener = countingRemovalListener();
     LoadingCache<Object, Object> nullCache =
         CacheBuilder.newBuilder().maximumSize(0).removalListener(listener).build(identityLoader());
-    assertEquals(0, nullCache.size());
+    assertThat(nullCache.size()).isEqualTo(0);
     Object key = new Object();
-    assertSame(key, nullCache.getUnchecked(key));
-    assertEquals(1, listener.getCount());
-    assertEquals(0, nullCache.size());
+    assertThat(nullCache.getUnchecked(key)).isSameInstanceAs(key);
+    assertThat(listener.getCount()).isEqualTo(1);
+    assertThat(nullCache.size()).isEqualTo(0);
     CacheTesting.checkEmpty(nullCache.asMap());
   }
 
@@ -397,12 +398,12 @@ public void run() {
     // At this point, the listener should be holding the seed value (a -> a), and the map should
     // contain the computed value (b -> b), since the clear() happened before the computation
     // completed.
-    assertEquals(1, listener.size());
+    assertThat(listener).hasSize(1);
     RemovalNotification<String, String> notification = listener.remove();
-    assertEquals("a", notification.getKey());
-    assertEquals("a", notification.getValue());
-    assertEquals(1, cache.size());
-    assertEquals("b", cache.getUnchecked("b"));
+    assertThat(notification.getKey()).isEqualTo("a");
+    assertThat(notification.getValue()).isEqualTo("a");
+    assertThat(cache.size()).isEqualTo(1);
+    assertThat(cache.getUnchecked("b")).isEqualTo("b");
   }
 
   // "Basher tests", where we throw a bunch of stuff at a LoadingCache and check basic invariants.
@@ -477,22 +478,22 @@ public void run() {
     Map<String, String> removalNotifications = new HashMap<>();
     for (RemovalNotification<String, String> notification : listener) {
       removalNotifications.put(notification.getKey(), notification.getValue());
-      assertEquals(
-          "Unexpected key/value pair passed to removalListener",
-          notification.getKey(),
-          notification.getValue());
+      assertWithMessage("Unexpected key/value pair passed to removalListener")
+          .that(notification.getValue())
+          .isEqualTo(notification.getKey());
     }
 
     // All of the seed values should have been visible, so we should have gotten removal
     // notifications for all of them.
     for (int i = 0; i < nSeededEntries; i++) {
-      assertEquals("b" + i, removalNotifications.get("b" + i));
+      assertThat(removalNotifications.get("b" + i)).isEqualTo("b" + i);
     }
 
     // Each of the values added to the map should either still be there, or have seen a removal
     // notification.
-    assertEquals(expectedKeys, Sets.union(cache.asMap().keySet(), removalNotifications.keySet()));
-    assertTrue(Sets.intersection(cache.asMap().keySet(), removalNotifications.keySet()).isEmpty());
+    assertThat(Sets.union(cache.asMap().keySet(), removalNotifications.keySet()))
+        .isEqualTo(expectedKeys);
+    assertThat(cache.asMap().keySet()).containsNoneIn(removalNotifications.keySet());
     threadPool.shutdown();
     threadPool.awaitTermination(300, SECONDS);
   }
@@ -571,15 +572,17 @@ public void run() {
 
     // Verify that each received removal notification was valid
     for (RemovalNotification<String, String> notification : removalListener) {
-      assertEquals("Invalid removal notification", notification.getKey(), notification.getValue());
+      assertWithMessage("Invalid removal notification")
+          .that(notification.getValue())
+          .isEqualTo(notification.getKey());
     }
 
     CacheStats stats = cache.stats();
-    assertEquals(removalListener.size(), stats.evictionCount());
-    assertEquals(computeCount.get(), stats.loadSuccessCount());
-    assertEquals(exceptionCount.get() + computeNullCount.get(), stats.loadExceptionCount());
+    assertThat(stats.evictionCount()).isEqualTo(removalListener.size());
+    assertThat(stats.loadSuccessCount()).isEqualTo(computeCount.get());
+    assertThat(stats.loadExceptionCount()).isEqualTo(exceptionCount.get() + computeNullCount.get());
     // each computed value is still in the cache, or was passed to the removal listener
-    assertEquals(computeCount.get(), cache.size() + removalListener.size());
+    assertThat(cache.size() + removalListener.size()).isEqualTo(computeCount.get());
   }
 
   @GwtIncompatible // NullPointerTester
@@ -594,7 +597,7 @@ public void testSizingDefaults() {
     LoadingCache<?, ?> cache = CacheBuilder.newBuilder().build(identityLoader());
     LocalCache<?, ?> map = CacheTesting.toLocalCache(cache);
     assertThat(map.segments).hasLength(4); // concurrency level
-    assertEquals(4, map.segments[0].table.length()); // capacity / conc level
+    assertThat(map.segments[0].table.length()).isEqualTo(4); // capacity / conc level
   }
 
   @GwtIncompatible // CountDownLatch
diff --git a/android/guava-tests/test/com/google/common/cache/CacheEvictionTest.java b/android/guava-tests/test/com/google/common/cache/CacheEvictionTest.java
index a6d97f881001..8f83959eb8f6 100644
--- a/android/guava-tests/test/com/google/common/cache/CacheEvictionTest.java
+++ b/android/guava-tests/test/com/google/common/cache/CacheEvictionTest.java
@@ -45,7 +45,7 @@ public void testEviction_setMaxSegmentSize() {
     IdentityLoader<Object> loader = identityLoader();
     for (int i = 1; i < 1000; i++) {
       LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().maximumSize(i).build(loader);
-      assertEquals(i, CacheTesting.getTotalSegmentSize(cache));
+      assertThat(CacheTesting.getTotalSegmentSize(cache)).isEqualTo(i);
     }
   }
 
@@ -54,7 +54,7 @@ public void testEviction_setMaxSegmentWeight() {
     for (int i = 1; i < 1000; i++) {
       LoadingCache<Object, Object> cache =
           CacheBuilder.newBuilder().maximumWeight(i).weigher(constantWeigher(1)).build(loader);
-      assertEquals(i, CacheTesting.getTotalSegmentSize(cache));
+      assertThat(CacheTesting.getTotalSegmentSize(cache)).isEqualTo(i);
     }
   }
 
@@ -64,10 +64,10 @@ public void testEviction_maxSizeOneSegment() {
         CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(MAX_SIZE).build(loader);
     for (int i = 0; i < 2 * MAX_SIZE; i++) {
       cache.getUnchecked(i);
-      assertEquals(min(i + 1, MAX_SIZE), cache.size());
+      assertThat(cache.size()).isEqualTo(min(i + 1, MAX_SIZE));
     }
 
-    assertEquals(MAX_SIZE, cache.size());
+    assertThat(cache.size()).isEqualTo(MAX_SIZE);
     CacheTesting.checkValidState(cache);
   }
 
@@ -81,10 +81,10 @@ public void testEviction_maxWeightOneSegment() {
             .build(loader);
     for (int i = 0; i < 2 * MAX_SIZE; i++) {
       cache.getUnchecked(i);
-      assertEquals(min(i + 1, MAX_SIZE), cache.size());
+      assertThat(cache.size()).isEqualTo(min(i + 1, MAX_SIZE));
     }
 
-    assertEquals(MAX_SIZE, cache.size());
+    assertThat(cache.size()).isEqualTo(MAX_SIZE);
     CacheTesting.checkValidState(cache);
   }
 
@@ -98,13 +98,13 @@ public void testEviction_maxSize() {
             .build(loader);
     for (int i = 0; i < 2 * MAX_SIZE; i++) {
       cache.getUnchecked(i);
-      assertTrue(cache.size() <= MAX_SIZE);
+      assertThat(cache.size() <= MAX_SIZE).isTrue();
     }
 
-    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));
-    assertEquals(MAX_SIZE, cache.size());
+    assertThat(CacheTesting.accessQueueSize(cache)).isEqualTo(MAX_SIZE);
+    assertThat(cache.size()).isEqualTo(MAX_SIZE);
     CacheTesting.processPendingNotifications(cache);
-    assertEquals(MAX_SIZE, removalListener.getCount());
+    assertThat(removalListener.getCount()).isEqualTo(MAX_SIZE);
     CacheTesting.checkValidState(cache);
   }
 
@@ -119,13 +119,13 @@ public void testEviction_maxWeight() {
             .build(loader);
     for (int i = 0; i < 2 * MAX_SIZE; i++) {
       cache.getUnchecked(i);
-      assertTrue(cache.size() <= MAX_SIZE);
+      assertThat(cache.size()).isAtMost(MAX_SIZE);
     }
 
-    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));
-    assertEquals(MAX_SIZE, cache.size());
+    assertThat(CacheTesting.accessQueueSize(cache)).isEqualTo(MAX_SIZE);
+    assertThat(cache.size()).isEqualTo(MAX_SIZE);
     CacheTesting.processPendingNotifications(cache);
-    assertEquals(MAX_SIZE, removalListener.getCount());
+    assertThat(removalListener.getCount()).isEqualTo(MAX_SIZE);
     CacheTesting.checkValidState(cache);
   }
 
@@ -255,7 +255,7 @@ public void testEviction_overflow() {
     cache.getUnchecked(objectWithHash(0));
     cache.getUnchecked(objectWithHash(0));
     CacheTesting.processPendingNotifications(cache);
-    assertEquals(1, removalListener.getCount());
+    assertThat(removalListener.getCount()).isEqualTo(1);
   }
 
   public void testUpdateRecency_onGet() {
diff --git a/android/guava-tests/test/com/google/common/cache/CacheExpirationTest.java b/android/guava-tests/test/com/google/common/cache/CacheExpirationTest.java
index 8122c68514e8..75095b28e0b6 100644
--- a/android/guava-tests/test/com/google/common/cache/CacheExpirationTest.java
+++ b/android/guava-tests/test/com/google/common/cache/CacheExpirationTest.java
@@ -17,6 +17,7 @@
 import static com.google.common.cache.TestingCacheLoaders.identityLoader;
 import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.util.Arrays.asList;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.MINUTES;
@@ -81,23 +82,29 @@ private void checkExpiration(
       CountingRemovalListener<String, Integer> removalListener) {
 
     for (int i = 0; i < 10; i++) {
-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));
+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);
     }
 
     for (int i = 0; i < 10; i++) {
       loader.reset();
-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));
-      assertFalse("Creator should not have been called @#" + i, loader.wasCalled());
+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);
+      assertWithMessage("Creator should not have been called @#%s", i)
+          .that(loader.wasCalled())
+          .isFalse();
     }
 
     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);
 
-    assertEquals("Map must be empty by now", 0, cache.size());
-    assertEquals("Eviction notifications must be received", 10, removalListener.getCount());
+    assertWithMessage("Map must be empty by now").that(cache.size()).isEqualTo(0);
+    assertWithMessage("Eviction notifications must be received")
+        .that(removalListener.getCount())
+        .isEqualTo(10);
 
     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);
     // ensure that no new notifications are sent
-    assertEquals("Eviction notifications must be received", 10, removalListener.getCount());
+    assertWithMessage("Eviction notifications must be received")
+        .that(removalListener.getCount())
+        .isEqualTo(10);
   }
 
   public void testExpiringGet_expireAfterWrite() {
@@ -133,13 +140,15 @@ private void runExpirationTest(
       CountingRemovalListener<String, Integer> removalListener) {
 
     for (int i = 0; i < 10; i++) {
-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));
+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);
     }
 
     for (int i = 0; i < 10; i++) {
       loader.reset();
-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));
-      assertFalse("Loader should NOT have been called @#" + i, loader.wasCalled());
+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);
+      assertWithMessage("Loader should NOT have been called @#%s", i)
+          .that(loader.wasCalled())
+          .isFalse();
     }
 
     // wait for entries to expire, but don't call expireEntries
@@ -149,31 +158,35 @@ private void runExpirationTest(
     cache.getUnchecked(KEY_PREFIX + 11);
 
     // collections views shouldn't expose expired entries
-    assertEquals(1, Iterators.size(cache.asMap().entrySet().iterator()));
-    assertEquals(1, Iterators.size(cache.asMap().keySet().iterator()));
-    assertEquals(1, Iterators.size(cache.asMap().values().iterator()));
+    assertThat(Iterators.size(cache.asMap().entrySet().iterator())).isEqualTo(1);
+    assertThat(Iterators.size(cache.asMap().keySet().iterator())).isEqualTo(1);
+    assertThat(Iterators.size(cache.asMap().values().iterator())).isEqualTo(1);
 
     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);
 
     for (int i = 0; i < 11; i++) {
-      assertFalse(cache.asMap().containsKey(KEY_PREFIX + i));
+      assertThat(cache.asMap().containsKey(KEY_PREFIX + i)).isFalse();
     }
-    assertEquals(11, removalListener.getCount());
+    assertThat(removalListener.getCount()).isEqualTo(11);
 
     for (int i = 0; i < 10; i++) {
-      assertFalse(cache.asMap().containsKey(KEY_PREFIX + i));
+      assertThat(cache.asMap().containsKey(KEY_PREFIX + i)).isFalse();
       loader.reset();
-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));
-      assertTrue("Creator should have been called @#" + i, loader.wasCalled());
+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);
+      assertWithMessage("Loader should have been called @#%s", i).that(loader.wasCalled()).isTrue();
     }
 
     // expire new values we just created
     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);
-    assertEquals("Eviction notifications must be received", 21, removalListener.getCount());
+    assertWithMessage("Eviction notifications must be received")
+        .that(removalListener.getCount())
+        .isEqualTo(21);
 
     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);
     // ensure that no new notifications are sent
-    assertEquals("Eviction notifications must be received", 21, removalListener.getCount());
+    assertWithMessage("Eviction notifications must be received")
+        .that(removalListener.getCount())
+        .isEqualTo(21);
   }
 
   public void testRemovalListener_expireAfterWrite() {
@@ -215,9 +228,9 @@ public AtomicInteger load(Integer key) {
       ticker.advance(1, MILLISECONDS);
     }
 
-    assertEquals(evictionCount.get() + 1, applyCount.get());
+    assertThat(applyCount.get()).isEqualTo(evictionCount.get() + 1);
     int remaining = cache.getUnchecked(10).get();
-    assertEquals(100, totalSum.get() + remaining);
+    assertThat(totalSum.get() + remaining).isEqualTo(100);
   }
 
   public void testRemovalScheduler_expireAfterWrite() {
@@ -435,46 +448,50 @@ private void runRemovalScheduler(
       FakeTicker ticker,
       String keyPrefix,
       long ttl) {
+    loader.setKeyPrefix(keyPrefix);
 
     int shift1 = 10 + VALUE_PREFIX;
     loader.setValuePrefix(shift1);
     // fill with initial data
     for (int i = 0; i < 10; i++) {
-      assertEquals(Integer.valueOf(i + shift1), cache.getUnchecked(keyPrefix + i));
+      assertThat(cache.getUnchecked(keyPrefix + i)).isEqualTo(i + shift1);
     }
-    assertEquals(10, CacheTesting.expirationQueueSize(cache));
-    assertEquals(0, removalListener.getCount());
+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);
+    assertThat(removalListener.getCount()).isEqualTo(0);
 
     // wait, so that entries have just 10 ms to live
     ticker.advance(ttl * 2 / 3, MILLISECONDS);
 
-    assertEquals(10, CacheTesting.expirationQueueSize(cache));
-    assertEquals(0, removalListener.getCount());
+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);
+    assertThat(removalListener.getCount()).isEqualTo(0);
 
     int shift2 = shift1 + 10;
     loader.setValuePrefix(shift2);
     // fill with new data - has to live for 20 ms more
     for (int i = 0; i < 10; i++) {
       cache.invalidate(keyPrefix + i);
-      assertEquals(
-          "key: " + keyPrefix + i, Integer.valueOf(i + shift2), cache.getUnchecked(keyPrefix + i));
+      assertWithMessage("key: %s%s", keyPrefix, i)
+          .that(cache.getUnchecked(keyPrefix + i))
+          .isEqualTo(i + shift2);
     }
-    assertEquals(10, CacheTesting.expirationQueueSize(cache));
-    assertEquals(10, removalListener.getCount()); // these are the invalidated ones
+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);
+    assertThat(removalListener.getCount()).isEqualTo(10); // these are the invalidated ones
 
     // old timeouts must expire after this wait
     ticker.advance(ttl * 2 / 3, MILLISECONDS);
 
-    assertEquals(10, CacheTesting.expirationQueueSize(cache));
-    assertEquals(10, removalListener.getCount());
+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);
+    assertThat(removalListener.getCount()).isEqualTo(10);
 
     // check that new values are still there - they still have 10 ms to live
     for (int i = 0; i < 10; i++) {
       loader.reset();
-      assertEquals(Integer.valueOf(i + shift2), cache.getUnchecked(keyPrefix + i));
-      assertFalse("Creator should NOT have been called @#" + i, loader.wasCalled());
+      assertThat(cache.getUnchecked(keyPrefix + i)).isEqualTo(i + shift2);
+      assertWithMessage("Creator should NOT have been called @#%s", i)
+          .that(loader.wasCalled())
+          .isFalse();
     }
-    assertEquals(10, removalListener.getCount());
+    assertThat(removalListener.getCount()).isEqualTo(10);
   }
 
   private static void getAll(LoadingCache<Integer, Integer> cache, List<Integer> keys) {
diff --git a/android/guava-tests/test/com/google/common/cache/CacheLoaderTest.java b/android/guava-tests/test/com/google/common/cache/CacheLoaderTest.java
index 70918db35fe7..8125ff117a6a 100644
--- a/android/guava-tests/test/com/google/common/cache/CacheLoaderTest.java
+++ b/android/guava-tests/test/com/google/common/cache/CacheLoaderTest.java
@@ -16,6 +16,7 @@
 
 package com.google.common.cache;
 
+import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.util.concurrent.Futures.immediateFuture;
 
 import com.google.common.collect.ImmutableList;
@@ -77,17 +78,17 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {
           }
         };
 
-    assertEquals(0, loadCount.get());
-    assertEquals(0, reloadCount.get());
-    assertEquals(0, loadAllCount.get());
+    assertThat(loadCount.get()).isEqualTo(0);
+    assertThat(reloadCount.get()).isEqualTo(0);
+    assertThat(loadAllCount.get()).isEqualTo(0);
 
     Object unused1 = baseLoader.load(new Object());
     @SuppressWarnings("unused") // https://errorprone.info/bugpattern/FutureReturnValueIgnored
     Future<?> possiblyIgnoredError = baseLoader.reload(new Object(), new Object());
     Map<Object, Object> unused2 = baseLoader.loadAll(ImmutableList.of(new Object()));
-    assertEquals(1, loadCount.get());
-    assertEquals(1, reloadCount.get());
-    assertEquals(1, loadAllCount.get());
+    assertThat(loadCount.get()).isEqualTo(1);
+    assertThat(reloadCount.get()).isEqualTo(1);
+    assertThat(loadAllCount.get()).isEqualTo(1);
 
     QueuingExecutor executor = new QueuingExecutor();
     CacheLoader<Object, Object> asyncReloader = CacheLoader.asyncReloading(baseLoader, executor);
@@ -96,13 +97,13 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {
     @SuppressWarnings("unused") // https://errorprone.info/bugpattern/FutureReturnValueIgnored
     Future<?> possiblyIgnoredError1 = asyncReloader.reload(new Object(), new Object());
     Map<Object, Object> unused4 = asyncReloader.loadAll(ImmutableList.of(new Object()));
-    assertEquals(2, loadCount.get());
-    assertEquals(1, reloadCount.get());
-    assertEquals(2, loadAllCount.get());
+    assertThat(loadCount.get()).isEqualTo(2);
+    assertThat(reloadCount.get()).isEqualTo(1);
+    assertThat(loadAllCount.get()).isEqualTo(2);
 
     executor.runNext();
-    assertEquals(2, loadCount.get());
-    assertEquals(2, reloadCount.get());
-    assertEquals(2, loadAllCount.get());
+    assertThat(loadCount.get()).isEqualTo(2);
+    assertThat(reloadCount.get()).isEqualTo(2);
+    assertThat(loadAllCount.get()).isEqualTo(2);
   }
 }
diff --git a/android/guava-tests/test/com/google/common/cache/CacheLoadingTest.java b/android/guava-tests/test/com/google/common/cache/CacheLoadingTest.java
index a2e3883d95b9..7dc674ae919c 100644
--- a/android/guava-tests/test/com/google/common/cache/CacheLoadingTest.java
+++ b/android/guava-tests/test/com/google/common/cache/CacheLoadingTest.java
@@ -21,6 +21,7 @@
 import static com.google.common.cache.TestingCacheLoaders.identityLoader;
 import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static com.google.common.util.concurrent.Futures.immediateFailedFuture;
 import static com.google.common.util.concurrent.Futures.immediateFuture;
 import static java.util.Arrays.asList;
@@ -33,7 +34,6 @@
 import com.google.common.cache.TestingCacheLoaders.IdentityLoader;
 import com.google.common.cache.TestingRemovalListeners.CountingRemovalListener;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
 import com.google.common.testing.FakeTicker;
 import com.google.common.testing.TestLogHandler;
@@ -83,7 +83,7 @@ public void tearDown() throws Exception {
 
   private Throwable popLoggedThrowable() {
     List<LogRecord> logRecords = logHandler.getStoredLogRecords();
-    assertEquals(1, logRecords.size());
+    assertThat(logRecords).hasSize(1);
     LogRecord logRecord = logRecords.get(0);
     logHandler.clear();
     return logRecord.getThrown();
@@ -105,59 +105,59 @@ public void testLoad() throws ExecutionException {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(identityLoader());
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Object key = new Object();
-    assertSame(key, cache.get(key));
+    assertThat(cache.get(key)).isSameInstanceAs(key);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     key = new Object();
-    assertSame(key, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(key);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     key = new Object();
     cache.refresh(key);
     checkNothingLogged();
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(3, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(3);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(key, cache.get(key));
+    assertThat(cache.get(key)).isSameInstanceAs(key);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(3, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(3);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     Object value = new Object();
     // callable is not called
-    assertSame(key, cache.get(key, throwing(new Exception())));
+    assertThat(cache.get(key, throwing(new Exception()))).isSameInstanceAs(key);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(3, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(3);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     key = new Object();
-    assertSame(value, cache.get(key, Callables.returning(value)));
+    assertThat(cache.get(key, Callables.returning(value))).isSameInstanceAs(value);
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(4, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(4);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(2);
   }
 
   public void testReload() throws ExecutionException {
@@ -179,32 +179,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkNothingLogged();
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(two, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testRefresh() {
@@ -232,41 +232,41 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
             .build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(two, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(two, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(3);
   }
 
   public void testRefresh_getIfPresent() {
@@ -294,41 +294,41 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
             .build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getIfPresent(key));
+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(two, cache.getIfPresent(key));
+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(two, cache.getIfPresent(key));
+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(3);
   }
 
   public void testBulkLoad_default() throws ExecutionException {
@@ -337,45 +337,45 @@ public void testBulkLoad_default() throws ExecutionException {
             .recordStats()
             .build(TestingCacheLoaders.<Integer>identityLoader());
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.<Integer>of()));
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(cache.getAll(ImmutableList.of())).isEmpty();
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));
+    assertThat(cache.getAll(asList(1))).containsExactly(1, 1);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));
+    assertThat(cache.getAll(asList(1, 2, 3, 4))).containsExactly(1, 1, 2, 2, 3, 3, 4, 4);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(4, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(4);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
-    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));
+    assertThat(cache.getAll(asList(2, 3))).containsExactly(2, 2, 3, 3);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(4, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(4);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(3);
 
     // duplicate keys are ignored, and don't impact stats
-    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));
+    assertThat(cache.getAll(asList(4, 5))).containsExactly(4, 4, 5, 5);
     stats = cache.stats();
-    assertEquals(5, stats.missCount());
-    assertEquals(5, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(4, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(5);
+    assertThat(stats.loadSuccessCount()).isEqualTo(5);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(4);
   }
 
   public void testBulkLoad_loadAll() throws ExecutionException {
@@ -383,45 +383,45 @@ public void testBulkLoad_loadAll() throws ExecutionException {
     CacheLoader<Integer, Integer> loader = bulkLoader(backingLoader);
     LoadingCache<Integer, Integer> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.<Integer>of()));
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(cache.getAll(ImmutableList.<Integer>of())).containsExactly();
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));
+    assertThat(cache.getAll(asList(1))).containsExactly(1, 1);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));
+    assertThat(cache.getAll(asList(1, 2, 3, 4))).containsExactly(1, 1, 2, 2, 3, 3, 4, 4);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
-    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));
+    assertThat(cache.getAll(asList(2, 3))).containsExactly(2, 2, 3, 3);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(3);
 
     // duplicate keys are ignored, and don't impact stats
-    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));
+    assertThat(cache.getAll(asList(4, 5))).containsExactly(4, 4, 5, 5);
     stats = cache.stats();
-    assertEquals(5, stats.missCount());
-    assertEquals(3, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(4, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(5);
+    assertThat(stats.loadSuccessCount()).isEqualTo(3);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(4);
   }
 
   public void testBulkLoad_extra() throws ExecutionException {
@@ -452,10 +452,10 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
     for (Entry<Object, Object> entry : result.entrySet()) {
       Object key = entry.getKey();
       Object value = entry.getValue();
-      assertSame(value, result.get(key));
-      assertNull(result.get(value));
-      assertSame(value, cache.asMap().get(key));
-      assertSame(key, cache.asMap().get(value));
+      assertThat(result.get(key)).isSameInstanceAs(value);
+      assertThat(result.get(value)).isNull();
+      assertThat(cache.asMap().get(key)).isSameInstanceAs(value);
+      assertThat(cache.asMap().get(value)).isSameInstanceAs(key);
     }
   }
 
@@ -482,7 +482,7 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
         };
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);
     cache.asMap().put(extraKey, extraKey);
-    assertSame(extraKey, cache.asMap().get(extraKey));
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);
 
     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
     Map<Object, Object> result = cache.getAll(asList(lookupKeys));
@@ -490,11 +490,11 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
     for (Entry<Object, Object> entry : result.entrySet()) {
       Object key = entry.getKey();
       Object value = entry.getValue();
-      assertSame(value, result.get(key));
-      assertSame(value, cache.asMap().get(key));
+      assertThat(result.get(key)).isSameInstanceAs(value);
+      assertThat(cache.asMap().get(key)).isSameInstanceAs(value);
     }
-    assertNull(result.get(extraKey));
-    assertSame(extraValue, cache.asMap().get(extraKey));
+    assertThat(result.get(extraKey)).isNull();
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);
   }
 
   public void testBulkLoad_clobberNullValue() throws ExecutionException {
@@ -521,16 +521,16 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
         };
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);
     cache.asMap().put(extraKey, extraKey);
-    assertSame(extraKey, cache.asMap().get(extraKey));
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);
 
     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));
 
     for (Object key : lookupKeys) {
-      assertTrue(cache.asMap().containsKey(key));
+      assertThat(cache.asMap().containsKey(key)).isTrue();
     }
-    assertSame(extraValue, cache.asMap().get(extraKey));
-    assertFalse(cache.asMap().containsKey(extraValue));
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);
+    assertThat(cache.asMap().containsKey(extraValue)).isFalse();
   }
 
   public void testBulkLoad_clobberNullKey() throws ExecutionException {
@@ -557,16 +557,16 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
         };
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);
     cache.asMap().put(extraKey, extraKey);
-    assertSame(extraKey, cache.asMap().get(extraKey));
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);
 
     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));
 
     for (Object key : lookupKeys) {
-      assertTrue(cache.asMap().containsKey(key));
+      assertThat(cache.asMap().containsKey(key)).isTrue();
     }
-    assertSame(extraValue, cache.asMap().get(extraKey));
-    assertFalse(cache.asMap().containsValue(extraKey));
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);
+    assertThat(cache.asMap().containsValue(extraKey)).isFalse();
   }
 
   public void testBulkLoad_partial() throws ExecutionException {
@@ -591,54 +591,54 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
 
     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));
-    assertSame(extraValue, cache.asMap().get(extraKey));
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);
   }
 
   public void testLoadNull() throws ExecutionException {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(constantLoader(null));
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     assertThrows(InvalidCacheLoadException.class, () -> cache.get(new Object()));
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(new Object()));
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(new Object());
     checkLoggedInvalidLoad();
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(3, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(3);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     assertThrows(
         InvalidCacheLoadException.class, () -> cache.get(new Object(), Callables.returning(null)));
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(4, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(4);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(5, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(5);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testReloadNull() throws ExecutionException {
@@ -659,32 +659,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedInvalidLoad();
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testReloadNullFuture() throws ExecutionException {
@@ -705,32 +705,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedInvalidLoad();
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testRefreshNull() {
@@ -757,59 +757,59 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
             .build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     // refreshed
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(3);
   }
 
   public void testBulkLoadNull() throws ExecutionException {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(bulkLoader(constantLoader(null)));
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testBulkLoadNullMap() throws ExecutionException {
@@ -830,17 +830,17 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {
                 });
 
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testLoadError() throws ExecutionException {
@@ -848,34 +848,34 @@ public void testLoadError() throws ExecutionException {
     CacheLoader<Object, Object> loader = errorLoader(e);
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ExecutionError expected = assertThrows(ExecutionError.class, () -> cache.get(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected = assertThrows(ExecutionError.class, () -> cache.getUnchecked(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(new Object());
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(3, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(3);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Error callableError = new Error();
     expected =
@@ -892,18 +892,18 @@ public Object call() {
                     }));
     assertThat(expected).hasCauseThat().isSameInstanceAs(callableError);
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(4, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(4);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected = assertThrows(ExecutionError.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(5, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(5);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testReloadError() throws ExecutionException {
@@ -925,32 +925,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testReloadFutureError() throws ExecutionException {
@@ -972,32 +972,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testRefreshError() {
@@ -1025,42 +1025,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
             .build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     // refreshed
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(3);
   }
 
   public void testBulkLoadError() throws ExecutionException {
@@ -1069,19 +1069,19 @@ public void testBulkLoadError() throws ExecutionException {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ExecutionError expected =
         assertThrows(ExecutionError.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testLoadCheckedException() {
@@ -1089,35 +1089,35 @@ public void testLoadCheckedException() {
     CacheLoader<Object, Object> loader = exceptionLoader(e);
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Exception expected = assertThrows(ExecutionException.class, () -> cache.get(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected =
         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(new Object());
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(3, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(3);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Exception callableException = new Exception();
     expected =
@@ -1125,18 +1125,18 @@ public void testLoadCheckedException() {
             ExecutionException.class, () -> cache.get(new Object(), throwing(callableException)));
     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(4, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(4);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected = assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(5, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(5);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testLoadInterruptedException() {
@@ -1144,62 +1144,62 @@ public void testLoadInterruptedException() {
     CacheLoader<Object, Object> loader = exceptionLoader(e);
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     // Sanity check:
-    assertFalse(Thread.interrupted());
+    assertThat(Thread.interrupted()).isFalse();
 
     Exception expected = assertThrows(ExecutionException.class, () -> cache.get(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
-    assertTrue(Thread.interrupted());
+    assertThat(Thread.interrupted()).isTrue();
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected =
         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
-    assertTrue(Thread.interrupted());
+    assertThat(Thread.interrupted()).isTrue();
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(new Object());
-    assertTrue(Thread.interrupted());
+    assertThat(Thread.interrupted()).isTrue();
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(3, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(3);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Exception callableException = new InterruptedException();
     expected =
         assertThrows(
             ExecutionException.class, () -> cache.get(new Object(), throwing(callableException)));
     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
-    assertTrue(Thread.interrupted());
+    assertThat(Thread.interrupted()).isTrue();
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(4, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(4);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected = assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
-    assertTrue(Thread.interrupted());
+    assertThat(Thread.interrupted()).isTrue();
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(5, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(5);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testReloadCheckedException() {
@@ -1221,32 +1221,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) throws Excep
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testReloadFutureCheckedException() {
@@ -1268,32 +1268,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testRefreshCheckedException() {
@@ -1321,42 +1321,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
             .build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     // refreshed
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(3);
   }
 
   public void testBulkLoadCheckedException() {
@@ -1365,19 +1365,19 @@ public void testBulkLoadCheckedException() {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ExecutionException expected =
         assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testBulkLoadInterruptedException() {
@@ -1386,20 +1386,20 @@ public void testBulkLoadInterruptedException() {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ExecutionException expected =
         assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
-    assertTrue(Thread.interrupted());
+    assertThat(Thread.interrupted()).isTrue();
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testLoadUncheckedException() throws ExecutionException {
@@ -1407,36 +1407,36 @@ public void testLoadUncheckedException() throws ExecutionException {
     CacheLoader<Object, Object> loader = exceptionLoader(e);
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     UncheckedExecutionException expected =
         assertThrows(UncheckedExecutionException.class, () -> cache.get(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected =
         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(new Object());
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(3, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(3);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Exception callableException = new RuntimeException();
     expected =
@@ -1445,19 +1445,19 @@ public void testLoadUncheckedException() throws ExecutionException {
             () -> cache.get(new Object(), throwing(callableException)));
     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(4, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(4);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected =
         assertThrows(UncheckedExecutionException.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(5, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(5);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testReloadUncheckedException() throws ExecutionException {
@@ -1479,32 +1479,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) throws Excep
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testReloadFutureUncheckedException() throws ExecutionException {
@@ -1526,32 +1526,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testRefreshUncheckedException() {
@@ -1579,42 +1579,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
             .build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     // refreshed
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(3);
   }
 
   public void testBulkLoadUncheckedException() throws ExecutionException {
@@ -1623,19 +1623,19 @@ public void testBulkLoadUncheckedException() throws ExecutionException {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     UncheckedExecutionException expected =
         assertThrows(UncheckedExecutionException.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testReloadAfterFailure() throws ExecutionException {
@@ -1660,15 +1660,15 @@ public String load(Integer key) throws Exception {
         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(1));
     assertThat(ue).hasCauseThat().isSameInstanceAs(e);
 
-    assertEquals("1", cache.getUnchecked(1));
-    assertEquals(0, removalListener.getCount());
+    assertThat(cache.getUnchecked(1)).isEqualTo("1");
+    assertThat(removalListener.getCount()).isEqualTo(0);
 
     count.set(0);
     cache.refresh(2);
     checkLoggedCause(e);
 
-    assertEquals("2", cache.getUnchecked(2));
-    assertEquals(0, removalListener.getCount());
+    assertThat(cache.getUnchecked(2)).isEqualTo("2");
+    assertThat(removalListener.getCount()).isEqualTo(0);
   }
 
 
@@ -1693,7 +1693,7 @@ public void testReloadAfterValueReclamation() throws InterruptedException, Execu
       Thread.sleep(i);
       System.gc();
     }
-    assertEquals(expectedComputations, countingLoader.getCount());
+    assertThat(countingLoader.getCount()).isEqualTo(expectedComputations);
 
     for (int i = 0; i < iterations; i++) {
       // The entry should get garbage collected and recomputed.
@@ -1708,7 +1708,7 @@ public void testReloadAfterValueReclamation() throws InterruptedException, Execu
       Thread.sleep(i);
       System.gc();
     }
-    assertEquals(expectedComputations, countingLoader.getCount());
+    assertThat(countingLoader.getCount()).isEqualTo(expectedComputations);
   }
 
   public void testReloadAfterSimulatedValueReclamation() throws ExecutionException {
@@ -1717,20 +1717,20 @@ public void testReloadAfterSimulatedValueReclamation() throws ExecutionException
         CacheBuilder.newBuilder().concurrencyLevel(1).weakValues().build(countingLoader);
 
     Object key = new Object();
-    assertNotNull(cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isNotNull();
 
     CacheTesting.simulateValueReclamation(cache, key);
 
     // this blocks if computation can't deal with partially-collected values
-    assertNotNull(cache.getUnchecked(key));
-    assertEquals(1, cache.size());
-    assertEquals(2, countingLoader.getCount());
+    assertThat(cache.getUnchecked(key)).isNotNull();
+    assertThat(cache.size()).isEqualTo(1);
+    assertThat(countingLoader.getCount()).isEqualTo(2);
 
     CacheTesting.simulateValueReclamation(cache, key);
     cache.refresh(key);
     checkNothingLogged();
-    assertEquals(1, cache.size());
-    assertEquals(3, countingLoader.getCount());
+    assertThat(cache.size()).isEqualTo(1);
+    assertThat(countingLoader.getCount()).isEqualTo(3);
   }
 
   public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {
@@ -1739,19 +1739,19 @@ public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {
         CacheBuilder.newBuilder().concurrencyLevel(1).weakKeys().build(countingLoader);
 
     Object key = new Object();
-    assertNotNull(cache.getUnchecked(key));
-    assertEquals(1, cache.size());
+    assertThat(cache.getUnchecked(key)).isNotNull();
+    assertThat(cache.size()).isEqualTo(1);
 
     CacheTesting.simulateKeyReclamation(cache, key);
 
     // this blocks if computation can't deal with partially-collected values
-    assertNotNull(cache.getUnchecked(key));
-    assertEquals(2, countingLoader.getCount());
+    assertThat(cache.getUnchecked(key)).isNotNull();
+    assertThat(countingLoader.getCount()).isEqualTo(2);
 
     CacheTesting.simulateKeyReclamation(cache, key);
     cache.refresh(key);
     checkNothingLogged();
-    assertEquals(3, countingLoader.getCount());
+    assertThat(countingLoader.getCount()).isEqualTo(3);
   }
 
   /**
@@ -1864,9 +1864,11 @@ public Object load(String key) throws InterruptedException {
 
     List<Object> resultArray = doConcurrentGet(cache, "bar", count, startSignal);
 
-    assertEquals(1, callCount.get());
+    assertThat(callCount.get()).isEqualTo(1);
     for (int i = 0; i < count; i++) {
-      assertSame("result(" + i + ") didn't match expected", result, resultArray.get(i));
+      assertWithMessage("result(%s) didn't match expected", i)
+          .that(resultArray.get(i))
+          .isSameInstanceAs(result);
     }
   }
 
@@ -1896,18 +1898,14 @@ public String load(String key) throws InterruptedException {
 
     List<Object> result = doConcurrentGet(cache, "bar", count, startSignal);
 
-    assertEquals(1, callCount.get());
+    assertThat(callCount.get()).isEqualTo(1);
     for (int i = 0; i < count; i++) {
       assertThat(result.get(i)).isInstanceOf(InvalidCacheLoadException.class);
     }
 
     // subsequent calls should call the loader again, not get the old exception
-    try {
-      cache.getUnchecked("bar");
-      fail();
-    } catch (InvalidCacheLoadException expected) {
-    }
-    assertEquals(2, callCount.get());
+    assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked("bar"));
+    assertThat(callCount.get()).isEqualTo(2);
   }
 
   /**
@@ -1936,7 +1934,7 @@ public String load(String key) throws InterruptedException {
 
     List<Object> result = doConcurrentGet(cache, "bar", count, startSignal);
 
-    assertEquals(1, callCount.get());
+    assertThat(callCount.get()).isEqualTo(1);
     for (int i = 0; i < count; i++) {
       // doConcurrentGet alternates between calling getUnchecked and calling get, but an unchecked
       // exception thrown by the loader is always wrapped as an UncheckedExecutionException.
@@ -1945,12 +1943,8 @@ public String load(String key) throws InterruptedException {
     }
 
     // subsequent calls should call the loader again, not get the old exception
-    try {
-      cache.getUnchecked("bar");
-      fail();
-    } catch (UncheckedExecutionException expected) {
-    }
-    assertEquals(2, callCount.get());
+    assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked("bar"));
+    assertThat(callCount.get()).isEqualTo(2);
   }
 
   /**
@@ -1979,7 +1973,7 @@ public String load(String key) throws IOException, InterruptedException {
 
     List<Object> result = doConcurrentGet(cache, "bar", count, startSignal);
 
-    assertEquals(1, callCount.get());
+    assertThat(callCount.get()).isEqualTo(1);
     for (int i = 0; i < count; i++) {
       // doConcurrentGet alternates between calling getUnchecked and calling get. If we call get(),
       // we should get an ExecutionException; if we call getUnchecked(), we should get an
@@ -1995,12 +1989,8 @@ public String load(String key) throws IOException, InterruptedException {
     }
 
     // subsequent calls should call the loader again, not get the old exception
-    try {
-      cache.getUnchecked("bar");
-      fail();
-    } catch (UncheckedExecutionException expected) {
-    }
-    assertEquals(2, callCount.get());
+    assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked("bar"));
+    assertThat(callCount.get()).isEqualTo(2);
   }
 
   /**
@@ -2084,9 +2074,9 @@ public String load(String key) throws InterruptedException {
     LoadingCache<String, String> cache = CacheBuilder.newBuilder().build(computeFunction);
     ConcurrentMap<String, String> map = cache.asMap();
     map.put(refreshKey, refreshKey);
-    assertEquals(1, map.size());
-    assertFalse(map.containsKey(getKey));
-    assertSame(refreshKey, map.get(refreshKey));
+    assertThat(map).hasSize(1);
+    assertThat(map.containsKey(getKey)).isFalse();
+    assertThat(map.get(refreshKey)).isSameInstanceAs(refreshKey);
 
     new Thread() {
       @Override
@@ -2106,9 +2096,9 @@ public void run() {
     getStartedSignal.await();
 
     // computation is in progress; asMap shouldn't have changed
-    assertEquals(1, map.size());
-    assertFalse(map.containsKey(getKey));
-    assertSame(refreshKey, map.get(refreshKey));
+    assertThat(map).hasSize(1);
+    assertThat(map.containsKey(getKey)).isFalse();
+    assertThat(map.get(refreshKey)).isSameInstanceAs(refreshKey);
 
     // let computation complete
     letGetFinishSignal.countDown();
@@ -2116,9 +2106,9 @@ public void run() {
     checkNothingLogged();
 
     // asMap view should have been updated
-    assertEquals(2, cache.size());
-    assertEquals(getKey + suffix, map.get(getKey));
-    assertEquals(refreshKey + suffix, map.get(refreshKey));
+    assertThat(cache.size()).isEqualTo(2);
+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);
+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);
   }
 
   public void testInvalidateDuringLoading() throws InterruptedException, ExecutionException {
@@ -2162,8 +2152,8 @@ public void run() {
     computationStarted.await();
     cache.invalidate(getKey);
     cache.invalidate(refreshKey);
-    assertFalse(map.containsKey(getKey));
-    assertFalse(map.containsKey(refreshKey));
+    assertThat(map.containsKey(getKey)).isFalse();
+    assertThat(map.containsKey(refreshKey)).isFalse();
 
     // let computation complete
     letGetFinishSignal.countDown();
@@ -2171,10 +2161,10 @@ public void run() {
     checkNothingLogged();
 
     // results should be visible
-    assertEquals(2, cache.size());
-    assertEquals(getKey + suffix, map.get(getKey));
-    assertEquals(refreshKey + suffix, map.get(refreshKey));
-    assertEquals(2, cache.size());
+    assertThat(cache.size()).isEqualTo(2);
+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);
+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);
+    assertThat(cache.size()).isEqualTo(2);
   }
 
   public void testInvalidateAndReloadDuringLoading()
@@ -2219,8 +2209,8 @@ public void run() {
     computationStarted.await();
     cache.invalidate(getKey);
     cache.invalidate(refreshKey);
-    assertFalse(map.containsKey(getKey));
-    assertFalse(map.containsKey(refreshKey));
+    assertThat(map.containsKey(getKey)).isFalse();
+    assertThat(map.containsKey(refreshKey)).isFalse();
 
     // start new computations
     new Thread() {
@@ -2244,9 +2234,9 @@ public void run() {
     checkNothingLogged();
 
     // results should be visible
-    assertEquals(2, cache.size());
-    assertEquals(getKey + suffix, map.get(getKey));
-    assertEquals(refreshKey + suffix, map.get(refreshKey));
+    assertThat(cache.size()).isEqualTo(2);
+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);
+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);
   }
 
   @SuppressWarnings("ThreadPriorityCheck") // doing our best to test for races
@@ -2331,11 +2321,11 @@ public void run() {
     computeSignal.countDown();
     doneSignal.await();
 
-    assertTrue(callCount.get() == 1);
-    assertEquals("barfoo", result.get(0));
-    assertEquals("barfoo", result.get(1));
-    assertEquals("barfoo", result.get(2));
-    assertEquals("barfoo", cache.getUnchecked(key));
+    assertThat(callCount.get()).isEqualTo(1);
+    assertThat(result.get(0)).isEqualTo("barfoo");
+    assertThat(result.get(1)).isEqualTo("barfoo");
+    assertThat(result.get(2)).isEqualTo("barfoo");
+    assertThat(cache.getUnchecked(key)).isEqualTo("barfoo");
   }
 
   // Test ignored because it is extremely flaky in CI builds
@@ -2423,10 +2413,10 @@ public void run() {
     computeSignal.countDown();
     doneSignal.await();
 
-    assertTrue(callCount.get() == 1);
-    assertEquals(key, result.get(0));
-    assertEquals(key, result.get(1));
-    assertEquals(key + suffix, cache.getUnchecked(key));
+    assertThat(callCount.get()).isEqualTo(1);
+    assertThat(result.get(0)).isEqualTo(key);
+    assertThat(result.get(1)).isEqualTo(key);
+    assertThat(cache.getUnchecked(key)).isEqualTo(key + suffix);
   }
 
   static <T> Callable<T> throwing(Exception exception) {
diff --git a/android/guava-tests/test/com/google/common/cache/CacheManualTest.java b/android/guava-tests/test/com/google/common/cache/CacheManualTest.java
index a2cf24dcef28..e3b358a738b0 100644
--- a/android/guava-tests/test/com/google/common/cache/CacheManualTest.java
+++ b/android/guava-tests/test/com/google/common/cache/CacheManualTest.java
@@ -14,6 +14,7 @@
 
 package com.google.common.cache;
 
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.Arrays.asList;
 
 import com.google.common.collect.ImmutableList;
@@ -30,126 +31,127 @@ public class CacheManualTest extends TestCase {
   public void testGetIfPresent() {
     Cache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Object one = new Object();
     Object two = new Object();
 
-    assertNull(cache.getIfPresent(one));
+    assertThat(cache.getIfPresent(one)).isNull();
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
-    assertNull(cache.asMap().get(one));
-    assertFalse(cache.asMap().containsKey(one));
-    assertFalse(cache.asMap().containsValue(two));
-
-    assertNull(cache.getIfPresent(two));
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
+    assertThat(cache.asMap().get(one)).isNull();
+    assertThat(cache.asMap().containsKey(one)).isFalse();
+    assertThat(cache.asMap().containsValue(two)).isFalse();
+
+    assertThat(cache.getIfPresent(two)).isNull();
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
-    assertNull(cache.asMap().get(two));
-    assertFalse(cache.asMap().containsKey(two));
-    assertFalse(cache.asMap().containsValue(one));
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
+    assertThat(cache.asMap().get(two)).isNull();
+    assertThat(cache.asMap().containsKey(two)).isFalse();
+    assertThat(cache.asMap().containsValue(one)).isFalse();
 
     cache.put(one, two);
 
-    assertSame(two, cache.getIfPresent(one));
+    assertThat(cache.getIfPresent(one)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
-    assertSame(two, cache.asMap().get(one));
-    assertTrue(cache.asMap().containsKey(one));
-    assertTrue(cache.asMap().containsValue(two));
-
-    assertNull(cache.getIfPresent(two));
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
+    assertThat(cache.asMap().get(one)).isSameInstanceAs(two);
+    assertThat(cache.asMap().containsKey(one)).isTrue();
+    assertThat(cache.asMap().containsValue(two)).isTrue();
+
+    assertThat(cache.getIfPresent(two)).isNull();
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
-    assertNull(cache.asMap().get(two));
-    assertFalse(cache.asMap().containsKey(two));
-    assertFalse(cache.asMap().containsValue(one));
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
+    assertThat(cache.asMap().get(two)).isNull();
+    assertThat(cache.asMap().containsKey(two)).isFalse();
+    assertThat(cache.asMap().containsValue(one)).isFalse();
 
     cache.put(two, one);
 
-    assertSame(two, cache.getIfPresent(one));
+    assertThat(cache.getIfPresent(one)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
-    assertSame(two, cache.asMap().get(one));
-    assertTrue(cache.asMap().containsKey(one));
-    assertTrue(cache.asMap().containsValue(two));
-
-    assertSame(one, cache.getIfPresent(two));
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(2);
+    assertThat(cache.asMap().get(one)).isSameInstanceAs(two);
+    assertThat(cache.asMap().containsKey(one)).isTrue();
+    assertThat(cache.asMap().containsValue(two)).isTrue();
+
+    assertThat(cache.getIfPresent(two)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
-    assertSame(one, cache.asMap().get(two));
-    assertTrue(cache.asMap().containsKey(two));
-    assertTrue(cache.asMap().containsValue(one));
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(3);
+    assertThat(cache.asMap().get(two)).isSameInstanceAs(one);
+    assertThat(cache.asMap().containsKey(two)).isTrue();
+    assertThat(cache.asMap().containsValue(one)).isTrue();
   }
 
   public void testGetAllPresent() {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().recordStats().build();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(), cache.getAllPresent(ImmutableList.<Integer>of()));
+    assertThat(cache.getAllPresent(ImmutableList.<Integer>of())).isEmpty();
     stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(), cache.getAllPresent(asList(1, 2, 3)));
+    assertThat(cache.getAllPresent(asList(1, 2, 3))).isEqualTo(ImmutableMap.of());
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.put(2, 22);
 
-    assertEquals(ImmutableMap.of(2, 22), cache.getAllPresent(asList(1, 2, 3)));
+    assertThat(cache.getAllPresent(asList(1, 2, 3))).containsExactly(2, 22);
     stats = cache.stats();
-    assertEquals(5, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(5);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     cache.put(3, 33);
 
-    assertEquals(ImmutableMap.of(2, 22, 3, 33), cache.getAllPresent(asList(1, 2, 3)));
+    assertThat(cache.getAllPresent(asList(1, 2, 3))).containsExactly(2, 22, 3, 33);
     stats = cache.stats();
-    assertEquals(6, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(6);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(3);
 
     cache.put(1, 11);
 
-    assertEquals(ImmutableMap.of(1, 11, 2, 22, 3, 33), cache.getAllPresent(asList(1, 2, 3)));
+    assertThat(cache.getAllPresent(asList(1, 2, 3)))
+        .isEqualTo(ImmutableMap.of(1, 11, 2, 22, 3, 33));
     stats = cache.stats();
-    assertEquals(6, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(6, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(6);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(6);
   }
 }
diff --git a/android/guava-tests/test/com/google/common/cache/CacheReferencesTest.java b/android/guava-tests/test/com/google/common/cache/CacheReferencesTest.java
index 5426d29141f5..11ce62e0a0b1 100644
--- a/android/guava-tests/test/com/google/common/cache/CacheReferencesTest.java
+++ b/android/guava-tests/test/com/google/common/cache/CacheReferencesTest.java
@@ -66,10 +66,10 @@ public void testContainsKeyAndValue() {
       // maintain strong refs so these won't be collected, regardless of cache's key/value strength
       Key key = new Key(1);
       String value = key.toString();
-      assertSame(value, cache.getUnchecked(key));
-      assertTrue(cache.asMap().containsKey(key));
-      assertTrue(cache.asMap().containsValue(value));
-      assertEquals(1, cache.size());
+      assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);
+      assertThat(cache.asMap().containsKey(key)).isTrue();
+      assertThat(cache.asMap().containsValue(value)).isTrue();
+      assertThat(cache.size()).isEqualTo(1);
     }
   }
 
@@ -77,13 +77,13 @@ public void testClear() {
     for (LoadingCache<Key, String> cache : caches()) {
       Key key = new Key(1);
       String value = key.toString();
-      assertSame(value, cache.getUnchecked(key));
-      assertFalse(cache.asMap().isEmpty());
+      assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);
+      assertThat(cache.asMap().isEmpty()).isFalse();
       cache.invalidateAll();
-      assertEquals(0, cache.size());
-      assertTrue(cache.asMap().isEmpty());
-      assertFalse(cache.asMap().containsKey(key));
-      assertFalse(cache.asMap().containsValue(value));
+      assertThat(cache.size()).isEqualTo(0);
+      assertThat(cache.asMap().isEmpty()).isTrue();
+      assertThat(cache.asMap().containsKey(key)).isFalse();
+      assertThat(cache.asMap().containsValue(value)).isFalse();
     }
   }
 
@@ -93,13 +93,12 @@ public void testKeySetEntrySetValues() {
       String value1 = key1.toString();
       Key key2 = new Key(2);
       String value2 = key2.toString();
-      assertSame(value1, cache.getUnchecked(key1));
-      assertSame(value2, cache.getUnchecked(key2));
-      assertEquals(ImmutableSet.of(key1, key2), cache.asMap().keySet());
+      assertThat(cache.getUnchecked(key1)).isSameInstanceAs(value1);
+      assertThat(cache.getUnchecked(key2)).isSameInstanceAs(value2);
+      assertThat(cache.asMap().keySet()).isEqualTo(ImmutableSet.of(key1, key2));
       assertThat(cache.asMap().values()).containsExactly(value1, value2);
-      assertEquals(
-          ImmutableSet.of(immutableEntry(key1, value1), immutableEntry(key2, value2)),
-          cache.asMap().entrySet());
+      assertThat(cache.asMap().entrySet())
+          .containsExactly(immutableEntry(key1, value1), immutableEntry(key2, value2));
     }
   }
 
@@ -109,15 +108,15 @@ public void testInvalidate() {
       String value1 = key1.toString();
       Key key2 = new Key(2);
       String value2 = key2.toString();
-      assertSame(value1, cache.getUnchecked(key1));
-      assertSame(value2, cache.getUnchecked(key2));
+      assertThat(cache.getUnchecked(key1)).isSameInstanceAs(value1);
+      assertThat(cache.getUnchecked(key2)).isSameInstanceAs(value2);
       cache.invalidate(key1);
-      assertFalse(cache.asMap().containsKey(key1));
-      assertTrue(cache.asMap().containsKey(key2));
-      assertEquals(1, cache.size());
-      assertEquals(ImmutableSet.of(key2), cache.asMap().keySet());
+      assertThat(cache.asMap().containsKey(key1)).isFalse();
+      assertThat(cache.asMap().containsKey(key2)).isTrue();
+      assertThat(cache.size()).isEqualTo(1);
+      assertThat(cache.asMap().keySet()).isEqualTo(ImmutableSet.of(key2));
       assertThat(cache.asMap().values()).contains(value2);
-      assertEquals(ImmutableSet.of(immutableEntry(key2, value2)), cache.asMap().entrySet());
+      assertThat(cache.asMap().entrySet()).containsExactly(immutableEntry(key2, value2));
     }
   }
 
diff --git a/android/guava-tests/test/com/google/common/cache/CacheRefreshTest.java b/android/guava-tests/test/com/google/common/cache/CacheRefreshTest.java
index 6a7948c470dc..83c3ea3b5777 100644
--- a/android/guava-tests/test/com/google/common/cache/CacheRefreshTest.java
+++ b/android/guava-tests/test/com/google/common/cache/CacheRefreshTest.java
@@ -15,6 +15,7 @@
 package com.google.common.cache;
 
 import static com.google.common.cache.TestingCacheLoaders.incrementingLoader;
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 import com.google.common.cache.TestingCacheLoaders.IncrementingLoader;
@@ -42,61 +43,61 @@ public void testAutoRefresh() {
     int expectedLoads = 0;
     int expectedReloads = 0;
     for (int i = 0; i < 3; i++) {
-      assertEquals(Integer.valueOf(i), cache.getUnchecked(i));
+      assertThat(cache.getUnchecked(i)).isEqualTo(i);
       expectedLoads++;
-      assertEquals(expectedLoads, loader.getLoadCount());
-      assertEquals(expectedReloads, loader.getReloadCount());
+      assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+      assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
       ticker.advance(1, MILLISECONDS);
     }
 
-    assertEquals(Integer.valueOf(0), cache.getUnchecked(0));
-    assertEquals(Integer.valueOf(1), cache.getUnchecked(1));
-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));
-    assertEquals(expectedLoads, loader.getLoadCount());
-    assertEquals(expectedReloads, loader.getReloadCount());
+    assertThat(cache.getUnchecked(0)).isEqualTo(0);
+    assertThat(cache.getUnchecked(1)).isEqualTo(1);
+    assertThat(cache.getUnchecked(2)).isEqualTo(2);
+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
 
     // refresh 0
     ticker.advance(1, MILLISECONDS);
-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));
+    assertThat(cache.getUnchecked(0)).isEqualTo(1);
     expectedReloads++;
-    assertEquals(Integer.valueOf(1), cache.getUnchecked(1));
-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));
-    assertEquals(expectedLoads, loader.getLoadCount());
-    assertEquals(expectedReloads, loader.getReloadCount());
+    assertThat(cache.getUnchecked(1)).isEqualTo(1);
+    assertThat(cache.getUnchecked(2)).isEqualTo(2);
+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
 
     // write to 1 to delay its refresh
     cache.asMap().put(1, -1);
     ticker.advance(1, MILLISECONDS);
-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));
-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));
-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));
-    assertEquals(expectedLoads, loader.getLoadCount());
-    assertEquals(expectedReloads, loader.getReloadCount());
+    assertThat(cache.getUnchecked(0)).isEqualTo(1);
+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);
+    assertThat(cache.getUnchecked(2)).isEqualTo(2);
+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
 
     // refresh 2
     ticker.advance(1, MILLISECONDS);
-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));
-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));
-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));
+    assertThat(cache.getUnchecked(0)).isEqualTo(1);
+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);
+    assertThat(cache.getUnchecked(2)).isEqualTo(3);
     expectedReloads++;
-    assertEquals(expectedLoads, loader.getLoadCount());
-    assertEquals(expectedReloads, loader.getReloadCount());
+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
 
     ticker.advance(1, MILLISECONDS);
-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));
-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));
-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));
-    assertEquals(expectedLoads, loader.getLoadCount());
-    assertEquals(expectedReloads, loader.getReloadCount());
+    assertThat(cache.getUnchecked(0)).isEqualTo(1);
+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);
+    assertThat(cache.getUnchecked(2)).isEqualTo(3);
+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
 
     // refresh 0 and 1
     ticker.advance(1, MILLISECONDS);
-    assertEquals(Integer.valueOf(2), cache.getUnchecked(0));
+    assertThat(cache.getUnchecked(0)).isEqualTo(2);
     expectedReloads++;
-    assertEquals(Integer.valueOf(0), cache.getUnchecked(1));
+    assertThat(cache.getUnchecked(1)).isEqualTo(0);
     expectedReloads++;
-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));
-    assertEquals(expectedLoads, loader.getLoadCount());
-    assertEquals(expectedReloads, loader.getReloadCount());
+    assertThat(cache.getUnchecked(2)).isEqualTo(3);
+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
   }
 }
diff --git a/android/guava-tests/test/com/google/common/cache/CacheStatsTest.java b/android/guava-tests/test/com/google/common/cache/CacheStatsTest.java
index cfd174aea242..72cbfee29807 100644
--- a/android/guava-tests/test/com/google/common/cache/CacheStatsTest.java
+++ b/android/guava-tests/test/com/google/common/cache/CacheStatsTest.java
@@ -31,34 +31,34 @@ public class CacheStatsTest extends TestCase {
 
   public void testEmpty() {
     CacheStats stats = new CacheStats(0, 0, 0, 0, 0, 0);
-    assertEquals(0, stats.requestCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
     assertThat(stats.hitRate()).isEqualTo(1.0);
-    assertEquals(0, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(0);
     assertThat(stats.missRate()).isEqualTo(0.0);
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
     assertThat(stats.loadExceptionRate()).isEqualTo(0.0);
-    assertEquals(0, stats.loadCount());
-    assertEquals(0, stats.totalLoadTime());
+    assertThat(stats.loadCount()).isEqualTo(0);
+    assertThat(stats.totalLoadTime()).isEqualTo(0);
     assertThat(stats.averageLoadPenalty()).isEqualTo(0.0);
-    assertEquals(0, stats.evictionCount());
+    assertThat(stats.evictionCount()).isEqualTo(0);
   }
 
   public void testSingle() {
     CacheStats stats = new CacheStats(11, 13, 17, 19, 23, 27);
-    assertEquals(24, stats.requestCount());
-    assertEquals(11, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(24);
+    assertThat(stats.hitCount()).isEqualTo(11);
     assertThat(stats.hitRate()).isEqualTo(11.0 / 24);
-    assertEquals(13, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(13);
     assertThat(stats.missRate()).isEqualTo(13.0 / 24);
-    assertEquals(17, stats.loadSuccessCount());
-    assertEquals(19, stats.loadExceptionCount());
+    assertThat(stats.loadSuccessCount()).isEqualTo(17);
+    assertThat(stats.loadExceptionCount()).isEqualTo(19);
     assertThat(stats.loadExceptionRate()).isEqualTo(19.0 / 36);
-    assertEquals(17 + 19, stats.loadCount());
-    assertEquals(23, stats.totalLoadTime());
+    assertThat(stats.loadCount()).isEqualTo(17 + 19);
+    assertThat(stats.totalLoadTime()).isEqualTo(23);
     assertThat(stats.averageLoadPenalty()).isEqualTo(23.0 / (17 + 19));
-    assertEquals(27, stats.evictionCount());
+    assertThat(stats.evictionCount()).isEqualTo(27);
   }
 
   public void testMinus() {
@@ -66,20 +66,20 @@ public void testMinus() {
     CacheStats two = new CacheStats(53, 47, 43, 41, 37, 31);
 
     CacheStats diff = two.minus(one);
-    assertEquals(76, diff.requestCount());
-    assertEquals(42, diff.hitCount());
+    assertThat(diff.requestCount()).isEqualTo(76);
+    assertThat(diff.hitCount()).isEqualTo(42);
     assertThat(diff.hitRate()).isEqualTo(42.0 / 76);
-    assertEquals(34, diff.missCount());
+    assertThat(diff.missCount()).isEqualTo(34);
     assertThat(diff.missRate()).isEqualTo(34.0 / 76);
-    assertEquals(26, diff.loadSuccessCount());
-    assertEquals(22, diff.loadExceptionCount());
+    assertThat(diff.loadSuccessCount()).isEqualTo(26);
+    assertThat(diff.loadExceptionCount()).isEqualTo(22);
     assertThat(diff.loadExceptionRate()).isEqualTo(22.0 / 48);
-    assertEquals(26 + 22, diff.loadCount());
-    assertEquals(14, diff.totalLoadTime());
+    assertThat(diff.loadCount()).isEqualTo(26 + 22);
+    assertThat(diff.totalLoadTime()).isEqualTo(14);
     assertThat(diff.averageLoadPenalty()).isEqualTo(14.0 / (26 + 22));
-    assertEquals(4, diff.evictionCount());
+    assertThat(diff.evictionCount()).isEqualTo(4);
 
-    assertEquals(new CacheStats(0, 0, 0, 0, 0, 0), one.minus(two));
+    assertThat(one.minus(two)).isEqualTo(new CacheStats(0, 0, 0, 0, 0, 0));
   }
 
   public void testPlus() {
@@ -87,20 +87,20 @@ public void testPlus() {
     CacheStats two = new CacheStats(53, 47, 41, 39, 37, 35);
 
     CacheStats sum = two.plus(one);
-    assertEquals(124, sum.requestCount());
-    assertEquals(64, sum.hitCount());
+    assertThat(sum.requestCount()).isEqualTo(124);
+    assertThat(sum.hitCount()).isEqualTo(64);
     assertThat(sum.hitRate()).isEqualTo(64.0 / 124);
-    assertEquals(60, sum.missCount());
+    assertThat(sum.missCount()).isEqualTo(60);
     assertThat(sum.missRate()).isEqualTo(60.0 / 124);
-    assertEquals(56, sum.loadSuccessCount());
-    assertEquals(52, sum.loadExceptionCount());
+    assertThat(sum.loadSuccessCount()).isEqualTo(56);
+    assertThat(sum.loadExceptionCount()).isEqualTo(52);
     assertThat(sum.loadExceptionRate()).isEqualTo(52.0 / 108);
-    assertEquals(56 + 52, sum.loadCount());
-    assertEquals(48, sum.totalLoadTime());
+    assertThat(sum.loadCount()).isEqualTo(56 + 52);
+    assertThat(sum.totalLoadTime()).isEqualTo(48);
     assertThat(sum.averageLoadPenalty()).isEqualTo(48.0 / (56 + 52));
-    assertEquals(44, sum.evictionCount());
+    assertThat(sum.evictionCount()).isEqualTo(44);
 
-    assertEquals(sum, one.plus(two));
+    assertThat(one.plus(two)).isEqualTo(sum);
   }
 
   public void testPlusLarge() {
@@ -115,19 +115,19 @@ public void testPlusLarge() {
     CacheStats smallCacheStats = new CacheStats(1, 1, 1, 1, 1, 1);
 
     CacheStats sum = smallCacheStats.plus(maxCacheStats);
-    assertEquals(Long.MAX_VALUE, sum.requestCount());
-    assertEquals(Long.MAX_VALUE, sum.hitCount());
+    assertThat(sum.requestCount()).isEqualTo(Long.MAX_VALUE);
+    assertThat(sum.hitCount()).isEqualTo(Long.MAX_VALUE);
     assertThat(sum.hitRate()).isEqualTo(1.0);
-    assertEquals(Long.MAX_VALUE, sum.missCount());
+    assertThat(sum.missCount()).isEqualTo(Long.MAX_VALUE);
     assertThat(sum.missRate()).isEqualTo(1.0);
-    assertEquals(Long.MAX_VALUE, sum.loadSuccessCount());
-    assertEquals(Long.MAX_VALUE, sum.loadExceptionCount());
+    assertThat(sum.loadSuccessCount()).isEqualTo(Long.MAX_VALUE);
+    assertThat(sum.loadExceptionCount()).isEqualTo(Long.MAX_VALUE);
     assertThat(sum.loadExceptionRate()).isEqualTo(1.0);
-    assertEquals(Long.MAX_VALUE, sum.loadCount());
-    assertEquals(Long.MAX_VALUE, sum.totalLoadTime());
+    assertThat(sum.loadCount()).isEqualTo(Long.MAX_VALUE);
+    assertThat(sum.totalLoadTime()).isEqualTo(Long.MAX_VALUE);
     assertThat(sum.averageLoadPenalty()).isEqualTo(1.0);
-    assertEquals(Long.MAX_VALUE, sum.evictionCount());
+    assertThat(sum.evictionCount()).isEqualTo(Long.MAX_VALUE);
 
-    assertEquals(sum, maxCacheStats.plus(smallCacheStats));
+    assertThat(maxCacheStats.plus(smallCacheStats)).isEqualTo(sum);
   }
 }
diff --git a/android/guava-tests/test/com/google/common/cache/CacheTesting.java b/android/guava-tests/test/com/google/common/cache/CacheTesting.java
index 5c27308ed868..6c33cde9d009 100644
--- a/android/guava-tests/test/com/google/common/cache/CacheTesting.java
+++ b/android/guava-tests/test/com/google/common/cache/CacheTesting.java
@@ -16,15 +16,9 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.lang.Math.max;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertNotSame;
-import static junit.framework.Assert.assertNull;
-import static junit.framework.Assert.assertSame;
-import static junit.framework.Assert.assertTrue;
 
 import com.google.common.base.Preconditions;
 import com.google.common.cache.LocalCache.LocalLoadingCache;
@@ -194,16 +188,16 @@ static void checkValidState(Cache<?, ?> cache) {
   static void checkValidState(LocalCache<?, ?> cchm) {
     for (Segment<?, ?> segment : cchm.segments) {
       segment.cleanUp();
-      assertFalse(segment.isLocked());
+      assertThat(segment.isLocked()).isFalse();
       Map<?, ?> table = segmentTable(segment);
       // cleanup and then check count after we have a strong reference to all entries
       segment.cleanUp();
       // under high memory pressure keys/values may be nulled out but not yet enqueued
       assertThat(table.size()).isAtMost(segment.count);
       for (Entry<?, ?> entry : table.entrySet()) {
-        assertNotNull(entry.getKey());
-        assertNotNull(entry.getValue());
-        assertSame(entry.getValue(), cchm.get(entry.getKey()));
+        assertThat(entry.getKey()).isNotNull();
+        assertThat(entry.getValue()).isNotNull();
+        assertThat(cchm.get(entry.getKey())).isSameInstanceAs(entry.getValue());
       }
     }
     checkEviction(cchm);
@@ -228,21 +222,21 @@ static void checkExpiration(LocalCache<?, ?> cchm) {
 
         ReferenceEntry<?, ?> prev = null;
         for (ReferenceEntry<?, ?> current : segment.writeQueue) {
-          assertTrue(entries.add(current));
+          assertThat(entries.add(current)).isTrue();
           if (prev != null) {
-            assertSame(prev, current.getPreviousInWriteQueue());
-            assertSame(prev.getNextInWriteQueue(), current);
+            assertThat(current.getPreviousInWriteQueue()).isSameInstanceAs(prev);
+            assertThat(current).isSameInstanceAs(prev.getNextInWriteQueue());
             assertThat(prev.getWriteTime()).isAtMost(current.getWriteTime());
           }
           Object key = current.getKey();
           if (key != null) {
-            assertSame(current, segment.getEntry(key, current.getHash()));
+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);
           }
           prev = current;
         }
-        assertEquals(segment.count, entries.size());
+        assertThat(entries).hasSize(segment.count);
       } else {
-        assertTrue(segment.writeQueue.isEmpty());
+        assertThat(segment.writeQueue.isEmpty()).isTrue();
       }
 
       if (cchm.usesAccessQueue()) {
@@ -250,24 +244,25 @@ static void checkExpiration(LocalCache<?, ?> cchm) {
 
         ReferenceEntry<?, ?> prev = null;
         for (ReferenceEntry<?, ?> current : segment.accessQueue) {
-          assertTrue(entries.add(current));
+          assertThat(entries.add(current)).isTrue();
           if (prev != null) {
-            assertSame(prev, current.getPreviousInAccessQueue());
-            assertSame(prev.getNextInAccessQueue(), current);
+            assertThat(current.getPreviousInAccessQueue()).isSameInstanceAs(prev);
+            assertThat(current).isSameInstanceAs(prev.getNextInAccessQueue());
             // read accesses may be slightly misordered
-            assertTrue(
-                prev.getAccessTime() <= current.getAccessTime()
-                    || prev.getAccessTime() - current.getAccessTime() < 1000);
+            assertThat(
+                    prev.getAccessTime() <= current.getAccessTime()
+                        || prev.getAccessTime() - current.getAccessTime() < 1000)
+                .isTrue();
           }
           Object key = current.getKey();
           if (key != null) {
-            assertSame(current, segment.getEntry(key, current.getHash()));
+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);
           }
           prev = current;
         }
-        assertEquals(segment.count, entries.size());
+        assertThat(entries).hasSize(segment.count);
       } else {
-        assertTrue(segment.accessQueue.isEmpty());
+        assertThat(segment.accessQueue).isEmpty();
       }
     }
   }
@@ -287,25 +282,25 @@ static void checkEviction(LocalCache<?, ?> map) {
     if (map.evictsBySize()) {
       for (Segment<?, ?> segment : map.segments) {
         drainRecencyQueue(segment);
-        assertEquals(0, segment.recencyQueue.size());
-        assertEquals(0, segment.readCount.get());
+        assertThat(segment.recencyQueue).isEmpty();
+        assertThat(segment.readCount.get()).isEqualTo(0);
 
         ReferenceEntry<?, ?> prev = null;
         for (ReferenceEntry<?, ?> current : segment.accessQueue) {
           if (prev != null) {
-            assertSame(prev, current.getPreviousInAccessQueue());
-            assertSame(prev.getNextInAccessQueue(), current);
+            assertThat(current.getPreviousInAccessQueue()).isSameInstanceAs(prev);
+            assertThat(current).isSameInstanceAs(prev.getNextInAccessQueue());
           }
           Object key = current.getKey();
           if (key != null) {
-            assertSame(current, segment.getEntry(key, current.getHash()));
+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);
           }
           prev = current;
         }
       }
     } else {
       for (Segment<?, ?> segment : map.segments) {
-        assertEquals(0, segment.recencyQueue.size());
+        assertThat(segment.recencyQueue).isEmpty();
       }
     }
   }
@@ -323,7 +318,7 @@ static <K, V> Map<K, V> segmentTable(Segment<K, V> segment) {
         K key = entry.getKey();
         V value = entry.getValueReference().get();
         if (key != null && value != null) {
-          assertNull(map.put(key, value));
+          assertThat(map.put(key, value)).isNull();
         }
       }
     }
@@ -390,8 +385,8 @@ static void checkRecency(
       LocalCache<Integer, Integer> cchm = toLocalCache(cache);
       Segment<?, ?> segment = cchm.segments[0];
       drainRecencyQueue(segment);
-      assertEquals(maxSize, accessQueueSize(cache));
-      assertEquals(maxSize, cache.size());
+      assertThat(accessQueueSize(cache)).isEqualTo(maxSize);
+      assertThat(cache.size()).isEqualTo(maxSize);
 
       ReferenceEntry<?, ?> originalHead = segment.accessQueue.peek();
       @SuppressWarnings("unchecked")
@@ -399,8 +394,8 @@ static void checkRecency(
       operation.accept(entry);
       drainRecencyQueue(segment);
 
-      assertNotSame(originalHead, segment.accessQueue.peek());
-      assertEquals(cache.size(), accessQueueSize(cache));
+      assertThat(segment.accessQueue.peek()).isNotSameInstanceAs(originalHead);
+      assertThat(accessQueueSize(cache)).isEqualTo(cache.size());
     }
   }
 
@@ -428,9 +423,13 @@ static void expireEntries(LocalCache<?, ?> cchm, long expiringTime, FakeTicker t
     long now = ticker.read();
     for (Segment<?, ?> segment : cchm.segments) {
       expireEntries(segment, now);
-      assertEquals("Expiration queue must be empty by now", 0, writeQueueSize(segment));
-      assertEquals("Expiration queue must be empty by now", 0, accessQueueSize(segment));
-      assertEquals("Segments must be empty by now", 0, segmentSize(segment));
+      assertWithMessage("Expiration queue must be empty by now")
+          .that(writeQueueSize(segment))
+          .isEqualTo(0);
+      assertWithMessage("Expiration queue must be empty by now")
+          .that(accessQueueSize(segment))
+          .isEqualTo(0);
+      assertWithMessage("Segments must be empty by now").that(segmentSize(segment)).isEqualTo(0);
     }
     cchm.processPendingNotifications();
   }
@@ -446,11 +445,11 @@ static void expireEntries(Segment<?, ?> segment, long now) {
   }
 
   static void checkEmpty(Cache<?, ?> cache) {
-    assertEquals(0, cache.size());
-    assertFalse(cache.asMap().containsKey(null));
-    assertFalse(cache.asMap().containsKey(6));
-    assertFalse(cache.asMap().containsValue(null));
-    assertFalse(cache.asMap().containsValue(6));
+    assertThat(cache.size()).isEqualTo(0);
+    assertThat(cache.asMap().containsKey(null)).isFalse();
+    assertThat(cache.asMap().containsKey(6)).isFalse();
+    assertThat(cache.asMap().containsValue(null)).isFalse();
+    assertThat(cache.asMap().containsValue(6)).isFalse();
     checkEmpty(cache.asMap());
   }
 
@@ -458,29 +457,29 @@ static void checkEmpty(ConcurrentMap<?, ?> map) {
     checkEmpty(map.keySet());
     checkEmpty(map.values());
     checkEmpty(map.entrySet());
-    assertEquals(ImmutableMap.of(), map);
-    assertEquals(ImmutableMap.of().hashCode(), map.hashCode());
-    assertEquals(ImmutableMap.of().toString(), map.toString());
+    assertThat(map).isEqualTo(ImmutableMap.of());
+    assertThat(map.hashCode()).isEqualTo(ImmutableMap.of().hashCode());
+    assertThat(map.toString()).isEqualTo(ImmutableMap.of().toString());
 
     if (map instanceof LocalCache) {
       LocalCache<?, ?> cchm = (LocalCache<?, ?>) map;
 
       checkValidState(cchm);
-      assertTrue(cchm.isEmpty());
-      assertEquals(0, cchm.size());
+      assertThat(cchm.isEmpty()).isTrue();
+      assertThat(cchm).isEmpty();
       for (LocalCache.Segment<?, ?> segment : cchm.segments) {
-        assertEquals(0, segment.count);
-        assertEquals(0, segmentSize(segment));
-        assertTrue(segment.writeQueue.isEmpty());
-        assertTrue(segment.accessQueue.isEmpty());
+        assertThat(segment.count).isEqualTo(0);
+        assertThat(segmentSize(segment)).isEqualTo(0);
+        assertThat(segment.writeQueue.isEmpty()).isTrue();
+        assertThat(segment.accessQueue.isEmpty()).isTrue();
       }
     }
   }
 
   static void checkEmpty(Collection<?> collection) {
-    assertTrue(collection.isEmpty());
-    assertEquals(0, collection.size());
-    assertFalse(collection.iterator().hasNext());
+    assertThat(collection.isEmpty()).isTrue();
+    assertThat(collection).isEmpty();
+    assertThat(collection.iterator().hasNext()).isFalse();
     assertThat(collection.toArray()).isEmpty();
     assertThat(collection.toArray(new Object[0])).isEmpty();
     if (collection instanceof Set) {
diff --git a/android/guava-tests/test/com/google/common/cache/EmptyCachesTest.java b/android/guava-tests/test/com/google/common/cache/EmptyCachesTest.java
index f93568bc29a5..94a912347d9d 100644
--- a/android/guava-tests/test/com/google/common/cache/EmptyCachesTest.java
+++ b/android/guava-tests/test/com/google/common/cache/EmptyCachesTest.java
@@ -16,6 +16,7 @@
 
 import static com.google.common.cache.CacheTesting.checkEmpty;
 import static com.google.common.cache.TestingCacheLoaders.identityLoader;
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.Arrays.asList;
 import static java.util.concurrent.TimeUnit.DAYS;
 import static java.util.concurrent.TimeUnit.SECONDS;
@@ -75,7 +76,7 @@ public void testInvalidateAll_empty() {
 
   public void testEquals_null() {
     for (LoadingCache<Object, Object> cache : caches()) {
-      assertFalse(cache.equals(null));
+      assertThat(cache.equals(null)).isFalse();
     }
   }
 
@@ -138,11 +139,11 @@ public void testKeySet_clear() {
   public void testKeySet_empty_remove() {
     for (LoadingCache<Object, Object> cache : caches()) {
       Set<Object> keys = cache.asMap().keySet();
-      assertFalse(keys.remove(null));
-      assertFalse(keys.remove(6));
-      assertFalse(keys.remove(-6));
-      assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));
-      assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));
+      assertThat(keys.remove(null)).isFalse();
+      assertThat(keys.remove(6)).isFalse();
+      assertThat(keys.remove(-6)).isFalse();
+      assertThat(keys.removeAll(asList(null, 0, 15, 1500))).isFalse();
+      assertThat(keys.retainAll(asList(null, 0, 15, 1500))).isFalse();
       checkEmpty(keys);
       checkEmpty(cache);
     }
@@ -158,11 +159,11 @@ public void testKeySet_remove() {
       // values of these removes, but the cache should be empty after the removes, regardless.
       keys.remove(1);
       keys.remove(2);
-      assertFalse(keys.remove(null));
-      assertFalse(keys.remove(6));
-      assertFalse(keys.remove(-6));
-      assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));
-      assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));
+      assertThat(keys.remove(null)).isFalse();
+      assertThat(keys.remove(6)).isFalse();
+      assertThat(keys.remove(-6)).isFalse();
+      assertThat(keys.removeAll(asList(null, 0, 15, 1500))).isFalse();
+      assertThat(keys.retainAll(asList(null, 0, 15, 1500))).isFalse();
       checkEmpty(keys);
       checkEmpty(cache);
     }
@@ -202,11 +203,11 @@ public void testValues_clear() {
   public void testValues_empty_remove() {
     for (LoadingCache<Object, Object> cache : caches()) {
       Collection<Object> values = cache.asMap().values();
-      assertFalse(values.remove(null));
-      assertFalse(values.remove(6));
-      assertFalse(values.remove(-6));
-      assertFalse(values.removeAll(asList(null, 0, 15, 1500)));
-      assertFalse(values.retainAll(asList(null, 0, 15, 1500)));
+      assertThat(values.remove(null)).isFalse();
+      assertThat(values.remove(6)).isFalse();
+      assertThat(values.remove(-6)).isFalse();
+      assertThat(values.removeAll(asList(null, 0, 15, 1500))).isFalse();
+      assertThat(values.retainAll(asList(null, 0, 15, 1500))).isFalse();
       checkEmpty(values);
       checkEmpty(cache);
     }
@@ -222,11 +223,11 @@ public void testValues_remove() {
       // values of these removes, but the cache should be empty after the removes, regardless.
       values.remove(1);
       values.remove(2);
-      assertFalse(values.remove(null));
-      assertFalse(values.remove(6));
-      assertFalse(values.remove(-6));
-      assertFalse(values.removeAll(asList(null, 0, 15, 1500)));
-      assertFalse(values.retainAll(asList(null, 0, 15, 1500)));
+      assertThat(values.remove(null)).isFalse();
+      assertThat(values.remove(6)).isFalse();
+      assertThat(values.remove(-6)).isFalse();
+      assertThat(values.removeAll(asList(null, 0, 15, 1500))).isFalse();
+      assertThat(values.retainAll(asList(null, 0, 15, 1500))).isFalse();
       checkEmpty(values);
       checkEmpty(cache);
     }
@@ -269,11 +270,11 @@ public void testEntrySet_clear() {
   public void testEntrySet_empty_remove() {
     for (LoadingCache<Object, Object> cache : caches()) {
       Set<Entry<Object, Object>> entrySet = cache.asMap().entrySet();
-      assertFalse(entrySet.remove(null));
-      assertFalse(entrySet.remove(entryOf(6, 6)));
-      assertFalse(entrySet.remove(entryOf(-6, -6)));
-      assertFalse(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15))));
-      assertFalse(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15))));
+      assertThat(entrySet.remove(null)).isFalse();
+      assertThat(entrySet.remove(entryOf(6, 6))).isFalse();
+      assertThat(entrySet.remove(entryOf(-6, -6))).isFalse();
+      assertThat(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15)))).isFalse();
+      assertThat(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15)))).isFalse();
       checkEmpty(entrySet);
       checkEmpty(cache);
     }
@@ -289,11 +290,11 @@ public void testEntrySet_remove() {
       // values of these removes, but the cache should be empty after the removes, regardless.
       entrySet.remove(entryOf(1, 1));
       entrySet.remove(entryOf(2, 2));
-      assertFalse(entrySet.remove(null));
-      assertFalse(entrySet.remove(entryOf(1, 1)));
-      assertFalse(entrySet.remove(entryOf(6, 6)));
-      assertFalse(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15))));
-      assertFalse(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15))));
+      assertThat(entrySet.remove(null)).isFalse();
+      assertThat(entrySet.remove(entryOf(1, 1))).isFalse();
+      assertThat(entrySet.remove(entryOf(6, 6))).isFalse();
+      assertThat(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15)))).isFalse();
+      assertThat(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15)))).isFalse();
       checkEmpty(entrySet);
       checkEmpty(cache);
     }
diff --git a/android/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java b/android/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java
index 76de76c3707c..9eb3fe7e33c7 100644
--- a/android/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java
+++ b/android/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java
@@ -16,12 +16,14 @@
 
 package com.google.common.cache;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.errorprone.annotations.Keep;
 import java.util.concurrent.ExecutionException;
 import junit.framework.TestCase;
 import org.jspecify.annotations.NullUnmarked;
@@ -56,15 +58,13 @@ protected Cache<String, Boolean> delegate() {
   }
 
   public void testGetIfPresent() throws ExecutionException {
-    when(mock.getIfPresent("key")).thenReturn(Boolean.TRUE);
-    assertSame(Boolean.TRUE, forward.getIfPresent("key"));
+    when(mock.getIfPresent("key")).thenReturn(true);
+    assertThat(forward.getIfPresent("key")).isSameInstanceAs(true);
   }
 
   public void testGetAllPresent() throws ExecutionException {
-    when(mock.getAllPresent(ImmutableList.of("key")))
-        .thenReturn(ImmutableMap.of("key", Boolean.TRUE));
-    assertEquals(
-        ImmutableMap.of("key", Boolean.TRUE), forward.getAllPresent(ImmutableList.of("key")));
+    when(mock.getAllPresent(ImmutableList.of("key"))).thenReturn(ImmutableMap.of("key", true));
+    assertThat(forward.getAllPresent(ImmutableList.of("key"))).containsExactly("key", true);
   }
 
   public void testInvalidate() {
@@ -84,17 +84,17 @@ public void testInvalidateAll() {
 
   public void testSize() {
     when(mock.size()).thenReturn(0L);
-    assertEquals(0, forward.size());
+    assertThat(forward.size()).isEqualTo(0);
   }
 
   public void testStats() {
     when(mock.stats()).thenReturn(null);
-    assertNull(forward.stats());
+    assertThat(forward.stats()).isNull();
   }
 
   public void testAsMap() {
     when(mock.asMap()).thenReturn(null);
-    assertNull(forward.asMap());
+    assertThat(forward.asMap()).isNull();
   }
 
   public void testCleanUp() {
@@ -103,6 +103,7 @@ public void testCleanUp() {
   }
 
   /** Make sure that all methods are forwarded. */
+  @Keep
   private static class OnlyGet<K, V> extends ForwardingCache<K, V> {
     @Override
     protected Cache<K, V> delegate() {
diff --git a/android/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java b/android/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java
index cdef91afe699..89029ab0ef67 100644
--- a/android/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java
+++ b/android/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java
@@ -16,12 +16,14 @@
 
 package com.google.common.cache;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.errorprone.annotations.Keep;
 import java.util.concurrent.ExecutionException;
 import junit.framework.TestCase;
 import org.jspecify.annotations.NullUnmarked;
@@ -56,23 +58,23 @@ protected LoadingCache<String, Boolean> delegate() {
   }
 
   public void testGet() throws ExecutionException {
-    when(mock.get("key")).thenReturn(Boolean.TRUE);
-    assertSame(Boolean.TRUE, forward.get("key"));
+    when(mock.get("key")).thenReturn(true);
+    assertThat(forward.get("key")).isSameInstanceAs(true);
   }
 
   public void testGetUnchecked() {
-    when(mock.getUnchecked("key")).thenReturn(Boolean.TRUE);
-    assertSame(Boolean.TRUE, forward.getUnchecked("key"));
+    when(mock.getUnchecked("key")).thenReturn(true);
+    assertThat(forward.getUnchecked("key")).isSameInstanceAs(true);
   }
 
   public void testGetAll() throws ExecutionException {
-    when(mock.getAll(ImmutableList.of("key"))).thenReturn(ImmutableMap.of("key", Boolean.TRUE));
-    assertEquals(ImmutableMap.of("key", Boolean.TRUE), forward.getAll(ImmutableList.of("key")));
+    when(mock.getAll(ImmutableList.of("key"))).thenReturn(ImmutableMap.of("key", true));
+    assertThat(forward.getAll(ImmutableList.of("key"))).containsExactly("key", true);
   }
 
   public void testApply() {
-    when(mock.apply("key")).thenReturn(Boolean.TRUE);
-    assertSame(Boolean.TRUE, forward.apply("key"));
+    when(mock.apply("key")).thenReturn(true);
+    assertThat(forward.apply("key")).isSameInstanceAs(true);
   }
 
   public void testInvalidate() {
@@ -97,12 +99,12 @@ public void testSize() {
 
   public void testStats() {
     when(mock.stats()).thenReturn(null);
-    assertNull(forward.stats());
+    assertThat(forward.stats()).isNull();
   }
 
   public void testAsMap() {
     when(mock.asMap()).thenReturn(null);
-    assertNull(forward.asMap());
+    assertThat(forward.asMap()).isNull();
   }
 
   public void testCleanUp() {
@@ -111,6 +113,7 @@ public void testCleanUp() {
   }
 
   /** Make sure that all methods are forwarded. */
+  @Keep
   private static class OnlyGet<K, V> extends ForwardingLoadingCache<K, V> {
     @Override
     protected LoadingCache<K, V> delegate() {
diff --git a/android/guava-tests/test/com/google/common/cache/LocalCacheTest.java b/android/guava-tests/test/com/google/common/cache/LocalCacheTest.java
index cf9739a7640b..017209eb4d6e 100644
--- a/android/guava-tests/test/com/google/common/cache/LocalCacheTest.java
+++ b/android/guava-tests/test/com/google/common/cache/LocalCacheTest.java
@@ -27,6 +27,7 @@
 import static com.google.common.cache.TestingWeighers.constantWeigher;
 import static com.google.common.collect.Maps.immutableEntry;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;
 import static java.lang.Math.max;
 import static java.lang.Thread.State.WAITING;
@@ -247,18 +248,18 @@ public void tearDown() throws Exception {
 
   private Throwable popLoggedThrowable() {
     List<LogRecord> logRecords = logHandler.getStoredLogRecords();
-    assertEquals(1, logRecords.size());
+    assertThat(logRecords).hasSize(1);
     LogRecord logRecord = logRecords.get(0);
     logHandler.clear();
     return logRecord.getThrown();
   }
 
   private void checkNothingLogged() {
-    assertTrue(logHandler.getStoredLogRecords().isEmpty());
+    assertThat(logHandler.getStoredLogRecords().isEmpty()).isTrue();
   }
 
   private void checkLogged(Throwable t) {
-    assertSame(t, popLoggedThrowable());
+    assertThat(popLoggedThrowable()).isSameInstanceAs(t);
   }
 
   /*
@@ -288,33 +289,33 @@ private static CacheBuilder<Object, Object> createCacheBuilder() {
   public void testDefaults() {
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());
 
-    assertSame(Strength.STRONG, map.keyStrength);
-    assertSame(Strength.STRONG, map.valueStrength);
-    assertSame(map.keyStrength.defaultEquivalence(), map.keyEquivalence);
-    assertSame(map.valueStrength.defaultEquivalence(), map.valueEquivalence);
+    assertThat(map.keyStrength).isEqualTo(Strength.STRONG);
+    assertThat(map.valueStrength).isEqualTo(Strength.STRONG);
+    assertThat(map.keyEquivalence).isSameInstanceAs(map.keyStrength.defaultEquivalence());
+    assertThat(map.valueEquivalence).isSameInstanceAs(map.valueStrength.defaultEquivalence());
 
-    assertEquals(0, map.expireAfterAccessNanos);
-    assertEquals(0, map.expireAfterWriteNanos);
-    assertEquals(0, map.refreshNanos);
-    assertEquals(CacheBuilder.UNSET_INT, map.maxWeight);
+    assertThat(map.expireAfterAccessNanos).isEqualTo(0);
+    assertThat(map.expireAfterWriteNanos).isEqualTo(0);
+    assertThat(map.refreshNanos).isEqualTo(0);
+    assertThat(map.maxWeight).isEqualTo(CacheBuilder.UNSET_INT);
 
-    assertSame(EntryFactory.STRONG, map.entryFactory);
-    assertSame(CacheBuilder.NullListener.INSTANCE, map.removalListener);
-    assertSame(DISCARDING_QUEUE, map.removalNotificationQueue);
-    assertSame(NULL_TICKER, map.ticker);
+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);
+    assertThat(map.removalListener).isSameInstanceAs(CacheBuilder.NullListener.INSTANCE);
+    assertThat(map.removalNotificationQueue).isSameInstanceAs(DISCARDING_QUEUE);
+    assertThat(map.ticker).isSameInstanceAs(NULL_TICKER);
 
-    assertEquals(4, map.concurrencyLevel);
+    assertThat(map.concurrencyLevel).isEqualTo(4);
 
     // concurrency level
     assertThat(map.segments).hasLength(4);
     // initial capacity / concurrency level
-    assertEquals(16 / map.segments.length, map.segments[0].table.length());
+    assertThat(map.segments[0].table.length()).isEqualTo(16 / map.segments.length);
 
-    assertFalse(map.evictsBySize());
-    assertFalse(map.expires());
-    assertFalse(map.expiresAfterWrite());
-    assertFalse(map.expiresAfterAccess());
-    assertFalse(map.refreshes());
+    assertThat(map.evictsBySize()).isFalse();
+    assertThat(map.expires()).isFalse();
+    assertThat(map.expiresAfterWrite()).isFalse();
+    assertThat(map.expiresAfterAccess()).isFalse();
+    assertThat(map.refreshes()).isFalse();
   }
 
   public void testSetKeyEquivalence() {
@@ -333,8 +334,8 @@ protected int doHash(Object t) {
 
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().keyEquivalence(testEquivalence));
-    assertSame(testEquivalence, map.keyEquivalence);
-    assertSame(map.valueStrength.defaultEquivalence(), map.valueEquivalence);
+    assertThat(map.keyEquivalence).isSameInstanceAs(testEquivalence);
+    assertThat(map.valueEquivalence).isSameInstanceAs(map.valueStrength.defaultEquivalence());
   }
 
   public void testSetValueEquivalence() {
@@ -353,8 +354,8 @@ protected int doHash(Object t) {
 
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().valueEquivalence(testEquivalence));
-    assertSame(testEquivalence, map.valueEquivalence);
-    assertSame(map.keyStrength.defaultEquivalence(), map.keyEquivalence);
+    assertThat(map.valueEquivalence).isSameInstanceAs(testEquivalence);
+    assertThat(map.keyEquivalence).isSameInstanceAs(map.keyStrength.defaultEquivalence());
   }
 
   public void testSetConcurrencyLevel() {
@@ -418,7 +419,7 @@ private static void checkInitialCapacity(
                 .concurrencyLevel(concurrencyLevel)
                 .initialCapacity(initialCapacity));
     for (int i = 0; i < map.segments.length; i++) {
-      assertEquals(segmentSize, map.segments[i].table.length());
+      assertThat(map.segments[i].table.length()).isEqualTo(segmentSize);
     }
   }
 
@@ -455,13 +456,15 @@ private static void checkMaximumSize(int concurrencyLevel, int initialCapacity,
                 .initialCapacity(initialCapacity)
                 .maximumSize(maxSize));
     long totalCapacity = 0;
-    assertTrue(
-        "segments=" + map.segments.length + ", maxSize=" + maxSize,
-        map.segments.length <= max(1, maxSize / 10));
+    assertWithMessage("segments=%s, maxSize=%s", map.segments.length, maxSize)
+        .that((long) map.segments.length)
+        .isAtMost(max(1, maxSize / 10));
     for (int i = 0; i < map.segments.length; i++) {
       totalCapacity += map.segments[i].maxSegmentWeight;
     }
-    assertTrue("totalCapacity=" + totalCapacity + ", maxSize=" + maxSize, totalCapacity == maxSize);
+    assertWithMessage("totalCapacity=%s, maxSize=%s", totalCapacity, maxSize)
+        .that(totalCapacity)
+        .isEqualTo(maxSize);
 
     map =
         makeLocalCache(
@@ -470,14 +473,16 @@ private static void checkMaximumSize(int concurrencyLevel, int initialCapacity,
                 .initialCapacity(initialCapacity)
                 .maximumWeight(maxSize)
                 .weigher(constantWeigher(1)));
-    assertTrue(
-        "segments=" + map.segments.length + ", maxSize=" + maxSize,
-        map.segments.length <= max(1, maxSize / 10));
+    assertWithMessage("segments=%s, maxSize=%s", map.segments.length, maxSize)
+        .that((long) map.segments.length)
+        .isAtMost(max(1, maxSize / 10));
     totalCapacity = 0;
     for (int i = 0; i < map.segments.length; i++) {
       totalCapacity += map.segments[i].maxSegmentWeight;
     }
-    assertTrue("totalCapacity=" + totalCapacity + ", maxSize=" + maxSize, totalCapacity == maxSize);
+    assertWithMessage("totalCapacity=%s, maxSize=%s", totalCapacity, maxSize)
+        .that(totalCapacity)
+        .isEqualTo(maxSize);
   }
 
   public void testSetWeigher() {
@@ -490,33 +495,33 @@ public int weigh(Object key, Object value) {
         };
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().maximumWeight(1).weigher(testWeigher));
-    assertSame(testWeigher, map.weigher);
+    assertThat(map.weigher).isSameInstanceAs(testWeigher);
   }
 
   public void testSetWeakKeys() {
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().weakKeys());
     checkStrength(map, Strength.WEAK, Strength.STRONG);
-    assertSame(EntryFactory.WEAK, map.entryFactory);
+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.WEAK);
   }
 
   public void testSetWeakValues() {
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().weakValues());
     checkStrength(map, Strength.STRONG, Strength.WEAK);
-    assertSame(EntryFactory.STRONG, map.entryFactory);
+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);
   }
 
   public void testSetSoftValues() {
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().softValues());
     checkStrength(map, Strength.STRONG, Strength.SOFT);
-    assertSame(EntryFactory.STRONG, map.entryFactory);
+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);
   }
 
   private static void checkStrength(
       LocalCache<Object, Object> map, Strength keyStrength, Strength valueStrength) {
-    assertSame(keyStrength, map.keyStrength);
-    assertSame(valueStrength, map.valueStrength);
-    assertSame(keyStrength.defaultEquivalence(), map.keyEquivalence);
-    assertSame(valueStrength.defaultEquivalence(), map.valueEquivalence);
+    assertThat(map.keyStrength).isSameInstanceAs(keyStrength);
+    assertThat(map.valueStrength).isSameInstanceAs(valueStrength);
+    assertThat(map.keyEquivalence).isSameInstanceAs(keyStrength.defaultEquivalence());
+    assertThat(map.valueEquivalence).isSameInstanceAs(valueStrength.defaultEquivalence());
   }
 
   public void testSetExpireAfterWrite() {
@@ -524,7 +529,7 @@ public void testSetExpireAfterWrite() {
     TimeUnit unit = SECONDS;
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().expireAfterWrite(duration, unit));
-    assertEquals(unit.toNanos(duration), map.expireAfterWriteNanos);
+    assertThat(map.expireAfterWriteNanos).isEqualTo(unit.toNanos(duration));
   }
 
   public void testSetExpireAfterAccess() {
@@ -532,7 +537,7 @@ public void testSetExpireAfterAccess() {
     TimeUnit unit = SECONDS;
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().expireAfterAccess(duration, unit));
-    assertEquals(unit.toNanos(duration), map.expireAfterAccessNanos);
+    assertThat(map.expireAfterAccessNanos).isEqualTo(unit.toNanos(duration));
   }
 
   public void testSetRefresh() {
@@ -540,7 +545,7 @@ public void testSetRefresh() {
     TimeUnit unit = SECONDS;
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().refreshAfterWrite(duration, unit));
-    assertEquals(unit.toNanos(duration), map.refreshNanos);
+    assertThat(map.refreshNanos).isEqualTo(unit.toNanos(duration));
   }
 
   public void testLongAsyncRefresh() throws Exception {
@@ -599,7 +604,7 @@ public void testSetRemovalListener() {
     RemovalListener<Object, Object> testListener = TestingRemovalListeners.nullRemovalListener();
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().removalListener(testListener));
-    assertSame(testListener, map.removalListener);
+    assertThat(map.removalListener).isSameInstanceAs(testListener);
   }
 
   public void testSetTicker() {
@@ -611,19 +616,26 @@ public long read() {
           }
         };
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().ticker(testTicker));
-    assertSame(testTicker, map.ticker);
+    assertThat(map.ticker).isSameInstanceAs(testTicker);
   }
 
   public void testEntryFactory() {
-    assertSame(EntryFactory.STRONG, EntryFactory.getFactory(Strength.STRONG, false, false));
-    assertSame(EntryFactory.STRONG_ACCESS, EntryFactory.getFactory(Strength.STRONG, true, false));
-    assertSame(EntryFactory.STRONG_WRITE, EntryFactory.getFactory(Strength.STRONG, false, true));
-    assertSame(
-        EntryFactory.STRONG_ACCESS_WRITE, EntryFactory.getFactory(Strength.STRONG, true, true));
-    assertSame(EntryFactory.WEAK, EntryFactory.getFactory(Strength.WEAK, false, false));
-    assertSame(EntryFactory.WEAK_ACCESS, EntryFactory.getFactory(Strength.WEAK, true, false));
-    assertSame(EntryFactory.WEAK_WRITE, EntryFactory.getFactory(Strength.WEAK, false, true));
-    assertSame(EntryFactory.WEAK_ACCESS_WRITE, EntryFactory.getFactory(Strength.WEAK, true, true));
+    assertThat(EntryFactory.getFactory(Strength.STRONG, false, false))
+        .isSameInstanceAs(EntryFactory.STRONG);
+    assertThat(EntryFactory.getFactory(Strength.STRONG, true, false))
+        .isSameInstanceAs(EntryFactory.STRONG_ACCESS);
+    assertThat(EntryFactory.getFactory(Strength.STRONG, false, true))
+        .isSameInstanceAs(EntryFactory.STRONG_WRITE);
+    assertThat(EntryFactory.getFactory(Strength.STRONG, true, true))
+        .isSameInstanceAs(EntryFactory.STRONG_ACCESS_WRITE);
+    assertThat(EntryFactory.getFactory(Strength.WEAK, false, false))
+        .isSameInstanceAs(EntryFactory.WEAK);
+    assertThat(EntryFactory.getFactory(Strength.WEAK, true, false))
+        .isSameInstanceAs(EntryFactory.WEAK_ACCESS);
+    assertThat(EntryFactory.getFactory(Strength.WEAK, false, true))
+        .isSameInstanceAs(EntryFactory.WEAK_WRITE);
+    assertThat(EntryFactory.getFactory(Strength.WEAK, true, true))
+        .isSameInstanceAs(EntryFactory.WEAK_ACCESS_WRITE);
   }
 
   // computation tests
@@ -631,13 +643,13 @@ public void testEntryFactory() {
   public void testCompute() throws ExecutionException {
     CountingLoader loader = new CountingLoader();
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());
-    assertEquals(0, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(0);
 
     Object key = new Object();
     Object value = map.get(key, loader);
-    assertEquals(1, loader.getCount());
-    assertEquals(value, map.get(key, loader));
-    assertEquals(1, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(1);
+    assertThat(map.get(key, loader)).isEqualTo(value);
+    assertThat(loader.getCount()).isEqualTo(1);
   }
 
   public void testRecordReadOnCompute() throws ExecutionException {
@@ -659,7 +671,7 @@ public void testRecordReadOnCompute() throws ExecutionException {
 
       checkEvictionQueues(map, segment, readOrder, writeOrder);
       checkExpirationTimes(map);
-      assertTrue(segment.recencyQueue.isEmpty());
+      assertThat(segment.recencyQueue.isEmpty()).isTrue();
 
       // access some of the elements
       Random random = new Random();
@@ -671,7 +683,7 @@ public void testRecordReadOnCompute() throws ExecutionException {
           map.get(entry.getKey(), loader);
           reads.add(entry);
           i.remove();
-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);
+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);
         }
       }
       int undrainedIndex = reads.size() - segment.recencyQueue.size();
@@ -686,14 +698,14 @@ public void testRecordReadOnCompute() throws ExecutionException {
   public void testComputeExistingEntry() throws ExecutionException {
     CountingLoader loader = new CountingLoader();
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());
-    assertEquals(0, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(0);
 
     Object key = new Object();
     Object value = new Object();
     map.put(key, value);
 
-    assertEquals(value, map.get(key, loader));
-    assertEquals(0, loader.getCount());
+    assertThat(map.get(key, loader)).isEqualTo(value);
+    assertThat(loader.getCount()).isEqualTo(0);
   }
 
   public void testComputePartiallyCollectedKey() throws ExecutionException {
@@ -702,7 +714,7 @@ public void testComputePartiallyCollectedKey() throws ExecutionException {
     LocalCache<Object, Object> map = makeLocalCache(builder);
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(0, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(0);
 
     Object key = new Object();
     int hash = map.hash(key);
@@ -715,14 +727,14 @@ public void testComputePartiallyCollectedKey() throws ExecutionException {
     table.set(index, entry);
     segment.count++;
 
-    assertSame(value, map.get(key, loader));
-    assertEquals(0, loader.getCount());
-    assertEquals(1, segment.count);
+    assertThat(map.get(key, loader)).isSameInstanceAs(value);
+    assertThat(loader.getCount()).isEqualTo(0);
+    assertThat(segment.count).isEqualTo(1);
 
     entry.clearKey();
-    assertNotSame(value, map.get(key, loader));
-    assertEquals(1, loader.getCount());
-    assertEquals(2, segment.count);
+    assertThat(map.get(key, loader)).isNotSameInstanceAs(value);
+    assertThat(loader.getCount()).isEqualTo(1);
+    assertThat(segment.count).isEqualTo(2);
   }
 
   public void testComputePartiallyCollectedValue() throws ExecutionException {
@@ -731,7 +743,7 @@ public void testComputePartiallyCollectedValue() throws ExecutionException {
     LocalCache<Object, Object> map = makeLocalCache(builder);
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(0, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(0);
 
     Object key = new Object();
     int hash = map.hash(key);
@@ -744,14 +756,14 @@ public void testComputePartiallyCollectedValue() throws ExecutionException {
     table.set(index, entry);
     segment.count++;
 
-    assertSame(value, map.get(key, loader));
-    assertEquals(0, loader.getCount());
-    assertEquals(1, segment.count);
+    assertThat(map.get(key, loader)).isSameInstanceAs(value);
+    assertThat(loader.getCount()).isEqualTo(0);
+    assertThat(segment.count).isEqualTo(1);
 
     valueRef.clear();
-    assertNotSame(value, map.get(key, loader));
-    assertEquals(1, loader.getCount());
-    assertEquals(1, segment.count);
+    assertThat(map.get(key, loader)).isNotSameInstanceAs(value);
+    assertThat(loader.getCount()).isEqualTo(1);
+    assertThat(segment.count).isEqualTo(1);
   }
 
   @AndroidIncompatible // Perhaps emulator clock does not update between the two get() calls?
@@ -759,15 +771,15 @@ public void testComputeExpiredEntry() throws ExecutionException {
     CacheBuilder<Object, Object> builder = createCacheBuilder().expireAfterWrite(1, NANOSECONDS);
     CountingLoader loader = new CountingLoader();
     LocalCache<Object, Object> map = makeLocalCache(builder);
-    assertEquals(0, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(0);
 
     Object key = new Object();
     Object one = map.get(key, loader);
-    assertEquals(1, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(1);
 
     Object two = map.get(key, loader);
-    assertNotSame(one, two);
-    assertEquals(2, loader.getCount());
+    assertThat(two).isNotSameInstanceAs(one);
+    assertThat(loader.getCount()).isEqualTo(2);
   }
 
   public void testValues() {
@@ -775,9 +787,9 @@ public void testValues() {
     map.put("foo", "bar");
     map.put("baz", "bar");
     map.put("quux", "quux");
-    assertFalse(map.values() instanceof Set);
-    assertTrue(map.values().removeAll(ImmutableSet.of("bar")));
-    assertEquals(1, map.size());
+    assertThat(map.values() instanceof Set).isFalse();
+    assertThat(map.values().removeAll(ImmutableSet.of("bar"))).isTrue();
+    assertThat(map).hasSize(1);
   }
 
   public void testCopyEntry_computing() {
@@ -802,7 +814,7 @@ public Object load(Object key) throws Exception {
     LocalCache<Object, Object> map = makeLocalCache(builder);
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     int hash = map.hash(one);
@@ -845,7 +857,7 @@ public void run() {
     @SuppressWarnings("unchecked")
     LoadingValueReference<Object, Object> valueReference =
         (LoadingValueReference) newEntry.getValueReference();
-    assertFalse(valueReference.futureValue.isDone());
+    assertThat(valueReference.futureValue.isDone()).isFalse();
     startSignal.countDown();
 
     try {
@@ -855,10 +867,10 @@ public void run() {
     }
 
     map.cleanUp(); // force notifications
-    assertTrue(listener.isEmpty());
-    assertTrue(map.containsKey(one));
-    assertEquals(1, map.size());
-    assertSame(computedObject, map.get(one));
+    assertThat(listener.isEmpty()).isTrue();
+    assertThat(map.containsKey(one)).isTrue();
+    assertThat(map).hasSize(1);
+    assertThat(map.get(one)).isSameInstanceAs(computedObject);
   }
 
   public void testRemovalListenerCheckedException() {
@@ -900,7 +912,7 @@ public Object load(Object key) throws Exception {
     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();
     CacheBuilder<Object, Object> builder = createCacheBuilder().removalListener(listener);
     LocalCache<Object, Object> map = makeLocalCache(builder);
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     Object two = new Object();
@@ -924,7 +936,7 @@ public void run() {
     }
 
     map.put(one, two);
-    assertSame(two, map.get(one));
+    assertThat(map.get(one)).isSameInstanceAs(two);
     startSignal.countDown();
 
     try {
@@ -935,7 +947,7 @@ public void run() {
 
     map.cleanUp(); // force notifications
     assertNotified(listener, one, computedObject, RemovalCause.REPLACED);
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
   }
 
   public void testSegmentRefresh_duplicate() throws ExecutionException {
@@ -961,7 +973,7 @@ public void testSegmentRefresh_duplicate() throws ExecutionException {
   public void testRemovalListener_explicit() {
     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     Object two = new Object();
@@ -996,13 +1008,13 @@ public void testRemovalListener_explicit() {
     i.remove();
     assertNotified(listener, five, six, RemovalCause.EXPLICIT);
 
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
   }
 
   public void testRemovalListener_replaced() {
     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     Object two = new Object();
@@ -1032,7 +1044,7 @@ public void testRemovalListener_collected() {
         makeLocalCache(
             createCacheBuilder().concurrencyLevel(1).softValues().removalListener(listener));
     Segment<Object, Object> segment = map.segments[0];
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     Object two = new Object();
@@ -1040,14 +1052,14 @@ public void testRemovalListener_collected() {
 
     map.put(one, two);
     map.put(two, three);
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     int hash = map.hash(one);
     ReferenceEntry<Object, Object> entry = segment.getEntry(one, hash);
     map.reclaimValue(entry.getValueReference());
     assertNotified(listener, one, two, RemovalCause.COLLECTED);
 
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
   }
 
   public void testRemovalListener_expired() {
@@ -1060,7 +1072,7 @@ public void testRemovalListener_expired() {
                 .expireAfterWrite(3, NANOSECONDS)
                 .ticker(ticker)
                 .removalListener(listener));
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     Object two = new Object();
@@ -1073,12 +1085,12 @@ public void testRemovalListener_expired() {
     map.put(two, three);
     ticker.advance(1);
     map.put(three, four);
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
     ticker.advance(1);
     map.put(four, five);
     assertNotified(listener, one, two, RemovalCause.EXPIRED);
 
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
   }
 
   public void testRemovalListener_size() {
@@ -1086,7 +1098,7 @@ public void testRemovalListener_size() {
     LocalCache<Object, Object> map =
         makeLocalCache(
             createCacheBuilder().concurrencyLevel(1).maximumSize(2).removalListener(listener));
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     Object two = new Object();
@@ -1095,19 +1107,19 @@ public void testRemovalListener_size() {
 
     map.put(one, two);
     map.put(two, three);
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
     map.put(three, four);
     assertNotified(listener, one, two, RemovalCause.SIZE);
 
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
   }
 
   static <K, V> void assertNotified(
       QueuingRemovalListener<K, V> listener, K key, V value, RemovalCause cause) {
     RemovalNotification<K, V> notification = listener.remove();
-    assertSame(key, notification.getKey());
-    assertSame(value, notification.getValue());
-    assertSame(cause, notification.getCause());
+    assertThat(notification.getKey()).isSameInstanceAs(key);
+    assertThat(notification.getValue()).isSameInstanceAs(value);
+    assertThat(notification.getCause()).isSameInstanceAs(cause);
   }
 
   // Segment core tests
@@ -1121,26 +1133,26 @@ public void testNewEntry() {
       int hashOne = map.hash(keyOne);
       ReferenceEntry<Object, Object> entryOne = map.newEntry(keyOne, hashOne, null);
       ValueReference<Object, Object> valueRefOne = map.newValueReference(entryOne, valueOne, 1);
-      assertSame(valueOne, valueRefOne.get());
+      assertThat(valueRefOne.get()).isSameInstanceAs(valueOne);
       entryOne.setValueReference(valueRefOne);
 
-      assertSame(keyOne, entryOne.getKey());
-      assertEquals(hashOne, entryOne.getHash());
-      assertNull(entryOne.getNext());
-      assertSame(valueRefOne, entryOne.getValueReference());
+      assertThat(entryOne.getKey()).isSameInstanceAs(keyOne);
+      assertThat(entryOne.getHash()).isEqualTo(hashOne);
+      assertThat(entryOne.getNext()).isNull();
+      assertThat(entryOne.getValueReference()).isSameInstanceAs(valueRefOne);
 
       Object keyTwo = new Object();
       Object valueTwo = new Object();
       int hashTwo = map.hash(keyTwo);
       ReferenceEntry<Object, Object> entryTwo = map.newEntry(keyTwo, hashTwo, entryOne);
       ValueReference<Object, Object> valueRefTwo = map.newValueReference(entryTwo, valueTwo, 1);
-      assertSame(valueTwo, valueRefTwo.get());
+      assertThat(valueRefTwo.get()).isSameInstanceAs(valueTwo);
       entryTwo.setValueReference(valueRefTwo);
 
-      assertSame(keyTwo, entryTwo.getKey());
-      assertEquals(hashTwo, entryTwo.getHash());
-      assertSame(entryOne, entryTwo.getNext());
-      assertSame(valueRefTwo, entryTwo.getValueReference());
+      assertThat(entryTwo.getKey()).isSameInstanceAs(keyTwo);
+      assertThat(entryTwo.getHash()).isEqualTo(hashTwo);
+      assertThat(entryTwo.getNext()).isSameInstanceAs(entryOne);
+      assertThat(entryTwo.getValueReference()).isSameInstanceAs(valueRefTwo);
     }
   }
 
@@ -1168,17 +1180,17 @@ public void testCopyEntry() {
       assertConnected(map, entryOne, entryTwo);
 
       ReferenceEntry<Object, Object> copyOne = map.copyEntry(entryOne, null);
-      assertSame(keyOne, entryOne.getKey());
-      assertEquals(hashOne, entryOne.getHash());
-      assertNull(entryOne.getNext());
-      assertSame(valueOne, copyOne.getValueReference().get());
+      assertThat(entryOne.getKey()).isSameInstanceAs(keyOne);
+      assertThat(entryOne.getHash()).isEqualTo(hashOne);
+      assertThat(entryOne.getNext()).isNull();
+      assertThat(copyOne.getValueReference().get()).isSameInstanceAs(valueOne);
       assertConnected(map, copyOne, entryTwo);
 
       ReferenceEntry<Object, Object> copyTwo = map.copyEntry(entryTwo, copyOne);
-      assertSame(keyTwo, copyTwo.getKey());
-      assertEquals(hashTwo, copyTwo.getHash());
-      assertSame(copyOne, copyTwo.getNext());
-      assertSame(valueTwo, copyTwo.getValueReference().get());
+      assertThat(copyTwo.getKey()).isSameInstanceAs(keyTwo);
+      assertThat(copyTwo.getHash()).isEqualTo(hashTwo);
+      assertThat(copyTwo.getNext()).isSameInstanceAs(copyOne);
+      assertThat(copyTwo.getValueReference().get()).isSameInstanceAs(valueTwo);
       assertConnected(map, copyOne, copyTwo);
     }
   }
@@ -1186,10 +1198,10 @@ public void testCopyEntry() {
   private static <K, V> void assertConnected(
       LocalCache<K, V> map, ReferenceEntry<K, V> one, ReferenceEntry<K, V> two) {
     if (map.usesWriteQueue()) {
-      assertSame(two, one.getNextInWriteQueue());
+      assertThat(one.getNextInWriteQueue()).isSameInstanceAs(two);
     }
     if (map.usesAccessQueue()) {
-      assertSame(two, one.getNextInAccessQueue());
+      assertThat(one.getNextInAccessQueue()).isSameInstanceAs(two);
     }
   }
 
@@ -1219,14 +1231,14 @@ public void testSegmentGetAndContains() {
     // count == 0
     table.set(index, entry);
     assertNull(segment.get(key, hash));
-    assertFalse(segment.containsKey(key, hash));
-    assertFalse(segment.containsValue(value));
+    assertThat(segment.containsKey(key, hash)).isFalse();
+    assertThat(segment.containsValue(value)).isFalse();
 
     // count == 1
     segment.count++;
-    assertSame(value, segment.get(key, hash));
-    assertTrue(segment.containsKey(key, hash));
-    assertTrue(segment.containsValue(value));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);
+    assertThat(segment.containsKey(key, hash)).isTrue();
+    assertThat(segment.containsValue(value)).isTrue();
     // don't see absent values now that count > 0
     assertNull(segment.get(new Object(), hash));
 
@@ -1237,10 +1249,10 @@ public void testSegmentGetAndContains() {
     nullEntry.setValueReference(nullValueRef);
     table.set(index, nullEntry);
     // skip the null key
-    assertSame(value, segment.get(key, hash));
-    assertTrue(segment.containsKey(key, hash));
-    assertTrue(segment.containsValue(value));
-    assertFalse(segment.containsValue(nullValue));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);
+    assertThat(segment.containsKey(key, hash)).isTrue();
+    assertThat(segment.containsValue(value)).isTrue();
+    assertThat(segment.containsValue(nullValue)).isFalse();
 
     // hash collision
     DummyEntry<Object, Object> dummy = DummyEntry.create(new Object(), hash, entry);
@@ -1248,10 +1260,10 @@ public void testSegmentGetAndContains() {
     ValueReference<Object, Object> dummyValueRef = map.newValueReference(dummy, dummyValue, 1);
     dummy.setValueReference(dummyValueRef);
     table.set(index, dummy);
-    assertSame(value, segment.get(key, hash));
-    assertTrue(segment.containsKey(key, hash));
-    assertTrue(segment.containsValue(value));
-    assertTrue(segment.containsValue(dummyValue));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);
+    assertThat(segment.containsKey(key, hash)).isTrue();
+    assertThat(segment.containsValue(value)).isTrue();
+    assertThat(segment.containsValue(dummyValue)).isTrue();
 
     // key collision
     dummy = DummyEntry.create(key, hash, entry);
@@ -1260,17 +1272,17 @@ public void testSegmentGetAndContains() {
     dummy.setValueReference(dummyValueRef);
     table.set(index, dummy);
     // returns the most recent entry
-    assertSame(dummyValue, segment.get(key, hash));
-    assertTrue(segment.containsKey(key, hash));
-    assertTrue(segment.containsValue(value));
-    assertTrue(segment.containsValue(dummyValue));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(dummyValue);
+    assertThat(segment.containsKey(key, hash)).isTrue();
+    assertThat(segment.containsValue(value)).isTrue();
+    assertThat(segment.containsValue(dummyValue)).isTrue();
 
     // expired
     dummy.setAccessTime(ticker.read() - 2);
     assertNull(segment.get(key, hash));
-    assertFalse(segment.containsKey(key, hash));
-    assertTrue(segment.containsValue(value));
-    assertFalse(segment.containsValue(dummyValue));
+    assertThat(segment.containsKey(key, hash)).isFalse();
+    assertThat(segment.containsValue(value)).isTrue();
+    assertThat(segment.containsValue(dummyValue)).isFalse();
   }
 
   public void testSegmentReplaceValue() {
@@ -1291,29 +1303,29 @@ public void testSegmentReplaceValue() {
     entry.setValueReference(oldValueRef);
 
     // no entry
-    assertFalse(segment.replace(key, hash, oldValue, newValue));
-    assertEquals(0, segment.count);
+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();
+    assertThat(segment.count).isEqualTo(0);
 
     // same value
     table.set(index, entry);
     segment.count++;
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
-    assertTrue(segment.replace(key, hash, oldValue, newValue));
-    assertEquals(1, segment.count);
-    assertSame(newValue, segment.get(key, hash));
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
+    assertThat(segment.replace(key, hash, oldValue, newValue)).isTrue();
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);
 
     // different value
-    assertFalse(segment.replace(key, hash, oldValue, newValue));
-    assertEquals(1, segment.count);
-    assertSame(newValue, segment.get(key, hash));
+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);
 
     // cleared
     entry.setValueReference(oldValueRef);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
     oldValueRef.clear();
-    assertFalse(segment.replace(key, hash, oldValue, newValue));
-    assertEquals(0, segment.count);
+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
   }
 
@@ -1336,23 +1348,23 @@ public void testSegmentReplace() {
 
     // no entry
     assertNull(segment.replace(key, hash, newValue));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
 
     // same key
     table.set(index, entry);
     segment.count++;
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
-    assertSame(oldValue, segment.replace(key, hash, newValue));
-    assertEquals(1, segment.count);
-    assertSame(newValue, segment.get(key, hash));
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
+    assertThat(segment.replace(key, hash, newValue)).isSameInstanceAs(oldValue);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);
 
     // cleared
     entry.setValueReference(oldValueRef);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
     oldValueRef.clear();
     assertNull(segment.replace(key, hash, newValue));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
   }
 
@@ -1368,24 +1380,24 @@ public void testSegmentPut() {
     Object newValue = new Object();
 
     // no entry
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.put(key, hash, oldValue, false));
-    assertEquals(1, segment.count);
+    assertThat(segment.count).isEqualTo(1);
 
     // same key
-    assertSame(oldValue, segment.put(key, hash, newValue, false));
-    assertEquals(1, segment.count);
-    assertSame(newValue, segment.get(key, hash));
+    assertThat(segment.put(key, hash, newValue, false)).isSameInstanceAs(oldValue);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);
 
     // cleared
     ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);
     DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);
     entry.setValueReference(oldValueRef);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
     oldValueRef.clear();
     assertNull(segment.put(key, hash, newValue, false));
-    assertEquals(1, segment.count);
-    assertSame(newValue, segment.get(key, hash));
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);
   }
 
   public void testSegmentPutIfAbsent() {
@@ -1400,31 +1412,31 @@ public void testSegmentPutIfAbsent() {
     Object newValue = new Object();
 
     // no entry
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.put(key, hash, oldValue, true));
-    assertEquals(1, segment.count);
+    assertThat(segment.count).isEqualTo(1);
 
     // same key
-    assertSame(oldValue, segment.put(key, hash, newValue, true));
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.put(key, hash, newValue, true)).isSameInstanceAs(oldValue);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
 
     // cleared
     ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);
     DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);
     entry.setValueReference(oldValueRef);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
     oldValueRef.clear();
     assertNull(segment.put(key, hash, newValue, true));
-    assertEquals(1, segment.count);
-    assertSame(newValue, segment.get(key, hash));
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);
   }
 
   public void testSegmentPut_expand() {
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
     Segment<Object, Object> segment = map.segments[0];
-    assertEquals(1, segment.table.length());
+    assertThat(segment.table.length()).isEqualTo(1);
 
     int count = 1024;
     for (int i = 0; i < count; i++) {
@@ -1432,7 +1444,7 @@ public void testSegmentPut_expand() {
       Object value = new Object();
       int hash = map.hash(key);
       assertNull(segment.put(key, hash, value, false));
-      assertTrue(segment.table.length() > i);
+      assertThat(segment.table.length()).isGreaterThan(i);
     }
   }
 
@@ -1454,7 +1466,7 @@ public void testSegmentPut_evict() {
         it.next();
         it.remove();
       }
-      assertEquals(originalMap, map);
+      assertThat(map).isEqualTo(originalMap);
     }
   }
 
@@ -1475,34 +1487,34 @@ public void testSegmentStoreComputedValue() {
 
     // absent
     Object value = new Object();
-    assertTrue(listener.isEmpty());
-    assertEquals(0, segment.count);
+    assertThat(listener.isEmpty()).isTrue();
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value));
-    assertSame(value, segment.get(key, hash));
-    assertEquals(1, segment.count);
-    assertTrue(listener.isEmpty());
+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value)).isTrue();
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(listener.isEmpty()).isTrue();
 
     // clobbered
     Object value2 = new Object();
-    assertFalse(segment.storeLoadedValue(key, hash, valueRef, value2));
-    assertEquals(1, segment.count);
-    assertSame(value, segment.get(key, hash));
+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value2)).isFalse();
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);
     RemovalNotification<Object, Object> notification = listener.remove();
-    assertEquals(immutableEntry(key, value2), notification);
-    assertEquals(RemovalCause.REPLACED, notification.getCause());
-    assertTrue(listener.isEmpty());
+    assertThat(notification).isEqualTo(immutableEntry(key, value2));
+    assertThat(notification.getCause()).isEqualTo(RemovalCause.REPLACED);
+    assertThat(listener.isEmpty()).isTrue();
 
     // inactive
     Object value3 = new Object();
     map.clear();
     listener.clear();
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     table.set(index, entry);
-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value3));
-    assertSame(value3, segment.get(key, hash));
-    assertEquals(1, segment.count);
-    assertTrue(listener.isEmpty());
+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value3)).isTrue();
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(listener.isEmpty()).isTrue();
 
     // replaced
     Object value4 = new Object();
@@ -1510,29 +1522,29 @@ public void testSegmentStoreComputedValue() {
     valueRef = new LoadingValueReference<>(value3Ref);
     entry.setValueReference(valueRef);
     table.set(index, entry);
-    assertSame(value3, segment.get(key, hash));
-    assertEquals(1, segment.count);
-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));
-    assertSame(value4, segment.get(key, hash));
-    assertEquals(1, segment.count);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value4)).isTrue();
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value4);
+    assertThat(segment.count).isEqualTo(1);
     notification = listener.remove();
-    assertEquals(immutableEntry(key, value3), notification);
-    assertEquals(RemovalCause.REPLACED, notification.getCause());
-    assertTrue(listener.isEmpty());
+    assertThat(notification).isEqualTo(immutableEntry(key, value3));
+    assertThat(notification.getCause()).isEqualTo(RemovalCause.REPLACED);
+    assertThat(listener.isEmpty()).isTrue();
 
     // collected
     entry.setValueReference(valueRef);
     table.set(index, entry);
-    assertSame(value3, segment.get(key, hash));
-    assertEquals(1, segment.count);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);
+    assertThat(segment.count).isEqualTo(1);
     value3Ref.clear();
-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));
-    assertSame(value4, segment.get(key, hash));
-    assertEquals(1, segment.count);
+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value4)).isTrue();
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value4);
+    assertThat(segment.count).isEqualTo(1);
     notification = listener.remove();
-    assertEquals(immutableEntry(key, null), notification);
-    assertEquals(RemovalCause.COLLECTED, notification.getCause());
-    assertTrue(listener.isEmpty());
+    assertThat(notification).isEqualTo(immutableEntry(key, null));
+    assertThat(notification.getCause()).isEqualTo(RemovalCause.COLLECTED);
+    assertThat(listener.isEmpty()).isTrue();
   }
 
   public void testSegmentRemove() {
@@ -1550,27 +1562,27 @@ public void testSegmentRemove() {
     entry.setValueReference(oldValueRef);
 
     // no entry
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.remove(key, hash));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
 
     // same key
     table.set(index, entry);
     segment.count++;
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
-    assertSame(oldValue, segment.remove(key, hash));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
+    assertThat(segment.remove(key, hash)).isSameInstanceAs(oldValue);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
 
     // cleared
     table.set(index, entry);
     segment.count++;
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
     oldValueRef.clear();
     assertNull(segment.remove(key, hash));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
   }
 
@@ -1590,33 +1602,33 @@ public void testSegmentRemoveValue() {
     entry.setValueReference(oldValueRef);
 
     // no entry
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.remove(key, hash));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
 
     // same value
     table.set(index, entry);
     segment.count++;
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
-    assertTrue(segment.remove(key, hash, oldValue));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
+    assertThat(segment.remove(key, hash, oldValue)).isTrue();
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
 
     // different value
     table.set(index, entry);
     segment.count++;
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
-    assertFalse(segment.remove(key, hash, newValue));
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
+    assertThat(segment.remove(key, hash, newValue)).isFalse();
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
 
     // cleared
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
     oldValueRef.clear();
-    assertFalse(segment.remove(key, hash, oldValue));
-    assertEquals(0, segment.count);
+    assertThat(segment.remove(key, hash, oldValue)).isFalse();
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
   }
 
@@ -1624,7 +1636,7 @@ public void testExpand() {
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
     Segment<Object, Object> segment = map.segments[0];
-    assertEquals(1, segment.table.length());
+    assertThat(segment.table.length()).isEqualTo(1);
 
     // manually add elements to avoid expansion
     int originalCount = 1024;
@@ -1641,17 +1653,17 @@ public void testExpand() {
     segment.table.set(0, entry);
     segment.count = originalCount;
     ImmutableMap<Object, Object> originalMap = ImmutableMap.copyOf(map);
-    assertEquals(originalCount, originalMap.size());
-    assertEquals(originalMap, map);
+    assertThat(originalMap).hasSize(originalCount);
+    assertThat(map).isEqualTo(originalMap);
 
     for (int i = 1; i <= originalCount * 2; i *= 2) {
       if (i > 1) {
         segment.expand();
       }
-      assertEquals(i, segment.table.length());
-      assertEquals(originalCount, countLiveEntries(map, 0));
-      assertEquals(originalCount, segment.count);
-      assertEquals(originalMap, map);
+      assertThat(segment.table.length()).isEqualTo(i);
+      assertThat(countLiveEntries(map, 0)).isEqualTo(originalCount);
+      assertThat(segment.count).isEqualTo(originalCount);
+      assertThat(map).isEqualTo(originalMap);
     }
   }
 
@@ -1660,7 +1672,7 @@ public void testGetCausesExpansion() throws ExecutionException {
       LocalCache<Object, Object> map =
           makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
       Segment<Object, Object> segment = map.segments[0];
-      assertEquals(1, segment.table.length());
+      assertThat(segment.table.length()).isEqualTo(1);
 
       for (int i = 0; i < count; i++) {
         Object key = new Object();
@@ -1675,10 +1687,10 @@ public Object load(Object key) {
               }
             });
       }
-      assertEquals(count, segment.count);
-      assertTrue(count <= segment.threshold);
-      assertTrue(count <= (segment.table.length() * 3 / 4));
-      assertTrue(count > (segment.table.length() * 3 / 8));
+      assertThat(segment.count).isEqualTo(count);
+      assertThat(count).isAtMost(segment.threshold);
+      assertThat(count).isAtMost((segment.table.length() * 3 / 4));
+      assertThat(count).isGreaterThan(segment.table.length() * 3 / 8);
     }
   }
 
@@ -1686,8 +1698,8 @@ public void testGetOrDefault() {
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
     map.put(1, 1);
-    assertEquals(1, map.getOrDefault(1, 2));
-    assertEquals(2, map.getOrDefault(2, 2));
+    assertThat(map.getOrDefault(1, 2)).isEqualTo(1);
+    assertThat(map.getOrDefault(2, 2)).isEqualTo(2);
   }
 
   public void testPutCausesExpansion() {
@@ -1695,17 +1707,17 @@ public void testPutCausesExpansion() {
       LocalCache<Object, Object> map =
           makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
       Segment<Object, Object> segment = map.segments[0];
-      assertEquals(1, segment.table.length());
+      assertThat(segment.table.length()).isEqualTo(1);
 
       for (int i = 0; i < count; i++) {
         Object key = new Object();
         Object value = new Object();
         segment.put(key, key.hashCode(), value, true);
       }
-      assertEquals(count, segment.count);
-      assertTrue(count <= segment.threshold);
-      assertTrue(count <= (segment.table.length() * 3 / 4));
-      assertTrue(count > (segment.table.length() * 3 / 8));
+      assertThat(segment.count).isEqualTo(count);
+      assertThat(count).isAtMost(segment.threshold);
+      assertThat(count).isAtMost((segment.table.length() * 3 / 4));
+      assertThat(count).isGreaterThan(segment.table.length() * 3 / 8);
     }
   }
 
@@ -1721,7 +1733,7 @@ public void testReclaimKey() {
                 .removalListener(listener));
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(1, table.length());
+    assertThat(table.length()).isEqualTo(1);
 
     // create 3 objects and chain them together
     Object keyOne = new Object();
@@ -1739,28 +1751,28 @@ public void testReclaimKey() {
         createDummyEntry(keyThree, hashThree, valueThree, entryTwo);
 
     // absent
-    assertEquals(0, listener.getCount());
-    assertFalse(segment.reclaimKey(entryOne, hashOne));
-    assertEquals(0, listener.getCount());
+    assertThat(listener.getCount()).isEqualTo(0);
+    assertThat(segment.reclaimKey(entryOne, hashOne)).isFalse();
+    assertThat(listener.getCount()).isEqualTo(0);
     table.set(0, entryOne);
-    assertFalse(segment.reclaimKey(entryTwo, hashTwo));
-    assertEquals(0, listener.getCount());
+    assertThat(segment.reclaimKey(entryTwo, hashTwo)).isFalse();
+    assertThat(listener.getCount()).isEqualTo(0);
     table.set(0, entryTwo);
-    assertFalse(segment.reclaimKey(entryThree, hashThree));
-    assertEquals(0, listener.getCount());
+    assertThat(segment.reclaimKey(entryThree, hashThree)).isFalse();
+    assertThat(listener.getCount()).isEqualTo(0);
 
     // present
     table.set(0, entryOne);
     segment.count = 1;
-    assertTrue(segment.reclaimKey(entryOne, hashOne));
-    assertEquals(1, listener.getCount());
-    assertSame(keyOne, listener.getLastEvictedKey());
-    assertSame(valueOne, listener.getLastEvictedValue());
-    assertTrue(map.removalNotificationQueue.isEmpty());
-    assertFalse(segment.accessQueue.contains(entryOne));
-    assertFalse(segment.writeQueue.contains(entryOne));
-    assertEquals(0, segment.count);
-    assertNull(table.get(0));
+    assertThat(segment.reclaimKey(entryOne, hashOne)).isTrue();
+    assertThat(listener.getCount()).isEqualTo(1);
+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(keyOne);
+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(valueOne);
+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();
+    assertThat(segment.accessQueue.contains(entryOne)).isFalse();
+    assertThat(segment.writeQueue.contains(entryOne)).isFalse();
+    assertThat(segment.count).isEqualTo(0);
+    assertThat(table.get(0)).isNull();
   }
 
   public void testRemoveEntryFromChain() {
@@ -1786,32 +1798,32 @@ public void testRemoveEntryFromChain() {
     assertNull(segment.removeEntryFromChain(entryOne, entryOne));
 
     // head
-    assertSame(entryOne, segment.removeEntryFromChain(entryTwo, entryTwo));
+    assertThat(segment.removeEntryFromChain(entryTwo, entryTwo)).isSameInstanceAs(entryOne);
 
     // middle
     ReferenceEntry<Object, Object> newFirst = segment.removeEntryFromChain(entryThree, entryTwo);
-    assertSame(keyThree, newFirst.getKey());
-    assertSame(valueThree, newFirst.getValueReference().get());
-    assertEquals(hashThree, newFirst.getHash());
-    assertSame(entryOne, newFirst.getNext());
+    assertThat(newFirst.getKey()).isSameInstanceAs(keyThree);
+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueThree);
+    assertThat(newFirst.getHash()).isEqualTo(hashThree);
+    assertThat(newFirst.getNext()).isSameInstanceAs(entryOne);
 
     // tail (remaining entries are copied in reverse order)
     newFirst = segment.removeEntryFromChain(entryThree, entryOne);
-    assertSame(keyTwo, newFirst.getKey());
-    assertSame(valueTwo, newFirst.getValueReference().get());
-    assertEquals(hashTwo, newFirst.getHash());
+    assertThat(newFirst.getKey()).isSameInstanceAs(keyTwo);
+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueTwo);
+    assertThat(newFirst.getHash()).isEqualTo(hashTwo);
     newFirst = newFirst.getNext();
-    assertSame(keyThree, newFirst.getKey());
-    assertSame(valueThree, newFirst.getValueReference().get());
-    assertEquals(hashThree, newFirst.getHash());
-    assertNull(newFirst.getNext());
+    assertThat(newFirst.getKey()).isSameInstanceAs(keyThree);
+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueThree);
+    assertThat(newFirst.getHash()).isEqualTo(hashThree);
+    assertThat(newFirst.getNext()).isNull();
   }
 
   public void testExpand_cleanup() {
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
     Segment<Object, Object> segment = map.segments[0];
-    assertEquals(1, segment.table.length());
+    assertThat(segment.table.length()).isEqualTo(1);
 
     // manually add elements to avoid expansion
     // 1/3 null keys, 1/3 null values
@@ -1832,22 +1844,22 @@ public void testExpand_cleanup() {
     segment.table.set(0, entry);
     segment.count = originalCount;
     int liveCount = originalCount / 3;
-    assertEquals(1, segment.table.length());
-    assertEquals(liveCount, countLiveEntries(map, 0));
+    assertThat(segment.table.length()).isEqualTo(1);
+    assertThat(countLiveEntries(map, 0)).isEqualTo(liveCount);
     ImmutableMap<Object, Object> originalMap = ImmutableMap.copyOf(map);
-    assertEquals(liveCount, originalMap.size());
+    assertThat(originalMap).hasSize(liveCount);
     // can't compare map contents until cleanup occurs
 
     for (int i = 1; i <= originalCount * 2; i *= 2) {
       if (i > 1) {
         segment.expand();
       }
-      assertEquals(i, segment.table.length());
-      assertEquals(liveCount, countLiveEntries(map, 0));
+      assertThat(segment.table.length()).isEqualTo(i);
+      assertThat(countLiveEntries(map, 0)).isEqualTo(liveCount);
       // expansion cleanup is sloppy, with a goal of avoiding unnecessary copies
-      assertTrue(segment.count >= liveCount);
-      assertTrue(segment.count <= originalCount);
-      assertEquals(originalMap, ImmutableMap.copyOf(map));
+      assertThat(segment.count).isAtLeast(liveCount);
+      assertThat(segment.count).isAtMost(originalCount);
+      assertThat(ImmutableMap.copyOf(map)).isEqualTo(originalMap);
     }
   }
 
@@ -1876,7 +1888,7 @@ public void testClear() {
                 .expireAfterWrite(99999, SECONDS));
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(1, table.length());
+    assertThat(table.length()).isEqualTo(1);
 
     Object key = new Object();
     Object value = new Object();
@@ -1888,17 +1900,17 @@ public void testClear() {
     segment.count = 1;
     segment.totalWeight = 1;
 
-    assertSame(entry, table.get(0));
-    assertSame(entry, segment.accessQueue.peek());
-    assertSame(entry, segment.writeQueue.peek());
+    assertThat(table.get(0)).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);
 
     segment.clear();
-    assertNull(table.get(0));
-    assertTrue(segment.accessQueue.isEmpty());
-    assertTrue(segment.writeQueue.isEmpty());
-    assertEquals(0, segment.readCount.get());
-    assertEquals(0, segment.count);
-    assertEquals(0, segment.totalWeight);
+    assertThat(table.get(0)).isNull();
+    assertThat(segment.accessQueue.isEmpty()).isTrue();
+    assertThat(segment.writeQueue.isEmpty()).isTrue();
+    assertThat(segment.readCount.get()).isEqualTo(0);
+    assertThat(segment.count).isEqualTo(0);
+    assertThat(segment.totalWeight).isEqualTo(0);
   }
 
   public void testClear_notification() {
@@ -1913,7 +1925,7 @@ public void testClear_notification() {
                 .removalListener(listener));
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(1, table.length());
+    assertThat(table.length()).isEqualTo(1);
 
     Object key = new Object();
     Object value = new Object();
@@ -1925,17 +1937,17 @@ public void testClear_notification() {
     segment.count = 1;
     segment.totalWeight = 1;
 
-    assertSame(entry, table.get(0));
-    assertSame(entry, segment.accessQueue.peek());
-    assertSame(entry, segment.writeQueue.peek());
+    assertThat(table.get(0)).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);
 
     segment.clear();
-    assertNull(table.get(0));
-    assertTrue(segment.accessQueue.isEmpty());
-    assertTrue(segment.writeQueue.isEmpty());
-    assertEquals(0, segment.readCount.get());
-    assertEquals(0, segment.count);
-    assertEquals(0, segment.totalWeight);
+    assertThat(table.get(0)).isNull();
+    assertThat(segment.accessQueue.isEmpty()).isTrue();
+    assertThat(segment.writeQueue.isEmpty()).isTrue();
+    assertThat(segment.readCount.get()).isEqualTo(0);
+    assertThat(segment.count).isEqualTo(0);
+    assertThat(segment.totalWeight).isEqualTo(0);
     assertNotified(listener, key, value, RemovalCause.EXPLICIT);
   }
 
@@ -1950,7 +1962,7 @@ public void testRemoveEntry() {
                 .removalListener(countingRemovalListener()));
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(1, table.length());
+    assertThat(table.length()).isEqualTo(1);
 
     Object key = new Object();
     Object value = new Object();
@@ -1958,19 +1970,19 @@ public void testRemoveEntry() {
     DummyEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);
 
     // remove absent
-    assertFalse(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));
+    assertThat(segment.removeEntry(entry, hash, RemovalCause.COLLECTED)).isFalse();
 
     // remove live
     segment.recordWrite(entry, 1, map.ticker.read());
     table.set(0, entry);
     segment.count = 1;
-    assertTrue(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));
+    assertThat(segment.removeEntry(entry, hash, RemovalCause.COLLECTED)).isTrue();
     assertNotificationEnqueued(map, key, value);
-    assertTrue(map.removalNotificationQueue.isEmpty());
-    assertFalse(segment.accessQueue.contains(entry));
-    assertFalse(segment.writeQueue.contains(entry));
-    assertEquals(0, segment.count);
-    assertNull(table.get(0));
+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();
+    assertThat(segment.accessQueue.contains(entry)).isFalse();
+    assertThat(segment.writeQueue.contains(entry)).isFalse();
+    assertThat(segment.count).isEqualTo(0);
+    assertThat(table.get(0)).isNull();
   }
 
   public void testReclaimValue() {
@@ -1985,7 +1997,7 @@ public void testReclaimValue() {
                 .removalListener(listener));
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(1, table.length());
+    assertThat(table.length()).isEqualTo(1);
 
     Object key = new Object();
     Object value = new Object();
@@ -1995,32 +2007,32 @@ public void testReclaimValue() {
     entry.setValueReference(valueRef);
 
     // reclaim absent
-    assertFalse(segment.reclaimValue(key, hash, valueRef));
+    assertThat(segment.reclaimValue(key, hash, valueRef)).isFalse();
 
     // reclaim live
     segment.recordWrite(entry, 1, map.ticker.read());
     table.set(0, entry);
     segment.count = 1;
-    assertTrue(segment.reclaimValue(key, hash, valueRef));
-    assertEquals(1, listener.getCount());
-    assertSame(key, listener.getLastEvictedKey());
-    assertSame(value, listener.getLastEvictedValue());
-    assertTrue(map.removalNotificationQueue.isEmpty());
-    assertFalse(segment.accessQueue.contains(entry));
-    assertFalse(segment.writeQueue.contains(entry));
-    assertEquals(0, segment.count);
-    assertNull(table.get(0));
+    assertThat(segment.reclaimValue(key, hash, valueRef)).isTrue();
+    assertThat(listener.getCount()).isEqualTo(1);
+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(key);
+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(value);
+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();
+    assertThat(segment.accessQueue.contains(entry)).isFalse();
+    assertThat(segment.writeQueue.contains(entry)).isFalse();
+    assertThat(segment.count).isEqualTo(0);
+    assertThat(table.get(0)).isNull();
 
     // reclaim wrong value reference
     table.set(0, entry);
     DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);
     entry.setValueReference(otherValueRef);
-    assertFalse(segment.reclaimValue(key, hash, valueRef));
-    assertEquals(1, listener.getCount());
-    assertTrue(segment.reclaimValue(key, hash, otherValueRef));
-    assertEquals(2, listener.getCount());
-    assertSame(key, listener.getLastEvictedKey());
-    assertSame(value, listener.getLastEvictedValue());
+    assertThat(segment.reclaimValue(key, hash, valueRef)).isFalse();
+    assertThat(listener.getCount()).isEqualTo(1);
+    assertThat(segment.reclaimValue(key, hash, otherValueRef)).isTrue();
+    assertThat(listener.getCount()).isEqualTo(2);
+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(key);
+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(value);
   }
 
   public void testRemoveComputingValue() {
@@ -2034,7 +2046,7 @@ public void testRemoveComputingValue() {
                 .removalListener(countingRemovalListener()));
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(1, table.length());
+    assertThat(table.length()).isEqualTo(1);
 
     Object key = new Object();
     int hash = map.hash(key);
@@ -2043,16 +2055,16 @@ public void testRemoveComputingValue() {
     entry.setValueReference(valueRef);
 
     // absent
-    assertFalse(segment.removeLoadingValue(key, hash, valueRef));
+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isFalse();
 
     // live
     table.set(0, entry);
     // don't increment count; this is used during computation
-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));
+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();
     // no notification sent with removeLoadingValue
-    assertTrue(map.removalNotificationQueue.isEmpty());
-    assertEquals(0, segment.count);
-    assertNull(table.get(0));
+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();
+    assertThat(segment.count).isEqualTo(0);
+    assertThat(table.get(0)).isNull();
 
     // active
     Object value = new Object();
@@ -2061,23 +2073,23 @@ public void testRemoveComputingValue() {
     entry.setValueReference(valueRef);
     table.set(0, entry);
     segment.count = 1;
-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));
-    assertSame(entry, table.get(0));
-    assertSame(value, segment.get(key, hash));
+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();
+    assertThat(table.get(0)).isSameInstanceAs(entry);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);
 
     // wrong value reference
     table.set(0, entry);
     DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);
     entry.setValueReference(otherValueRef);
-    assertFalse(segment.removeLoadingValue(key, hash, valueRef));
+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isFalse();
     entry.setValueReference(valueRef);
-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));
+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();
   }
 
   private static <K, V> void assertNotificationEnqueued(LocalCache<K, V> map, K key, V value) {
     RemovalNotification<K, V> notification = map.removalNotificationQueue.poll();
-    assertSame(key, notification.getKey());
-    assertSame(value, notification.getValue());
+    assertThat(notification.getKey()).isSameInstanceAs(key);
+    assertThat(notification.getValue()).isSameInstanceAs(value);
   }
 
   // Segment eviction tests
@@ -2094,15 +2106,15 @@ public void testDrainRecencyQueueOnWrite() {
         Object valueTwo = new Object();
 
         map.put(keyOne, valueOne);
-        assertTrue(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isTrue();
 
         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {
           map.get(keyOne);
         }
-        assertFalse(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isFalse();
 
         map.put(keyTwo, valueTwo);
-        assertTrue(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isTrue();
       }
     }
   }
@@ -2119,16 +2131,16 @@ public void testDrainRecencyQueueOnRead() {
         // repeated get of the same key
 
         map.put(keyOne, valueOne);
-        assertTrue(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isTrue();
 
         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {
           map.get(keyOne);
         }
-        assertFalse(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isFalse();
 
         for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {
           map.get(keyOne);
-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);
+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);
         }
 
         // get over many different keys
@@ -2136,16 +2148,16 @@ public void testDrainRecencyQueueOnRead() {
         for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {
           map.put(new Object(), new Object());
         }
-        assertTrue(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isTrue();
 
         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {
           map.get(keyOne);
         }
-        assertFalse(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isFalse();
 
         for (Object key : map.keySet()) {
           map.get(key);
-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);
+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);
         }
       }
     }
@@ -2211,7 +2223,7 @@ public void testRecordReadOnGet() {
 
       checkEvictionQueues(map, segment, readOrder, writeOrder);
       checkExpirationTimes(map);
-      assertTrue(segment.recencyQueue.isEmpty());
+      assertThat(segment.recencyQueue.isEmpty()).isTrue();
 
       // access some of the elements
       Random random = new Random();
@@ -2223,7 +2235,7 @@ public void testRecordReadOnGet() {
           map.get(entry.getKey());
           reads.add(entry);
           i.remove();
-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);
+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);
         }
       }
       int undrainedIndex = reads.size() - segment.recencyQueue.size();
@@ -2297,12 +2309,13 @@ static <K, V> void checkEvictionQueues(
   private static <K, V> void assertSameEntries(
       List<ReferenceEntry<K, V>> expectedEntries, List<ReferenceEntry<K, V>> actualEntries) {
     int size = expectedEntries.size();
-    assertEquals(size, actualEntries.size());
+    assertThat(actualEntries).hasSize(size);
     for (int i = 0; i < size; i++) {
       ReferenceEntry<K, V> expectedEntry = expectedEntries.get(i);
       ReferenceEntry<K, V> actualEntry = actualEntries.get(i);
-      assertSame(expectedEntry.getKey(), actualEntry.getKey());
-      assertSame(expectedEntry.getValueReference().get(), actualEntry.getValueReference().get());
+      assertThat(actualEntry.getKey()).isSameInstanceAs(expectedEntry.getKey());
+      assertThat(actualEntry.getValueReference().get())
+          .isSameInstanceAs(expectedEntry.getValueReference().get());
     }
   }
 
@@ -2316,10 +2329,10 @@ static <K, V> void checkExpirationTimes(LocalCache<K, V> map) {
       long lastWriteTime = 0;
       for (ReferenceEntry<K, V> e : segment.recencyQueue) {
         long accessTime = e.getAccessTime();
-        assertTrue(accessTime >= lastAccessTime);
+        assertThat(accessTime).isAtLeast(lastAccessTime);
         lastAccessTime = accessTime;
         long writeTime = e.getWriteTime();
-        assertTrue(writeTime >= lastWriteTime);
+        assertThat(writeTime).isAtLeast(lastWriteTime);
         lastWriteTime = writeTime;
       }
 
@@ -2327,12 +2340,12 @@ static <K, V> void checkExpirationTimes(LocalCache<K, V> map) {
       lastWriteTime = 0;
       for (ReferenceEntry<K, V> e : segment.accessQueue) {
         long accessTime = e.getAccessTime();
-        assertTrue(accessTime >= lastAccessTime);
+        assertThat(accessTime).isAtLeast(lastAccessTime);
         lastAccessTime = accessTime;
       }
       for (ReferenceEntry<K, V> e : segment.writeQueue) {
         long writeTime = e.getWriteTime();
-        assertTrue(writeTime >= lastWriteTime);
+        assertThat(writeTime).isAtLeast(lastWriteTime);
         lastWriteTime = writeTime;
       }
     }
@@ -2352,31 +2365,31 @@ public void testExpireAfterWrite() {
     Object value = new Object();
     map.put(key, value);
     ReferenceEntry<Object, Object> entry = map.getEntry(key);
-    assertTrue(map.isLive(entry, ticker.read()));
+    assertThat(map.isLive(entry, ticker.read())).isTrue();
 
     segment.writeQueue.add(entry);
-    assertSame(value, map.get(key));
-    assertSame(entry, segment.writeQueue.peek());
-    assertEquals(1, segment.writeQueue.size());
+    assertThat(map.get(key)).isSameInstanceAs(value);
+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.writeQueue).hasSize(1);
 
     segment.recordRead(entry, ticker.read());
     segment.expireEntries(ticker.read());
-    assertSame(value, map.get(key));
-    assertSame(entry, segment.writeQueue.peek());
-    assertEquals(1, segment.writeQueue.size());
+    assertThat(map.get(key)).isSameInstanceAs(value);
+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.writeQueue).hasSize(1);
 
     ticker.advance(1);
     segment.recordRead(entry, ticker.read());
     segment.expireEntries(ticker.read());
-    assertSame(value, map.get(key));
-    assertSame(entry, segment.writeQueue.peek());
-    assertEquals(1, segment.writeQueue.size());
+    assertThat(map.get(key)).isSameInstanceAs(value);
+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.writeQueue).hasSize(1);
 
     ticker.advance(1);
-    assertNull(map.get(key));
+    assertThat(map.get(key)).isNull();
     segment.expireEntries(ticker.read());
-    assertNull(map.get(key));
-    assertTrue(segment.writeQueue.isEmpty());
+    assertThat(map.get(key)).isNull();
+    assertThat(segment.writeQueue.isEmpty()).isTrue();
   }
 
   public void testExpireAfterAccess() {
@@ -2393,46 +2406,46 @@ public void testExpireAfterAccess() {
     Object value = new Object();
     map.put(key, value);
     ReferenceEntry<Object, Object> entry = map.getEntry(key);
-    assertTrue(map.isLive(entry, ticker.read()));
+    assertThat(map.isLive(entry, ticker.read())).isTrue();
 
     segment.accessQueue.add(entry);
-    assertSame(value, map.get(key));
-    assertSame(entry, segment.accessQueue.peek());
-    assertEquals(1, segment.accessQueue.size());
+    assertThat(map.get(key)).isSameInstanceAs(value);
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue).hasSize(1);
 
     segment.recordRead(entry, ticker.read());
     segment.expireEntries(ticker.read());
-    assertTrue(map.containsKey(key));
-    assertSame(entry, segment.accessQueue.peek());
-    assertEquals(1, segment.accessQueue.size());
+    assertThat(map.containsKey(key)).isTrue();
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue).hasSize(1);
 
     ticker.advance(1);
     segment.recordRead(entry, ticker.read());
     segment.expireEntries(ticker.read());
-    assertTrue(map.containsKey(key));
-    assertSame(entry, segment.accessQueue.peek());
-    assertEquals(1, segment.accessQueue.size());
+    assertThat(map.containsKey(key)).isTrue();
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue).hasSize(1);
 
     ticker.advance(1);
     segment.recordRead(entry, ticker.read());
     segment.expireEntries(ticker.read());
-    assertTrue(map.containsKey(key));
-    assertSame(entry, segment.accessQueue.peek());
-    assertEquals(1, segment.accessQueue.size());
+    assertThat(map.containsKey(key)).isTrue();
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue).hasSize(1);
 
     ticker.advance(1);
     segment.expireEntries(ticker.read());
-    assertTrue(map.containsKey(key));
-    assertSame(entry, segment.accessQueue.peek());
-    assertEquals(1, segment.accessQueue.size());
+    assertThat(map.containsKey(key)).isTrue();
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue).hasSize(1);
 
     ticker.advance(1);
-    assertFalse(map.containsKey(key));
-    assertNull(map.get(key));
+    assertThat(map.containsKey(key)).isFalse();
+    assertThat(map.get(key)).isNull();
     segment.expireEntries(ticker.read());
-    assertFalse(map.containsKey(key));
-    assertNull(map.get(key));
-    assertTrue(segment.accessQueue.isEmpty());
+    assertThat(map.containsKey(key)).isFalse();
+    assertThat(map.get(key)).isNull();
+    assertThat(segment.accessQueue.isEmpty()).isTrue();
   }
 
   public void testEvictEntries() {
@@ -2461,8 +2474,8 @@ public void testEvictEntries() {
     }
     segment.count = originalCount;
     segment.totalWeight = originalCount;
-    assertEquals(originalCount, map.size());
-    assertEquals(originalMap, map);
+    assertThat(map).hasSize(originalCount);
+    assertThat(map).isEqualTo(originalMap);
 
     Iterator<Object> it = originalMap.keySet().iterator();
     for (int i = 0; i < originalCount - maxSize; i++) {
@@ -2470,8 +2483,8 @@ public void testEvictEntries() {
       it.remove();
     }
     segment.evictEntries(entry);
-    assertEquals(maxSize, map.size());
-    assertEquals(originalMap, map);
+    assertThat(map).hasSize(maxSize);
+    assertThat(map).isEqualTo(originalMap);
   }
 
   // reference queues
@@ -2496,11 +2509,11 @@ public void testDrainKeyReferenceQueueOnWrite() {
         reference.enqueue();
 
         map.put(keyTwo, valueTwo);
-        assertFalse(map.containsKey(keyOne));
-        assertFalse(map.containsValue(valueOne));
-        assertNull(map.get(keyOne));
-        assertEquals(1, map.size());
-        assertNull(segment.keyReferenceQueue.poll());
+        assertThat(map.containsKey(keyOne)).isFalse();
+        assertThat(map.containsValue(valueOne)).isFalse();
+        assertThat(map.get(keyOne)).isNull();
+        assertThat(map).hasSize(1);
+        assertThat(segment.keyReferenceQueue.poll()).isNull();
       }
     }
   }
@@ -2526,11 +2539,11 @@ public void testDrainValueReferenceQueueOnWrite() {
         reference.enqueue();
 
         map.put(keyTwo, valueTwo);
-        assertFalse(map.containsKey(keyOne));
-        assertFalse(map.containsValue(valueOne));
-        assertNull(map.get(keyOne));
-        assertEquals(1, map.size());
-        assertNull(segment.valueReferenceQueue.poll());
+        assertThat(map.containsKey(keyOne)).isFalse();
+        assertThat(map.containsValue(valueOne)).isFalse();
+        assertThat(map.get(keyOne)).isNull();
+        assertThat(map).hasSize(1);
+        assertThat(segment.valueReferenceQueue.poll()).isNull();
       }
     }
   }
@@ -2556,11 +2569,11 @@ public void testDrainKeyReferenceQueueOnRead() {
         for (int i = 0; i < SMALL_MAX_SIZE; i++) {
           map.get(keyTwo);
         }
-        assertFalse(map.containsKey(keyOne));
-        assertFalse(map.containsValue(valueOne));
-        assertNull(map.get(keyOne));
-        assertEquals(0, map.size());
-        assertNull(segment.keyReferenceQueue.poll());
+        assertThat(map.containsKey(keyOne)).isFalse();
+        assertThat(map.containsValue(valueOne)).isFalse();
+        assertThat(map.get(keyOne)).isNull();
+        assertThat(map).isEmpty();
+        assertThat(segment.keyReferenceQueue.poll()).isNull();
       }
     }
   }
@@ -2587,11 +2600,11 @@ public void testDrainValueReferenceQueueOnRead() {
         for (int i = 0; i < SMALL_MAX_SIZE; i++) {
           map.get(keyTwo);
         }
-        assertFalse(map.containsKey(keyOne));
-        assertFalse(map.containsValue(valueOne));
-        assertNull(map.get(keyOne));
-        assertEquals(0, map.size());
-        assertNull(segment.valueReferenceQueue.poll());
+        assertThat(map.containsKey(keyOne)).isFalse();
+        assertThat(map.containsValue(valueOne)).isFalse();
+        assertThat(map.get(keyOne)).isNull();
+        assertThat(map).isEmpty();
+        assertThat(segment.valueReferenceQueue.poll()).isNull();
       }
     }
   }
@@ -2624,42 +2637,45 @@ public void testSerializationProxyLoading() {
                 .build(loader);
     // add a non-serializable entry
     one.getUnchecked(new Object());
-    assertEquals(1, one.size());
-    assertFalse(one.asMap().isEmpty());
+    assertThat(one.size()).isEqualTo(1);
+    assertThat(one.asMap().isEmpty()).isFalse();
     LocalLoadingCache<Object, Object> two = SerializableTester.reserialize(one);
-    assertEquals(0, two.size());
-    assertTrue(two.asMap().isEmpty());
+    assertThat(two.size()).isEqualTo(0);
+    assertThat(two.asMap().isEmpty()).isTrue();
 
     LocalCache<Object, Object> localCacheOne = one.localCache;
     LocalCache<Object, Object> localCacheTwo = two.localCache;
 
-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);
-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);
-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);
-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);
-    assertEquals(localCacheOne.maxWeight, localCacheTwo.maxWeight);
-    assertEquals(localCacheOne.weigher, localCacheTwo.weigher);
-    assertEquals(localCacheOne.expireAfterAccessNanos, localCacheTwo.expireAfterAccessNanos);
-    assertEquals(localCacheOne.expireAfterWriteNanos, localCacheTwo.expireAfterWriteNanos);
-    assertEquals(localCacheOne.refreshNanos, localCacheTwo.refreshNanos);
-    assertEquals(localCacheOne.removalListener, localCacheTwo.removalListener);
-    assertEquals(localCacheOne.ticker, localCacheTwo.ticker);
+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);
+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);
+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);
+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);
+    assertThat(localCacheTwo.maxWeight).isEqualTo(localCacheOne.maxWeight);
+    assertThat(localCacheTwo.weigher).isEqualTo(localCacheOne.weigher);
+    assertThat(localCacheTwo.expireAfterAccessNanos)
+        .isEqualTo(localCacheOne.expireAfterAccessNanos);
+    assertThat(localCacheTwo.expireAfterWriteNanos).isEqualTo(localCacheOne.expireAfterWriteNanos);
+    assertThat(localCacheTwo.refreshNanos).isEqualTo(localCacheOne.refreshNanos);
+    assertThat(localCacheTwo.removalListener).isEqualTo(localCacheOne.removalListener);
+    assertThat(localCacheTwo.ticker).isEqualTo(localCacheOne.ticker);
 
     // serialize the reconstituted version to be sure we haven't lost the ability to reserialize
     LocalLoadingCache<Object, Object> three = SerializableTester.reserialize(two);
     LocalCache<Object, Object> localCacheThree = three.localCache;
 
-    assertEquals(localCacheTwo.defaultLoader, localCacheThree.defaultLoader);
-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);
-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);
-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);
-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);
-    assertEquals(localCacheTwo.maxWeight, localCacheThree.maxWeight);
-    assertEquals(localCacheTwo.weigher, localCacheThree.weigher);
-    assertEquals(localCacheTwo.expireAfterAccessNanos, localCacheThree.expireAfterAccessNanos);
-    assertEquals(localCacheTwo.expireAfterWriteNanos, localCacheThree.expireAfterWriteNanos);
-    assertEquals(localCacheTwo.removalListener, localCacheThree.removalListener);
-    assertEquals(localCacheTwo.ticker, localCacheThree.ticker);
+    assertThat(localCacheThree.defaultLoader).isEqualTo(localCacheTwo.defaultLoader);
+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);
+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);
+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);
+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);
+    assertThat(localCacheThree.maxWeight).isEqualTo(localCacheTwo.maxWeight);
+    assertThat(localCacheThree.weigher).isEqualTo(localCacheTwo.weigher);
+    assertThat(localCacheThree.expireAfterAccessNanos)
+        .isEqualTo(localCacheTwo.expireAfterAccessNanos);
+    assertThat(localCacheThree.expireAfterWriteNanos)
+        .isEqualTo(localCacheTwo.expireAfterWriteNanos);
+    assertThat(localCacheThree.removalListener).isEqualTo(localCacheTwo.removalListener);
+    assertThat(localCacheThree.ticker).isEqualTo(localCacheTwo.ticker);
   }
 
   public void testSerializationProxyManual() {
@@ -2681,40 +2697,43 @@ public void testSerializationProxyManual() {
                 .build();
     // add a non-serializable entry
     one.put(new Object(), new Object());
-    assertEquals(1, one.size());
-    assertFalse(one.asMap().isEmpty());
+    assertThat(one.size()).isEqualTo(1);
+    assertThat(one.asMap().isEmpty()).isFalse();
     LocalManualCache<Object, Object> two = SerializableTester.reserialize(one);
-    assertEquals(0, two.size());
-    assertTrue(two.asMap().isEmpty());
+    assertThat(two.size()).isEqualTo(0);
+    assertThat(two.asMap().isEmpty()).isTrue();
 
     LocalCache<Object, Object> localCacheOne = one.localCache;
     LocalCache<Object, Object> localCacheTwo = two.localCache;
 
-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);
-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);
-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);
-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);
-    assertEquals(localCacheOne.maxWeight, localCacheTwo.maxWeight);
-    assertEquals(localCacheOne.weigher, localCacheTwo.weigher);
-    assertEquals(localCacheOne.expireAfterAccessNanos, localCacheTwo.expireAfterAccessNanos);
-    assertEquals(localCacheOne.expireAfterWriteNanos, localCacheTwo.expireAfterWriteNanos);
-    assertEquals(localCacheOne.removalListener, localCacheTwo.removalListener);
-    assertEquals(localCacheOne.ticker, localCacheTwo.ticker);
+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);
+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);
+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);
+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);
+    assertThat(localCacheTwo.maxWeight).isEqualTo(localCacheOne.maxWeight);
+    assertThat(localCacheTwo.weigher).isEqualTo(localCacheOne.weigher);
+    assertThat(localCacheTwo.expireAfterAccessNanos)
+        .isEqualTo(localCacheOne.expireAfterAccessNanos);
+    assertThat(localCacheTwo.expireAfterWriteNanos).isEqualTo(localCacheOne.expireAfterWriteNanos);
+    assertThat(localCacheTwo.removalListener).isEqualTo(localCacheOne.removalListener);
+    assertThat(localCacheTwo.ticker).isEqualTo(localCacheOne.ticker);
 
     // serialize the reconstituted version to be sure we haven't lost the ability to reserialize
     LocalManualCache<Object, Object> three = SerializableTester.reserialize(two);
     LocalCache<Object, Object> localCacheThree = three.localCache;
 
-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);
-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);
-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);
-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);
-    assertEquals(localCacheTwo.maxWeight, localCacheThree.maxWeight);
-    assertEquals(localCacheTwo.weigher, localCacheThree.weigher);
-    assertEquals(localCacheTwo.expireAfterAccessNanos, localCacheThree.expireAfterAccessNanos);
-    assertEquals(localCacheTwo.expireAfterWriteNanos, localCacheThree.expireAfterWriteNanos);
-    assertEquals(localCacheTwo.removalListener, localCacheThree.removalListener);
-    assertEquals(localCacheTwo.ticker, localCacheThree.ticker);
+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);
+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);
+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);
+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);
+    assertThat(localCacheThree.maxWeight).isEqualTo(localCacheTwo.maxWeight);
+    assertThat(localCacheThree.weigher).isEqualTo(localCacheTwo.weigher);
+    assertThat(localCacheThree.expireAfterAccessNanos)
+        .isEqualTo(localCacheTwo.expireAfterAccessNanos);
+    assertThat(localCacheThree.expireAfterWriteNanos)
+        .isEqualTo(localCacheTwo.expireAfterWriteNanos);
+    assertThat(localCacheThree.removalListener).isEqualTo(localCacheTwo.removalListener);
+    assertThat(localCacheThree.ticker).isEqualTo(localCacheTwo.ticker);
   }
 
   public void testLoadDifferentKeyInLoader() throws ExecutionException, InterruptedException {
@@ -2722,16 +2741,16 @@ public void testLoadDifferentKeyInLoader() throws ExecutionException, Interrupte
     String key1 = "key1";
     String key2 = "key2";
 
-    assertEquals(
-        key2,
-        cache.get(
-            key1,
-            new CacheLoader<String, String>() {
-              @Override
-              public String load(String key) throws Exception {
-                return cache.get(key2, identityLoader()); // loads a different key, should work
-              }
-            }));
+    assertThat(
+            cache.get(
+                key1,
+                new CacheLoader<String, String>() {
+                  @Override
+                  public String load(String key) throws Exception {
+                    return cache.get(key2, identityLoader()); // loads a different key, should work
+                  }
+                }))
+        .isEqualTo(key2);
   }
 
   public void testRecursiveLoad() throws InterruptedException {
diff --git a/android/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java b/android/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java
index 1f927b731894..20dce52c426b 100644
--- a/android/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java
+++ b/android/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java
@@ -62,7 +62,7 @@ public Object load(Object from) {
           }
         };
     LocalLoadingCache<Object, Object> cache = makeCache(createCacheBuilder(), loader);
-    assertSame(loader, cache.localCache.defaultLoader);
+    assertThat(cache.localCache.defaultLoader).isSameInstanceAs(loader);
   }
 
   // null parameters test
@@ -78,82 +78,82 @@ public void testNullParameters() throws Exception {
   public void testStats() {
     CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1).maximumSize(2);
     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     Object one = new Object();
     cache.getUnchecked(one);
     CacheStats stats = cache.stats();
-    assertEquals(1, stats.requestCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
     assertThat(stats.hitRate()).isEqualTo(0.0);
-    assertEquals(1, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(1);
     assertThat(stats.missRate()).isEqualTo(1.0);
-    assertEquals(1, stats.loadCount());
+    assertThat(stats.loadCount()).isEqualTo(1);
     long totalLoadTime = stats.totalLoadTime();
-    assertTrue(totalLoadTime >= 0);
-    assertTrue(stats.averageLoadPenalty() >= 0.0);
-    assertEquals(0, stats.evictionCount());
+    assertThat(totalLoadTime).isAtLeast(0);
+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);
+    assertThat(stats.evictionCount()).isEqualTo(0);
 
     cache.getUnchecked(one);
     stats = cache.stats();
-    assertEquals(2, stats.requestCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(1);
     assertThat(stats.hitRate()).isEqualTo(1.0 / 2);
-    assertEquals(1, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(1);
     assertThat(stats.missRate()).isEqualTo(1.0 / 2);
-    assertEquals(1, stats.loadCount());
-    assertEquals(0, stats.evictionCount());
+    assertThat(stats.loadCount()).isEqualTo(1);
+    assertThat(stats.evictionCount()).isEqualTo(0);
 
     Object two = new Object();
     cache.getUnchecked(two);
     stats = cache.stats();
-    assertEquals(3, stats.requestCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(3);
+    assertThat(stats.hitCount()).isEqualTo(1);
     assertThat(stats.hitRate()).isEqualTo(1.0 / 3);
-    assertEquals(2, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(2);
     assertThat(stats.missRate()).isEqualTo(2.0 / 3);
-    assertEquals(2, stats.loadCount());
-    assertTrue(stats.totalLoadTime() >= totalLoadTime);
+    assertThat(stats.loadCount()).isEqualTo(2);
+    assertThat(stats.totalLoadTime()).isAtLeast(totalLoadTime);
     totalLoadTime = stats.totalLoadTime();
-    assertTrue(stats.averageLoadPenalty() >= 0.0);
-    assertEquals(0, stats.evictionCount());
+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);
+    assertThat(stats.evictionCount()).isEqualTo(0);
 
     Object three = new Object();
     cache.getUnchecked(three);
     stats = cache.stats();
-    assertEquals(4, stats.requestCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(4);
+    assertThat(stats.hitCount()).isEqualTo(1);
     assertThat(stats.hitRate()).isEqualTo(1.0 / 4);
-    assertEquals(3, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(3);
     assertThat(stats.missRate()).isEqualTo(3.0 / 4);
-    assertEquals(3, stats.loadCount());
-    assertTrue(stats.totalLoadTime() >= totalLoadTime);
-    assertTrue(stats.averageLoadPenalty() >= 0.0);
-    assertEquals(1, stats.evictionCount());
+    assertThat(stats.loadCount()).isEqualTo(3);
+    assertThat(stats.totalLoadTime()).isAtLeast(totalLoadTime);
+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);
+    assertThat(stats.evictionCount()).isEqualTo(1);
   }
 
   public void testStatsNoops() {
     CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1);
     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
     ConcurrentMap<Object, Object> map = cache.localCache; // modifiable map view
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     Object one = new Object();
     assertNull(map.put(one, one));
-    assertSame(one, map.get(one));
-    assertTrue(map.containsKey(one));
-    assertTrue(map.containsValue(one));
+    assertThat(map.get(one)).isSameInstanceAs(one);
+    assertThat(map.containsKey(one)).isTrue();
+    assertThat(map.containsValue(one)).isTrue();
     Object two = new Object();
-    assertSame(one, map.replace(one, two));
-    assertTrue(map.containsKey(one));
-    assertFalse(map.containsValue(one));
+    assertThat(map.replace(one, two)).isSameInstanceAs(one);
+    assertThat(map.containsKey(one)).isTrue();
+    assertThat(map.containsValue(one)).isFalse();
     Object three = new Object();
-    assertTrue(map.replace(one, two, three));
-    assertTrue(map.remove(one, three));
-    assertFalse(map.containsKey(one));
-    assertFalse(map.containsValue(one));
+    assertThat(map.replace(one, two, three)).isTrue();
+    assertThat(map.remove(one, three)).isTrue();
+    assertThat(map.containsKey(one)).isFalse();
+    assertThat(map.containsValue(one)).isFalse();
     assertNull(map.putIfAbsent(two, three));
-    assertSame(three, map.remove(two));
+    assertThat(map.remove(two)).isSameInstanceAs(three);
     assertNull(map.put(three, one));
     assertNull(map.put(one, two));
 
@@ -171,56 +171,56 @@ public void testStatsNoops() {
 
     map.clear();
 
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
   }
 
   public void testNoStats() {
     CacheBuilder<Object, Object> builder =
         CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(2);
     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     Object one = new Object();
     cache.getUnchecked(one);
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     cache.getUnchecked(one);
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     Object two = new Object();
     cache.getUnchecked(two);
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     Object three = new Object();
     cache.getUnchecked(three);
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
   }
 
   public void testRecordStats() {
     CacheBuilder<Object, Object> builder =
         createCacheBuilder().recordStats().concurrencyLevel(1).maximumSize(2);
     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
-    assertEquals(0, cache.stats().hitCount());
-    assertEquals(0, cache.stats().missCount());
+    assertThat(cache.stats().hitCount()).isEqualTo(0);
+    assertThat(cache.stats().missCount()).isEqualTo(0);
 
     Object one = new Object();
     cache.getUnchecked(one);
-    assertEquals(0, cache.stats().hitCount());
-    assertEquals(1, cache.stats().missCount());
+    assertThat(cache.stats().hitCount()).isEqualTo(0);
+    assertThat(cache.stats().missCount()).isEqualTo(1);
 
     cache.getUnchecked(one);
-    assertEquals(1, cache.stats().hitCount());
-    assertEquals(1, cache.stats().missCount());
+    assertThat(cache.stats().hitCount()).isEqualTo(1);
+    assertThat(cache.stats().missCount()).isEqualTo(1);
 
     Object two = new Object();
     cache.getUnchecked(two);
-    assertEquals(1, cache.stats().hitCount());
-    assertEquals(2, cache.stats().missCount());
+    assertThat(cache.stats().hitCount()).isEqualTo(1);
+    assertThat(cache.stats().missCount()).isEqualTo(2);
 
     Object three = new Object();
     cache.getUnchecked(three);
-    assertEquals(1, cache.stats().hitCount());
-    assertEquals(3, cache.stats().missCount());
+    assertThat(cache.stats().hitCount()).isEqualTo(1);
+    assertThat(cache.stats().missCount()).isEqualTo(3);
   }
 
   // asMap tests
@@ -228,7 +228,7 @@ public void testRecordStats() {
   public void testAsMap() {
     CacheBuilder<Object, Object> builder = createCacheBuilder();
     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     Object one = new Object();
     Object two = new Object();
@@ -236,47 +236,47 @@ public void testAsMap() {
 
     ConcurrentMap<Object, Object> map = cache.asMap();
     assertNull(map.put(one, two));
-    assertSame(two, map.get(one));
+    assertThat(map.get(one)).isSameInstanceAs(two);
     map.putAll(ImmutableMap.of(two, three));
-    assertSame(three, map.get(two));
-    assertSame(two, map.putIfAbsent(one, three));
-    assertSame(two, map.get(one));
+    assertThat(map.get(two)).isSameInstanceAs(three);
+    assertThat(map.putIfAbsent(one, three)).isSameInstanceAs(two);
+    assertThat(map.get(one)).isSameInstanceAs(two);
     assertNull(map.putIfAbsent(three, one));
-    assertSame(one, map.get(three));
-    assertSame(two, map.replace(one, three));
-    assertSame(three, map.get(one));
-    assertFalse(map.replace(one, two, three));
-    assertSame(three, map.get(one));
-    assertTrue(map.replace(one, three, two));
-    assertSame(two, map.get(one));
-    assertEquals(3, map.size());
+    assertThat(map.get(three)).isSameInstanceAs(one);
+    assertThat(map.replace(one, three)).isSameInstanceAs(two);
+    assertThat(map.get(one)).isSameInstanceAs(three);
+    assertThat(map.replace(one, two, three)).isFalse();
+    assertThat(map.get(one)).isSameInstanceAs(three);
+    assertThat(map.replace(one, three, two)).isTrue();
+    assertThat(map.get(one)).isSameInstanceAs(two);
+    assertThat(map).hasSize(3);
 
     map.clear();
-    assertTrue(map.isEmpty());
-    assertEquals(0, map.size());
+    assertThat(map.isEmpty()).isTrue();
+    assertThat(map).isEmpty();
 
     cache.getUnchecked(one);
-    assertEquals(1, map.size());
-    assertSame(one, map.get(one));
-    assertTrue(map.containsKey(one));
-    assertTrue(map.containsValue(one));
-    assertSame(one, map.remove(one));
-    assertEquals(0, map.size());
+    assertThat(map).hasSize(1);
+    assertThat(map.get(one)).isSameInstanceAs(one);
+    assertThat(map.containsKey(one)).isTrue();
+    assertThat(map.containsValue(one)).isTrue();
+    assertThat(map.remove(one)).isSameInstanceAs(one);
+    assertThat(map).isEmpty();
 
     cache.getUnchecked(one);
-    assertEquals(1, map.size());
-    assertFalse(map.remove(one, two));
-    assertTrue(map.remove(one, one));
-    assertEquals(0, map.size());
+    assertThat(map).hasSize(1);
+    assertThat(map.remove(one, two)).isFalse();
+    assertThat(map.remove(one, one)).isTrue();
+    assertThat(map).isEmpty();
 
     cache.getUnchecked(one);
     Map<Object, Object> newMap = ImmutableMap.of(one, one);
-    assertEquals(newMap, map);
-    assertEquals(newMap.entrySet(), map.entrySet());
-    assertEquals(newMap.keySet(), map.keySet());
+    assertThat(map).isEqualTo(newMap);
+    assertThat(map.entrySet()).isEqualTo(newMap.entrySet());
+    assertThat(map.keySet()).isEqualTo(newMap.keySet());
     Set<Object> expectedValues = ImmutableSet.of(one);
     Set<Object> actualValues = ImmutableSet.copyOf(map.values());
-    assertEquals(expectedValues, actualValues);
+    assertThat(actualValues).isEqualTo(expectedValues);
   }
 
   /** Lookups on the map view shouldn't impact the recency queue. */
@@ -288,12 +288,12 @@ public void testAsMapRecency() {
     ConcurrentMap<Object, Object> map = cache.asMap();
 
     Object one = new Object();
-    assertSame(one, cache.getUnchecked(one));
-    assertTrue(segment.recencyQueue.isEmpty());
-    assertSame(one, map.get(one));
-    assertSame(one, segment.recencyQueue.peek().getKey());
-    assertSame(one, cache.getUnchecked(one));
-    assertFalse(segment.recencyQueue.isEmpty());
+    assertThat(cache.getUnchecked(one)).isSameInstanceAs(one);
+    assertThat(segment.recencyQueue.isEmpty()).isTrue();
+    assertThat(map.get(one)).isSameInstanceAs(one);
+    assertThat(segment.recencyQueue.peek().getKey()).isSameInstanceAs(one);
+    assertThat(cache.getUnchecked(one)).isSameInstanceAs(one);
+    assertThat(segment.recencyQueue.isEmpty()).isFalse();
   }
 
   public void testRecursiveComputation() throws InterruptedException {
@@ -313,7 +313,7 @@ public String load(Integer key) {
     LoadingCache<Integer, String> recursiveCache =
         CacheBuilder.newBuilder().weakKeys().weakValues().build(recursiveLoader);
     cacheRef.set(recursiveCache);
-    assertEquals("3, 2, 1, 0", recursiveCache.getUnchecked(3));
+    assertThat(recursiveCache.getUnchecked(3)).isEqualTo("3, 2, 1, 0");
 
     recursiveLoader =
         new CacheLoader<Integer, String>() {
diff --git a/android/guava-tests/test/com/google/common/cache/NullCacheTest.java b/android/guava-tests/test/com/google/common/cache/NullCacheTest.java
index ae49a5366394..5def1a0ac218 100644
--- a/android/guava-tests/test/com/google/common/cache/NullCacheTest.java
+++ b/android/guava-tests/test/com/google/common/cache/NullCacheTest.java
@@ -51,12 +51,12 @@ public void testGet() {
             .build(constantLoader(computed));
 
     Object key = new Object();
-    assertSame(computed, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);
     RemovalNotification<Object, Object> notification = listener.remove();
-    assertSame(key, notification.getKey());
-    assertSame(computed, notification.getValue());
-    assertSame(RemovalCause.SIZE, notification.getCause());
-    assertTrue(listener.isEmpty());
+    assertThat(notification.getKey()).isSameInstanceAs(key);
+    assertThat(notification.getValue()).isSameInstanceAs(computed);
+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);
+    assertThat(listener.isEmpty()).isTrue();
     checkEmpty(cache);
   }
 
@@ -69,12 +69,12 @@ public void testGet_expireAfterWrite() {
             .build(constantLoader(computed));
 
     Object key = new Object();
-    assertSame(computed, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);
     RemovalNotification<Object, Object> notification = listener.remove();
-    assertSame(key, notification.getKey());
-    assertSame(computed, notification.getValue());
-    assertSame(RemovalCause.SIZE, notification.getCause());
-    assertTrue(listener.isEmpty());
+    assertThat(notification.getKey()).isSameInstanceAs(key);
+    assertThat(notification.getValue()).isSameInstanceAs(computed);
+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);
+    assertThat(listener.isEmpty()).isTrue();
     checkEmpty(cache);
   }
 
@@ -87,12 +87,12 @@ public void testGet_expireAfterAccess() {
             .build(constantLoader(computed));
 
     Object key = new Object();
-    assertSame(computed, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);
     RemovalNotification<Object, Object> notification = listener.remove();
-    assertSame(key, notification.getKey());
-    assertSame(computed, notification.getValue());
-    assertSame(RemovalCause.SIZE, notification.getCause());
-    assertTrue(listener.isEmpty());
+    assertThat(notification.getKey()).isSameInstanceAs(key);
+    assertThat(notification.getValue()).isSameInstanceAs(computed);
+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);
+    assertThat(listener.isEmpty()).isTrue();
     checkEmpty(cache);
   }
 
@@ -105,7 +105,7 @@ public void testGet_computeNull() {
 
     assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(new Object()));
 
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
     checkEmpty(cache);
   }
 
@@ -120,7 +120,7 @@ public void testGet_runtimeException() {
     UncheckedExecutionException uee =
         assertThrows(UncheckedExecutionException.class, () -> map.getUnchecked(new Object()));
     assertThat(uee).hasCauseThat().isSameInstanceAs(e);
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
     checkEmpty(map);
   }
 }
diff --git a/android/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java b/android/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java
index ea2066d1b09a..0c529574f1d1 100644
--- a/android/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java
+++ b/android/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java
@@ -59,7 +59,7 @@ public void testSize_populated() {
     for (LoadingCache<Object, Object> cache : caches()) {
       // don't let the entries get GCed
       List<Entry<Object, Object>> unused = warmUp(cache);
-      assertEquals(WARMUP_SIZE, cache.size());
+      assertThat(cache.size()).isEqualTo(WARMUP_SIZE);
       assertMapSize(cache.asMap(), WARMUP_SIZE);
       checkValidState(cache);
     }
@@ -71,12 +71,12 @@ public void testContainsKey_found() {
       List<Entry<Object, Object>> warmed = warmUp(cache);
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);
-        assertTrue(cache.asMap().containsKey(entry.getKey()));
-        assertTrue(cache.asMap().containsValue(entry.getValue()));
+        assertThat(cache.asMap().containsKey(entry.getKey())).isTrue();
+        assertThat(cache.asMap().containsValue(entry.getValue())).isTrue();
         // this getUnchecked() call shouldn't be a cache miss; verified below
-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));
+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());
       }
-      assertEquals(WARMUP_SIZE, cache.stats().missCount());
+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);
       checkValidState(cache);
     }
   }
@@ -88,18 +88,18 @@ public void testPut_populated() {
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);
         Object newValue = new Object();
-        assertSame(entry.getValue(), cache.asMap().put(entry.getKey(), newValue));
+        assertThat(cache.asMap().put(entry.getKey(), newValue)).isSameInstanceAs(entry.getValue());
         // don't let the new entry get GCed
         warmed.add(entryOf(entry.getKey(), newValue));
         Object newKey = new Object();
-        assertNull(cache.asMap().put(newKey, entry.getValue()));
+        assertThat(cache.asMap().put(newKey, entry.getValue())).isNull();
         // this getUnchecked() call shouldn't be a cache miss; verified below
-        assertEquals(newValue, cache.getUnchecked(entry.getKey()));
-        assertEquals(entry.getValue(), cache.getUnchecked(newKey));
+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(newValue);
+        assertThat(cache.getUnchecked(newKey)).isEqualTo(entry.getValue());
         // don't let the new entry get GCed
         warmed.add(entryOf(newKey, entry.getValue()));
       }
-      assertEquals(WARMUP_SIZE, cache.stats().missCount());
+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);
       checkValidState(cache);
     }
   }
@@ -111,16 +111,17 @@ public void testPutIfAbsent_populated() {
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);
         Object newValue = new Object();
-        assertSame(entry.getValue(), cache.asMap().putIfAbsent(entry.getKey(), newValue));
+        assertThat(cache.asMap().putIfAbsent(entry.getKey(), newValue))
+            .isSameInstanceAs(entry.getValue());
         Object newKey = new Object();
-        assertNull(cache.asMap().putIfAbsent(newKey, entry.getValue()));
+        assertThat(cache.asMap().putIfAbsent(newKey, entry.getValue())).isNull();
         // this getUnchecked() call shouldn't be a cache miss; verified below
-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));
-        assertEquals(entry.getValue(), cache.getUnchecked(newKey));
+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());
+        assertThat(cache.getUnchecked(newKey)).isEqualTo(entry.getValue());
         // don't let the new entry get GCed
         warmed.add(entryOf(newKey, entry.getValue()));
       }
-      assertEquals(WARMUP_SIZE, cache.stats().missCount());
+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);
       checkValidState(cache);
     }
   }
@@ -133,8 +134,8 @@ public void testPutAll_populated() {
       Object newValue = new Object();
       cache.asMap().putAll(ImmutableMap.of(newKey, newValue));
       // this getUnchecked() call shouldn't be a cache miss; verified below
-      assertEquals(newValue, cache.getUnchecked(newKey));
-      assertEquals(WARMUP_SIZE, cache.stats().missCount());
+      assertThat(cache.getUnchecked(newKey)).isEqualTo(newValue);
+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);
       checkValidState(cache);
     }
   }
@@ -146,16 +147,17 @@ public void testReplace_populated() {
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);
         Object newValue = new Object();
-        assertSame(entry.getValue(), cache.asMap().replace(entry.getKey(), newValue));
-        assertTrue(cache.asMap().replace(entry.getKey(), newValue, entry.getValue()));
+        assertThat(cache.asMap().replace(entry.getKey(), newValue))
+            .isSameInstanceAs(entry.getValue());
+        assertThat(cache.asMap().replace(entry.getKey(), newValue, entry.getValue())).isTrue();
         Object newKey = new Object();
-        assertNull(cache.asMap().replace(newKey, entry.getValue()));
-        assertFalse(cache.asMap().replace(newKey, entry.getValue(), newValue));
+        assertThat(cache.asMap().replace(newKey, entry.getValue())).isNull();
+        assertThat(cache.asMap().replace(newKey, entry.getValue(), newValue)).isFalse();
         // this getUnchecked() call shouldn't be a cache miss; verified below
-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));
-        assertFalse(cache.asMap().containsKey(newKey));
+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());
+        assertThat(cache.asMap().containsKey(newKey)).isFalse();
       }
-      assertEquals(WARMUP_SIZE, cache.stats().missCount());
+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);
       checkValidState(cache);
     }
   }
@@ -167,9 +169,9 @@ public void testRemove_byKey() {
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);
         Object key = entry.getKey();
-        assertEquals(entry.getValue(), cache.asMap().remove(key));
-        assertNull(cache.asMap().remove(key));
-        assertFalse(cache.asMap().containsKey(key));
+        assertThat(cache.asMap().remove(key)).isEqualTo(entry.getValue());
+        assertThat(cache.asMap().remove(key)).isNull();
+        assertThat(cache.asMap().containsKey(key)).isFalse();
       }
       checkEmpty(cache);
     }
@@ -182,10 +184,10 @@ public void testRemove_byKeyAndValue() {
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Object key = warmed.get(i - WARMUP_MIN).getKey();
         Object value = warmed.get(i - WARMUP_MIN).getValue();
-        assertFalse(cache.asMap().remove(key, -1));
-        assertTrue(cache.asMap().remove(key, value));
-        assertFalse(cache.asMap().remove(key, -1));
-        assertFalse(cache.asMap().containsKey(key));
+        assertThat(cache.asMap().remove(key, -1)).isFalse();
+        assertThat(cache.asMap().remove(key, value)).isTrue();
+        assertThat(cache.asMap().remove(key, -1)).isFalse();
+        assertThat(cache.asMap().containsKey(key)).isFalse();
       }
       checkEmpty(cache);
     }
@@ -206,13 +208,13 @@ public void testKeySet_populated() {
           .addEqualityGroup(cache.asMap().keySet(), keys)
           .addEqualityGroup(ImmutableSet.of())
           .testEquals();
-      assertEquals(WARMUP_SIZE, keys.size());
+      assertThat(keys).hasSize(WARMUP_SIZE);
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Object key = warmed.get(i - WARMUP_MIN).getKey();
-        assertTrue(keys.contains(key));
-        assertTrue(keys.remove(key));
-        assertFalse(keys.remove(key));
-        assertFalse(keys.contains(key));
+        assertThat(keys.contains(key)).isTrue();
+        assertThat(keys.remove(key)).isTrue();
+        assertThat(keys.remove(key)).isFalse();
+        assertThat(keys.contains(key)).isFalse();
       }
       checkEmpty(keys);
       checkEmpty(cache);
@@ -229,13 +231,13 @@ public void testValues_populated() {
       assertThat(values.toArray()).asList().containsExactlyElementsIn(expected);
       assertThat(values.toArray(new Object[0])).asList().containsExactlyElementsIn(expected);
 
-      assertEquals(WARMUP_SIZE, values.size());
+      assertThat(values).hasSize(WARMUP_SIZE);
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Object value = warmed.get(i - WARMUP_MIN).getValue();
-        assertTrue(values.contains(value));
-        assertTrue(values.remove(value));
-        assertFalse(values.remove(value));
-        assertFalse(values.contains(value));
+        assertThat(values.contains(value)).isTrue();
+        assertThat(values.remove(value)).isTrue();
+        assertThat(values.remove(value)).isFalse();
+        assertThat(values.contains(value)).isFalse();
       }
       checkEmpty(values);
       checkEmpty(cache);
@@ -257,13 +259,13 @@ public void testEntrySet_populated() {
           .addEqualityGroup(cache.asMap().entrySet(), entries)
           .addEqualityGroup(ImmutableSet.of())
           .testEquals();
-      assertEquals(WARMUP_SIZE, entries.size());
+      assertThat(entries).hasSize(WARMUP_SIZE);
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Entry<Object, Object> newEntry = warmed.get(i - WARMUP_MIN);
-        assertTrue(entries.contains(newEntry));
-        assertTrue(entries.remove(newEntry));
-        assertFalse(entries.remove(newEntry));
-        assertFalse(entries.contains(newEntry));
+        assertThat(entries.contains(newEntry)).isTrue();
+        assertThat(entries.remove(newEntry)).isTrue();
+        assertThat(entries.remove(newEntry)).isFalse();
+        assertThat(entries.contains(newEntry)).isFalse();
       }
       checkEmpty(entries);
       checkEmpty(cache);
@@ -276,11 +278,11 @@ public void testWriteThroughEntry() {
       Entry<Object, Object> entry = Iterables.getOnlyElement(cache.asMap().entrySet());
 
       cache.invalidate(1);
-      assertEquals(0, cache.size());
+      assertThat(cache.size()).isEqualTo(0);
 
       entry.setValue(3);
-      assertEquals(1, cache.size());
-      assertEquals(3, cache.getIfPresent(1));
+      assertThat(cache.size()).isEqualTo(1);
+      assertThat(cache.getIfPresent(1)).isEqualTo(3);
       checkValidState(cache);
 
       assertThrows(NullPointerException.class, () -> entry.setValue(null));
@@ -356,25 +358,26 @@ private Entry<Object, Object> entryOf(Object key, Object value) {
   }
 
   private void assertMapSize(Map<?, ?> map, int size) {
-    assertEquals(size, map.size());
+    assertThat(map).hasSize(size);
     if (size > 0) {
-      assertFalse(map.isEmpty());
+      assertThat(map.isEmpty()).isFalse();
     } else {
-      assertTrue(map.isEmpty());
+      assertThat(map.isEmpty()).isTrue();
     }
     assertCollectionSize(map.keySet(), size);
     assertCollectionSize(map.entrySet(), size);
     assertCollectionSize(map.values(), size);
   }
 
+  @SuppressWarnings("IterablesSizeOfCollection") // we are testing our iterator implementation
   private void assertCollectionSize(Collection<?> collection, int size) {
-    assertEquals(size, collection.size());
+    assertThat(collection.size()).isEqualTo(size);
     if (size > 0) {
-      assertFalse(collection.isEmpty());
+      assertThat(collection.isEmpty()).isFalse();
     } else {
-      assertTrue(collection.isEmpty());
+      assertThat(collection.isEmpty()).isTrue();
     }
-    assertEquals(size, Iterables.size(collection));
-    assertEquals(size, Iterators.size(collection.iterator()));
+    assertThat(Iterables.size(collection)).isEqualTo(size);
+    assertThat(Iterators.size(collection.iterator())).isEqualTo(size);
   }
 }
diff --git a/guava-tests/test/com/google/common/cache/AbstractCacheTest.java b/guava-tests/test/com/google/common/cache/AbstractCacheTest.java
index f803fccedfe7..6a1fc772cf57 100644
--- a/guava-tests/test/com/google/common/cache/AbstractCacheTest.java
+++ b/guava-tests/test/com/google/common/cache/AbstractCacheTest.java
@@ -21,7 +21,6 @@
 import com.google.common.cache.AbstractCache.SimpleStatsCounter;
 import com.google.common.cache.AbstractCache.StatsCounter;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicReference;
@@ -47,11 +46,11 @@ public void testGetIfPresent() {
           }
         };
 
-    assertNull(cache.getIfPresent(new Object()));
+    assertThat(cache.getIfPresent(new Object())).isNull();
 
     Object newValue = new Object();
     valueRef.set(newValue);
-    assertSame(newValue, cache.getIfPresent(new Object()));
+    assertThat(cache.getIfPresent(new Object())).isSameInstanceAs(newValue);
   }
 
   public void testGetAllPresent_empty() {
@@ -63,7 +62,7 @@ public void testGetAllPresent_empty() {
           }
         };
 
-    assertEquals(ImmutableMap.of(), cache.getAllPresent(ImmutableList.of(new Object())));
+    assertThat(cache.getAllPresent(ImmutableList.of(new Object()))).isEmpty();
   }
 
   public void testGetAllPresent_cached() {
@@ -77,9 +76,8 @@ public void testGetAllPresent_cached() {
           }
         };
 
-    assertEquals(
-        ImmutableMap.of(cachedKey, cachedValue),
-        cache.getAllPresent(ImmutableList.of(cachedKey, new Object())));
+    assertThat(cache.getAllPresent(ImmutableList.of(cachedKey, new Object())))
+        .containsExactly(cachedKey, cachedValue);
   }
 
   public void testInvalidateAll() {
@@ -99,23 +97,23 @@ public void invalidate(Object key) {
 
     List<Integer> toInvalidate = ImmutableList.of(1, 2, 3, 4);
     cache.invalidateAll(toInvalidate);
-    assertEquals(toInvalidate, invalidated);
+    assertThat(invalidated).isEqualTo(toInvalidate);
   }
 
   public void testEmptySimpleStats() {
     StatsCounter counter = new SimpleStatsCounter();
     CacheStats stats = counter.snapshot();
-    assertEquals(0, stats.requestCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
     assertThat(stats.hitRate()).isEqualTo(1.0);
-    assertEquals(0, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(0);
     assertThat(stats.missRate()).isEqualTo(0.0);
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.loadCount());
-    assertEquals(0, stats.totalLoadTime());
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.loadCount()).isEqualTo(0);
+    assertThat(stats.totalLoadTime()).isEqualTo(0);
     assertThat(stats.averageLoadPenalty()).isEqualTo(0.0);
-    assertEquals(0, stats.evictionCount());
+    assertThat(stats.evictionCount()).isEqualTo(0);
   }
 
   public void testSingleSimpleStats() {
@@ -137,18 +135,18 @@ public void testSingleSimpleStats() {
     }
     CacheStats stats = counter.snapshot();
     int requestCount = 11 + 23;
-    assertEquals(requestCount, stats.requestCount());
-    assertEquals(11, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(requestCount);
+    assertThat(stats.hitCount()).isEqualTo(11);
     assertThat(stats.hitRate()).isEqualTo(11.0 / requestCount);
     int missCount = 23;
-    assertEquals(missCount, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(missCount);
     assertThat(stats.missRate()).isEqualTo(((double) missCount) / requestCount);
-    assertEquals(13, stats.loadSuccessCount());
-    assertEquals(17, stats.loadExceptionCount());
-    assertEquals(13 + 17, stats.loadCount());
-    assertEquals(214, stats.totalLoadTime());
+    assertThat(stats.loadSuccessCount()).isEqualTo(13);
+    assertThat(stats.loadExceptionCount()).isEqualTo(17);
+    assertThat(stats.loadCount()).isEqualTo(13 + 17);
+    assertThat(stats.totalLoadTime()).isEqualTo(214);
     assertThat(stats.averageLoadPenalty()).isEqualTo(214.0 / (13 + 17));
-    assertEquals(27, stats.evictionCount());
+    assertThat(stats.evictionCount()).isEqualTo(27);
   }
 
   public void testSimpleStatsOverflow() {
@@ -156,7 +154,7 @@ public void testSimpleStatsOverflow() {
     counter.recordLoadSuccess(Long.MAX_VALUE);
     counter.recordLoadSuccess(1);
     CacheStats stats = counter.snapshot();
-    assertEquals(Long.MAX_VALUE, stats.totalLoadTime());
+    assertThat(stats.totalLoadTime()).isEqualTo(Long.MAX_VALUE);
   }
 
   public void testSimpleStatsIncrementBy() {
@@ -201,6 +199,6 @@ public void testSimpleStatsIncrementBy() {
     }
 
     counter1.incrementBy(counter2);
-    assertEquals(new CacheStats(38, 60, 44, 54, totalLoadTime, 66), counter1.snapshot());
+    assertThat(counter1.snapshot()).isEqualTo(new CacheStats(38, 60, 44, 54, totalLoadTime, 66));
   }
 }
diff --git a/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java b/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java
index 6548982acc49..85b37bf24ed6 100644
--- a/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java
+++ b/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java
@@ -61,7 +61,7 @@ public Object get(Object key) throws ExecutionException {
 
     Object newValue = new Object();
     valueRef.set(newValue);
-    assertSame(newValue, cache.getUnchecked(new Object()));
+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);
   }
 
   public void testGetUnchecked_unchecked() {
@@ -90,7 +90,7 @@ public Object get(Object key) throws ExecutionException {
 
     Object newValue = new Object();
     valueRef.set(newValue);
-    assertSame(newValue, cache.getUnchecked(new Object()));
+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);
   }
 
   public void testGetUnchecked_error() {
@@ -119,7 +119,7 @@ public Object get(Object key) throws ExecutionException {
 
     Object newValue = new Object();
     valueRef.set(newValue);
-    assertSame(newValue, cache.getUnchecked(new Object()));
+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);
   }
 
   public void testGetUnchecked_otherThrowable() {
@@ -148,6 +148,6 @@ public Object get(Object key) throws ExecutionException {
 
     Object newValue = new Object();
     valueRef.set(newValue);
-    assertSame(newValue, cache.getUnchecked(new Object()));
+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);
   }
 }
diff --git a/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java b/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java
index e1dee691ac29..600a85bbc82c 100644
--- a/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java
+++ b/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java
@@ -16,6 +16,7 @@
 
 package com.google.common.cache;
 
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 import com.google.common.annotations.GwtCompatible;
@@ -31,8 +32,11 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ExecutionException;
-import junit.framework.TestCase;
 import org.jspecify.annotations.NullUnmarked;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 /**
  * Test suite for {@link CacheBuilder}. TODO(cpovirk): merge into CacheBuilderTest?
@@ -41,18 +45,18 @@
  */
 @GwtCompatible
 @NullUnmarked
-public class CacheBuilderGwtTest extends TestCase {
+@RunWith(JUnit4.class)
+public class CacheBuilderGwtTest {
 
   private FakeTicker fakeTicker;
 
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-
+  @Before
+  public void setUp() {
     fakeTicker = new FakeTicker();
   }
 
-  public void testLoader() throws ExecutionException {
+  @Test
+  public void loader() throws ExecutionException {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();
 
     Callable<Integer> loader =
@@ -67,19 +71,20 @@ public Integer call() throws Exception {
 
     cache.put(0, 10);
 
-    assertEquals(Integer.valueOf(10), cache.get(0, loader));
-    assertEquals(Integer.valueOf(1), cache.get(20, loader));
-    assertEquals(Integer.valueOf(2), cache.get(34, loader));
+    assertThat(cache.get(0, loader)).isEqualTo(10);
+    assertThat(cache.get(20, loader)).isEqualTo(1);
+    assertThat(cache.get(34, loader)).isEqualTo(2);
 
     cache.invalidate(0);
-    assertEquals(Integer.valueOf(3), cache.get(0, loader));
+    assertThat(cache.get(0, loader)).isEqualTo(3);
 
     cache.put(0, 10);
     cache.invalidateAll();
-    assertEquals(Integer.valueOf(4), cache.get(0, loader));
+    assertThat(cache.get(0, loader)).isEqualTo(4);
   }
 
-  public void testSizeConstraint() {
+  @Test
+  public void sizeConstraint() {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().maximumSize(4).build();
 
     cache.put(1, 10);
@@ -88,22 +93,24 @@ public void testSizeConstraint() {
     cache.put(4, 40);
     cache.put(5, 50);
 
-    assertEquals(null, cache.getIfPresent(10));
+    assertThat(cache.getIfPresent(10)).isNull();
     // Order required to remove dependence on access order / write order constraint.
-    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));
-    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));
-    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));
+    assertThat(cache.getIfPresent(2)).isEqualTo(20);
+    assertThat(cache.getIfPresent(3)).isEqualTo(30);
+    assertThat(cache.getIfPresent(4)).isEqualTo(40);
+    assertThat(cache.getIfPresent(5)).isEqualTo(50);
 
     cache.put(1, 10);
-    assertEquals(Integer.valueOf(10), cache.getIfPresent(1));
-    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));
-    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));
-    assertEquals(null, cache.getIfPresent(2));
+    assertThat(cache.getIfPresent(1)).isEqualTo(10);
+    assertThat(cache.getIfPresent(3)).isEqualTo(30);
+    assertThat(cache.getIfPresent(4)).isEqualTo(40);
+    assertThat(cache.getIfPresent(5)).isEqualTo(50);
+    assertThat(cache.getIfPresent(2)).isNull();
   }
 
-  public void testLoadingCache() throws ExecutionException {
+  @SuppressWarnings({"deprecation", "LoadingCacheApply"})
+  @Test
+  public void loadingCache() throws ExecutionException {
     CacheLoader<Integer, Integer> loader =
         new CacheLoader<Integer, Integer>() {
           int i = 0;
@@ -120,17 +127,18 @@ public Integer load(Integer key) throws Exception {
 
     Map<Integer, Integer> map = cache.getAll(ImmutableList.of(10, 20, 30, 54, 443, 1));
 
-    assertEquals(Integer.valueOf(20), map.get(10));
-    assertEquals(Integer.valueOf(0), map.get(20));
-    assertEquals(Integer.valueOf(1), map.get(30));
-    assertEquals(Integer.valueOf(2), map.get(54));
-    assertEquals(Integer.valueOf(3), map.get(443));
-    assertEquals(Integer.valueOf(4), map.get(1));
-    assertEquals(Integer.valueOf(5), cache.get(6));
-    assertEquals(Integer.valueOf(6), cache.apply(7));
+    assertThat(map).containsEntry(10, 20);
+    assertThat(map).containsEntry(20, 0);
+    assertThat(map).containsEntry(30, 1);
+    assertThat(map).containsEntry(54, 2);
+    assertThat(map).containsEntry(443, 3);
+    assertThat(map).containsEntry(1, 4);
+    assertThat(cache.get(6)).isEqualTo(5);
+    assertThat(cache.apply(7)).isEqualTo(6);
   }
 
-  public void testExpireAfterAccess() {
+  @Test
+  public void expireAfterAccess() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterAccess(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -138,14 +146,15 @@ public void testExpireAfterAccess() {
     cache.put(2, 30);
 
     fakeTicker.advance(999, MILLISECONDS);
-    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));
+    assertThat(cache.getIfPresent(2)).isEqualTo(30);
     fakeTicker.advance(1, MILLISECONDS);
-    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));
+    assertThat(cache.getIfPresent(2)).isEqualTo(30);
     fakeTicker.advance(1000, MILLISECONDS);
-    assertEquals(null, cache.getIfPresent(0));
+    assertThat(cache.getIfPresent(0)).isNull();
   }
 
-  public void testExpireAfterWrite() {
+  @Test
+  public void expireAfterWrite() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -154,23 +163,24 @@ public void testExpireAfterWrite() {
     cache.put(4, 2);
 
     fakeTicker.advance(999, MILLISECONDS);
-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));
-    assertEquals(Integer.valueOf(2), cache.getIfPresent(4));
+    assertThat(cache.getIfPresent(10)).isEqualTo(100);
+    assertThat(cache.getIfPresent(20)).isEqualTo(200);
+    assertThat(cache.getIfPresent(4)).isEqualTo(2);
 
     fakeTicker.advance(2, MILLISECONDS);
-    assertEquals(null, cache.getIfPresent(10));
-    assertEquals(null, cache.getIfPresent(20));
-    assertEquals(null, cache.getIfPresent(4));
+    assertThat(cache.getIfPresent(10)).isNull();
+    assertThat(cache.getIfPresent(20)).isNull();
+    assertThat(cache.getIfPresent(4)).isNull();
 
     cache.put(10, 20);
-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));
+    assertThat(cache.getIfPresent(10)).isEqualTo(20);
 
     fakeTicker.advance(1000, MILLISECONDS);
-    assertEquals(null, cache.getIfPresent(10));
+    assertThat(cache.getIfPresent(10)).isNull();
   }
 
-  public void testExpireAfterWriteAndAccess() {
+  @Test
+  public void expireAfterWriteAndAccess() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder()
             .expireAfterWrite(1000, MILLISECONDS)
@@ -183,26 +193,28 @@ public void testExpireAfterWriteAndAccess() {
     cache.put(4, 2);
 
     fakeTicker.advance(499, MILLISECONDS);
-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));
+    assertThat(cache.getIfPresent(10)).isEqualTo(100);
+    assertThat(cache.getIfPresent(20)).isEqualTo(200);
 
     fakeTicker.advance(2, MILLISECONDS);
-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));
-    assertEquals(null, cache.getIfPresent(4));
+    assertThat(cache.getIfPresent(10)).isEqualTo(100);
+    assertThat(cache.getIfPresent(20)).isEqualTo(200);
+    assertThat(cache.getIfPresent(4)).isNull();
 
     fakeTicker.advance(499, MILLISECONDS);
-    assertEquals(null, cache.getIfPresent(10));
-    assertEquals(null, cache.getIfPresent(20));
+    assertThat(cache.getIfPresent(10)).isNull();
+    assertThat(cache.getIfPresent(20)).isNull();
 
     cache.put(10, 20);
-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));
+    assertThat(cache.getIfPresent(10)).isEqualTo(20);
 
     fakeTicker.advance(500, MILLISECONDS);
-    assertEquals(null, cache.getIfPresent(10));
+    assertThat(cache.getIfPresent(10)).isNull();
   }
 
-  public void testMapMethods() {
+  @SuppressWarnings("ContainsEntryAfterGetInteger") // we are testing our implementation of Map.get
+  @Test
+  public void mapMethods() {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();
 
     ConcurrentMap<Integer, Integer> asMap = cache.asMap();
@@ -213,38 +225,39 @@ public void testMapMethods() {
     asMap.replace(2, 79);
     asMap.replace(3, 60);
 
-    assertEquals(null, cache.getIfPresent(3));
-    assertEquals(null, asMap.get(3));
+    assertThat(cache.getIfPresent(3)).isNull();
+    assertThat(asMap.get(3)).isNull();
 
-    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));
-    assertEquals(Integer.valueOf(79), asMap.get(2));
+    assertThat(cache.getIfPresent(2)).isEqualTo(79);
+    assertThat(asMap.get(2)).isEqualTo(79);
 
     asMap.replace(10, 100, 50);
     asMap.replace(2, 52, 99);
 
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(50), asMap.get(10));
-    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));
-    assertEquals(Integer.valueOf(79), asMap.get(2));
+    assertThat(cache.getIfPresent(10)).isEqualTo(50);
+    assertThat(asMap.get(10)).isEqualTo(50);
+    assertThat(cache.getIfPresent(2)).isEqualTo(79);
+    assertThat(asMap.get(2)).isEqualTo(79);
 
     asMap.remove(10, 100);
     asMap.remove(2, 79);
 
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(50), asMap.get(10));
-    assertEquals(null, cache.getIfPresent(2));
-    assertEquals(null, asMap.get(2));
+    assertThat(cache.getIfPresent(10)).isEqualTo(50);
+    assertThat(asMap.get(10)).isEqualTo(50);
+    assertThat(cache.getIfPresent(2)).isNull();
+    assertThat(asMap.get(2)).isNull();
 
     asMap.putIfAbsent(2, 20);
     asMap.putIfAbsent(10, 20);
 
-    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));
-    assertEquals(Integer.valueOf(20), asMap.get(2));
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(50), asMap.get(10));
+    assertThat(cache.getIfPresent(2)).isEqualTo(20);
+    assertThat(asMap.get(2)).isEqualTo(20);
+    assertThat(cache.getIfPresent(10)).isEqualTo(50);
+    assertThat(asMap.get(10)).isEqualTo(50);
   }
 
-  public void testRemovalListener() {
+  @Test
+  public void removalListener() {
     int[] stats = new int[4];
 
     RemovalListener<Integer, Integer> countingListener =
@@ -303,30 +316,32 @@ public void onRemoval(RemovalNotification<Integer, Integer> notification) {
 
     cache.invalidateAll();
 
-    assertEquals(2, stats[0]);
-    assertEquals(2, stats[1]);
-    assertEquals(4, stats[2]);
-    assertEquals(3, stats[3]);
+    assertThat(stats[0]).isEqualTo(2);
+    assertThat(stats[1]).isEqualTo(2);
+    assertThat(stats[2]).isEqualTo(4);
+    assertThat(stats[3]).isEqualTo(3);
   }
 
-  public void testPutAll() {
+  @Test
+  public void putAll() {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();
 
     cache.putAll(ImmutableMap.of(10, 20, 30, 50, 60, 90));
 
-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(30));
-    assertEquals(Integer.valueOf(90), cache.getIfPresent(60));
+    assertThat(cache.getIfPresent(10)).isEqualTo(20);
+    assertThat(cache.getIfPresent(30)).isEqualTo(50);
+    assertThat(cache.getIfPresent(60)).isEqualTo(90);
 
     cache.asMap().putAll(ImmutableMap.of(10, 50, 30, 20, 60, 70, 5, 5));
 
-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));
-    assertEquals(Integer.valueOf(20), cache.getIfPresent(30));
-    assertEquals(Integer.valueOf(70), cache.getIfPresent(60));
-    assertEquals(Integer.valueOf(5), cache.getIfPresent(5));
+    assertThat(cache.getIfPresent(10)).isEqualTo(50);
+    assertThat(cache.getIfPresent(30)).isEqualTo(20);
+    assertThat(cache.getIfPresent(60)).isEqualTo(70);
+    assertThat(cache.getIfPresent(5)).isEqualTo(5);
   }
 
-  public void testInvalidate() {
+  @Test
+  public void invalidate() {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();
 
     cache.put(654, 2675);
@@ -335,12 +350,13 @@ public void testInvalidate() {
 
     cache.invalidate(654);
 
-    assertFalse(cache.asMap().containsKey(654));
-    assertTrue(cache.asMap().containsKey(2456));
-    assertTrue(cache.asMap().containsKey(2));
+    assertThat(cache.asMap().containsKey(654)).isFalse();
+    assertThat(cache.asMap().containsKey(2456)).isTrue();
+    assertThat(cache.asMap().containsKey(2)).isTrue();
   }
 
-  public void testInvalidateAll() {
+  @Test
+  public void invalidateAll() {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();
 
     cache.put(654, 2675);
@@ -348,9 +364,9 @@ public void testInvalidateAll() {
     cache.put(2, 15);
 
     cache.invalidateAll();
-    assertFalse(cache.asMap().containsKey(654));
-    assertFalse(cache.asMap().containsKey(2456));
-    assertFalse(cache.asMap().containsKey(2));
+    assertThat(cache.asMap().containsKey(654)).isFalse();
+    assertThat(cache.asMap().containsKey(2456)).isFalse();
+    assertThat(cache.asMap().containsKey(2)).isFalse();
 
     cache.put(654, 2675);
     cache.put(2456, 56);
@@ -359,13 +375,14 @@ public void testInvalidateAll() {
 
     cache.invalidateAll(ImmutableSet.of(1, 2));
 
-    assertFalse(cache.asMap().containsKey(1));
-    assertFalse(cache.asMap().containsKey(2));
-    assertTrue(cache.asMap().containsKey(654));
-    assertTrue(cache.asMap().containsKey(2456));
+    assertThat(cache.asMap().containsKey(1)).isFalse();
+    assertThat(cache.asMap().containsKey(2)).isFalse();
+    assertThat(cache.asMap().containsKey(654)).isTrue();
+    assertThat(cache.asMap().containsKey(2456)).isTrue();
   }
 
-  public void testAsMap_containsValue() {
+  @Test
+  public void asMap_containsValue() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(20000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -376,12 +393,15 @@ public void testAsMap_containsValue() {
 
     fakeTicker.advance(10001, MILLISECONDS);
 
-    assertTrue(cache.asMap().containsValue(15));
-    assertTrue(cache.asMap().containsValue(56));
-    assertFalse(cache.asMap().containsValue(2675));
+    assertThat(cache.asMap().containsValue(15)).isTrue();
+    assertThat(cache.asMap().containsValue(56)).isTrue();
+    assertThat(cache.asMap().containsValue(2675)).isFalse();
   }
 
-  public void testAsMap_containsKey() {
+  // we are testing our implementation of Map.containsKey
+  @SuppressWarnings("ContainsEntryAfterGetInteger")
+  @Test
+  public void asMap_containsKey() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(20000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -392,12 +412,15 @@ public void testAsMap_containsKey() {
 
     fakeTicker.advance(10001, MILLISECONDS);
 
-    assertTrue(cache.asMap().containsKey(2));
-    assertTrue(cache.asMap().containsKey(2456));
-    assertFalse(cache.asMap().containsKey(654));
+    assertThat(cache.asMap().containsKey(2)).isTrue();
+    assertThat(cache.asMap().containsKey(2456)).isTrue();
+    assertThat(cache.asMap().containsKey(654)).isFalse();
   }
 
-  public void testAsMapValues_contains() {
+  // we are testing our implementation of Map.values().contains
+  @SuppressWarnings("ValuesContainsValue")
+  @Test
+  public void asMapValues_contains() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -408,12 +431,13 @@ public void testAsMapValues_contains() {
 
     fakeTicker.advance(501, MILLISECONDS);
 
-    assertTrue(cache.asMap().values().contains(22));
-    assertTrue(cache.asMap().values().contains(10));
-    assertFalse(cache.asMap().values().contains(20));
+    assertThat(cache.asMap().values().contains(22)).isTrue();
+    assertThat(cache.asMap().values().contains(10)).isTrue();
+    assertThat(cache.asMap().values().contains(20)).isFalse();
   }
 
-  public void testAsMapKeySet() {
+  @Test
+  public void asMapKeySet() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -426,10 +450,11 @@ public void testAsMapKeySet() {
 
     Set<Integer> foundKeys = new HashSet<>(cache.asMap().keySet());
 
-    assertEquals(ImmutableSet.of(20, 5), foundKeys);
+    assertThat(foundKeys).containsExactly(20, 5);
   }
 
-  public void testAsMapKeySet_contains() {
+  @Test
+  public void asMapKeySet_contains() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -440,12 +465,13 @@ public void testAsMapKeySet_contains() {
 
     fakeTicker.advance(501, MILLISECONDS);
 
-    assertTrue(cache.asMap().keySet().contains(20));
-    assertTrue(cache.asMap().keySet().contains(5));
-    assertFalse(cache.asMap().keySet().contains(10));
+    assertThat(cache.asMap().keySet().contains(20)).isTrue();
+    assertThat(cache.asMap().keySet().contains(5)).isTrue();
+    assertThat(cache.asMap().keySet().contains(10)).isFalse();
   }
 
-  public void testAsMapEntrySet() {
+  @Test
+  public void asMapEntrySet() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -460,10 +486,11 @@ public void testAsMapEntrySet() {
     for (Entry<Integer, Integer> current : cache.asMap().entrySet()) {
       sum += current.getKey() + current.getValue();
     }
-    assertEquals(57, sum);
+    assertThat(sum).isEqualTo(57);
   }
 
-  public void testAsMapValues_iteratorRemove() {
+  @Test
+  public void asMapValues_iteratorRemove() {
     Cache<Integer, Integer> cache =
         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();
 
@@ -472,6 +499,6 @@ public void testAsMapValues_iteratorRemove() {
     iterator.next();
     iterator.remove();
 
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
   }
 }
diff --git a/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java b/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java
index 670275b08252..7948e82f89f3 100644
--- a/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java
+++ b/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java
@@ -18,6 +18,8 @@
 
 import static com.google.common.cache.CacheBuilderSpec.parse;
 import static com.google.common.cache.TestingWeighers.constantWeigher;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.util.concurrent.TimeUnit.DAYS;
 import static java.util.concurrent.TimeUnit.HOURS;
 import static java.util.concurrent.TimeUnit.MINUTES;
@@ -40,27 +42,27 @@
 public class CacheBuilderSpecTest extends TestCase {
   public void testParse_empty() {
     CacheBuilderSpec spec = parse("");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(CacheBuilder.newBuilder(), CacheBuilder.from(spec));
   }
 
   public void testParse_initialCapacity() {
     CacheBuilderSpec spec = parse("initialCapacity=10");
-    assertEquals(10, spec.initialCapacity.intValue());
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isEqualTo(10);
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().initialCapacity(10), CacheBuilder.from(spec));
   }
@@ -72,13 +74,13 @@ public void testParse_initialCapacityRepeated() {
 
   public void testParse_maximumSize() {
     CacheBuilderSpec spec = parse("maximumSize=9000");
-    assertNull(spec.initialCapacity);
-    assertEquals(9000, spec.maximumSize.longValue());
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isEqualTo(9000L);
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().maximumSize(9000), CacheBuilder.from(spec));
   }
@@ -89,13 +91,13 @@ public void testParse_maximumSizeRepeated() {
 
   public void testParse_maximumWeight() {
     CacheBuilderSpec spec = parse("maximumWeight=9000");
-    assertNull(spec.initialCapacity);
-    assertEquals(9000, spec.maximumWeight.longValue());
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumWeight).isEqualTo(9000L);
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().maximumWeight(9000), CacheBuilder.from(spec));
   }
@@ -110,14 +112,14 @@ public void testParse_maximumSizeAndMaximumWeight() {
 
   public void testParse_concurrencyLevel() {
     CacheBuilderSpec spec = parse("concurrencyLevel=32");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertEquals(32, spec.concurrencyLevel.intValue());
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isEqualTo(32);
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().concurrencyLevel(32), CacheBuilder.from(spec));
   }
@@ -129,14 +131,14 @@ public void testParse_concurrencyLevelRepeated() {
 
   public void testParse_weakKeys() {
     CacheBuilderSpec spec = parse("weakKeys");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertEquals(Strength.WEAK, spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().weakKeys(), CacheBuilder.from(spec));
   }
 
@@ -150,14 +152,14 @@ public void testParse_repeatedKeyStrength() {
 
   public void testParse_softValues() {
     CacheBuilderSpec spec = parse("softValues");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertEquals(Strength.SOFT, spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isEqualTo(Strength.SOFT);
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().softValues(), CacheBuilder.from(spec));
   }
 
@@ -167,14 +169,14 @@ public void testParse_softValuesCannotHaveValue() {
 
   public void testParse_weakValues() {
     CacheBuilderSpec spec = parse("weakValues");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertEquals(Strength.WEAK, spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isEqualTo(Strength.WEAK);
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().weakValues(), CacheBuilder.from(spec));
   }
 
@@ -194,39 +196,39 @@ public void testParse_repeatedValueStrength() {
 
   public void testParse_writeExpirationDays() {
     CacheBuilderSpec spec = parse("expireAfterWrite=10d");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertEquals(DAYS, spec.writeExpirationTimeUnit);
-    assertEquals(10L, spec.writeExpirationDuration);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(DAYS);
+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterWrite(10L, DAYS), CacheBuilder.from(spec));
   }
 
   public void testParse_writeExpirationHours() {
     CacheBuilderSpec spec = parse("expireAfterWrite=150h");
-    assertEquals(HOURS, spec.writeExpirationTimeUnit);
-    assertEquals(150L, spec.writeExpirationDuration);
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(HOURS);
+    assertThat(spec.writeExpirationDuration).isEqualTo(150L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterWrite(150L, HOURS), CacheBuilder.from(spec));
   }
 
   public void testParse_writeExpirationMinutes() {
     CacheBuilderSpec spec = parse("expireAfterWrite=10m");
-    assertEquals(MINUTES, spec.writeExpirationTimeUnit);
-    assertEquals(10L, spec.writeExpirationDuration);
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(MINUTES);
+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterWrite(10L, MINUTES), CacheBuilder.from(spec));
   }
 
   public void testParse_writeExpirationSeconds() {
     CacheBuilderSpec spec = parse("expireAfterWrite=10s");
-    assertEquals(SECONDS, spec.writeExpirationTimeUnit);
-    assertEquals(10L, spec.writeExpirationDuration);
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(SECONDS);
+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterWrite(10L, SECONDS), CacheBuilder.from(spec));
   }
@@ -238,39 +240,39 @@ public void testParse_writeExpirationRepeated() {
 
   public void testParse_accessExpirationDays() {
     CacheBuilderSpec spec = parse("expireAfterAccess=10d");
-    assertNull(spec.initialCapacity);
-    assertNull(spec.maximumSize);
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertNull(spec.keyStrength);
-    assertNull(spec.valueStrength);
-    assertNull(spec.writeExpirationTimeUnit);
-    assertEquals(DAYS, spec.accessExpirationTimeUnit);
-    assertEquals(10L, spec.accessExpirationDuration);
+    assertThat(spec.initialCapacity).isNull();
+    assertThat(spec.maximumSize).isNull();
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isNull();
+    assertThat(spec.valueStrength).isNull();
+    assertThat(spec.writeExpirationTimeUnit).isNull();
+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(DAYS);
+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterAccess(10L, DAYS), CacheBuilder.from(spec));
   }
 
   public void testParse_accessExpirationHours() {
     CacheBuilderSpec spec = parse("expireAfterAccess=150h");
-    assertEquals(HOURS, spec.accessExpirationTimeUnit);
-    assertEquals(150L, spec.accessExpirationDuration);
+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(HOURS);
+    assertThat(spec.accessExpirationDuration).isEqualTo(150L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterAccess(150L, HOURS), CacheBuilder.from(spec));
   }
 
   public void testParse_accessExpirationMinutes() {
     CacheBuilderSpec spec = parse("expireAfterAccess=10m");
-    assertEquals(MINUTES, spec.accessExpirationTimeUnit);
-    assertEquals(10L, spec.accessExpirationDuration);
+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(MINUTES);
+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterAccess(10L, MINUTES), CacheBuilder.from(spec));
   }
 
   public void testParse_accessExpirationSeconds() {
     CacheBuilderSpec spec = parse("expireAfterAccess=10s");
-    assertEquals(SECONDS, spec.accessExpirationTimeUnit);
-    assertEquals(10L, spec.accessExpirationDuration);
+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(SECONDS);
+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterAccess(10L, SECONDS), CacheBuilder.from(spec));
   }
@@ -282,7 +284,7 @@ public void testParse_accessExpirationRepeated() {
 
   public void testParse_recordStats() {
     CacheBuilderSpec spec = parse("recordStats");
-    assertTrue(spec.recordStats);
+    assertThat(spec.recordStats).isTrue();
     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().recordStats(), CacheBuilder.from(spec));
   }
 
@@ -296,10 +298,10 @@ public void testParse_recordStatsRepeated() {
 
   public void testParse_accessExpirationAndWriteExpiration() {
     CacheBuilderSpec spec = parse("expireAfterAccess=10s,expireAfterWrite=9m");
-    assertEquals(MINUTES, spec.writeExpirationTimeUnit);
-    assertEquals(9L, spec.writeExpirationDuration);
-    assertEquals(SECONDS, spec.accessExpirationTimeUnit);
-    assertEquals(10L, spec.accessExpirationDuration);
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(MINUTES);
+    assertThat(spec.writeExpirationDuration).isEqualTo(9L);
+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(SECONDS);
+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);
     assertCacheBuilderEquivalence(
         CacheBuilder.newBuilder().expireAfterAccess(10L, SECONDS).expireAfterWrite(9L, MINUTES),
         CacheBuilder.from(spec));
@@ -310,16 +312,16 @@ public void testParse_multipleKeys() {
         parse(
             "initialCapacity=10,maximumSize=20,concurrencyLevel=30,"
                 + "weakKeys,weakValues,expireAfterAccess=10m,expireAfterWrite=1h");
-    assertEquals(10, spec.initialCapacity.intValue());
-    assertEquals(20, spec.maximumSize.intValue());
-    assertNull(spec.maximumWeight);
-    assertEquals(30, spec.concurrencyLevel.intValue());
-    assertEquals(Strength.WEAK, spec.keyStrength);
-    assertEquals(Strength.WEAK, spec.valueStrength);
-    assertEquals(HOURS, spec.writeExpirationTimeUnit);
-    assertEquals(MINUTES, spec.accessExpirationTimeUnit);
-    assertEquals(1L, spec.writeExpirationDuration);
-    assertEquals(10L, spec.accessExpirationDuration);
+    assertThat(spec.initialCapacity).isEqualTo(10);
+    assertThat(spec.maximumSize).isEqualTo(20);
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isEqualTo(30);
+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);
+    assertThat(spec.valueStrength).isEqualTo(Strength.WEAK);
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(HOURS);
+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(MINUTES);
+    assertThat(spec.writeExpirationDuration).isEqualTo(1L);
+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);
     CacheBuilder<?, ?> expected =
         CacheBuilder.newBuilder()
             .initialCapacity(10)
@@ -337,15 +339,15 @@ public void testParse_whitespaceAllowed() {
         parse(
             " initialCapacity=10,\nmaximumSize=20,\t\r"
                 + "weakKeys \t ,softValues \n , \r  expireAfterWrite \t =  15s\n\n");
-    assertEquals(10, spec.initialCapacity.intValue());
-    assertEquals(20, spec.maximumSize.intValue());
-    assertNull(spec.maximumWeight);
-    assertNull(spec.concurrencyLevel);
-    assertEquals(Strength.WEAK, spec.keyStrength);
-    assertEquals(Strength.SOFT, spec.valueStrength);
-    assertEquals(SECONDS, spec.writeExpirationTimeUnit);
-    assertEquals(15L, spec.writeExpirationDuration);
-    assertNull(spec.accessExpirationTimeUnit);
+    assertThat(spec.initialCapacity).isEqualTo(10);
+    assertThat(spec.maximumSize).isEqualTo(20);
+    assertThat(spec.maximumWeight).isNull();
+    assertThat(spec.concurrencyLevel).isNull();
+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);
+    assertThat(spec.valueStrength).isEqualTo(Strength.SOFT);
+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(SECONDS);
+    assertThat(spec.writeExpirationDuration).isEqualTo(15L);
+    assertThat(spec.accessExpirationTimeUnit).isNull();
     CacheBuilder<?, ?> expected =
         CacheBuilder.newBuilder()
             .initialCapacity(10)
@@ -424,9 +426,9 @@ public void testDisableCaching() {
     Object value = new Object();
     LoadingCache<Object, Object> cache =
         builder.build(CacheLoader.from(Suppliers.ofInstance(value)));
-    assertSame(value, cache.getUnchecked(key));
-    assertEquals(0, cache.size());
-    assertFalse(cache.asMap().containsKey(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);
+    assertThat(cache.size()).isEqualTo(0);
+    assertThat(cache.asMap().containsKey(key)).isFalse();
   }
 
   public void testCacheBuilderFrom_string() {
@@ -445,22 +447,41 @@ public void testCacheBuilderFrom_string() {
     assertCacheBuilderEquivalence(expected, fromString);
   }
 
-  private static void assertCacheBuilderEquivalence(CacheBuilder<?, ?> a, CacheBuilder<?, ?> b) {
-    assertEquals("concurrencyLevel", a.concurrencyLevel, b.concurrencyLevel);
-    assertEquals("expireAfterAccessNanos", a.expireAfterAccessNanos, b.expireAfterAccessNanos);
-    assertEquals("expireAfterWriteNanos", a.expireAfterWriteNanos, b.expireAfterWriteNanos);
-    assertEquals("initialCapacity", a.initialCapacity, b.initialCapacity);
-    assertEquals("maximumSize", a.maximumSize, b.maximumSize);
-    assertEquals("maximumWeight", a.maximumWeight, b.maximumWeight);
-    assertEquals("refreshNanos", a.refreshNanos, b.refreshNanos);
-    assertEquals("keyEquivalence", a.keyEquivalence, b.keyEquivalence);
-    assertEquals("keyStrength", a.keyStrength, b.keyStrength);
-    assertEquals("removalListener", a.removalListener, b.removalListener);
-    assertEquals("weigher", a.weigher, b.weigher);
-    assertEquals("valueEquivalence", a.valueEquivalence, b.valueEquivalence);
-    assertEquals("valueStrength", a.valueStrength, b.valueStrength);
-    assertEquals("statsCounterSupplier", a.statsCounterSupplier, b.statsCounterSupplier);
-    assertEquals("ticker", a.ticker, b.ticker);
-    assertEquals("recordStats", a.isRecordingStats(), b.isRecordingStats());
+  private static void assertCacheBuilderEquivalence(
+      CacheBuilder<?, ?> expected, CacheBuilder<?, ?> actual) {
+    assertWithMessage("concurrencyLevel")
+        .that(actual.concurrencyLevel)
+        .isEqualTo(expected.concurrencyLevel);
+    assertWithMessage("expireAfterAccessNanos")
+        .that(actual.expireAfterAccessNanos)
+        .isEqualTo(expected.expireAfterAccessNanos);
+    assertWithMessage("expireAfterWriteNanos")
+        .that(actual.expireAfterWriteNanos)
+        .isEqualTo(expected.expireAfterWriteNanos);
+    assertWithMessage("initialCapacity")
+        .that(actual.initialCapacity)
+        .isEqualTo(expected.initialCapacity);
+    assertWithMessage("maximumSize").that(actual.maximumSize).isEqualTo(expected.maximumSize);
+    assertWithMessage("maximumWeight").that(actual.maximumWeight).isEqualTo(expected.maximumWeight);
+    assertWithMessage("refreshNanos").that(actual.refreshNanos).isEqualTo(expected.refreshNanos);
+    assertWithMessage("keyEquivalence")
+        .that(actual.keyEquivalence)
+        .isEqualTo(expected.keyEquivalence);
+    assertWithMessage("keyStrength").that(actual.keyStrength).isEqualTo(expected.keyStrength);
+    assertWithMessage("removalListener")
+        .that(actual.removalListener)
+        .isEqualTo(expected.removalListener);
+    assertWithMessage("weigher").that(actual.weigher).isEqualTo(expected.weigher);
+    assertWithMessage("valueEquivalence")
+        .that(actual.valueEquivalence)
+        .isEqualTo(expected.valueEquivalence);
+    assertWithMessage("valueStrength").that(actual.valueStrength).isEqualTo(expected.valueStrength);
+    assertWithMessage("statsCounterSupplier")
+        .that(actual.statsCounterSupplier)
+        .isEqualTo(expected.statsCounterSupplier);
+    assertWithMessage("ticker").that(actual.ticker).isEqualTo(expected.ticker);
+    assertWithMessage("recordStats")
+        .that(actual.isRecordingStats())
+        .isEqualTo(expected.isRecordingStats());
   }
 }
diff --git a/guava-tests/test/com/google/common/cache/CacheBuilderTest.java b/guava-tests/test/com/google/common/cache/CacheBuilderTest.java
index 63653d58a993..0466bb017b3b 100644
--- a/guava-tests/test/com/google/common/cache/CacheBuilderTest.java
+++ b/guava-tests/test/com/google/common/cache/CacheBuilderTest.java
@@ -24,6 +24,7 @@
 import static com.google.common.cache.TestingRemovalListeners.queuingRemovalListener;
 import static com.google.common.cache.TestingWeighers.constantWeigher;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.util.concurrent.Executors.newFixedThreadPool;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
@@ -63,8 +64,8 @@ public void testNewBuilder() {
     LoadingCache<String, Integer> cache =
         CacheBuilder.newBuilder().removalListener(countingRemovalListener()).build(loader);
 
-    assertEquals(Integer.valueOf(1), cache.getUnchecked("one"));
-    assertEquals(1, cache.size());
+    assertThat(cache.getUnchecked("one")).isEqualTo(1);
+    assertThat(cache.size()).isEqualTo(1);
   }
 
   public void testInitialCapacity_negative() {
@@ -83,10 +84,10 @@ public void testInitialCapacity_small() {
     LocalCache<?, ?> map = CacheTesting.toLocalCache(cache);
 
     assertThat(map.segments).hasLength(4);
-    assertEquals(2, map.segments[0].table.length());
-    assertEquals(2, map.segments[1].table.length());
-    assertEquals(2, map.segments[2].table.length());
-    assertEquals(2, map.segments[3].table.length());
+    assertThat(map.segments[0].table.length()).isEqualTo(2);
+    assertThat(map.segments[1].table.length()).isEqualTo(2);
+    assertThat(map.segments[2].table.length()).isEqualTo(2);
+    assertThat(map.segments[3].table.length()).isEqualTo(2);
   }
 
   @GwtIncompatible // CacheTesting
@@ -96,10 +97,10 @@ public void testInitialCapacity_smallest() {
 
     assertThat(map.segments).hasLength(4);
     // 1 is as low as it goes, not 0. it feels dirty to know this/test this.
-    assertEquals(1, map.segments[0].table.length());
-    assertEquals(1, map.segments[1].table.length());
-    assertEquals(1, map.segments[2].table.length());
-    assertEquals(1, map.segments[3].table.length());
+    assertThat(map.segments[0].table.length()).isEqualTo(1);
+    assertThat(map.segments[1].table.length()).isEqualTo(1);
+    assertThat(map.segments[2].table.length()).isEqualTo(1);
+    assertThat(map.segments[3].table.length()).isEqualTo(1);
   }
 
   public void testInitialCapacity_large() {
@@ -327,7 +328,7 @@ public void testRemovalListener_setTwice() {
   }
 
   public void testValuesIsNotASet() {
-    assertFalse(CacheBuilder.newBuilder().build().asMap().values() instanceof Set);
+    assertThat(CacheBuilder.newBuilder().build().asMap().values() instanceof Set).isFalse();
   }
 
   @GwtIncompatible // CacheTesting
@@ -335,11 +336,11 @@ public void testNullCache() {
     CountingRemovalListener<Object, Object> listener = countingRemovalListener();
     LoadingCache<Object, Object> nullCache =
         CacheBuilder.newBuilder().maximumSize(0).removalListener(listener).build(identityLoader());
-    assertEquals(0, nullCache.size());
+    assertThat(nullCache.size()).isEqualTo(0);
     Object key = new Object();
-    assertSame(key, nullCache.getUnchecked(key));
-    assertEquals(1, listener.getCount());
-    assertEquals(0, nullCache.size());
+    assertThat(nullCache.getUnchecked(key)).isSameInstanceAs(key);
+    assertThat(listener.getCount()).isEqualTo(1);
+    assertThat(nullCache.size()).isEqualTo(0);
     CacheTesting.checkEmpty(nullCache.asMap());
   }
 
@@ -396,12 +397,12 @@ public void run() {
     // At this point, the listener should be holding the seed value (a -> a), and the map should
     // contain the computed value (b -> b), since the clear() happened before the computation
     // completed.
-    assertEquals(1, listener.size());
+    assertThat(listener).hasSize(1);
     RemovalNotification<String, String> notification = listener.remove();
-    assertEquals("a", notification.getKey());
-    assertEquals("a", notification.getValue());
-    assertEquals(1, cache.size());
-    assertEquals("b", cache.getUnchecked("b"));
+    assertThat(notification.getKey()).isEqualTo("a");
+    assertThat(notification.getValue()).isEqualTo("a");
+    assertThat(cache.size()).isEqualTo(1);
+    assertThat(cache.getUnchecked("b")).isEqualTo("b");
   }
 
   // "Basher tests", where we throw a bunch of stuff at a LoadingCache and check basic invariants.
@@ -476,22 +477,22 @@ public void run() {
     Map<String, String> removalNotifications = new HashMap<>();
     for (RemovalNotification<String, String> notification : listener) {
       removalNotifications.put(notification.getKey(), notification.getValue());
-      assertEquals(
-          "Unexpected key/value pair passed to removalListener",
-          notification.getKey(),
-          notification.getValue());
+      assertWithMessage("Unexpected key/value pair passed to removalListener")
+          .that(notification.getValue())
+          .isEqualTo(notification.getKey());
     }
 
     // All of the seed values should have been visible, so we should have gotten removal
     // notifications for all of them.
     for (int i = 0; i < nSeededEntries; i++) {
-      assertEquals("b" + i, removalNotifications.get("b" + i));
+      assertThat(removalNotifications.get("b" + i)).isEqualTo("b" + i);
     }
 
     // Each of the values added to the map should either still be there, or have seen a removal
     // notification.
-    assertEquals(expectedKeys, Sets.union(cache.asMap().keySet(), removalNotifications.keySet()));
-    assertTrue(Sets.intersection(cache.asMap().keySet(), removalNotifications.keySet()).isEmpty());
+    assertThat(Sets.union(cache.asMap().keySet(), removalNotifications.keySet()))
+        .isEqualTo(expectedKeys);
+    assertThat(cache.asMap().keySet()).containsNoneIn(removalNotifications.keySet());
     threadPool.shutdown();
     threadPool.awaitTermination(300, SECONDS);
   }
@@ -570,15 +571,17 @@ public void run() {
 
     // Verify that each received removal notification was valid
     for (RemovalNotification<String, String> notification : removalListener) {
-      assertEquals("Invalid removal notification", notification.getKey(), notification.getValue());
+      assertWithMessage("Invalid removal notification")
+          .that(notification.getValue())
+          .isEqualTo(notification.getKey());
     }
 
     CacheStats stats = cache.stats();
-    assertEquals(removalListener.size(), stats.evictionCount());
-    assertEquals(computeCount.get(), stats.loadSuccessCount());
-    assertEquals(exceptionCount.get() + computeNullCount.get(), stats.loadExceptionCount());
+    assertThat(stats.evictionCount()).isEqualTo(removalListener.size());
+    assertThat(stats.loadSuccessCount()).isEqualTo(computeCount.get());
+    assertThat(stats.loadExceptionCount()).isEqualTo(exceptionCount.get() + computeNullCount.get());
     // each computed value is still in the cache, or was passed to the removal listener
-    assertEquals(computeCount.get(), cache.size() + removalListener.size());
+    assertThat(cache.size() + removalListener.size()).isEqualTo(computeCount.get());
   }
 
   @GwtIncompatible // NullPointerTester
@@ -593,7 +596,7 @@ public void testSizingDefaults() {
     LoadingCache<?, ?> cache = CacheBuilder.newBuilder().build(identityLoader());
     LocalCache<?, ?> map = CacheTesting.toLocalCache(cache);
     assertThat(map.segments).hasLength(4); // concurrency level
-    assertEquals(4, map.segments[0].table.length()); // capacity / conc level
+    assertThat(map.segments[0].table.length()).isEqualTo(4); // capacity / conc level
   }
 
   @GwtIncompatible // CountDownLatch
diff --git a/guava-tests/test/com/google/common/cache/CacheEvictionTest.java b/guava-tests/test/com/google/common/cache/CacheEvictionTest.java
index a6d97f881001..8f83959eb8f6 100644
--- a/guava-tests/test/com/google/common/cache/CacheEvictionTest.java
+++ b/guava-tests/test/com/google/common/cache/CacheEvictionTest.java
@@ -45,7 +45,7 @@ public void testEviction_setMaxSegmentSize() {
     IdentityLoader<Object> loader = identityLoader();
     for (int i = 1; i < 1000; i++) {
       LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().maximumSize(i).build(loader);
-      assertEquals(i, CacheTesting.getTotalSegmentSize(cache));
+      assertThat(CacheTesting.getTotalSegmentSize(cache)).isEqualTo(i);
     }
   }
 
@@ -54,7 +54,7 @@ public void testEviction_setMaxSegmentWeight() {
     for (int i = 1; i < 1000; i++) {
       LoadingCache<Object, Object> cache =
           CacheBuilder.newBuilder().maximumWeight(i).weigher(constantWeigher(1)).build(loader);
-      assertEquals(i, CacheTesting.getTotalSegmentSize(cache));
+      assertThat(CacheTesting.getTotalSegmentSize(cache)).isEqualTo(i);
     }
   }
 
@@ -64,10 +64,10 @@ public void testEviction_maxSizeOneSegment() {
         CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(MAX_SIZE).build(loader);
     for (int i = 0; i < 2 * MAX_SIZE; i++) {
       cache.getUnchecked(i);
-      assertEquals(min(i + 1, MAX_SIZE), cache.size());
+      assertThat(cache.size()).isEqualTo(min(i + 1, MAX_SIZE));
     }
 
-    assertEquals(MAX_SIZE, cache.size());
+    assertThat(cache.size()).isEqualTo(MAX_SIZE);
     CacheTesting.checkValidState(cache);
   }
 
@@ -81,10 +81,10 @@ public void testEviction_maxWeightOneSegment() {
             .build(loader);
     for (int i = 0; i < 2 * MAX_SIZE; i++) {
       cache.getUnchecked(i);
-      assertEquals(min(i + 1, MAX_SIZE), cache.size());
+      assertThat(cache.size()).isEqualTo(min(i + 1, MAX_SIZE));
     }
 
-    assertEquals(MAX_SIZE, cache.size());
+    assertThat(cache.size()).isEqualTo(MAX_SIZE);
     CacheTesting.checkValidState(cache);
   }
 
@@ -98,13 +98,13 @@ public void testEviction_maxSize() {
             .build(loader);
     for (int i = 0; i < 2 * MAX_SIZE; i++) {
       cache.getUnchecked(i);
-      assertTrue(cache.size() <= MAX_SIZE);
+      assertThat(cache.size() <= MAX_SIZE).isTrue();
     }
 
-    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));
-    assertEquals(MAX_SIZE, cache.size());
+    assertThat(CacheTesting.accessQueueSize(cache)).isEqualTo(MAX_SIZE);
+    assertThat(cache.size()).isEqualTo(MAX_SIZE);
     CacheTesting.processPendingNotifications(cache);
-    assertEquals(MAX_SIZE, removalListener.getCount());
+    assertThat(removalListener.getCount()).isEqualTo(MAX_SIZE);
     CacheTesting.checkValidState(cache);
   }
 
@@ -119,13 +119,13 @@ public void testEviction_maxWeight() {
             .build(loader);
     for (int i = 0; i < 2 * MAX_SIZE; i++) {
       cache.getUnchecked(i);
-      assertTrue(cache.size() <= MAX_SIZE);
+      assertThat(cache.size()).isAtMost(MAX_SIZE);
     }
 
-    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));
-    assertEquals(MAX_SIZE, cache.size());
+    assertThat(CacheTesting.accessQueueSize(cache)).isEqualTo(MAX_SIZE);
+    assertThat(cache.size()).isEqualTo(MAX_SIZE);
     CacheTesting.processPendingNotifications(cache);
-    assertEquals(MAX_SIZE, removalListener.getCount());
+    assertThat(removalListener.getCount()).isEqualTo(MAX_SIZE);
     CacheTesting.checkValidState(cache);
   }
 
@@ -255,7 +255,7 @@ public void testEviction_overflow() {
     cache.getUnchecked(objectWithHash(0));
     cache.getUnchecked(objectWithHash(0));
     CacheTesting.processPendingNotifications(cache);
-    assertEquals(1, removalListener.getCount());
+    assertThat(removalListener.getCount()).isEqualTo(1);
   }
 
   public void testUpdateRecency_onGet() {
diff --git a/guava-tests/test/com/google/common/cache/CacheExpirationTest.java b/guava-tests/test/com/google/common/cache/CacheExpirationTest.java
index 8122c68514e8..75095b28e0b6 100644
--- a/guava-tests/test/com/google/common/cache/CacheExpirationTest.java
+++ b/guava-tests/test/com/google/common/cache/CacheExpirationTest.java
@@ -17,6 +17,7 @@
 import static com.google.common.cache.TestingCacheLoaders.identityLoader;
 import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.util.Arrays.asList;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.MINUTES;
@@ -81,23 +82,29 @@ private void checkExpiration(
       CountingRemovalListener<String, Integer> removalListener) {
 
     for (int i = 0; i < 10; i++) {
-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));
+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);
     }
 
     for (int i = 0; i < 10; i++) {
       loader.reset();
-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));
-      assertFalse("Creator should not have been called @#" + i, loader.wasCalled());
+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);
+      assertWithMessage("Creator should not have been called @#%s", i)
+          .that(loader.wasCalled())
+          .isFalse();
     }
 
     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);
 
-    assertEquals("Map must be empty by now", 0, cache.size());
-    assertEquals("Eviction notifications must be received", 10, removalListener.getCount());
+    assertWithMessage("Map must be empty by now").that(cache.size()).isEqualTo(0);
+    assertWithMessage("Eviction notifications must be received")
+        .that(removalListener.getCount())
+        .isEqualTo(10);
 
     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);
     // ensure that no new notifications are sent
-    assertEquals("Eviction notifications must be received", 10, removalListener.getCount());
+    assertWithMessage("Eviction notifications must be received")
+        .that(removalListener.getCount())
+        .isEqualTo(10);
   }
 
   public void testExpiringGet_expireAfterWrite() {
@@ -133,13 +140,15 @@ private void runExpirationTest(
       CountingRemovalListener<String, Integer> removalListener) {
 
     for (int i = 0; i < 10; i++) {
-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));
+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);
     }
 
     for (int i = 0; i < 10; i++) {
       loader.reset();
-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));
-      assertFalse("Loader should NOT have been called @#" + i, loader.wasCalled());
+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);
+      assertWithMessage("Loader should NOT have been called @#%s", i)
+          .that(loader.wasCalled())
+          .isFalse();
     }
 
     // wait for entries to expire, but don't call expireEntries
@@ -149,31 +158,35 @@ private void runExpirationTest(
     cache.getUnchecked(KEY_PREFIX + 11);
 
     // collections views shouldn't expose expired entries
-    assertEquals(1, Iterators.size(cache.asMap().entrySet().iterator()));
-    assertEquals(1, Iterators.size(cache.asMap().keySet().iterator()));
-    assertEquals(1, Iterators.size(cache.asMap().values().iterator()));
+    assertThat(Iterators.size(cache.asMap().entrySet().iterator())).isEqualTo(1);
+    assertThat(Iterators.size(cache.asMap().keySet().iterator())).isEqualTo(1);
+    assertThat(Iterators.size(cache.asMap().values().iterator())).isEqualTo(1);
 
     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);
 
     for (int i = 0; i < 11; i++) {
-      assertFalse(cache.asMap().containsKey(KEY_PREFIX + i));
+      assertThat(cache.asMap().containsKey(KEY_PREFIX + i)).isFalse();
     }
-    assertEquals(11, removalListener.getCount());
+    assertThat(removalListener.getCount()).isEqualTo(11);
 
     for (int i = 0; i < 10; i++) {
-      assertFalse(cache.asMap().containsKey(KEY_PREFIX + i));
+      assertThat(cache.asMap().containsKey(KEY_PREFIX + i)).isFalse();
       loader.reset();
-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));
-      assertTrue("Creator should have been called @#" + i, loader.wasCalled());
+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);
+      assertWithMessage("Loader should have been called @#%s", i).that(loader.wasCalled()).isTrue();
     }
 
     // expire new values we just created
     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);
-    assertEquals("Eviction notifications must be received", 21, removalListener.getCount());
+    assertWithMessage("Eviction notifications must be received")
+        .that(removalListener.getCount())
+        .isEqualTo(21);
 
     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);
     // ensure that no new notifications are sent
-    assertEquals("Eviction notifications must be received", 21, removalListener.getCount());
+    assertWithMessage("Eviction notifications must be received")
+        .that(removalListener.getCount())
+        .isEqualTo(21);
   }
 
   public void testRemovalListener_expireAfterWrite() {
@@ -215,9 +228,9 @@ public AtomicInteger load(Integer key) {
       ticker.advance(1, MILLISECONDS);
     }
 
-    assertEquals(evictionCount.get() + 1, applyCount.get());
+    assertThat(applyCount.get()).isEqualTo(evictionCount.get() + 1);
     int remaining = cache.getUnchecked(10).get();
-    assertEquals(100, totalSum.get() + remaining);
+    assertThat(totalSum.get() + remaining).isEqualTo(100);
   }
 
   public void testRemovalScheduler_expireAfterWrite() {
@@ -435,46 +448,50 @@ private void runRemovalScheduler(
       FakeTicker ticker,
       String keyPrefix,
       long ttl) {
+    loader.setKeyPrefix(keyPrefix);
 
     int shift1 = 10 + VALUE_PREFIX;
     loader.setValuePrefix(shift1);
     // fill with initial data
     for (int i = 0; i < 10; i++) {
-      assertEquals(Integer.valueOf(i + shift1), cache.getUnchecked(keyPrefix + i));
+      assertThat(cache.getUnchecked(keyPrefix + i)).isEqualTo(i + shift1);
     }
-    assertEquals(10, CacheTesting.expirationQueueSize(cache));
-    assertEquals(0, removalListener.getCount());
+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);
+    assertThat(removalListener.getCount()).isEqualTo(0);
 
     // wait, so that entries have just 10 ms to live
     ticker.advance(ttl * 2 / 3, MILLISECONDS);
 
-    assertEquals(10, CacheTesting.expirationQueueSize(cache));
-    assertEquals(0, removalListener.getCount());
+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);
+    assertThat(removalListener.getCount()).isEqualTo(0);
 
     int shift2 = shift1 + 10;
     loader.setValuePrefix(shift2);
     // fill with new data - has to live for 20 ms more
     for (int i = 0; i < 10; i++) {
       cache.invalidate(keyPrefix + i);
-      assertEquals(
-          "key: " + keyPrefix + i, Integer.valueOf(i + shift2), cache.getUnchecked(keyPrefix + i));
+      assertWithMessage("key: %s%s", keyPrefix, i)
+          .that(cache.getUnchecked(keyPrefix + i))
+          .isEqualTo(i + shift2);
     }
-    assertEquals(10, CacheTesting.expirationQueueSize(cache));
-    assertEquals(10, removalListener.getCount()); // these are the invalidated ones
+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);
+    assertThat(removalListener.getCount()).isEqualTo(10); // these are the invalidated ones
 
     // old timeouts must expire after this wait
     ticker.advance(ttl * 2 / 3, MILLISECONDS);
 
-    assertEquals(10, CacheTesting.expirationQueueSize(cache));
-    assertEquals(10, removalListener.getCount());
+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);
+    assertThat(removalListener.getCount()).isEqualTo(10);
 
     // check that new values are still there - they still have 10 ms to live
     for (int i = 0; i < 10; i++) {
       loader.reset();
-      assertEquals(Integer.valueOf(i + shift2), cache.getUnchecked(keyPrefix + i));
-      assertFalse("Creator should NOT have been called @#" + i, loader.wasCalled());
+      assertThat(cache.getUnchecked(keyPrefix + i)).isEqualTo(i + shift2);
+      assertWithMessage("Creator should NOT have been called @#%s", i)
+          .that(loader.wasCalled())
+          .isFalse();
     }
-    assertEquals(10, removalListener.getCount());
+    assertThat(removalListener.getCount()).isEqualTo(10);
   }
 
   private static void getAll(LoadingCache<Integer, Integer> cache, List<Integer> keys) {
diff --git a/guava-tests/test/com/google/common/cache/CacheLoaderTest.java b/guava-tests/test/com/google/common/cache/CacheLoaderTest.java
index 70918db35fe7..8125ff117a6a 100644
--- a/guava-tests/test/com/google/common/cache/CacheLoaderTest.java
+++ b/guava-tests/test/com/google/common/cache/CacheLoaderTest.java
@@ -16,6 +16,7 @@
 
 package com.google.common.cache;
 
+import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.util.concurrent.Futures.immediateFuture;
 
 import com.google.common.collect.ImmutableList;
@@ -77,17 +78,17 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {
           }
         };
 
-    assertEquals(0, loadCount.get());
-    assertEquals(0, reloadCount.get());
-    assertEquals(0, loadAllCount.get());
+    assertThat(loadCount.get()).isEqualTo(0);
+    assertThat(reloadCount.get()).isEqualTo(0);
+    assertThat(loadAllCount.get()).isEqualTo(0);
 
     Object unused1 = baseLoader.load(new Object());
     @SuppressWarnings("unused") // https://errorprone.info/bugpattern/FutureReturnValueIgnored
     Future<?> possiblyIgnoredError = baseLoader.reload(new Object(), new Object());
     Map<Object, Object> unused2 = baseLoader.loadAll(ImmutableList.of(new Object()));
-    assertEquals(1, loadCount.get());
-    assertEquals(1, reloadCount.get());
-    assertEquals(1, loadAllCount.get());
+    assertThat(loadCount.get()).isEqualTo(1);
+    assertThat(reloadCount.get()).isEqualTo(1);
+    assertThat(loadAllCount.get()).isEqualTo(1);
 
     QueuingExecutor executor = new QueuingExecutor();
     CacheLoader<Object, Object> asyncReloader = CacheLoader.asyncReloading(baseLoader, executor);
@@ -96,13 +97,13 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {
     @SuppressWarnings("unused") // https://errorprone.info/bugpattern/FutureReturnValueIgnored
     Future<?> possiblyIgnoredError1 = asyncReloader.reload(new Object(), new Object());
     Map<Object, Object> unused4 = asyncReloader.loadAll(ImmutableList.of(new Object()));
-    assertEquals(2, loadCount.get());
-    assertEquals(1, reloadCount.get());
-    assertEquals(2, loadAllCount.get());
+    assertThat(loadCount.get()).isEqualTo(2);
+    assertThat(reloadCount.get()).isEqualTo(1);
+    assertThat(loadAllCount.get()).isEqualTo(2);
 
     executor.runNext();
-    assertEquals(2, loadCount.get());
-    assertEquals(2, reloadCount.get());
-    assertEquals(2, loadAllCount.get());
+    assertThat(loadCount.get()).isEqualTo(2);
+    assertThat(reloadCount.get()).isEqualTo(2);
+    assertThat(loadAllCount.get()).isEqualTo(2);
   }
 }
diff --git a/guava-tests/test/com/google/common/cache/CacheLoadingTest.java b/guava-tests/test/com/google/common/cache/CacheLoadingTest.java
index a2e3883d95b9..7dc674ae919c 100644
--- a/guava-tests/test/com/google/common/cache/CacheLoadingTest.java
+++ b/guava-tests/test/com/google/common/cache/CacheLoadingTest.java
@@ -21,6 +21,7 @@
 import static com.google.common.cache.TestingCacheLoaders.identityLoader;
 import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static com.google.common.util.concurrent.Futures.immediateFailedFuture;
 import static com.google.common.util.concurrent.Futures.immediateFuture;
 import static java.util.Arrays.asList;
@@ -33,7 +34,6 @@
 import com.google.common.cache.TestingCacheLoaders.IdentityLoader;
 import com.google.common.cache.TestingRemovalListeners.CountingRemovalListener;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
 import com.google.common.testing.FakeTicker;
 import com.google.common.testing.TestLogHandler;
@@ -83,7 +83,7 @@ public void tearDown() throws Exception {
 
   private Throwable popLoggedThrowable() {
     List<LogRecord> logRecords = logHandler.getStoredLogRecords();
-    assertEquals(1, logRecords.size());
+    assertThat(logRecords).hasSize(1);
     LogRecord logRecord = logRecords.get(0);
     logHandler.clear();
     return logRecord.getThrown();
@@ -105,59 +105,59 @@ public void testLoad() throws ExecutionException {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(identityLoader());
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Object key = new Object();
-    assertSame(key, cache.get(key));
+    assertThat(cache.get(key)).isSameInstanceAs(key);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     key = new Object();
-    assertSame(key, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(key);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     key = new Object();
     cache.refresh(key);
     checkNothingLogged();
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(3, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(3);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(key, cache.get(key));
+    assertThat(cache.get(key)).isSameInstanceAs(key);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(3, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(3);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     Object value = new Object();
     // callable is not called
-    assertSame(key, cache.get(key, throwing(new Exception())));
+    assertThat(cache.get(key, throwing(new Exception()))).isSameInstanceAs(key);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(3, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(3);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     key = new Object();
-    assertSame(value, cache.get(key, Callables.returning(value)));
+    assertThat(cache.get(key, Callables.returning(value))).isSameInstanceAs(value);
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(4, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(4);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(2);
   }
 
   public void testReload() throws ExecutionException {
@@ -179,32 +179,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkNothingLogged();
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(two, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testRefresh() {
@@ -232,41 +232,41 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
             .build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(two, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(two, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(3);
   }
 
   public void testRefresh_getIfPresent() {
@@ -294,41 +294,41 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
             .build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getIfPresent(key));
+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(two, cache.getIfPresent(key));
+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(two, cache.getIfPresent(key));
+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(3);
   }
 
   public void testBulkLoad_default() throws ExecutionException {
@@ -337,45 +337,45 @@ public void testBulkLoad_default() throws ExecutionException {
             .recordStats()
             .build(TestingCacheLoaders.<Integer>identityLoader());
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.<Integer>of()));
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(cache.getAll(ImmutableList.of())).isEmpty();
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));
+    assertThat(cache.getAll(asList(1))).containsExactly(1, 1);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));
+    assertThat(cache.getAll(asList(1, 2, 3, 4))).containsExactly(1, 1, 2, 2, 3, 3, 4, 4);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(4, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(4);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
-    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));
+    assertThat(cache.getAll(asList(2, 3))).containsExactly(2, 2, 3, 3);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(4, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(4);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(3);
 
     // duplicate keys are ignored, and don't impact stats
-    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));
+    assertThat(cache.getAll(asList(4, 5))).containsExactly(4, 4, 5, 5);
     stats = cache.stats();
-    assertEquals(5, stats.missCount());
-    assertEquals(5, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(4, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(5);
+    assertThat(stats.loadSuccessCount()).isEqualTo(5);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(4);
   }
 
   public void testBulkLoad_loadAll() throws ExecutionException {
@@ -383,45 +383,45 @@ public void testBulkLoad_loadAll() throws ExecutionException {
     CacheLoader<Integer, Integer> loader = bulkLoader(backingLoader);
     LoadingCache<Integer, Integer> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.<Integer>of()));
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(cache.getAll(ImmutableList.<Integer>of())).containsExactly();
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));
+    assertThat(cache.getAll(asList(1))).containsExactly(1, 1);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));
+    assertThat(cache.getAll(asList(1, 2, 3, 4))).containsExactly(1, 1, 2, 2, 3, 3, 4, 4);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
-    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));
+    assertThat(cache.getAll(asList(2, 3))).containsExactly(2, 2, 3, 3);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(2, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(2);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(3);
 
     // duplicate keys are ignored, and don't impact stats
-    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));
+    assertThat(cache.getAll(asList(4, 5))).containsExactly(4, 4, 5, 5);
     stats = cache.stats();
-    assertEquals(5, stats.missCount());
-    assertEquals(3, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(4, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(5);
+    assertThat(stats.loadSuccessCount()).isEqualTo(3);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(4);
   }
 
   public void testBulkLoad_extra() throws ExecutionException {
@@ -452,10 +452,10 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
     for (Entry<Object, Object> entry : result.entrySet()) {
       Object key = entry.getKey();
       Object value = entry.getValue();
-      assertSame(value, result.get(key));
-      assertNull(result.get(value));
-      assertSame(value, cache.asMap().get(key));
-      assertSame(key, cache.asMap().get(value));
+      assertThat(result.get(key)).isSameInstanceAs(value);
+      assertThat(result.get(value)).isNull();
+      assertThat(cache.asMap().get(key)).isSameInstanceAs(value);
+      assertThat(cache.asMap().get(value)).isSameInstanceAs(key);
     }
   }
 
@@ -482,7 +482,7 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
         };
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);
     cache.asMap().put(extraKey, extraKey);
-    assertSame(extraKey, cache.asMap().get(extraKey));
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);
 
     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
     Map<Object, Object> result = cache.getAll(asList(lookupKeys));
@@ -490,11 +490,11 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
     for (Entry<Object, Object> entry : result.entrySet()) {
       Object key = entry.getKey();
       Object value = entry.getValue();
-      assertSame(value, result.get(key));
-      assertSame(value, cache.asMap().get(key));
+      assertThat(result.get(key)).isSameInstanceAs(value);
+      assertThat(cache.asMap().get(key)).isSameInstanceAs(value);
     }
-    assertNull(result.get(extraKey));
-    assertSame(extraValue, cache.asMap().get(extraKey));
+    assertThat(result.get(extraKey)).isNull();
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);
   }
 
   public void testBulkLoad_clobberNullValue() throws ExecutionException {
@@ -521,16 +521,16 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
         };
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);
     cache.asMap().put(extraKey, extraKey);
-    assertSame(extraKey, cache.asMap().get(extraKey));
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);
 
     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));
 
     for (Object key : lookupKeys) {
-      assertTrue(cache.asMap().containsKey(key));
+      assertThat(cache.asMap().containsKey(key)).isTrue();
     }
-    assertSame(extraValue, cache.asMap().get(extraKey));
-    assertFalse(cache.asMap().containsKey(extraValue));
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);
+    assertThat(cache.asMap().containsKey(extraValue)).isFalse();
   }
 
   public void testBulkLoad_clobberNullKey() throws ExecutionException {
@@ -557,16 +557,16 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
         };
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);
     cache.asMap().put(extraKey, extraKey);
-    assertSame(extraKey, cache.asMap().get(extraKey));
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);
 
     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));
 
     for (Object key : lookupKeys) {
-      assertTrue(cache.asMap().containsKey(key));
+      assertThat(cache.asMap().containsKey(key)).isTrue();
     }
-    assertSame(extraValue, cache.asMap().get(extraKey));
-    assertFalse(cache.asMap().containsValue(extraKey));
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);
+    assertThat(cache.asMap().containsValue(extraKey)).isFalse();
   }
 
   public void testBulkLoad_partial() throws ExecutionException {
@@ -591,54 +591,54 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
 
     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};
     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));
-    assertSame(extraValue, cache.asMap().get(extraKey));
+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);
   }
 
   public void testLoadNull() throws ExecutionException {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(constantLoader(null));
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     assertThrows(InvalidCacheLoadException.class, () -> cache.get(new Object()));
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(new Object()));
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(new Object());
     checkLoggedInvalidLoad();
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(3, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(3);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     assertThrows(
         InvalidCacheLoadException.class, () -> cache.get(new Object(), Callables.returning(null)));
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(4, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(4);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(5, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(5);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testReloadNull() throws ExecutionException {
@@ -659,32 +659,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedInvalidLoad();
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testReloadNullFuture() throws ExecutionException {
@@ -705,32 +705,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedInvalidLoad();
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testRefreshNull() {
@@ -757,59 +757,59 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
             .build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     // refreshed
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(3);
   }
 
   public void testBulkLoadNull() throws ExecutionException {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(bulkLoader(constantLoader(null)));
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testBulkLoadNullMap() throws ExecutionException {
@@ -830,17 +830,17 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {
                 });
 
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testLoadError() throws ExecutionException {
@@ -848,34 +848,34 @@ public void testLoadError() throws ExecutionException {
     CacheLoader<Object, Object> loader = errorLoader(e);
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ExecutionError expected = assertThrows(ExecutionError.class, () -> cache.get(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected = assertThrows(ExecutionError.class, () -> cache.getUnchecked(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(new Object());
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(3, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(3);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Error callableError = new Error();
     expected =
@@ -892,18 +892,18 @@ public Object call() {
                     }));
     assertThat(expected).hasCauseThat().isSameInstanceAs(callableError);
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(4, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(4);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected = assertThrows(ExecutionError.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(5, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(5);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testReloadError() throws ExecutionException {
@@ -925,32 +925,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testReloadFutureError() throws ExecutionException {
@@ -972,32 +972,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testRefreshError() {
@@ -1025,42 +1025,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
             .build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     // refreshed
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(3);
   }
 
   public void testBulkLoadError() throws ExecutionException {
@@ -1069,19 +1069,19 @@ public void testBulkLoadError() throws ExecutionException {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ExecutionError expected =
         assertThrows(ExecutionError.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testLoadCheckedException() {
@@ -1089,35 +1089,35 @@ public void testLoadCheckedException() {
     CacheLoader<Object, Object> loader = exceptionLoader(e);
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Exception expected = assertThrows(ExecutionException.class, () -> cache.get(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected =
         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(new Object());
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(3, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(3);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Exception callableException = new Exception();
     expected =
@@ -1125,18 +1125,18 @@ public void testLoadCheckedException() {
             ExecutionException.class, () -> cache.get(new Object(), throwing(callableException)));
     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(4, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(4);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected = assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(5, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(5);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testLoadInterruptedException() {
@@ -1144,62 +1144,62 @@ public void testLoadInterruptedException() {
     CacheLoader<Object, Object> loader = exceptionLoader(e);
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     // Sanity check:
-    assertFalse(Thread.interrupted());
+    assertThat(Thread.interrupted()).isFalse();
 
     Exception expected = assertThrows(ExecutionException.class, () -> cache.get(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
-    assertTrue(Thread.interrupted());
+    assertThat(Thread.interrupted()).isTrue();
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected =
         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
-    assertTrue(Thread.interrupted());
+    assertThat(Thread.interrupted()).isTrue();
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(new Object());
-    assertTrue(Thread.interrupted());
+    assertThat(Thread.interrupted()).isTrue();
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(3, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(3);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Exception callableException = new InterruptedException();
     expected =
         assertThrows(
             ExecutionException.class, () -> cache.get(new Object(), throwing(callableException)));
     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
-    assertTrue(Thread.interrupted());
+    assertThat(Thread.interrupted()).isTrue();
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(4, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(4);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected = assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
-    assertTrue(Thread.interrupted());
+    assertThat(Thread.interrupted()).isTrue();
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(5, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(5);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testReloadCheckedException() {
@@ -1221,32 +1221,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) throws Excep
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testReloadFutureCheckedException() {
@@ -1268,32 +1268,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testRefreshCheckedException() {
@@ -1321,42 +1321,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
             .build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     // refreshed
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(3);
   }
 
   public void testBulkLoadCheckedException() {
@@ -1365,19 +1365,19 @@ public void testBulkLoadCheckedException() {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ExecutionException expected =
         assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testBulkLoadInterruptedException() {
@@ -1386,20 +1386,20 @@ public void testBulkLoadInterruptedException() {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ExecutionException expected =
         assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
-    assertTrue(Thread.interrupted());
+    assertThat(Thread.interrupted()).isTrue();
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testLoadUncheckedException() throws ExecutionException {
@@ -1407,36 +1407,36 @@ public void testLoadUncheckedException() throws ExecutionException {
     CacheLoader<Object, Object> loader = exceptionLoader(e);
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     UncheckedExecutionException expected =
         assertThrows(UncheckedExecutionException.class, () -> cache.get(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected =
         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(new Object());
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(3, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(3);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Exception callableException = new RuntimeException();
     expected =
@@ -1445,19 +1445,19 @@ public void testLoadUncheckedException() throws ExecutionException {
             () -> cache.get(new Object(), throwing(callableException)));
     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(4, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(4);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     expected =
         assertThrows(UncheckedExecutionException.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(4, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(5, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(4);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(5);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testReloadUncheckedException() throws ExecutionException {
@@ -1479,32 +1479,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) throws Excep
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testReloadFutureUncheckedException() throws ExecutionException {
@@ -1526,32 +1526,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.refresh(key);
     checkLoggedCause(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(1);
   }
 
   public void testRefreshUncheckedException() {
@@ -1579,42 +1579,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
             .build(loader);
     Object key = new Object();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     // refreshed
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(2);
 
     ticker.advance(1, MILLISECONDS);
-    assertSame(one, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(1, stats.loadSuccessCount());
-    assertEquals(2, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(1);
+    assertThat(stats.loadExceptionCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(3);
   }
 
   public void testBulkLoadUncheckedException() throws ExecutionException {
@@ -1623,19 +1623,19 @@ public void testBulkLoadUncheckedException() throws ExecutionException {
     LoadingCache<Object, Object> cache =
         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     UncheckedExecutionException expected =
         assertThrows(UncheckedExecutionException.class, () -> cache.getAll(asList(new Object())));
     assertThat(expected).hasCauseThat().isSameInstanceAs(e);
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(1, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
   }
 
   public void testReloadAfterFailure() throws ExecutionException {
@@ -1660,15 +1660,15 @@ public String load(Integer key) throws Exception {
         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(1));
     assertThat(ue).hasCauseThat().isSameInstanceAs(e);
 
-    assertEquals("1", cache.getUnchecked(1));
-    assertEquals(0, removalListener.getCount());
+    assertThat(cache.getUnchecked(1)).isEqualTo("1");
+    assertThat(removalListener.getCount()).isEqualTo(0);
 
     count.set(0);
     cache.refresh(2);
     checkLoggedCause(e);
 
-    assertEquals("2", cache.getUnchecked(2));
-    assertEquals(0, removalListener.getCount());
+    assertThat(cache.getUnchecked(2)).isEqualTo("2");
+    assertThat(removalListener.getCount()).isEqualTo(0);
   }
 
 
@@ -1693,7 +1693,7 @@ public void testReloadAfterValueReclamation() throws InterruptedException, Execu
       Thread.sleep(i);
       System.gc();
     }
-    assertEquals(expectedComputations, countingLoader.getCount());
+    assertThat(countingLoader.getCount()).isEqualTo(expectedComputations);
 
     for (int i = 0; i < iterations; i++) {
       // The entry should get garbage collected and recomputed.
@@ -1708,7 +1708,7 @@ public void testReloadAfterValueReclamation() throws InterruptedException, Execu
       Thread.sleep(i);
       System.gc();
     }
-    assertEquals(expectedComputations, countingLoader.getCount());
+    assertThat(countingLoader.getCount()).isEqualTo(expectedComputations);
   }
 
   public void testReloadAfterSimulatedValueReclamation() throws ExecutionException {
@@ -1717,20 +1717,20 @@ public void testReloadAfterSimulatedValueReclamation() throws ExecutionException
         CacheBuilder.newBuilder().concurrencyLevel(1).weakValues().build(countingLoader);
 
     Object key = new Object();
-    assertNotNull(cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isNotNull();
 
     CacheTesting.simulateValueReclamation(cache, key);
 
     // this blocks if computation can't deal with partially-collected values
-    assertNotNull(cache.getUnchecked(key));
-    assertEquals(1, cache.size());
-    assertEquals(2, countingLoader.getCount());
+    assertThat(cache.getUnchecked(key)).isNotNull();
+    assertThat(cache.size()).isEqualTo(1);
+    assertThat(countingLoader.getCount()).isEqualTo(2);
 
     CacheTesting.simulateValueReclamation(cache, key);
     cache.refresh(key);
     checkNothingLogged();
-    assertEquals(1, cache.size());
-    assertEquals(3, countingLoader.getCount());
+    assertThat(cache.size()).isEqualTo(1);
+    assertThat(countingLoader.getCount()).isEqualTo(3);
   }
 
   public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {
@@ -1739,19 +1739,19 @@ public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {
         CacheBuilder.newBuilder().concurrencyLevel(1).weakKeys().build(countingLoader);
 
     Object key = new Object();
-    assertNotNull(cache.getUnchecked(key));
-    assertEquals(1, cache.size());
+    assertThat(cache.getUnchecked(key)).isNotNull();
+    assertThat(cache.size()).isEqualTo(1);
 
     CacheTesting.simulateKeyReclamation(cache, key);
 
     // this blocks if computation can't deal with partially-collected values
-    assertNotNull(cache.getUnchecked(key));
-    assertEquals(2, countingLoader.getCount());
+    assertThat(cache.getUnchecked(key)).isNotNull();
+    assertThat(countingLoader.getCount()).isEqualTo(2);
 
     CacheTesting.simulateKeyReclamation(cache, key);
     cache.refresh(key);
     checkNothingLogged();
-    assertEquals(3, countingLoader.getCount());
+    assertThat(countingLoader.getCount()).isEqualTo(3);
   }
 
   /**
@@ -1864,9 +1864,11 @@ public Object load(String key) throws InterruptedException {
 
     List<Object> resultArray = doConcurrentGet(cache, "bar", count, startSignal);
 
-    assertEquals(1, callCount.get());
+    assertThat(callCount.get()).isEqualTo(1);
     for (int i = 0; i < count; i++) {
-      assertSame("result(" + i + ") didn't match expected", result, resultArray.get(i));
+      assertWithMessage("result(%s) didn't match expected", i)
+          .that(resultArray.get(i))
+          .isSameInstanceAs(result);
     }
   }
 
@@ -1896,18 +1898,14 @@ public String load(String key) throws InterruptedException {
 
     List<Object> result = doConcurrentGet(cache, "bar", count, startSignal);
 
-    assertEquals(1, callCount.get());
+    assertThat(callCount.get()).isEqualTo(1);
     for (int i = 0; i < count; i++) {
       assertThat(result.get(i)).isInstanceOf(InvalidCacheLoadException.class);
     }
 
     // subsequent calls should call the loader again, not get the old exception
-    try {
-      cache.getUnchecked("bar");
-      fail();
-    } catch (InvalidCacheLoadException expected) {
-    }
-    assertEquals(2, callCount.get());
+    assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked("bar"));
+    assertThat(callCount.get()).isEqualTo(2);
   }
 
   /**
@@ -1936,7 +1934,7 @@ public String load(String key) throws InterruptedException {
 
     List<Object> result = doConcurrentGet(cache, "bar", count, startSignal);
 
-    assertEquals(1, callCount.get());
+    assertThat(callCount.get()).isEqualTo(1);
     for (int i = 0; i < count; i++) {
       // doConcurrentGet alternates between calling getUnchecked and calling get, but an unchecked
       // exception thrown by the loader is always wrapped as an UncheckedExecutionException.
@@ -1945,12 +1943,8 @@ public String load(String key) throws InterruptedException {
     }
 
     // subsequent calls should call the loader again, not get the old exception
-    try {
-      cache.getUnchecked("bar");
-      fail();
-    } catch (UncheckedExecutionException expected) {
-    }
-    assertEquals(2, callCount.get());
+    assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked("bar"));
+    assertThat(callCount.get()).isEqualTo(2);
   }
 
   /**
@@ -1979,7 +1973,7 @@ public String load(String key) throws IOException, InterruptedException {
 
     List<Object> result = doConcurrentGet(cache, "bar", count, startSignal);
 
-    assertEquals(1, callCount.get());
+    assertThat(callCount.get()).isEqualTo(1);
     for (int i = 0; i < count; i++) {
       // doConcurrentGet alternates between calling getUnchecked and calling get. If we call get(),
       // we should get an ExecutionException; if we call getUnchecked(), we should get an
@@ -1995,12 +1989,8 @@ public String load(String key) throws IOException, InterruptedException {
     }
 
     // subsequent calls should call the loader again, not get the old exception
-    try {
-      cache.getUnchecked("bar");
-      fail();
-    } catch (UncheckedExecutionException expected) {
-    }
-    assertEquals(2, callCount.get());
+    assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked("bar"));
+    assertThat(callCount.get()).isEqualTo(2);
   }
 
   /**
@@ -2084,9 +2074,9 @@ public String load(String key) throws InterruptedException {
     LoadingCache<String, String> cache = CacheBuilder.newBuilder().build(computeFunction);
     ConcurrentMap<String, String> map = cache.asMap();
     map.put(refreshKey, refreshKey);
-    assertEquals(1, map.size());
-    assertFalse(map.containsKey(getKey));
-    assertSame(refreshKey, map.get(refreshKey));
+    assertThat(map).hasSize(1);
+    assertThat(map.containsKey(getKey)).isFalse();
+    assertThat(map.get(refreshKey)).isSameInstanceAs(refreshKey);
 
     new Thread() {
       @Override
@@ -2106,9 +2096,9 @@ public void run() {
     getStartedSignal.await();
 
     // computation is in progress; asMap shouldn't have changed
-    assertEquals(1, map.size());
-    assertFalse(map.containsKey(getKey));
-    assertSame(refreshKey, map.get(refreshKey));
+    assertThat(map).hasSize(1);
+    assertThat(map.containsKey(getKey)).isFalse();
+    assertThat(map.get(refreshKey)).isSameInstanceAs(refreshKey);
 
     // let computation complete
     letGetFinishSignal.countDown();
@@ -2116,9 +2106,9 @@ public void run() {
     checkNothingLogged();
 
     // asMap view should have been updated
-    assertEquals(2, cache.size());
-    assertEquals(getKey + suffix, map.get(getKey));
-    assertEquals(refreshKey + suffix, map.get(refreshKey));
+    assertThat(cache.size()).isEqualTo(2);
+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);
+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);
   }
 
   public void testInvalidateDuringLoading() throws InterruptedException, ExecutionException {
@@ -2162,8 +2152,8 @@ public void run() {
     computationStarted.await();
     cache.invalidate(getKey);
     cache.invalidate(refreshKey);
-    assertFalse(map.containsKey(getKey));
-    assertFalse(map.containsKey(refreshKey));
+    assertThat(map.containsKey(getKey)).isFalse();
+    assertThat(map.containsKey(refreshKey)).isFalse();
 
     // let computation complete
     letGetFinishSignal.countDown();
@@ -2171,10 +2161,10 @@ public void run() {
     checkNothingLogged();
 
     // results should be visible
-    assertEquals(2, cache.size());
-    assertEquals(getKey + suffix, map.get(getKey));
-    assertEquals(refreshKey + suffix, map.get(refreshKey));
-    assertEquals(2, cache.size());
+    assertThat(cache.size()).isEqualTo(2);
+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);
+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);
+    assertThat(cache.size()).isEqualTo(2);
   }
 
   public void testInvalidateAndReloadDuringLoading()
@@ -2219,8 +2209,8 @@ public void run() {
     computationStarted.await();
     cache.invalidate(getKey);
     cache.invalidate(refreshKey);
-    assertFalse(map.containsKey(getKey));
-    assertFalse(map.containsKey(refreshKey));
+    assertThat(map.containsKey(getKey)).isFalse();
+    assertThat(map.containsKey(refreshKey)).isFalse();
 
     // start new computations
     new Thread() {
@@ -2244,9 +2234,9 @@ public void run() {
     checkNothingLogged();
 
     // results should be visible
-    assertEquals(2, cache.size());
-    assertEquals(getKey + suffix, map.get(getKey));
-    assertEquals(refreshKey + suffix, map.get(refreshKey));
+    assertThat(cache.size()).isEqualTo(2);
+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);
+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);
   }
 
   @SuppressWarnings("ThreadPriorityCheck") // doing our best to test for races
@@ -2331,11 +2321,11 @@ public void run() {
     computeSignal.countDown();
     doneSignal.await();
 
-    assertTrue(callCount.get() == 1);
-    assertEquals("barfoo", result.get(0));
-    assertEquals("barfoo", result.get(1));
-    assertEquals("barfoo", result.get(2));
-    assertEquals("barfoo", cache.getUnchecked(key));
+    assertThat(callCount.get()).isEqualTo(1);
+    assertThat(result.get(0)).isEqualTo("barfoo");
+    assertThat(result.get(1)).isEqualTo("barfoo");
+    assertThat(result.get(2)).isEqualTo("barfoo");
+    assertThat(cache.getUnchecked(key)).isEqualTo("barfoo");
   }
 
   // Test ignored because it is extremely flaky in CI builds
@@ -2423,10 +2413,10 @@ public void run() {
     computeSignal.countDown();
     doneSignal.await();
 
-    assertTrue(callCount.get() == 1);
-    assertEquals(key, result.get(0));
-    assertEquals(key, result.get(1));
-    assertEquals(key + suffix, cache.getUnchecked(key));
+    assertThat(callCount.get()).isEqualTo(1);
+    assertThat(result.get(0)).isEqualTo(key);
+    assertThat(result.get(1)).isEqualTo(key);
+    assertThat(cache.getUnchecked(key)).isEqualTo(key + suffix);
   }
 
   static <T> Callable<T> throwing(Exception exception) {
diff --git a/guava-tests/test/com/google/common/cache/CacheManualTest.java b/guava-tests/test/com/google/common/cache/CacheManualTest.java
index a2cf24dcef28..e3b358a738b0 100644
--- a/guava-tests/test/com/google/common/cache/CacheManualTest.java
+++ b/guava-tests/test/com/google/common/cache/CacheManualTest.java
@@ -14,6 +14,7 @@
 
 package com.google.common.cache;
 
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.Arrays.asList;
 
 import com.google.common.collect.ImmutableList;
@@ -30,126 +31,127 @@ public class CacheManualTest extends TestCase {
   public void testGetIfPresent() {
     Cache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     Object one = new Object();
     Object two = new Object();
 
-    assertNull(cache.getIfPresent(one));
+    assertThat(cache.getIfPresent(one)).isNull();
     stats = cache.stats();
-    assertEquals(1, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
-    assertNull(cache.asMap().get(one));
-    assertFalse(cache.asMap().containsKey(one));
-    assertFalse(cache.asMap().containsValue(two));
-
-    assertNull(cache.getIfPresent(two));
+    assertThat(stats.missCount()).isEqualTo(1);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
+    assertThat(cache.asMap().get(one)).isNull();
+    assertThat(cache.asMap().containsKey(one)).isFalse();
+    assertThat(cache.asMap().containsValue(two)).isFalse();
+
+    assertThat(cache.getIfPresent(two)).isNull();
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
-    assertNull(cache.asMap().get(two));
-    assertFalse(cache.asMap().containsKey(two));
-    assertFalse(cache.asMap().containsValue(one));
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
+    assertThat(cache.asMap().get(two)).isNull();
+    assertThat(cache.asMap().containsKey(two)).isFalse();
+    assertThat(cache.asMap().containsValue(one)).isFalse();
 
     cache.put(one, two);
 
-    assertSame(two, cache.getIfPresent(one));
+    assertThat(cache.getIfPresent(one)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(2, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
-    assertSame(two, cache.asMap().get(one));
-    assertTrue(cache.asMap().containsKey(one));
-    assertTrue(cache.asMap().containsValue(two));
-
-    assertNull(cache.getIfPresent(two));
+    assertThat(stats.missCount()).isEqualTo(2);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
+    assertThat(cache.asMap().get(one)).isSameInstanceAs(two);
+    assertThat(cache.asMap().containsKey(one)).isTrue();
+    assertThat(cache.asMap().containsValue(two)).isTrue();
+
+    assertThat(cache.getIfPresent(two)).isNull();
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
-    assertNull(cache.asMap().get(two));
-    assertFalse(cache.asMap().containsKey(two));
-    assertFalse(cache.asMap().containsValue(one));
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
+    assertThat(cache.asMap().get(two)).isNull();
+    assertThat(cache.asMap().containsKey(two)).isFalse();
+    assertThat(cache.asMap().containsValue(one)).isFalse();
 
     cache.put(two, one);
 
-    assertSame(two, cache.getIfPresent(one));
+    assertThat(cache.getIfPresent(one)).isSameInstanceAs(two);
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(2, stats.hitCount());
-    assertSame(two, cache.asMap().get(one));
-    assertTrue(cache.asMap().containsKey(one));
-    assertTrue(cache.asMap().containsValue(two));
-
-    assertSame(one, cache.getIfPresent(two));
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(2);
+    assertThat(cache.asMap().get(one)).isSameInstanceAs(two);
+    assertThat(cache.asMap().containsKey(one)).isTrue();
+    assertThat(cache.asMap().containsValue(two)).isTrue();
+
+    assertThat(cache.getIfPresent(two)).isSameInstanceAs(one);
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
-    assertSame(one, cache.asMap().get(two));
-    assertTrue(cache.asMap().containsKey(two));
-    assertTrue(cache.asMap().containsValue(one));
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(3);
+    assertThat(cache.asMap().get(two)).isSameInstanceAs(one);
+    assertThat(cache.asMap().containsKey(two)).isTrue();
+    assertThat(cache.asMap().containsValue(one)).isTrue();
   }
 
   public void testGetAllPresent() {
     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().recordStats().build();
     CacheStats stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(), cache.getAllPresent(ImmutableList.<Integer>of()));
+    assertThat(cache.getAllPresent(ImmutableList.<Integer>of())).isEmpty();
     stats = cache.stats();
-    assertEquals(0, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(0);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
-    assertEquals(ImmutableMap.of(), cache.getAllPresent(asList(1, 2, 3)));
+    assertThat(cache.getAllPresent(asList(1, 2, 3))).isEqualTo(ImmutableMap.of());
     stats = cache.stats();
-    assertEquals(3, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(3);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
 
     cache.put(2, 22);
 
-    assertEquals(ImmutableMap.of(2, 22), cache.getAllPresent(asList(1, 2, 3)));
+    assertThat(cache.getAllPresent(asList(1, 2, 3))).containsExactly(2, 22);
     stats = cache.stats();
-    assertEquals(5, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(5);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(1);
 
     cache.put(3, 33);
 
-    assertEquals(ImmutableMap.of(2, 22, 3, 33), cache.getAllPresent(asList(1, 2, 3)));
+    assertThat(cache.getAllPresent(asList(1, 2, 3))).containsExactly(2, 22, 3, 33);
     stats = cache.stats();
-    assertEquals(6, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(3, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(6);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(3);
 
     cache.put(1, 11);
 
-    assertEquals(ImmutableMap.of(1, 11, 2, 22, 3, 33), cache.getAllPresent(asList(1, 2, 3)));
+    assertThat(cache.getAllPresent(asList(1, 2, 3)))
+        .isEqualTo(ImmutableMap.of(1, 11, 2, 22, 3, 33));
     stats = cache.stats();
-    assertEquals(6, stats.missCount());
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
-    assertEquals(6, stats.hitCount());
+    assertThat(stats.missCount()).isEqualTo(6);
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(6);
   }
 }
diff --git a/guava-tests/test/com/google/common/cache/CacheReferencesTest.java b/guava-tests/test/com/google/common/cache/CacheReferencesTest.java
index 5426d29141f5..11ce62e0a0b1 100644
--- a/guava-tests/test/com/google/common/cache/CacheReferencesTest.java
+++ b/guava-tests/test/com/google/common/cache/CacheReferencesTest.java
@@ -66,10 +66,10 @@ public void testContainsKeyAndValue() {
       // maintain strong refs so these won't be collected, regardless of cache's key/value strength
       Key key = new Key(1);
       String value = key.toString();
-      assertSame(value, cache.getUnchecked(key));
-      assertTrue(cache.asMap().containsKey(key));
-      assertTrue(cache.asMap().containsValue(value));
-      assertEquals(1, cache.size());
+      assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);
+      assertThat(cache.asMap().containsKey(key)).isTrue();
+      assertThat(cache.asMap().containsValue(value)).isTrue();
+      assertThat(cache.size()).isEqualTo(1);
     }
   }
 
@@ -77,13 +77,13 @@ public void testClear() {
     for (LoadingCache<Key, String> cache : caches()) {
       Key key = new Key(1);
       String value = key.toString();
-      assertSame(value, cache.getUnchecked(key));
-      assertFalse(cache.asMap().isEmpty());
+      assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);
+      assertThat(cache.asMap().isEmpty()).isFalse();
       cache.invalidateAll();
-      assertEquals(0, cache.size());
-      assertTrue(cache.asMap().isEmpty());
-      assertFalse(cache.asMap().containsKey(key));
-      assertFalse(cache.asMap().containsValue(value));
+      assertThat(cache.size()).isEqualTo(0);
+      assertThat(cache.asMap().isEmpty()).isTrue();
+      assertThat(cache.asMap().containsKey(key)).isFalse();
+      assertThat(cache.asMap().containsValue(value)).isFalse();
     }
   }
 
@@ -93,13 +93,12 @@ public void testKeySetEntrySetValues() {
       String value1 = key1.toString();
       Key key2 = new Key(2);
       String value2 = key2.toString();
-      assertSame(value1, cache.getUnchecked(key1));
-      assertSame(value2, cache.getUnchecked(key2));
-      assertEquals(ImmutableSet.of(key1, key2), cache.asMap().keySet());
+      assertThat(cache.getUnchecked(key1)).isSameInstanceAs(value1);
+      assertThat(cache.getUnchecked(key2)).isSameInstanceAs(value2);
+      assertThat(cache.asMap().keySet()).isEqualTo(ImmutableSet.of(key1, key2));
       assertThat(cache.asMap().values()).containsExactly(value1, value2);
-      assertEquals(
-          ImmutableSet.of(immutableEntry(key1, value1), immutableEntry(key2, value2)),
-          cache.asMap().entrySet());
+      assertThat(cache.asMap().entrySet())
+          .containsExactly(immutableEntry(key1, value1), immutableEntry(key2, value2));
     }
   }
 
@@ -109,15 +108,15 @@ public void testInvalidate() {
       String value1 = key1.toString();
       Key key2 = new Key(2);
       String value2 = key2.toString();
-      assertSame(value1, cache.getUnchecked(key1));
-      assertSame(value2, cache.getUnchecked(key2));
+      assertThat(cache.getUnchecked(key1)).isSameInstanceAs(value1);
+      assertThat(cache.getUnchecked(key2)).isSameInstanceAs(value2);
       cache.invalidate(key1);
-      assertFalse(cache.asMap().containsKey(key1));
-      assertTrue(cache.asMap().containsKey(key2));
-      assertEquals(1, cache.size());
-      assertEquals(ImmutableSet.of(key2), cache.asMap().keySet());
+      assertThat(cache.asMap().containsKey(key1)).isFalse();
+      assertThat(cache.asMap().containsKey(key2)).isTrue();
+      assertThat(cache.size()).isEqualTo(1);
+      assertThat(cache.asMap().keySet()).isEqualTo(ImmutableSet.of(key2));
       assertThat(cache.asMap().values()).contains(value2);
-      assertEquals(ImmutableSet.of(immutableEntry(key2, value2)), cache.asMap().entrySet());
+      assertThat(cache.asMap().entrySet()).containsExactly(immutableEntry(key2, value2));
     }
   }
 
diff --git a/guava-tests/test/com/google/common/cache/CacheRefreshTest.java b/guava-tests/test/com/google/common/cache/CacheRefreshTest.java
index 6a7948c470dc..83c3ea3b5777 100644
--- a/guava-tests/test/com/google/common/cache/CacheRefreshTest.java
+++ b/guava-tests/test/com/google/common/cache/CacheRefreshTest.java
@@ -15,6 +15,7 @@
 package com.google.common.cache;
 
 import static com.google.common.cache.TestingCacheLoaders.incrementingLoader;
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 import com.google.common.cache.TestingCacheLoaders.IncrementingLoader;
@@ -42,61 +43,61 @@ public void testAutoRefresh() {
     int expectedLoads = 0;
     int expectedReloads = 0;
     for (int i = 0; i < 3; i++) {
-      assertEquals(Integer.valueOf(i), cache.getUnchecked(i));
+      assertThat(cache.getUnchecked(i)).isEqualTo(i);
       expectedLoads++;
-      assertEquals(expectedLoads, loader.getLoadCount());
-      assertEquals(expectedReloads, loader.getReloadCount());
+      assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+      assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
       ticker.advance(1, MILLISECONDS);
     }
 
-    assertEquals(Integer.valueOf(0), cache.getUnchecked(0));
-    assertEquals(Integer.valueOf(1), cache.getUnchecked(1));
-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));
-    assertEquals(expectedLoads, loader.getLoadCount());
-    assertEquals(expectedReloads, loader.getReloadCount());
+    assertThat(cache.getUnchecked(0)).isEqualTo(0);
+    assertThat(cache.getUnchecked(1)).isEqualTo(1);
+    assertThat(cache.getUnchecked(2)).isEqualTo(2);
+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
 
     // refresh 0
     ticker.advance(1, MILLISECONDS);
-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));
+    assertThat(cache.getUnchecked(0)).isEqualTo(1);
     expectedReloads++;
-    assertEquals(Integer.valueOf(1), cache.getUnchecked(1));
-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));
-    assertEquals(expectedLoads, loader.getLoadCount());
-    assertEquals(expectedReloads, loader.getReloadCount());
+    assertThat(cache.getUnchecked(1)).isEqualTo(1);
+    assertThat(cache.getUnchecked(2)).isEqualTo(2);
+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
 
     // write to 1 to delay its refresh
     cache.asMap().put(1, -1);
     ticker.advance(1, MILLISECONDS);
-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));
-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));
-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));
-    assertEquals(expectedLoads, loader.getLoadCount());
-    assertEquals(expectedReloads, loader.getReloadCount());
+    assertThat(cache.getUnchecked(0)).isEqualTo(1);
+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);
+    assertThat(cache.getUnchecked(2)).isEqualTo(2);
+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
 
     // refresh 2
     ticker.advance(1, MILLISECONDS);
-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));
-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));
-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));
+    assertThat(cache.getUnchecked(0)).isEqualTo(1);
+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);
+    assertThat(cache.getUnchecked(2)).isEqualTo(3);
     expectedReloads++;
-    assertEquals(expectedLoads, loader.getLoadCount());
-    assertEquals(expectedReloads, loader.getReloadCount());
+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
 
     ticker.advance(1, MILLISECONDS);
-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));
-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));
-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));
-    assertEquals(expectedLoads, loader.getLoadCount());
-    assertEquals(expectedReloads, loader.getReloadCount());
+    assertThat(cache.getUnchecked(0)).isEqualTo(1);
+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);
+    assertThat(cache.getUnchecked(2)).isEqualTo(3);
+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
 
     // refresh 0 and 1
     ticker.advance(1, MILLISECONDS);
-    assertEquals(Integer.valueOf(2), cache.getUnchecked(0));
+    assertThat(cache.getUnchecked(0)).isEqualTo(2);
     expectedReloads++;
-    assertEquals(Integer.valueOf(0), cache.getUnchecked(1));
+    assertThat(cache.getUnchecked(1)).isEqualTo(0);
     expectedReloads++;
-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));
-    assertEquals(expectedLoads, loader.getLoadCount());
-    assertEquals(expectedReloads, loader.getReloadCount());
+    assertThat(cache.getUnchecked(2)).isEqualTo(3);
+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);
+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);
   }
 }
diff --git a/guava-tests/test/com/google/common/cache/CacheStatsTest.java b/guava-tests/test/com/google/common/cache/CacheStatsTest.java
index cfd174aea242..72cbfee29807 100644
--- a/guava-tests/test/com/google/common/cache/CacheStatsTest.java
+++ b/guava-tests/test/com/google/common/cache/CacheStatsTest.java
@@ -31,34 +31,34 @@ public class CacheStatsTest extends TestCase {
 
   public void testEmpty() {
     CacheStats stats = new CacheStats(0, 0, 0, 0, 0, 0);
-    assertEquals(0, stats.requestCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(0);
+    assertThat(stats.hitCount()).isEqualTo(0);
     assertThat(stats.hitRate()).isEqualTo(1.0);
-    assertEquals(0, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(0);
     assertThat(stats.missRate()).isEqualTo(0.0);
-    assertEquals(0, stats.loadSuccessCount());
-    assertEquals(0, stats.loadExceptionCount());
+    assertThat(stats.loadSuccessCount()).isEqualTo(0);
+    assertThat(stats.loadExceptionCount()).isEqualTo(0);
     assertThat(stats.loadExceptionRate()).isEqualTo(0.0);
-    assertEquals(0, stats.loadCount());
-    assertEquals(0, stats.totalLoadTime());
+    assertThat(stats.loadCount()).isEqualTo(0);
+    assertThat(stats.totalLoadTime()).isEqualTo(0);
     assertThat(stats.averageLoadPenalty()).isEqualTo(0.0);
-    assertEquals(0, stats.evictionCount());
+    assertThat(stats.evictionCount()).isEqualTo(0);
   }
 
   public void testSingle() {
     CacheStats stats = new CacheStats(11, 13, 17, 19, 23, 27);
-    assertEquals(24, stats.requestCount());
-    assertEquals(11, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(24);
+    assertThat(stats.hitCount()).isEqualTo(11);
     assertThat(stats.hitRate()).isEqualTo(11.0 / 24);
-    assertEquals(13, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(13);
     assertThat(stats.missRate()).isEqualTo(13.0 / 24);
-    assertEquals(17, stats.loadSuccessCount());
-    assertEquals(19, stats.loadExceptionCount());
+    assertThat(stats.loadSuccessCount()).isEqualTo(17);
+    assertThat(stats.loadExceptionCount()).isEqualTo(19);
     assertThat(stats.loadExceptionRate()).isEqualTo(19.0 / 36);
-    assertEquals(17 + 19, stats.loadCount());
-    assertEquals(23, stats.totalLoadTime());
+    assertThat(stats.loadCount()).isEqualTo(17 + 19);
+    assertThat(stats.totalLoadTime()).isEqualTo(23);
     assertThat(stats.averageLoadPenalty()).isEqualTo(23.0 / (17 + 19));
-    assertEquals(27, stats.evictionCount());
+    assertThat(stats.evictionCount()).isEqualTo(27);
   }
 
   public void testMinus() {
@@ -66,20 +66,20 @@ public void testMinus() {
     CacheStats two = new CacheStats(53, 47, 43, 41, 37, 31);
 
     CacheStats diff = two.minus(one);
-    assertEquals(76, diff.requestCount());
-    assertEquals(42, diff.hitCount());
+    assertThat(diff.requestCount()).isEqualTo(76);
+    assertThat(diff.hitCount()).isEqualTo(42);
     assertThat(diff.hitRate()).isEqualTo(42.0 / 76);
-    assertEquals(34, diff.missCount());
+    assertThat(diff.missCount()).isEqualTo(34);
     assertThat(diff.missRate()).isEqualTo(34.0 / 76);
-    assertEquals(26, diff.loadSuccessCount());
-    assertEquals(22, diff.loadExceptionCount());
+    assertThat(diff.loadSuccessCount()).isEqualTo(26);
+    assertThat(diff.loadExceptionCount()).isEqualTo(22);
     assertThat(diff.loadExceptionRate()).isEqualTo(22.0 / 48);
-    assertEquals(26 + 22, diff.loadCount());
-    assertEquals(14, diff.totalLoadTime());
+    assertThat(diff.loadCount()).isEqualTo(26 + 22);
+    assertThat(diff.totalLoadTime()).isEqualTo(14);
     assertThat(diff.averageLoadPenalty()).isEqualTo(14.0 / (26 + 22));
-    assertEquals(4, diff.evictionCount());
+    assertThat(diff.evictionCount()).isEqualTo(4);
 
-    assertEquals(new CacheStats(0, 0, 0, 0, 0, 0), one.minus(two));
+    assertThat(one.minus(two)).isEqualTo(new CacheStats(0, 0, 0, 0, 0, 0));
   }
 
   public void testPlus() {
@@ -87,20 +87,20 @@ public void testPlus() {
     CacheStats two = new CacheStats(53, 47, 41, 39, 37, 35);
 
     CacheStats sum = two.plus(one);
-    assertEquals(124, sum.requestCount());
-    assertEquals(64, sum.hitCount());
+    assertThat(sum.requestCount()).isEqualTo(124);
+    assertThat(sum.hitCount()).isEqualTo(64);
     assertThat(sum.hitRate()).isEqualTo(64.0 / 124);
-    assertEquals(60, sum.missCount());
+    assertThat(sum.missCount()).isEqualTo(60);
     assertThat(sum.missRate()).isEqualTo(60.0 / 124);
-    assertEquals(56, sum.loadSuccessCount());
-    assertEquals(52, sum.loadExceptionCount());
+    assertThat(sum.loadSuccessCount()).isEqualTo(56);
+    assertThat(sum.loadExceptionCount()).isEqualTo(52);
     assertThat(sum.loadExceptionRate()).isEqualTo(52.0 / 108);
-    assertEquals(56 + 52, sum.loadCount());
-    assertEquals(48, sum.totalLoadTime());
+    assertThat(sum.loadCount()).isEqualTo(56 + 52);
+    assertThat(sum.totalLoadTime()).isEqualTo(48);
     assertThat(sum.averageLoadPenalty()).isEqualTo(48.0 / (56 + 52));
-    assertEquals(44, sum.evictionCount());
+    assertThat(sum.evictionCount()).isEqualTo(44);
 
-    assertEquals(sum, one.plus(two));
+    assertThat(one.plus(two)).isEqualTo(sum);
   }
 
   public void testPlusLarge() {
@@ -115,19 +115,19 @@ public void testPlusLarge() {
     CacheStats smallCacheStats = new CacheStats(1, 1, 1, 1, 1, 1);
 
     CacheStats sum = smallCacheStats.plus(maxCacheStats);
-    assertEquals(Long.MAX_VALUE, sum.requestCount());
-    assertEquals(Long.MAX_VALUE, sum.hitCount());
+    assertThat(sum.requestCount()).isEqualTo(Long.MAX_VALUE);
+    assertThat(sum.hitCount()).isEqualTo(Long.MAX_VALUE);
     assertThat(sum.hitRate()).isEqualTo(1.0);
-    assertEquals(Long.MAX_VALUE, sum.missCount());
+    assertThat(sum.missCount()).isEqualTo(Long.MAX_VALUE);
     assertThat(sum.missRate()).isEqualTo(1.0);
-    assertEquals(Long.MAX_VALUE, sum.loadSuccessCount());
-    assertEquals(Long.MAX_VALUE, sum.loadExceptionCount());
+    assertThat(sum.loadSuccessCount()).isEqualTo(Long.MAX_VALUE);
+    assertThat(sum.loadExceptionCount()).isEqualTo(Long.MAX_VALUE);
     assertThat(sum.loadExceptionRate()).isEqualTo(1.0);
-    assertEquals(Long.MAX_VALUE, sum.loadCount());
-    assertEquals(Long.MAX_VALUE, sum.totalLoadTime());
+    assertThat(sum.loadCount()).isEqualTo(Long.MAX_VALUE);
+    assertThat(sum.totalLoadTime()).isEqualTo(Long.MAX_VALUE);
     assertThat(sum.averageLoadPenalty()).isEqualTo(1.0);
-    assertEquals(Long.MAX_VALUE, sum.evictionCount());
+    assertThat(sum.evictionCount()).isEqualTo(Long.MAX_VALUE);
 
-    assertEquals(sum, maxCacheStats.plus(smallCacheStats));
+    assertThat(maxCacheStats.plus(smallCacheStats)).isEqualTo(sum);
   }
 }
diff --git a/guava-tests/test/com/google/common/cache/CacheTesting.java b/guava-tests/test/com/google/common/cache/CacheTesting.java
index 5c27308ed868..6c33cde9d009 100644
--- a/guava-tests/test/com/google/common/cache/CacheTesting.java
+++ b/guava-tests/test/com/google/common/cache/CacheTesting.java
@@ -16,15 +16,9 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static java.lang.Math.max;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.assertNotSame;
-import static junit.framework.Assert.assertNull;
-import static junit.framework.Assert.assertSame;
-import static junit.framework.Assert.assertTrue;
 
 import com.google.common.base.Preconditions;
 import com.google.common.cache.LocalCache.LocalLoadingCache;
@@ -194,16 +188,16 @@ static void checkValidState(Cache<?, ?> cache) {
   static void checkValidState(LocalCache<?, ?> cchm) {
     for (Segment<?, ?> segment : cchm.segments) {
       segment.cleanUp();
-      assertFalse(segment.isLocked());
+      assertThat(segment.isLocked()).isFalse();
       Map<?, ?> table = segmentTable(segment);
       // cleanup and then check count after we have a strong reference to all entries
       segment.cleanUp();
       // under high memory pressure keys/values may be nulled out but not yet enqueued
       assertThat(table.size()).isAtMost(segment.count);
       for (Entry<?, ?> entry : table.entrySet()) {
-        assertNotNull(entry.getKey());
-        assertNotNull(entry.getValue());
-        assertSame(entry.getValue(), cchm.get(entry.getKey()));
+        assertThat(entry.getKey()).isNotNull();
+        assertThat(entry.getValue()).isNotNull();
+        assertThat(cchm.get(entry.getKey())).isSameInstanceAs(entry.getValue());
       }
     }
     checkEviction(cchm);
@@ -228,21 +222,21 @@ static void checkExpiration(LocalCache<?, ?> cchm) {
 
         ReferenceEntry<?, ?> prev = null;
         for (ReferenceEntry<?, ?> current : segment.writeQueue) {
-          assertTrue(entries.add(current));
+          assertThat(entries.add(current)).isTrue();
           if (prev != null) {
-            assertSame(prev, current.getPreviousInWriteQueue());
-            assertSame(prev.getNextInWriteQueue(), current);
+            assertThat(current.getPreviousInWriteQueue()).isSameInstanceAs(prev);
+            assertThat(current).isSameInstanceAs(prev.getNextInWriteQueue());
             assertThat(prev.getWriteTime()).isAtMost(current.getWriteTime());
           }
           Object key = current.getKey();
           if (key != null) {
-            assertSame(current, segment.getEntry(key, current.getHash()));
+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);
           }
           prev = current;
         }
-        assertEquals(segment.count, entries.size());
+        assertThat(entries).hasSize(segment.count);
       } else {
-        assertTrue(segment.writeQueue.isEmpty());
+        assertThat(segment.writeQueue.isEmpty()).isTrue();
       }
 
       if (cchm.usesAccessQueue()) {
@@ -250,24 +244,25 @@ static void checkExpiration(LocalCache<?, ?> cchm) {
 
         ReferenceEntry<?, ?> prev = null;
         for (ReferenceEntry<?, ?> current : segment.accessQueue) {
-          assertTrue(entries.add(current));
+          assertThat(entries.add(current)).isTrue();
           if (prev != null) {
-            assertSame(prev, current.getPreviousInAccessQueue());
-            assertSame(prev.getNextInAccessQueue(), current);
+            assertThat(current.getPreviousInAccessQueue()).isSameInstanceAs(prev);
+            assertThat(current).isSameInstanceAs(prev.getNextInAccessQueue());
             // read accesses may be slightly misordered
-            assertTrue(
-                prev.getAccessTime() <= current.getAccessTime()
-                    || prev.getAccessTime() - current.getAccessTime() < 1000);
+            assertThat(
+                    prev.getAccessTime() <= current.getAccessTime()
+                        || prev.getAccessTime() - current.getAccessTime() < 1000)
+                .isTrue();
           }
           Object key = current.getKey();
           if (key != null) {
-            assertSame(current, segment.getEntry(key, current.getHash()));
+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);
           }
           prev = current;
         }
-        assertEquals(segment.count, entries.size());
+        assertThat(entries).hasSize(segment.count);
       } else {
-        assertTrue(segment.accessQueue.isEmpty());
+        assertThat(segment.accessQueue).isEmpty();
       }
     }
   }
@@ -287,25 +282,25 @@ static void checkEviction(LocalCache<?, ?> map) {
     if (map.evictsBySize()) {
       for (Segment<?, ?> segment : map.segments) {
         drainRecencyQueue(segment);
-        assertEquals(0, segment.recencyQueue.size());
-        assertEquals(0, segment.readCount.get());
+        assertThat(segment.recencyQueue).isEmpty();
+        assertThat(segment.readCount.get()).isEqualTo(0);
 
         ReferenceEntry<?, ?> prev = null;
         for (ReferenceEntry<?, ?> current : segment.accessQueue) {
           if (prev != null) {
-            assertSame(prev, current.getPreviousInAccessQueue());
-            assertSame(prev.getNextInAccessQueue(), current);
+            assertThat(current.getPreviousInAccessQueue()).isSameInstanceAs(prev);
+            assertThat(current).isSameInstanceAs(prev.getNextInAccessQueue());
           }
           Object key = current.getKey();
           if (key != null) {
-            assertSame(current, segment.getEntry(key, current.getHash()));
+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);
           }
           prev = current;
         }
       }
     } else {
       for (Segment<?, ?> segment : map.segments) {
-        assertEquals(0, segment.recencyQueue.size());
+        assertThat(segment.recencyQueue).isEmpty();
       }
     }
   }
@@ -323,7 +318,7 @@ static <K, V> Map<K, V> segmentTable(Segment<K, V> segment) {
         K key = entry.getKey();
         V value = entry.getValueReference().get();
         if (key != null && value != null) {
-          assertNull(map.put(key, value));
+          assertThat(map.put(key, value)).isNull();
         }
       }
     }
@@ -390,8 +385,8 @@ static void checkRecency(
       LocalCache<Integer, Integer> cchm = toLocalCache(cache);
       Segment<?, ?> segment = cchm.segments[0];
       drainRecencyQueue(segment);
-      assertEquals(maxSize, accessQueueSize(cache));
-      assertEquals(maxSize, cache.size());
+      assertThat(accessQueueSize(cache)).isEqualTo(maxSize);
+      assertThat(cache.size()).isEqualTo(maxSize);
 
       ReferenceEntry<?, ?> originalHead = segment.accessQueue.peek();
       @SuppressWarnings("unchecked")
@@ -399,8 +394,8 @@ static void checkRecency(
       operation.accept(entry);
       drainRecencyQueue(segment);
 
-      assertNotSame(originalHead, segment.accessQueue.peek());
-      assertEquals(cache.size(), accessQueueSize(cache));
+      assertThat(segment.accessQueue.peek()).isNotSameInstanceAs(originalHead);
+      assertThat(accessQueueSize(cache)).isEqualTo(cache.size());
     }
   }
 
@@ -428,9 +423,13 @@ static void expireEntries(LocalCache<?, ?> cchm, long expiringTime, FakeTicker t
     long now = ticker.read();
     for (Segment<?, ?> segment : cchm.segments) {
       expireEntries(segment, now);
-      assertEquals("Expiration queue must be empty by now", 0, writeQueueSize(segment));
-      assertEquals("Expiration queue must be empty by now", 0, accessQueueSize(segment));
-      assertEquals("Segments must be empty by now", 0, segmentSize(segment));
+      assertWithMessage("Expiration queue must be empty by now")
+          .that(writeQueueSize(segment))
+          .isEqualTo(0);
+      assertWithMessage("Expiration queue must be empty by now")
+          .that(accessQueueSize(segment))
+          .isEqualTo(0);
+      assertWithMessage("Segments must be empty by now").that(segmentSize(segment)).isEqualTo(0);
     }
     cchm.processPendingNotifications();
   }
@@ -446,11 +445,11 @@ static void expireEntries(Segment<?, ?> segment, long now) {
   }
 
   static void checkEmpty(Cache<?, ?> cache) {
-    assertEquals(0, cache.size());
-    assertFalse(cache.asMap().containsKey(null));
-    assertFalse(cache.asMap().containsKey(6));
-    assertFalse(cache.asMap().containsValue(null));
-    assertFalse(cache.asMap().containsValue(6));
+    assertThat(cache.size()).isEqualTo(0);
+    assertThat(cache.asMap().containsKey(null)).isFalse();
+    assertThat(cache.asMap().containsKey(6)).isFalse();
+    assertThat(cache.asMap().containsValue(null)).isFalse();
+    assertThat(cache.asMap().containsValue(6)).isFalse();
     checkEmpty(cache.asMap());
   }
 
@@ -458,29 +457,29 @@ static void checkEmpty(ConcurrentMap<?, ?> map) {
     checkEmpty(map.keySet());
     checkEmpty(map.values());
     checkEmpty(map.entrySet());
-    assertEquals(ImmutableMap.of(), map);
-    assertEquals(ImmutableMap.of().hashCode(), map.hashCode());
-    assertEquals(ImmutableMap.of().toString(), map.toString());
+    assertThat(map).isEqualTo(ImmutableMap.of());
+    assertThat(map.hashCode()).isEqualTo(ImmutableMap.of().hashCode());
+    assertThat(map.toString()).isEqualTo(ImmutableMap.of().toString());
 
     if (map instanceof LocalCache) {
       LocalCache<?, ?> cchm = (LocalCache<?, ?>) map;
 
       checkValidState(cchm);
-      assertTrue(cchm.isEmpty());
-      assertEquals(0, cchm.size());
+      assertThat(cchm.isEmpty()).isTrue();
+      assertThat(cchm).isEmpty();
       for (LocalCache.Segment<?, ?> segment : cchm.segments) {
-        assertEquals(0, segment.count);
-        assertEquals(0, segmentSize(segment));
-        assertTrue(segment.writeQueue.isEmpty());
-        assertTrue(segment.accessQueue.isEmpty());
+        assertThat(segment.count).isEqualTo(0);
+        assertThat(segmentSize(segment)).isEqualTo(0);
+        assertThat(segment.writeQueue.isEmpty()).isTrue();
+        assertThat(segment.accessQueue.isEmpty()).isTrue();
       }
     }
   }
 
   static void checkEmpty(Collection<?> collection) {
-    assertTrue(collection.isEmpty());
-    assertEquals(0, collection.size());
-    assertFalse(collection.iterator().hasNext());
+    assertThat(collection.isEmpty()).isTrue();
+    assertThat(collection).isEmpty();
+    assertThat(collection.iterator().hasNext()).isFalse();
     assertThat(collection.toArray()).isEmpty();
     assertThat(collection.toArray(new Object[0])).isEmpty();
     if (collection instanceof Set) {
diff --git a/guava-tests/test/com/google/common/cache/EmptyCachesTest.java b/guava-tests/test/com/google/common/cache/EmptyCachesTest.java
index f93568bc29a5..94a912347d9d 100644
--- a/guava-tests/test/com/google/common/cache/EmptyCachesTest.java
+++ b/guava-tests/test/com/google/common/cache/EmptyCachesTest.java
@@ -16,6 +16,7 @@
 
 import static com.google.common.cache.CacheTesting.checkEmpty;
 import static com.google.common.cache.TestingCacheLoaders.identityLoader;
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.Arrays.asList;
 import static java.util.concurrent.TimeUnit.DAYS;
 import static java.util.concurrent.TimeUnit.SECONDS;
@@ -75,7 +76,7 @@ public void testInvalidateAll_empty() {
 
   public void testEquals_null() {
     for (LoadingCache<Object, Object> cache : caches()) {
-      assertFalse(cache.equals(null));
+      assertThat(cache.equals(null)).isFalse();
     }
   }
 
@@ -138,11 +139,11 @@ public void testKeySet_clear() {
   public void testKeySet_empty_remove() {
     for (LoadingCache<Object, Object> cache : caches()) {
       Set<Object> keys = cache.asMap().keySet();
-      assertFalse(keys.remove(null));
-      assertFalse(keys.remove(6));
-      assertFalse(keys.remove(-6));
-      assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));
-      assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));
+      assertThat(keys.remove(null)).isFalse();
+      assertThat(keys.remove(6)).isFalse();
+      assertThat(keys.remove(-6)).isFalse();
+      assertThat(keys.removeAll(asList(null, 0, 15, 1500))).isFalse();
+      assertThat(keys.retainAll(asList(null, 0, 15, 1500))).isFalse();
       checkEmpty(keys);
       checkEmpty(cache);
     }
@@ -158,11 +159,11 @@ public void testKeySet_remove() {
       // values of these removes, but the cache should be empty after the removes, regardless.
       keys.remove(1);
       keys.remove(2);
-      assertFalse(keys.remove(null));
-      assertFalse(keys.remove(6));
-      assertFalse(keys.remove(-6));
-      assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));
-      assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));
+      assertThat(keys.remove(null)).isFalse();
+      assertThat(keys.remove(6)).isFalse();
+      assertThat(keys.remove(-6)).isFalse();
+      assertThat(keys.removeAll(asList(null, 0, 15, 1500))).isFalse();
+      assertThat(keys.retainAll(asList(null, 0, 15, 1500))).isFalse();
       checkEmpty(keys);
       checkEmpty(cache);
     }
@@ -202,11 +203,11 @@ public void testValues_clear() {
   public void testValues_empty_remove() {
     for (LoadingCache<Object, Object> cache : caches()) {
       Collection<Object> values = cache.asMap().values();
-      assertFalse(values.remove(null));
-      assertFalse(values.remove(6));
-      assertFalse(values.remove(-6));
-      assertFalse(values.removeAll(asList(null, 0, 15, 1500)));
-      assertFalse(values.retainAll(asList(null, 0, 15, 1500)));
+      assertThat(values.remove(null)).isFalse();
+      assertThat(values.remove(6)).isFalse();
+      assertThat(values.remove(-6)).isFalse();
+      assertThat(values.removeAll(asList(null, 0, 15, 1500))).isFalse();
+      assertThat(values.retainAll(asList(null, 0, 15, 1500))).isFalse();
       checkEmpty(values);
       checkEmpty(cache);
     }
@@ -222,11 +223,11 @@ public void testValues_remove() {
       // values of these removes, but the cache should be empty after the removes, regardless.
       values.remove(1);
       values.remove(2);
-      assertFalse(values.remove(null));
-      assertFalse(values.remove(6));
-      assertFalse(values.remove(-6));
-      assertFalse(values.removeAll(asList(null, 0, 15, 1500)));
-      assertFalse(values.retainAll(asList(null, 0, 15, 1500)));
+      assertThat(values.remove(null)).isFalse();
+      assertThat(values.remove(6)).isFalse();
+      assertThat(values.remove(-6)).isFalse();
+      assertThat(values.removeAll(asList(null, 0, 15, 1500))).isFalse();
+      assertThat(values.retainAll(asList(null, 0, 15, 1500))).isFalse();
       checkEmpty(values);
       checkEmpty(cache);
     }
@@ -269,11 +270,11 @@ public void testEntrySet_clear() {
   public void testEntrySet_empty_remove() {
     for (LoadingCache<Object, Object> cache : caches()) {
       Set<Entry<Object, Object>> entrySet = cache.asMap().entrySet();
-      assertFalse(entrySet.remove(null));
-      assertFalse(entrySet.remove(entryOf(6, 6)));
-      assertFalse(entrySet.remove(entryOf(-6, -6)));
-      assertFalse(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15))));
-      assertFalse(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15))));
+      assertThat(entrySet.remove(null)).isFalse();
+      assertThat(entrySet.remove(entryOf(6, 6))).isFalse();
+      assertThat(entrySet.remove(entryOf(-6, -6))).isFalse();
+      assertThat(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15)))).isFalse();
+      assertThat(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15)))).isFalse();
       checkEmpty(entrySet);
       checkEmpty(cache);
     }
@@ -289,11 +290,11 @@ public void testEntrySet_remove() {
       // values of these removes, but the cache should be empty after the removes, regardless.
       entrySet.remove(entryOf(1, 1));
       entrySet.remove(entryOf(2, 2));
-      assertFalse(entrySet.remove(null));
-      assertFalse(entrySet.remove(entryOf(1, 1)));
-      assertFalse(entrySet.remove(entryOf(6, 6)));
-      assertFalse(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15))));
-      assertFalse(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15))));
+      assertThat(entrySet.remove(null)).isFalse();
+      assertThat(entrySet.remove(entryOf(1, 1))).isFalse();
+      assertThat(entrySet.remove(entryOf(6, 6))).isFalse();
+      assertThat(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15)))).isFalse();
+      assertThat(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15)))).isFalse();
       checkEmpty(entrySet);
       checkEmpty(cache);
     }
diff --git a/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java b/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java
index 76de76c3707c..9eb3fe7e33c7 100644
--- a/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java
+++ b/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java
@@ -16,12 +16,14 @@
 
 package com.google.common.cache;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.errorprone.annotations.Keep;
 import java.util.concurrent.ExecutionException;
 import junit.framework.TestCase;
 import org.jspecify.annotations.NullUnmarked;
@@ -56,15 +58,13 @@ protected Cache<String, Boolean> delegate() {
   }
 
   public void testGetIfPresent() throws ExecutionException {
-    when(mock.getIfPresent("key")).thenReturn(Boolean.TRUE);
-    assertSame(Boolean.TRUE, forward.getIfPresent("key"));
+    when(mock.getIfPresent("key")).thenReturn(true);
+    assertThat(forward.getIfPresent("key")).isSameInstanceAs(true);
   }
 
   public void testGetAllPresent() throws ExecutionException {
-    when(mock.getAllPresent(ImmutableList.of("key")))
-        .thenReturn(ImmutableMap.of("key", Boolean.TRUE));
-    assertEquals(
-        ImmutableMap.of("key", Boolean.TRUE), forward.getAllPresent(ImmutableList.of("key")));
+    when(mock.getAllPresent(ImmutableList.of("key"))).thenReturn(ImmutableMap.of("key", true));
+    assertThat(forward.getAllPresent(ImmutableList.of("key"))).containsExactly("key", true);
   }
 
   public void testInvalidate() {
@@ -84,17 +84,17 @@ public void testInvalidateAll() {
 
   public void testSize() {
     when(mock.size()).thenReturn(0L);
-    assertEquals(0, forward.size());
+    assertThat(forward.size()).isEqualTo(0);
   }
 
   public void testStats() {
     when(mock.stats()).thenReturn(null);
-    assertNull(forward.stats());
+    assertThat(forward.stats()).isNull();
   }
 
   public void testAsMap() {
     when(mock.asMap()).thenReturn(null);
-    assertNull(forward.asMap());
+    assertThat(forward.asMap()).isNull();
   }
 
   public void testCleanUp() {
@@ -103,6 +103,7 @@ public void testCleanUp() {
   }
 
   /** Make sure that all methods are forwarded. */
+  @Keep
   private static class OnlyGet<K, V> extends ForwardingCache<K, V> {
     @Override
     protected Cache<K, V> delegate() {
diff --git a/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java b/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java
index cdef91afe699..89029ab0ef67 100644
--- a/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java
+++ b/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java
@@ -16,12 +16,14 @@
 
 package com.google.common.cache;
 
+import static com.google.common.truth.Truth.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import com.google.errorprone.annotations.Keep;
 import java.util.concurrent.ExecutionException;
 import junit.framework.TestCase;
 import org.jspecify.annotations.NullUnmarked;
@@ -56,23 +58,23 @@ protected LoadingCache<String, Boolean> delegate() {
   }
 
   public void testGet() throws ExecutionException {
-    when(mock.get("key")).thenReturn(Boolean.TRUE);
-    assertSame(Boolean.TRUE, forward.get("key"));
+    when(mock.get("key")).thenReturn(true);
+    assertThat(forward.get("key")).isSameInstanceAs(true);
   }
 
   public void testGetUnchecked() {
-    when(mock.getUnchecked("key")).thenReturn(Boolean.TRUE);
-    assertSame(Boolean.TRUE, forward.getUnchecked("key"));
+    when(mock.getUnchecked("key")).thenReturn(true);
+    assertThat(forward.getUnchecked("key")).isSameInstanceAs(true);
   }
 
   public void testGetAll() throws ExecutionException {
-    when(mock.getAll(ImmutableList.of("key"))).thenReturn(ImmutableMap.of("key", Boolean.TRUE));
-    assertEquals(ImmutableMap.of("key", Boolean.TRUE), forward.getAll(ImmutableList.of("key")));
+    when(mock.getAll(ImmutableList.of("key"))).thenReturn(ImmutableMap.of("key", true));
+    assertThat(forward.getAll(ImmutableList.of("key"))).containsExactly("key", true);
   }
 
   public void testApply() {
-    when(mock.apply("key")).thenReturn(Boolean.TRUE);
-    assertSame(Boolean.TRUE, forward.apply("key"));
+    when(mock.apply("key")).thenReturn(true);
+    assertThat(forward.apply("key")).isSameInstanceAs(true);
   }
 
   public void testInvalidate() {
@@ -97,12 +99,12 @@ public void testSize() {
 
   public void testStats() {
     when(mock.stats()).thenReturn(null);
-    assertNull(forward.stats());
+    assertThat(forward.stats()).isNull();
   }
 
   public void testAsMap() {
     when(mock.asMap()).thenReturn(null);
-    assertNull(forward.asMap());
+    assertThat(forward.asMap()).isNull();
   }
 
   public void testCleanUp() {
@@ -111,6 +113,7 @@ public void testCleanUp() {
   }
 
   /** Make sure that all methods are forwarded. */
+  @Keep
   private static class OnlyGet<K, V> extends ForwardingLoadingCache<K, V> {
     @Override
     protected LoadingCache<K, V> delegate() {
diff --git a/guava-tests/test/com/google/common/cache/LocalCacheMapComputeTest.java b/guava-tests/test/com/google/common/cache/LocalCacheMapComputeTest.java
index 0ca0a13f746c..474aab6a13c7 100644
--- a/guava-tests/test/com/google/common/cache/LocalCacheMapComputeTest.java
+++ b/guava-tests/test/com/google/common/cache/LocalCacheMapComputeTest.java
@@ -61,7 +61,7 @@ public void testComputeIfAbsent() {
         n -> {
           cache.asMap().computeIfAbsent(key, k -> "value" + n);
         });
-    assertEquals(1, cache.size());
+    assertThat(cache.size()).isEqualTo(1);
   }
 
   public void testComputeIfAbsentEviction() {
@@ -96,7 +96,7 @@ public void testComputeIfPresent() {
         n -> {
           cache.asMap().computeIfPresent(key, (k, v) -> v + delimiter + n);
         });
-    assertEquals(1, cache.size());
+    assertThat(cache.size()).isEqualTo(1);
     assertThat(cache.getIfPresent(key).split(delimiter)).hasLength(count + 1);
   }
 
@@ -161,7 +161,7 @@ public void testCompute() {
         n -> {
           cache.asMap().compute(key, (k, v) -> null);
         });
-    assertEquals(0, cache.size());
+    assertThat(cache.size()).isEqualTo(0);
   }
 
   public void testComputeWithLoad() {
diff --git a/guava-tests/test/com/google/common/cache/LocalCacheTest.java b/guava-tests/test/com/google/common/cache/LocalCacheTest.java
index 789536226b48..9eed4e73b959 100644
--- a/guava-tests/test/com/google/common/cache/LocalCacheTest.java
+++ b/guava-tests/test/com/google/common/cache/LocalCacheTest.java
@@ -27,6 +27,7 @@
 import static com.google.common.cache.TestingWeighers.constantWeigher;
 import static com.google.common.collect.Maps.immutableEntry;
 import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;
 import static java.lang.Math.max;
 import static java.lang.Thread.State.WAITING;
@@ -247,18 +248,18 @@ public void tearDown() throws Exception {
 
   private Throwable popLoggedThrowable() {
     List<LogRecord> logRecords = logHandler.getStoredLogRecords();
-    assertEquals(1, logRecords.size());
+    assertThat(logRecords).hasSize(1);
     LogRecord logRecord = logRecords.get(0);
     logHandler.clear();
     return logRecord.getThrown();
   }
 
   private void checkNothingLogged() {
-    assertTrue(logHandler.getStoredLogRecords().isEmpty());
+    assertThat(logHandler.getStoredLogRecords().isEmpty()).isTrue();
   }
 
   private void checkLogged(Throwable t) {
-    assertSame(t, popLoggedThrowable());
+    assertThat(popLoggedThrowable()).isSameInstanceAs(t);
   }
 
   /*
@@ -288,33 +289,33 @@ private static CacheBuilder<Object, Object> createCacheBuilder() {
   public void testDefaults() {
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());
 
-    assertSame(Strength.STRONG, map.keyStrength);
-    assertSame(Strength.STRONG, map.valueStrength);
-    assertSame(map.keyStrength.defaultEquivalence(), map.keyEquivalence);
-    assertSame(map.valueStrength.defaultEquivalence(), map.valueEquivalence);
+    assertThat(map.keyStrength).isEqualTo(Strength.STRONG);
+    assertThat(map.valueStrength).isEqualTo(Strength.STRONG);
+    assertThat(map.keyEquivalence).isSameInstanceAs(map.keyStrength.defaultEquivalence());
+    assertThat(map.valueEquivalence).isSameInstanceAs(map.valueStrength.defaultEquivalence());
 
-    assertEquals(0, map.expireAfterAccessNanos);
-    assertEquals(0, map.expireAfterWriteNanos);
-    assertEquals(0, map.refreshNanos);
-    assertEquals(CacheBuilder.UNSET_INT, map.maxWeight);
+    assertThat(map.expireAfterAccessNanos).isEqualTo(0);
+    assertThat(map.expireAfterWriteNanos).isEqualTo(0);
+    assertThat(map.refreshNanos).isEqualTo(0);
+    assertThat(map.maxWeight).isEqualTo(CacheBuilder.UNSET_INT);
 
-    assertSame(EntryFactory.STRONG, map.entryFactory);
-    assertSame(CacheBuilder.NullListener.INSTANCE, map.removalListener);
-    assertSame(DISCARDING_QUEUE, map.removalNotificationQueue);
-    assertSame(NULL_TICKER, map.ticker);
+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);
+    assertThat(map.removalListener).isSameInstanceAs(CacheBuilder.NullListener.INSTANCE);
+    assertThat(map.removalNotificationQueue).isSameInstanceAs(DISCARDING_QUEUE);
+    assertThat(map.ticker).isSameInstanceAs(NULL_TICKER);
 
-    assertEquals(4, map.concurrencyLevel);
+    assertThat(map.concurrencyLevel).isEqualTo(4);
 
     // concurrency level
     assertThat(map.segments).hasLength(4);
     // initial capacity / concurrency level
-    assertEquals(16 / map.segments.length, map.segments[0].table.length());
+    assertThat(map.segments[0].table.length()).isEqualTo(16 / map.segments.length);
 
-    assertFalse(map.evictsBySize());
-    assertFalse(map.expires());
-    assertFalse(map.expiresAfterWrite());
-    assertFalse(map.expiresAfterAccess());
-    assertFalse(map.refreshes());
+    assertThat(map.evictsBySize()).isFalse();
+    assertThat(map.expires()).isFalse();
+    assertThat(map.expiresAfterWrite()).isFalse();
+    assertThat(map.expiresAfterAccess()).isFalse();
+    assertThat(map.refreshes()).isFalse();
   }
 
   public void testSetKeyEquivalence() {
@@ -333,8 +334,8 @@ protected int doHash(Object t) {
 
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().keyEquivalence(testEquivalence));
-    assertSame(testEquivalence, map.keyEquivalence);
-    assertSame(map.valueStrength.defaultEquivalence(), map.valueEquivalence);
+    assertThat(map.keyEquivalence).isSameInstanceAs(testEquivalence);
+    assertThat(map.valueEquivalence).isSameInstanceAs(map.valueStrength.defaultEquivalence());
   }
 
   public void testSetValueEquivalence() {
@@ -353,8 +354,8 @@ protected int doHash(Object t) {
 
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().valueEquivalence(testEquivalence));
-    assertSame(testEquivalence, map.valueEquivalence);
-    assertSame(map.keyStrength.defaultEquivalence(), map.keyEquivalence);
+    assertThat(map.valueEquivalence).isSameInstanceAs(testEquivalence);
+    assertThat(map.keyEquivalence).isSameInstanceAs(map.keyStrength.defaultEquivalence());
   }
 
   public void testSetConcurrencyLevel() {
@@ -418,7 +419,7 @@ private static void checkInitialCapacity(
                 .concurrencyLevel(concurrencyLevel)
                 .initialCapacity(initialCapacity));
     for (int i = 0; i < map.segments.length; i++) {
-      assertEquals(segmentSize, map.segments[i].table.length());
+      assertThat(map.segments[i].table.length()).isEqualTo(segmentSize);
     }
   }
 
@@ -455,13 +456,15 @@ private static void checkMaximumSize(int concurrencyLevel, int initialCapacity,
                 .initialCapacity(initialCapacity)
                 .maximumSize(maxSize));
     long totalCapacity = 0;
-    assertTrue(
-        "segments=" + map.segments.length + ", maxSize=" + maxSize,
-        map.segments.length <= max(1, maxSize / 10));
+    assertWithMessage("segments=%s, maxSize=%s", map.segments.length, maxSize)
+        .that((long) map.segments.length)
+        .isAtMost(max(1, maxSize / 10));
     for (int i = 0; i < map.segments.length; i++) {
       totalCapacity += map.segments[i].maxSegmentWeight;
     }
-    assertTrue("totalCapacity=" + totalCapacity + ", maxSize=" + maxSize, totalCapacity == maxSize);
+    assertWithMessage("totalCapacity=%s, maxSize=%s", totalCapacity, maxSize)
+        .that(totalCapacity)
+        .isEqualTo(maxSize);
 
     map =
         makeLocalCache(
@@ -470,14 +473,16 @@ private static void checkMaximumSize(int concurrencyLevel, int initialCapacity,
                 .initialCapacity(initialCapacity)
                 .maximumWeight(maxSize)
                 .weigher(constantWeigher(1)));
-    assertTrue(
-        "segments=" + map.segments.length + ", maxSize=" + maxSize,
-        map.segments.length <= max(1, maxSize / 10));
+    assertWithMessage("segments=%s, maxSize=%s", map.segments.length, maxSize)
+        .that((long) map.segments.length)
+        .isAtMost(max(1, maxSize / 10));
     totalCapacity = 0;
     for (int i = 0; i < map.segments.length; i++) {
       totalCapacity += map.segments[i].maxSegmentWeight;
     }
-    assertTrue("totalCapacity=" + totalCapacity + ", maxSize=" + maxSize, totalCapacity == maxSize);
+    assertWithMessage("totalCapacity=%s, maxSize=%s", totalCapacity, maxSize)
+        .that(totalCapacity)
+        .isEqualTo(maxSize);
   }
 
   public void testSetWeigher() {
@@ -490,33 +495,33 @@ public int weigh(Object key, Object value) {
         };
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().maximumWeight(1).weigher(testWeigher));
-    assertSame(testWeigher, map.weigher);
+    assertThat(map.weigher).isSameInstanceAs(testWeigher);
   }
 
   public void testSetWeakKeys() {
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().weakKeys());
     checkStrength(map, Strength.WEAK, Strength.STRONG);
-    assertSame(EntryFactory.WEAK, map.entryFactory);
+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.WEAK);
   }
 
   public void testSetWeakValues() {
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().weakValues());
     checkStrength(map, Strength.STRONG, Strength.WEAK);
-    assertSame(EntryFactory.STRONG, map.entryFactory);
+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);
   }
 
   public void testSetSoftValues() {
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().softValues());
     checkStrength(map, Strength.STRONG, Strength.SOFT);
-    assertSame(EntryFactory.STRONG, map.entryFactory);
+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);
   }
 
   private static void checkStrength(
       LocalCache<Object, Object> map, Strength keyStrength, Strength valueStrength) {
-    assertSame(keyStrength, map.keyStrength);
-    assertSame(valueStrength, map.valueStrength);
-    assertSame(keyStrength.defaultEquivalence(), map.keyEquivalence);
-    assertSame(valueStrength.defaultEquivalence(), map.valueEquivalence);
+    assertThat(map.keyStrength).isSameInstanceAs(keyStrength);
+    assertThat(map.valueStrength).isSameInstanceAs(valueStrength);
+    assertThat(map.keyEquivalence).isSameInstanceAs(keyStrength.defaultEquivalence());
+    assertThat(map.valueEquivalence).isSameInstanceAs(valueStrength.defaultEquivalence());
   }
 
   public void testSetExpireAfterWrite() {
@@ -524,7 +529,7 @@ public void testSetExpireAfterWrite() {
     TimeUnit unit = SECONDS;
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().expireAfterWrite(duration, unit));
-    assertEquals(unit.toNanos(duration), map.expireAfterWriteNanos);
+    assertThat(map.expireAfterWriteNanos).isEqualTo(unit.toNanos(duration));
   }
 
   public void testSetExpireAfterAccess() {
@@ -532,7 +537,7 @@ public void testSetExpireAfterAccess() {
     TimeUnit unit = SECONDS;
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().expireAfterAccess(duration, unit));
-    assertEquals(unit.toNanos(duration), map.expireAfterAccessNanos);
+    assertThat(map.expireAfterAccessNanos).isEqualTo(unit.toNanos(duration));
   }
 
   public void testSetRefresh() {
@@ -540,7 +545,7 @@ public void testSetRefresh() {
     TimeUnit unit = SECONDS;
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().refreshAfterWrite(duration, unit));
-    assertEquals(unit.toNanos(duration), map.refreshNanos);
+    assertThat(map.refreshNanos).isEqualTo(unit.toNanos(duration));
   }
 
   public void testLongAsyncRefresh() throws Exception {
@@ -599,7 +604,7 @@ public void testSetRemovalListener() {
     RemovalListener<Object, Object> testListener = TestingRemovalListeners.nullRemovalListener();
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().removalListener(testListener));
-    assertSame(testListener, map.removalListener);
+    assertThat(map.removalListener).isSameInstanceAs(testListener);
   }
 
   public void testSetTicker() {
@@ -611,19 +616,26 @@ public long read() {
           }
         };
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().ticker(testTicker));
-    assertSame(testTicker, map.ticker);
+    assertThat(map.ticker).isSameInstanceAs(testTicker);
   }
 
   public void testEntryFactory() {
-    assertSame(EntryFactory.STRONG, EntryFactory.getFactory(Strength.STRONG, false, false));
-    assertSame(EntryFactory.STRONG_ACCESS, EntryFactory.getFactory(Strength.STRONG, true, false));
-    assertSame(EntryFactory.STRONG_WRITE, EntryFactory.getFactory(Strength.STRONG, false, true));
-    assertSame(
-        EntryFactory.STRONG_ACCESS_WRITE, EntryFactory.getFactory(Strength.STRONG, true, true));
-    assertSame(EntryFactory.WEAK, EntryFactory.getFactory(Strength.WEAK, false, false));
-    assertSame(EntryFactory.WEAK_ACCESS, EntryFactory.getFactory(Strength.WEAK, true, false));
-    assertSame(EntryFactory.WEAK_WRITE, EntryFactory.getFactory(Strength.WEAK, false, true));
-    assertSame(EntryFactory.WEAK_ACCESS_WRITE, EntryFactory.getFactory(Strength.WEAK, true, true));
+    assertThat(EntryFactory.getFactory(Strength.STRONG, false, false))
+        .isSameInstanceAs(EntryFactory.STRONG);
+    assertThat(EntryFactory.getFactory(Strength.STRONG, true, false))
+        .isSameInstanceAs(EntryFactory.STRONG_ACCESS);
+    assertThat(EntryFactory.getFactory(Strength.STRONG, false, true))
+        .isSameInstanceAs(EntryFactory.STRONG_WRITE);
+    assertThat(EntryFactory.getFactory(Strength.STRONG, true, true))
+        .isSameInstanceAs(EntryFactory.STRONG_ACCESS_WRITE);
+    assertThat(EntryFactory.getFactory(Strength.WEAK, false, false))
+        .isSameInstanceAs(EntryFactory.WEAK);
+    assertThat(EntryFactory.getFactory(Strength.WEAK, true, false))
+        .isSameInstanceAs(EntryFactory.WEAK_ACCESS);
+    assertThat(EntryFactory.getFactory(Strength.WEAK, false, true))
+        .isSameInstanceAs(EntryFactory.WEAK_WRITE);
+    assertThat(EntryFactory.getFactory(Strength.WEAK, true, true))
+        .isSameInstanceAs(EntryFactory.WEAK_ACCESS_WRITE);
   }
 
   // computation tests
@@ -631,13 +643,13 @@ public void testEntryFactory() {
   public void testCompute() throws ExecutionException {
     CountingLoader loader = new CountingLoader();
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());
-    assertEquals(0, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(0);
 
     Object key = new Object();
     Object value = map.get(key, loader);
-    assertEquals(1, loader.getCount());
-    assertEquals(value, map.get(key, loader));
-    assertEquals(1, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(1);
+    assertThat(map.get(key, loader)).isEqualTo(value);
+    assertThat(loader.getCount()).isEqualTo(1);
   }
 
   public void testRecordReadOnCompute() throws ExecutionException {
@@ -659,7 +671,7 @@ public void testRecordReadOnCompute() throws ExecutionException {
 
       checkEvictionQueues(map, segment, readOrder, writeOrder);
       checkExpirationTimes(map);
-      assertTrue(segment.recencyQueue.isEmpty());
+      assertThat(segment.recencyQueue.isEmpty()).isTrue();
 
       // access some of the elements
       Random random = new Random();
@@ -671,7 +683,7 @@ public void testRecordReadOnCompute() throws ExecutionException {
           map.get(entry.getKey(), loader);
           reads.add(entry);
           i.remove();
-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);
+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);
         }
       }
       int undrainedIndex = reads.size() - segment.recencyQueue.size();
@@ -686,14 +698,14 @@ public void testRecordReadOnCompute() throws ExecutionException {
   public void testComputeExistingEntry() throws ExecutionException {
     CountingLoader loader = new CountingLoader();
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());
-    assertEquals(0, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(0);
 
     Object key = new Object();
     Object value = new Object();
     map.put(key, value);
 
-    assertEquals(value, map.get(key, loader));
-    assertEquals(0, loader.getCount());
+    assertThat(map.get(key, loader)).isEqualTo(value);
+    assertThat(loader.getCount()).isEqualTo(0);
   }
 
   public void testComputePartiallyCollectedKey() throws ExecutionException {
@@ -702,7 +714,7 @@ public void testComputePartiallyCollectedKey() throws ExecutionException {
     LocalCache<Object, Object> map = makeLocalCache(builder);
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(0, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(0);
 
     Object key = new Object();
     int hash = map.hash(key);
@@ -715,14 +727,14 @@ public void testComputePartiallyCollectedKey() throws ExecutionException {
     table.set(index, entry);
     segment.count++;
 
-    assertSame(value, map.get(key, loader));
-    assertEquals(0, loader.getCount());
-    assertEquals(1, segment.count);
+    assertThat(map.get(key, loader)).isSameInstanceAs(value);
+    assertThat(loader.getCount()).isEqualTo(0);
+    assertThat(segment.count).isEqualTo(1);
 
     entry.clearKey();
-    assertNotSame(value, map.get(key, loader));
-    assertEquals(1, loader.getCount());
-    assertEquals(2, segment.count);
+    assertThat(map.get(key, loader)).isNotSameInstanceAs(value);
+    assertThat(loader.getCount()).isEqualTo(1);
+    assertThat(segment.count).isEqualTo(2);
   }
 
   public void testComputePartiallyCollectedValue() throws ExecutionException {
@@ -731,7 +743,7 @@ public void testComputePartiallyCollectedValue() throws ExecutionException {
     LocalCache<Object, Object> map = makeLocalCache(builder);
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(0, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(0);
 
     Object key = new Object();
     int hash = map.hash(key);
@@ -744,14 +756,14 @@ public void testComputePartiallyCollectedValue() throws ExecutionException {
     table.set(index, entry);
     segment.count++;
 
-    assertSame(value, map.get(key, loader));
-    assertEquals(0, loader.getCount());
-    assertEquals(1, segment.count);
+    assertThat(map.get(key, loader)).isSameInstanceAs(value);
+    assertThat(loader.getCount()).isEqualTo(0);
+    assertThat(segment.count).isEqualTo(1);
 
     valueRef.clear();
-    assertNotSame(value, map.get(key, loader));
-    assertEquals(1, loader.getCount());
-    assertEquals(1, segment.count);
+    assertThat(map.get(key, loader)).isNotSameInstanceAs(value);
+    assertThat(loader.getCount()).isEqualTo(1);
+    assertThat(segment.count).isEqualTo(1);
   }
 
   @AndroidIncompatible // Perhaps emulator clock does not update between the two get() calls?
@@ -759,15 +771,15 @@ public void testComputeExpiredEntry() throws ExecutionException {
     CacheBuilder<Object, Object> builder = createCacheBuilder().expireAfterWrite(1, NANOSECONDS);
     CountingLoader loader = new CountingLoader();
     LocalCache<Object, Object> map = makeLocalCache(builder);
-    assertEquals(0, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(0);
 
     Object key = new Object();
     Object one = map.get(key, loader);
-    assertEquals(1, loader.getCount());
+    assertThat(loader.getCount()).isEqualTo(1);
 
     Object two = map.get(key, loader);
-    assertNotSame(one, two);
-    assertEquals(2, loader.getCount());
+    assertThat(two).isNotSameInstanceAs(one);
+    assertThat(loader.getCount()).isEqualTo(2);
   }
 
   public void testValues() {
@@ -775,9 +787,9 @@ public void testValues() {
     map.put("foo", "bar");
     map.put("baz", "bar");
     map.put("quux", "quux");
-    assertFalse(map.values() instanceof Set);
-    assertTrue(map.values().removeAll(ImmutableSet.of("bar")));
-    assertEquals(1, map.size());
+    assertThat(map.values() instanceof Set).isFalse();
+    assertThat(map.values().removeAll(ImmutableSet.of("bar"))).isTrue();
+    assertThat(map).hasSize(1);
   }
 
   public void testComputeIfAbsent_removalListener() {
@@ -793,7 +805,7 @@ public void onRemoval(RemovalNotification<Object, Object> notification) {
         CacheBuilder.newBuilder().removalListener(removalListener).build();
     cache.put("a", "b");
     cache.asMap().computeIfAbsent("a", k -> "c");
-    assertTrue(notifications.toString(), notifications.isEmpty());
+    assertThat(notifications).isEmpty();
   }
 
   public void testCopyEntry_computing() {
@@ -818,7 +830,7 @@ public Object load(Object key) throws Exception {
     LocalCache<Object, Object> map = makeLocalCache(builder);
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     int hash = map.hash(one);
@@ -861,7 +873,7 @@ public void run() {
     @SuppressWarnings("unchecked")
     LoadingValueReference<Object, Object> valueReference =
         (LoadingValueReference) newEntry.getValueReference();
-    assertFalse(valueReference.futureValue.isDone());
+    assertThat(valueReference.futureValue.isDone()).isFalse();
     startSignal.countDown();
 
     try {
@@ -871,10 +883,10 @@ public void run() {
     }
 
     map.cleanUp(); // force notifications
-    assertTrue(listener.isEmpty());
-    assertTrue(map.containsKey(one));
-    assertEquals(1, map.size());
-    assertSame(computedObject, map.get(one));
+    assertThat(listener.isEmpty()).isTrue();
+    assertThat(map.containsKey(one)).isTrue();
+    assertThat(map).hasSize(1);
+    assertThat(map.get(one)).isSameInstanceAs(computedObject);
   }
 
   public void testRemovalListenerCheckedException() {
@@ -916,7 +928,7 @@ public Object load(Object key) throws Exception {
     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();
     CacheBuilder<Object, Object> builder = createCacheBuilder().removalListener(listener);
     LocalCache<Object, Object> map = makeLocalCache(builder);
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     Object two = new Object();
@@ -940,7 +952,7 @@ public void run() {
     }
 
     map.put(one, two);
-    assertSame(two, map.get(one));
+    assertThat(map.get(one)).isSameInstanceAs(two);
     startSignal.countDown();
 
     try {
@@ -951,7 +963,7 @@ public void run() {
 
     map.cleanUp(); // force notifications
     assertNotified(listener, one, computedObject, RemovalCause.REPLACED);
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
   }
 
   public void testSegmentRefresh_duplicate() throws ExecutionException {
@@ -977,7 +989,7 @@ public void testSegmentRefresh_duplicate() throws ExecutionException {
   public void testRemovalListener_explicit() {
     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     Object two = new Object();
@@ -1012,13 +1024,13 @@ public void testRemovalListener_explicit() {
     i.remove();
     assertNotified(listener, five, six, RemovalCause.EXPLICIT);
 
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
   }
 
   public void testRemovalListener_replaced() {
     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();
     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     Object two = new Object();
@@ -1048,7 +1060,7 @@ public void testRemovalListener_collected() {
         makeLocalCache(
             createCacheBuilder().concurrencyLevel(1).softValues().removalListener(listener));
     Segment<Object, Object> segment = map.segments[0];
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     Object two = new Object();
@@ -1056,14 +1068,14 @@ public void testRemovalListener_collected() {
 
     map.put(one, two);
     map.put(two, three);
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     int hash = map.hash(one);
     ReferenceEntry<Object, Object> entry = segment.getEntry(one, hash);
     map.reclaimValue(entry.getValueReference());
     assertNotified(listener, one, two, RemovalCause.COLLECTED);
 
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
   }
 
   public void testRemovalListener_expired() {
@@ -1076,7 +1088,7 @@ public void testRemovalListener_expired() {
                 .expireAfterWrite(3, NANOSECONDS)
                 .ticker(ticker)
                 .removalListener(listener));
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     Object two = new Object();
@@ -1089,12 +1101,12 @@ public void testRemovalListener_expired() {
     map.put(two, three);
     ticker.advance(1);
     map.put(three, four);
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
     ticker.advance(1);
     map.put(four, five);
     assertNotified(listener, one, two, RemovalCause.EXPIRED);
 
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
   }
 
   public void testRemovalListener_size() {
@@ -1102,7 +1114,7 @@ public void testRemovalListener_size() {
     LocalCache<Object, Object> map =
         makeLocalCache(
             createCacheBuilder().concurrencyLevel(1).maximumSize(2).removalListener(listener));
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
 
     Object one = new Object();
     Object two = new Object();
@@ -1111,19 +1123,19 @@ public void testRemovalListener_size() {
 
     map.put(one, two);
     map.put(two, three);
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
     map.put(three, four);
     assertNotified(listener, one, two, RemovalCause.SIZE);
 
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
   }
 
   static <K, V> void assertNotified(
       QueuingRemovalListener<K, V> listener, K key, V value, RemovalCause cause) {
     RemovalNotification<K, V> notification = listener.remove();
-    assertSame(key, notification.getKey());
-    assertSame(value, notification.getValue());
-    assertSame(cause, notification.getCause());
+    assertThat(notification.getKey()).isSameInstanceAs(key);
+    assertThat(notification.getValue()).isSameInstanceAs(value);
+    assertThat(notification.getCause()).isSameInstanceAs(cause);
   }
 
   // Segment core tests
@@ -1137,26 +1149,26 @@ public void testNewEntry() {
       int hashOne = map.hash(keyOne);
       ReferenceEntry<Object, Object> entryOne = map.newEntry(keyOne, hashOne, null);
       ValueReference<Object, Object> valueRefOne = map.newValueReference(entryOne, valueOne, 1);
-      assertSame(valueOne, valueRefOne.get());
+      assertThat(valueRefOne.get()).isSameInstanceAs(valueOne);
       entryOne.setValueReference(valueRefOne);
 
-      assertSame(keyOne, entryOne.getKey());
-      assertEquals(hashOne, entryOne.getHash());
-      assertNull(entryOne.getNext());
-      assertSame(valueRefOne, entryOne.getValueReference());
+      assertThat(entryOne.getKey()).isSameInstanceAs(keyOne);
+      assertThat(entryOne.getHash()).isEqualTo(hashOne);
+      assertThat(entryOne.getNext()).isNull();
+      assertThat(entryOne.getValueReference()).isSameInstanceAs(valueRefOne);
 
       Object keyTwo = new Object();
       Object valueTwo = new Object();
       int hashTwo = map.hash(keyTwo);
       ReferenceEntry<Object, Object> entryTwo = map.newEntry(keyTwo, hashTwo, entryOne);
       ValueReference<Object, Object> valueRefTwo = map.newValueReference(entryTwo, valueTwo, 1);
-      assertSame(valueTwo, valueRefTwo.get());
+      assertThat(valueRefTwo.get()).isSameInstanceAs(valueTwo);
       entryTwo.setValueReference(valueRefTwo);
 
-      assertSame(keyTwo, entryTwo.getKey());
-      assertEquals(hashTwo, entryTwo.getHash());
-      assertSame(entryOne, entryTwo.getNext());
-      assertSame(valueRefTwo, entryTwo.getValueReference());
+      assertThat(entryTwo.getKey()).isSameInstanceAs(keyTwo);
+      assertThat(entryTwo.getHash()).isEqualTo(hashTwo);
+      assertThat(entryTwo.getNext()).isSameInstanceAs(entryOne);
+      assertThat(entryTwo.getValueReference()).isSameInstanceAs(valueRefTwo);
     }
   }
 
@@ -1184,17 +1196,17 @@ public void testCopyEntry() {
       assertConnected(map, entryOne, entryTwo);
 
       ReferenceEntry<Object, Object> copyOne = map.copyEntry(entryOne, null);
-      assertSame(keyOne, entryOne.getKey());
-      assertEquals(hashOne, entryOne.getHash());
-      assertNull(entryOne.getNext());
-      assertSame(valueOne, copyOne.getValueReference().get());
+      assertThat(entryOne.getKey()).isSameInstanceAs(keyOne);
+      assertThat(entryOne.getHash()).isEqualTo(hashOne);
+      assertThat(entryOne.getNext()).isNull();
+      assertThat(copyOne.getValueReference().get()).isSameInstanceAs(valueOne);
       assertConnected(map, copyOne, entryTwo);
 
       ReferenceEntry<Object, Object> copyTwo = map.copyEntry(entryTwo, copyOne);
-      assertSame(keyTwo, copyTwo.getKey());
-      assertEquals(hashTwo, copyTwo.getHash());
-      assertSame(copyOne, copyTwo.getNext());
-      assertSame(valueTwo, copyTwo.getValueReference().get());
+      assertThat(copyTwo.getKey()).isSameInstanceAs(keyTwo);
+      assertThat(copyTwo.getHash()).isEqualTo(hashTwo);
+      assertThat(copyTwo.getNext()).isSameInstanceAs(copyOne);
+      assertThat(copyTwo.getValueReference().get()).isSameInstanceAs(valueTwo);
       assertConnected(map, copyOne, copyTwo);
     }
   }
@@ -1202,10 +1214,10 @@ public void testCopyEntry() {
   private static <K, V> void assertConnected(
       LocalCache<K, V> map, ReferenceEntry<K, V> one, ReferenceEntry<K, V> two) {
     if (map.usesWriteQueue()) {
-      assertSame(two, one.getNextInWriteQueue());
+      assertThat(one.getNextInWriteQueue()).isSameInstanceAs(two);
     }
     if (map.usesAccessQueue()) {
-      assertSame(two, one.getNextInAccessQueue());
+      assertThat(one.getNextInAccessQueue()).isSameInstanceAs(two);
     }
   }
 
@@ -1235,14 +1247,14 @@ public void testSegmentGetAndContains() {
     // count == 0
     table.set(index, entry);
     assertNull(segment.get(key, hash));
-    assertFalse(segment.containsKey(key, hash));
-    assertFalse(segment.containsValue(value));
+    assertThat(segment.containsKey(key, hash)).isFalse();
+    assertThat(segment.containsValue(value)).isFalse();
 
     // count == 1
     segment.count++;
-    assertSame(value, segment.get(key, hash));
-    assertTrue(segment.containsKey(key, hash));
-    assertTrue(segment.containsValue(value));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);
+    assertThat(segment.containsKey(key, hash)).isTrue();
+    assertThat(segment.containsValue(value)).isTrue();
     // don't see absent values now that count > 0
     assertNull(segment.get(new Object(), hash));
 
@@ -1253,10 +1265,10 @@ public void testSegmentGetAndContains() {
     nullEntry.setValueReference(nullValueRef);
     table.set(index, nullEntry);
     // skip the null key
-    assertSame(value, segment.get(key, hash));
-    assertTrue(segment.containsKey(key, hash));
-    assertTrue(segment.containsValue(value));
-    assertFalse(segment.containsValue(nullValue));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);
+    assertThat(segment.containsKey(key, hash)).isTrue();
+    assertThat(segment.containsValue(value)).isTrue();
+    assertThat(segment.containsValue(nullValue)).isFalse();
 
     // hash collision
     DummyEntry<Object, Object> dummy = DummyEntry.create(new Object(), hash, entry);
@@ -1264,10 +1276,10 @@ public void testSegmentGetAndContains() {
     ValueReference<Object, Object> dummyValueRef = map.newValueReference(dummy, dummyValue, 1);
     dummy.setValueReference(dummyValueRef);
     table.set(index, dummy);
-    assertSame(value, segment.get(key, hash));
-    assertTrue(segment.containsKey(key, hash));
-    assertTrue(segment.containsValue(value));
-    assertTrue(segment.containsValue(dummyValue));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);
+    assertThat(segment.containsKey(key, hash)).isTrue();
+    assertThat(segment.containsValue(value)).isTrue();
+    assertThat(segment.containsValue(dummyValue)).isTrue();
 
     // key collision
     dummy = DummyEntry.create(key, hash, entry);
@@ -1276,17 +1288,17 @@ public void testSegmentGetAndContains() {
     dummy.setValueReference(dummyValueRef);
     table.set(index, dummy);
     // returns the most recent entry
-    assertSame(dummyValue, segment.get(key, hash));
-    assertTrue(segment.containsKey(key, hash));
-    assertTrue(segment.containsValue(value));
-    assertTrue(segment.containsValue(dummyValue));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(dummyValue);
+    assertThat(segment.containsKey(key, hash)).isTrue();
+    assertThat(segment.containsValue(value)).isTrue();
+    assertThat(segment.containsValue(dummyValue)).isTrue();
 
     // expired
     dummy.setAccessTime(ticker.read() - 2);
     assertNull(segment.get(key, hash));
-    assertFalse(segment.containsKey(key, hash));
-    assertTrue(segment.containsValue(value));
-    assertFalse(segment.containsValue(dummyValue));
+    assertThat(segment.containsKey(key, hash)).isFalse();
+    assertThat(segment.containsValue(value)).isTrue();
+    assertThat(segment.containsValue(dummyValue)).isFalse();
   }
 
   public void testSegmentReplaceValue() {
@@ -1307,29 +1319,29 @@ public void testSegmentReplaceValue() {
     entry.setValueReference(oldValueRef);
 
     // no entry
-    assertFalse(segment.replace(key, hash, oldValue, newValue));
-    assertEquals(0, segment.count);
+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();
+    assertThat(segment.count).isEqualTo(0);
 
     // same value
     table.set(index, entry);
     segment.count++;
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
-    assertTrue(segment.replace(key, hash, oldValue, newValue));
-    assertEquals(1, segment.count);
-    assertSame(newValue, segment.get(key, hash));
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
+    assertThat(segment.replace(key, hash, oldValue, newValue)).isTrue();
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);
 
     // different value
-    assertFalse(segment.replace(key, hash, oldValue, newValue));
-    assertEquals(1, segment.count);
-    assertSame(newValue, segment.get(key, hash));
+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);
 
     // cleared
     entry.setValueReference(oldValueRef);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
     oldValueRef.clear();
-    assertFalse(segment.replace(key, hash, oldValue, newValue));
-    assertEquals(0, segment.count);
+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
   }
 
@@ -1352,23 +1364,23 @@ public void testSegmentReplace() {
 
     // no entry
     assertNull(segment.replace(key, hash, newValue));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
 
     // same key
     table.set(index, entry);
     segment.count++;
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
-    assertSame(oldValue, segment.replace(key, hash, newValue));
-    assertEquals(1, segment.count);
-    assertSame(newValue, segment.get(key, hash));
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
+    assertThat(segment.replace(key, hash, newValue)).isSameInstanceAs(oldValue);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);
 
     // cleared
     entry.setValueReference(oldValueRef);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
     oldValueRef.clear();
     assertNull(segment.replace(key, hash, newValue));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
   }
 
@@ -1384,24 +1396,24 @@ public void testSegmentPut() {
     Object newValue = new Object();
 
     // no entry
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.put(key, hash, oldValue, false));
-    assertEquals(1, segment.count);
+    assertThat(segment.count).isEqualTo(1);
 
     // same key
-    assertSame(oldValue, segment.put(key, hash, newValue, false));
-    assertEquals(1, segment.count);
-    assertSame(newValue, segment.get(key, hash));
+    assertThat(segment.put(key, hash, newValue, false)).isSameInstanceAs(oldValue);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);
 
     // cleared
     ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);
     DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);
     entry.setValueReference(oldValueRef);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
     oldValueRef.clear();
     assertNull(segment.put(key, hash, newValue, false));
-    assertEquals(1, segment.count);
-    assertSame(newValue, segment.get(key, hash));
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);
   }
 
   public void testSegmentPutIfAbsent() {
@@ -1416,31 +1428,31 @@ public void testSegmentPutIfAbsent() {
     Object newValue = new Object();
 
     // no entry
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.put(key, hash, oldValue, true));
-    assertEquals(1, segment.count);
+    assertThat(segment.count).isEqualTo(1);
 
     // same key
-    assertSame(oldValue, segment.put(key, hash, newValue, true));
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.put(key, hash, newValue, true)).isSameInstanceAs(oldValue);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
 
     // cleared
     ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);
     DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);
     entry.setValueReference(oldValueRef);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
     oldValueRef.clear();
     assertNull(segment.put(key, hash, newValue, true));
-    assertEquals(1, segment.count);
-    assertSame(newValue, segment.get(key, hash));
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);
   }
 
   public void testSegmentPut_expand() {
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
     Segment<Object, Object> segment = map.segments[0];
-    assertEquals(1, segment.table.length());
+    assertThat(segment.table.length()).isEqualTo(1);
 
     int count = 1024;
     for (int i = 0; i < count; i++) {
@@ -1448,7 +1460,7 @@ public void testSegmentPut_expand() {
       Object value = new Object();
       int hash = map.hash(key);
       assertNull(segment.put(key, hash, value, false));
-      assertTrue(segment.table.length() > i);
+      assertThat(segment.table.length()).isGreaterThan(i);
     }
   }
 
@@ -1470,7 +1482,7 @@ public void testSegmentPut_evict() {
         it.next();
         it.remove();
       }
-      assertEquals(originalMap, map);
+      assertThat(map).isEqualTo(originalMap);
     }
   }
 
@@ -1491,34 +1503,34 @@ public void testSegmentStoreComputedValue() {
 
     // absent
     Object value = new Object();
-    assertTrue(listener.isEmpty());
-    assertEquals(0, segment.count);
+    assertThat(listener.isEmpty()).isTrue();
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value));
-    assertSame(value, segment.get(key, hash));
-    assertEquals(1, segment.count);
-    assertTrue(listener.isEmpty());
+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value)).isTrue();
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(listener.isEmpty()).isTrue();
 
     // clobbered
     Object value2 = new Object();
-    assertFalse(segment.storeLoadedValue(key, hash, valueRef, value2));
-    assertEquals(1, segment.count);
-    assertSame(value, segment.get(key, hash));
+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value2)).isFalse();
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);
     RemovalNotification<Object, Object> notification = listener.remove();
-    assertEquals(immutableEntry(key, value2), notification);
-    assertEquals(RemovalCause.REPLACED, notification.getCause());
-    assertTrue(listener.isEmpty());
+    assertThat(notification).isEqualTo(immutableEntry(key, value2));
+    assertThat(notification.getCause()).isEqualTo(RemovalCause.REPLACED);
+    assertThat(listener.isEmpty()).isTrue();
 
     // inactive
     Object value3 = new Object();
     map.clear();
     listener.clear();
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     table.set(index, entry);
-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value3));
-    assertSame(value3, segment.get(key, hash));
-    assertEquals(1, segment.count);
-    assertTrue(listener.isEmpty());
+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value3)).isTrue();
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(listener.isEmpty()).isTrue();
 
     // replaced
     Object value4 = new Object();
@@ -1526,29 +1538,29 @@ public void testSegmentStoreComputedValue() {
     valueRef = new LoadingValueReference<>(value3Ref);
     entry.setValueReference(valueRef);
     table.set(index, entry);
-    assertSame(value3, segment.get(key, hash));
-    assertEquals(1, segment.count);
-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));
-    assertSame(value4, segment.get(key, hash));
-    assertEquals(1, segment.count);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value4)).isTrue();
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value4);
+    assertThat(segment.count).isEqualTo(1);
     notification = listener.remove();
-    assertEquals(immutableEntry(key, value3), notification);
-    assertEquals(RemovalCause.REPLACED, notification.getCause());
-    assertTrue(listener.isEmpty());
+    assertThat(notification).isEqualTo(immutableEntry(key, value3));
+    assertThat(notification.getCause()).isEqualTo(RemovalCause.REPLACED);
+    assertThat(listener.isEmpty()).isTrue();
 
     // collected
     entry.setValueReference(valueRef);
     table.set(index, entry);
-    assertSame(value3, segment.get(key, hash));
-    assertEquals(1, segment.count);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);
+    assertThat(segment.count).isEqualTo(1);
     value3Ref.clear();
-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));
-    assertSame(value4, segment.get(key, hash));
-    assertEquals(1, segment.count);
+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value4)).isTrue();
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value4);
+    assertThat(segment.count).isEqualTo(1);
     notification = listener.remove();
-    assertEquals(immutableEntry(key, null), notification);
-    assertEquals(RemovalCause.COLLECTED, notification.getCause());
-    assertTrue(listener.isEmpty());
+    assertThat(notification).isEqualTo(immutableEntry(key, null));
+    assertThat(notification.getCause()).isEqualTo(RemovalCause.COLLECTED);
+    assertThat(listener.isEmpty()).isTrue();
   }
 
   public void testSegmentRemove() {
@@ -1566,27 +1578,27 @@ public void testSegmentRemove() {
     entry.setValueReference(oldValueRef);
 
     // no entry
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.remove(key, hash));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
 
     // same key
     table.set(index, entry);
     segment.count++;
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
-    assertSame(oldValue, segment.remove(key, hash));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
+    assertThat(segment.remove(key, hash)).isSameInstanceAs(oldValue);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
 
     // cleared
     table.set(index, entry);
     segment.count++;
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
     oldValueRef.clear();
     assertNull(segment.remove(key, hash));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
   }
 
@@ -1606,33 +1618,33 @@ public void testSegmentRemoveValue() {
     entry.setValueReference(oldValueRef);
 
     // no entry
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.remove(key, hash));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(0);
 
     // same value
     table.set(index, entry);
     segment.count++;
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
-    assertTrue(segment.remove(key, hash, oldValue));
-    assertEquals(0, segment.count);
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
+    assertThat(segment.remove(key, hash, oldValue)).isTrue();
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
 
     // different value
     table.set(index, entry);
     segment.count++;
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
-    assertFalse(segment.remove(key, hash, newValue));
-    assertEquals(1, segment.count);
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
+    assertThat(segment.remove(key, hash, newValue)).isFalse();
+    assertThat(segment.count).isEqualTo(1);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
 
     // cleared
-    assertSame(oldValue, segment.get(key, hash));
+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);
     oldValueRef.clear();
-    assertFalse(segment.remove(key, hash, oldValue));
-    assertEquals(0, segment.count);
+    assertThat(segment.remove(key, hash, oldValue)).isFalse();
+    assertThat(segment.count).isEqualTo(0);
     assertNull(segment.get(key, hash));
   }
 
@@ -1640,7 +1652,7 @@ public void testExpand() {
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
     Segment<Object, Object> segment = map.segments[0];
-    assertEquals(1, segment.table.length());
+    assertThat(segment.table.length()).isEqualTo(1);
 
     // manually add elements to avoid expansion
     int originalCount = 1024;
@@ -1657,17 +1669,17 @@ public void testExpand() {
     segment.table.set(0, entry);
     segment.count = originalCount;
     ImmutableMap<Object, Object> originalMap = ImmutableMap.copyOf(map);
-    assertEquals(originalCount, originalMap.size());
-    assertEquals(originalMap, map);
+    assertThat(originalMap).hasSize(originalCount);
+    assertThat(map).isEqualTo(originalMap);
 
     for (int i = 1; i <= originalCount * 2; i *= 2) {
       if (i > 1) {
         segment.expand();
       }
-      assertEquals(i, segment.table.length());
-      assertEquals(originalCount, countLiveEntries(map, 0));
-      assertEquals(originalCount, segment.count);
-      assertEquals(originalMap, map);
+      assertThat(segment.table.length()).isEqualTo(i);
+      assertThat(countLiveEntries(map, 0)).isEqualTo(originalCount);
+      assertThat(segment.count).isEqualTo(originalCount);
+      assertThat(map).isEqualTo(originalMap);
     }
   }
 
@@ -1676,7 +1688,7 @@ public void testGetCausesExpansion() throws ExecutionException {
       LocalCache<Object, Object> map =
           makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
       Segment<Object, Object> segment = map.segments[0];
-      assertEquals(1, segment.table.length());
+      assertThat(segment.table.length()).isEqualTo(1);
 
       for (int i = 0; i < count; i++) {
         Object key = new Object();
@@ -1691,10 +1703,10 @@ public Object load(Object key) {
               }
             });
       }
-      assertEquals(count, segment.count);
-      assertTrue(count <= segment.threshold);
-      assertTrue(count <= (segment.table.length() * 3 / 4));
-      assertTrue(count > (segment.table.length() * 3 / 8));
+      assertThat(segment.count).isEqualTo(count);
+      assertThat(count).isAtMost(segment.threshold);
+      assertThat(count).isAtMost((segment.table.length() * 3 / 4));
+      assertThat(count).isGreaterThan(segment.table.length() * 3 / 8);
     }
   }
 
@@ -1702,8 +1714,8 @@ public void testGetOrDefault() {
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
     map.put(1, 1);
-    assertEquals(1, map.getOrDefault(1, 2));
-    assertEquals(2, map.getOrDefault(2, 2));
+    assertThat(map.getOrDefault(1, 2)).isEqualTo(1);
+    assertThat(map.getOrDefault(2, 2)).isEqualTo(2);
   }
 
   public void testPutCausesExpansion() {
@@ -1711,17 +1723,17 @@ public void testPutCausesExpansion() {
       LocalCache<Object, Object> map =
           makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
       Segment<Object, Object> segment = map.segments[0];
-      assertEquals(1, segment.table.length());
+      assertThat(segment.table.length()).isEqualTo(1);
 
       for (int i = 0; i < count; i++) {
         Object key = new Object();
         Object value = new Object();
         segment.put(key, key.hashCode(), value, true);
       }
-      assertEquals(count, segment.count);
-      assertTrue(count <= segment.threshold);
-      assertTrue(count <= (segment.table.length() * 3 / 4));
-      assertTrue(count > (segment.table.length() * 3 / 8));
+      assertThat(segment.count).isEqualTo(count);
+      assertThat(count).isAtMost(segment.threshold);
+      assertThat(count).isAtMost((segment.table.length() * 3 / 4));
+      assertThat(count).isGreaterThan(segment.table.length() * 3 / 8);
     }
   }
 
@@ -1737,7 +1749,7 @@ public void testReclaimKey() {
                 .removalListener(listener));
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(1, table.length());
+    assertThat(table.length()).isEqualTo(1);
 
     // create 3 objects and chain them together
     Object keyOne = new Object();
@@ -1755,28 +1767,28 @@ public void testReclaimKey() {
         createDummyEntry(keyThree, hashThree, valueThree, entryTwo);
 
     // absent
-    assertEquals(0, listener.getCount());
-    assertFalse(segment.reclaimKey(entryOne, hashOne));
-    assertEquals(0, listener.getCount());
+    assertThat(listener.getCount()).isEqualTo(0);
+    assertThat(segment.reclaimKey(entryOne, hashOne)).isFalse();
+    assertThat(listener.getCount()).isEqualTo(0);
     table.set(0, entryOne);
-    assertFalse(segment.reclaimKey(entryTwo, hashTwo));
-    assertEquals(0, listener.getCount());
+    assertThat(segment.reclaimKey(entryTwo, hashTwo)).isFalse();
+    assertThat(listener.getCount()).isEqualTo(0);
     table.set(0, entryTwo);
-    assertFalse(segment.reclaimKey(entryThree, hashThree));
-    assertEquals(0, listener.getCount());
+    assertThat(segment.reclaimKey(entryThree, hashThree)).isFalse();
+    assertThat(listener.getCount()).isEqualTo(0);
 
     // present
     table.set(0, entryOne);
     segment.count = 1;
-    assertTrue(segment.reclaimKey(entryOne, hashOne));
-    assertEquals(1, listener.getCount());
-    assertSame(keyOne, listener.getLastEvictedKey());
-    assertSame(valueOne, listener.getLastEvictedValue());
-    assertTrue(map.removalNotificationQueue.isEmpty());
-    assertFalse(segment.accessQueue.contains(entryOne));
-    assertFalse(segment.writeQueue.contains(entryOne));
-    assertEquals(0, segment.count);
-    assertNull(table.get(0));
+    assertThat(segment.reclaimKey(entryOne, hashOne)).isTrue();
+    assertThat(listener.getCount()).isEqualTo(1);
+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(keyOne);
+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(valueOne);
+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();
+    assertThat(segment.accessQueue.contains(entryOne)).isFalse();
+    assertThat(segment.writeQueue.contains(entryOne)).isFalse();
+    assertThat(segment.count).isEqualTo(0);
+    assertThat(table.get(0)).isNull();
   }
 
   public void testRemoveEntryFromChain() {
@@ -1802,32 +1814,32 @@ public void testRemoveEntryFromChain() {
     assertNull(segment.removeEntryFromChain(entryOne, entryOne));
 
     // head
-    assertSame(entryOne, segment.removeEntryFromChain(entryTwo, entryTwo));
+    assertThat(segment.removeEntryFromChain(entryTwo, entryTwo)).isSameInstanceAs(entryOne);
 
     // middle
     ReferenceEntry<Object, Object> newFirst = segment.removeEntryFromChain(entryThree, entryTwo);
-    assertSame(keyThree, newFirst.getKey());
-    assertSame(valueThree, newFirst.getValueReference().get());
-    assertEquals(hashThree, newFirst.getHash());
-    assertSame(entryOne, newFirst.getNext());
+    assertThat(newFirst.getKey()).isSameInstanceAs(keyThree);
+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueThree);
+    assertThat(newFirst.getHash()).isEqualTo(hashThree);
+    assertThat(newFirst.getNext()).isSameInstanceAs(entryOne);
 
     // tail (remaining entries are copied in reverse order)
     newFirst = segment.removeEntryFromChain(entryThree, entryOne);
-    assertSame(keyTwo, newFirst.getKey());
-    assertSame(valueTwo, newFirst.getValueReference().get());
-    assertEquals(hashTwo, newFirst.getHash());
+    assertThat(newFirst.getKey()).isSameInstanceAs(keyTwo);
+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueTwo);
+    assertThat(newFirst.getHash()).isEqualTo(hashTwo);
     newFirst = newFirst.getNext();
-    assertSame(keyThree, newFirst.getKey());
-    assertSame(valueThree, newFirst.getValueReference().get());
-    assertEquals(hashThree, newFirst.getHash());
-    assertNull(newFirst.getNext());
+    assertThat(newFirst.getKey()).isSameInstanceAs(keyThree);
+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueThree);
+    assertThat(newFirst.getHash()).isEqualTo(hashThree);
+    assertThat(newFirst.getNext()).isNull();
   }
 
   public void testExpand_cleanup() {
     LocalCache<Object, Object> map =
         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));
     Segment<Object, Object> segment = map.segments[0];
-    assertEquals(1, segment.table.length());
+    assertThat(segment.table.length()).isEqualTo(1);
 
     // manually add elements to avoid expansion
     // 1/3 null keys, 1/3 null values
@@ -1848,22 +1860,22 @@ public void testExpand_cleanup() {
     segment.table.set(0, entry);
     segment.count = originalCount;
     int liveCount = originalCount / 3;
-    assertEquals(1, segment.table.length());
-    assertEquals(liveCount, countLiveEntries(map, 0));
+    assertThat(segment.table.length()).isEqualTo(1);
+    assertThat(countLiveEntries(map, 0)).isEqualTo(liveCount);
     ImmutableMap<Object, Object> originalMap = ImmutableMap.copyOf(map);
-    assertEquals(liveCount, originalMap.size());
+    assertThat(originalMap).hasSize(liveCount);
     // can't compare map contents until cleanup occurs
 
     for (int i = 1; i <= originalCount * 2; i *= 2) {
       if (i > 1) {
         segment.expand();
       }
-      assertEquals(i, segment.table.length());
-      assertEquals(liveCount, countLiveEntries(map, 0));
+      assertThat(segment.table.length()).isEqualTo(i);
+      assertThat(countLiveEntries(map, 0)).isEqualTo(liveCount);
       // expansion cleanup is sloppy, with a goal of avoiding unnecessary copies
-      assertTrue(segment.count >= liveCount);
-      assertTrue(segment.count <= originalCount);
-      assertEquals(originalMap, ImmutableMap.copyOf(map));
+      assertThat(segment.count).isAtLeast(liveCount);
+      assertThat(segment.count).isAtMost(originalCount);
+      assertThat(ImmutableMap.copyOf(map)).isEqualTo(originalMap);
     }
   }
 
@@ -1883,8 +1895,8 @@ public void testRemoveIfWithConcurrentModification() {
                 return false;
               }
             });
-    assertEquals(3, map.size());
-    assertFalse(map.containsValue(1));
+    assertThat(map).hasSize(3);
+    assertThat(map.containsValue(1)).isFalse();
   }
 
   public void testRemoveIfWithConcurrentRemoval() {
@@ -1900,7 +1912,7 @@ public void testRemoveIfWithConcurrentRemoval() {
               map.remove((entry.getKey() + 1) % 3);
               return false;
             });
-    assertEquals(1, map.size());
+    assertThat(map).hasSize(1);
   }
 
   private static <K, V> int countLiveEntries(LocalCache<K, V> map, long now) {
@@ -1928,7 +1940,7 @@ public void testClear() {
                 .expireAfterWrite(99999, SECONDS));
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(1, table.length());
+    assertThat(table.length()).isEqualTo(1);
 
     Object key = new Object();
     Object value = new Object();
@@ -1940,17 +1952,17 @@ public void testClear() {
     segment.count = 1;
     segment.totalWeight = 1;
 
-    assertSame(entry, table.get(0));
-    assertSame(entry, segment.accessQueue.peek());
-    assertSame(entry, segment.writeQueue.peek());
+    assertThat(table.get(0)).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);
 
     segment.clear();
-    assertNull(table.get(0));
-    assertTrue(segment.accessQueue.isEmpty());
-    assertTrue(segment.writeQueue.isEmpty());
-    assertEquals(0, segment.readCount.get());
-    assertEquals(0, segment.count);
-    assertEquals(0, segment.totalWeight);
+    assertThat(table.get(0)).isNull();
+    assertThat(segment.accessQueue.isEmpty()).isTrue();
+    assertThat(segment.writeQueue.isEmpty()).isTrue();
+    assertThat(segment.readCount.get()).isEqualTo(0);
+    assertThat(segment.count).isEqualTo(0);
+    assertThat(segment.totalWeight).isEqualTo(0);
   }
 
   public void testClear_notification() {
@@ -1965,7 +1977,7 @@ public void testClear_notification() {
                 .removalListener(listener));
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(1, table.length());
+    assertThat(table.length()).isEqualTo(1);
 
     Object key = new Object();
     Object value = new Object();
@@ -1977,17 +1989,17 @@ public void testClear_notification() {
     segment.count = 1;
     segment.totalWeight = 1;
 
-    assertSame(entry, table.get(0));
-    assertSame(entry, segment.accessQueue.peek());
-    assertSame(entry, segment.writeQueue.peek());
+    assertThat(table.get(0)).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);
 
     segment.clear();
-    assertNull(table.get(0));
-    assertTrue(segment.accessQueue.isEmpty());
-    assertTrue(segment.writeQueue.isEmpty());
-    assertEquals(0, segment.readCount.get());
-    assertEquals(0, segment.count);
-    assertEquals(0, segment.totalWeight);
+    assertThat(table.get(0)).isNull();
+    assertThat(segment.accessQueue.isEmpty()).isTrue();
+    assertThat(segment.writeQueue.isEmpty()).isTrue();
+    assertThat(segment.readCount.get()).isEqualTo(0);
+    assertThat(segment.count).isEqualTo(0);
+    assertThat(segment.totalWeight).isEqualTo(0);
     assertNotified(listener, key, value, RemovalCause.EXPLICIT);
   }
 
@@ -2002,7 +2014,7 @@ public void testRemoveEntry() {
                 .removalListener(countingRemovalListener()));
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(1, table.length());
+    assertThat(table.length()).isEqualTo(1);
 
     Object key = new Object();
     Object value = new Object();
@@ -2010,19 +2022,19 @@ public void testRemoveEntry() {
     DummyEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);
 
     // remove absent
-    assertFalse(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));
+    assertThat(segment.removeEntry(entry, hash, RemovalCause.COLLECTED)).isFalse();
 
     // remove live
     segment.recordWrite(entry, 1, map.ticker.read());
     table.set(0, entry);
     segment.count = 1;
-    assertTrue(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));
+    assertThat(segment.removeEntry(entry, hash, RemovalCause.COLLECTED)).isTrue();
     assertNotificationEnqueued(map, key, value);
-    assertTrue(map.removalNotificationQueue.isEmpty());
-    assertFalse(segment.accessQueue.contains(entry));
-    assertFalse(segment.writeQueue.contains(entry));
-    assertEquals(0, segment.count);
-    assertNull(table.get(0));
+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();
+    assertThat(segment.accessQueue.contains(entry)).isFalse();
+    assertThat(segment.writeQueue.contains(entry)).isFalse();
+    assertThat(segment.count).isEqualTo(0);
+    assertThat(table.get(0)).isNull();
   }
 
   public void testReclaimValue() {
@@ -2037,7 +2049,7 @@ public void testReclaimValue() {
                 .removalListener(listener));
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(1, table.length());
+    assertThat(table.length()).isEqualTo(1);
 
     Object key = new Object();
     Object value = new Object();
@@ -2047,32 +2059,32 @@ public void testReclaimValue() {
     entry.setValueReference(valueRef);
 
     // reclaim absent
-    assertFalse(segment.reclaimValue(key, hash, valueRef));
+    assertThat(segment.reclaimValue(key, hash, valueRef)).isFalse();
 
     // reclaim live
     segment.recordWrite(entry, 1, map.ticker.read());
     table.set(0, entry);
     segment.count = 1;
-    assertTrue(segment.reclaimValue(key, hash, valueRef));
-    assertEquals(1, listener.getCount());
-    assertSame(key, listener.getLastEvictedKey());
-    assertSame(value, listener.getLastEvictedValue());
-    assertTrue(map.removalNotificationQueue.isEmpty());
-    assertFalse(segment.accessQueue.contains(entry));
-    assertFalse(segment.writeQueue.contains(entry));
-    assertEquals(0, segment.count);
-    assertNull(table.get(0));
+    assertThat(segment.reclaimValue(key, hash, valueRef)).isTrue();
+    assertThat(listener.getCount()).isEqualTo(1);
+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(key);
+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(value);
+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();
+    assertThat(segment.accessQueue.contains(entry)).isFalse();
+    assertThat(segment.writeQueue.contains(entry)).isFalse();
+    assertThat(segment.count).isEqualTo(0);
+    assertThat(table.get(0)).isNull();
 
     // reclaim wrong value reference
     table.set(0, entry);
     DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);
     entry.setValueReference(otherValueRef);
-    assertFalse(segment.reclaimValue(key, hash, valueRef));
-    assertEquals(1, listener.getCount());
-    assertTrue(segment.reclaimValue(key, hash, otherValueRef));
-    assertEquals(2, listener.getCount());
-    assertSame(key, listener.getLastEvictedKey());
-    assertSame(value, listener.getLastEvictedValue());
+    assertThat(segment.reclaimValue(key, hash, valueRef)).isFalse();
+    assertThat(listener.getCount()).isEqualTo(1);
+    assertThat(segment.reclaimValue(key, hash, otherValueRef)).isTrue();
+    assertThat(listener.getCount()).isEqualTo(2);
+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(key);
+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(value);
   }
 
   public void testRemoveComputingValue() {
@@ -2086,7 +2098,7 @@ public void testRemoveComputingValue() {
                 .removalListener(countingRemovalListener()));
     Segment<Object, Object> segment = map.segments[0];
     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;
-    assertEquals(1, table.length());
+    assertThat(table.length()).isEqualTo(1);
 
     Object key = new Object();
     int hash = map.hash(key);
@@ -2095,16 +2107,16 @@ public void testRemoveComputingValue() {
     entry.setValueReference(valueRef);
 
     // absent
-    assertFalse(segment.removeLoadingValue(key, hash, valueRef));
+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isFalse();
 
     // live
     table.set(0, entry);
     // don't increment count; this is used during computation
-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));
+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();
     // no notification sent with removeLoadingValue
-    assertTrue(map.removalNotificationQueue.isEmpty());
-    assertEquals(0, segment.count);
-    assertNull(table.get(0));
+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();
+    assertThat(segment.count).isEqualTo(0);
+    assertThat(table.get(0)).isNull();
 
     // active
     Object value = new Object();
@@ -2113,23 +2125,23 @@ public void testRemoveComputingValue() {
     entry.setValueReference(valueRef);
     table.set(0, entry);
     segment.count = 1;
-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));
-    assertSame(entry, table.get(0));
-    assertSame(value, segment.get(key, hash));
+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();
+    assertThat(table.get(0)).isSameInstanceAs(entry);
+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);
 
     // wrong value reference
     table.set(0, entry);
     DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);
     entry.setValueReference(otherValueRef);
-    assertFalse(segment.removeLoadingValue(key, hash, valueRef));
+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isFalse();
     entry.setValueReference(valueRef);
-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));
+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();
   }
 
   private static <K, V> void assertNotificationEnqueued(LocalCache<K, V> map, K key, V value) {
     RemovalNotification<K, V> notification = map.removalNotificationQueue.poll();
-    assertSame(key, notification.getKey());
-    assertSame(value, notification.getValue());
+    assertThat(notification.getKey()).isSameInstanceAs(key);
+    assertThat(notification.getValue()).isSameInstanceAs(value);
   }
 
   // Segment eviction tests
@@ -2146,15 +2158,15 @@ public void testDrainRecencyQueueOnWrite() {
         Object valueTwo = new Object();
 
         map.put(keyOne, valueOne);
-        assertTrue(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isTrue();
 
         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {
           map.get(keyOne);
         }
-        assertFalse(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isFalse();
 
         map.put(keyTwo, valueTwo);
-        assertTrue(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isTrue();
       }
     }
   }
@@ -2171,16 +2183,16 @@ public void testDrainRecencyQueueOnRead() {
         // repeated get of the same key
 
         map.put(keyOne, valueOne);
-        assertTrue(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isTrue();
 
         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {
           map.get(keyOne);
         }
-        assertFalse(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isFalse();
 
         for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {
           map.get(keyOne);
-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);
+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);
         }
 
         // get over many different keys
@@ -2188,16 +2200,16 @@ public void testDrainRecencyQueueOnRead() {
         for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {
           map.put(new Object(), new Object());
         }
-        assertTrue(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isTrue();
 
         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {
           map.get(keyOne);
         }
-        assertFalse(segment.recencyQueue.isEmpty());
+        assertThat(segment.recencyQueue.isEmpty()).isFalse();
 
         for (Object key : map.keySet()) {
           map.get(key);
-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);
+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);
         }
       }
     }
@@ -2263,7 +2275,7 @@ public void testRecordReadOnGet() {
 
       checkEvictionQueues(map, segment, readOrder, writeOrder);
       checkExpirationTimes(map);
-      assertTrue(segment.recencyQueue.isEmpty());
+      assertThat(segment.recencyQueue.isEmpty()).isTrue();
 
       // access some of the elements
       Random random = new Random();
@@ -2275,7 +2287,7 @@ public void testRecordReadOnGet() {
           map.get(entry.getKey());
           reads.add(entry);
           i.remove();
-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);
+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);
         }
       }
       int undrainedIndex = reads.size() - segment.recencyQueue.size();
@@ -2349,12 +2361,13 @@ static <K, V> void checkEvictionQueues(
   private static <K, V> void assertSameEntries(
       List<ReferenceEntry<K, V>> expectedEntries, List<ReferenceEntry<K, V>> actualEntries) {
     int size = expectedEntries.size();
-    assertEquals(size, actualEntries.size());
+    assertThat(actualEntries).hasSize(size);
     for (int i = 0; i < size; i++) {
       ReferenceEntry<K, V> expectedEntry = expectedEntries.get(i);
       ReferenceEntry<K, V> actualEntry = actualEntries.get(i);
-      assertSame(expectedEntry.getKey(), actualEntry.getKey());
-      assertSame(expectedEntry.getValueReference().get(), actualEntry.getValueReference().get());
+      assertThat(actualEntry.getKey()).isSameInstanceAs(expectedEntry.getKey());
+      assertThat(actualEntry.getValueReference().get())
+          .isSameInstanceAs(expectedEntry.getValueReference().get());
     }
   }
 
@@ -2368,10 +2381,10 @@ static <K, V> void checkExpirationTimes(LocalCache<K, V> map) {
       long lastWriteTime = 0;
       for (ReferenceEntry<K, V> e : segment.recencyQueue) {
         long accessTime = e.getAccessTime();
-        assertTrue(accessTime >= lastAccessTime);
+        assertThat(accessTime).isAtLeast(lastAccessTime);
         lastAccessTime = accessTime;
         long writeTime = e.getWriteTime();
-        assertTrue(writeTime >= lastWriteTime);
+        assertThat(writeTime).isAtLeast(lastWriteTime);
         lastWriteTime = writeTime;
       }
 
@@ -2379,12 +2392,12 @@ static <K, V> void checkExpirationTimes(LocalCache<K, V> map) {
       lastWriteTime = 0;
       for (ReferenceEntry<K, V> e : segment.accessQueue) {
         long accessTime = e.getAccessTime();
-        assertTrue(accessTime >= lastAccessTime);
+        assertThat(accessTime).isAtLeast(lastAccessTime);
         lastAccessTime = accessTime;
       }
       for (ReferenceEntry<K, V> e : segment.writeQueue) {
         long writeTime = e.getWriteTime();
-        assertTrue(writeTime >= lastWriteTime);
+        assertThat(writeTime).isAtLeast(lastWriteTime);
         lastWriteTime = writeTime;
       }
     }
@@ -2404,31 +2417,31 @@ public void testExpireAfterWrite() {
     Object value = new Object();
     map.put(key, value);
     ReferenceEntry<Object, Object> entry = map.getEntry(key);
-    assertTrue(map.isLive(entry, ticker.read()));
+    assertThat(map.isLive(entry, ticker.read())).isTrue();
 
     segment.writeQueue.add(entry);
-    assertSame(value, map.get(key));
-    assertSame(entry, segment.writeQueue.peek());
-    assertEquals(1, segment.writeQueue.size());
+    assertThat(map.get(key)).isSameInstanceAs(value);
+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.writeQueue).hasSize(1);
 
     segment.recordRead(entry, ticker.read());
     segment.expireEntries(ticker.read());
-    assertSame(value, map.get(key));
-    assertSame(entry, segment.writeQueue.peek());
-    assertEquals(1, segment.writeQueue.size());
+    assertThat(map.get(key)).isSameInstanceAs(value);
+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.writeQueue).hasSize(1);
 
     ticker.advance(1);
     segment.recordRead(entry, ticker.read());
     segment.expireEntries(ticker.read());
-    assertSame(value, map.get(key));
-    assertSame(entry, segment.writeQueue.peek());
-    assertEquals(1, segment.writeQueue.size());
+    assertThat(map.get(key)).isSameInstanceAs(value);
+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.writeQueue).hasSize(1);
 
     ticker.advance(1);
-    assertNull(map.get(key));
+    assertThat(map.get(key)).isNull();
     segment.expireEntries(ticker.read());
-    assertNull(map.get(key));
-    assertTrue(segment.writeQueue.isEmpty());
+    assertThat(map.get(key)).isNull();
+    assertThat(segment.writeQueue.isEmpty()).isTrue();
   }
 
   public void testExpireAfterAccess() {
@@ -2445,46 +2458,46 @@ public void testExpireAfterAccess() {
     Object value = new Object();
     map.put(key, value);
     ReferenceEntry<Object, Object> entry = map.getEntry(key);
-    assertTrue(map.isLive(entry, ticker.read()));
+    assertThat(map.isLive(entry, ticker.read())).isTrue();
 
     segment.accessQueue.add(entry);
-    assertSame(value, map.get(key));
-    assertSame(entry, segment.accessQueue.peek());
-    assertEquals(1, segment.accessQueue.size());
+    assertThat(map.get(key)).isSameInstanceAs(value);
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue).hasSize(1);
 
     segment.recordRead(entry, ticker.read());
     segment.expireEntries(ticker.read());
-    assertTrue(map.containsKey(key));
-    assertSame(entry, segment.accessQueue.peek());
-    assertEquals(1, segment.accessQueue.size());
+    assertThat(map.containsKey(key)).isTrue();
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue).hasSize(1);
 
     ticker.advance(1);
     segment.recordRead(entry, ticker.read());
     segment.expireEntries(ticker.read());
-    assertTrue(map.containsKey(key));
-    assertSame(entry, segment.accessQueue.peek());
-    assertEquals(1, segment.accessQueue.size());
+    assertThat(map.containsKey(key)).isTrue();
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue).hasSize(1);
 
     ticker.advance(1);
     segment.recordRead(entry, ticker.read());
     segment.expireEntries(ticker.read());
-    assertTrue(map.containsKey(key));
-    assertSame(entry, segment.accessQueue.peek());
-    assertEquals(1, segment.accessQueue.size());
+    assertThat(map.containsKey(key)).isTrue();
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue).hasSize(1);
 
     ticker.advance(1);
     segment.expireEntries(ticker.read());
-    assertTrue(map.containsKey(key));
-    assertSame(entry, segment.accessQueue.peek());
-    assertEquals(1, segment.accessQueue.size());
+    assertThat(map.containsKey(key)).isTrue();
+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);
+    assertThat(segment.accessQueue).hasSize(1);
 
     ticker.advance(1);
-    assertFalse(map.containsKey(key));
-    assertNull(map.get(key));
+    assertThat(map.containsKey(key)).isFalse();
+    assertThat(map.get(key)).isNull();
     segment.expireEntries(ticker.read());
-    assertFalse(map.containsKey(key));
-    assertNull(map.get(key));
-    assertTrue(segment.accessQueue.isEmpty());
+    assertThat(map.containsKey(key)).isFalse();
+    assertThat(map.get(key)).isNull();
+    assertThat(segment.accessQueue.isEmpty()).isTrue();
   }
 
   public void testEvictEntries() {
@@ -2513,8 +2526,8 @@ public void testEvictEntries() {
     }
     segment.count = originalCount;
     segment.totalWeight = originalCount;
-    assertEquals(originalCount, map.size());
-    assertEquals(originalMap, map);
+    assertThat(map).hasSize(originalCount);
+    assertThat(map).isEqualTo(originalMap);
 
     Iterator<Object> it = originalMap.keySet().iterator();
     for (int i = 0; i < originalCount - maxSize; i++) {
@@ -2522,8 +2535,8 @@ public void testEvictEntries() {
       it.remove();
     }
     segment.evictEntries(entry);
-    assertEquals(maxSize, map.size());
-    assertEquals(originalMap, map);
+    assertThat(map).hasSize(maxSize);
+    assertThat(map).isEqualTo(originalMap);
   }
 
   // reference queues
@@ -2548,11 +2561,11 @@ public void testDrainKeyReferenceQueueOnWrite() {
         reference.enqueue();
 
         map.put(keyTwo, valueTwo);
-        assertFalse(map.containsKey(keyOne));
-        assertFalse(map.containsValue(valueOne));
-        assertNull(map.get(keyOne));
-        assertEquals(1, map.size());
-        assertNull(segment.keyReferenceQueue.poll());
+        assertThat(map.containsKey(keyOne)).isFalse();
+        assertThat(map.containsValue(valueOne)).isFalse();
+        assertThat(map.get(keyOne)).isNull();
+        assertThat(map).hasSize(1);
+        assertThat(segment.keyReferenceQueue.poll()).isNull();
       }
     }
   }
@@ -2578,11 +2591,11 @@ public void testDrainValueReferenceQueueOnWrite() {
         reference.enqueue();
 
         map.put(keyTwo, valueTwo);
-        assertFalse(map.containsKey(keyOne));
-        assertFalse(map.containsValue(valueOne));
-        assertNull(map.get(keyOne));
-        assertEquals(1, map.size());
-        assertNull(segment.valueReferenceQueue.poll());
+        assertThat(map.containsKey(keyOne)).isFalse();
+        assertThat(map.containsValue(valueOne)).isFalse();
+        assertThat(map.get(keyOne)).isNull();
+        assertThat(map).hasSize(1);
+        assertThat(segment.valueReferenceQueue.poll()).isNull();
       }
     }
   }
@@ -2608,11 +2621,11 @@ public void testDrainKeyReferenceQueueOnRead() {
         for (int i = 0; i < SMALL_MAX_SIZE; i++) {
           map.get(keyTwo);
         }
-        assertFalse(map.containsKey(keyOne));
-        assertFalse(map.containsValue(valueOne));
-        assertNull(map.get(keyOne));
-        assertEquals(0, map.size());
-        assertNull(segment.keyReferenceQueue.poll());
+        assertThat(map.containsKey(keyOne)).isFalse();
+        assertThat(map.containsValue(valueOne)).isFalse();
+        assertThat(map.get(keyOne)).isNull();
+        assertThat(map).isEmpty();
+        assertThat(segment.keyReferenceQueue.poll()).isNull();
       }
     }
   }
@@ -2639,11 +2652,11 @@ public void testDrainValueReferenceQueueOnRead() {
         for (int i = 0; i < SMALL_MAX_SIZE; i++) {
           map.get(keyTwo);
         }
-        assertFalse(map.containsKey(keyOne));
-        assertFalse(map.containsValue(valueOne));
-        assertNull(map.get(keyOne));
-        assertEquals(0, map.size());
-        assertNull(segment.valueReferenceQueue.poll());
+        assertThat(map.containsKey(keyOne)).isFalse();
+        assertThat(map.containsValue(valueOne)).isFalse();
+        assertThat(map.get(keyOne)).isNull();
+        assertThat(map).isEmpty();
+        assertThat(segment.valueReferenceQueue.poll()).isNull();
       }
     }
   }
@@ -2676,42 +2689,45 @@ public void testSerializationProxyLoading() {
                 .build(loader);
     // add a non-serializable entry
     one.getUnchecked(new Object());
-    assertEquals(1, one.size());
-    assertFalse(one.asMap().isEmpty());
+    assertThat(one.size()).isEqualTo(1);
+    assertThat(one.asMap().isEmpty()).isFalse();
     LocalLoadingCache<Object, Object> two = SerializableTester.reserialize(one);
-    assertEquals(0, two.size());
-    assertTrue(two.asMap().isEmpty());
+    assertThat(two.size()).isEqualTo(0);
+    assertThat(two.asMap().isEmpty()).isTrue();
 
     LocalCache<Object, Object> localCacheOne = one.localCache;
     LocalCache<Object, Object> localCacheTwo = two.localCache;
 
-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);
-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);
-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);
-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);
-    assertEquals(localCacheOne.maxWeight, localCacheTwo.maxWeight);
-    assertEquals(localCacheOne.weigher, localCacheTwo.weigher);
-    assertEquals(localCacheOne.expireAfterAccessNanos, localCacheTwo.expireAfterAccessNanos);
-    assertEquals(localCacheOne.expireAfterWriteNanos, localCacheTwo.expireAfterWriteNanos);
-    assertEquals(localCacheOne.refreshNanos, localCacheTwo.refreshNanos);
-    assertEquals(localCacheOne.removalListener, localCacheTwo.removalListener);
-    assertEquals(localCacheOne.ticker, localCacheTwo.ticker);
+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);
+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);
+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);
+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);
+    assertThat(localCacheTwo.maxWeight).isEqualTo(localCacheOne.maxWeight);
+    assertThat(localCacheTwo.weigher).isEqualTo(localCacheOne.weigher);
+    assertThat(localCacheTwo.expireAfterAccessNanos)
+        .isEqualTo(localCacheOne.expireAfterAccessNanos);
+    assertThat(localCacheTwo.expireAfterWriteNanos).isEqualTo(localCacheOne.expireAfterWriteNanos);
+    assertThat(localCacheTwo.refreshNanos).isEqualTo(localCacheOne.refreshNanos);
+    assertThat(localCacheTwo.removalListener).isEqualTo(localCacheOne.removalListener);
+    assertThat(localCacheTwo.ticker).isEqualTo(localCacheOne.ticker);
 
     // serialize the reconstituted version to be sure we haven't lost the ability to reserialize
     LocalLoadingCache<Object, Object> three = SerializableTester.reserialize(two);
     LocalCache<Object, Object> localCacheThree = three.localCache;
 
-    assertEquals(localCacheTwo.defaultLoader, localCacheThree.defaultLoader);
-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);
-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);
-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);
-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);
-    assertEquals(localCacheTwo.maxWeight, localCacheThree.maxWeight);
-    assertEquals(localCacheTwo.weigher, localCacheThree.weigher);
-    assertEquals(localCacheTwo.expireAfterAccessNanos, localCacheThree.expireAfterAccessNanos);
-    assertEquals(localCacheTwo.expireAfterWriteNanos, localCacheThree.expireAfterWriteNanos);
-    assertEquals(localCacheTwo.removalListener, localCacheThree.removalListener);
-    assertEquals(localCacheTwo.ticker, localCacheThree.ticker);
+    assertThat(localCacheThree.defaultLoader).isEqualTo(localCacheTwo.defaultLoader);
+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);
+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);
+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);
+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);
+    assertThat(localCacheThree.maxWeight).isEqualTo(localCacheTwo.maxWeight);
+    assertThat(localCacheThree.weigher).isEqualTo(localCacheTwo.weigher);
+    assertThat(localCacheThree.expireAfterAccessNanos)
+        .isEqualTo(localCacheTwo.expireAfterAccessNanos);
+    assertThat(localCacheThree.expireAfterWriteNanos)
+        .isEqualTo(localCacheTwo.expireAfterWriteNanos);
+    assertThat(localCacheThree.removalListener).isEqualTo(localCacheTwo.removalListener);
+    assertThat(localCacheThree.ticker).isEqualTo(localCacheTwo.ticker);
   }
 
   public void testSerializationProxyManual() {
@@ -2733,40 +2749,43 @@ public void testSerializationProxyManual() {
                 .build();
     // add a non-serializable entry
     one.put(new Object(), new Object());
-    assertEquals(1, one.size());
-    assertFalse(one.asMap().isEmpty());
+    assertThat(one.size()).isEqualTo(1);
+    assertThat(one.asMap().isEmpty()).isFalse();
     LocalManualCache<Object, Object> two = SerializableTester.reserialize(one);
-    assertEquals(0, two.size());
-    assertTrue(two.asMap().isEmpty());
+    assertThat(two.size()).isEqualTo(0);
+    assertThat(two.asMap().isEmpty()).isTrue();
 
     LocalCache<Object, Object> localCacheOne = one.localCache;
     LocalCache<Object, Object> localCacheTwo = two.localCache;
 
-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);
-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);
-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);
-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);
-    assertEquals(localCacheOne.maxWeight, localCacheTwo.maxWeight);
-    assertEquals(localCacheOne.weigher, localCacheTwo.weigher);
-    assertEquals(localCacheOne.expireAfterAccessNanos, localCacheTwo.expireAfterAccessNanos);
-    assertEquals(localCacheOne.expireAfterWriteNanos, localCacheTwo.expireAfterWriteNanos);
-    assertEquals(localCacheOne.removalListener, localCacheTwo.removalListener);
-    assertEquals(localCacheOne.ticker, localCacheTwo.ticker);
+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);
+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);
+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);
+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);
+    assertThat(localCacheTwo.maxWeight).isEqualTo(localCacheOne.maxWeight);
+    assertThat(localCacheTwo.weigher).isEqualTo(localCacheOne.weigher);
+    assertThat(localCacheTwo.expireAfterAccessNanos)
+        .isEqualTo(localCacheOne.expireAfterAccessNanos);
+    assertThat(localCacheTwo.expireAfterWriteNanos).isEqualTo(localCacheOne.expireAfterWriteNanos);
+    assertThat(localCacheTwo.removalListener).isEqualTo(localCacheOne.removalListener);
+    assertThat(localCacheTwo.ticker).isEqualTo(localCacheOne.ticker);
 
     // serialize the reconstituted version to be sure we haven't lost the ability to reserialize
     LocalManualCache<Object, Object> three = SerializableTester.reserialize(two);
     LocalCache<Object, Object> localCacheThree = three.localCache;
 
-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);
-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);
-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);
-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);
-    assertEquals(localCacheTwo.maxWeight, localCacheThree.maxWeight);
-    assertEquals(localCacheTwo.weigher, localCacheThree.weigher);
-    assertEquals(localCacheTwo.expireAfterAccessNanos, localCacheThree.expireAfterAccessNanos);
-    assertEquals(localCacheTwo.expireAfterWriteNanos, localCacheThree.expireAfterWriteNanos);
-    assertEquals(localCacheTwo.removalListener, localCacheThree.removalListener);
-    assertEquals(localCacheTwo.ticker, localCacheThree.ticker);
+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);
+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);
+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);
+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);
+    assertThat(localCacheThree.maxWeight).isEqualTo(localCacheTwo.maxWeight);
+    assertThat(localCacheThree.weigher).isEqualTo(localCacheTwo.weigher);
+    assertThat(localCacheThree.expireAfterAccessNanos)
+        .isEqualTo(localCacheTwo.expireAfterAccessNanos);
+    assertThat(localCacheThree.expireAfterWriteNanos)
+        .isEqualTo(localCacheTwo.expireAfterWriteNanos);
+    assertThat(localCacheThree.removalListener).isEqualTo(localCacheTwo.removalListener);
+    assertThat(localCacheThree.ticker).isEqualTo(localCacheTwo.ticker);
   }
 
   public void testLoadDifferentKeyInLoader() throws ExecutionException, InterruptedException {
@@ -2774,16 +2793,16 @@ public void testLoadDifferentKeyInLoader() throws ExecutionException, Interrupte
     String key1 = "key1";
     String key2 = "key2";
 
-    assertEquals(
-        key2,
-        cache.get(
-            key1,
-            new CacheLoader<String, String>() {
-              @Override
-              public String load(String key) throws Exception {
-                return cache.get(key2, identityLoader()); // loads a different key, should work
-              }
-            }));
+    assertThat(
+            cache.get(
+                key1,
+                new CacheLoader<String, String>() {
+                  @Override
+                  public String load(String key) throws Exception {
+                    return cache.get(key2, identityLoader()); // loads a different key, should work
+                  }
+                }))
+        .isEqualTo(key2);
   }
 
   public void testRecursiveLoad() throws InterruptedException {
diff --git a/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java b/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java
index 1f927b731894..20dce52c426b 100644
--- a/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java
+++ b/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java
@@ -62,7 +62,7 @@ public Object load(Object from) {
           }
         };
     LocalLoadingCache<Object, Object> cache = makeCache(createCacheBuilder(), loader);
-    assertSame(loader, cache.localCache.defaultLoader);
+    assertThat(cache.localCache.defaultLoader).isSameInstanceAs(loader);
   }
 
   // null parameters test
@@ -78,82 +78,82 @@ public void testNullParameters() throws Exception {
   public void testStats() {
     CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1).maximumSize(2);
     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     Object one = new Object();
     cache.getUnchecked(one);
     CacheStats stats = cache.stats();
-    assertEquals(1, stats.requestCount());
-    assertEquals(0, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(1);
+    assertThat(stats.hitCount()).isEqualTo(0);
     assertThat(stats.hitRate()).isEqualTo(0.0);
-    assertEquals(1, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(1);
     assertThat(stats.missRate()).isEqualTo(1.0);
-    assertEquals(1, stats.loadCount());
+    assertThat(stats.loadCount()).isEqualTo(1);
     long totalLoadTime = stats.totalLoadTime();
-    assertTrue(totalLoadTime >= 0);
-    assertTrue(stats.averageLoadPenalty() >= 0.0);
-    assertEquals(0, stats.evictionCount());
+    assertThat(totalLoadTime).isAtLeast(0);
+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);
+    assertThat(stats.evictionCount()).isEqualTo(0);
 
     cache.getUnchecked(one);
     stats = cache.stats();
-    assertEquals(2, stats.requestCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(2);
+    assertThat(stats.hitCount()).isEqualTo(1);
     assertThat(stats.hitRate()).isEqualTo(1.0 / 2);
-    assertEquals(1, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(1);
     assertThat(stats.missRate()).isEqualTo(1.0 / 2);
-    assertEquals(1, stats.loadCount());
-    assertEquals(0, stats.evictionCount());
+    assertThat(stats.loadCount()).isEqualTo(1);
+    assertThat(stats.evictionCount()).isEqualTo(0);
 
     Object two = new Object();
     cache.getUnchecked(two);
     stats = cache.stats();
-    assertEquals(3, stats.requestCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(3);
+    assertThat(stats.hitCount()).isEqualTo(1);
     assertThat(stats.hitRate()).isEqualTo(1.0 / 3);
-    assertEquals(2, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(2);
     assertThat(stats.missRate()).isEqualTo(2.0 / 3);
-    assertEquals(2, stats.loadCount());
-    assertTrue(stats.totalLoadTime() >= totalLoadTime);
+    assertThat(stats.loadCount()).isEqualTo(2);
+    assertThat(stats.totalLoadTime()).isAtLeast(totalLoadTime);
     totalLoadTime = stats.totalLoadTime();
-    assertTrue(stats.averageLoadPenalty() >= 0.0);
-    assertEquals(0, stats.evictionCount());
+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);
+    assertThat(stats.evictionCount()).isEqualTo(0);
 
     Object three = new Object();
     cache.getUnchecked(three);
     stats = cache.stats();
-    assertEquals(4, stats.requestCount());
-    assertEquals(1, stats.hitCount());
+    assertThat(stats.requestCount()).isEqualTo(4);
+    assertThat(stats.hitCount()).isEqualTo(1);
     assertThat(stats.hitRate()).isEqualTo(1.0 / 4);
-    assertEquals(3, stats.missCount());
+    assertThat(stats.missCount()).isEqualTo(3);
     assertThat(stats.missRate()).isEqualTo(3.0 / 4);
-    assertEquals(3, stats.loadCount());
-    assertTrue(stats.totalLoadTime() >= totalLoadTime);
-    assertTrue(stats.averageLoadPenalty() >= 0.0);
-    assertEquals(1, stats.evictionCount());
+    assertThat(stats.loadCount()).isEqualTo(3);
+    assertThat(stats.totalLoadTime()).isAtLeast(totalLoadTime);
+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);
+    assertThat(stats.evictionCount()).isEqualTo(1);
   }
 
   public void testStatsNoops() {
     CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1);
     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
     ConcurrentMap<Object, Object> map = cache.localCache; // modifiable map view
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     Object one = new Object();
     assertNull(map.put(one, one));
-    assertSame(one, map.get(one));
-    assertTrue(map.containsKey(one));
-    assertTrue(map.containsValue(one));
+    assertThat(map.get(one)).isSameInstanceAs(one);
+    assertThat(map.containsKey(one)).isTrue();
+    assertThat(map.containsValue(one)).isTrue();
     Object two = new Object();
-    assertSame(one, map.replace(one, two));
-    assertTrue(map.containsKey(one));
-    assertFalse(map.containsValue(one));
+    assertThat(map.replace(one, two)).isSameInstanceAs(one);
+    assertThat(map.containsKey(one)).isTrue();
+    assertThat(map.containsValue(one)).isFalse();
     Object three = new Object();
-    assertTrue(map.replace(one, two, three));
-    assertTrue(map.remove(one, three));
-    assertFalse(map.containsKey(one));
-    assertFalse(map.containsValue(one));
+    assertThat(map.replace(one, two, three)).isTrue();
+    assertThat(map.remove(one, three)).isTrue();
+    assertThat(map.containsKey(one)).isFalse();
+    assertThat(map.containsValue(one)).isFalse();
     assertNull(map.putIfAbsent(two, three));
-    assertSame(three, map.remove(two));
+    assertThat(map.remove(two)).isSameInstanceAs(three);
     assertNull(map.put(three, one));
     assertNull(map.put(one, two));
 
@@ -171,56 +171,56 @@ public void testStatsNoops() {
 
     map.clear();
 
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
   }
 
   public void testNoStats() {
     CacheBuilder<Object, Object> builder =
         CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(2);
     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     Object one = new Object();
     cache.getUnchecked(one);
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     cache.getUnchecked(one);
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     Object two = new Object();
     cache.getUnchecked(two);
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     Object three = new Object();
     cache.getUnchecked(three);
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
   }
 
   public void testRecordStats() {
     CacheBuilder<Object, Object> builder =
         createCacheBuilder().recordStats().concurrencyLevel(1).maximumSize(2);
     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
-    assertEquals(0, cache.stats().hitCount());
-    assertEquals(0, cache.stats().missCount());
+    assertThat(cache.stats().hitCount()).isEqualTo(0);
+    assertThat(cache.stats().missCount()).isEqualTo(0);
 
     Object one = new Object();
     cache.getUnchecked(one);
-    assertEquals(0, cache.stats().hitCount());
-    assertEquals(1, cache.stats().missCount());
+    assertThat(cache.stats().hitCount()).isEqualTo(0);
+    assertThat(cache.stats().missCount()).isEqualTo(1);
 
     cache.getUnchecked(one);
-    assertEquals(1, cache.stats().hitCount());
-    assertEquals(1, cache.stats().missCount());
+    assertThat(cache.stats().hitCount()).isEqualTo(1);
+    assertThat(cache.stats().missCount()).isEqualTo(1);
 
     Object two = new Object();
     cache.getUnchecked(two);
-    assertEquals(1, cache.stats().hitCount());
-    assertEquals(2, cache.stats().missCount());
+    assertThat(cache.stats().hitCount()).isEqualTo(1);
+    assertThat(cache.stats().missCount()).isEqualTo(2);
 
     Object three = new Object();
     cache.getUnchecked(three);
-    assertEquals(1, cache.stats().hitCount());
-    assertEquals(3, cache.stats().missCount());
+    assertThat(cache.stats().hitCount()).isEqualTo(1);
+    assertThat(cache.stats().missCount()).isEqualTo(3);
   }
 
   // asMap tests
@@ -228,7 +228,7 @@ public void testRecordStats() {
   public void testAsMap() {
     CacheBuilder<Object, Object> builder = createCacheBuilder();
     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());
-    assertEquals(EMPTY_STATS, cache.stats());
+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);
 
     Object one = new Object();
     Object two = new Object();
@@ -236,47 +236,47 @@ public void testAsMap() {
 
     ConcurrentMap<Object, Object> map = cache.asMap();
     assertNull(map.put(one, two));
-    assertSame(two, map.get(one));
+    assertThat(map.get(one)).isSameInstanceAs(two);
     map.putAll(ImmutableMap.of(two, three));
-    assertSame(three, map.get(two));
-    assertSame(two, map.putIfAbsent(one, three));
-    assertSame(two, map.get(one));
+    assertThat(map.get(two)).isSameInstanceAs(three);
+    assertThat(map.putIfAbsent(one, three)).isSameInstanceAs(two);
+    assertThat(map.get(one)).isSameInstanceAs(two);
     assertNull(map.putIfAbsent(three, one));
-    assertSame(one, map.get(three));
-    assertSame(two, map.replace(one, three));
-    assertSame(three, map.get(one));
-    assertFalse(map.replace(one, two, three));
-    assertSame(three, map.get(one));
-    assertTrue(map.replace(one, three, two));
-    assertSame(two, map.get(one));
-    assertEquals(3, map.size());
+    assertThat(map.get(three)).isSameInstanceAs(one);
+    assertThat(map.replace(one, three)).isSameInstanceAs(two);
+    assertThat(map.get(one)).isSameInstanceAs(three);
+    assertThat(map.replace(one, two, three)).isFalse();
+    assertThat(map.get(one)).isSameInstanceAs(three);
+    assertThat(map.replace(one, three, two)).isTrue();
+    assertThat(map.get(one)).isSameInstanceAs(two);
+    assertThat(map).hasSize(3);
 
     map.clear();
-    assertTrue(map.isEmpty());
-    assertEquals(0, map.size());
+    assertThat(map.isEmpty()).isTrue();
+    assertThat(map).isEmpty();
 
     cache.getUnchecked(one);
-    assertEquals(1, map.size());
-    assertSame(one, map.get(one));
-    assertTrue(map.containsKey(one));
-    assertTrue(map.containsValue(one));
-    assertSame(one, map.remove(one));
-    assertEquals(0, map.size());
+    assertThat(map).hasSize(1);
+    assertThat(map.get(one)).isSameInstanceAs(one);
+    assertThat(map.containsKey(one)).isTrue();
+    assertThat(map.containsValue(one)).isTrue();
+    assertThat(map.remove(one)).isSameInstanceAs(one);
+    assertThat(map).isEmpty();
 
     cache.getUnchecked(one);
-    assertEquals(1, map.size());
-    assertFalse(map.remove(one, two));
-    assertTrue(map.remove(one, one));
-    assertEquals(0, map.size());
+    assertThat(map).hasSize(1);
+    assertThat(map.remove(one, two)).isFalse();
+    assertThat(map.remove(one, one)).isTrue();
+    assertThat(map).isEmpty();
 
     cache.getUnchecked(one);
     Map<Object, Object> newMap = ImmutableMap.of(one, one);
-    assertEquals(newMap, map);
-    assertEquals(newMap.entrySet(), map.entrySet());
-    assertEquals(newMap.keySet(), map.keySet());
+    assertThat(map).isEqualTo(newMap);
+    assertThat(map.entrySet()).isEqualTo(newMap.entrySet());
+    assertThat(map.keySet()).isEqualTo(newMap.keySet());
     Set<Object> expectedValues = ImmutableSet.of(one);
     Set<Object> actualValues = ImmutableSet.copyOf(map.values());
-    assertEquals(expectedValues, actualValues);
+    assertThat(actualValues).isEqualTo(expectedValues);
   }
 
   /** Lookups on the map view shouldn't impact the recency queue. */
@@ -288,12 +288,12 @@ public void testAsMapRecency() {
     ConcurrentMap<Object, Object> map = cache.asMap();
 
     Object one = new Object();
-    assertSame(one, cache.getUnchecked(one));
-    assertTrue(segment.recencyQueue.isEmpty());
-    assertSame(one, map.get(one));
-    assertSame(one, segment.recencyQueue.peek().getKey());
-    assertSame(one, cache.getUnchecked(one));
-    assertFalse(segment.recencyQueue.isEmpty());
+    assertThat(cache.getUnchecked(one)).isSameInstanceAs(one);
+    assertThat(segment.recencyQueue.isEmpty()).isTrue();
+    assertThat(map.get(one)).isSameInstanceAs(one);
+    assertThat(segment.recencyQueue.peek().getKey()).isSameInstanceAs(one);
+    assertThat(cache.getUnchecked(one)).isSameInstanceAs(one);
+    assertThat(segment.recencyQueue.isEmpty()).isFalse();
   }
 
   public void testRecursiveComputation() throws InterruptedException {
@@ -313,7 +313,7 @@ public String load(Integer key) {
     LoadingCache<Integer, String> recursiveCache =
         CacheBuilder.newBuilder().weakKeys().weakValues().build(recursiveLoader);
     cacheRef.set(recursiveCache);
-    assertEquals("3, 2, 1, 0", recursiveCache.getUnchecked(3));
+    assertThat(recursiveCache.getUnchecked(3)).isEqualTo("3, 2, 1, 0");
 
     recursiveLoader =
         new CacheLoader<Integer, String>() {
diff --git a/guava-tests/test/com/google/common/cache/NullCacheTest.java b/guava-tests/test/com/google/common/cache/NullCacheTest.java
index ae49a5366394..5def1a0ac218 100644
--- a/guava-tests/test/com/google/common/cache/NullCacheTest.java
+++ b/guava-tests/test/com/google/common/cache/NullCacheTest.java
@@ -51,12 +51,12 @@ public void testGet() {
             .build(constantLoader(computed));
 
     Object key = new Object();
-    assertSame(computed, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);
     RemovalNotification<Object, Object> notification = listener.remove();
-    assertSame(key, notification.getKey());
-    assertSame(computed, notification.getValue());
-    assertSame(RemovalCause.SIZE, notification.getCause());
-    assertTrue(listener.isEmpty());
+    assertThat(notification.getKey()).isSameInstanceAs(key);
+    assertThat(notification.getValue()).isSameInstanceAs(computed);
+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);
+    assertThat(listener.isEmpty()).isTrue();
     checkEmpty(cache);
   }
 
@@ -69,12 +69,12 @@ public void testGet_expireAfterWrite() {
             .build(constantLoader(computed));
 
     Object key = new Object();
-    assertSame(computed, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);
     RemovalNotification<Object, Object> notification = listener.remove();
-    assertSame(key, notification.getKey());
-    assertSame(computed, notification.getValue());
-    assertSame(RemovalCause.SIZE, notification.getCause());
-    assertTrue(listener.isEmpty());
+    assertThat(notification.getKey()).isSameInstanceAs(key);
+    assertThat(notification.getValue()).isSameInstanceAs(computed);
+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);
+    assertThat(listener.isEmpty()).isTrue();
     checkEmpty(cache);
   }
 
@@ -87,12 +87,12 @@ public void testGet_expireAfterAccess() {
             .build(constantLoader(computed));
 
     Object key = new Object();
-    assertSame(computed, cache.getUnchecked(key));
+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);
     RemovalNotification<Object, Object> notification = listener.remove();
-    assertSame(key, notification.getKey());
-    assertSame(computed, notification.getValue());
-    assertSame(RemovalCause.SIZE, notification.getCause());
-    assertTrue(listener.isEmpty());
+    assertThat(notification.getKey()).isSameInstanceAs(key);
+    assertThat(notification.getValue()).isSameInstanceAs(computed);
+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);
+    assertThat(listener.isEmpty()).isTrue();
     checkEmpty(cache);
   }
 
@@ -105,7 +105,7 @@ public void testGet_computeNull() {
 
     assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(new Object()));
 
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
     checkEmpty(cache);
   }
 
@@ -120,7 +120,7 @@ public void testGet_runtimeException() {
     UncheckedExecutionException uee =
         assertThrows(UncheckedExecutionException.class, () -> map.getUnchecked(new Object()));
     assertThat(uee).hasCauseThat().isSameInstanceAs(e);
-    assertTrue(listener.isEmpty());
+    assertThat(listener.isEmpty()).isTrue();
     checkEmpty(map);
   }
 }
diff --git a/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java b/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java
index ea2066d1b09a..0c529574f1d1 100644
--- a/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java
+++ b/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java
@@ -59,7 +59,7 @@ public void testSize_populated() {
     for (LoadingCache<Object, Object> cache : caches()) {
       // don't let the entries get GCed
       List<Entry<Object, Object>> unused = warmUp(cache);
-      assertEquals(WARMUP_SIZE, cache.size());
+      assertThat(cache.size()).isEqualTo(WARMUP_SIZE);
       assertMapSize(cache.asMap(), WARMUP_SIZE);
       checkValidState(cache);
     }
@@ -71,12 +71,12 @@ public void testContainsKey_found() {
       List<Entry<Object, Object>> warmed = warmUp(cache);
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);
-        assertTrue(cache.asMap().containsKey(entry.getKey()));
-        assertTrue(cache.asMap().containsValue(entry.getValue()));
+        assertThat(cache.asMap().containsKey(entry.getKey())).isTrue();
+        assertThat(cache.asMap().containsValue(entry.getValue())).isTrue();
         // this getUnchecked() call shouldn't be a cache miss; verified below
-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));
+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());
       }
-      assertEquals(WARMUP_SIZE, cache.stats().missCount());
+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);
       checkValidState(cache);
     }
   }
@@ -88,18 +88,18 @@ public void testPut_populated() {
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);
         Object newValue = new Object();
-        assertSame(entry.getValue(), cache.asMap().put(entry.getKey(), newValue));
+        assertThat(cache.asMap().put(entry.getKey(), newValue)).isSameInstanceAs(entry.getValue());
         // don't let the new entry get GCed
         warmed.add(entryOf(entry.getKey(), newValue));
         Object newKey = new Object();
-        assertNull(cache.asMap().put(newKey, entry.getValue()));
+        assertThat(cache.asMap().put(newKey, entry.getValue())).isNull();
         // this getUnchecked() call shouldn't be a cache miss; verified below
-        assertEquals(newValue, cache.getUnchecked(entry.getKey()));
-        assertEquals(entry.getValue(), cache.getUnchecked(newKey));
+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(newValue);
+        assertThat(cache.getUnchecked(newKey)).isEqualTo(entry.getValue());
         // don't let the new entry get GCed
         warmed.add(entryOf(newKey, entry.getValue()));
       }
-      assertEquals(WARMUP_SIZE, cache.stats().missCount());
+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);
       checkValidState(cache);
     }
   }
@@ -111,16 +111,17 @@ public void testPutIfAbsent_populated() {
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);
         Object newValue = new Object();
-        assertSame(entry.getValue(), cache.asMap().putIfAbsent(entry.getKey(), newValue));
+        assertThat(cache.asMap().putIfAbsent(entry.getKey(), newValue))
+            .isSameInstanceAs(entry.getValue());
         Object newKey = new Object();
-        assertNull(cache.asMap().putIfAbsent(newKey, entry.getValue()));
+        assertThat(cache.asMap().putIfAbsent(newKey, entry.getValue())).isNull();
         // this getUnchecked() call shouldn't be a cache miss; verified below
-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));
-        assertEquals(entry.getValue(), cache.getUnchecked(newKey));
+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());
+        assertThat(cache.getUnchecked(newKey)).isEqualTo(entry.getValue());
         // don't let the new entry get GCed
         warmed.add(entryOf(newKey, entry.getValue()));
       }
-      assertEquals(WARMUP_SIZE, cache.stats().missCount());
+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);
       checkValidState(cache);
     }
   }
@@ -133,8 +134,8 @@ public void testPutAll_populated() {
       Object newValue = new Object();
       cache.asMap().putAll(ImmutableMap.of(newKey, newValue));
       // this getUnchecked() call shouldn't be a cache miss; verified below
-      assertEquals(newValue, cache.getUnchecked(newKey));
-      assertEquals(WARMUP_SIZE, cache.stats().missCount());
+      assertThat(cache.getUnchecked(newKey)).isEqualTo(newValue);
+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);
       checkValidState(cache);
     }
   }
@@ -146,16 +147,17 @@ public void testReplace_populated() {
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);
         Object newValue = new Object();
-        assertSame(entry.getValue(), cache.asMap().replace(entry.getKey(), newValue));
-        assertTrue(cache.asMap().replace(entry.getKey(), newValue, entry.getValue()));
+        assertThat(cache.asMap().replace(entry.getKey(), newValue))
+            .isSameInstanceAs(entry.getValue());
+        assertThat(cache.asMap().replace(entry.getKey(), newValue, entry.getValue())).isTrue();
         Object newKey = new Object();
-        assertNull(cache.asMap().replace(newKey, entry.getValue()));
-        assertFalse(cache.asMap().replace(newKey, entry.getValue(), newValue));
+        assertThat(cache.asMap().replace(newKey, entry.getValue())).isNull();
+        assertThat(cache.asMap().replace(newKey, entry.getValue(), newValue)).isFalse();
         // this getUnchecked() call shouldn't be a cache miss; verified below
-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));
-        assertFalse(cache.asMap().containsKey(newKey));
+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());
+        assertThat(cache.asMap().containsKey(newKey)).isFalse();
       }
-      assertEquals(WARMUP_SIZE, cache.stats().missCount());
+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);
       checkValidState(cache);
     }
   }
@@ -167,9 +169,9 @@ public void testRemove_byKey() {
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);
         Object key = entry.getKey();
-        assertEquals(entry.getValue(), cache.asMap().remove(key));
-        assertNull(cache.asMap().remove(key));
-        assertFalse(cache.asMap().containsKey(key));
+        assertThat(cache.asMap().remove(key)).isEqualTo(entry.getValue());
+        assertThat(cache.asMap().remove(key)).isNull();
+        assertThat(cache.asMap().containsKey(key)).isFalse();
       }
       checkEmpty(cache);
     }
@@ -182,10 +184,10 @@ public void testRemove_byKeyAndValue() {
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Object key = warmed.get(i - WARMUP_MIN).getKey();
         Object value = warmed.get(i - WARMUP_MIN).getValue();
-        assertFalse(cache.asMap().remove(key, -1));
-        assertTrue(cache.asMap().remove(key, value));
-        assertFalse(cache.asMap().remove(key, -1));
-        assertFalse(cache.asMap().containsKey(key));
+        assertThat(cache.asMap().remove(key, -1)).isFalse();
+        assertThat(cache.asMap().remove(key, value)).isTrue();
+        assertThat(cache.asMap().remove(key, -1)).isFalse();
+        assertThat(cache.asMap().containsKey(key)).isFalse();
       }
       checkEmpty(cache);
     }
@@ -206,13 +208,13 @@ public void testKeySet_populated() {
           .addEqualityGroup(cache.asMap().keySet(), keys)
           .addEqualityGroup(ImmutableSet.of())
           .testEquals();
-      assertEquals(WARMUP_SIZE, keys.size());
+      assertThat(keys).hasSize(WARMUP_SIZE);
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Object key = warmed.get(i - WARMUP_MIN).getKey();
-        assertTrue(keys.contains(key));
-        assertTrue(keys.remove(key));
-        assertFalse(keys.remove(key));
-        assertFalse(keys.contains(key));
+        assertThat(keys.contains(key)).isTrue();
+        assertThat(keys.remove(key)).isTrue();
+        assertThat(keys.remove(key)).isFalse();
+        assertThat(keys.contains(key)).isFalse();
       }
       checkEmpty(keys);
       checkEmpty(cache);
@@ -229,13 +231,13 @@ public void testValues_populated() {
       assertThat(values.toArray()).asList().containsExactlyElementsIn(expected);
       assertThat(values.toArray(new Object[0])).asList().containsExactlyElementsIn(expected);
 
-      assertEquals(WARMUP_SIZE, values.size());
+      assertThat(values).hasSize(WARMUP_SIZE);
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Object value = warmed.get(i - WARMUP_MIN).getValue();
-        assertTrue(values.contains(value));
-        assertTrue(values.remove(value));
-        assertFalse(values.remove(value));
-        assertFalse(values.contains(value));
+        assertThat(values.contains(value)).isTrue();
+        assertThat(values.remove(value)).isTrue();
+        assertThat(values.remove(value)).isFalse();
+        assertThat(values.contains(value)).isFalse();
       }
       checkEmpty(values);
       checkEmpty(cache);
@@ -257,13 +259,13 @@ public void testEntrySet_populated() {
           .addEqualityGroup(cache.asMap().entrySet(), entries)
           .addEqualityGroup(ImmutableSet.of())
           .testEquals();
-      assertEquals(WARMUP_SIZE, entries.size());
+      assertThat(entries).hasSize(WARMUP_SIZE);
       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {
         Entry<Object, Object> newEntry = warmed.get(i - WARMUP_MIN);
-        assertTrue(entries.contains(newEntry));
-        assertTrue(entries.remove(newEntry));
-        assertFalse(entries.remove(newEntry));
-        assertFalse(entries.contains(newEntry));
+        assertThat(entries.contains(newEntry)).isTrue();
+        assertThat(entries.remove(newEntry)).isTrue();
+        assertThat(entries.remove(newEntry)).isFalse();
+        assertThat(entries.contains(newEntry)).isFalse();
       }
       checkEmpty(entries);
       checkEmpty(cache);
@@ -276,11 +278,11 @@ public void testWriteThroughEntry() {
       Entry<Object, Object> entry = Iterables.getOnlyElement(cache.asMap().entrySet());
 
       cache.invalidate(1);
-      assertEquals(0, cache.size());
+      assertThat(cache.size()).isEqualTo(0);
 
       entry.setValue(3);
-      assertEquals(1, cache.size());
-      assertEquals(3, cache.getIfPresent(1));
+      assertThat(cache.size()).isEqualTo(1);
+      assertThat(cache.getIfPresent(1)).isEqualTo(3);
       checkValidState(cache);
 
       assertThrows(NullPointerException.class, () -> entry.setValue(null));
@@ -356,25 +358,26 @@ private Entry<Object, Object> entryOf(Object key, Object value) {
   }
 
   private void assertMapSize(Map<?, ?> map, int size) {
-    assertEquals(size, map.size());
+    assertThat(map).hasSize(size);
     if (size > 0) {
-      assertFalse(map.isEmpty());
+      assertThat(map.isEmpty()).isFalse();
     } else {
-      assertTrue(map.isEmpty());
+      assertThat(map.isEmpty()).isTrue();
     }
     assertCollectionSize(map.keySet(), size);
     assertCollectionSize(map.entrySet(), size);
     assertCollectionSize(map.values(), size);
   }
 
+  @SuppressWarnings("IterablesSizeOfCollection") // we are testing our iterator implementation
   private void assertCollectionSize(Collection<?> collection, int size) {
-    assertEquals(size, collection.size());
+    assertThat(collection.size()).isEqualTo(size);
     if (size > 0) {
-      assertFalse(collection.isEmpty());
+      assertThat(collection.isEmpty()).isFalse();
     } else {
-      assertTrue(collection.isEmpty());
+      assertThat(collection.isEmpty()).isTrue();
     }
-    assertEquals(size, Iterables.size(collection));
-    assertEquals(size, Iterators.size(collection.iterator()));
+    assertThat(Iterables.size(collection)).isEqualTo(size);
+    assertThat(Iterators.size(collection.iterator())).isEqualTo(size);
   }
 }
