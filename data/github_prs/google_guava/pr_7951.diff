diff --git a/android/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java b/android/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java
deleted file mode 100644
index 76e04fddfc81..000000000000
--- a/android/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2012 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package com.google.common.collect;
-
-import com.google.caliper.BeforeExperiment;
-import com.google.caliper.Benchmark;
-import com.google.caliper.Param;
-import com.google.common.base.Optional;
-import com.google.common.primitives.Ints;
-import java.util.List;
-import java.util.Random;
-import org.jspecify.annotations.NullUnmarked;
-
-/**
- * Benchmarks for the {@code TreeTraverser} operations on binary trees.
- *
- * @author Louis Wasserman
- */
-@NullUnmarked
-public class BinaryTreeTraverserBenchmark {
-  private static class BinaryNode {
-    final int x;
-    final Optional<BinaryNode> left;
-    final Optional<BinaryNode> right;
-
-    BinaryNode(int x, Optional<BinaryNode> left, Optional<BinaryNode> right) {
-      this.x = x;
-      this.left = left;
-      this.right = right;
-    }
-  }
-
-  enum Topology {
-    BALANCED {
-      @Override
-      Optional<BinaryNode> createTree(int size, Random rng) {
-        if (size == 0) {
-          return Optional.absent();
-        } else {
-          int leftChildSize = (size - 1) / 2;
-          int rightChildSize = size - 1 - leftChildSize;
-          return Optional.of(
-              new BinaryNode(
-                  rng.nextInt(), createTree(leftChildSize, rng), createTree(rightChildSize, rng)));
-        }
-      }
-    },
-    ALL_LEFT {
-      @Override
-      Optional<BinaryNode> createTree(int size, Random rng) {
-        Optional<BinaryNode> root = Optional.absent();
-        for (int i = 0; i < size; i++) {
-          root = Optional.of(new BinaryNode(rng.nextInt(), root, Optional.<BinaryNode>absent()));
-        }
-        return root;
-      }
-    },
-    ALL_RIGHT {
-      @Override
-      Optional<BinaryNode> createTree(int size, Random rng) {
-        Optional<BinaryNode> root = Optional.absent();
-        for (int i = 0; i < size; i++) {
-          root = Optional.of(new BinaryNode(rng.nextInt(), Optional.<BinaryNode>absent(), root));
-        }
-        return root;
-      }
-    },
-    RANDOM {
-      /**
-       * Generates a tree with topology selected uniformly at random from the topologies of binary
-       * trees of the specified size.
-       */
-      @Override
-      Optional<BinaryNode> createTree(int size, Random rng) {
-        int[] keys = new int[size];
-        for (int i = 0; i < size; i++) {
-          keys[i] = rng.nextInt();
-        }
-        return createTreap(Ints.asList(keys));
-      }
-
-      // See http://en.wikipedia.org/wiki/Treap for details on the algorithm.
-      private Optional<BinaryNode> createTreap(List<Integer> keys) {
-        if (keys.isEmpty()) {
-          return Optional.absent();
-        }
-        int minIndex = 0;
-        for (int i = 1; i < keys.size(); i++) {
-          if (keys.get(i) < keys.get(minIndex)) {
-            minIndex = i;
-          }
-        }
-        Optional<BinaryNode> leftChild = createTreap(keys.subList(0, minIndex));
-        Optional<BinaryNode> rightChild = createTreap(keys.subList(minIndex + 1, keys.size()));
-        return Optional.of(new BinaryNode(keys.get(minIndex), leftChild, rightChild));
-      }
-    };
-
-    abstract Optional<BinaryNode> createTree(int size, Random rng);
-  }
-
-  private static final TreeTraverser<BinaryNode> VIEWER =
-      new TreeTraverser<BinaryNode>() {
-        @Override
-        public Iterable<BinaryNode> children(BinaryNode root) {
-          return Optional.presentInstances(ImmutableList.of(root.left, root.right));
-        }
-      };
-
-  enum Traversal {
-    PRE_ORDER {
-      @Override
-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {
-        return viewer.preOrderTraversal(root);
-      }
-    },
-    POST_ORDER {
-      @Override
-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {
-        return viewer.postOrderTraversal(root);
-      }
-    },
-    BREADTH_FIRST {
-      @Override
-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {
-        return viewer.breadthFirstTraversal(root);
-      }
-    };
-
-    abstract <T> Iterable<T> view(T root, TreeTraverser<T> viewer);
-  }
-
-  private Iterable<BinaryNode> view;
-
-  @Param Topology topology;
-
-  @Param({"1", "100", "10000", "1000000"})
-  int size;
-
-  @Param Traversal traversal;
-
-  @Param({"1234"})
-  SpecialRandom rng;
-
-  @BeforeExperiment
-  void setUp() {
-    this.view = traversal.view(topology.createTree(size, rng).get(), VIEWER);
-  }
-
-  @Benchmark
-  int traversal(int reps) {
-    int tmp = 0;
-
-    for (int i = 0; i < reps; i++) {
-      for (BinaryNode node : view) {
-        tmp += node.x;
-      }
-    }
-    return tmp;
-  }
-}
diff --git a/android/guava-tests/test/com/google/common/collect/TreeTraverserTest.java b/android/guava-tests/test/com/google/common/collect/TreeTraverserTest.java
index 4dc03d65bdb6..428650e42f81 100644
--- a/android/guava-tests/test/com/google/common/collect/TreeTraverserTest.java
+++ b/android/guava-tests/test/com/google/common/collect/TreeTraverserTest.java
@@ -29,10 +29,12 @@
 /**
  * Tests for {@code TreeTraverser}.
  *
+ * @deprecated Use {@link com.google.common.graph.Traverser} instead.
  * @author Louis Wasserman
  */
 @GwtCompatible
 @NullMarked
+@Deprecated // Use com.google.common.graph.Traverser instead.
 public class TreeTraverserTest extends TestCase {
   private static class Node {
     final char value;
diff --git a/android/guava/src/com/google/common/collect/TreeTraverser.java b/android/guava/src/com/google/common/collect/TreeTraverser.java
index acdca30bd4a0..bcffbc16bab6 100644
--- a/android/guava/src/com/google/common/collect/TreeTraverser.java
+++ b/android/guava/src/com/google/common/collect/TreeTraverser.java
@@ -69,13 +69,14 @@
  *     their equivalent on the result of {@code Traverser.forTree(tree)} where {@code tree}
  *     implements {@code SuccessorsFunction}, which has a similar API as {@link #children} or can be
  *     the same lambda function as passed into {@link #using(Function)}.
- *     <p>This class is scheduled to be removed in October 2019.
  */
-// TODO(b/68134636): Remove by 2019-10
+// This class is now only available externally for backwards compatibility; it should not be used
+// internally (hence the package-private visibility and @Deprecated annotation).
 @Deprecated
 @Beta
 @GwtCompatible
-public abstract class TreeTraverser<T> {
+public
+abstract class TreeTraverser<T> {
   /** Constructor for use by subclasses. */
   public TreeTraverser() {}
 
diff --git a/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java b/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java
deleted file mode 100644
index 76e04fddfc81..000000000000
--- a/guava-tests/benchmark/com/google/common/collect/BinaryTreeTraverserBenchmark.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2012 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package com.google.common.collect;
-
-import com.google.caliper.BeforeExperiment;
-import com.google.caliper.Benchmark;
-import com.google.caliper.Param;
-import com.google.common.base.Optional;
-import com.google.common.primitives.Ints;
-import java.util.List;
-import java.util.Random;
-import org.jspecify.annotations.NullUnmarked;
-
-/**
- * Benchmarks for the {@code TreeTraverser} operations on binary trees.
- *
- * @author Louis Wasserman
- */
-@NullUnmarked
-public class BinaryTreeTraverserBenchmark {
-  private static class BinaryNode {
-    final int x;
-    final Optional<BinaryNode> left;
-    final Optional<BinaryNode> right;
-
-    BinaryNode(int x, Optional<BinaryNode> left, Optional<BinaryNode> right) {
-      this.x = x;
-      this.left = left;
-      this.right = right;
-    }
-  }
-
-  enum Topology {
-    BALANCED {
-      @Override
-      Optional<BinaryNode> createTree(int size, Random rng) {
-        if (size == 0) {
-          return Optional.absent();
-        } else {
-          int leftChildSize = (size - 1) / 2;
-          int rightChildSize = size - 1 - leftChildSize;
-          return Optional.of(
-              new BinaryNode(
-                  rng.nextInt(), createTree(leftChildSize, rng), createTree(rightChildSize, rng)));
-        }
-      }
-    },
-    ALL_LEFT {
-      @Override
-      Optional<BinaryNode> createTree(int size, Random rng) {
-        Optional<BinaryNode> root = Optional.absent();
-        for (int i = 0; i < size; i++) {
-          root = Optional.of(new BinaryNode(rng.nextInt(), root, Optional.<BinaryNode>absent()));
-        }
-        return root;
-      }
-    },
-    ALL_RIGHT {
-      @Override
-      Optional<BinaryNode> createTree(int size, Random rng) {
-        Optional<BinaryNode> root = Optional.absent();
-        for (int i = 0; i < size; i++) {
-          root = Optional.of(new BinaryNode(rng.nextInt(), Optional.<BinaryNode>absent(), root));
-        }
-        return root;
-      }
-    },
-    RANDOM {
-      /**
-       * Generates a tree with topology selected uniformly at random from the topologies of binary
-       * trees of the specified size.
-       */
-      @Override
-      Optional<BinaryNode> createTree(int size, Random rng) {
-        int[] keys = new int[size];
-        for (int i = 0; i < size; i++) {
-          keys[i] = rng.nextInt();
-        }
-        return createTreap(Ints.asList(keys));
-      }
-
-      // See http://en.wikipedia.org/wiki/Treap for details on the algorithm.
-      private Optional<BinaryNode> createTreap(List<Integer> keys) {
-        if (keys.isEmpty()) {
-          return Optional.absent();
-        }
-        int minIndex = 0;
-        for (int i = 1; i < keys.size(); i++) {
-          if (keys.get(i) < keys.get(minIndex)) {
-            minIndex = i;
-          }
-        }
-        Optional<BinaryNode> leftChild = createTreap(keys.subList(0, minIndex));
-        Optional<BinaryNode> rightChild = createTreap(keys.subList(minIndex + 1, keys.size()));
-        return Optional.of(new BinaryNode(keys.get(minIndex), leftChild, rightChild));
-      }
-    };
-
-    abstract Optional<BinaryNode> createTree(int size, Random rng);
-  }
-
-  private static final TreeTraverser<BinaryNode> VIEWER =
-      new TreeTraverser<BinaryNode>() {
-        @Override
-        public Iterable<BinaryNode> children(BinaryNode root) {
-          return Optional.presentInstances(ImmutableList.of(root.left, root.right));
-        }
-      };
-
-  enum Traversal {
-    PRE_ORDER {
-      @Override
-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {
-        return viewer.preOrderTraversal(root);
-      }
-    },
-    POST_ORDER {
-      @Override
-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {
-        return viewer.postOrderTraversal(root);
-      }
-    },
-    BREADTH_FIRST {
-      @Override
-      <T> Iterable<T> view(T root, TreeTraverser<T> viewer) {
-        return viewer.breadthFirstTraversal(root);
-      }
-    };
-
-    abstract <T> Iterable<T> view(T root, TreeTraverser<T> viewer);
-  }
-
-  private Iterable<BinaryNode> view;
-
-  @Param Topology topology;
-
-  @Param({"1", "100", "10000", "1000000"})
-  int size;
-
-  @Param Traversal traversal;
-
-  @Param({"1234"})
-  SpecialRandom rng;
-
-  @BeforeExperiment
-  void setUp() {
-    this.view = traversal.view(topology.createTree(size, rng).get(), VIEWER);
-  }
-
-  @Benchmark
-  int traversal(int reps) {
-    int tmp = 0;
-
-    for (int i = 0; i < reps; i++) {
-      for (BinaryNode node : view) {
-        tmp += node.x;
-      }
-    }
-    return tmp;
-  }
-}
diff --git a/guava-tests/test/com/google/common/collect/TreeTraverserTest.java b/guava-tests/test/com/google/common/collect/TreeTraverserTest.java
index bcb8daae8826..5b6694ad666b 100644
--- a/guava-tests/test/com/google/common/collect/TreeTraverserTest.java
+++ b/guava-tests/test/com/google/common/collect/TreeTraverserTest.java
@@ -29,10 +29,12 @@
 /**
  * Tests for {@code TreeTraverser}.
  *
+ * @deprecated Use {@link com.google.common.graph.Traverser} instead.
  * @author Louis Wasserman
  */
 @GwtCompatible
 @NullMarked
+@Deprecated // Use com.google.common.graph.Traverser instead.
 public class TreeTraverserTest extends TestCase {
   private static class Node {
     final char value;
diff --git a/guava/src/com/google/common/collect/TreeTraverser.java b/guava/src/com/google/common/collect/TreeTraverser.java
index e2cbf8de9b55..0db81f55b5df 100644
--- a/guava/src/com/google/common/collect/TreeTraverser.java
+++ b/guava/src/com/google/common/collect/TreeTraverser.java
@@ -70,13 +70,14 @@
  *     their equivalent on the result of {@code Traverser.forTree(tree)} where {@code tree}
  *     implements {@code SuccessorsFunction}, which has a similar API as {@link #children} or can be
  *     the same lambda function as passed into {@link #using(Function)}.
- *     <p>This class is scheduled to be removed in October 2019.
  */
-// TODO(b/68134636): Remove by 2019-10
+// This class is now only available externally for backwards compatibility; it should not be used
+// internally (hence the package-private visibility and @Deprecated annotation).
 @Deprecated
 @Beta
 @GwtCompatible
-public abstract class TreeTraverser<T> {
+public
+abstract class TreeTraverser<T> {
   /** Constructor for use by subclasses. */
   public TreeTraverser() {}
 
diff --git a/refactorings/TraverserRewrite.java b/refactorings/TraverserRewrite.java
deleted file mode 100644
index 74e068462d00..000000000000
--- a/refactorings/TraverserRewrite.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2017 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import com.google.common.collect.TreeTraverser;
-import com.google.common.graph.Traverser;
-import com.google.errorprone.refaster.annotation.AfterTemplate;
-import com.google.errorprone.refaster.annotation.BeforeTemplate;
-import com.google.errorprone.refaster.annotation.Placeholder;
-
-/**
- * Refaster rules to rewrite usages of {@code com.google.common.collect.TreeTraverser} in terms of
- * {@code com.google.common.graph.Traverser}.
- */
-@SuppressWarnings("DefaultPackage")
-public class TraverserRewrite {
-  abstract class TreeTraverserPreOrder<N> {
-    @Placeholder
-    abstract Iterable<N> getChildren(N node);
-
-    @BeforeTemplate
-    Iterable<N> before1(N root) {
-      return TreeTraverser.using((N node) -> getChildren(node)).preOrderTraversal(root);
-    }
-
-    @BeforeTemplate
-    Iterable<N> before2(N root) {
-      return new TreeTraverser<N>() {
-        @Override
-        public Iterable<N> children(N node) {
-          return getChildren(node);
-        }
-      }.preOrderTraversal(root);
-    }
-
-    @AfterTemplate
-    Iterable<N> after(N root) {
-      return Traverser.forTree((N node) -> getChildren(node)).depthFirstPreOrder(root);
-    }
-  }
-
-  abstract class TreeTraverserPostOrder<N> {
-    @Placeholder
-    abstract Iterable<N> getChildren(N node);
-
-    @BeforeTemplate
-    Iterable<N> before1(N root) {
-      return TreeTraverser.using((N node) -> getChildren(node)).postOrderTraversal(root);
-    }
-
-    @BeforeTemplate
-    Iterable<N> before2(N root) {
-      return new TreeTraverser<N>() {
-        @Override
-        public Iterable<N> children(N node) {
-          return getChildren(node);
-        }
-      }.postOrderTraversal(root);
-    }
-
-    @AfterTemplate
-    Iterable<N> after(N root) {
-      return Traverser.forTree((N node) -> getChildren(node)).depthFirstPostOrder(root);
-    }
-  }
-
-  abstract class TreeTraverserBreadthFirst<N> {
-    @Placeholder
-    abstract Iterable<N> getChildren(N node);
-
-    @BeforeTemplate
-    Iterable<N> before1(N root) {
-      return TreeTraverser.using((N node) -> getChildren(node)).breadthFirstTraversal(root);
-    }
-
-    @BeforeTemplate
-    Iterable<N> before2(N root) {
-      return new TreeTraverser<N>() {
-        @Override
-        public Iterable<N> children(N node) {
-          return getChildren(node);
-        }
-      }.breadthFirstTraversal(root);
-    }
-
-    @AfterTemplate
-    Iterable<N> after(N root) {
-      return Traverser.forTree((N node) -> getChildren(node)).breadthFirst(root);
-    }
-  }
-}
