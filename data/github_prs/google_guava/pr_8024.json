{
  "id": 8024,
  "repository": "google/guava",
  "title": "Add support to `Graphs.transitiveClosure()` for different strategies for adding self-loops.",
  "body": "Add support to `Graphs.transitiveClosure()` for different strategies for adding self-loops.\n\nFixes https://github.com/google/guava/issues/2778.\n\nFix/suppress a few unrelated minor warnings.\n\nRELNOTES=`graph`: Added support to `Graphs.transitiveClosure()` for different strategies for adding self-loops.\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-09-29T21:20:54+00:00",
  "created_at": "2025-09-25T18:24:37+00:00",
  "updated_at": "2025-09-29T21:20:55+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "453a78866bb39d26b4062774478f90d23f64e831",
  "head_sha": "2e13df25b2e7c3d59e29cc238b10541139fd2509",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava-tests/test/com/google/common/graph/GraphsTest.java",
      "status": "modified",
      "additions": 158,
      "deletions": 23,
      "changes": 181,
      "patch": "@@ -16,16 +16,16 @@\n \n package com.google.common.graph;\n \n+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_ALWAYS;\n+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_FOR_CYCLES;\n import static com.google.common.graph.Graphs.copyOf;\n import static com.google.common.graph.Graphs.inducedSubgraph;\n-import static com.google.common.graph.Graphs.reachableNodes;\n import static com.google.common.graph.Graphs.transitiveClosure;\n import static com.google.common.graph.Graphs.transpose;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertThrows;\n \n import com.google.common.collect.ImmutableSet;\n-import java.util.Set;\n import org.jspecify.annotations.NullUnmarked;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -61,7 +61,7 @@ public class GraphsTest {\n   static final String ERROR_SELF_LOOP = \"self-loops are not allowed\";\n \n   @Test\n-  public void transitiveClosure_directedGraph() {\n+  public void transitiveClosure_directedGraph_addSelfLoopsAlways() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n     directedGraph.putEdge(N1, N2);\n     directedGraph.putEdge(N1, N3);\n@@ -77,11 +77,30 @@ public void transitiveClosure_directedGraph() {\n     expectedClosure.putEdge(N3, N3);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(directedGraph, expectedClosure);\n+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_undirectedGraph() {\n+  public void transitiveClosure_directedGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n+    directedGraph.putEdge(N1, N2);\n+    directedGraph.putEdge(N1, N3);\n+    directedGraph.putEdge(N2, N3);\n+    directedGraph.addNode(N4);\n+\n+    // the above graph is its own transitive closure\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.addNode(N4);\n+\n+    assertThat(\n+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_undirectedGraph_addSelfLoopsAlways() {\n     MutableGraph<Integer> undirectedGraph =\n         GraphBuilder.undirected().allowsSelfLoops(false).build();\n     undirectedGraph.putEdge(N1, N2);\n@@ -98,11 +117,34 @@ public void transitiveClosure_undirectedGraph() {\n     expectedClosure.putEdge(N3, N3);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(undirectedGraph, expectedClosure);\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_directedPathGraph() {\n+  public void transitiveClosure_undirectedGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> undirectedGraph =\n+        GraphBuilder.undirected().allowsSelfLoops(false).build();\n+    undirectedGraph.putEdge(N1, N2);\n+    undirectedGraph.putEdge(N1, N3);\n+    undirectedGraph.putEdge(N2, N3);\n+    undirectedGraph.addNode(N4);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.addNode(N4); // N4 is isolated => no incident edges in this transitive closure\n+\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedPathGraph_addSelfLoopsAlways() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n     directedGraph.putEdge(N1, N2);\n     directedGraph.putEdge(N2, N3);\n@@ -120,7 +162,26 @@ public void transitiveClosure_directedPathGraph() {\n     expectedClosure.putEdge(N3, N4);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(directedGraph, expectedClosure);\n+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedPathGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n+    directedGraph.putEdge(N1, N2);\n+    directedGraph.putEdge(N2, N3);\n+    directedGraph.putEdge(N3, N4);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N4);\n+\n+    assertThat(\n+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n@@ -143,11 +204,65 @@ public void transitiveClosure_undirectedPathGraph() {\n     expectedClosure.putEdge(N3, N4);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(undirectedGraph, expectedClosure);\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_directedCycleGraph() {\n+  public void transitiveClosure_undirectedPathGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> undirectedGraph =\n+        GraphBuilder.undirected().allowsSelfLoops(false).build();\n+    undirectedGraph.putEdge(N1, N2);\n+    undirectedGraph.putEdge(N2, N3);\n+    undirectedGraph.putEdge(N3, N4);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.putEdge(N3, N4);\n+    expectedClosure.putEdge(N4, N4);\n+\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedCycleGraph_addSelfLoopsAlways() {\n+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n+    directedGraph.putEdge(N1, N2);\n+    directedGraph.putEdge(N2, N3);\n+    directedGraph.putEdge(N3, N4);\n+    directedGraph.putEdge(N4, N1);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N1);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N1);\n+    expectedClosure.putEdge(N3, N2);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.putEdge(N3, N4);\n+    expectedClosure.putEdge(N4, N1);\n+    expectedClosure.putEdge(N4, N2);\n+    expectedClosure.putEdge(N4, N3);\n+    expectedClosure.putEdge(N4, N4);\n+\n+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedCycleGraph_addSelfLoopsForCycles() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n     directedGraph.putEdge(N1, N2);\n     directedGraph.putEdge(N2, N3);\n@@ -172,11 +287,37 @@ public void transitiveClosure_directedCycleGraph() {\n     expectedClosure.putEdge(N4, N3);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(directedGraph, expectedClosure);\n+    assertThat(\n+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_undirectedCycleGraph_addSelfLoopsAlways() {\n+    MutableGraph<Integer> undirectedGraph =\n+        GraphBuilder.undirected().allowsSelfLoops(false).build();\n+    undirectedGraph.putEdge(N1, N2);\n+    undirectedGraph.putEdge(N2, N3);\n+    undirectedGraph.putEdge(N3, N4);\n+    undirectedGraph.putEdge(N4, N1);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.putEdge(N3, N4);\n+    expectedClosure.putEdge(N4, N4);\n+\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_undirectedCycleGraph() {\n+  public void transitiveClosure_undirectedCycleGraph_addSelfLoopsForCycles() {\n     MutableGraph<Integer> undirectedGraph =\n         GraphBuilder.undirected().allowsSelfLoops(false).build();\n     undirectedGraph.putEdge(N1, N2);\n@@ -196,7 +337,8 @@ public void transitiveClosure_undirectedCycleGraph() {\n     expectedClosure.putEdge(N3, N4);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(undirectedGraph, expectedClosure);\n+    assertThat(\n+        transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n@@ -334,7 +476,7 @@ public void transpose_directedNetwork() {\n \n   @Test\n   public void inducedSubgraph_graph() {\n-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n \n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();\n     directedGraph.putEdge(N1, N2);\n@@ -353,7 +495,7 @@ public void inducedSubgraph_graph() {\n \n   @Test\n   public void inducedSubgraph_valueGraph() {\n-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n \n     MutableValueGraph<Integer, String> directedGraph =\n         ValueGraphBuilder.directed().allowsSelfLoops(true).build();\n@@ -374,7 +516,7 @@ public void inducedSubgraph_valueGraph() {\n \n   @Test\n   public void inducedSubgraph_network() {\n-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n \n     MutableNetwork<Integer, String> directedGraph =\n         NetworkBuilder.directed().allowsSelfLoops(true).build();\n@@ -570,13 +712,6 @@ public void builder_expectedEdgeCount_negative() {\n     assertThat(e).hasMessageThat().contains(ERROR_NEGATIVE_COUNT);\n   }\n \n-  private static <N> void checkTransitiveClosure(Graph<N> originalGraph, Graph<N> expectedClosure) {\n-    for (N node : originalGraph.nodes()) {\n-      assertThat(reachableNodes(originalGraph, node)).isEqualTo(expectedClosure.successors(node));\n-    }\n-    assertThat(transitiveClosure(originalGraph)).isEqualTo(expectedClosure);\n-  }\n-\n   private static MutableGraph<Integer> buildDirectedGraph() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();\n     directedGraph.putEdge(N1, N1);"
    },
    {
      "filename": "android/guava/src/com/google/common/graph/Graphs.java",
      "status": "modified",
      "additions": 73,
      "deletions": 34,
      "changes": 107,
      "patch": "@@ -18,18 +18,17 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.graph.GraphConstants.NODE_NOT_IN_GRAPH;\n+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_ALWAYS;\n import static java.util.Objects.requireNonNull;\n \n import com.google.common.annotations.Beta;\n import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Iterables;\n import com.google.common.collect.Iterators;\n import com.google.common.collect.Maps;\n import com.google.errorprone.annotations.CanIgnoreReturnValue;\n import java.util.ArrayDeque;\n import java.util.Collection;\n import java.util.Deque;\n-import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Objects;\n@@ -174,51 +173,91 @@ private static boolean canTraverseWithoutReusingEdge(\n   }\n \n   /**\n-   * Returns the transitive closure of {@code graph}. The transitive closure of a graph is another\n-   * graph with an edge connecting node A to node B if node B is {@link #reachableNodes(Graph,\n-   * Object) reachable} from node A.\n+   * Returns the transitive closure of {@code graph}. The transitive closure of a graph {@code G} is\n+   * a graph {@code T} that is a supergraph of {@code G}, augmented by, for each pair of nodes A and\n+   * B, an edge connecting node A to node B if there is a sequence of edges in {@code G} starting at\n+   * A and ending at B.\n+   *\n+   * <p>{@code strategy} defines the circumstances under which self-loops will be added to the\n+   * transitive closure graph.\n    *\n    * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live view\n    * of the transitive closure of {@code graph}. In other words, the returned {@link Graph} will not\n    * be updated after modifications to {@code graph}.\n    *\n-   * @since 33.1.0 (present with return type {@code Graph} since 20.0)\n+   * @since NEXT\n    */\n-  // TODO(b/31438252): Consider potential optimizations for this algorithm.\n-  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {\n+  // TODO(b/31438252): Consider optimizing for undirected graphs.\n+  public static <N> ImmutableGraph<N> transitiveClosure(\n+      Graph<N> graph, TransitiveClosureSelfLoopStrategy strategy) {\n     ImmutableGraph.Builder<N> transitiveClosure =\n         GraphBuilder.from(graph).allowsSelfLoops(true).<N>immutable();\n-    // Every node is, at a minimum, reachable from itself. Since the resulting transitive closure\n-    // will have no isolated nodes, we can skip adding nodes explicitly and let putEdge() do it.\n-\n-    if (graph.isDirected()) {\n-      // Note: works for both directed and undirected graphs, but we only use in the directed case.\n-      for (N node : graph.nodes()) {\n-        for (N reachableNode : reachableNodes(graph, node)) {\n-          transitiveClosure.putEdge(node, reachableNode);\n-        }\n-      }\n-    } else {\n-      // An optimization for the undirected case: for every node B reachable from node A,\n-      // node A and node B have the same reachability set.\n-      Set<N> visitedNodes = new HashSet<>();\n-      for (N node : graph.nodes()) {\n-        if (!visitedNodes.contains(node)) {\n-          Set<N> reachableNodes = reachableNodes(graph, node);\n-          visitedNodes.addAll(reachableNodes);\n-          int pairwiseMatch = 1; // start at 1 to include self-loops\n-          for (N nodeU : reachableNodes) {\n-            for (N nodeV : Iterables.limit(reachableNodes, pairwiseMatch++)) {\n-              transitiveClosure.putEdge(nodeU, nodeV);\n-            }\n-          }\n-        }\n+\n+    for (N node : graph.nodes()) {\n+      // add each node explicitly to include isolated nodes\n+      transitiveClosure.addNode(node);\n+      for (N reachableNode : getReachableNodes(graph, node, strategy)) {\n+        transitiveClosure.putEdge(node, reachableNode);\n       }\n     }\n-\n     return transitiveClosure.build();\n   }\n \n+  /**\n+   * Equivalent to {@code transitiveClosure(graph, ADD_SELF_LOOPS_ALWAYS)}. Callers should look at\n+   * the different strategy options that the new method supports rather than simply migrating to the\n+   * new method with the existing behavior; we believe that most callers will want to use the {@code\n+   * ADD_SELF_LOOPS_FOR_CYCLES} strategy.\n+   *\n+   * @since 33.1.0 (present with return type {@code Graph} since 20.0)\n+   * @deprecated Use {@link #transitiveClosure(Graph, TransitiveClosureSelfLoopStrategy)} instead.\n+   */\n+  @SuppressWarnings(\"InlineMeSuggester\") // We expect most users to want to change behavior.\n+  @Deprecated\n+  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {\n+    return transitiveClosure(graph, ADD_SELF_LOOPS_ALWAYS);\n+  }\n+\n+  /**\n+   * Returns the nodes reachable from {@code node} in {@code graph}, according to the given {@code\n+   * strategy}.\n+   */\n+  private static <N> Iterable<N> getReachableNodes(\n+      Graph<N> graph, N node, TransitiveClosureSelfLoopStrategy strategy) {\n+    Traverser<N> traverser = Traverser.forGraph(graph);\n+    switch (strategy) {\n+      case ADD_SELF_LOOPS_ALWAYS: // always include 'node'\n+        return traverser.breadthFirst(node);\n+      case ADD_SELF_LOOPS_FOR_CYCLES: // include 'node' iff there's an incident cycle\n+        // note that if 'node' has a self-loop, it will appear in its successors\n+        return traverser.breadthFirst(graph.successors(node));\n+    }\n+    throw new IllegalArgumentException(\"Unrecognized strategy: \" + strategy);\n+  }\n+\n+  /**\n+   * A strategy for adding self-loops to {@linkplain #transitiveClosure(Graph,\n+   * TransitiveClosureSelfLoopStrategy) the transitive closure graph}. All strategies preserve\n+   * self-loops that are present in the original graph.\n+   *\n+   * <p>The strategies differ based on how they define \"cycle incident to a node\".\n+   *\n+   * @since NEXT\n+   */\n+  public enum TransitiveClosureSelfLoopStrategy {\n+    /**\n+     * Add a self-loop to each node in the original graph; this is based on a definition of \"cycle\n+     * incident to a node\" that includes zero-length cycles. This matches the behavior of the\n+     * now-deprecated {@link #transitiveClosure(Graph)} method.\n+     */\n+    ADD_SELF_LOOPS_ALWAYS,\n+    /**\n+     * Add a self-loop to each node that is incident to a cycle of length one or greater in the\n+     * original graph.\n+     */\n+    ADD_SELF_LOOPS_FOR_CYCLES\n+  }\n+\n   /**\n    * Returns the set of nodes that are reachable from {@code node}. Specifically, it returns all\n    * nodes {@code v} such that there exists a path (a sequence of adjacent outgoing edges) starting"
    },
    {
      "filename": "guava-tests/test/com/google/common/graph/GraphsTest.java",
      "status": "modified",
      "additions": 158,
      "deletions": 23,
      "changes": 181,
      "patch": "@@ -16,16 +16,16 @@\n \n package com.google.common.graph;\n \n+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_ALWAYS;\n+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_FOR_CYCLES;\n import static com.google.common.graph.Graphs.copyOf;\n import static com.google.common.graph.Graphs.inducedSubgraph;\n-import static com.google.common.graph.Graphs.reachableNodes;\n import static com.google.common.graph.Graphs.transitiveClosure;\n import static com.google.common.graph.Graphs.transpose;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertThrows;\n \n import com.google.common.collect.ImmutableSet;\n-import java.util.Set;\n import org.jspecify.annotations.NullUnmarked;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -61,7 +61,7 @@ public class GraphsTest {\n   static final String ERROR_SELF_LOOP = \"self-loops are not allowed\";\n \n   @Test\n-  public void transitiveClosure_directedGraph() {\n+  public void transitiveClosure_directedGraph_addSelfLoopsAlways() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n     directedGraph.putEdge(N1, N2);\n     directedGraph.putEdge(N1, N3);\n@@ -77,11 +77,30 @@ public void transitiveClosure_directedGraph() {\n     expectedClosure.putEdge(N3, N3);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(directedGraph, expectedClosure);\n+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_undirectedGraph() {\n+  public void transitiveClosure_directedGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n+    directedGraph.putEdge(N1, N2);\n+    directedGraph.putEdge(N1, N3);\n+    directedGraph.putEdge(N2, N3);\n+    directedGraph.addNode(N4);\n+\n+    // the above graph is its own transitive closure\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.addNode(N4);\n+\n+    assertThat(\n+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_undirectedGraph_addSelfLoopsAlways() {\n     MutableGraph<Integer> undirectedGraph =\n         GraphBuilder.undirected().allowsSelfLoops(false).build();\n     undirectedGraph.putEdge(N1, N2);\n@@ -98,11 +117,34 @@ public void transitiveClosure_undirectedGraph() {\n     expectedClosure.putEdge(N3, N3);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(undirectedGraph, expectedClosure);\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_directedPathGraph() {\n+  public void transitiveClosure_undirectedGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> undirectedGraph =\n+        GraphBuilder.undirected().allowsSelfLoops(false).build();\n+    undirectedGraph.putEdge(N1, N2);\n+    undirectedGraph.putEdge(N1, N3);\n+    undirectedGraph.putEdge(N2, N3);\n+    undirectedGraph.addNode(N4);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.addNode(N4); // N4 is isolated => no incident edges in this transitive closure\n+\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedPathGraph_addSelfLoopsAlways() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n     directedGraph.putEdge(N1, N2);\n     directedGraph.putEdge(N2, N3);\n@@ -120,7 +162,26 @@ public void transitiveClosure_directedPathGraph() {\n     expectedClosure.putEdge(N3, N4);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(directedGraph, expectedClosure);\n+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedPathGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n+    directedGraph.putEdge(N1, N2);\n+    directedGraph.putEdge(N2, N3);\n+    directedGraph.putEdge(N3, N4);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N4);\n+\n+    assertThat(\n+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n@@ -143,11 +204,65 @@ public void transitiveClosure_undirectedPathGraph() {\n     expectedClosure.putEdge(N3, N4);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(undirectedGraph, expectedClosure);\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_directedCycleGraph() {\n+  public void transitiveClosure_undirectedPathGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> undirectedGraph =\n+        GraphBuilder.undirected().allowsSelfLoops(false).build();\n+    undirectedGraph.putEdge(N1, N2);\n+    undirectedGraph.putEdge(N2, N3);\n+    undirectedGraph.putEdge(N3, N4);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.putEdge(N3, N4);\n+    expectedClosure.putEdge(N4, N4);\n+\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedCycleGraph_addSelfLoopsAlways() {\n+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n+    directedGraph.putEdge(N1, N2);\n+    directedGraph.putEdge(N2, N3);\n+    directedGraph.putEdge(N3, N4);\n+    directedGraph.putEdge(N4, N1);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N1);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N1);\n+    expectedClosure.putEdge(N3, N2);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.putEdge(N3, N4);\n+    expectedClosure.putEdge(N4, N1);\n+    expectedClosure.putEdge(N4, N2);\n+    expectedClosure.putEdge(N4, N3);\n+    expectedClosure.putEdge(N4, N4);\n+\n+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedCycleGraph_addSelfLoopsForCycles() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n     directedGraph.putEdge(N1, N2);\n     directedGraph.putEdge(N2, N3);\n@@ -172,11 +287,37 @@ public void transitiveClosure_directedCycleGraph() {\n     expectedClosure.putEdge(N4, N3);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(directedGraph, expectedClosure);\n+    assertThat(\n+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_undirectedCycleGraph_addSelfLoopsAlways() {\n+    MutableGraph<Integer> undirectedGraph =\n+        GraphBuilder.undirected().allowsSelfLoops(false).build();\n+    undirectedGraph.putEdge(N1, N2);\n+    undirectedGraph.putEdge(N2, N3);\n+    undirectedGraph.putEdge(N3, N4);\n+    undirectedGraph.putEdge(N4, N1);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.putEdge(N3, N4);\n+    expectedClosure.putEdge(N4, N4);\n+\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_undirectedCycleGraph() {\n+  public void transitiveClosure_undirectedCycleGraph_addSelfLoopsForCycles() {\n     MutableGraph<Integer> undirectedGraph =\n         GraphBuilder.undirected().allowsSelfLoops(false).build();\n     undirectedGraph.putEdge(N1, N2);\n@@ -196,7 +337,8 @@ public void transitiveClosure_undirectedCycleGraph() {\n     expectedClosure.putEdge(N3, N4);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(undirectedGraph, expectedClosure);\n+    assertThat(\n+        transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n@@ -335,7 +477,7 @@ public void transpose_directedNetwork() {\n \n   @Test\n   public void inducedSubgraph_graph() {\n-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n \n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();\n     directedGraph.putEdge(N1, N2);\n@@ -354,7 +496,7 @@ public void inducedSubgraph_graph() {\n \n   @Test\n   public void inducedSubgraph_valueGraph() {\n-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n \n     MutableValueGraph<Integer, String> directedGraph =\n         ValueGraphBuilder.directed().allowsSelfLoops(true).build();\n@@ -375,7 +517,7 @@ public void inducedSubgraph_valueGraph() {\n \n   @Test\n   public void inducedSubgraph_network() {\n-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n \n     MutableNetwork<Integer, String> directedGraph =\n         NetworkBuilder.directed().allowsSelfLoops(true).build();\n@@ -571,13 +713,6 @@ public void builder_expectedEdgeCount_negative() {\n     assertThat(e).hasMessageThat().contains(ERROR_NEGATIVE_COUNT);\n   }\n \n-  private static <N> void checkTransitiveClosure(Graph<N> originalGraph, Graph<N> expectedClosure) {\n-    for (N node : originalGraph.nodes()) {\n-      assertThat(reachableNodes(originalGraph, node)).isEqualTo(expectedClosure.successors(node));\n-    }\n-    assertThat(transitiveClosure(originalGraph)).isEqualTo(expectedClosure);\n-  }\n-\n   private static MutableGraph<Integer> buildDirectedGraph() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();\n     directedGraph.putEdge(N1, N1);"
    },
    {
      "filename": "guava/src/com/google/common/graph/Graphs.java",
      "status": "modified",
      "additions": 73,
      "deletions": 34,
      "changes": 107,
      "patch": "@@ -18,18 +18,17 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.graph.GraphConstants.NODE_NOT_IN_GRAPH;\n+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_ALWAYS;\n import static java.util.Objects.requireNonNull;\n \n import com.google.common.annotations.Beta;\n import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Iterables;\n import com.google.common.collect.Iterators;\n import com.google.common.collect.Maps;\n import com.google.errorprone.annotations.CanIgnoreReturnValue;\n import java.util.ArrayDeque;\n import java.util.Collection;\n import java.util.Deque;\n-import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Objects;\n@@ -175,51 +174,91 @@ private static boolean canTraverseWithoutReusingEdge(\n   }\n \n   /**\n-   * Returns the transitive closure of {@code graph}. The transitive closure of a graph is another\n-   * graph with an edge connecting node A to node B if node B is {@link #reachableNodes(Graph,\n-   * Object) reachable} from node A.\n+   * Returns the transitive closure of {@code graph}. The transitive closure of a graph {@code G} is\n+   * a graph {@code T} that is a supergraph of {@code G}, augmented by, for each pair of nodes A and\n+   * B, an edge connecting node A to node B if there is a sequence of edges in {@code G} starting at\n+   * A and ending at B.\n+   *\n+   * <p>{@code strategy} defines the circumstances under which self-loops will be added to the\n+   * transitive closure graph.\n    *\n    * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live view\n    * of the transitive closure of {@code graph}. In other words, the returned {@link Graph} will not\n    * be updated after modifications to {@code graph}.\n    *\n-   * @since 33.1.0 (present with return type {@code Graph} since 20.0)\n+   * @since NEXT\n    */\n-  // TODO(b/31438252): Consider potential optimizations for this algorithm.\n-  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {\n+  // TODO(b/31438252): Consider optimizing for undirected graphs.\n+  public static <N> ImmutableGraph<N> transitiveClosure(\n+      Graph<N> graph, TransitiveClosureSelfLoopStrategy strategy) {\n     ImmutableGraph.Builder<N> transitiveClosure =\n         GraphBuilder.from(graph).allowsSelfLoops(true).<N>immutable();\n-    // Every node is, at a minimum, reachable from itself. Since the resulting transitive closure\n-    // will have no isolated nodes, we can skip adding nodes explicitly and let putEdge() do it.\n-\n-    if (graph.isDirected()) {\n-      // Note: works for both directed and undirected graphs, but we only use in the directed case.\n-      for (N node : graph.nodes()) {\n-        for (N reachableNode : reachableNodes(graph, node)) {\n-          transitiveClosure.putEdge(node, reachableNode);\n-        }\n-      }\n-    } else {\n-      // An optimization for the undirected case: for every node B reachable from node A,\n-      // node A and node B have the same reachability set.\n-      Set<N> visitedNodes = new HashSet<>();\n-      for (N node : graph.nodes()) {\n-        if (!visitedNodes.contains(node)) {\n-          Set<N> reachableNodes = reachableNodes(graph, node);\n-          visitedNodes.addAll(reachableNodes);\n-          int pairwiseMatch = 1; // start at 1 to include self-loops\n-          for (N nodeU : reachableNodes) {\n-            for (N nodeV : Iterables.limit(reachableNodes, pairwiseMatch++)) {\n-              transitiveClosure.putEdge(nodeU, nodeV);\n-            }\n-          }\n-        }\n+\n+    for (N node : graph.nodes()) {\n+      // add each node explicitly to include isolated nodes\n+      transitiveClosure.addNode(node);\n+      for (N reachableNode : getReachableNodes(graph, node, strategy)) {\n+        transitiveClosure.putEdge(node, reachableNode);\n       }\n     }\n-\n     return transitiveClosure.build();\n   }\n \n+  /**\n+   * Equivalent to {@code transitiveClosure(graph, ADD_SELF_LOOPS_ALWAYS)}. Callers should look at\n+   * the different strategy options that the new method supports rather than simply migrating to the\n+   * new method with the existing behavior; we believe that most callers will want to use the {@code\n+   * ADD_SELF_LOOPS_FOR_CYCLES} strategy.\n+   *\n+   * @since 33.1.0 (present with return type {@code Graph} since 20.0)\n+   * @deprecated Use {@link #transitiveClosure(Graph, TransitiveClosureSelfLoopStrategy)} instead.\n+   */\n+  @SuppressWarnings(\"InlineMeSuggester\") // We expect most users to want to change behavior.\n+  @Deprecated\n+  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {\n+    return transitiveClosure(graph, ADD_SELF_LOOPS_ALWAYS);\n+  }\n+\n+  /**\n+   * Returns the nodes reachable from {@code node} in {@code graph}, according to the given {@code\n+   * strategy}.\n+   */\n+  private static <N> Iterable<N> getReachableNodes(\n+      Graph<N> graph, N node, TransitiveClosureSelfLoopStrategy strategy) {\n+    Traverser<N> traverser = Traverser.forGraph(graph);\n+    switch (strategy) {\n+      case ADD_SELF_LOOPS_ALWAYS: // always include 'node'\n+        return traverser.breadthFirst(node);\n+      case ADD_SELF_LOOPS_FOR_CYCLES: // include 'node' iff there's an incident cycle\n+        // note that if 'node' has a self-loop, it will appear in its successors\n+        return traverser.breadthFirst(graph.successors(node));\n+    }\n+    throw new IllegalArgumentException(\"Unrecognized strategy: \" + strategy);\n+  }\n+\n+  /**\n+   * A strategy for adding self-loops to {@linkplain #transitiveClosure(Graph,\n+   * TransitiveClosureSelfLoopStrategy) the transitive closure graph}. All strategies preserve\n+   * self-loops that are present in the original graph.\n+   *\n+   * <p>The strategies differ based on how they define \"cycle incident to a node\".\n+   *\n+   * @since NEXT\n+   */\n+  public enum TransitiveClosureSelfLoopStrategy {\n+    /**\n+     * Add a self-loop to each node in the original graph; this is based on a definition of \"cycle\n+     * incident to a node\" that includes zero-length cycles. This matches the behavior of the\n+     * now-deprecated {@link #transitiveClosure(Graph)} method.\n+     */\n+    ADD_SELF_LOOPS_ALWAYS,\n+    /**\n+     * Add a self-loop to each node that is incident to a cycle of length one or greater in the\n+     * original graph.\n+     */\n+    ADD_SELF_LOOPS_FOR_CYCLES\n+  }\n+\n   /**\n    * Returns the set of nodes that are reachable from {@code node}. Specifically, it returns all\n    * nodes {@code v} such that there exists a path (a sequence of adjacent outgoing edges) starting"
    }
  ],
  "diff": "diff --git a/android/guava-tests/test/com/google/common/graph/GraphsTest.java b/android/guava-tests/test/com/google/common/graph/GraphsTest.java\nindex 20199ee8feb3..293ac4529273 100644\n--- a/android/guava-tests/test/com/google/common/graph/GraphsTest.java\n+++ b/android/guava-tests/test/com/google/common/graph/GraphsTest.java\n@@ -16,16 +16,16 @@\n \n package com.google.common.graph;\n \n+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_ALWAYS;\n+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_FOR_CYCLES;\n import static com.google.common.graph.Graphs.copyOf;\n import static com.google.common.graph.Graphs.inducedSubgraph;\n-import static com.google.common.graph.Graphs.reachableNodes;\n import static com.google.common.graph.Graphs.transitiveClosure;\n import static com.google.common.graph.Graphs.transpose;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertThrows;\n \n import com.google.common.collect.ImmutableSet;\n-import java.util.Set;\n import org.jspecify.annotations.NullUnmarked;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -61,7 +61,7 @@ public class GraphsTest {\n   static final String ERROR_SELF_LOOP = \"self-loops are not allowed\";\n \n   @Test\n-  public void transitiveClosure_directedGraph() {\n+  public void transitiveClosure_directedGraph_addSelfLoopsAlways() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n     directedGraph.putEdge(N1, N2);\n     directedGraph.putEdge(N1, N3);\n@@ -77,11 +77,30 @@ public void transitiveClosure_directedGraph() {\n     expectedClosure.putEdge(N3, N3);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(directedGraph, expectedClosure);\n+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_undirectedGraph() {\n+  public void transitiveClosure_directedGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n+    directedGraph.putEdge(N1, N2);\n+    directedGraph.putEdge(N1, N3);\n+    directedGraph.putEdge(N2, N3);\n+    directedGraph.addNode(N4);\n+\n+    // the above graph is its own transitive closure\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.addNode(N4);\n+\n+    assertThat(\n+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_undirectedGraph_addSelfLoopsAlways() {\n     MutableGraph<Integer> undirectedGraph =\n         GraphBuilder.undirected().allowsSelfLoops(false).build();\n     undirectedGraph.putEdge(N1, N2);\n@@ -98,11 +117,34 @@ public void transitiveClosure_undirectedGraph() {\n     expectedClosure.putEdge(N3, N3);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(undirectedGraph, expectedClosure);\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_directedPathGraph() {\n+  public void transitiveClosure_undirectedGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> undirectedGraph =\n+        GraphBuilder.undirected().allowsSelfLoops(false).build();\n+    undirectedGraph.putEdge(N1, N2);\n+    undirectedGraph.putEdge(N1, N3);\n+    undirectedGraph.putEdge(N2, N3);\n+    undirectedGraph.addNode(N4);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.addNode(N4); // N4 is isolated => no incident edges in this transitive closure\n+\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedPathGraph_addSelfLoopsAlways() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n     directedGraph.putEdge(N1, N2);\n     directedGraph.putEdge(N2, N3);\n@@ -120,7 +162,26 @@ public void transitiveClosure_directedPathGraph() {\n     expectedClosure.putEdge(N3, N4);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(directedGraph, expectedClosure);\n+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedPathGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n+    directedGraph.putEdge(N1, N2);\n+    directedGraph.putEdge(N2, N3);\n+    directedGraph.putEdge(N3, N4);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N4);\n+\n+    assertThat(\n+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n@@ -143,11 +204,65 @@ public void transitiveClosure_undirectedPathGraph() {\n     expectedClosure.putEdge(N3, N4);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(undirectedGraph, expectedClosure);\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_directedCycleGraph() {\n+  public void transitiveClosure_undirectedPathGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> undirectedGraph =\n+        GraphBuilder.undirected().allowsSelfLoops(false).build();\n+    undirectedGraph.putEdge(N1, N2);\n+    undirectedGraph.putEdge(N2, N3);\n+    undirectedGraph.putEdge(N3, N4);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.putEdge(N3, N4);\n+    expectedClosure.putEdge(N4, N4);\n+\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedCycleGraph_addSelfLoopsAlways() {\n+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n+    directedGraph.putEdge(N1, N2);\n+    directedGraph.putEdge(N2, N3);\n+    directedGraph.putEdge(N3, N4);\n+    directedGraph.putEdge(N4, N1);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N1);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N1);\n+    expectedClosure.putEdge(N3, N2);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.putEdge(N3, N4);\n+    expectedClosure.putEdge(N4, N1);\n+    expectedClosure.putEdge(N4, N2);\n+    expectedClosure.putEdge(N4, N3);\n+    expectedClosure.putEdge(N4, N4);\n+\n+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedCycleGraph_addSelfLoopsForCycles() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n     directedGraph.putEdge(N1, N2);\n     directedGraph.putEdge(N2, N3);\n@@ -172,11 +287,37 @@ public void transitiveClosure_directedCycleGraph() {\n     expectedClosure.putEdge(N4, N3);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(directedGraph, expectedClosure);\n+    assertThat(\n+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_undirectedCycleGraph_addSelfLoopsAlways() {\n+    MutableGraph<Integer> undirectedGraph =\n+        GraphBuilder.undirected().allowsSelfLoops(false).build();\n+    undirectedGraph.putEdge(N1, N2);\n+    undirectedGraph.putEdge(N2, N3);\n+    undirectedGraph.putEdge(N3, N4);\n+    undirectedGraph.putEdge(N4, N1);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.putEdge(N3, N4);\n+    expectedClosure.putEdge(N4, N4);\n+\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_undirectedCycleGraph() {\n+  public void transitiveClosure_undirectedCycleGraph_addSelfLoopsForCycles() {\n     MutableGraph<Integer> undirectedGraph =\n         GraphBuilder.undirected().allowsSelfLoops(false).build();\n     undirectedGraph.putEdge(N1, N2);\n@@ -196,7 +337,8 @@ public void transitiveClosure_undirectedCycleGraph() {\n     expectedClosure.putEdge(N3, N4);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(undirectedGraph, expectedClosure);\n+    assertThat(\n+        transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n@@ -334,7 +476,7 @@ public void transpose_directedNetwork() {\n \n   @Test\n   public void inducedSubgraph_graph() {\n-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n \n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();\n     directedGraph.putEdge(N1, N2);\n@@ -353,7 +495,7 @@ public void inducedSubgraph_graph() {\n \n   @Test\n   public void inducedSubgraph_valueGraph() {\n-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n \n     MutableValueGraph<Integer, String> directedGraph =\n         ValueGraphBuilder.directed().allowsSelfLoops(true).build();\n@@ -374,7 +516,7 @@ public void inducedSubgraph_valueGraph() {\n \n   @Test\n   public void inducedSubgraph_network() {\n-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n \n     MutableNetwork<Integer, String> directedGraph =\n         NetworkBuilder.directed().allowsSelfLoops(true).build();\n@@ -570,13 +712,6 @@ public void builder_expectedEdgeCount_negative() {\n     assertThat(e).hasMessageThat().contains(ERROR_NEGATIVE_COUNT);\n   }\n \n-  private static <N> void checkTransitiveClosure(Graph<N> originalGraph, Graph<N> expectedClosure) {\n-    for (N node : originalGraph.nodes()) {\n-      assertThat(reachableNodes(originalGraph, node)).isEqualTo(expectedClosure.successors(node));\n-    }\n-    assertThat(transitiveClosure(originalGraph)).isEqualTo(expectedClosure);\n-  }\n-\n   private static MutableGraph<Integer> buildDirectedGraph() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();\n     directedGraph.putEdge(N1, N1);\ndiff --git a/android/guava/src/com/google/common/graph/Graphs.java b/android/guava/src/com/google/common/graph/Graphs.java\nindex bca410aaa209..ead5bdc90f87 100644\n--- a/android/guava/src/com/google/common/graph/Graphs.java\n+++ b/android/guava/src/com/google/common/graph/Graphs.java\n@@ -18,18 +18,17 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.graph.GraphConstants.NODE_NOT_IN_GRAPH;\n+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_ALWAYS;\n import static java.util.Objects.requireNonNull;\n \n import com.google.common.annotations.Beta;\n import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Iterables;\n import com.google.common.collect.Iterators;\n import com.google.common.collect.Maps;\n import com.google.errorprone.annotations.CanIgnoreReturnValue;\n import java.util.ArrayDeque;\n import java.util.Collection;\n import java.util.Deque;\n-import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Objects;\n@@ -174,51 +173,91 @@ private static boolean canTraverseWithoutReusingEdge(\n   }\n \n   /**\n-   * Returns the transitive closure of {@code graph}. The transitive closure of a graph is another\n-   * graph with an edge connecting node A to node B if node B is {@link #reachableNodes(Graph,\n-   * Object) reachable} from node A.\n+   * Returns the transitive closure of {@code graph}. The transitive closure of a graph {@code G} is\n+   * a graph {@code T} that is a supergraph of {@code G}, augmented by, for each pair of nodes A and\n+   * B, an edge connecting node A to node B if there is a sequence of edges in {@code G} starting at\n+   * A and ending at B.\n+   *\n+   * <p>{@code strategy} defines the circumstances under which self-loops will be added to the\n+   * transitive closure graph.\n    *\n    * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live view\n    * of the transitive closure of {@code graph}. In other words, the returned {@link Graph} will not\n    * be updated after modifications to {@code graph}.\n    *\n-   * @since 33.1.0 (present with return type {@code Graph} since 20.0)\n+   * @since NEXT\n    */\n-  // TODO(b/31438252): Consider potential optimizations for this algorithm.\n-  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {\n+  // TODO(b/31438252): Consider optimizing for undirected graphs.\n+  public static <N> ImmutableGraph<N> transitiveClosure(\n+      Graph<N> graph, TransitiveClosureSelfLoopStrategy strategy) {\n     ImmutableGraph.Builder<N> transitiveClosure =\n         GraphBuilder.from(graph).allowsSelfLoops(true).<N>immutable();\n-    // Every node is, at a minimum, reachable from itself. Since the resulting transitive closure\n-    // will have no isolated nodes, we can skip adding nodes explicitly and let putEdge() do it.\n-\n-    if (graph.isDirected()) {\n-      // Note: works for both directed and undirected graphs, but we only use in the directed case.\n-      for (N node : graph.nodes()) {\n-        for (N reachableNode : reachableNodes(graph, node)) {\n-          transitiveClosure.putEdge(node, reachableNode);\n-        }\n-      }\n-    } else {\n-      // An optimization for the undirected case: for every node B reachable from node A,\n-      // node A and node B have the same reachability set.\n-      Set<N> visitedNodes = new HashSet<>();\n-      for (N node : graph.nodes()) {\n-        if (!visitedNodes.contains(node)) {\n-          Set<N> reachableNodes = reachableNodes(graph, node);\n-          visitedNodes.addAll(reachableNodes);\n-          int pairwiseMatch = 1; // start at 1 to include self-loops\n-          for (N nodeU : reachableNodes) {\n-            for (N nodeV : Iterables.limit(reachableNodes, pairwiseMatch++)) {\n-              transitiveClosure.putEdge(nodeU, nodeV);\n-            }\n-          }\n-        }\n+\n+    for (N node : graph.nodes()) {\n+      // add each node explicitly to include isolated nodes\n+      transitiveClosure.addNode(node);\n+      for (N reachableNode : getReachableNodes(graph, node, strategy)) {\n+        transitiveClosure.putEdge(node, reachableNode);\n       }\n     }\n-\n     return transitiveClosure.build();\n   }\n \n+  /**\n+   * Equivalent to {@code transitiveClosure(graph, ADD_SELF_LOOPS_ALWAYS)}. Callers should look at\n+   * the different strategy options that the new method supports rather than simply migrating to the\n+   * new method with the existing behavior; we believe that most callers will want to use the {@code\n+   * ADD_SELF_LOOPS_FOR_CYCLES} strategy.\n+   *\n+   * @since 33.1.0 (present with return type {@code Graph} since 20.0)\n+   * @deprecated Use {@link #transitiveClosure(Graph, TransitiveClosureSelfLoopStrategy)} instead.\n+   */\n+  @SuppressWarnings(\"InlineMeSuggester\") // We expect most users to want to change behavior.\n+  @Deprecated\n+  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {\n+    return transitiveClosure(graph, ADD_SELF_LOOPS_ALWAYS);\n+  }\n+\n+  /**\n+   * Returns the nodes reachable from {@code node} in {@code graph}, according to the given {@code\n+   * strategy}.\n+   */\n+  private static <N> Iterable<N> getReachableNodes(\n+      Graph<N> graph, N node, TransitiveClosureSelfLoopStrategy strategy) {\n+    Traverser<N> traverser = Traverser.forGraph(graph);\n+    switch (strategy) {\n+      case ADD_SELF_LOOPS_ALWAYS: // always include 'node'\n+        return traverser.breadthFirst(node);\n+      case ADD_SELF_LOOPS_FOR_CYCLES: // include 'node' iff there's an incident cycle\n+        // note that if 'node' has a self-loop, it will appear in its successors\n+        return traverser.breadthFirst(graph.successors(node));\n+    }\n+    throw new IllegalArgumentException(\"Unrecognized strategy: \" + strategy);\n+  }\n+\n+  /**\n+   * A strategy for adding self-loops to {@linkplain #transitiveClosure(Graph,\n+   * TransitiveClosureSelfLoopStrategy) the transitive closure graph}. All strategies preserve\n+   * self-loops that are present in the original graph.\n+   *\n+   * <p>The strategies differ based on how they define \"cycle incident to a node\".\n+   *\n+   * @since NEXT\n+   */\n+  public enum TransitiveClosureSelfLoopStrategy {\n+    /**\n+     * Add a self-loop to each node in the original graph; this is based on a definition of \"cycle\n+     * incident to a node\" that includes zero-length cycles. This matches the behavior of the\n+     * now-deprecated {@link #transitiveClosure(Graph)} method.\n+     */\n+    ADD_SELF_LOOPS_ALWAYS,\n+    /**\n+     * Add a self-loop to each node that is incident to a cycle of length one or greater in the\n+     * original graph.\n+     */\n+    ADD_SELF_LOOPS_FOR_CYCLES\n+  }\n+\n   /**\n    * Returns the set of nodes that are reachable from {@code node}. Specifically, it returns all\n    * nodes {@code v} such that there exists a path (a sequence of adjacent outgoing edges) starting\ndiff --git a/guava-tests/test/com/google/common/graph/GraphsTest.java b/guava-tests/test/com/google/common/graph/GraphsTest.java\nindex 4be09009d080..15d5f13bdcfd 100644\n--- a/guava-tests/test/com/google/common/graph/GraphsTest.java\n+++ b/guava-tests/test/com/google/common/graph/GraphsTest.java\n@@ -16,16 +16,16 @@\n \n package com.google.common.graph;\n \n+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_ALWAYS;\n+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_FOR_CYCLES;\n import static com.google.common.graph.Graphs.copyOf;\n import static com.google.common.graph.Graphs.inducedSubgraph;\n-import static com.google.common.graph.Graphs.reachableNodes;\n import static com.google.common.graph.Graphs.transitiveClosure;\n import static com.google.common.graph.Graphs.transpose;\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertThrows;\n \n import com.google.common.collect.ImmutableSet;\n-import java.util.Set;\n import org.jspecify.annotations.NullUnmarked;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -61,7 +61,7 @@ public class GraphsTest {\n   static final String ERROR_SELF_LOOP = \"self-loops are not allowed\";\n \n   @Test\n-  public void transitiveClosure_directedGraph() {\n+  public void transitiveClosure_directedGraph_addSelfLoopsAlways() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n     directedGraph.putEdge(N1, N2);\n     directedGraph.putEdge(N1, N3);\n@@ -77,11 +77,30 @@ public void transitiveClosure_directedGraph() {\n     expectedClosure.putEdge(N3, N3);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(directedGraph, expectedClosure);\n+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_undirectedGraph() {\n+  public void transitiveClosure_directedGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n+    directedGraph.putEdge(N1, N2);\n+    directedGraph.putEdge(N1, N3);\n+    directedGraph.putEdge(N2, N3);\n+    directedGraph.addNode(N4);\n+\n+    // the above graph is its own transitive closure\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.addNode(N4);\n+\n+    assertThat(\n+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_undirectedGraph_addSelfLoopsAlways() {\n     MutableGraph<Integer> undirectedGraph =\n         GraphBuilder.undirected().allowsSelfLoops(false).build();\n     undirectedGraph.putEdge(N1, N2);\n@@ -98,11 +117,34 @@ public void transitiveClosure_undirectedGraph() {\n     expectedClosure.putEdge(N3, N3);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(undirectedGraph, expectedClosure);\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_directedPathGraph() {\n+  public void transitiveClosure_undirectedGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> undirectedGraph =\n+        GraphBuilder.undirected().allowsSelfLoops(false).build();\n+    undirectedGraph.putEdge(N1, N2);\n+    undirectedGraph.putEdge(N1, N3);\n+    undirectedGraph.putEdge(N2, N3);\n+    undirectedGraph.addNode(N4);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.addNode(N4); // N4 is isolated => no incident edges in this transitive closure\n+\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedPathGraph_addSelfLoopsAlways() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n     directedGraph.putEdge(N1, N2);\n     directedGraph.putEdge(N2, N3);\n@@ -120,7 +162,26 @@ public void transitiveClosure_directedPathGraph() {\n     expectedClosure.putEdge(N3, N4);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(directedGraph, expectedClosure);\n+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedPathGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n+    directedGraph.putEdge(N1, N2);\n+    directedGraph.putEdge(N2, N3);\n+    directedGraph.putEdge(N3, N4);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N4);\n+\n+    assertThat(\n+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n@@ -143,11 +204,65 @@ public void transitiveClosure_undirectedPathGraph() {\n     expectedClosure.putEdge(N3, N4);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(undirectedGraph, expectedClosure);\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_directedCycleGraph() {\n+  public void transitiveClosure_undirectedPathGraph_addSelfLoopsForCycles() {\n+    MutableGraph<Integer> undirectedGraph =\n+        GraphBuilder.undirected().allowsSelfLoops(false).build();\n+    undirectedGraph.putEdge(N1, N2);\n+    undirectedGraph.putEdge(N2, N3);\n+    undirectedGraph.putEdge(N3, N4);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.putEdge(N3, N4);\n+    expectedClosure.putEdge(N4, N4);\n+\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedCycleGraph_addSelfLoopsAlways() {\n+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n+    directedGraph.putEdge(N1, N2);\n+    directedGraph.putEdge(N2, N3);\n+    directedGraph.putEdge(N3, N4);\n+    directedGraph.putEdge(N4, N1);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N1);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N1);\n+    expectedClosure.putEdge(N3, N2);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.putEdge(N3, N4);\n+    expectedClosure.putEdge(N4, N1);\n+    expectedClosure.putEdge(N4, N2);\n+    expectedClosure.putEdge(N4, N3);\n+    expectedClosure.putEdge(N4, N4);\n+\n+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_directedCycleGraph_addSelfLoopsForCycles() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();\n     directedGraph.putEdge(N1, N2);\n     directedGraph.putEdge(N2, N3);\n@@ -172,11 +287,37 @@ public void transitiveClosure_directedCycleGraph() {\n     expectedClosure.putEdge(N4, N3);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(directedGraph, expectedClosure);\n+    assertThat(\n+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n+  }\n+\n+  @Test\n+  public void transitiveClosure_undirectedCycleGraph_addSelfLoopsAlways() {\n+    MutableGraph<Integer> undirectedGraph =\n+        GraphBuilder.undirected().allowsSelfLoops(false).build();\n+    undirectedGraph.putEdge(N1, N2);\n+    undirectedGraph.putEdge(N2, N3);\n+    undirectedGraph.putEdge(N3, N4);\n+    undirectedGraph.putEdge(N4, N1);\n+\n+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();\n+    expectedClosure.putEdge(N1, N1);\n+    expectedClosure.putEdge(N1, N2);\n+    expectedClosure.putEdge(N1, N3);\n+    expectedClosure.putEdge(N1, N4);\n+    expectedClosure.putEdge(N2, N2);\n+    expectedClosure.putEdge(N2, N3);\n+    expectedClosure.putEdge(N2, N4);\n+    expectedClosure.putEdge(N3, N3);\n+    expectedClosure.putEdge(N3, N4);\n+    expectedClosure.putEdge(N4, N4);\n+\n+    assertThat(\n+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n-  public void transitiveClosure_undirectedCycleGraph() {\n+  public void transitiveClosure_undirectedCycleGraph_addSelfLoopsForCycles() {\n     MutableGraph<Integer> undirectedGraph =\n         GraphBuilder.undirected().allowsSelfLoops(false).build();\n     undirectedGraph.putEdge(N1, N2);\n@@ -196,7 +337,8 @@ public void transitiveClosure_undirectedCycleGraph() {\n     expectedClosure.putEdge(N3, N4);\n     expectedClosure.putEdge(N4, N4);\n \n-    checkTransitiveClosure(undirectedGraph, expectedClosure);\n+    assertThat(\n+        transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);\n   }\n \n   @Test\n@@ -335,7 +477,7 @@ public void transpose_directedNetwork() {\n \n   @Test\n   public void inducedSubgraph_graph() {\n-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n \n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();\n     directedGraph.putEdge(N1, N2);\n@@ -354,7 +496,7 @@ public void inducedSubgraph_graph() {\n \n   @Test\n   public void inducedSubgraph_valueGraph() {\n-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n \n     MutableValueGraph<Integer, String> directedGraph =\n         ValueGraphBuilder.directed().allowsSelfLoops(true).build();\n@@ -375,7 +517,7 @@ public void inducedSubgraph_valueGraph() {\n \n   @Test\n   public void inducedSubgraph_network() {\n-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);\n \n     MutableNetwork<Integer, String> directedGraph =\n         NetworkBuilder.directed().allowsSelfLoops(true).build();\n@@ -571,13 +713,6 @@ public void builder_expectedEdgeCount_negative() {\n     assertThat(e).hasMessageThat().contains(ERROR_NEGATIVE_COUNT);\n   }\n \n-  private static <N> void checkTransitiveClosure(Graph<N> originalGraph, Graph<N> expectedClosure) {\n-    for (N node : originalGraph.nodes()) {\n-      assertThat(reachableNodes(originalGraph, node)).isEqualTo(expectedClosure.successors(node));\n-    }\n-    assertThat(transitiveClosure(originalGraph)).isEqualTo(expectedClosure);\n-  }\n-\n   private static MutableGraph<Integer> buildDirectedGraph() {\n     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();\n     directedGraph.putEdge(N1, N1);\ndiff --git a/guava/src/com/google/common/graph/Graphs.java b/guava/src/com/google/common/graph/Graphs.java\nindex 2b0e7eb83298..ee54e392c1de 100644\n--- a/guava/src/com/google/common/graph/Graphs.java\n+++ b/guava/src/com/google/common/graph/Graphs.java\n@@ -18,18 +18,17 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.graph.GraphConstants.NODE_NOT_IN_GRAPH;\n+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_ALWAYS;\n import static java.util.Objects.requireNonNull;\n \n import com.google.common.annotations.Beta;\n import com.google.common.collect.ImmutableSet;\n-import com.google.common.collect.Iterables;\n import com.google.common.collect.Iterators;\n import com.google.common.collect.Maps;\n import com.google.errorprone.annotations.CanIgnoreReturnValue;\n import java.util.ArrayDeque;\n import java.util.Collection;\n import java.util.Deque;\n-import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Objects;\n@@ -175,51 +174,91 @@ private static boolean canTraverseWithoutReusingEdge(\n   }\n \n   /**\n-   * Returns the transitive closure of {@code graph}. The transitive closure of a graph is another\n-   * graph with an edge connecting node A to node B if node B is {@link #reachableNodes(Graph,\n-   * Object) reachable} from node A.\n+   * Returns the transitive closure of {@code graph}. The transitive closure of a graph {@code G} is\n+   * a graph {@code T} that is a supergraph of {@code G}, augmented by, for each pair of nodes A and\n+   * B, an edge connecting node A to node B if there is a sequence of edges in {@code G} starting at\n+   * A and ending at B.\n+   *\n+   * <p>{@code strategy} defines the circumstances under which self-loops will be added to the\n+   * transitive closure graph.\n    *\n    * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live view\n    * of the transitive closure of {@code graph}. In other words, the returned {@link Graph} will not\n    * be updated after modifications to {@code graph}.\n    *\n-   * @since 33.1.0 (present with return type {@code Graph} since 20.0)\n+   * @since NEXT\n    */\n-  // TODO(b/31438252): Consider potential optimizations for this algorithm.\n-  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {\n+  // TODO(b/31438252): Consider optimizing for undirected graphs.\n+  public static <N> ImmutableGraph<N> transitiveClosure(\n+      Graph<N> graph, TransitiveClosureSelfLoopStrategy strategy) {\n     ImmutableGraph.Builder<N> transitiveClosure =\n         GraphBuilder.from(graph).allowsSelfLoops(true).<N>immutable();\n-    // Every node is, at a minimum, reachable from itself. Since the resulting transitive closure\n-    // will have no isolated nodes, we can skip adding nodes explicitly and let putEdge() do it.\n-\n-    if (graph.isDirected()) {\n-      // Note: works for both directed and undirected graphs, but we only use in the directed case.\n-      for (N node : graph.nodes()) {\n-        for (N reachableNode : reachableNodes(graph, node)) {\n-          transitiveClosure.putEdge(node, reachableNode);\n-        }\n-      }\n-    } else {\n-      // An optimization for the undirected case: for every node B reachable from node A,\n-      // node A and node B have the same reachability set.\n-      Set<N> visitedNodes = new HashSet<>();\n-      for (N node : graph.nodes()) {\n-        if (!visitedNodes.contains(node)) {\n-          Set<N> reachableNodes = reachableNodes(graph, node);\n-          visitedNodes.addAll(reachableNodes);\n-          int pairwiseMatch = 1; // start at 1 to include self-loops\n-          for (N nodeU : reachableNodes) {\n-            for (N nodeV : Iterables.limit(reachableNodes, pairwiseMatch++)) {\n-              transitiveClosure.putEdge(nodeU, nodeV);\n-            }\n-          }\n-        }\n+\n+    for (N node : graph.nodes()) {\n+      // add each node explicitly to include isolated nodes\n+      transitiveClosure.addNode(node);\n+      for (N reachableNode : getReachableNodes(graph, node, strategy)) {\n+        transitiveClosure.putEdge(node, reachableNode);\n       }\n     }\n-\n     return transitiveClosure.build();\n   }\n \n+  /**\n+   * Equivalent to {@code transitiveClosure(graph, ADD_SELF_LOOPS_ALWAYS)}. Callers should look at\n+   * the different strategy options that the new method supports rather than simply migrating to the\n+   * new method with the existing behavior; we believe that most callers will want to use the {@code\n+   * ADD_SELF_LOOPS_FOR_CYCLES} strategy.\n+   *\n+   * @since 33.1.0 (present with return type {@code Graph} since 20.0)\n+   * @deprecated Use {@link #transitiveClosure(Graph, TransitiveClosureSelfLoopStrategy)} instead.\n+   */\n+  @SuppressWarnings(\"InlineMeSuggester\") // We expect most users to want to change behavior.\n+  @Deprecated\n+  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {\n+    return transitiveClosure(graph, ADD_SELF_LOOPS_ALWAYS);\n+  }\n+\n+  /**\n+   * Returns the nodes reachable from {@code node} in {@code graph}, according to the given {@code\n+   * strategy}.\n+   */\n+  private static <N> Iterable<N> getReachableNodes(\n+      Graph<N> graph, N node, TransitiveClosureSelfLoopStrategy strategy) {\n+    Traverser<N> traverser = Traverser.forGraph(graph);\n+    switch (strategy) {\n+      case ADD_SELF_LOOPS_ALWAYS: // always include 'node'\n+        return traverser.breadthFirst(node);\n+      case ADD_SELF_LOOPS_FOR_CYCLES: // include 'node' iff there's an incident cycle\n+        // note that if 'node' has a self-loop, it will appear in its successors\n+        return traverser.breadthFirst(graph.successors(node));\n+    }\n+    throw new IllegalArgumentException(\"Unrecognized strategy: \" + strategy);\n+  }\n+\n+  /**\n+   * A strategy for adding self-loops to {@linkplain #transitiveClosure(Graph,\n+   * TransitiveClosureSelfLoopStrategy) the transitive closure graph}. All strategies preserve\n+   * self-loops that are present in the original graph.\n+   *\n+   * <p>The strategies differ based on how they define \"cycle incident to a node\".\n+   *\n+   * @since NEXT\n+   */\n+  public enum TransitiveClosureSelfLoopStrategy {\n+    /**\n+     * Add a self-loop to each node in the original graph; this is based on a definition of \"cycle\n+     * incident to a node\" that includes zero-length cycles. This matches the behavior of the\n+     * now-deprecated {@link #transitiveClosure(Graph)} method.\n+     */\n+    ADD_SELF_LOOPS_ALWAYS,\n+    /**\n+     * Add a self-loop to each node that is incident to a cycle of length one or greater in the\n+     * original graph.\n+     */\n+    ADD_SELF_LOOPS_FOR_CYCLES\n+  }\n+\n   /**\n    * Returns the set of nodes that are reachable from {@code node}. Specifically, it returns all\n    * nodes {@code v} such that there exists a path (a sequence of adjacent outgoing edges) starting\n",
  "additions": 462,
  "deletions": 114,
  "changed_files": 4,
  "url": "https://github.com/google/guava/pull/8024",
  "mined_at": "2025-10-25T12:53:43.566176"
}