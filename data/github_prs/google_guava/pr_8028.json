{
  "id": 8028,
  "repository": "google/guava",
  "title": "Rewrite `c.g.c.cache` tests to use Truth assertions.",
  "body": "Rewrite `c.g.c.cache` tests to use Truth assertions.\n\nRELNOTES=n/a\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-09-30T22:03:33+00:00",
  "created_at": "2025-09-27T01:12:52+00:00",
  "updated_at": "2025-09-30T22:03:33+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "20e00a1c29aa8e72228a1c91bec85d8dd8d2fefa",
  "head_sha": "ca18af83382f54edfe66264ec5bb5c6ada72b058",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava-tests/test/com/google/common/cache/AbstractCacheTest.java",
      "status": "modified",
      "additions": 24,
      "deletions": 26,
      "changes": 50,
      "patch": "@@ -21,7 +21,6 @@\n import com.google.common.cache.AbstractCache.SimpleStatsCounter;\n import com.google.common.cache.AbstractCache.StatsCounter;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -47,11 +46,11 @@ public void testGetIfPresent() {\n           }\n         };\n \n-    assertNull(cache.getIfPresent(new Object()));\n+    assertThat(cache.getIfPresent(new Object())).isNull();\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getIfPresent(new Object()));\n+    assertThat(cache.getIfPresent(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetAllPresent_empty() {\n@@ -63,7 +62,7 @@ public void testGetAllPresent_empty() {\n           }\n         };\n \n-    assertEquals(ImmutableMap.of(), cache.getAllPresent(ImmutableList.of(new Object())));\n+    assertThat(cache.getAllPresent(ImmutableList.of(new Object()))).isEmpty();\n   }\n \n   public void testGetAllPresent_cached() {\n@@ -77,9 +76,8 @@ public void testGetAllPresent_cached() {\n           }\n         };\n \n-    assertEquals(\n-        ImmutableMap.of(cachedKey, cachedValue),\n-        cache.getAllPresent(ImmutableList.of(cachedKey, new Object())));\n+    assertThat(cache.getAllPresent(ImmutableList.of(cachedKey, new Object())))\n+        .containsExactly(cachedKey, cachedValue);\n   }\n \n   public void testInvalidateAll() {\n@@ -99,23 +97,23 @@ public void invalidate(Object key) {\n \n     List<Integer> toInvalidate = ImmutableList.of(1, 2, 3, 4);\n     cache.invalidateAll(toInvalidate);\n-    assertEquals(toInvalidate, invalidated);\n+    assertThat(invalidated).isEqualTo(toInvalidate);\n   }\n \n   public void testEmptySimpleStats() {\n     StatsCounter counter = new SimpleStatsCounter();\n     CacheStats stats = counter.snapshot();\n-    assertEquals(0, stats.requestCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n     assertThat(stats.hitRate()).isEqualTo(1.0);\n-    assertEquals(0, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n     assertThat(stats.missRate()).isEqualTo(0.0);\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.loadCount());\n-    assertEquals(0, stats.totalLoadTime());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.loadCount()).isEqualTo(0);\n+    assertThat(stats.totalLoadTime()).isEqualTo(0);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n   }\n \n   public void testSingleSimpleStats() {\n@@ -137,26 +135,26 @@ public void testSingleSimpleStats() {\n     }\n     CacheStats stats = counter.snapshot();\n     int requestCount = 11 + 23;\n-    assertEquals(requestCount, stats.requestCount());\n-    assertEquals(11, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(requestCount);\n+    assertThat(stats.hitCount()).isEqualTo(11);\n     assertThat(stats.hitRate()).isEqualTo(11.0 / requestCount);\n     int missCount = 23;\n-    assertEquals(missCount, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(missCount);\n     assertThat(stats.missRate()).isEqualTo(((double) missCount) / requestCount);\n-    assertEquals(13, stats.loadSuccessCount());\n-    assertEquals(17, stats.loadExceptionCount());\n-    assertEquals(13 + 17, stats.loadCount());\n-    assertEquals(214, stats.totalLoadTime());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(13);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(17);\n+    assertThat(stats.loadCount()).isEqualTo(13 + 17);\n+    assertThat(stats.totalLoadTime()).isEqualTo(214);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(214.0 / (13 + 17));\n-    assertEquals(27, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(27);\n   }\n \n   public void testSimpleStatsOverflow() {\n     StatsCounter counter = new SimpleStatsCounter();\n     counter.recordLoadSuccess(Long.MAX_VALUE);\n     counter.recordLoadSuccess(1);\n     CacheStats stats = counter.snapshot();\n-    assertEquals(Long.MAX_VALUE, stats.totalLoadTime());\n+    assertThat(stats.totalLoadTime()).isEqualTo(Long.MAX_VALUE);\n   }\n \n   public void testSimpleStatsIncrementBy() {\n@@ -201,6 +199,6 @@ public void testSimpleStatsIncrementBy() {\n     }\n \n     counter1.incrementBy(counter2);\n-    assertEquals(new CacheStats(38, 60, 44, 54, totalLoadTime, 66), counter1.snapshot());\n+    assertThat(counter1.snapshot()).isEqualTo(new CacheStats(38, 60, 44, 54, totalLoadTime, 66));\n   }\n }"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "patch": "@@ -61,7 +61,7 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetUnchecked_unchecked() {\n@@ -90,7 +90,7 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetUnchecked_error() {\n@@ -119,7 +119,7 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetUnchecked_otherThrowable() {\n@@ -148,6 +148,6 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n }"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java",
      "status": "modified",
      "additions": 146,
      "deletions": 119,
      "changes": 265,
      "patch": "@@ -16,6 +16,7 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n \n import com.google.common.annotations.GwtCompatible;\n@@ -31,8 +32,11 @@\n import java.util.concurrent.Callable;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ExecutionException;\n-import junit.framework.TestCase;\n import org.jspecify.annotations.NullUnmarked;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n \n /**\n  * Test suite for {@link CacheBuilder}. TODO(cpovirk): merge into CacheBuilderTest?\n@@ -41,18 +45,18 @@\n  */\n @GwtCompatible\n @NullUnmarked\n-public class CacheBuilderGwtTest extends TestCase {\n+@RunWith(JUnit4.class)\n+public class CacheBuilderGwtTest {\n \n   private FakeTicker fakeTicker;\n \n-  @Override\n-  protected void setUp() throws Exception {\n-    super.setUp();\n-\n+  @Before\n+  public void setUp() {\n     fakeTicker = new FakeTicker();\n   }\n \n-  public void testLoader() throws ExecutionException {\n+  @Test\n+  public void loader() throws ExecutionException {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     Callable<Integer> loader =\n@@ -67,19 +71,20 @@ public Integer call() throws Exception {\n \n     cache.put(0, 10);\n \n-    assertEquals(Integer.valueOf(10), cache.get(0, loader));\n-    assertEquals(Integer.valueOf(1), cache.get(20, loader));\n-    assertEquals(Integer.valueOf(2), cache.get(34, loader));\n+    assertThat(cache.get(0, loader)).isEqualTo(10);\n+    assertThat(cache.get(20, loader)).isEqualTo(1);\n+    assertThat(cache.get(34, loader)).isEqualTo(2);\n \n     cache.invalidate(0);\n-    assertEquals(Integer.valueOf(3), cache.get(0, loader));\n+    assertThat(cache.get(0, loader)).isEqualTo(3);\n \n     cache.put(0, 10);\n     cache.invalidateAll();\n-    assertEquals(Integer.valueOf(4), cache.get(0, loader));\n+    assertThat(cache.get(0, loader)).isEqualTo(4);\n   }\n \n-  public void testSizeConstraint() {\n+  @Test\n+  public void sizeConstraint() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().maximumSize(4).build();\n \n     cache.put(1, 10);\n@@ -88,22 +93,24 @@ public void testSizeConstraint() {\n     cache.put(4, 40);\n     cache.put(5, 50);\n \n-    assertEquals(null, cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isNull();\n     // Order required to remove dependence on access order / write order constraint.\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));\n-    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(3)).isEqualTo(30);\n+    assertThat(cache.getIfPresent(4)).isEqualTo(40);\n+    assertThat(cache.getIfPresent(5)).isEqualTo(50);\n \n     cache.put(1, 10);\n-    assertEquals(Integer.valueOf(10), cache.getIfPresent(1));\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));\n-    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));\n-    assertEquals(null, cache.getIfPresent(2));\n+    assertThat(cache.getIfPresent(1)).isEqualTo(10);\n+    assertThat(cache.getIfPresent(3)).isEqualTo(30);\n+    assertThat(cache.getIfPresent(4)).isEqualTo(40);\n+    assertThat(cache.getIfPresent(5)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(2)).isNull();\n   }\n \n-  public void testLoadingCache() throws ExecutionException {\n+  @SuppressWarnings({\"deprecation\", \"LoadingCacheApply\"})\n+  @Test\n+  public void loadingCache() throws ExecutionException {\n     CacheLoader<Integer, Integer> loader =\n         new CacheLoader<Integer, Integer>() {\n           int i = 0;\n@@ -120,32 +127,34 @@ public Integer load(Integer key) throws Exception {\n \n     Map<Integer, Integer> map = cache.getAll(ImmutableList.of(10, 20, 30, 54, 443, 1));\n \n-    assertEquals(Integer.valueOf(20), map.get(10));\n-    assertEquals(Integer.valueOf(0), map.get(20));\n-    assertEquals(Integer.valueOf(1), map.get(30));\n-    assertEquals(Integer.valueOf(2), map.get(54));\n-    assertEquals(Integer.valueOf(3), map.get(443));\n-    assertEquals(Integer.valueOf(4), map.get(1));\n-    assertEquals(Integer.valueOf(5), cache.get(6));\n-    assertEquals(Integer.valueOf(6), cache.apply(7));\n+    assertThat(map).containsEntry(10, 20);\n+    assertThat(map).containsEntry(20, 0);\n+    assertThat(map).containsEntry(30, 1);\n+    assertThat(map).containsEntry(54, 2);\n+    assertThat(map).containsEntry(443, 3);\n+    assertThat(map).containsEntry(1, 4);\n+    assertThat(cache.get(6)).isEqualTo(5);\n+    assertThat(cache.apply(7)).isEqualTo(6);\n   }\n \n-  public void testExpireAfterAccess() {\n+  @Test\n+  public void expireAfterAccess() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterAccess(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n     cache.put(0, 10);\n     cache.put(2, 30);\n \n     fakeTicker.advance(999, MILLISECONDS);\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(30);\n     fakeTicker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(30);\n     fakeTicker.advance(1000, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(0));\n+    assertThat(cache.getIfPresent(0)).isNull();\n   }\n \n-  public void testExpireAfterWrite() {\n+  @Test\n+  public void expireAfterWrite() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -154,23 +163,24 @@ public void testExpireAfterWrite() {\n     cache.put(4, 2);\n \n     fakeTicker.advance(999, MILLISECONDS);\n-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));\n-    assertEquals(Integer.valueOf(2), cache.getIfPresent(4));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(100);\n+    assertThat(cache.getIfPresent(20)).isEqualTo(200);\n+    assertThat(cache.getIfPresent(4)).isEqualTo(2);\n \n     fakeTicker.advance(2, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n-    assertEquals(null, cache.getIfPresent(20));\n-    assertEquals(null, cache.getIfPresent(4));\n+    assertThat(cache.getIfPresent(10)).isNull();\n+    assertThat(cache.getIfPresent(20)).isNull();\n+    assertThat(cache.getIfPresent(4)).isNull();\n \n     cache.put(10, 20);\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(20);\n \n     fakeTicker.advance(1000, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isNull();\n   }\n \n-  public void testExpireAfterWriteAndAccess() {\n+  @Test\n+  public void expireAfterWriteAndAccess() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder()\n             .expireAfterWrite(1000, MILLISECONDS)\n@@ -183,26 +193,28 @@ public void testExpireAfterWriteAndAccess() {\n     cache.put(4, 2);\n \n     fakeTicker.advance(499, MILLISECONDS);\n-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(100);\n+    assertThat(cache.getIfPresent(20)).isEqualTo(200);\n \n     fakeTicker.advance(2, MILLISECONDS);\n-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));\n-    assertEquals(null, cache.getIfPresent(4));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(100);\n+    assertThat(cache.getIfPresent(20)).isEqualTo(200);\n+    assertThat(cache.getIfPresent(4)).isNull();\n \n     fakeTicker.advance(499, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n-    assertEquals(null, cache.getIfPresent(20));\n+    assertThat(cache.getIfPresent(10)).isNull();\n+    assertThat(cache.getIfPresent(20)).isNull();\n \n     cache.put(10, 20);\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(20);\n \n     fakeTicker.advance(500, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isNull();\n   }\n \n-  public void testMapMethods() {\n+  @SuppressWarnings(\"ContainsEntryAfterGetInteger\") // we are testing our implementation of Map.get\n+  @Test\n+  public void mapMethods() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     ConcurrentMap<Integer, Integer> asMap = cache.asMap();\n@@ -213,38 +225,39 @@ public void testMapMethods() {\n     asMap.replace(2, 79);\n     asMap.replace(3, 60);\n \n-    assertEquals(null, cache.getIfPresent(3));\n-    assertEquals(null, asMap.get(3));\n+    assertThat(cache.getIfPresent(3)).isNull();\n+    assertThat(asMap.get(3)).isNull();\n \n-    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(79), asMap.get(2));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(79);\n+    assertThat(asMap.get(2)).isEqualTo(79);\n \n     asMap.replace(10, 100, 50);\n     asMap.replace(2, 52, 99);\n \n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), asMap.get(10));\n-    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(79), asMap.get(2));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(asMap.get(10)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(2)).isEqualTo(79);\n+    assertThat(asMap.get(2)).isEqualTo(79);\n \n     asMap.remove(10, 100);\n     asMap.remove(2, 79);\n \n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), asMap.get(10));\n-    assertEquals(null, cache.getIfPresent(2));\n-    assertEquals(null, asMap.get(2));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(asMap.get(10)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(2)).isNull();\n+    assertThat(asMap.get(2)).isNull();\n \n     asMap.putIfAbsent(2, 20);\n     asMap.putIfAbsent(10, 20);\n \n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(20), asMap.get(2));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), asMap.get(10));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(20);\n+    assertThat(asMap.get(2)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(asMap.get(10)).isEqualTo(50);\n   }\n \n-  public void testRemovalListener() {\n+  @Test\n+  public void removalListener() {\n     int[] stats = new int[4];\n \n     RemovalListener<Integer, Integer> countingListener =\n@@ -303,30 +316,32 @@ public void onRemoval(RemovalNotification<Integer, Integer> notification) {\n \n     cache.invalidateAll();\n \n-    assertEquals(2, stats[0]);\n-    assertEquals(2, stats[1]);\n-    assertEquals(4, stats[2]);\n-    assertEquals(3, stats[3]);\n+    assertThat(stats[0]).isEqualTo(2);\n+    assertThat(stats[1]).isEqualTo(2);\n+    assertThat(stats[2]).isEqualTo(4);\n+    assertThat(stats[3]).isEqualTo(3);\n   }\n \n-  public void testPutAll() {\n+  @Test\n+  public void putAll() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     cache.putAll(ImmutableMap.of(10, 20, 30, 50, 60, 90));\n \n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(30));\n-    assertEquals(Integer.valueOf(90), cache.getIfPresent(60));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(30)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(60)).isEqualTo(90);\n \n     cache.asMap().putAll(ImmutableMap.of(10, 50, 30, 20, 60, 70, 5, 5));\n \n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(30));\n-    assertEquals(Integer.valueOf(70), cache.getIfPresent(60));\n-    assertEquals(Integer.valueOf(5), cache.getIfPresent(5));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(30)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(60)).isEqualTo(70);\n+    assertThat(cache.getIfPresent(5)).isEqualTo(5);\n   }\n \n-  public void testInvalidate() {\n+  @Test\n+  public void invalidate() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     cache.put(654, 2675);\n@@ -335,22 +350,23 @@ public void testInvalidate() {\n \n     cache.invalidate(654);\n \n-    assertFalse(cache.asMap().containsKey(654));\n-    assertTrue(cache.asMap().containsKey(2456));\n-    assertTrue(cache.asMap().containsKey(2));\n+    assertThat(cache.asMap().containsKey(654)).isFalse();\n+    assertThat(cache.asMap().containsKey(2456)).isTrue();\n+    assertThat(cache.asMap().containsKey(2)).isTrue();\n   }\n \n-  public void testInvalidateAll() {\n+  @Test\n+  public void invalidateAll() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     cache.put(654, 2675);\n     cache.put(2456, 56);\n     cache.put(2, 15);\n \n     cache.invalidateAll();\n-    assertFalse(cache.asMap().containsKey(654));\n-    assertFalse(cache.asMap().containsKey(2456));\n-    assertFalse(cache.asMap().containsKey(2));\n+    assertThat(cache.asMap().containsKey(654)).isFalse();\n+    assertThat(cache.asMap().containsKey(2456)).isFalse();\n+    assertThat(cache.asMap().containsKey(2)).isFalse();\n \n     cache.put(654, 2675);\n     cache.put(2456, 56);\n@@ -359,13 +375,14 @@ public void testInvalidateAll() {\n \n     cache.invalidateAll(ImmutableSet.of(1, 2));\n \n-    assertFalse(cache.asMap().containsKey(1));\n-    assertFalse(cache.asMap().containsKey(2));\n-    assertTrue(cache.asMap().containsKey(654));\n-    assertTrue(cache.asMap().containsKey(2456));\n+    assertThat(cache.asMap().containsKey(1)).isFalse();\n+    assertThat(cache.asMap().containsKey(2)).isFalse();\n+    assertThat(cache.asMap().containsKey(654)).isTrue();\n+    assertThat(cache.asMap().containsKey(2456)).isTrue();\n   }\n \n-  public void testAsMap_containsValue() {\n+  @Test\n+  public void asMap_containsValue() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(20000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -376,12 +393,15 @@ public void testAsMap_containsValue() {\n \n     fakeTicker.advance(10001, MILLISECONDS);\n \n-    assertTrue(cache.asMap().containsValue(15));\n-    assertTrue(cache.asMap().containsValue(56));\n-    assertFalse(cache.asMap().containsValue(2675));\n+    assertThat(cache.asMap().containsValue(15)).isTrue();\n+    assertThat(cache.asMap().containsValue(56)).isTrue();\n+    assertThat(cache.asMap().containsValue(2675)).isFalse();\n   }\n \n-  public void testAsMap_containsKey() {\n+  // we are testing our implementation of Map.containsKey\n+  @SuppressWarnings(\"ContainsEntryAfterGetInteger\")\n+  @Test\n+  public void asMap_containsKey() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(20000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -392,12 +412,15 @@ public void testAsMap_containsKey() {\n \n     fakeTicker.advance(10001, MILLISECONDS);\n \n-    assertTrue(cache.asMap().containsKey(2));\n-    assertTrue(cache.asMap().containsKey(2456));\n-    assertFalse(cache.asMap().containsKey(654));\n+    assertThat(cache.asMap().containsKey(2)).isTrue();\n+    assertThat(cache.asMap().containsKey(2456)).isTrue();\n+    assertThat(cache.asMap().containsKey(654)).isFalse();\n   }\n \n-  public void testAsMapValues_contains() {\n+  // we are testing our implementation of Map.values().contains\n+  @SuppressWarnings(\"ValuesContainsValue\")\n+  @Test\n+  public void asMapValues_contains() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -408,12 +431,13 @@ public void testAsMapValues_contains() {\n \n     fakeTicker.advance(501, MILLISECONDS);\n \n-    assertTrue(cache.asMap().values().contains(22));\n-    assertTrue(cache.asMap().values().contains(10));\n-    assertFalse(cache.asMap().values().contains(20));\n+    assertThat(cache.asMap().values().contains(22)).isTrue();\n+    assertThat(cache.asMap().values().contains(10)).isTrue();\n+    assertThat(cache.asMap().values().contains(20)).isFalse();\n   }\n \n-  public void testAsMapKeySet() {\n+  @Test\n+  public void asMapKeySet() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -426,10 +450,11 @@ public void testAsMapKeySet() {\n \n     Set<Integer> foundKeys = new HashSet<>(cache.asMap().keySet());\n \n-    assertEquals(ImmutableSet.of(20, 5), foundKeys);\n+    assertThat(foundKeys).containsExactly(20, 5);\n   }\n \n-  public void testAsMapKeySet_contains() {\n+  @Test\n+  public void asMapKeySet_contains() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -440,12 +465,13 @@ public void testAsMapKeySet_contains() {\n \n     fakeTicker.advance(501, MILLISECONDS);\n \n-    assertTrue(cache.asMap().keySet().contains(20));\n-    assertTrue(cache.asMap().keySet().contains(5));\n-    assertFalse(cache.asMap().keySet().contains(10));\n+    assertThat(cache.asMap().keySet().contains(20)).isTrue();\n+    assertThat(cache.asMap().keySet().contains(5)).isTrue();\n+    assertThat(cache.asMap().keySet().contains(10)).isFalse();\n   }\n \n-  public void testAsMapEntrySet() {\n+  @Test\n+  public void asMapEntrySet() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -460,10 +486,11 @@ public void testAsMapEntrySet() {\n     for (Entry<Integer, Integer> current : cache.asMap().entrySet()) {\n       sum += current.getKey() + current.getValue();\n     }\n-    assertEquals(57, sum);\n+    assertThat(sum).isEqualTo(57);\n   }\n \n-  public void testAsMapValues_iteratorRemove() {\n+  @Test\n+  public void asMapValues_iteratorRemove() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -472,6 +499,6 @@ public void testAsMapValues_iteratorRemove() {\n     iterator.next();\n     iterator.remove();\n \n-    assertEquals(0, cache.size());\n+    assertThat(cache.size()).isEqualTo(0);\n   }\n }"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java",
      "status": "modified",
      "additions": 157,
      "deletions": 136,
      "changes": 293,
      "patch": "@@ -18,6 +18,8 @@\n \n import static com.google.common.cache.CacheBuilderSpec.parse;\n import static com.google.common.cache.TestingWeighers.constantWeigher;\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.util.concurrent.TimeUnit.DAYS;\n import static java.util.concurrent.TimeUnit.HOURS;\n import static java.util.concurrent.TimeUnit.MINUTES;\n@@ -40,27 +42,27 @@\n public class CacheBuilderSpecTest extends TestCase {\n   public void testParse_empty() {\n     CacheBuilderSpec spec = parse(\"\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder(), CacheBuilder.from(spec));\n   }\n \n   public void testParse_initialCapacity() {\n     CacheBuilderSpec spec = parse(\"initialCapacity=10\");\n-    assertEquals(10, spec.initialCapacity.intValue());\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isEqualTo(10);\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().initialCapacity(10), CacheBuilder.from(spec));\n   }\n@@ -72,13 +74,13 @@ public void testParse_initialCapacityRepeated() {\n \n   public void testParse_maximumSize() {\n     CacheBuilderSpec spec = parse(\"maximumSize=9000\");\n-    assertNull(spec.initialCapacity);\n-    assertEquals(9000, spec.maximumSize.longValue());\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isEqualTo(9000L);\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().maximumSize(9000), CacheBuilder.from(spec));\n   }\n@@ -89,13 +91,13 @@ public void testParse_maximumSizeRepeated() {\n \n   public void testParse_maximumWeight() {\n     CacheBuilderSpec spec = parse(\"maximumWeight=9000\");\n-    assertNull(spec.initialCapacity);\n-    assertEquals(9000, spec.maximumWeight.longValue());\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumWeight).isEqualTo(9000L);\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().maximumWeight(9000), CacheBuilder.from(spec));\n   }\n@@ -110,14 +112,14 @@ public void testParse_maximumSizeAndMaximumWeight() {\n \n   public void testParse_concurrencyLevel() {\n     CacheBuilderSpec spec = parse(\"concurrencyLevel=32\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertEquals(32, spec.concurrencyLevel.intValue());\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isEqualTo(32);\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().concurrencyLevel(32), CacheBuilder.from(spec));\n   }\n@@ -129,14 +131,14 @@ public void testParse_concurrencyLevelRepeated() {\n \n   public void testParse_weakKeys() {\n     CacheBuilderSpec spec = parse(\"weakKeys\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertEquals(Strength.WEAK, spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().weakKeys(), CacheBuilder.from(spec));\n   }\n \n@@ -150,14 +152,14 @@ public void testParse_repeatedKeyStrength() {\n \n   public void testParse_softValues() {\n     CacheBuilderSpec spec = parse(\"softValues\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertEquals(Strength.SOFT, spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isEqualTo(Strength.SOFT);\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().softValues(), CacheBuilder.from(spec));\n   }\n \n@@ -167,14 +169,14 @@ public void testParse_softValuesCannotHaveValue() {\n \n   public void testParse_weakValues() {\n     CacheBuilderSpec spec = parse(\"weakValues\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertEquals(Strength.WEAK, spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().weakValues(), CacheBuilder.from(spec));\n   }\n \n@@ -194,39 +196,39 @@ public void testParse_repeatedValueStrength() {\n \n   public void testParse_writeExpirationDays() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=10d\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertEquals(DAYS, spec.writeExpirationTimeUnit);\n-    assertEquals(10L, spec.writeExpirationDuration);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(DAYS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(10L, DAYS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_writeExpirationHours() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=150h\");\n-    assertEquals(HOURS, spec.writeExpirationTimeUnit);\n-    assertEquals(150L, spec.writeExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(HOURS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(150L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(150L, HOURS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_writeExpirationMinutes() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=10m\");\n-    assertEquals(MINUTES, spec.writeExpirationTimeUnit);\n-    assertEquals(10L, spec.writeExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(10L, MINUTES), CacheBuilder.from(spec));\n   }\n \n   public void testParse_writeExpirationSeconds() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=10s\");\n-    assertEquals(SECONDS, spec.writeExpirationTimeUnit);\n-    assertEquals(10L, spec.writeExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(10L, SECONDS), CacheBuilder.from(spec));\n   }\n@@ -238,39 +240,39 @@ public void testParse_writeExpirationRepeated() {\n \n   public void testParse_accessExpirationDays() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10d\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertEquals(DAYS, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(DAYS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, DAYS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_accessExpirationHours() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=150h\");\n-    assertEquals(HOURS, spec.accessExpirationTimeUnit);\n-    assertEquals(150L, spec.accessExpirationDuration);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(HOURS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(150L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(150L, HOURS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_accessExpirationMinutes() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10m\");\n-    assertEquals(MINUTES, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, MINUTES), CacheBuilder.from(spec));\n   }\n \n   public void testParse_accessExpirationSeconds() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10s\");\n-    assertEquals(SECONDS, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, SECONDS), CacheBuilder.from(spec));\n   }\n@@ -282,7 +284,7 @@ public void testParse_accessExpirationRepeated() {\n \n   public void testParse_recordStats() {\n     CacheBuilderSpec spec = parse(\"recordStats\");\n-    assertTrue(spec.recordStats);\n+    assertThat(spec.recordStats).isTrue();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().recordStats(), CacheBuilder.from(spec));\n   }\n \n@@ -296,10 +298,10 @@ public void testParse_recordStatsRepeated() {\n \n   public void testParse_accessExpirationAndWriteExpiration() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10s,expireAfterWrite=9m\");\n-    assertEquals(MINUTES, spec.writeExpirationTimeUnit);\n-    assertEquals(9L, spec.writeExpirationDuration);\n-    assertEquals(SECONDS, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(9L);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, SECONDS).expireAfterWrite(9L, MINUTES),\n         CacheBuilder.from(spec));\n@@ -310,16 +312,16 @@ public void testParse_multipleKeys() {\n         parse(\n             \"initialCapacity=10,maximumSize=20,concurrencyLevel=30,\"\n                 + \"weakKeys,weakValues,expireAfterAccess=10m,expireAfterWrite=1h\");\n-    assertEquals(10, spec.initialCapacity.intValue());\n-    assertEquals(20, spec.maximumSize.intValue());\n-    assertNull(spec.maximumWeight);\n-    assertEquals(30, spec.concurrencyLevel.intValue());\n-    assertEquals(Strength.WEAK, spec.keyStrength);\n-    assertEquals(Strength.WEAK, spec.valueStrength);\n-    assertEquals(HOURS, spec.writeExpirationTimeUnit);\n-    assertEquals(MINUTES, spec.accessExpirationTimeUnit);\n-    assertEquals(1L, spec.writeExpirationDuration);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.initialCapacity).isEqualTo(10);\n+    assertThat(spec.maximumSize).isEqualTo(20);\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isEqualTo(30);\n+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.valueStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(HOURS);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(1L);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     CacheBuilder<?, ?> expected =\n         CacheBuilder.newBuilder()\n             .initialCapacity(10)\n@@ -337,15 +339,15 @@ public void testParse_whitespaceAllowed() {\n         parse(\n             \" initialCapacity=10,\\nmaximumSize=20,\\t\\r\"\n                 + \"weakKeys \\t ,softValues \\n , \\r  expireAfterWrite \\t =  15s\\n\\n\");\n-    assertEquals(10, spec.initialCapacity.intValue());\n-    assertEquals(20, spec.maximumSize.intValue());\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertEquals(Strength.WEAK, spec.keyStrength);\n-    assertEquals(Strength.SOFT, spec.valueStrength);\n-    assertEquals(SECONDS, spec.writeExpirationTimeUnit);\n-    assertEquals(15L, spec.writeExpirationDuration);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isEqualTo(10);\n+    assertThat(spec.maximumSize).isEqualTo(20);\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.valueStrength).isEqualTo(Strength.SOFT);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(15L);\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     CacheBuilder<?, ?> expected =\n         CacheBuilder.newBuilder()\n             .initialCapacity(10)\n@@ -424,9 +426,9 @@ public void testDisableCaching() {\n     Object value = new Object();\n     LoadingCache<Object, Object> cache =\n         builder.build(CacheLoader.from(Suppliers.ofInstance(value)));\n-    assertSame(value, cache.getUnchecked(key));\n-    assertEquals(0, cache.size());\n-    assertFalse(cache.asMap().containsKey(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);\n+    assertThat(cache.size()).isEqualTo(0);\n+    assertThat(cache.asMap().containsKey(key)).isFalse();\n   }\n \n   public void testCacheBuilderFrom_string() {\n@@ -445,22 +447,41 @@ public void testCacheBuilderFrom_string() {\n     assertCacheBuilderEquivalence(expected, fromString);\n   }\n \n-  private static void assertCacheBuilderEquivalence(CacheBuilder<?, ?> a, CacheBuilder<?, ?> b) {\n-    assertEquals(\"concurrencyLevel\", a.concurrencyLevel, b.concurrencyLevel);\n-    assertEquals(\"expireAfterAccessNanos\", a.expireAfterAccessNanos, b.expireAfterAccessNanos);\n-    assertEquals(\"expireAfterWriteNanos\", a.expireAfterWriteNanos, b.expireAfterWriteNanos);\n-    assertEquals(\"initialCapacity\", a.initialCapacity, b.initialCapacity);\n-    assertEquals(\"maximumSize\", a.maximumSize, b.maximumSize);\n-    assertEquals(\"maximumWeight\", a.maximumWeight, b.maximumWeight);\n-    assertEquals(\"refreshNanos\", a.refreshNanos, b.refreshNanos);\n-    assertEquals(\"keyEquivalence\", a.keyEquivalence, b.keyEquivalence);\n-    assertEquals(\"keyStrength\", a.keyStrength, b.keyStrength);\n-    assertEquals(\"removalListener\", a.removalListener, b.removalListener);\n-    assertEquals(\"weigher\", a.weigher, b.weigher);\n-    assertEquals(\"valueEquivalence\", a.valueEquivalence, b.valueEquivalence);\n-    assertEquals(\"valueStrength\", a.valueStrength, b.valueStrength);\n-    assertEquals(\"statsCounterSupplier\", a.statsCounterSupplier, b.statsCounterSupplier);\n-    assertEquals(\"ticker\", a.ticker, b.ticker);\n-    assertEquals(\"recordStats\", a.isRecordingStats(), b.isRecordingStats());\n+  private static void assertCacheBuilderEquivalence(\n+      CacheBuilder<?, ?> expected, CacheBuilder<?, ?> actual) {\n+    assertWithMessage(\"concurrencyLevel\")\n+        .that(actual.concurrencyLevel)\n+        .isEqualTo(expected.concurrencyLevel);\n+    assertWithMessage(\"expireAfterAccessNanos\")\n+        .that(actual.expireAfterAccessNanos)\n+        .isEqualTo(expected.expireAfterAccessNanos);\n+    assertWithMessage(\"expireAfterWriteNanos\")\n+        .that(actual.expireAfterWriteNanos)\n+        .isEqualTo(expected.expireAfterWriteNanos);\n+    assertWithMessage(\"initialCapacity\")\n+        .that(actual.initialCapacity)\n+        .isEqualTo(expected.initialCapacity);\n+    assertWithMessage(\"maximumSize\").that(actual.maximumSize).isEqualTo(expected.maximumSize);\n+    assertWithMessage(\"maximumWeight\").that(actual.maximumWeight).isEqualTo(expected.maximumWeight);\n+    assertWithMessage(\"refreshNanos\").that(actual.refreshNanos).isEqualTo(expected.refreshNanos);\n+    assertWithMessage(\"keyEquivalence\")\n+        .that(actual.keyEquivalence)\n+        .isEqualTo(expected.keyEquivalence);\n+    assertWithMessage(\"keyStrength\").that(actual.keyStrength).isEqualTo(expected.keyStrength);\n+    assertWithMessage(\"removalListener\")\n+        .that(actual.removalListener)\n+        .isEqualTo(expected.removalListener);\n+    assertWithMessage(\"weigher\").that(actual.weigher).isEqualTo(expected.weigher);\n+    assertWithMessage(\"valueEquivalence\")\n+        .that(actual.valueEquivalence)\n+        .isEqualTo(expected.valueEquivalence);\n+    assertWithMessage(\"valueStrength\").that(actual.valueStrength).isEqualTo(expected.valueStrength);\n+    assertWithMessage(\"statsCounterSupplier\")\n+        .that(actual.statsCounterSupplier)\n+        .isEqualTo(expected.statsCounterSupplier);\n+    assertWithMessage(\"ticker\").that(actual.ticker).isEqualTo(expected.ticker);\n+    assertWithMessage(\"recordStats\")\n+        .that(actual.isRecordingStats())\n+        .isEqualTo(expected.isRecordingStats());\n   }\n }"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/CacheBuilderTest.java",
      "status": "modified",
      "additions": 36,
      "deletions": 33,
      "changes": 69,
      "patch": "@@ -24,6 +24,7 @@\n import static com.google.common.cache.TestingRemovalListeners.queuingRemovalListener;\n import static com.google.common.cache.TestingWeighers.constantWeigher;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.util.concurrent.Executors.newFixedThreadPool;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n@@ -63,8 +64,8 @@ public void testNewBuilder() {\n     LoadingCache<String, Integer> cache =\n         CacheBuilder.newBuilder().removalListener(countingRemovalListener()).build(loader);\n \n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(\"one\"));\n-    assertEquals(1, cache.size());\n+    assertThat(cache.getUnchecked(\"one\")).isEqualTo(1);\n+    assertThat(cache.size()).isEqualTo(1);\n   }\n \n   public void testInitialCapacity_negative() {\n@@ -83,10 +84,10 @@ public void testInitialCapacity_small() {\n     LocalCache<?, ?> map = CacheTesting.toLocalCache(cache);\n \n     assertThat(map.segments).hasLength(4);\n-    assertEquals(2, map.segments[0].table.length());\n-    assertEquals(2, map.segments[1].table.length());\n-    assertEquals(2, map.segments[2].table.length());\n-    assertEquals(2, map.segments[3].table.length());\n+    assertThat(map.segments[0].table.length()).isEqualTo(2);\n+    assertThat(map.segments[1].table.length()).isEqualTo(2);\n+    assertThat(map.segments[2].table.length()).isEqualTo(2);\n+    assertThat(map.segments[3].table.length()).isEqualTo(2);\n   }\n \n   @GwtIncompatible // CacheTesting\n@@ -96,10 +97,10 @@ public void testInitialCapacity_smallest() {\n \n     assertThat(map.segments).hasLength(4);\n     // 1 is as low as it goes, not 0. it feels dirty to know this/test this.\n-    assertEquals(1, map.segments[0].table.length());\n-    assertEquals(1, map.segments[1].table.length());\n-    assertEquals(1, map.segments[2].table.length());\n-    assertEquals(1, map.segments[3].table.length());\n+    assertThat(map.segments[0].table.length()).isEqualTo(1);\n+    assertThat(map.segments[1].table.length()).isEqualTo(1);\n+    assertThat(map.segments[2].table.length()).isEqualTo(1);\n+    assertThat(map.segments[3].table.length()).isEqualTo(1);\n   }\n \n   public void testInitialCapacity_large() {\n@@ -328,19 +329,19 @@ public void testRemovalListener_setTwice() {\n   }\n \n   public void testValuesIsNotASet() {\n-    assertFalse(CacheBuilder.newBuilder().build().asMap().values() instanceof Set);\n+    assertThat(CacheBuilder.newBuilder().build().asMap().values() instanceof Set).isFalse();\n   }\n \n   @GwtIncompatible // CacheTesting\n   public void testNullCache() {\n     CountingRemovalListener<Object, Object> listener = countingRemovalListener();\n     LoadingCache<Object, Object> nullCache =\n         CacheBuilder.newBuilder().maximumSize(0).removalListener(listener).build(identityLoader());\n-    assertEquals(0, nullCache.size());\n+    assertThat(nullCache.size()).isEqualTo(0);\n     Object key = new Object();\n-    assertSame(key, nullCache.getUnchecked(key));\n-    assertEquals(1, listener.getCount());\n-    assertEquals(0, nullCache.size());\n+    assertThat(nullCache.getUnchecked(key)).isSameInstanceAs(key);\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(nullCache.size()).isEqualTo(0);\n     CacheTesting.checkEmpty(nullCache.asMap());\n   }\n \n@@ -397,12 +398,12 @@ public void run() {\n     // At this point, the listener should be holding the seed value (a -> a), and the map should\n     // contain the computed value (b -> b), since the clear() happened before the computation\n     // completed.\n-    assertEquals(1, listener.size());\n+    assertThat(listener).hasSize(1);\n     RemovalNotification<String, String> notification = listener.remove();\n-    assertEquals(\"a\", notification.getKey());\n-    assertEquals(\"a\", notification.getValue());\n-    assertEquals(1, cache.size());\n-    assertEquals(\"b\", cache.getUnchecked(\"b\"));\n+    assertThat(notification.getKey()).isEqualTo(\"a\");\n+    assertThat(notification.getValue()).isEqualTo(\"a\");\n+    assertThat(cache.size()).isEqualTo(1);\n+    assertThat(cache.getUnchecked(\"b\")).isEqualTo(\"b\");\n   }\n \n   // \"Basher tests\", where we throw a bunch of stuff at a LoadingCache and check basic invariants.\n@@ -477,22 +478,22 @@ public void run() {\n     Map<String, String> removalNotifications = new HashMap<>();\n     for (RemovalNotification<String, String> notification : listener) {\n       removalNotifications.put(notification.getKey(), notification.getValue());\n-      assertEquals(\n-          \"Unexpected key/value pair passed to removalListener\",\n-          notification.getKey(),\n-          notification.getValue());\n+      assertWithMessage(\"Unexpected key/value pair passed to removalListener\")\n+          .that(notification.getValue())\n+          .isEqualTo(notification.getKey());\n     }\n \n     // All of the seed values should have been visible, so we should have gotten removal\n     // notifications for all of them.\n     for (int i = 0; i < nSeededEntries; i++) {\n-      assertEquals(\"b\" + i, removalNotifications.get(\"b\" + i));\n+      assertThat(removalNotifications.get(\"b\" + i)).isEqualTo(\"b\" + i);\n     }\n \n     // Each of the values added to the map should either still be there, or have seen a removal\n     // notification.\n-    assertEquals(expectedKeys, Sets.union(cache.asMap().keySet(), removalNotifications.keySet()));\n-    assertTrue(Sets.intersection(cache.asMap().keySet(), removalNotifications.keySet()).isEmpty());\n+    assertThat(Sets.union(cache.asMap().keySet(), removalNotifications.keySet()))\n+        .isEqualTo(expectedKeys);\n+    assertThat(cache.asMap().keySet()).containsNoneIn(removalNotifications.keySet());\n     threadPool.shutdown();\n     threadPool.awaitTermination(300, SECONDS);\n   }\n@@ -571,15 +572,17 @@ public void run() {\n \n     // Verify that each received removal notification was valid\n     for (RemovalNotification<String, String> notification : removalListener) {\n-      assertEquals(\"Invalid removal notification\", notification.getKey(), notification.getValue());\n+      assertWithMessage(\"Invalid removal notification\")\n+          .that(notification.getValue())\n+          .isEqualTo(notification.getKey());\n     }\n \n     CacheStats stats = cache.stats();\n-    assertEquals(removalListener.size(), stats.evictionCount());\n-    assertEquals(computeCount.get(), stats.loadSuccessCount());\n-    assertEquals(exceptionCount.get() + computeNullCount.get(), stats.loadExceptionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(removalListener.size());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(computeCount.get());\n+    assertThat(stats.loadExceptionCount()).isEqualTo(exceptionCount.get() + computeNullCount.get());\n     // each computed value is still in the cache, or was passed to the removal listener\n-    assertEquals(computeCount.get(), cache.size() + removalListener.size());\n+    assertThat(cache.size() + removalListener.size()).isEqualTo(computeCount.get());\n   }\n \n   @GwtIncompatible // NullPointerTester\n@@ -594,7 +597,7 @@ public void testSizingDefaults() {\n     LoadingCache<?, ?> cache = CacheBuilder.newBuilder().build(identityLoader());\n     LocalCache<?, ?> map = CacheTesting.toLocalCache(cache);\n     assertThat(map.segments).hasLength(4); // concurrency level\n-    assertEquals(4, map.segments[0].table.length()); // capacity / conc level\n+    assertThat(map.segments[0].table.length()).isEqualTo(4); // capacity / conc level\n   }\n \n   @GwtIncompatible // CountDownLatch"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/CacheEvictionTest.java",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "patch": "@@ -45,7 +45,7 @@ public void testEviction_setMaxSegmentSize() {\n     IdentityLoader<Object> loader = identityLoader();\n     for (int i = 1; i < 1000; i++) {\n       LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().maximumSize(i).build(loader);\n-      assertEquals(i, CacheTesting.getTotalSegmentSize(cache));\n+      assertThat(CacheTesting.getTotalSegmentSize(cache)).isEqualTo(i);\n     }\n   }\n \n@@ -54,7 +54,7 @@ public void testEviction_setMaxSegmentWeight() {\n     for (int i = 1; i < 1000; i++) {\n       LoadingCache<Object, Object> cache =\n           CacheBuilder.newBuilder().maximumWeight(i).weigher(constantWeigher(1)).build(loader);\n-      assertEquals(i, CacheTesting.getTotalSegmentSize(cache));\n+      assertThat(CacheTesting.getTotalSegmentSize(cache)).isEqualTo(i);\n     }\n   }\n \n@@ -64,10 +64,10 @@ public void testEviction_maxSizeOneSegment() {\n         CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(MAX_SIZE).build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertEquals(min(i + 1, MAX_SIZE), cache.size());\n+      assertThat(cache.size()).isEqualTo(min(i + 1, MAX_SIZE));\n     }\n \n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -81,10 +81,10 @@ public void testEviction_maxWeightOneSegment() {\n             .build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertEquals(min(i + 1, MAX_SIZE), cache.size());\n+      assertThat(cache.size()).isEqualTo(min(i + 1, MAX_SIZE));\n     }\n \n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -98,13 +98,13 @@ public void testEviction_maxSize() {\n             .build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertTrue(cache.size() <= MAX_SIZE);\n+      assertThat(cache.size() <= MAX_SIZE).isTrue();\n     }\n \n-    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));\n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(CacheTesting.accessQueueSize(cache)).isEqualTo(MAX_SIZE);\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.processPendingNotifications(cache);\n-    assertEquals(MAX_SIZE, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -119,13 +119,13 @@ public void testEviction_maxWeight() {\n             .build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertTrue(cache.size() <= MAX_SIZE);\n+      assertThat(cache.size()).isAtMost(MAX_SIZE);\n     }\n \n-    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));\n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(CacheTesting.accessQueueSize(cache)).isEqualTo(MAX_SIZE);\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.processPendingNotifications(cache);\n-    assertEquals(MAX_SIZE, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -255,7 +255,7 @@ public void testEviction_overflow() {\n     cache.getUnchecked(objectWithHash(0));\n     cache.getUnchecked(objectWithHash(0));\n     CacheTesting.processPendingNotifications(cache);\n-    assertEquals(1, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(1);\n   }\n \n   public void testUpdateRecency_onGet() {"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/CacheExpirationTest.java",
      "status": "modified",
      "additions": 52,
      "deletions": 35,
      "changes": 87,
      "patch": "@@ -17,6 +17,7 @@\n import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.util.Arrays.asList;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static java.util.concurrent.TimeUnit.MINUTES;\n@@ -81,23 +82,29 @@ private void checkExpiration(\n       CountingRemovalListener<String, Integer> removalListener) {\n \n     for (int i = 0; i < 10; i++) {\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n     }\n \n     for (int i = 0; i < 10; i++) {\n       loader.reset();\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n-      assertFalse(\"Creator should not have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n+      assertWithMessage(\"Creator should not have been called @#%s\", i)\n+          .that(loader.wasCalled())\n+          .isFalse();\n     }\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n \n-    assertEquals(\"Map must be empty by now\", 0, cache.size());\n-    assertEquals(\"Eviction notifications must be received\", 10, removalListener.getCount());\n+    assertWithMessage(\"Map must be empty by now\").that(cache.size()).isEqualTo(0);\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(10);\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n     // ensure that no new notifications are sent\n-    assertEquals(\"Eviction notifications must be received\", 10, removalListener.getCount());\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(10);\n   }\n \n   public void testExpiringGet_expireAfterWrite() {\n@@ -133,13 +140,15 @@ private void runExpirationTest(\n       CountingRemovalListener<String, Integer> removalListener) {\n \n     for (int i = 0; i < 10; i++) {\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n     }\n \n     for (int i = 0; i < 10; i++) {\n       loader.reset();\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n-      assertFalse(\"Loader should NOT have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n+      assertWithMessage(\"Loader should NOT have been called @#%s\", i)\n+          .that(loader.wasCalled())\n+          .isFalse();\n     }\n \n     // wait for entries to expire, but don't call expireEntries\n@@ -149,31 +158,35 @@ private void runExpirationTest(\n     cache.getUnchecked(KEY_PREFIX + 11);\n \n     // collections views shouldn't expose expired entries\n-    assertEquals(1, Iterators.size(cache.asMap().entrySet().iterator()));\n-    assertEquals(1, Iterators.size(cache.asMap().keySet().iterator()));\n-    assertEquals(1, Iterators.size(cache.asMap().values().iterator()));\n+    assertThat(Iterators.size(cache.asMap().entrySet().iterator())).isEqualTo(1);\n+    assertThat(Iterators.size(cache.asMap().keySet().iterator())).isEqualTo(1);\n+    assertThat(Iterators.size(cache.asMap().values().iterator())).isEqualTo(1);\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n \n     for (int i = 0; i < 11; i++) {\n-      assertFalse(cache.asMap().containsKey(KEY_PREFIX + i));\n+      assertThat(cache.asMap().containsKey(KEY_PREFIX + i)).isFalse();\n     }\n-    assertEquals(11, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(11);\n \n     for (int i = 0; i < 10; i++) {\n-      assertFalse(cache.asMap().containsKey(KEY_PREFIX + i));\n+      assertThat(cache.asMap().containsKey(KEY_PREFIX + i)).isFalse();\n       loader.reset();\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n-      assertTrue(\"Creator should have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n+      assertWithMessage(\"Loader should have been called @#%s\", i).that(loader.wasCalled()).isTrue();\n     }\n \n     // expire new values we just created\n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n-    assertEquals(\"Eviction notifications must be received\", 21, removalListener.getCount());\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(21);\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n     // ensure that no new notifications are sent\n-    assertEquals(\"Eviction notifications must be received\", 21, removalListener.getCount());\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(21);\n   }\n \n   public void testRemovalListener_expireAfterWrite() {\n@@ -215,9 +228,9 @@ public AtomicInteger load(Integer key) {\n       ticker.advance(1, MILLISECONDS);\n     }\n \n-    assertEquals(evictionCount.get() + 1, applyCount.get());\n+    assertThat(applyCount.get()).isEqualTo(evictionCount.get() + 1);\n     int remaining = cache.getUnchecked(10).get();\n-    assertEquals(100, totalSum.get() + remaining);\n+    assertThat(totalSum.get() + remaining).isEqualTo(100);\n   }\n \n   public void testRemovalScheduler_expireAfterWrite() {\n@@ -435,46 +448,50 @@ private void runRemovalScheduler(\n       FakeTicker ticker,\n       String keyPrefix,\n       long ttl) {\n+    loader.setKeyPrefix(keyPrefix);\n \n     int shift1 = 10 + VALUE_PREFIX;\n     loader.setValuePrefix(shift1);\n     // fill with initial data\n     for (int i = 0; i < 10; i++) {\n-      assertEquals(Integer.valueOf(i + shift1), cache.getUnchecked(keyPrefix + i));\n+      assertThat(cache.getUnchecked(keyPrefix + i)).isEqualTo(i + shift1);\n     }\n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n \n     // wait, so that entries have just 10 ms to live\n     ticker.advance(ttl * 2 / 3, MILLISECONDS);\n \n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n \n     int shift2 = shift1 + 10;\n     loader.setValuePrefix(shift2);\n     // fill with new data - has to live for 20 ms more\n     for (int i = 0; i < 10; i++) {\n       cache.invalidate(keyPrefix + i);\n-      assertEquals(\n-          \"key: \" + keyPrefix + i, Integer.valueOf(i + shift2), cache.getUnchecked(keyPrefix + i));\n+      assertWithMessage(\"key: %s%s\", keyPrefix, i)\n+          .that(cache.getUnchecked(keyPrefix + i))\n+          .isEqualTo(i + shift2);\n     }\n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(10, removalListener.getCount()); // these are the invalidated ones\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(10); // these are the invalidated ones\n \n     // old timeouts must expire after this wait\n     ticker.advance(ttl * 2 / 3, MILLISECONDS);\n \n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(10, removalListener.getCount());\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(10);\n \n     // check that new values are still there - they still have 10 ms to live\n     for (int i = 0; i < 10; i++) {\n       loader.reset();\n-      assertEquals(Integer.valueOf(i + shift2), cache.getUnchecked(keyPrefix + i));\n-      assertFalse(\"Creator should NOT have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(keyPrefix + i)).isEqualTo(i + shift2);\n+      assertWithMessage(\"Creator should NOT have been called @#%s\", i)\n+          .that(loader.wasCalled())\n+          .isFalse();\n     }\n-    assertEquals(10, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(10);\n   }\n \n   private static void getAll(LoadingCache<Integer, Integer> cache, List<Integer> keys) {"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/CacheLoaderTest.java",
      "status": "modified",
      "additions": 13,
      "deletions": 12,
      "changes": 25,
      "patch": "@@ -16,6 +16,7 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.util.concurrent.Futures.immediateFuture;\n \n import com.google.common.collect.ImmutableList;\n@@ -77,17 +78,17 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {\n           }\n         };\n \n-    assertEquals(0, loadCount.get());\n-    assertEquals(0, reloadCount.get());\n-    assertEquals(0, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(0);\n+    assertThat(reloadCount.get()).isEqualTo(0);\n+    assertThat(loadAllCount.get()).isEqualTo(0);\n \n     Object unused1 = baseLoader.load(new Object());\n     @SuppressWarnings(\"unused\") // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n     Future<?> possiblyIgnoredError = baseLoader.reload(new Object(), new Object());\n     Map<Object, Object> unused2 = baseLoader.loadAll(ImmutableList.of(new Object()));\n-    assertEquals(1, loadCount.get());\n-    assertEquals(1, reloadCount.get());\n-    assertEquals(1, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(1);\n+    assertThat(reloadCount.get()).isEqualTo(1);\n+    assertThat(loadAllCount.get()).isEqualTo(1);\n \n     QueuingExecutor executor = new QueuingExecutor();\n     CacheLoader<Object, Object> asyncReloader = CacheLoader.asyncReloading(baseLoader, executor);\n@@ -96,13 +97,13 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {\n     @SuppressWarnings(\"unused\") // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n     Future<?> possiblyIgnoredError1 = asyncReloader.reload(new Object(), new Object());\n     Map<Object, Object> unused4 = asyncReloader.loadAll(ImmutableList.of(new Object()));\n-    assertEquals(2, loadCount.get());\n-    assertEquals(1, reloadCount.get());\n-    assertEquals(2, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(2);\n+    assertThat(reloadCount.get()).isEqualTo(1);\n+    assertThat(loadAllCount.get()).isEqualTo(2);\n \n     executor.runNext();\n-    assertEquals(2, loadCount.get());\n-    assertEquals(2, reloadCount.get());\n-    assertEquals(2, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(2);\n+    assertThat(reloadCount.get()).isEqualTo(2);\n+    assertThat(loadAllCount.get()).isEqualTo(2);\n   }\n }"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/CacheLoadingTest.java",
      "status": "modified",
      "additions": 651,
      "deletions": 661,
      "changes": 1312,
      "patch": "@@ -21,6 +21,7 @@\n import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static com.google.common.util.concurrent.Futures.immediateFailedFuture;\n import static com.google.common.util.concurrent.Futures.immediateFuture;\n import static java.util.Arrays.asList;\n@@ -33,7 +34,6 @@\n import com.google.common.cache.TestingCacheLoaders.IdentityLoader;\n import com.google.common.cache.TestingRemovalListeners.CountingRemovalListener;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Lists;\n import com.google.common.testing.FakeTicker;\n import com.google.common.testing.TestLogHandler;\n@@ -83,7 +83,7 @@ public void tearDown() throws Exception {\n \n   private Throwable popLoggedThrowable() {\n     List<LogRecord> logRecords = logHandler.getStoredLogRecords();\n-    assertEquals(1, logRecords.size());\n+    assertThat(logRecords).hasSize(1);\n     LogRecord logRecord = logRecords.get(0);\n     logHandler.clear();\n     return logRecord.getThrown();\n@@ -105,59 +105,59 @@ public void testLoad() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(identityLoader());\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Object key = new Object();\n-    assertSame(key, cache.get(key));\n+    assertThat(cache.get(key)).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     key = new Object();\n-    assertSame(key, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     key = new Object();\n     cache.refresh(key);\n     checkNothingLogged();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(key, cache.get(key));\n+    assertThat(cache.get(key)).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     Object value = new Object();\n     // callable is not called\n-    assertSame(key, cache.get(key, throwing(new Exception())));\n+    assertThat(cache.get(key, throwing(new Exception()))).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     key = new Object();\n-    assertSame(value, cache.get(key, Callables.returning(value)));\n+    assertThat(cache.get(key, Callables.returning(value))).isSameInstanceAs(value);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(4, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(4);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n   }\n \n   public void testReload() throws ExecutionException {\n@@ -179,32 +179,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkNothingLogged();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(two, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefresh() {\n@@ -232,41 +232,41 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testRefresh_getIfPresent() {\n@@ -294,41 +294,41 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getIfPresent(key));\n+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getIfPresent(key));\n+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getIfPresent(key));\n+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoad_default() throws ExecutionException {\n@@ -337,91 +337,91 @@ public void testBulkLoad_default() throws ExecutionException {\n             .recordStats()\n             .build(TestingCacheLoaders.<Integer>identityLoader());\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.<Integer>of()));\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(cache.getAll(ImmutableList.of())).isEmpty();\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));\n+    assertThat(cache.getAll(asList(1))).containsExactly(1, 1);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));\n+    assertThat(cache.getAll(asList(1, 2, 3, 4))).containsExactly(1, 1, 2, 2, 3, 3, 4, 4);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(4, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(4);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n-    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));\n+    assertThat(cache.getAll(asList(2, 3))).containsExactly(2, 2, 3, 3);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(4, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(4);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n \n     // duplicate keys are ignored, and don't impact stats\n-    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));\n+    assertThat(cache.getAll(asList(4, 5))).containsExactly(4, 4, 5, 5);\n     stats = cache.stats();\n-    assertEquals(5, stats.missCount());\n-    assertEquals(5, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(4, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(5);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(5);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(4);\n   }\n \n   public void testBulkLoad_loadAll() throws ExecutionException {\n     IdentityLoader<Integer> backingLoader = identityLoader();\n     CacheLoader<Integer, Integer> loader = bulkLoader(backingLoader);\n     LoadingCache<Integer, Integer> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.<Integer>of()));\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(cache.getAll(ImmutableList.<Integer>of())).containsExactly();\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));\n+    assertThat(cache.getAll(asList(1))).containsExactly(1, 1);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));\n+    assertThat(cache.getAll(asList(1, 2, 3, 4))).containsExactly(1, 1, 2, 2, 3, 3, 4, 4);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n-    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));\n+    assertThat(cache.getAll(asList(2, 3))).containsExactly(2, 2, 3, 3);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n \n     // duplicate keys are ignored, and don't impact stats\n-    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));\n+    assertThat(cache.getAll(asList(4, 5))).containsExactly(4, 4, 5, 5);\n     stats = cache.stats();\n-    assertEquals(5, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(4, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(5);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(4);\n   }\n \n   public void testBulkLoad_extra() throws ExecutionException {\n@@ -452,10 +452,10 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n     for (Entry<Object, Object> entry : result.entrySet()) {\n       Object key = entry.getKey();\n       Object value = entry.getValue();\n-      assertSame(value, result.get(key));\n-      assertNull(result.get(value));\n-      assertSame(value, cache.asMap().get(key));\n-      assertSame(key, cache.asMap().get(value));\n+      assertThat(result.get(key)).isSameInstanceAs(value);\n+      assertThat(result.get(value)).isNull();\n+      assertThat(cache.asMap().get(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().get(value)).isSameInstanceAs(key);\n     }\n   }\n \n@@ -482,19 +482,19 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n         };\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);\n     cache.asMap().put(extraKey, extraKey);\n-    assertSame(extraKey, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     Map<Object, Object> result = cache.getAll(asList(lookupKeys));\n     assertThat(result.keySet()).containsExactlyElementsIn(asList(lookupKeys));\n     for (Entry<Object, Object> entry : result.entrySet()) {\n       Object key = entry.getKey();\n       Object value = entry.getValue();\n-      assertSame(value, result.get(key));\n-      assertSame(value, cache.asMap().get(key));\n+      assertThat(result.get(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().get(key)).isSameInstanceAs(value);\n     }\n-    assertNull(result.get(extraKey));\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n+    assertThat(result.get(extraKey)).isNull();\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n   }\n \n   public void testBulkLoad_clobberNullValue() throws ExecutionException {\n@@ -521,16 +521,16 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n         };\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);\n     cache.asMap().put(extraKey, extraKey);\n-    assertSame(extraKey, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));\n \n     for (Object key : lookupKeys) {\n-      assertTrue(cache.asMap().containsKey(key));\n+      assertThat(cache.asMap().containsKey(key)).isTrue();\n     }\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n-    assertFalse(cache.asMap().containsKey(extraValue));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n+    assertThat(cache.asMap().containsKey(extraValue)).isFalse();\n   }\n \n   public void testBulkLoad_clobberNullKey() throws ExecutionException {\n@@ -557,16 +557,16 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n         };\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);\n     cache.asMap().put(extraKey, extraKey);\n-    assertSame(extraKey, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));\n \n     for (Object key : lookupKeys) {\n-      assertTrue(cache.asMap().containsKey(key));\n+      assertThat(cache.asMap().containsKey(key)).isTrue();\n     }\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n-    assertFalse(cache.asMap().containsValue(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n+    assertThat(cache.asMap().containsValue(extraKey)).isFalse();\n   }\n \n   public void testBulkLoad_partial() throws ExecutionException {\n@@ -591,54 +591,54 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n   }\n \n   public void testLoadNull() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(constantLoader(null));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.get(new Object()));\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(new Object()));\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedInvalidLoad();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(\n         InvalidCacheLoadException.class, () -> cache.get(new Object(), Callables.returning(null)));\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadNull() throws ExecutionException {\n@@ -659,32 +659,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedInvalidLoad();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadNullFuture() throws ExecutionException {\n@@ -705,32 +705,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedInvalidLoad();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshNull() {\n@@ -757,59 +757,59 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadNull() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(constantLoader(null)));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testBulkLoadNullMap() throws ExecutionException {\n@@ -830,52 +830,52 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {\n                 });\n \n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadError() throws ExecutionException {\n     Error e = new Error();\n     CacheLoader<Object, Object> loader = errorLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionError expected = assertThrows(ExecutionError.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionError.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Error callableError = new Error();\n     expected =\n@@ -892,18 +892,18 @@ public Object call() {\n                     }));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableError);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionError.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadError() throws ExecutionException {\n@@ -925,32 +925,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadFutureError() throws ExecutionException {\n@@ -972,32 +972,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshError() {\n@@ -1025,42 +1025,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadError() throws ExecutionException {\n@@ -1069,137 +1069,137 @@ public void testBulkLoadError() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionError expected =\n         assertThrows(ExecutionError.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadCheckedException() {\n     Exception e = new Exception();\n     CacheLoader<Object, Object> loader = exceptionLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception expected = assertThrows(ExecutionException.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception callableException = new Exception();\n     expected =\n         assertThrows(\n             ExecutionException.class, () -> cache.get(new Object(), throwing(callableException)));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadInterruptedException() {\n     Exception e = new InterruptedException();\n     CacheLoader<Object, Object> loader = exceptionLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     // Sanity check:\n-    assertFalse(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isFalse();\n \n     Exception expected = assertThrows(ExecutionException.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception callableException = new InterruptedException();\n     expected =\n         assertThrows(\n             ExecutionException.class, () -> cache.get(new Object(), throwing(callableException)));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadCheckedException() {\n@@ -1221,32 +1221,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) throws Excep\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadFutureCheckedException() {\n@@ -1268,32 +1268,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshCheckedException() {\n@@ -1321,42 +1321,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadCheckedException() {\n@@ -1365,19 +1365,19 @@ public void testBulkLoadCheckedException() {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionException expected =\n         assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testBulkLoadInterruptedException() {\n@@ -1386,57 +1386,57 @@ public void testBulkLoadInterruptedException() {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionException expected =\n         assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadUncheckedException() throws ExecutionException {\n     Exception e = new RuntimeException();\n     CacheLoader<Object, Object> loader = exceptionLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     UncheckedExecutionException expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception callableException = new RuntimeException();\n     expected =\n@@ -1445,19 +1445,19 @@ public void testLoadUncheckedException() throws ExecutionException {\n             () -> cache.get(new Object(), throwing(callableException)));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadUncheckedException() throws ExecutionException {\n@@ -1479,32 +1479,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) throws Excep\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadFutureUncheckedException() throws ExecutionException {\n@@ -1526,32 +1526,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshUncheckedException() {\n@@ -1579,42 +1579,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadUncheckedException() throws ExecutionException {\n@@ -1623,19 +1623,19 @@ public void testBulkLoadUncheckedException() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     UncheckedExecutionException expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadAfterFailure() throws ExecutionException {\n@@ -1660,15 +1660,15 @@ public String load(Integer key) throws Exception {\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(1));\n     assertThat(ue).hasCauseThat().isSameInstanceAs(e);\n \n-    assertEquals(\"1\", cache.getUnchecked(1));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(cache.getUnchecked(1)).isEqualTo(\"1\");\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n \n     count.set(0);\n     cache.refresh(2);\n     checkLoggedCause(e);\n \n-    assertEquals(\"2\", cache.getUnchecked(2));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(cache.getUnchecked(2)).isEqualTo(\"2\");\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n   }\n \n \n@@ -1693,7 +1693,7 @@ public void testReloadAfterValueReclamation() throws InterruptedException, Execu\n       Thread.sleep(i);\n       System.gc();\n     }\n-    assertEquals(expectedComputations, countingLoader.getCount());\n+    assertThat(countingLoader.getCount()).isEqualTo(expectedComputations);\n \n     for (int i = 0; i < iterations; i++) {\n       // The entry should get garbage collected and recomputed.\n@@ -1708,7 +1708,7 @@ public void testReloadAfterValueReclamation() throws InterruptedException, Execu\n       Thread.sleep(i);\n       System.gc();\n     }\n-    assertEquals(expectedComputations, countingLoader.getCount());\n+    assertThat(countingLoader.getCount()).isEqualTo(expectedComputations);\n   }\n \n   public void testReloadAfterSimulatedValueReclamation() throws ExecutionException {\n@@ -1717,20 +1717,20 @@ public void testReloadAfterSimulatedValueReclamation() throws ExecutionException\n         CacheBuilder.newBuilder().concurrencyLevel(1).weakValues().build(countingLoader);\n \n     Object key = new Object();\n-    assertNotNull(cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n \n     CacheTesting.simulateValueReclamation(cache, key);\n \n     // this blocks if computation can't deal with partially-collected values\n-    assertNotNull(cache.getUnchecked(key));\n-    assertEquals(1, cache.size());\n-    assertEquals(2, countingLoader.getCount());\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n+    assertThat(cache.size()).isEqualTo(1);\n+    assertThat(countingLoader.getCount()).isEqualTo(2);\n \n     CacheTesting.simulateValueReclamation(cache, key);\n     cache.refresh(key);\n     checkNothingLogged();\n-    assertEquals(1, cache.size());\n-    assertEquals(3, countingLoader.getCount());\n+    assertThat(cache.size()).isEqualTo(1);\n+    assertThat(countingLoader.getCount()).isEqualTo(3);\n   }\n \n   public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {\n@@ -1739,19 +1739,19 @@ public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {\n         CacheBuilder.newBuilder().concurrencyLevel(1).weakKeys().build(countingLoader);\n \n     Object key = new Object();\n-    assertNotNull(cache.getUnchecked(key));\n-    assertEquals(1, cache.size());\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n+    assertThat(cache.size()).isEqualTo(1);\n \n     CacheTesting.simulateKeyReclamation(cache, key);\n \n     // this blocks if computation can't deal with partially-collected values\n-    assertNotNull(cache.getUnchecked(key));\n-    assertEquals(2, countingLoader.getCount());\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n+    assertThat(countingLoader.getCount()).isEqualTo(2);\n \n     CacheTesting.simulateKeyReclamation(cache, key);\n     cache.refresh(key);\n     checkNothingLogged();\n-    assertEquals(3, countingLoader.getCount());\n+    assertThat(countingLoader.getCount()).isEqualTo(3);\n   }\n \n   /**\n@@ -1864,9 +1864,11 @@ public Object load(String key) throws InterruptedException {\n \n     List<Object> resultArray = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n-      assertSame(\"result(\" + i + \") didn't match expected\", result, resultArray.get(i));\n+      assertWithMessage(\"result(%s) didn't match expected\", i)\n+          .that(resultArray.get(i))\n+          .isSameInstanceAs(result);\n     }\n   }\n \n@@ -1896,18 +1898,14 @@ public String load(String key) throws InterruptedException {\n \n     List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n       assertThat(result.get(i)).isInstanceOf(InvalidCacheLoadException.class);\n     }\n \n     // subsequent calls should call the loader again, not get the old exception\n-    try {\n-      cache.getUnchecked(\"bar\");\n-      fail();\n-    } catch (InvalidCacheLoadException expected) {\n-    }\n-    assertEquals(2, callCount.get());\n+    assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(\"bar\"));\n+    assertThat(callCount.get()).isEqualTo(2);\n   }\n \n   /**\n@@ -1936,7 +1934,7 @@ public String load(String key) throws InterruptedException {\n \n     List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n       // doConcurrentGet alternates between calling getUnchecked and calling get, but an unchecked\n       // exception thrown by the loader is always wrapped as an UncheckedExecutionException.\n@@ -1945,12 +1943,8 @@ public String load(String key) throws InterruptedException {\n     }\n \n     // subsequent calls should call the loader again, not get the old exception\n-    try {\n-      cache.getUnchecked(\"bar\");\n-      fail();\n-    } catch (UncheckedExecutionException expected) {\n-    }\n-    assertEquals(2, callCount.get());\n+    assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(\"bar\"));\n+    assertThat(callCount.get()).isEqualTo(2);\n   }\n \n   /**\n@@ -1979,7 +1973,7 @@ public String load(String key) throws IOException, InterruptedException {\n \n     List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n       // doConcurrentGet alternates between calling getUnchecked and calling get. If we call get(),\n       // we should get an ExecutionException; if we call getUnchecked(), we should get an\n@@ -1995,12 +1989,8 @@ public String load(String key) throws IOException, InterruptedException {\n     }\n \n     // subsequent calls should call the loader again, not get the old exception\n-    try {\n-      cache.getUnchecked(\"bar\");\n-      fail();\n-    } catch (UncheckedExecutionException expected) {\n-    }\n-    assertEquals(2, callCount.get());\n+    assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(\"bar\"));\n+    assertThat(callCount.get()).isEqualTo(2);\n   }\n \n   /**\n@@ -2084,9 +2074,9 @@ public String load(String key) throws InterruptedException {\n     LoadingCache<String, String> cache = CacheBuilder.newBuilder().build(computeFunction);\n     ConcurrentMap<String, String> map = cache.asMap();\n     map.put(refreshKey, refreshKey);\n-    assertEquals(1, map.size());\n-    assertFalse(map.containsKey(getKey));\n-    assertSame(refreshKey, map.get(refreshKey));\n+    assertThat(map).hasSize(1);\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.get(refreshKey)).isSameInstanceAs(refreshKey);\n \n     new Thread() {\n       @Override\n@@ -2106,19 +2096,19 @@ public void run() {\n     getStartedSignal.await();\n \n     // computation is in progress; asMap shouldn't have changed\n-    assertEquals(1, map.size());\n-    assertFalse(map.containsKey(getKey));\n-    assertSame(refreshKey, map.get(refreshKey));\n+    assertThat(map).hasSize(1);\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.get(refreshKey)).isSameInstanceAs(refreshKey);\n \n     // let computation complete\n     letGetFinishSignal.countDown();\n     getFinishedSignal.await();\n     checkNothingLogged();\n \n     // asMap view should have been updated\n-    assertEquals(2, cache.size());\n-    assertEquals(getKey + suffix, map.get(getKey));\n-    assertEquals(refreshKey + suffix, map.get(refreshKey));\n+    assertThat(cache.size()).isEqualTo(2);\n+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);\n+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);\n   }\n \n   public void testInvalidateDuringLoading() throws InterruptedException, ExecutionException {\n@@ -2162,19 +2152,19 @@ public void run() {\n     computationStarted.await();\n     cache.invalidate(getKey);\n     cache.invalidate(refreshKey);\n-    assertFalse(map.containsKey(getKey));\n-    assertFalse(map.containsKey(refreshKey));\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.containsKey(refreshKey)).isFalse();\n \n     // let computation complete\n     letGetFinishSignal.countDown();\n     getFinishedSignal.await();\n     checkNothingLogged();\n \n     // results should be visible\n-    assertEquals(2, cache.size());\n-    assertEquals(getKey + suffix, map.get(getKey));\n-    assertEquals(refreshKey + suffix, map.get(refreshKey));\n-    assertEquals(2, cache.size());\n+    assertThat(cache.size()).isEqualTo(2);\n+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);\n+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);\n+    assertThat(cache.size()).isEqualTo(2);\n   }\n \n   public void testInvalidateAndReloadDuringLoading()\n@@ -2219,8 +2209,8 @@ public void run() {\n     computationStarted.await();\n     cache.invalidate(getKey);\n     cache.invalidate(refreshKey);\n-    assertFalse(map.containsKey(getKey));\n-    assertFalse(map.containsKey(refreshKey));\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.containsKey(refreshKey)).isFalse();\n \n     // start new computations\n     new Thread() {\n@@ -2244,9 +2234,9 @@ public void run() {\n     checkNothingLogged();\n \n     // results should be visible\n-    assertEquals(2, cache.size());\n-    assertEquals(getKey + suffix, map.get(getKey));\n-    assertEquals(refreshKey + suffix, map.get(refreshKey));\n+    assertThat(cache.size()).isEqualTo(2);\n+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);\n+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);\n   }\n \n   @SuppressWarnings(\"ThreadPriorityCheck\") // doing our best to test for races\n@@ -2331,11 +2321,11 @@ public void run() {\n     computeSignal.countDown();\n     doneSignal.await();\n \n-    assertTrue(callCount.get() == 1);\n-    assertEquals(\"barfoo\", result.get(0));\n-    assertEquals(\"barfoo\", result.get(1));\n-    assertEquals(\"barfoo\", result.get(2));\n-    assertEquals(\"barfoo\", cache.getUnchecked(key));\n+    assertThat(callCount.get()).isEqualTo(1);\n+    assertThat(result.get(0)).isEqualTo(\"barfoo\");\n+    assertThat(result.get(1)).isEqualTo(\"barfoo\");\n+    assertThat(result.get(2)).isEqualTo(\"barfoo\");\n+    assertThat(cache.getUnchecked(key)).isEqualTo(\"barfoo\");\n   }\n \n   // Test ignored because it is extremely flaky in CI builds\n@@ -2423,10 +2413,10 @@ public void run() {\n     computeSignal.countDown();\n     doneSignal.await();\n \n-    assertTrue(callCount.get() == 1);\n-    assertEquals(key, result.get(0));\n-    assertEquals(key, result.get(1));\n-    assertEquals(key + suffix, cache.getUnchecked(key));\n+    assertThat(callCount.get()).isEqualTo(1);\n+    assertThat(result.get(0)).isEqualTo(key);\n+    assertThat(result.get(1)).isEqualTo(key);\n+    assertThat(cache.getUnchecked(key)).isEqualTo(key + suffix);\n   }\n \n   static <T> Callable<T> throwing(Exception exception) {"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/CacheManualTest.java",
      "status": "modified",
      "additions": 86,
      "deletions": 84,
      "changes": 170,
      "patch": "@@ -14,6 +14,7 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.Arrays.asList;\n \n import com.google.common.collect.ImmutableList;\n@@ -30,126 +31,127 @@ public class CacheManualTest extends TestCase {\n   public void testGetIfPresent() {\n     Cache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Object one = new Object();\n     Object two = new Object();\n \n-    assertNull(cache.getIfPresent(one));\n+    assertThat(cache.getIfPresent(one)).isNull();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n-    assertNull(cache.asMap().get(one));\n-    assertFalse(cache.asMap().containsKey(one));\n-    assertFalse(cache.asMap().containsValue(two));\n-\n-    assertNull(cache.getIfPresent(two));\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n+    assertThat(cache.asMap().get(one)).isNull();\n+    assertThat(cache.asMap().containsKey(one)).isFalse();\n+    assertThat(cache.asMap().containsValue(two)).isFalse();\n+\n+    assertThat(cache.getIfPresent(two)).isNull();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n-    assertNull(cache.asMap().get(two));\n-    assertFalse(cache.asMap().containsKey(two));\n-    assertFalse(cache.asMap().containsValue(one));\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n+    assertThat(cache.asMap().get(two)).isNull();\n+    assertThat(cache.asMap().containsKey(two)).isFalse();\n+    assertThat(cache.asMap().containsValue(one)).isFalse();\n \n     cache.put(one, two);\n \n-    assertSame(two, cache.getIfPresent(one));\n+    assertThat(cache.getIfPresent(one)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n-    assertSame(two, cache.asMap().get(one));\n-    assertTrue(cache.asMap().containsKey(one));\n-    assertTrue(cache.asMap().containsValue(two));\n-\n-    assertNull(cache.getIfPresent(two));\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n+    assertThat(cache.asMap().get(one)).isSameInstanceAs(two);\n+    assertThat(cache.asMap().containsKey(one)).isTrue();\n+    assertThat(cache.asMap().containsValue(two)).isTrue();\n+\n+    assertThat(cache.getIfPresent(two)).isNull();\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n-    assertNull(cache.asMap().get(two));\n-    assertFalse(cache.asMap().containsKey(two));\n-    assertFalse(cache.asMap().containsValue(one));\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n+    assertThat(cache.asMap().get(two)).isNull();\n+    assertThat(cache.asMap().containsKey(two)).isFalse();\n+    assertThat(cache.asMap().containsValue(one)).isFalse();\n \n     cache.put(two, one);\n \n-    assertSame(two, cache.getIfPresent(one));\n+    assertThat(cache.getIfPresent(one)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n-    assertSame(two, cache.asMap().get(one));\n-    assertTrue(cache.asMap().containsKey(one));\n-    assertTrue(cache.asMap().containsValue(two));\n-\n-    assertSame(one, cache.getIfPresent(two));\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n+    assertThat(cache.asMap().get(one)).isSameInstanceAs(two);\n+    assertThat(cache.asMap().containsKey(one)).isTrue();\n+    assertThat(cache.asMap().containsValue(two)).isTrue();\n+\n+    assertThat(cache.getIfPresent(two)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n-    assertSame(one, cache.asMap().get(two));\n-    assertTrue(cache.asMap().containsKey(two));\n-    assertTrue(cache.asMap().containsValue(one));\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n+    assertThat(cache.asMap().get(two)).isSameInstanceAs(one);\n+    assertThat(cache.asMap().containsKey(two)).isTrue();\n+    assertThat(cache.asMap().containsValue(one)).isTrue();\n   }\n \n   public void testGetAllPresent() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().recordStats().build();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAllPresent(ImmutableList.<Integer>of()));\n+    assertThat(cache.getAllPresent(ImmutableList.<Integer>of())).isEmpty();\n     stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3))).isEqualTo(ImmutableMap.of());\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.put(2, 22);\n \n-    assertEquals(ImmutableMap.of(2, 22), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3))).containsExactly(2, 22);\n     stats = cache.stats();\n-    assertEquals(5, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(5);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     cache.put(3, 33);\n \n-    assertEquals(ImmutableMap.of(2, 22, 3, 33), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3))).containsExactly(2, 22, 3, 33);\n     stats = cache.stats();\n-    assertEquals(6, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(6);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n \n     cache.put(1, 11);\n \n-    assertEquals(ImmutableMap.of(1, 11, 2, 22, 3, 33), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3)))\n+        .isEqualTo(ImmutableMap.of(1, 11, 2, 22, 3, 33));\n     stats = cache.stats();\n-    assertEquals(6, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(6, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(6);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(6);\n   }\n }"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/CacheReferencesTest.java",
      "status": "modified",
      "additions": 22,
      "deletions": 23,
      "changes": 45,
      "patch": "@@ -66,24 +66,24 @@ public void testContainsKeyAndValue() {\n       // maintain strong refs so these won't be collected, regardless of cache's key/value strength\n       Key key = new Key(1);\n       String value = key.toString();\n-      assertSame(value, cache.getUnchecked(key));\n-      assertTrue(cache.asMap().containsKey(key));\n-      assertTrue(cache.asMap().containsValue(value));\n-      assertEquals(1, cache.size());\n+      assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().containsKey(key)).isTrue();\n+      assertThat(cache.asMap().containsValue(value)).isTrue();\n+      assertThat(cache.size()).isEqualTo(1);\n     }\n   }\n \n   public void testClear() {\n     for (LoadingCache<Key, String> cache : caches()) {\n       Key key = new Key(1);\n       String value = key.toString();\n-      assertSame(value, cache.getUnchecked(key));\n-      assertFalse(cache.asMap().isEmpty());\n+      assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().isEmpty()).isFalse();\n       cache.invalidateAll();\n-      assertEquals(0, cache.size());\n-      assertTrue(cache.asMap().isEmpty());\n-      assertFalse(cache.asMap().containsKey(key));\n-      assertFalse(cache.asMap().containsValue(value));\n+      assertThat(cache.size()).isEqualTo(0);\n+      assertThat(cache.asMap().isEmpty()).isTrue();\n+      assertThat(cache.asMap().containsKey(key)).isFalse();\n+      assertThat(cache.asMap().containsValue(value)).isFalse();\n     }\n   }\n \n@@ -93,13 +93,12 @@ public void testKeySetEntrySetValues() {\n       String value1 = key1.toString();\n       Key key2 = new Key(2);\n       String value2 = key2.toString();\n-      assertSame(value1, cache.getUnchecked(key1));\n-      assertSame(value2, cache.getUnchecked(key2));\n-      assertEquals(ImmutableSet.of(key1, key2), cache.asMap().keySet());\n+      assertThat(cache.getUnchecked(key1)).isSameInstanceAs(value1);\n+      assertThat(cache.getUnchecked(key2)).isSameInstanceAs(value2);\n+      assertThat(cache.asMap().keySet()).isEqualTo(ImmutableSet.of(key1, key2));\n       assertThat(cache.asMap().values()).containsExactly(value1, value2);\n-      assertEquals(\n-          ImmutableSet.of(immutableEntry(key1, value1), immutableEntry(key2, value2)),\n-          cache.asMap().entrySet());\n+      assertThat(cache.asMap().entrySet())\n+          .containsExactly(immutableEntry(key1, value1), immutableEntry(key2, value2));\n     }\n   }\n \n@@ -109,15 +108,15 @@ public void testInvalidate() {\n       String value1 = key1.toString();\n       Key key2 = new Key(2);\n       String value2 = key2.toString();\n-      assertSame(value1, cache.getUnchecked(key1));\n-      assertSame(value2, cache.getUnchecked(key2));\n+      assertThat(cache.getUnchecked(key1)).isSameInstanceAs(value1);\n+      assertThat(cache.getUnchecked(key2)).isSameInstanceAs(value2);\n       cache.invalidate(key1);\n-      assertFalse(cache.asMap().containsKey(key1));\n-      assertTrue(cache.asMap().containsKey(key2));\n-      assertEquals(1, cache.size());\n-      assertEquals(ImmutableSet.of(key2), cache.asMap().keySet());\n+      assertThat(cache.asMap().containsKey(key1)).isFalse();\n+      assertThat(cache.asMap().containsKey(key2)).isTrue();\n+      assertThat(cache.size()).isEqualTo(1);\n+      assertThat(cache.asMap().keySet()).isEqualTo(ImmutableSet.of(key2));\n       assertThat(cache.asMap().values()).contains(value2);\n-      assertEquals(ImmutableSet.of(immutableEntry(key2, value2)), cache.asMap().entrySet());\n+      assertThat(cache.asMap().entrySet()).containsExactly(immutableEntry(key2, value2));\n     }\n   }\n "
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/CacheRefreshTest.java",
      "status": "modified",
      "additions": 34,
      "deletions": 33,
      "changes": 67,
      "patch": "@@ -15,6 +15,7 @@\n package com.google.common.cache;\n \n import static com.google.common.cache.TestingCacheLoaders.incrementingLoader;\n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n \n import com.google.common.cache.TestingCacheLoaders.IncrementingLoader;\n@@ -42,61 +43,61 @@ public void testAutoRefresh() {\n     int expectedLoads = 0;\n     int expectedReloads = 0;\n     for (int i = 0; i < 3; i++) {\n-      assertEquals(Integer.valueOf(i), cache.getUnchecked(i));\n+      assertThat(cache.getUnchecked(i)).isEqualTo(i);\n       expectedLoads++;\n-      assertEquals(expectedLoads, loader.getLoadCount());\n-      assertEquals(expectedReloads, loader.getReloadCount());\n+      assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+      assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n       ticker.advance(1, MILLISECONDS);\n     }\n \n-    assertEquals(Integer.valueOf(0), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(0)).isEqualTo(0);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // refresh 0\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n     expectedReloads++;\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(1)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // write to 1 to delay its refresh\n     cache.asMap().put(1, -1);\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // refresh 2\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(3);\n     expectedReloads++;\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(3);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // refresh 0 and 1\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(0));\n+    assertThat(cache.getUnchecked(0)).isEqualTo(2);\n     expectedReloads++;\n-    assertEquals(Integer.valueOf(0), cache.getUnchecked(1));\n+    assertThat(cache.getUnchecked(1)).isEqualTo(0);\n     expectedReloads++;\n-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(2)).isEqualTo(3);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n   }\n }"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/CacheStatsTest.java",
      "status": "modified",
      "additions": 43,
      "deletions": 43,
      "changes": 86,
      "patch": "@@ -31,76 +31,76 @@ public class CacheStatsTest extends TestCase {\n \n   public void testEmpty() {\n     CacheStats stats = new CacheStats(0, 0, 0, 0, 0, 0);\n-    assertEquals(0, stats.requestCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n     assertThat(stats.hitRate()).isEqualTo(1.0);\n-    assertEquals(0, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n     assertThat(stats.missRate()).isEqualTo(0.0);\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n     assertThat(stats.loadExceptionRate()).isEqualTo(0.0);\n-    assertEquals(0, stats.loadCount());\n-    assertEquals(0, stats.totalLoadTime());\n+    assertThat(stats.loadCount()).isEqualTo(0);\n+    assertThat(stats.totalLoadTime()).isEqualTo(0);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n   }\n \n   public void testSingle() {\n     CacheStats stats = new CacheStats(11, 13, 17, 19, 23, 27);\n-    assertEquals(24, stats.requestCount());\n-    assertEquals(11, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(24);\n+    assertThat(stats.hitCount()).isEqualTo(11);\n     assertThat(stats.hitRate()).isEqualTo(11.0 / 24);\n-    assertEquals(13, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(13);\n     assertThat(stats.missRate()).isEqualTo(13.0 / 24);\n-    assertEquals(17, stats.loadSuccessCount());\n-    assertEquals(19, stats.loadExceptionCount());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(17);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(19);\n     assertThat(stats.loadExceptionRate()).isEqualTo(19.0 / 36);\n-    assertEquals(17 + 19, stats.loadCount());\n-    assertEquals(23, stats.totalLoadTime());\n+    assertThat(stats.loadCount()).isEqualTo(17 + 19);\n+    assertThat(stats.totalLoadTime()).isEqualTo(23);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(23.0 / (17 + 19));\n-    assertEquals(27, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(27);\n   }\n \n   public void testMinus() {\n     CacheStats one = new CacheStats(11, 13, 17, 19, 23, 27);\n     CacheStats two = new CacheStats(53, 47, 43, 41, 37, 31);\n \n     CacheStats diff = two.minus(one);\n-    assertEquals(76, diff.requestCount());\n-    assertEquals(42, diff.hitCount());\n+    assertThat(diff.requestCount()).isEqualTo(76);\n+    assertThat(diff.hitCount()).isEqualTo(42);\n     assertThat(diff.hitRate()).isEqualTo(42.0 / 76);\n-    assertEquals(34, diff.missCount());\n+    assertThat(diff.missCount()).isEqualTo(34);\n     assertThat(diff.missRate()).isEqualTo(34.0 / 76);\n-    assertEquals(26, diff.loadSuccessCount());\n-    assertEquals(22, diff.loadExceptionCount());\n+    assertThat(diff.loadSuccessCount()).isEqualTo(26);\n+    assertThat(diff.loadExceptionCount()).isEqualTo(22);\n     assertThat(diff.loadExceptionRate()).isEqualTo(22.0 / 48);\n-    assertEquals(26 + 22, diff.loadCount());\n-    assertEquals(14, diff.totalLoadTime());\n+    assertThat(diff.loadCount()).isEqualTo(26 + 22);\n+    assertThat(diff.totalLoadTime()).isEqualTo(14);\n     assertThat(diff.averageLoadPenalty()).isEqualTo(14.0 / (26 + 22));\n-    assertEquals(4, diff.evictionCount());\n+    assertThat(diff.evictionCount()).isEqualTo(4);\n \n-    assertEquals(new CacheStats(0, 0, 0, 0, 0, 0), one.minus(two));\n+    assertThat(one.minus(two)).isEqualTo(new CacheStats(0, 0, 0, 0, 0, 0));\n   }\n \n   public void testPlus() {\n     CacheStats one = new CacheStats(11, 13, 15, 13, 11, 9);\n     CacheStats two = new CacheStats(53, 47, 41, 39, 37, 35);\n \n     CacheStats sum = two.plus(one);\n-    assertEquals(124, sum.requestCount());\n-    assertEquals(64, sum.hitCount());\n+    assertThat(sum.requestCount()).isEqualTo(124);\n+    assertThat(sum.hitCount()).isEqualTo(64);\n     assertThat(sum.hitRate()).isEqualTo(64.0 / 124);\n-    assertEquals(60, sum.missCount());\n+    assertThat(sum.missCount()).isEqualTo(60);\n     assertThat(sum.missRate()).isEqualTo(60.0 / 124);\n-    assertEquals(56, sum.loadSuccessCount());\n-    assertEquals(52, sum.loadExceptionCount());\n+    assertThat(sum.loadSuccessCount()).isEqualTo(56);\n+    assertThat(sum.loadExceptionCount()).isEqualTo(52);\n     assertThat(sum.loadExceptionRate()).isEqualTo(52.0 / 108);\n-    assertEquals(56 + 52, sum.loadCount());\n-    assertEquals(48, sum.totalLoadTime());\n+    assertThat(sum.loadCount()).isEqualTo(56 + 52);\n+    assertThat(sum.totalLoadTime()).isEqualTo(48);\n     assertThat(sum.averageLoadPenalty()).isEqualTo(48.0 / (56 + 52));\n-    assertEquals(44, sum.evictionCount());\n+    assertThat(sum.evictionCount()).isEqualTo(44);\n \n-    assertEquals(sum, one.plus(two));\n+    assertThat(one.plus(two)).isEqualTo(sum);\n   }\n \n   public void testPlusLarge() {\n@@ -115,19 +115,19 @@ public void testPlusLarge() {\n     CacheStats smallCacheStats = new CacheStats(1, 1, 1, 1, 1, 1);\n \n     CacheStats sum = smallCacheStats.plus(maxCacheStats);\n-    assertEquals(Long.MAX_VALUE, sum.requestCount());\n-    assertEquals(Long.MAX_VALUE, sum.hitCount());\n+    assertThat(sum.requestCount()).isEqualTo(Long.MAX_VALUE);\n+    assertThat(sum.hitCount()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.hitRate()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.missCount());\n+    assertThat(sum.missCount()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.missRate()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.loadSuccessCount());\n-    assertEquals(Long.MAX_VALUE, sum.loadExceptionCount());\n+    assertThat(sum.loadSuccessCount()).isEqualTo(Long.MAX_VALUE);\n+    assertThat(sum.loadExceptionCount()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.loadExceptionRate()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.loadCount());\n-    assertEquals(Long.MAX_VALUE, sum.totalLoadTime());\n+    assertThat(sum.loadCount()).isEqualTo(Long.MAX_VALUE);\n+    assertThat(sum.totalLoadTime()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.averageLoadPenalty()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.evictionCount());\n+    assertThat(sum.evictionCount()).isEqualTo(Long.MAX_VALUE);\n \n-    assertEquals(sum, maxCacheStats.plus(smallCacheStats));\n+    assertThat(maxCacheStats.plus(smallCacheStats)).isEqualTo(sum);\n   }\n }"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/CacheTesting.java",
      "status": "modified",
      "additions": 56,
      "deletions": 57,
      "changes": 113,
      "patch": "@@ -16,15 +16,9 @@\n \n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.lang.Math.max;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n-import static junit.framework.Assert.assertEquals;\n-import static junit.framework.Assert.assertFalse;\n-import static junit.framework.Assert.assertNotNull;\n-import static junit.framework.Assert.assertNotSame;\n-import static junit.framework.Assert.assertNull;\n-import static junit.framework.Assert.assertSame;\n-import static junit.framework.Assert.assertTrue;\n \n import com.google.common.base.Preconditions;\n import com.google.common.cache.LocalCache.LocalLoadingCache;\n@@ -194,16 +188,16 @@ static void checkValidState(Cache<?, ?> cache) {\n   static void checkValidState(LocalCache<?, ?> cchm) {\n     for (Segment<?, ?> segment : cchm.segments) {\n       segment.cleanUp();\n-      assertFalse(segment.isLocked());\n+      assertThat(segment.isLocked()).isFalse();\n       Map<?, ?> table = segmentTable(segment);\n       // cleanup and then check count after we have a strong reference to all entries\n       segment.cleanUp();\n       // under high memory pressure keys/values may be nulled out but not yet enqueued\n       assertThat(table.size()).isAtMost(segment.count);\n       for (Entry<?, ?> entry : table.entrySet()) {\n-        assertNotNull(entry.getKey());\n-        assertNotNull(entry.getValue());\n-        assertSame(entry.getValue(), cchm.get(entry.getKey()));\n+        assertThat(entry.getKey()).isNotNull();\n+        assertThat(entry.getValue()).isNotNull();\n+        assertThat(cchm.get(entry.getKey())).isSameInstanceAs(entry.getValue());\n       }\n     }\n     checkEviction(cchm);\n@@ -228,46 +222,47 @@ static void checkExpiration(LocalCache<?, ?> cchm) {\n \n         ReferenceEntry<?, ?> prev = null;\n         for (ReferenceEntry<?, ?> current : segment.writeQueue) {\n-          assertTrue(entries.add(current));\n+          assertThat(entries.add(current)).isTrue();\n           if (prev != null) {\n-            assertSame(prev, current.getPreviousInWriteQueue());\n-            assertSame(prev.getNextInWriteQueue(), current);\n+            assertThat(current.getPreviousInWriteQueue()).isSameInstanceAs(prev);\n+            assertThat(current).isSameInstanceAs(prev.getNextInWriteQueue());\n             assertThat(prev.getWriteTime()).isAtMost(current.getWriteTime());\n           }\n           Object key = current.getKey();\n           if (key != null) {\n-            assertSame(current, segment.getEntry(key, current.getHash()));\n+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);\n           }\n           prev = current;\n         }\n-        assertEquals(segment.count, entries.size());\n+        assertThat(entries).hasSize(segment.count);\n       } else {\n-        assertTrue(segment.writeQueue.isEmpty());\n+        assertThat(segment.writeQueue.isEmpty()).isTrue();\n       }\n \n       if (cchm.usesAccessQueue()) {\n         Set<ReferenceEntry<?, ?>> entries = Sets.newIdentityHashSet();\n \n         ReferenceEntry<?, ?> prev = null;\n         for (ReferenceEntry<?, ?> current : segment.accessQueue) {\n-          assertTrue(entries.add(current));\n+          assertThat(entries.add(current)).isTrue();\n           if (prev != null) {\n-            assertSame(prev, current.getPreviousInAccessQueue());\n-            assertSame(prev.getNextInAccessQueue(), current);\n+            assertThat(current.getPreviousInAccessQueue()).isSameInstanceAs(prev);\n+            assertThat(current).isSameInstanceAs(prev.getNextInAccessQueue());\n             // read accesses may be slightly misordered\n-            assertTrue(\n-                prev.getAccessTime() <= current.getAccessTime()\n-                    || prev.getAccessTime() - current.getAccessTime() < 1000);\n+            assertThat(\n+                    prev.getAccessTime() <= current.getAccessTime()\n+                        || prev.getAccessTime() - current.getAccessTime() < 1000)\n+                .isTrue();\n           }\n           Object key = current.getKey();\n           if (key != null) {\n-            assertSame(current, segment.getEntry(key, current.getHash()));\n+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);\n           }\n           prev = current;\n         }\n-        assertEquals(segment.count, entries.size());\n+        assertThat(entries).hasSize(segment.count);\n       } else {\n-        assertTrue(segment.accessQueue.isEmpty());\n+        assertThat(segment.accessQueue).isEmpty();\n       }\n     }\n   }\n@@ -287,25 +282,25 @@ static void checkEviction(LocalCache<?, ?> map) {\n     if (map.evictsBySize()) {\n       for (Segment<?, ?> segment : map.segments) {\n         drainRecencyQueue(segment);\n-        assertEquals(0, segment.recencyQueue.size());\n-        assertEquals(0, segment.readCount.get());\n+        assertThat(segment.recencyQueue).isEmpty();\n+        assertThat(segment.readCount.get()).isEqualTo(0);\n \n         ReferenceEntry<?, ?> prev = null;\n         for (ReferenceEntry<?, ?> current : segment.accessQueue) {\n           if (prev != null) {\n-            assertSame(prev, current.getPreviousInAccessQueue());\n-            assertSame(prev.getNextInAccessQueue(), current);\n+            assertThat(current.getPreviousInAccessQueue()).isSameInstanceAs(prev);\n+            assertThat(current).isSameInstanceAs(prev.getNextInAccessQueue());\n           }\n           Object key = current.getKey();\n           if (key != null) {\n-            assertSame(current, segment.getEntry(key, current.getHash()));\n+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);\n           }\n           prev = current;\n         }\n       }\n     } else {\n       for (Segment<?, ?> segment : map.segments) {\n-        assertEquals(0, segment.recencyQueue.size());\n+        assertThat(segment.recencyQueue).isEmpty();\n       }\n     }\n   }\n@@ -323,7 +318,7 @@ static <K, V> Map<K, V> segmentTable(Segment<K, V> segment) {\n         K key = entry.getKey();\n         V value = entry.getValueReference().get();\n         if (key != null && value != null) {\n-          assertNull(map.put(key, value));\n+          assertThat(map.put(key, value)).isNull();\n         }\n       }\n     }\n@@ -390,17 +385,17 @@ static void checkRecency(\n       LocalCache<Integer, Integer> cchm = toLocalCache(cache);\n       Segment<?, ?> segment = cchm.segments[0];\n       drainRecencyQueue(segment);\n-      assertEquals(maxSize, accessQueueSize(cache));\n-      assertEquals(maxSize, cache.size());\n+      assertThat(accessQueueSize(cache)).isEqualTo(maxSize);\n+      assertThat(cache.size()).isEqualTo(maxSize);\n \n       ReferenceEntry<?, ?> originalHead = segment.accessQueue.peek();\n       @SuppressWarnings(\"unchecked\")\n       ReferenceEntry<Integer, Integer> entry = (ReferenceEntry<Integer, Integer>) originalHead;\n       operation.accept(entry);\n       drainRecencyQueue(segment);\n \n-      assertNotSame(originalHead, segment.accessQueue.peek());\n-      assertEquals(cache.size(), accessQueueSize(cache));\n+      assertThat(segment.accessQueue.peek()).isNotSameInstanceAs(originalHead);\n+      assertThat(accessQueueSize(cache)).isEqualTo(cache.size());\n     }\n   }\n \n@@ -428,9 +423,13 @@ static void expireEntries(LocalCache<?, ?> cchm, long expiringTime, FakeTicker t\n     long now = ticker.read();\n     for (Segment<?, ?> segment : cchm.segments) {\n       expireEntries(segment, now);\n-      assertEquals(\"Expiration queue must be empty by now\", 0, writeQueueSize(segment));\n-      assertEquals(\"Expiration queue must be empty by now\", 0, accessQueueSize(segment));\n-      assertEquals(\"Segments must be empty by now\", 0, segmentSize(segment));\n+      assertWithMessage(\"Expiration queue must be empty by now\")\n+          .that(writeQueueSize(segment))\n+          .isEqualTo(0);\n+      assertWithMessage(\"Expiration queue must be empty by now\")\n+          .that(accessQueueSize(segment))\n+          .isEqualTo(0);\n+      assertWithMessage(\"Segments must be empty by now\").that(segmentSize(segment)).isEqualTo(0);\n     }\n     cchm.processPendingNotifications();\n   }\n@@ -446,41 +445,41 @@ static void expireEntries(Segment<?, ?> segment, long now) {\n   }\n \n   static void checkEmpty(Cache<?, ?> cache) {\n-    assertEquals(0, cache.size());\n-    assertFalse(cache.asMap().containsKey(null));\n-    assertFalse(cache.asMap().containsKey(6));\n-    assertFalse(cache.asMap().containsValue(null));\n-    assertFalse(cache.asMap().containsValue(6));\n+    assertThat(cache.size()).isEqualTo(0);\n+    assertThat(cache.asMap().containsKey(null)).isFalse();\n+    assertThat(cache.asMap().containsKey(6)).isFalse();\n+    assertThat(cache.asMap().containsValue(null)).isFalse();\n+    assertThat(cache.asMap().containsValue(6)).isFalse();\n     checkEmpty(cache.asMap());\n   }\n \n   static void checkEmpty(ConcurrentMap<?, ?> map) {\n     checkEmpty(map.keySet());\n     checkEmpty(map.values());\n     checkEmpty(map.entrySet());\n-    assertEquals(ImmutableMap.of(), map);\n-    assertEquals(ImmutableMap.of().hashCode(), map.hashCode());\n-    assertEquals(ImmutableMap.of().toString(), map.toString());\n+    assertThat(map).isEqualTo(ImmutableMap.of());\n+    assertThat(map.hashCode()).isEqualTo(ImmutableMap.of().hashCode());\n+    assertThat(map.toString()).isEqualTo(ImmutableMap.of().toString());\n \n     if (map instanceof LocalCache) {\n       LocalCache<?, ?> cchm = (LocalCache<?, ?>) map;\n \n       checkValidState(cchm);\n-      assertTrue(cchm.isEmpty());\n-      assertEquals(0, cchm.size());\n+      assertThat(cchm.isEmpty()).isTrue();\n+      assertThat(cchm).isEmpty();\n       for (LocalCache.Segment<?, ?> segment : cchm.segments) {\n-        assertEquals(0, segment.count);\n-        assertEquals(0, segmentSize(segment));\n-        assertTrue(segment.writeQueue.isEmpty());\n-        assertTrue(segment.accessQueue.isEmpty());\n+        assertThat(segment.count).isEqualTo(0);\n+        assertThat(segmentSize(segment)).isEqualTo(0);\n+        assertThat(segment.writeQueue.isEmpty()).isTrue();\n+        assertThat(segment.accessQueue.isEmpty()).isTrue();\n       }\n     }\n   }\n \n   static void checkEmpty(Collection<?> collection) {\n-    assertTrue(collection.isEmpty());\n-    assertEquals(0, collection.size());\n-    assertFalse(collection.iterator().hasNext());\n+    assertThat(collection.isEmpty()).isTrue();\n+    assertThat(collection).isEmpty();\n+    assertThat(collection.iterator().hasNext()).isFalse();\n     assertThat(collection.toArray()).isEmpty();\n     assertThat(collection.toArray(new Object[0])).isEmpty();\n     if (collection instanceof Set) {"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/EmptyCachesTest.java",
      "status": "modified",
      "additions": 32,
      "deletions": 31,
      "changes": 63,
      "patch": "@@ -16,6 +16,7 @@\n \n import static com.google.common.cache.CacheTesting.checkEmpty;\n import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.Arrays.asList;\n import static java.util.concurrent.TimeUnit.DAYS;\n import static java.util.concurrent.TimeUnit.SECONDS;\n@@ -75,7 +76,7 @@ public void testInvalidateAll_empty() {\n \n   public void testEquals_null() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n-      assertFalse(cache.equals(null));\n+      assertThat(cache.equals(null)).isFalse();\n     }\n   }\n \n@@ -138,11 +139,11 @@ public void testKeySet_clear() {\n   public void testKeySet_empty_remove() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       Set<Object> keys = cache.asMap().keySet();\n-      assertFalse(keys.remove(null));\n-      assertFalse(keys.remove(6));\n-      assertFalse(keys.remove(-6));\n-      assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(keys.remove(null)).isFalse();\n+      assertThat(keys.remove(6)).isFalse();\n+      assertThat(keys.remove(-6)).isFalse();\n+      assertThat(keys.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(keys.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(keys);\n       checkEmpty(cache);\n     }\n@@ -158,11 +159,11 @@ public void testKeySet_remove() {\n       // values of these removes, but the cache should be empty after the removes, regardless.\n       keys.remove(1);\n       keys.remove(2);\n-      assertFalse(keys.remove(null));\n-      assertFalse(keys.remove(6));\n-      assertFalse(keys.remove(-6));\n-      assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(keys.remove(null)).isFalse();\n+      assertThat(keys.remove(6)).isFalse();\n+      assertThat(keys.remove(-6)).isFalse();\n+      assertThat(keys.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(keys.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(keys);\n       checkEmpty(cache);\n     }\n@@ -202,11 +203,11 @@ public void testValues_clear() {\n   public void testValues_empty_remove() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       Collection<Object> values = cache.asMap().values();\n-      assertFalse(values.remove(null));\n-      assertFalse(values.remove(6));\n-      assertFalse(values.remove(-6));\n-      assertFalse(values.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(values.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(values.remove(null)).isFalse();\n+      assertThat(values.remove(6)).isFalse();\n+      assertThat(values.remove(-6)).isFalse();\n+      assertThat(values.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(values.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(values);\n       checkEmpty(cache);\n     }\n@@ -222,11 +223,11 @@ public void testValues_remove() {\n       // values of these removes, but the cache should be empty after the removes, regardless.\n       values.remove(1);\n       values.remove(2);\n-      assertFalse(values.remove(null));\n-      assertFalse(values.remove(6));\n-      assertFalse(values.remove(-6));\n-      assertFalse(values.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(values.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(values.remove(null)).isFalse();\n+      assertThat(values.remove(6)).isFalse();\n+      assertThat(values.remove(-6)).isFalse();\n+      assertThat(values.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(values.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(values);\n       checkEmpty(cache);\n     }\n@@ -269,11 +270,11 @@ public void testEntrySet_clear() {\n   public void testEntrySet_empty_remove() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       Set<Entry<Object, Object>> entrySet = cache.asMap().entrySet();\n-      assertFalse(entrySet.remove(null));\n-      assertFalse(entrySet.remove(entryOf(6, 6)));\n-      assertFalse(entrySet.remove(entryOf(-6, -6)));\n-      assertFalse(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15))));\n-      assertFalse(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15))));\n+      assertThat(entrySet.remove(null)).isFalse();\n+      assertThat(entrySet.remove(entryOf(6, 6))).isFalse();\n+      assertThat(entrySet.remove(entryOf(-6, -6))).isFalse();\n+      assertThat(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15)))).isFalse();\n+      assertThat(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15)))).isFalse();\n       checkEmpty(entrySet);\n       checkEmpty(cache);\n     }\n@@ -289,11 +290,11 @@ public void testEntrySet_remove() {\n       // values of these removes, but the cache should be empty after the removes, regardless.\n       entrySet.remove(entryOf(1, 1));\n       entrySet.remove(entryOf(2, 2));\n-      assertFalse(entrySet.remove(null));\n-      assertFalse(entrySet.remove(entryOf(1, 1)));\n-      assertFalse(entrySet.remove(entryOf(6, 6)));\n-      assertFalse(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15))));\n-      assertFalse(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15))));\n+      assertThat(entrySet.remove(null)).isFalse();\n+      assertThat(entrySet.remove(entryOf(1, 1))).isFalse();\n+      assertThat(entrySet.remove(entryOf(6, 6))).isFalse();\n+      assertThat(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15)))).isFalse();\n+      assertThat(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15)))).isFalse();\n       checkEmpty(entrySet);\n       checkEmpty(cache);\n     }"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java",
      "status": "modified",
      "additions": 10,
      "deletions": 9,
      "changes": 19,
      "patch": "@@ -16,12 +16,14 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.errorprone.annotations.Keep;\n import java.util.concurrent.ExecutionException;\n import junit.framework.TestCase;\n import org.jspecify.annotations.NullUnmarked;\n@@ -56,15 +58,13 @@ protected Cache<String, Boolean> delegate() {\n   }\n \n   public void testGetIfPresent() throws ExecutionException {\n-    when(mock.getIfPresent(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.getIfPresent(\"key\"));\n+    when(mock.getIfPresent(\"key\")).thenReturn(true);\n+    assertThat(forward.getIfPresent(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testGetAllPresent() throws ExecutionException {\n-    when(mock.getAllPresent(ImmutableList.of(\"key\")))\n-        .thenReturn(ImmutableMap.of(\"key\", Boolean.TRUE));\n-    assertEquals(\n-        ImmutableMap.of(\"key\", Boolean.TRUE), forward.getAllPresent(ImmutableList.of(\"key\")));\n+    when(mock.getAllPresent(ImmutableList.of(\"key\"))).thenReturn(ImmutableMap.of(\"key\", true));\n+    assertThat(forward.getAllPresent(ImmutableList.of(\"key\"))).containsExactly(\"key\", true);\n   }\n \n   public void testInvalidate() {\n@@ -84,17 +84,17 @@ public void testInvalidateAll() {\n \n   public void testSize() {\n     when(mock.size()).thenReturn(0L);\n-    assertEquals(0, forward.size());\n+    assertThat(forward.size()).isEqualTo(0);\n   }\n \n   public void testStats() {\n     when(mock.stats()).thenReturn(null);\n-    assertNull(forward.stats());\n+    assertThat(forward.stats()).isNull();\n   }\n \n   public void testAsMap() {\n     when(mock.asMap()).thenReturn(null);\n-    assertNull(forward.asMap());\n+    assertThat(forward.asMap()).isNull();\n   }\n \n   public void testCleanUp() {\n@@ -103,6 +103,7 @@ public void testCleanUp() {\n   }\n \n   /** Make sure that all methods are forwarded. */\n+  @Keep\n   private static class OnlyGet<K, V> extends ForwardingCache<K, V> {\n     @Override\n     protected Cache<K, V> delegate() {"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java",
      "status": "modified",
      "additions": 13,
      "deletions": 10,
      "changes": 23,
      "patch": "@@ -16,12 +16,14 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.errorprone.annotations.Keep;\n import java.util.concurrent.ExecutionException;\n import junit.framework.TestCase;\n import org.jspecify.annotations.NullUnmarked;\n@@ -56,23 +58,23 @@ protected LoadingCache<String, Boolean> delegate() {\n   }\n \n   public void testGet() throws ExecutionException {\n-    when(mock.get(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.get(\"key\"));\n+    when(mock.get(\"key\")).thenReturn(true);\n+    assertThat(forward.get(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testGetUnchecked() {\n-    when(mock.getUnchecked(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.getUnchecked(\"key\"));\n+    when(mock.getUnchecked(\"key\")).thenReturn(true);\n+    assertThat(forward.getUnchecked(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testGetAll() throws ExecutionException {\n-    when(mock.getAll(ImmutableList.of(\"key\"))).thenReturn(ImmutableMap.of(\"key\", Boolean.TRUE));\n-    assertEquals(ImmutableMap.of(\"key\", Boolean.TRUE), forward.getAll(ImmutableList.of(\"key\")));\n+    when(mock.getAll(ImmutableList.of(\"key\"))).thenReturn(ImmutableMap.of(\"key\", true));\n+    assertThat(forward.getAll(ImmutableList.of(\"key\"))).containsExactly(\"key\", true);\n   }\n \n   public void testApply() {\n-    when(mock.apply(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.apply(\"key\"));\n+    when(mock.apply(\"key\")).thenReturn(true);\n+    assertThat(forward.apply(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testInvalidate() {\n@@ -97,12 +99,12 @@ public void testSize() {\n \n   public void testStats() {\n     when(mock.stats()).thenReturn(null);\n-    assertNull(forward.stats());\n+    assertThat(forward.stats()).isNull();\n   }\n \n   public void testAsMap() {\n     when(mock.asMap()).thenReturn(null);\n-    assertNull(forward.asMap());\n+    assertThat(forward.asMap()).isNull();\n   }\n \n   public void testCleanUp() {\n@@ -111,6 +113,7 @@ public void testCleanUp() {\n   }\n \n   /** Make sure that all methods are forwarded. */\n+  @Keep\n   private static class OnlyGet<K, V> extends ForwardingLoadingCache<K, V> {\n     @Override\n     protected LoadingCache<K, V> delegate() {"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/LocalCacheTest.java",
      "status": "modified",
      "additions": 517,
      "deletions": 498,
      "changes": 1015,
      "patch": "@@ -27,6 +27,7 @@\n import static com.google.common.cache.TestingWeighers.constantWeigher;\n import static com.google.common.collect.Maps.immutableEntry;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n import static java.lang.Math.max;\n import static java.lang.Thread.State.WAITING;\n@@ -247,18 +248,18 @@ public void tearDown() throws Exception {\n \n   private Throwable popLoggedThrowable() {\n     List<LogRecord> logRecords = logHandler.getStoredLogRecords();\n-    assertEquals(1, logRecords.size());\n+    assertThat(logRecords).hasSize(1);\n     LogRecord logRecord = logRecords.get(0);\n     logHandler.clear();\n     return logRecord.getThrown();\n   }\n \n   private void checkNothingLogged() {\n-    assertTrue(logHandler.getStoredLogRecords().isEmpty());\n+    assertThat(logHandler.getStoredLogRecords().isEmpty()).isTrue();\n   }\n \n   private void checkLogged(Throwable t) {\n-    assertSame(t, popLoggedThrowable());\n+    assertThat(popLoggedThrowable()).isSameInstanceAs(t);\n   }\n \n   /*\n@@ -288,33 +289,33 @@ private static CacheBuilder<Object, Object> createCacheBuilder() {\n   public void testDefaults() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n \n-    assertSame(Strength.STRONG, map.keyStrength);\n-    assertSame(Strength.STRONG, map.valueStrength);\n-    assertSame(map.keyStrength.defaultEquivalence(), map.keyEquivalence);\n-    assertSame(map.valueStrength.defaultEquivalence(), map.valueEquivalence);\n+    assertThat(map.keyStrength).isEqualTo(Strength.STRONG);\n+    assertThat(map.valueStrength).isEqualTo(Strength.STRONG);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(map.keyStrength.defaultEquivalence());\n+    assertThat(map.valueEquivalence).isSameInstanceAs(map.valueStrength.defaultEquivalence());\n \n-    assertEquals(0, map.expireAfterAccessNanos);\n-    assertEquals(0, map.expireAfterWriteNanos);\n-    assertEquals(0, map.refreshNanos);\n-    assertEquals(CacheBuilder.UNSET_INT, map.maxWeight);\n+    assertThat(map.expireAfterAccessNanos).isEqualTo(0);\n+    assertThat(map.expireAfterWriteNanos).isEqualTo(0);\n+    assertThat(map.refreshNanos).isEqualTo(0);\n+    assertThat(map.maxWeight).isEqualTo(CacheBuilder.UNSET_INT);\n \n-    assertSame(EntryFactory.STRONG, map.entryFactory);\n-    assertSame(CacheBuilder.NullListener.INSTANCE, map.removalListener);\n-    assertSame(DISCARDING_QUEUE, map.removalNotificationQueue);\n-    assertSame(NULL_TICKER, map.ticker);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);\n+    assertThat(map.removalListener).isSameInstanceAs(CacheBuilder.NullListener.INSTANCE);\n+    assertThat(map.removalNotificationQueue).isSameInstanceAs(DISCARDING_QUEUE);\n+    assertThat(map.ticker).isSameInstanceAs(NULL_TICKER);\n \n-    assertEquals(4, map.concurrencyLevel);\n+    assertThat(map.concurrencyLevel).isEqualTo(4);\n \n     // concurrency level\n     assertThat(map.segments).hasLength(4);\n     // initial capacity / concurrency level\n-    assertEquals(16 / map.segments.length, map.segments[0].table.length());\n+    assertThat(map.segments[0].table.length()).isEqualTo(16 / map.segments.length);\n \n-    assertFalse(map.evictsBySize());\n-    assertFalse(map.expires());\n-    assertFalse(map.expiresAfterWrite());\n-    assertFalse(map.expiresAfterAccess());\n-    assertFalse(map.refreshes());\n+    assertThat(map.evictsBySize()).isFalse();\n+    assertThat(map.expires()).isFalse();\n+    assertThat(map.expiresAfterWrite()).isFalse();\n+    assertThat(map.expiresAfterAccess()).isFalse();\n+    assertThat(map.refreshes()).isFalse();\n   }\n \n   public void testSetKeyEquivalence() {\n@@ -333,8 +334,8 @@ protected int doHash(Object t) {\n \n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().keyEquivalence(testEquivalence));\n-    assertSame(testEquivalence, map.keyEquivalence);\n-    assertSame(map.valueStrength.defaultEquivalence(), map.valueEquivalence);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(testEquivalence);\n+    assertThat(map.valueEquivalence).isSameInstanceAs(map.valueStrength.defaultEquivalence());\n   }\n \n   public void testSetValueEquivalence() {\n@@ -353,8 +354,8 @@ protected int doHash(Object t) {\n \n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().valueEquivalence(testEquivalence));\n-    assertSame(testEquivalence, map.valueEquivalence);\n-    assertSame(map.keyStrength.defaultEquivalence(), map.keyEquivalence);\n+    assertThat(map.valueEquivalence).isSameInstanceAs(testEquivalence);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(map.keyStrength.defaultEquivalence());\n   }\n \n   public void testSetConcurrencyLevel() {\n@@ -418,7 +419,7 @@ private static void checkInitialCapacity(\n                 .concurrencyLevel(concurrencyLevel)\n                 .initialCapacity(initialCapacity));\n     for (int i = 0; i < map.segments.length; i++) {\n-      assertEquals(segmentSize, map.segments[i].table.length());\n+      assertThat(map.segments[i].table.length()).isEqualTo(segmentSize);\n     }\n   }\n \n@@ -455,13 +456,15 @@ private static void checkMaximumSize(int concurrencyLevel, int initialCapacity,\n                 .initialCapacity(initialCapacity)\n                 .maximumSize(maxSize));\n     long totalCapacity = 0;\n-    assertTrue(\n-        \"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n-        map.segments.length <= max(1, maxSize / 10));\n+    assertWithMessage(\"segments=%s, maxSize=%s\", map.segments.length, maxSize)\n+        .that((long) map.segments.length)\n+        .isAtMost(max(1, maxSize / 10));\n     for (int i = 0; i < map.segments.length; i++) {\n       totalCapacity += map.segments[i].maxSegmentWeight;\n     }\n-    assertTrue(\"totalCapacity=\" + totalCapacity + \", maxSize=\" + maxSize, totalCapacity == maxSize);\n+    assertWithMessage(\"totalCapacity=%s, maxSize=%s\", totalCapacity, maxSize)\n+        .that(totalCapacity)\n+        .isEqualTo(maxSize);\n \n     map =\n         makeLocalCache(\n@@ -470,14 +473,16 @@ private static void checkMaximumSize(int concurrencyLevel, int initialCapacity,\n                 .initialCapacity(initialCapacity)\n                 .maximumWeight(maxSize)\n                 .weigher(constantWeigher(1)));\n-    assertTrue(\n-        \"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n-        map.segments.length <= max(1, maxSize / 10));\n+    assertWithMessage(\"segments=%s, maxSize=%s\", map.segments.length, maxSize)\n+        .that((long) map.segments.length)\n+        .isAtMost(max(1, maxSize / 10));\n     totalCapacity = 0;\n     for (int i = 0; i < map.segments.length; i++) {\n       totalCapacity += map.segments[i].maxSegmentWeight;\n     }\n-    assertTrue(\"totalCapacity=\" + totalCapacity + \", maxSize=\" + maxSize, totalCapacity == maxSize);\n+    assertWithMessage(\"totalCapacity=%s, maxSize=%s\", totalCapacity, maxSize)\n+        .that(totalCapacity)\n+        .isEqualTo(maxSize);\n   }\n \n   public void testSetWeigher() {\n@@ -490,57 +495,57 @@ public int weigh(Object key, Object value) {\n         };\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().maximumWeight(1).weigher(testWeigher));\n-    assertSame(testWeigher, map.weigher);\n+    assertThat(map.weigher).isSameInstanceAs(testWeigher);\n   }\n \n   public void testSetWeakKeys() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().weakKeys());\n     checkStrength(map, Strength.WEAK, Strength.STRONG);\n-    assertSame(EntryFactory.WEAK, map.entryFactory);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.WEAK);\n   }\n \n   public void testSetWeakValues() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().weakValues());\n     checkStrength(map, Strength.STRONG, Strength.WEAK);\n-    assertSame(EntryFactory.STRONG, map.entryFactory);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);\n   }\n \n   public void testSetSoftValues() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().softValues());\n     checkStrength(map, Strength.STRONG, Strength.SOFT);\n-    assertSame(EntryFactory.STRONG, map.entryFactory);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);\n   }\n \n   private static void checkStrength(\n       LocalCache<Object, Object> map, Strength keyStrength, Strength valueStrength) {\n-    assertSame(keyStrength, map.keyStrength);\n-    assertSame(valueStrength, map.valueStrength);\n-    assertSame(keyStrength.defaultEquivalence(), map.keyEquivalence);\n-    assertSame(valueStrength.defaultEquivalence(), map.valueEquivalence);\n+    assertThat(map.keyStrength).isSameInstanceAs(keyStrength);\n+    assertThat(map.valueStrength).isSameInstanceAs(valueStrength);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(keyStrength.defaultEquivalence());\n+    assertThat(map.valueEquivalence).isSameInstanceAs(valueStrength.defaultEquivalence());\n   }\n \n   public void testSetExpireAfterWrite() {\n     long duration = 42;\n     TimeUnit unit = SECONDS;\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().expireAfterWrite(duration, unit));\n-    assertEquals(unit.toNanos(duration), map.expireAfterWriteNanos);\n+    assertThat(map.expireAfterWriteNanos).isEqualTo(unit.toNanos(duration));\n   }\n \n   public void testSetExpireAfterAccess() {\n     long duration = 42;\n     TimeUnit unit = SECONDS;\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().expireAfterAccess(duration, unit));\n-    assertEquals(unit.toNanos(duration), map.expireAfterAccessNanos);\n+    assertThat(map.expireAfterAccessNanos).isEqualTo(unit.toNanos(duration));\n   }\n \n   public void testSetRefresh() {\n     long duration = 42;\n     TimeUnit unit = SECONDS;\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().refreshAfterWrite(duration, unit));\n-    assertEquals(unit.toNanos(duration), map.refreshNanos);\n+    assertThat(map.refreshNanos).isEqualTo(unit.toNanos(duration));\n   }\n \n   public void testLongAsyncRefresh() throws Exception {\n@@ -599,7 +604,7 @@ public void testSetRemovalListener() {\n     RemovalListener<Object, Object> testListener = TestingRemovalListeners.nullRemovalListener();\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().removalListener(testListener));\n-    assertSame(testListener, map.removalListener);\n+    assertThat(map.removalListener).isSameInstanceAs(testListener);\n   }\n \n   public void testSetTicker() {\n@@ -611,33 +616,40 @@ public long read() {\n           }\n         };\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().ticker(testTicker));\n-    assertSame(testTicker, map.ticker);\n+    assertThat(map.ticker).isSameInstanceAs(testTicker);\n   }\n \n   public void testEntryFactory() {\n-    assertSame(EntryFactory.STRONG, EntryFactory.getFactory(Strength.STRONG, false, false));\n-    assertSame(EntryFactory.STRONG_ACCESS, EntryFactory.getFactory(Strength.STRONG, true, false));\n-    assertSame(EntryFactory.STRONG_WRITE, EntryFactory.getFactory(Strength.STRONG, false, true));\n-    assertSame(\n-        EntryFactory.STRONG_ACCESS_WRITE, EntryFactory.getFactory(Strength.STRONG, true, true));\n-    assertSame(EntryFactory.WEAK, EntryFactory.getFactory(Strength.WEAK, false, false));\n-    assertSame(EntryFactory.WEAK_ACCESS, EntryFactory.getFactory(Strength.WEAK, true, false));\n-    assertSame(EntryFactory.WEAK_WRITE, EntryFactory.getFactory(Strength.WEAK, false, true));\n-    assertSame(EntryFactory.WEAK_ACCESS_WRITE, EntryFactory.getFactory(Strength.WEAK, true, true));\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, false, false))\n+        .isSameInstanceAs(EntryFactory.STRONG);\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, true, false))\n+        .isSameInstanceAs(EntryFactory.STRONG_ACCESS);\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, false, true))\n+        .isSameInstanceAs(EntryFactory.STRONG_WRITE);\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, true, true))\n+        .isSameInstanceAs(EntryFactory.STRONG_ACCESS_WRITE);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, false, false))\n+        .isSameInstanceAs(EntryFactory.WEAK);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, true, false))\n+        .isSameInstanceAs(EntryFactory.WEAK_ACCESS);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, false, true))\n+        .isSameInstanceAs(EntryFactory.WEAK_WRITE);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, true, true))\n+        .isSameInstanceAs(EntryFactory.WEAK_ACCESS_WRITE);\n   }\n \n   // computation tests\n \n   public void testCompute() throws ExecutionException {\n     CountingLoader loader = new CountingLoader();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     Object value = map.get(key, loader);\n-    assertEquals(1, loader.getCount());\n-    assertEquals(value, map.get(key, loader));\n-    assertEquals(1, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(1);\n+    assertThat(map.get(key, loader)).isEqualTo(value);\n+    assertThat(loader.getCount()).isEqualTo(1);\n   }\n \n   public void testRecordReadOnCompute() throws ExecutionException {\n@@ -659,7 +671,7 @@ public void testRecordReadOnCompute() throws ExecutionException {\n \n       checkEvictionQueues(map, segment, readOrder, writeOrder);\n       checkExpirationTimes(map);\n-      assertTrue(segment.recencyQueue.isEmpty());\n+      assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n       // access some of the elements\n       Random random = new Random();\n@@ -671,7 +683,7 @@ public void testRecordReadOnCompute() throws ExecutionException {\n           map.get(entry.getKey(), loader);\n           reads.add(entry);\n           i.remove();\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n       }\n       int undrainedIndex = reads.size() - segment.recencyQueue.size();\n@@ -686,14 +698,14 @@ public void testRecordReadOnCompute() throws ExecutionException {\n   public void testComputeExistingEntry() throws ExecutionException {\n     CountingLoader loader = new CountingLoader();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     Object value = new Object();\n     map.put(key, value);\n \n-    assertEquals(value, map.get(key, loader));\n-    assertEquals(0, loader.getCount());\n+    assertThat(map.get(key, loader)).isEqualTo(value);\n+    assertThat(loader.getCount()).isEqualTo(0);\n   }\n \n   public void testComputePartiallyCollectedKey() throws ExecutionException {\n@@ -702,7 +714,7 @@ public void testComputePartiallyCollectedKey() throws ExecutionException {\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     int hash = map.hash(key);\n@@ -715,14 +727,14 @@ public void testComputePartiallyCollectedKey() throws ExecutionException {\n     table.set(index, entry);\n     segment.count++;\n \n-    assertSame(value, map.get(key, loader));\n-    assertEquals(0, loader.getCount());\n-    assertEquals(1, segment.count);\n+    assertThat(map.get(key, loader)).isSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(1);\n \n     entry.clearKey();\n-    assertNotSame(value, map.get(key, loader));\n-    assertEquals(1, loader.getCount());\n-    assertEquals(2, segment.count);\n+    assertThat(map.get(key, loader)).isNotSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(1);\n+    assertThat(segment.count).isEqualTo(2);\n   }\n \n   public void testComputePartiallyCollectedValue() throws ExecutionException {\n@@ -731,7 +743,7 @@ public void testComputePartiallyCollectedValue() throws ExecutionException {\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     int hash = map.hash(key);\n@@ -744,40 +756,40 @@ public void testComputePartiallyCollectedValue() throws ExecutionException {\n     table.set(index, entry);\n     segment.count++;\n \n-    assertSame(value, map.get(key, loader));\n-    assertEquals(0, loader.getCount());\n-    assertEquals(1, segment.count);\n+    assertThat(map.get(key, loader)).isSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(1);\n \n     valueRef.clear();\n-    assertNotSame(value, map.get(key, loader));\n-    assertEquals(1, loader.getCount());\n-    assertEquals(1, segment.count);\n+    assertThat(map.get(key, loader)).isNotSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(1);\n+    assertThat(segment.count).isEqualTo(1);\n   }\n \n   @AndroidIncompatible // Perhaps emulator clock does not update between the two get() calls?\n   public void testComputeExpiredEntry() throws ExecutionException {\n     CacheBuilder<Object, Object> builder = createCacheBuilder().expireAfterWrite(1, NANOSECONDS);\n     CountingLoader loader = new CountingLoader();\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     Object one = map.get(key, loader);\n-    assertEquals(1, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(1);\n \n     Object two = map.get(key, loader);\n-    assertNotSame(one, two);\n-    assertEquals(2, loader.getCount());\n+    assertThat(two).isNotSameInstanceAs(one);\n+    assertThat(loader.getCount()).isEqualTo(2);\n   }\n \n   public void testValues() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n     map.put(\"foo\", \"bar\");\n     map.put(\"baz\", \"bar\");\n     map.put(\"quux\", \"quux\");\n-    assertFalse(map.values() instanceof Set);\n-    assertTrue(map.values().removeAll(ImmutableSet.of(\"bar\")));\n-    assertEquals(1, map.size());\n+    assertThat(map.values() instanceof Set).isFalse();\n+    assertThat(map.values().removeAll(ImmutableSet.of(\"bar\"))).isTrue();\n+    assertThat(map).hasSize(1);\n   }\n \n   public void testCopyEntry_computing() {\n@@ -802,7 +814,7 @@ public Object load(Object key) throws Exception {\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     int hash = map.hash(one);\n@@ -845,7 +857,7 @@ public void run() {\n     @SuppressWarnings(\"unchecked\")\n     LoadingValueReference<Object, Object> valueReference =\n         (LoadingValueReference) newEntry.getValueReference();\n-    assertFalse(valueReference.futureValue.isDone());\n+    assertThat(valueReference.futureValue.isDone()).isFalse();\n     startSignal.countDown();\n \n     try {\n@@ -855,10 +867,10 @@ public void run() {\n     }\n \n     map.cleanUp(); // force notifications\n-    assertTrue(listener.isEmpty());\n-    assertTrue(map.containsKey(one));\n-    assertEquals(1, map.size());\n-    assertSame(computedObject, map.get(one));\n+    assertThat(listener.isEmpty()).isTrue();\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map).hasSize(1);\n+    assertThat(map.get(one)).isSameInstanceAs(computedObject);\n   }\n \n   public void testRemovalListenerCheckedException() {\n@@ -900,7 +912,7 @@ public Object load(Object key) throws Exception {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     CacheBuilder<Object, Object> builder = createCacheBuilder().removalListener(listener);\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -924,7 +936,7 @@ public void run() {\n     }\n \n     map.put(one, two);\n-    assertSame(two, map.get(one));\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n     startSignal.countDown();\n \n     try {\n@@ -935,7 +947,7 @@ public void run() {\n \n     map.cleanUp(); // force notifications\n     assertNotified(listener, one, computedObject, RemovalCause.REPLACED);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testSegmentRefresh_duplicate() throws ExecutionException {\n@@ -961,7 +973,7 @@ public void testSegmentRefresh_duplicate() throws ExecutionException {\n   public void testRemovalListener_explicit() {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -996,13 +1008,13 @@ public void testRemovalListener_explicit() {\n     i.remove();\n     assertNotified(listener, five, six, RemovalCause.EXPLICIT);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testRemovalListener_replaced() {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1032,22 +1044,22 @@ public void testRemovalListener_collected() {\n         makeLocalCache(\n             createCacheBuilder().concurrencyLevel(1).softValues().removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n     Object three = new Object();\n \n     map.put(one, two);\n     map.put(two, three);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     int hash = map.hash(one);\n     ReferenceEntry<Object, Object> entry = segment.getEntry(one, hash);\n     map.reclaimValue(entry.getValueReference());\n     assertNotified(listener, one, two, RemovalCause.COLLECTED);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testRemovalListener_expired() {\n@@ -1060,7 +1072,7 @@ public void testRemovalListener_expired() {\n                 .expireAfterWrite(3, NANOSECONDS)\n                 .ticker(ticker)\n                 .removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1073,20 +1085,20 @@ public void testRemovalListener_expired() {\n     map.put(two, three);\n     ticker.advance(1);\n     map.put(three, four);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     ticker.advance(1);\n     map.put(four, five);\n     assertNotified(listener, one, two, RemovalCause.EXPIRED);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testRemovalListener_size() {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     LocalCache<Object, Object> map =\n         makeLocalCache(\n             createCacheBuilder().concurrencyLevel(1).maximumSize(2).removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1095,19 +1107,19 @@ public void testRemovalListener_size() {\n \n     map.put(one, two);\n     map.put(two, three);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     map.put(three, four);\n     assertNotified(listener, one, two, RemovalCause.SIZE);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   static <K, V> void assertNotified(\n       QueuingRemovalListener<K, V> listener, K key, V value, RemovalCause cause) {\n     RemovalNotification<K, V> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(value, notification.getValue());\n-    assertSame(cause, notification.getCause());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(value);\n+    assertThat(notification.getCause()).isSameInstanceAs(cause);\n   }\n \n   // Segment core tests\n@@ -1121,26 +1133,26 @@ public void testNewEntry() {\n       int hashOne = map.hash(keyOne);\n       ReferenceEntry<Object, Object> entryOne = map.newEntry(keyOne, hashOne, null);\n       ValueReference<Object, Object> valueRefOne = map.newValueReference(entryOne, valueOne, 1);\n-      assertSame(valueOne, valueRefOne.get());\n+      assertThat(valueRefOne.get()).isSameInstanceAs(valueOne);\n       entryOne.setValueReference(valueRefOne);\n \n-      assertSame(keyOne, entryOne.getKey());\n-      assertEquals(hashOne, entryOne.getHash());\n-      assertNull(entryOne.getNext());\n-      assertSame(valueRefOne, entryOne.getValueReference());\n+      assertThat(entryOne.getKey()).isSameInstanceAs(keyOne);\n+      assertThat(entryOne.getHash()).isEqualTo(hashOne);\n+      assertThat(entryOne.getNext()).isNull();\n+      assertThat(entryOne.getValueReference()).isSameInstanceAs(valueRefOne);\n \n       Object keyTwo = new Object();\n       Object valueTwo = new Object();\n       int hashTwo = map.hash(keyTwo);\n       ReferenceEntry<Object, Object> entryTwo = map.newEntry(keyTwo, hashTwo, entryOne);\n       ValueReference<Object, Object> valueRefTwo = map.newValueReference(entryTwo, valueTwo, 1);\n-      assertSame(valueTwo, valueRefTwo.get());\n+      assertThat(valueRefTwo.get()).isSameInstanceAs(valueTwo);\n       entryTwo.setValueReference(valueRefTwo);\n \n-      assertSame(keyTwo, entryTwo.getKey());\n-      assertEquals(hashTwo, entryTwo.getHash());\n-      assertSame(entryOne, entryTwo.getNext());\n-      assertSame(valueRefTwo, entryTwo.getValueReference());\n+      assertThat(entryTwo.getKey()).isSameInstanceAs(keyTwo);\n+      assertThat(entryTwo.getHash()).isEqualTo(hashTwo);\n+      assertThat(entryTwo.getNext()).isSameInstanceAs(entryOne);\n+      assertThat(entryTwo.getValueReference()).isSameInstanceAs(valueRefTwo);\n     }\n   }\n \n@@ -1168,28 +1180,28 @@ public void testCopyEntry() {\n       assertConnected(map, entryOne, entryTwo);\n \n       ReferenceEntry<Object, Object> copyOne = map.copyEntry(entryOne, null);\n-      assertSame(keyOne, entryOne.getKey());\n-      assertEquals(hashOne, entryOne.getHash());\n-      assertNull(entryOne.getNext());\n-      assertSame(valueOne, copyOne.getValueReference().get());\n+      assertThat(entryOne.getKey()).isSameInstanceAs(keyOne);\n+      assertThat(entryOne.getHash()).isEqualTo(hashOne);\n+      assertThat(entryOne.getNext()).isNull();\n+      assertThat(copyOne.getValueReference().get()).isSameInstanceAs(valueOne);\n       assertConnected(map, copyOne, entryTwo);\n \n       ReferenceEntry<Object, Object> copyTwo = map.copyEntry(entryTwo, copyOne);\n-      assertSame(keyTwo, copyTwo.getKey());\n-      assertEquals(hashTwo, copyTwo.getHash());\n-      assertSame(copyOne, copyTwo.getNext());\n-      assertSame(valueTwo, copyTwo.getValueReference().get());\n+      assertThat(copyTwo.getKey()).isSameInstanceAs(keyTwo);\n+      assertThat(copyTwo.getHash()).isEqualTo(hashTwo);\n+      assertThat(copyTwo.getNext()).isSameInstanceAs(copyOne);\n+      assertThat(copyTwo.getValueReference().get()).isSameInstanceAs(valueTwo);\n       assertConnected(map, copyOne, copyTwo);\n     }\n   }\n \n   private static <K, V> void assertConnected(\n       LocalCache<K, V> map, ReferenceEntry<K, V> one, ReferenceEntry<K, V> two) {\n     if (map.usesWriteQueue()) {\n-      assertSame(two, one.getNextInWriteQueue());\n+      assertThat(one.getNextInWriteQueue()).isSameInstanceAs(two);\n     }\n     if (map.usesAccessQueue()) {\n-      assertSame(two, one.getNextInAccessQueue());\n+      assertThat(one.getNextInAccessQueue()).isSameInstanceAs(two);\n     }\n   }\n \n@@ -1219,14 +1231,14 @@ public void testSegmentGetAndContains() {\n     // count == 0\n     table.set(index, entry);\n     assertNull(segment.get(key, hash));\n-    assertFalse(segment.containsKey(key, hash));\n-    assertFalse(segment.containsValue(value));\n+    assertThat(segment.containsKey(key, hash)).isFalse();\n+    assertThat(segment.containsValue(value)).isFalse();\n \n     // count == 1\n     segment.count++;\n-    assertSame(value, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n     // don't see absent values now that count > 0\n     assertNull(segment.get(new Object(), hash));\n \n@@ -1237,21 +1249,21 @@ public void testSegmentGetAndContains() {\n     nullEntry.setValueReference(nullValueRef);\n     table.set(index, nullEntry);\n     // skip the null key\n-    assertSame(value, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertFalse(segment.containsValue(nullValue));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(nullValue)).isFalse();\n \n     // hash collision\n     DummyEntry<Object, Object> dummy = DummyEntry.create(new Object(), hash, entry);\n     Object dummyValue = new Object();\n     ValueReference<Object, Object> dummyValueRef = map.newValueReference(dummy, dummyValue, 1);\n     dummy.setValueReference(dummyValueRef);\n     table.set(index, dummy);\n-    assertSame(value, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertTrue(segment.containsValue(dummyValue));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(dummyValue)).isTrue();\n \n     // key collision\n     dummy = DummyEntry.create(key, hash, entry);\n@@ -1260,17 +1272,17 @@ public void testSegmentGetAndContains() {\n     dummy.setValueReference(dummyValueRef);\n     table.set(index, dummy);\n     // returns the most recent entry\n-    assertSame(dummyValue, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertTrue(segment.containsValue(dummyValue));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(dummyValue);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(dummyValue)).isTrue();\n \n     // expired\n     dummy.setAccessTime(ticker.read() - 2);\n     assertNull(segment.get(key, hash));\n-    assertFalse(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertFalse(segment.containsValue(dummyValue));\n+    assertThat(segment.containsKey(key, hash)).isFalse();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(dummyValue)).isFalse();\n   }\n \n   public void testSegmentReplaceValue() {\n@@ -1291,29 +1303,29 @@ public void testSegmentReplaceValue() {\n     entry.setValueReference(oldValueRef);\n \n     // no entry\n-    assertFalse(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same value\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertTrue(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isTrue();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // different value\n-    assertFalse(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // cleared\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n-    assertFalse(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1336,23 +1348,23 @@ public void testSegmentReplace() {\n \n     // no entry\n     assertNull(segment.replace(key, hash, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same key\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertSame(oldValue, segment.replace(key, hash, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.replace(key, hash, newValue)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // cleared\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.replace(key, hash, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1368,24 +1380,24 @@ public void testSegmentPut() {\n     Object newValue = new Object();\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.put(key, hash, oldValue, false));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n \n     // same key\n-    assertSame(oldValue, segment.put(key, hash, newValue, false));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.put(key, hash, newValue, false)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // cleared\n     ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);\n     DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.put(key, hash, newValue, false));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n   }\n \n   public void testSegmentPutIfAbsent() {\n@@ -1400,39 +1412,39 @@ public void testSegmentPutIfAbsent() {\n     Object newValue = new Object();\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.put(key, hash, oldValue, true));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n \n     // same key\n-    assertSame(oldValue, segment.put(key, hash, newValue, true));\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.put(key, hash, newValue, true)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n \n     // cleared\n     ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);\n     DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.put(key, hash, newValue, true));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n   }\n \n   public void testSegmentPut_expand() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertEquals(1, segment.table.length());\n+    assertThat(segment.table.length()).isEqualTo(1);\n \n     int count = 1024;\n     for (int i = 0; i < count; i++) {\n       Object key = new Object();\n       Object value = new Object();\n       int hash = map.hash(key);\n       assertNull(segment.put(key, hash, value, false));\n-      assertTrue(segment.table.length() > i);\n+      assertThat(segment.table.length()).isGreaterThan(i);\n     }\n   }\n \n@@ -1454,7 +1466,7 @@ public void testSegmentPut_evict() {\n         it.next();\n         it.remove();\n       }\n-      assertEquals(originalMap, map);\n+      assertThat(map).isEqualTo(originalMap);\n     }\n   }\n \n@@ -1475,64 +1487,64 @@ public void testSegmentStoreComputedValue() {\n \n     // absent\n     Object value = new Object();\n-    assertTrue(listener.isEmpty());\n-    assertEquals(0, segment.count);\n+    assertThat(listener.isEmpty()).isTrue();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value));\n-    assertSame(value, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n-    assertTrue(listener.isEmpty());\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // clobbered\n     Object value2 = new Object();\n-    assertFalse(segment.storeLoadedValue(key, hash, valueRef, value2));\n-    assertEquals(1, segment.count);\n-    assertSame(value, segment.get(key, hash));\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value2)).isFalse();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertEquals(immutableEntry(key, value2), notification);\n-    assertEquals(RemovalCause.REPLACED, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification).isEqualTo(immutableEntry(key, value2));\n+    assertThat(notification.getCause()).isEqualTo(RemovalCause.REPLACED);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // inactive\n     Object value3 = new Object();\n     map.clear();\n     listener.clear();\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     table.set(index, entry);\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value3));\n-    assertSame(value3, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n-    assertTrue(listener.isEmpty());\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value3)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // replaced\n     Object value4 = new Object();\n     DummyValueReference<Object, Object> value3Ref = DummyValueReference.create(value3);\n     valueRef = new LoadingValueReference<>(value3Ref);\n     entry.setValueReference(valueRef);\n     table.set(index, entry);\n-    assertSame(value3, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));\n-    assertSame(value4, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value4)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value4);\n+    assertThat(segment.count).isEqualTo(1);\n     notification = listener.remove();\n-    assertEquals(immutableEntry(key, value3), notification);\n-    assertEquals(RemovalCause.REPLACED, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification).isEqualTo(immutableEntry(key, value3));\n+    assertThat(notification.getCause()).isEqualTo(RemovalCause.REPLACED);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // collected\n     entry.setValueReference(valueRef);\n     table.set(index, entry);\n-    assertSame(value3, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);\n+    assertThat(segment.count).isEqualTo(1);\n     value3Ref.clear();\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));\n-    assertSame(value4, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value4)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value4);\n+    assertThat(segment.count).isEqualTo(1);\n     notification = listener.remove();\n-    assertEquals(immutableEntry(key, null), notification);\n-    assertEquals(RemovalCause.COLLECTED, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification).isEqualTo(immutableEntry(key, null));\n+    assertThat(notification.getCause()).isEqualTo(RemovalCause.COLLECTED);\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testSegmentRemove() {\n@@ -1550,27 +1562,27 @@ public void testSegmentRemove() {\n     entry.setValueReference(oldValueRef);\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same key\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertSame(oldValue, segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.remove(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n \n     // cleared\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1590,41 +1602,41 @@ public void testSegmentRemoveValue() {\n     entry.setValueReference(oldValueRef);\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same value\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertTrue(segment.remove(key, hash, oldValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.remove(key, hash, oldValue)).isTrue();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n \n     // different value\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertFalse(segment.remove(key, hash, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.remove(key, hash, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n \n     // cleared\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n-    assertFalse(segment.remove(key, hash, oldValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.remove(key, hash, oldValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n   public void testExpand() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertEquals(1, segment.table.length());\n+    assertThat(segment.table.length()).isEqualTo(1);\n \n     // manually add elements to avoid expansion\n     int originalCount = 1024;\n@@ -1641,17 +1653,17 @@ public void testExpand() {\n     segment.table.set(0, entry);\n     segment.count = originalCount;\n     ImmutableMap<Object, Object> originalMap = ImmutableMap.copyOf(map);\n-    assertEquals(originalCount, originalMap.size());\n-    assertEquals(originalMap, map);\n+    assertThat(originalMap).hasSize(originalCount);\n+    assertThat(map).isEqualTo(originalMap);\n \n     for (int i = 1; i <= originalCount * 2; i *= 2) {\n       if (i > 1) {\n         segment.expand();\n       }\n-      assertEquals(i, segment.table.length());\n-      assertEquals(originalCount, countLiveEntries(map, 0));\n-      assertEquals(originalCount, segment.count);\n-      assertEquals(originalMap, map);\n+      assertThat(segment.table.length()).isEqualTo(i);\n+      assertThat(countLiveEntries(map, 0)).isEqualTo(originalCount);\n+      assertThat(segment.count).isEqualTo(originalCount);\n+      assertThat(map).isEqualTo(originalMap);\n     }\n   }\n \n@@ -1660,7 +1672,7 @@ public void testGetCausesExpansion() throws ExecutionException {\n       LocalCache<Object, Object> map =\n           makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n       Segment<Object, Object> segment = map.segments[0];\n-      assertEquals(1, segment.table.length());\n+      assertThat(segment.table.length()).isEqualTo(1);\n \n       for (int i = 0; i < count; i++) {\n         Object key = new Object();\n@@ -1675,37 +1687,37 @@ public Object load(Object key) {\n               }\n             });\n       }\n-      assertEquals(count, segment.count);\n-      assertTrue(count <= segment.threshold);\n-      assertTrue(count <= (segment.table.length() * 3 / 4));\n-      assertTrue(count > (segment.table.length() * 3 / 8));\n+      assertThat(segment.count).isEqualTo(count);\n+      assertThat(count).isAtMost(segment.threshold);\n+      assertThat(count).isAtMost((segment.table.length() * 3 / 4));\n+      assertThat(count).isGreaterThan(segment.table.length() * 3 / 8);\n     }\n   }\n \n   public void testGetOrDefault() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     map.put(1, 1);\n-    assertEquals(1, map.getOrDefault(1, 2));\n-    assertEquals(2, map.getOrDefault(2, 2));\n+    assertThat(map.getOrDefault(1, 2)).isEqualTo(1);\n+    assertThat(map.getOrDefault(2, 2)).isEqualTo(2);\n   }\n \n   public void testPutCausesExpansion() {\n     for (int count = 1; count <= 100; count++) {\n       LocalCache<Object, Object> map =\n           makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n       Segment<Object, Object> segment = map.segments[0];\n-      assertEquals(1, segment.table.length());\n+      assertThat(segment.table.length()).isEqualTo(1);\n \n       for (int i = 0; i < count; i++) {\n         Object key = new Object();\n         Object value = new Object();\n         segment.put(key, key.hashCode(), value, true);\n       }\n-      assertEquals(count, segment.count);\n-      assertTrue(count <= segment.threshold);\n-      assertTrue(count <= (segment.table.length() * 3 / 4));\n-      assertTrue(count > (segment.table.length() * 3 / 8));\n+      assertThat(segment.count).isEqualTo(count);\n+      assertThat(count).isAtMost(segment.threshold);\n+      assertThat(count).isAtMost((segment.table.length() * 3 / 4));\n+      assertThat(count).isGreaterThan(segment.table.length() * 3 / 8);\n     }\n   }\n \n@@ -1721,7 +1733,7 @@ public void testReclaimKey() {\n                 .removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     // create 3 objects and chain them together\n     Object keyOne = new Object();\n@@ -1739,28 +1751,28 @@ public void testReclaimKey() {\n         createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n \n     // absent\n-    assertEquals(0, listener.getCount());\n-    assertFalse(segment.reclaimKey(entryOne, hashOne));\n-    assertEquals(0, listener.getCount());\n+    assertThat(listener.getCount()).isEqualTo(0);\n+    assertThat(segment.reclaimKey(entryOne, hashOne)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(0);\n     table.set(0, entryOne);\n-    assertFalse(segment.reclaimKey(entryTwo, hashTwo));\n-    assertEquals(0, listener.getCount());\n+    assertThat(segment.reclaimKey(entryTwo, hashTwo)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(0);\n     table.set(0, entryTwo);\n-    assertFalse(segment.reclaimKey(entryThree, hashThree));\n-    assertEquals(0, listener.getCount());\n+    assertThat(segment.reclaimKey(entryThree, hashThree)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(0);\n \n     // present\n     table.set(0, entryOne);\n     segment.count = 1;\n-    assertTrue(segment.reclaimKey(entryOne, hashOne));\n-    assertEquals(1, listener.getCount());\n-    assertSame(keyOne, listener.getLastEvictedKey());\n-    assertSame(valueOne, listener.getLastEvictedValue());\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertFalse(segment.accessQueue.contains(entryOne));\n-    assertFalse(segment.writeQueue.contains(entryOne));\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(segment.reclaimKey(entryOne, hashOne)).isTrue();\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(keyOne);\n+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(valueOne);\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.accessQueue.contains(entryOne)).isFalse();\n+    assertThat(segment.writeQueue.contains(entryOne)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n   }\n \n   public void testRemoveEntryFromChain() {\n@@ -1786,32 +1798,32 @@ public void testRemoveEntryFromChain() {\n     assertNull(segment.removeEntryFromChain(entryOne, entryOne));\n \n     // head\n-    assertSame(entryOne, segment.removeEntryFromChain(entryTwo, entryTwo));\n+    assertThat(segment.removeEntryFromChain(entryTwo, entryTwo)).isSameInstanceAs(entryOne);\n \n     // middle\n     ReferenceEntry<Object, Object> newFirst = segment.removeEntryFromChain(entryThree, entryTwo);\n-    assertSame(keyThree, newFirst.getKey());\n-    assertSame(valueThree, newFirst.getValueReference().get());\n-    assertEquals(hashThree, newFirst.getHash());\n-    assertSame(entryOne, newFirst.getNext());\n+    assertThat(newFirst.getKey()).isSameInstanceAs(keyThree);\n+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueThree);\n+    assertThat(newFirst.getHash()).isEqualTo(hashThree);\n+    assertThat(newFirst.getNext()).isSameInstanceAs(entryOne);\n \n     // tail (remaining entries are copied in reverse order)\n     newFirst = segment.removeEntryFromChain(entryThree, entryOne);\n-    assertSame(keyTwo, newFirst.getKey());\n-    assertSame(valueTwo, newFirst.getValueReference().get());\n-    assertEquals(hashTwo, newFirst.getHash());\n+    assertThat(newFirst.getKey()).isSameInstanceAs(keyTwo);\n+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueTwo);\n+    assertThat(newFirst.getHash()).isEqualTo(hashTwo);\n     newFirst = newFirst.getNext();\n-    assertSame(keyThree, newFirst.getKey());\n-    assertSame(valueThree, newFirst.getValueReference().get());\n-    assertEquals(hashThree, newFirst.getHash());\n-    assertNull(newFirst.getNext());\n+    assertThat(newFirst.getKey()).isSameInstanceAs(keyThree);\n+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueThree);\n+    assertThat(newFirst.getHash()).isEqualTo(hashThree);\n+    assertThat(newFirst.getNext()).isNull();\n   }\n \n   public void testExpand_cleanup() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertEquals(1, segment.table.length());\n+    assertThat(segment.table.length()).isEqualTo(1);\n \n     // manually add elements to avoid expansion\n     // 1/3 null keys, 1/3 null values\n@@ -1832,22 +1844,22 @@ public void testExpand_cleanup() {\n     segment.table.set(0, entry);\n     segment.count = originalCount;\n     int liveCount = originalCount / 3;\n-    assertEquals(1, segment.table.length());\n-    assertEquals(liveCount, countLiveEntries(map, 0));\n+    assertThat(segment.table.length()).isEqualTo(1);\n+    assertThat(countLiveEntries(map, 0)).isEqualTo(liveCount);\n     ImmutableMap<Object, Object> originalMap = ImmutableMap.copyOf(map);\n-    assertEquals(liveCount, originalMap.size());\n+    assertThat(originalMap).hasSize(liveCount);\n     // can't compare map contents until cleanup occurs\n \n     for (int i = 1; i <= originalCount * 2; i *= 2) {\n       if (i > 1) {\n         segment.expand();\n       }\n-      assertEquals(i, segment.table.length());\n-      assertEquals(liveCount, countLiveEntries(map, 0));\n+      assertThat(segment.table.length()).isEqualTo(i);\n+      assertThat(countLiveEntries(map, 0)).isEqualTo(liveCount);\n       // expansion cleanup is sloppy, with a goal of avoiding unnecessary copies\n-      assertTrue(segment.count >= liveCount);\n-      assertTrue(segment.count <= originalCount);\n-      assertEquals(originalMap, ImmutableMap.copyOf(map));\n+      assertThat(segment.count).isAtLeast(liveCount);\n+      assertThat(segment.count).isAtMost(originalCount);\n+      assertThat(ImmutableMap.copyOf(map)).isEqualTo(originalMap);\n     }\n   }\n \n@@ -1876,7 +1888,7 @@ public void testClear() {\n                 .expireAfterWrite(99999, SECONDS));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -1888,17 +1900,17 @@ public void testClear() {\n     segment.count = 1;\n     segment.totalWeight = 1;\n \n-    assertSame(entry, table.get(0));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertSame(entry, segment.writeQueue.peek());\n+    assertThat(table.get(0)).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n \n     segment.clear();\n-    assertNull(table.get(0));\n-    assertTrue(segment.accessQueue.isEmpty());\n-    assertTrue(segment.writeQueue.isEmpty());\n-    assertEquals(0, segment.readCount.get());\n-    assertEquals(0, segment.count);\n-    assertEquals(0, segment.totalWeight);\n+    assertThat(table.get(0)).isNull();\n+    assertThat(segment.accessQueue.isEmpty()).isTrue();\n+    assertThat(segment.writeQueue.isEmpty()).isTrue();\n+    assertThat(segment.readCount.get()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(segment.totalWeight).isEqualTo(0);\n   }\n \n   public void testClear_notification() {\n@@ -1913,7 +1925,7 @@ public void testClear_notification() {\n                 .removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -1925,17 +1937,17 @@ public void testClear_notification() {\n     segment.count = 1;\n     segment.totalWeight = 1;\n \n-    assertSame(entry, table.get(0));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertSame(entry, segment.writeQueue.peek());\n+    assertThat(table.get(0)).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n \n     segment.clear();\n-    assertNull(table.get(0));\n-    assertTrue(segment.accessQueue.isEmpty());\n-    assertTrue(segment.writeQueue.isEmpty());\n-    assertEquals(0, segment.readCount.get());\n-    assertEquals(0, segment.count);\n-    assertEquals(0, segment.totalWeight);\n+    assertThat(table.get(0)).isNull();\n+    assertThat(segment.accessQueue.isEmpty()).isTrue();\n+    assertThat(segment.writeQueue.isEmpty()).isTrue();\n+    assertThat(segment.readCount.get()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(segment.totalWeight).isEqualTo(0);\n     assertNotified(listener, key, value, RemovalCause.EXPLICIT);\n   }\n \n@@ -1950,27 +1962,27 @@ public void testRemoveEntry() {\n                 .removalListener(countingRemovalListener()));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n     int hash = map.hash(key);\n     DummyEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);\n \n     // remove absent\n-    assertFalse(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));\n+    assertThat(segment.removeEntry(entry, hash, RemovalCause.COLLECTED)).isFalse();\n \n     // remove live\n     segment.recordWrite(entry, 1, map.ticker.read());\n     table.set(0, entry);\n     segment.count = 1;\n-    assertTrue(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));\n+    assertThat(segment.removeEntry(entry, hash, RemovalCause.COLLECTED)).isTrue();\n     assertNotificationEnqueued(map, key, value);\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertFalse(segment.accessQueue.contains(entry));\n-    assertFalse(segment.writeQueue.contains(entry));\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.accessQueue.contains(entry)).isFalse();\n+    assertThat(segment.writeQueue.contains(entry)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n   }\n \n   public void testReclaimValue() {\n@@ -1985,7 +1997,7 @@ public void testReclaimValue() {\n                 .removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -1995,32 +2007,32 @@ public void testReclaimValue() {\n     entry.setValueReference(valueRef);\n \n     // reclaim absent\n-    assertFalse(segment.reclaimValue(key, hash, valueRef));\n+    assertThat(segment.reclaimValue(key, hash, valueRef)).isFalse();\n \n     // reclaim live\n     segment.recordWrite(entry, 1, map.ticker.read());\n     table.set(0, entry);\n     segment.count = 1;\n-    assertTrue(segment.reclaimValue(key, hash, valueRef));\n-    assertEquals(1, listener.getCount());\n-    assertSame(key, listener.getLastEvictedKey());\n-    assertSame(value, listener.getLastEvictedValue());\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertFalse(segment.accessQueue.contains(entry));\n-    assertFalse(segment.writeQueue.contains(entry));\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(segment.reclaimValue(key, hash, valueRef)).isTrue();\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(key);\n+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(value);\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.accessQueue.contains(entry)).isFalse();\n+    assertThat(segment.writeQueue.contains(entry)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n \n     // reclaim wrong value reference\n     table.set(0, entry);\n     DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);\n     entry.setValueReference(otherValueRef);\n-    assertFalse(segment.reclaimValue(key, hash, valueRef));\n-    assertEquals(1, listener.getCount());\n-    assertTrue(segment.reclaimValue(key, hash, otherValueRef));\n-    assertEquals(2, listener.getCount());\n-    assertSame(key, listener.getLastEvictedKey());\n-    assertSame(value, listener.getLastEvictedValue());\n+    assertThat(segment.reclaimValue(key, hash, valueRef)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(segment.reclaimValue(key, hash, otherValueRef)).isTrue();\n+    assertThat(listener.getCount()).isEqualTo(2);\n+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(key);\n+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(value);\n   }\n \n   public void testRemoveComputingValue() {\n@@ -2034,7 +2046,7 @@ public void testRemoveComputingValue() {\n                 .removalListener(countingRemovalListener()));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     int hash = map.hash(key);\n@@ -2043,16 +2055,16 @@ public void testRemoveComputingValue() {\n     entry.setValueReference(valueRef);\n \n     // absent\n-    assertFalse(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isFalse();\n \n     // live\n     table.set(0, entry);\n     // don't increment count; this is used during computation\n-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();\n     // no notification sent with removeLoadingValue\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n \n     // active\n     Object value = new Object();\n@@ -2061,23 +2073,23 @@ public void testRemoveComputingValue() {\n     entry.setValueReference(valueRef);\n     table.set(0, entry);\n     segment.count = 1;\n-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));\n-    assertSame(entry, table.get(0));\n-    assertSame(value, segment.get(key, hash));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();\n+    assertThat(table.get(0)).isSameInstanceAs(entry);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n \n     // wrong value reference\n     table.set(0, entry);\n     DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);\n     entry.setValueReference(otherValueRef);\n-    assertFalse(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isFalse();\n     entry.setValueReference(valueRef);\n-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();\n   }\n \n   private static <K, V> void assertNotificationEnqueued(LocalCache<K, V> map, K key, V value) {\n     RemovalNotification<K, V> notification = map.removalNotificationQueue.poll();\n-    assertSame(key, notification.getKey());\n-    assertSame(value, notification.getValue());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(value);\n   }\n \n   // Segment eviction tests\n@@ -2094,15 +2106,15 @@ public void testDrainRecencyQueueOnWrite() {\n         Object valueTwo = new Object();\n \n         map.put(keyOne, valueOne);\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {\n           map.get(keyOne);\n         }\n-        assertFalse(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isFalse();\n \n         map.put(keyTwo, valueTwo);\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n       }\n     }\n   }\n@@ -2119,33 +2131,33 @@ public void testDrainRecencyQueueOnRead() {\n         // repeated get of the same key\n \n         map.put(keyOne, valueOne);\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {\n           map.get(keyOne);\n         }\n-        assertFalse(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isFalse();\n \n         for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n           map.get(keyOne);\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n \n         // get over many different keys\n \n         for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n           map.put(new Object(), new Object());\n         }\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {\n           map.get(keyOne);\n         }\n-        assertFalse(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isFalse();\n \n         for (Object key : map.keySet()) {\n           map.get(key);\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n       }\n     }\n@@ -2211,7 +2223,7 @@ public void testRecordReadOnGet() {\n \n       checkEvictionQueues(map, segment, readOrder, writeOrder);\n       checkExpirationTimes(map);\n-      assertTrue(segment.recencyQueue.isEmpty());\n+      assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n       // access some of the elements\n       Random random = new Random();\n@@ -2223,7 +2235,7 @@ public void testRecordReadOnGet() {\n           map.get(entry.getKey());\n           reads.add(entry);\n           i.remove();\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n       }\n       int undrainedIndex = reads.size() - segment.recencyQueue.size();\n@@ -2297,12 +2309,13 @@ static <K, V> void checkEvictionQueues(\n   private static <K, V> void assertSameEntries(\n       List<ReferenceEntry<K, V>> expectedEntries, List<ReferenceEntry<K, V>> actualEntries) {\n     int size = expectedEntries.size();\n-    assertEquals(size, actualEntries.size());\n+    assertThat(actualEntries).hasSize(size);\n     for (int i = 0; i < size; i++) {\n       ReferenceEntry<K, V> expectedEntry = expectedEntries.get(i);\n       ReferenceEntry<K, V> actualEntry = actualEntries.get(i);\n-      assertSame(expectedEntry.getKey(), actualEntry.getKey());\n-      assertSame(expectedEntry.getValueReference().get(), actualEntry.getValueReference().get());\n+      assertThat(actualEntry.getKey()).isSameInstanceAs(expectedEntry.getKey());\n+      assertThat(actualEntry.getValueReference().get())\n+          .isSameInstanceAs(expectedEntry.getValueReference().get());\n     }\n   }\n \n@@ -2316,23 +2329,23 @@ static <K, V> void checkExpirationTimes(LocalCache<K, V> map) {\n       long lastWriteTime = 0;\n       for (ReferenceEntry<K, V> e : segment.recencyQueue) {\n         long accessTime = e.getAccessTime();\n-        assertTrue(accessTime >= lastAccessTime);\n+        assertThat(accessTime).isAtLeast(lastAccessTime);\n         lastAccessTime = accessTime;\n         long writeTime = e.getWriteTime();\n-        assertTrue(writeTime >= lastWriteTime);\n+        assertThat(writeTime).isAtLeast(lastWriteTime);\n         lastWriteTime = writeTime;\n       }\n \n       lastAccessTime = 0;\n       lastWriteTime = 0;\n       for (ReferenceEntry<K, V> e : segment.accessQueue) {\n         long accessTime = e.getAccessTime();\n-        assertTrue(accessTime >= lastAccessTime);\n+        assertThat(accessTime).isAtLeast(lastAccessTime);\n         lastAccessTime = accessTime;\n       }\n       for (ReferenceEntry<K, V> e : segment.writeQueue) {\n         long writeTime = e.getWriteTime();\n-        assertTrue(writeTime >= lastWriteTime);\n+        assertThat(writeTime).isAtLeast(lastWriteTime);\n         lastWriteTime = writeTime;\n       }\n     }\n@@ -2352,31 +2365,31 @@ public void testExpireAfterWrite() {\n     Object value = new Object();\n     map.put(key, value);\n     ReferenceEntry<Object, Object> entry = map.getEntry(key);\n-    assertTrue(map.isLive(entry, ticker.read()));\n+    assertThat(map.isLive(entry, ticker.read())).isTrue();\n \n     segment.writeQueue.add(entry);\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.writeQueue.peek());\n-    assertEquals(1, segment.writeQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue).hasSize(1);\n \n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.writeQueue.peek());\n-    assertEquals(1, segment.writeQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.writeQueue.peek());\n-    assertEquals(1, segment.writeQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue).hasSize(1);\n \n     ticker.advance(1);\n-    assertNull(map.get(key));\n+    assertThat(map.get(key)).isNull();\n     segment.expireEntries(ticker.read());\n-    assertNull(map.get(key));\n-    assertTrue(segment.writeQueue.isEmpty());\n+    assertThat(map.get(key)).isNull();\n+    assertThat(segment.writeQueue.isEmpty()).isTrue();\n   }\n \n   public void testExpireAfterAccess() {\n@@ -2393,46 +2406,46 @@ public void testExpireAfterAccess() {\n     Object value = new Object();\n     map.put(key, value);\n     ReferenceEntry<Object, Object> entry = map.getEntry(key);\n-    assertTrue(map.isLive(entry, ticker.read()));\n+    assertThat(map.isLive(entry, ticker.read())).isTrue();\n \n     segment.accessQueue.add(entry);\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n-    assertFalse(map.containsKey(key));\n-    assertNull(map.get(key));\n+    assertThat(map.containsKey(key)).isFalse();\n+    assertThat(map.get(key)).isNull();\n     segment.expireEntries(ticker.read());\n-    assertFalse(map.containsKey(key));\n-    assertNull(map.get(key));\n-    assertTrue(segment.accessQueue.isEmpty());\n+    assertThat(map.containsKey(key)).isFalse();\n+    assertThat(map.get(key)).isNull();\n+    assertThat(segment.accessQueue.isEmpty()).isTrue();\n   }\n \n   public void testEvictEntries() {\n@@ -2461,17 +2474,17 @@ public void testEvictEntries() {\n     }\n     segment.count = originalCount;\n     segment.totalWeight = originalCount;\n-    assertEquals(originalCount, map.size());\n-    assertEquals(originalMap, map);\n+    assertThat(map).hasSize(originalCount);\n+    assertThat(map).isEqualTo(originalMap);\n \n     Iterator<Object> it = originalMap.keySet().iterator();\n     for (int i = 0; i < originalCount - maxSize; i++) {\n       it.next();\n       it.remove();\n     }\n     segment.evictEntries(entry);\n-    assertEquals(maxSize, map.size());\n-    assertEquals(originalMap, map);\n+    assertThat(map).hasSize(maxSize);\n+    assertThat(map).isEqualTo(originalMap);\n   }\n \n   // reference queues\n@@ -2496,11 +2509,11 @@ public void testDrainKeyReferenceQueueOnWrite() {\n         reference.enqueue();\n \n         map.put(keyTwo, valueTwo);\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(1, map.size());\n-        assertNull(segment.keyReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).hasSize(1);\n+        assertThat(segment.keyReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2526,11 +2539,11 @@ public void testDrainValueReferenceQueueOnWrite() {\n         reference.enqueue();\n \n         map.put(keyTwo, valueTwo);\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(1, map.size());\n-        assertNull(segment.valueReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).hasSize(1);\n+        assertThat(segment.valueReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2556,11 +2569,11 @@ public void testDrainKeyReferenceQueueOnRead() {\n         for (int i = 0; i < SMALL_MAX_SIZE; i++) {\n           map.get(keyTwo);\n         }\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(0, map.size());\n-        assertNull(segment.keyReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).isEmpty();\n+        assertThat(segment.keyReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2587,11 +2600,11 @@ public void testDrainValueReferenceQueueOnRead() {\n         for (int i = 0; i < SMALL_MAX_SIZE; i++) {\n           map.get(keyTwo);\n         }\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(0, map.size());\n-        assertNull(segment.valueReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).isEmpty();\n+        assertThat(segment.valueReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2624,42 +2637,45 @@ public void testSerializationProxyLoading() {\n                 .build(loader);\n     // add a non-serializable entry\n     one.getUnchecked(new Object());\n-    assertEquals(1, one.size());\n-    assertFalse(one.asMap().isEmpty());\n+    assertThat(one.size()).isEqualTo(1);\n+    assertThat(one.asMap().isEmpty()).isFalse();\n     LocalLoadingCache<Object, Object> two = SerializableTester.reserialize(one);\n-    assertEquals(0, two.size());\n-    assertTrue(two.asMap().isEmpty());\n+    assertThat(two.size()).isEqualTo(0);\n+    assertThat(two.asMap().isEmpty()).isTrue();\n \n     LocalCache<Object, Object> localCacheOne = one.localCache;\n     LocalCache<Object, Object> localCacheTwo = two.localCache;\n \n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.maxWeight, localCacheTwo.maxWeight);\n-    assertEquals(localCacheOne.weigher, localCacheTwo.weigher);\n-    assertEquals(localCacheOne.expireAfterAccessNanos, localCacheTwo.expireAfterAccessNanos);\n-    assertEquals(localCacheOne.expireAfterWriteNanos, localCacheTwo.expireAfterWriteNanos);\n-    assertEquals(localCacheOne.refreshNanos, localCacheTwo.refreshNanos);\n-    assertEquals(localCacheOne.removalListener, localCacheTwo.removalListener);\n-    assertEquals(localCacheOne.ticker, localCacheTwo.ticker);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.maxWeight).isEqualTo(localCacheOne.maxWeight);\n+    assertThat(localCacheTwo.weigher).isEqualTo(localCacheOne.weigher);\n+    assertThat(localCacheTwo.expireAfterAccessNanos)\n+        .isEqualTo(localCacheOne.expireAfterAccessNanos);\n+    assertThat(localCacheTwo.expireAfterWriteNanos).isEqualTo(localCacheOne.expireAfterWriteNanos);\n+    assertThat(localCacheTwo.refreshNanos).isEqualTo(localCacheOne.refreshNanos);\n+    assertThat(localCacheTwo.removalListener).isEqualTo(localCacheOne.removalListener);\n+    assertThat(localCacheTwo.ticker).isEqualTo(localCacheOne.ticker);\n \n     // serialize the reconstituted version to be sure we haven't lost the ability to reserialize\n     LocalLoadingCache<Object, Object> three = SerializableTester.reserialize(two);\n     LocalCache<Object, Object> localCacheThree = three.localCache;\n \n-    assertEquals(localCacheTwo.defaultLoader, localCacheThree.defaultLoader);\n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.maxWeight, localCacheThree.maxWeight);\n-    assertEquals(localCacheTwo.weigher, localCacheThree.weigher);\n-    assertEquals(localCacheTwo.expireAfterAccessNanos, localCacheThree.expireAfterAccessNanos);\n-    assertEquals(localCacheTwo.expireAfterWriteNanos, localCacheThree.expireAfterWriteNanos);\n-    assertEquals(localCacheTwo.removalListener, localCacheThree.removalListener);\n-    assertEquals(localCacheTwo.ticker, localCacheThree.ticker);\n+    assertThat(localCacheThree.defaultLoader).isEqualTo(localCacheTwo.defaultLoader);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.maxWeight).isEqualTo(localCacheTwo.maxWeight);\n+    assertThat(localCacheThree.weigher).isEqualTo(localCacheTwo.weigher);\n+    assertThat(localCacheThree.expireAfterAccessNanos)\n+        .isEqualTo(localCacheTwo.expireAfterAccessNanos);\n+    assertThat(localCacheThree.expireAfterWriteNanos)\n+        .isEqualTo(localCacheTwo.expireAfterWriteNanos);\n+    assertThat(localCacheThree.removalListener).isEqualTo(localCacheTwo.removalListener);\n+    assertThat(localCacheThree.ticker).isEqualTo(localCacheTwo.ticker);\n   }\n \n   public void testSerializationProxyManual() {\n@@ -2681,57 +2697,60 @@ public void testSerializationProxyManual() {\n                 .build();\n     // add a non-serializable entry\n     one.put(new Object(), new Object());\n-    assertEquals(1, one.size());\n-    assertFalse(one.asMap().isEmpty());\n+    assertThat(one.size()).isEqualTo(1);\n+    assertThat(one.asMap().isEmpty()).isFalse();\n     LocalManualCache<Object, Object> two = SerializableTester.reserialize(one);\n-    assertEquals(0, two.size());\n-    assertTrue(two.asMap().isEmpty());\n+    assertThat(two.size()).isEqualTo(0);\n+    assertThat(two.asMap().isEmpty()).isTrue();\n \n     LocalCache<Object, Object> localCacheOne = one.localCache;\n     LocalCache<Object, Object> localCacheTwo = two.localCache;\n \n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.maxWeight, localCacheTwo.maxWeight);\n-    assertEquals(localCacheOne.weigher, localCacheTwo.weigher);\n-    assertEquals(localCacheOne.expireAfterAccessNanos, localCacheTwo.expireAfterAccessNanos);\n-    assertEquals(localCacheOne.expireAfterWriteNanos, localCacheTwo.expireAfterWriteNanos);\n-    assertEquals(localCacheOne.removalListener, localCacheTwo.removalListener);\n-    assertEquals(localCacheOne.ticker, localCacheTwo.ticker);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.maxWeight).isEqualTo(localCacheOne.maxWeight);\n+    assertThat(localCacheTwo.weigher).isEqualTo(localCacheOne.weigher);\n+    assertThat(localCacheTwo.expireAfterAccessNanos)\n+        .isEqualTo(localCacheOne.expireAfterAccessNanos);\n+    assertThat(localCacheTwo.expireAfterWriteNanos).isEqualTo(localCacheOne.expireAfterWriteNanos);\n+    assertThat(localCacheTwo.removalListener).isEqualTo(localCacheOne.removalListener);\n+    assertThat(localCacheTwo.ticker).isEqualTo(localCacheOne.ticker);\n \n     // serialize the reconstituted version to be sure we haven't lost the ability to reserialize\n     LocalManualCache<Object, Object> three = SerializableTester.reserialize(two);\n     LocalCache<Object, Object> localCacheThree = three.localCache;\n \n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.maxWeight, localCacheThree.maxWeight);\n-    assertEquals(localCacheTwo.weigher, localCacheThree.weigher);\n-    assertEquals(localCacheTwo.expireAfterAccessNanos, localCacheThree.expireAfterAccessNanos);\n-    assertEquals(localCacheTwo.expireAfterWriteNanos, localCacheThree.expireAfterWriteNanos);\n-    assertEquals(localCacheTwo.removalListener, localCacheThree.removalListener);\n-    assertEquals(localCacheTwo.ticker, localCacheThree.ticker);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.maxWeight).isEqualTo(localCacheTwo.maxWeight);\n+    assertThat(localCacheThree.weigher).isEqualTo(localCacheTwo.weigher);\n+    assertThat(localCacheThree.expireAfterAccessNanos)\n+        .isEqualTo(localCacheTwo.expireAfterAccessNanos);\n+    assertThat(localCacheThree.expireAfterWriteNanos)\n+        .isEqualTo(localCacheTwo.expireAfterWriteNanos);\n+    assertThat(localCacheThree.removalListener).isEqualTo(localCacheTwo.removalListener);\n+    assertThat(localCacheThree.ticker).isEqualTo(localCacheTwo.ticker);\n   }\n \n   public void testLoadDifferentKeyInLoader() throws ExecutionException, InterruptedException {\n     LocalCache<String, String> cache = makeLocalCache(createCacheBuilder());\n     String key1 = \"key1\";\n     String key2 = \"key2\";\n \n-    assertEquals(\n-        key2,\n-        cache.get(\n-            key1,\n-            new CacheLoader<String, String>() {\n-              @Override\n-              public String load(String key) throws Exception {\n-                return cache.get(key2, identityLoader()); // loads a different key, should work\n-              }\n-            }));\n+    assertThat(\n+            cache.get(\n+                key1,\n+                new CacheLoader<String, String>() {\n+                  @Override\n+                  public String load(String key) throws Exception {\n+                    return cache.get(key2, identityLoader()); // loads a different key, should work\n+                  }\n+                }))\n+        .isEqualTo(key2);\n   }\n \n   public void testRecursiveLoad() throws InterruptedException {"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java",
      "status": "modified",
      "additions": 92,
      "deletions": 92,
      "changes": 184,
      "patch": "@@ -62,7 +62,7 @@ public Object load(Object from) {\n           }\n         };\n     LocalLoadingCache<Object, Object> cache = makeCache(createCacheBuilder(), loader);\n-    assertSame(loader, cache.localCache.defaultLoader);\n+    assertThat(cache.localCache.defaultLoader).isSameInstanceAs(loader);\n   }\n \n   // null parameters test\n@@ -78,82 +78,82 @@ public void testNullParameters() throws Exception {\n   public void testStats() {\n     CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1).maximumSize(2);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     cache.getUnchecked(one);\n     CacheStats stats = cache.stats();\n-    assertEquals(1, stats.requestCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n     assertThat(stats.hitRate()).isEqualTo(0.0);\n-    assertEquals(1, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n     assertThat(stats.missRate()).isEqualTo(1.0);\n-    assertEquals(1, stats.loadCount());\n+    assertThat(stats.loadCount()).isEqualTo(1);\n     long totalLoadTime = stats.totalLoadTime();\n-    assertTrue(totalLoadTime >= 0);\n-    assertTrue(stats.averageLoadPenalty() >= 0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(totalLoadTime).isAtLeast(0);\n+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n \n     cache.getUnchecked(one);\n     stats = cache.stats();\n-    assertEquals(2, stats.requestCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n     assertThat(stats.hitRate()).isEqualTo(1.0 / 2);\n-    assertEquals(1, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n     assertThat(stats.missRate()).isEqualTo(1.0 / 2);\n-    assertEquals(1, stats.loadCount());\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.loadCount()).isEqualTo(1);\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n \n     Object two = new Object();\n     cache.getUnchecked(two);\n     stats = cache.stats();\n-    assertEquals(3, stats.requestCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n     assertThat(stats.hitRate()).isEqualTo(1.0 / 3);\n-    assertEquals(2, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n     assertThat(stats.missRate()).isEqualTo(2.0 / 3);\n-    assertEquals(2, stats.loadCount());\n-    assertTrue(stats.totalLoadTime() >= totalLoadTime);\n+    assertThat(stats.loadCount()).isEqualTo(2);\n+    assertThat(stats.totalLoadTime()).isAtLeast(totalLoadTime);\n     totalLoadTime = stats.totalLoadTime();\n-    assertTrue(stats.averageLoadPenalty() >= 0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n \n     Object three = new Object();\n     cache.getUnchecked(three);\n     stats = cache.stats();\n-    assertEquals(4, stats.requestCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n     assertThat(stats.hitRate()).isEqualTo(1.0 / 4);\n-    assertEquals(3, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n     assertThat(stats.missRate()).isEqualTo(3.0 / 4);\n-    assertEquals(3, stats.loadCount());\n-    assertTrue(stats.totalLoadTime() >= totalLoadTime);\n-    assertTrue(stats.averageLoadPenalty() >= 0.0);\n-    assertEquals(1, stats.evictionCount());\n+    assertThat(stats.loadCount()).isEqualTo(3);\n+    assertThat(stats.totalLoadTime()).isAtLeast(totalLoadTime);\n+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);\n+    assertThat(stats.evictionCount()).isEqualTo(1);\n   }\n \n   public void testStatsNoops() {\n     CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n     ConcurrentMap<Object, Object> map = cache.localCache; // modifiable map view\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     assertNull(map.put(one, one));\n-    assertSame(one, map.get(one));\n-    assertTrue(map.containsKey(one));\n-    assertTrue(map.containsValue(one));\n+    assertThat(map.get(one)).isSameInstanceAs(one);\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map.containsValue(one)).isTrue();\n     Object two = new Object();\n-    assertSame(one, map.replace(one, two));\n-    assertTrue(map.containsKey(one));\n-    assertFalse(map.containsValue(one));\n+    assertThat(map.replace(one, two)).isSameInstanceAs(one);\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map.containsValue(one)).isFalse();\n     Object three = new Object();\n-    assertTrue(map.replace(one, two, three));\n-    assertTrue(map.remove(one, three));\n-    assertFalse(map.containsKey(one));\n-    assertFalse(map.containsValue(one));\n+    assertThat(map.replace(one, two, three)).isTrue();\n+    assertThat(map.remove(one, three)).isTrue();\n+    assertThat(map.containsKey(one)).isFalse();\n+    assertThat(map.containsValue(one)).isFalse();\n     assertNull(map.putIfAbsent(two, three));\n-    assertSame(three, map.remove(two));\n+    assertThat(map.remove(two)).isSameInstanceAs(three);\n     assertNull(map.put(three, one));\n     assertNull(map.put(one, two));\n \n@@ -171,112 +171,112 @@ public void testStatsNoops() {\n \n     map.clear();\n \n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n   }\n \n   public void testNoStats() {\n     CacheBuilder<Object, Object> builder =\n         CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(2);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     cache.getUnchecked(one);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     cache.getUnchecked(one);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object two = new Object();\n     cache.getUnchecked(two);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object three = new Object();\n     cache.getUnchecked(three);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n   }\n \n   public void testRecordStats() {\n     CacheBuilder<Object, Object> builder =\n         createCacheBuilder().recordStats().concurrencyLevel(1).maximumSize(2);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(0, cache.stats().hitCount());\n-    assertEquals(0, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(0);\n+    assertThat(cache.stats().missCount()).isEqualTo(0);\n \n     Object one = new Object();\n     cache.getUnchecked(one);\n-    assertEquals(0, cache.stats().hitCount());\n-    assertEquals(1, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(0);\n+    assertThat(cache.stats().missCount()).isEqualTo(1);\n \n     cache.getUnchecked(one);\n-    assertEquals(1, cache.stats().hitCount());\n-    assertEquals(1, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(1);\n+    assertThat(cache.stats().missCount()).isEqualTo(1);\n \n     Object two = new Object();\n     cache.getUnchecked(two);\n-    assertEquals(1, cache.stats().hitCount());\n-    assertEquals(2, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(1);\n+    assertThat(cache.stats().missCount()).isEqualTo(2);\n \n     Object three = new Object();\n     cache.getUnchecked(three);\n-    assertEquals(1, cache.stats().hitCount());\n-    assertEquals(3, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(1);\n+    assertThat(cache.stats().missCount()).isEqualTo(3);\n   }\n \n   // asMap tests\n \n   public void testAsMap() {\n     CacheBuilder<Object, Object> builder = createCacheBuilder();\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     Object two = new Object();\n     Object three = new Object();\n \n     ConcurrentMap<Object, Object> map = cache.asMap();\n     assertNull(map.put(one, two));\n-    assertSame(two, map.get(one));\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n     map.putAll(ImmutableMap.of(two, three));\n-    assertSame(three, map.get(two));\n-    assertSame(two, map.putIfAbsent(one, three));\n-    assertSame(two, map.get(one));\n+    assertThat(map.get(two)).isSameInstanceAs(three);\n+    assertThat(map.putIfAbsent(one, three)).isSameInstanceAs(two);\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n     assertNull(map.putIfAbsent(three, one));\n-    assertSame(one, map.get(three));\n-    assertSame(two, map.replace(one, three));\n-    assertSame(three, map.get(one));\n-    assertFalse(map.replace(one, two, three));\n-    assertSame(three, map.get(one));\n-    assertTrue(map.replace(one, three, two));\n-    assertSame(two, map.get(one));\n-    assertEquals(3, map.size());\n+    assertThat(map.get(three)).isSameInstanceAs(one);\n+    assertThat(map.replace(one, three)).isSameInstanceAs(two);\n+    assertThat(map.get(one)).isSameInstanceAs(three);\n+    assertThat(map.replace(one, two, three)).isFalse();\n+    assertThat(map.get(one)).isSameInstanceAs(three);\n+    assertThat(map.replace(one, three, two)).isTrue();\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n+    assertThat(map).hasSize(3);\n \n     map.clear();\n-    assertTrue(map.isEmpty());\n-    assertEquals(0, map.size());\n+    assertThat(map.isEmpty()).isTrue();\n+    assertThat(map).isEmpty();\n \n     cache.getUnchecked(one);\n-    assertEquals(1, map.size());\n-    assertSame(one, map.get(one));\n-    assertTrue(map.containsKey(one));\n-    assertTrue(map.containsValue(one));\n-    assertSame(one, map.remove(one));\n-    assertEquals(0, map.size());\n+    assertThat(map).hasSize(1);\n+    assertThat(map.get(one)).isSameInstanceAs(one);\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map.containsValue(one)).isTrue();\n+    assertThat(map.remove(one)).isSameInstanceAs(one);\n+    assertThat(map).isEmpty();\n \n     cache.getUnchecked(one);\n-    assertEquals(1, map.size());\n-    assertFalse(map.remove(one, two));\n-    assertTrue(map.remove(one, one));\n-    assertEquals(0, map.size());\n+    assertThat(map).hasSize(1);\n+    assertThat(map.remove(one, two)).isFalse();\n+    assertThat(map.remove(one, one)).isTrue();\n+    assertThat(map).isEmpty();\n \n     cache.getUnchecked(one);\n     Map<Object, Object> newMap = ImmutableMap.of(one, one);\n-    assertEquals(newMap, map);\n-    assertEquals(newMap.entrySet(), map.entrySet());\n-    assertEquals(newMap.keySet(), map.keySet());\n+    assertThat(map).isEqualTo(newMap);\n+    assertThat(map.entrySet()).isEqualTo(newMap.entrySet());\n+    assertThat(map.keySet()).isEqualTo(newMap.keySet());\n     Set<Object> expectedValues = ImmutableSet.of(one);\n     Set<Object> actualValues = ImmutableSet.copyOf(map.values());\n-    assertEquals(expectedValues, actualValues);\n+    assertThat(actualValues).isEqualTo(expectedValues);\n   }\n \n   /** Lookups on the map view shouldn't impact the recency queue. */\n@@ -288,12 +288,12 @@ public void testAsMapRecency() {\n     ConcurrentMap<Object, Object> map = cache.asMap();\n \n     Object one = new Object();\n-    assertSame(one, cache.getUnchecked(one));\n-    assertTrue(segment.recencyQueue.isEmpty());\n-    assertSame(one, map.get(one));\n-    assertSame(one, segment.recencyQueue.peek().getKey());\n-    assertSame(one, cache.getUnchecked(one));\n-    assertFalse(segment.recencyQueue.isEmpty());\n+    assertThat(cache.getUnchecked(one)).isSameInstanceAs(one);\n+    assertThat(segment.recencyQueue.isEmpty()).isTrue();\n+    assertThat(map.get(one)).isSameInstanceAs(one);\n+    assertThat(segment.recencyQueue.peek().getKey()).isSameInstanceAs(one);\n+    assertThat(cache.getUnchecked(one)).isSameInstanceAs(one);\n+    assertThat(segment.recencyQueue.isEmpty()).isFalse();\n   }\n \n   public void testRecursiveComputation() throws InterruptedException {\n@@ -313,7 +313,7 @@ public String load(Integer key) {\n     LoadingCache<Integer, String> recursiveCache =\n         CacheBuilder.newBuilder().weakKeys().weakValues().build(recursiveLoader);\n     cacheRef.set(recursiveCache);\n-    assertEquals(\"3, 2, 1, 0\", recursiveCache.getUnchecked(3));\n+    assertThat(recursiveCache.getUnchecked(3)).isEqualTo(\"3, 2, 1, 0\");\n \n     recursiveLoader =\n         new CacheLoader<Integer, String>() {"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/NullCacheTest.java",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "patch": "@@ -51,12 +51,12 @@ public void testGet() {\n             .build(constantLoader(computed));\n \n     Object key = new Object();\n-    assertSame(computed, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(computed, notification.getValue());\n-    assertSame(RemovalCause.SIZE, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(computed);\n+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -69,12 +69,12 @@ public void testGet_expireAfterWrite() {\n             .build(constantLoader(computed));\n \n     Object key = new Object();\n-    assertSame(computed, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(computed, notification.getValue());\n-    assertSame(RemovalCause.SIZE, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(computed);\n+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -87,12 +87,12 @@ public void testGet_expireAfterAccess() {\n             .build(constantLoader(computed));\n \n     Object key = new Object();\n-    assertSame(computed, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(computed, notification.getValue());\n-    assertSame(RemovalCause.SIZE, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(computed);\n+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -105,7 +105,7 @@ public void testGet_computeNull() {\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(new Object()));\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -120,7 +120,7 @@ public void testGet_runtimeException() {\n     UncheckedExecutionException uee =\n         assertThrows(UncheckedExecutionException.class, () -> map.getUnchecked(new Object()));\n     assertThat(uee).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(map);\n   }\n }"
    },
    {
      "filename": "android/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java",
      "status": "modified",
      "additions": 60,
      "deletions": 57,
      "changes": 117,
      "patch": "@@ -59,7 +59,7 @@ public void testSize_populated() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       // don't let the entries get GCed\n       List<Entry<Object, Object>> unused = warmUp(cache);\n-      assertEquals(WARMUP_SIZE, cache.size());\n+      assertThat(cache.size()).isEqualTo(WARMUP_SIZE);\n       assertMapSize(cache.asMap(), WARMUP_SIZE);\n       checkValidState(cache);\n     }\n@@ -71,12 +71,12 @@ public void testContainsKey_found() {\n       List<Entry<Object, Object>> warmed = warmUp(cache);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n-        assertTrue(cache.asMap().containsKey(entry.getKey()));\n-        assertTrue(cache.asMap().containsValue(entry.getValue()));\n+        assertThat(cache.asMap().containsKey(entry.getKey())).isTrue();\n+        assertThat(cache.asMap().containsValue(entry.getValue())).isTrue();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -88,18 +88,18 @@ public void testPut_populated() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object newValue = new Object();\n-        assertSame(entry.getValue(), cache.asMap().put(entry.getKey(), newValue));\n+        assertThat(cache.asMap().put(entry.getKey(), newValue)).isSameInstanceAs(entry.getValue());\n         // don't let the new entry get GCed\n         warmed.add(entryOf(entry.getKey(), newValue));\n         Object newKey = new Object();\n-        assertNull(cache.asMap().put(newKey, entry.getValue()));\n+        assertThat(cache.asMap().put(newKey, entry.getValue())).isNull();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(newValue, cache.getUnchecked(entry.getKey()));\n-        assertEquals(entry.getValue(), cache.getUnchecked(newKey));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(newValue);\n+        assertThat(cache.getUnchecked(newKey)).isEqualTo(entry.getValue());\n         // don't let the new entry get GCed\n         warmed.add(entryOf(newKey, entry.getValue()));\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -111,16 +111,17 @@ public void testPutIfAbsent_populated() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object newValue = new Object();\n-        assertSame(entry.getValue(), cache.asMap().putIfAbsent(entry.getKey(), newValue));\n+        assertThat(cache.asMap().putIfAbsent(entry.getKey(), newValue))\n+            .isSameInstanceAs(entry.getValue());\n         Object newKey = new Object();\n-        assertNull(cache.asMap().putIfAbsent(newKey, entry.getValue()));\n+        assertThat(cache.asMap().putIfAbsent(newKey, entry.getValue())).isNull();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));\n-        assertEquals(entry.getValue(), cache.getUnchecked(newKey));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());\n+        assertThat(cache.getUnchecked(newKey)).isEqualTo(entry.getValue());\n         // don't let the new entry get GCed\n         warmed.add(entryOf(newKey, entry.getValue()));\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -133,8 +134,8 @@ public void testPutAll_populated() {\n       Object newValue = new Object();\n       cache.asMap().putAll(ImmutableMap.of(newKey, newValue));\n       // this getUnchecked() call shouldn't be a cache miss; verified below\n-      assertEquals(newValue, cache.getUnchecked(newKey));\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.getUnchecked(newKey)).isEqualTo(newValue);\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -146,16 +147,17 @@ public void testReplace_populated() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object newValue = new Object();\n-        assertSame(entry.getValue(), cache.asMap().replace(entry.getKey(), newValue));\n-        assertTrue(cache.asMap().replace(entry.getKey(), newValue, entry.getValue()));\n+        assertThat(cache.asMap().replace(entry.getKey(), newValue))\n+            .isSameInstanceAs(entry.getValue());\n+        assertThat(cache.asMap().replace(entry.getKey(), newValue, entry.getValue())).isTrue();\n         Object newKey = new Object();\n-        assertNull(cache.asMap().replace(newKey, entry.getValue()));\n-        assertFalse(cache.asMap().replace(newKey, entry.getValue(), newValue));\n+        assertThat(cache.asMap().replace(newKey, entry.getValue())).isNull();\n+        assertThat(cache.asMap().replace(newKey, entry.getValue(), newValue)).isFalse();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));\n-        assertFalse(cache.asMap().containsKey(newKey));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());\n+        assertThat(cache.asMap().containsKey(newKey)).isFalse();\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -167,9 +169,9 @@ public void testRemove_byKey() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object key = entry.getKey();\n-        assertEquals(entry.getValue(), cache.asMap().remove(key));\n-        assertNull(cache.asMap().remove(key));\n-        assertFalse(cache.asMap().containsKey(key));\n+        assertThat(cache.asMap().remove(key)).isEqualTo(entry.getValue());\n+        assertThat(cache.asMap().remove(key)).isNull();\n+        assertThat(cache.asMap().containsKey(key)).isFalse();\n       }\n       checkEmpty(cache);\n     }\n@@ -182,10 +184,10 @@ public void testRemove_byKeyAndValue() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Object key = warmed.get(i - WARMUP_MIN).getKey();\n         Object value = warmed.get(i - WARMUP_MIN).getValue();\n-        assertFalse(cache.asMap().remove(key, -1));\n-        assertTrue(cache.asMap().remove(key, value));\n-        assertFalse(cache.asMap().remove(key, -1));\n-        assertFalse(cache.asMap().containsKey(key));\n+        assertThat(cache.asMap().remove(key, -1)).isFalse();\n+        assertThat(cache.asMap().remove(key, value)).isTrue();\n+        assertThat(cache.asMap().remove(key, -1)).isFalse();\n+        assertThat(cache.asMap().containsKey(key)).isFalse();\n       }\n       checkEmpty(cache);\n     }\n@@ -206,13 +208,13 @@ public void testKeySet_populated() {\n           .addEqualityGroup(cache.asMap().keySet(), keys)\n           .addEqualityGroup(ImmutableSet.of())\n           .testEquals();\n-      assertEquals(WARMUP_SIZE, keys.size());\n+      assertThat(keys).hasSize(WARMUP_SIZE);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Object key = warmed.get(i - WARMUP_MIN).getKey();\n-        assertTrue(keys.contains(key));\n-        assertTrue(keys.remove(key));\n-        assertFalse(keys.remove(key));\n-        assertFalse(keys.contains(key));\n+        assertThat(keys.contains(key)).isTrue();\n+        assertThat(keys.remove(key)).isTrue();\n+        assertThat(keys.remove(key)).isFalse();\n+        assertThat(keys.contains(key)).isFalse();\n       }\n       checkEmpty(keys);\n       checkEmpty(cache);\n@@ -229,13 +231,13 @@ public void testValues_populated() {\n       assertThat(values.toArray()).asList().containsExactlyElementsIn(expected);\n       assertThat(values.toArray(new Object[0])).asList().containsExactlyElementsIn(expected);\n \n-      assertEquals(WARMUP_SIZE, values.size());\n+      assertThat(values).hasSize(WARMUP_SIZE);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Object value = warmed.get(i - WARMUP_MIN).getValue();\n-        assertTrue(values.contains(value));\n-        assertTrue(values.remove(value));\n-        assertFalse(values.remove(value));\n-        assertFalse(values.contains(value));\n+        assertThat(values.contains(value)).isTrue();\n+        assertThat(values.remove(value)).isTrue();\n+        assertThat(values.remove(value)).isFalse();\n+        assertThat(values.contains(value)).isFalse();\n       }\n       checkEmpty(values);\n       checkEmpty(cache);\n@@ -257,13 +259,13 @@ public void testEntrySet_populated() {\n           .addEqualityGroup(cache.asMap().entrySet(), entries)\n           .addEqualityGroup(ImmutableSet.of())\n           .testEquals();\n-      assertEquals(WARMUP_SIZE, entries.size());\n+      assertThat(entries).hasSize(WARMUP_SIZE);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> newEntry = warmed.get(i - WARMUP_MIN);\n-        assertTrue(entries.contains(newEntry));\n-        assertTrue(entries.remove(newEntry));\n-        assertFalse(entries.remove(newEntry));\n-        assertFalse(entries.contains(newEntry));\n+        assertThat(entries.contains(newEntry)).isTrue();\n+        assertThat(entries.remove(newEntry)).isTrue();\n+        assertThat(entries.remove(newEntry)).isFalse();\n+        assertThat(entries.contains(newEntry)).isFalse();\n       }\n       checkEmpty(entries);\n       checkEmpty(cache);\n@@ -276,11 +278,11 @@ public void testWriteThroughEntry() {\n       Entry<Object, Object> entry = Iterables.getOnlyElement(cache.asMap().entrySet());\n \n       cache.invalidate(1);\n-      assertEquals(0, cache.size());\n+      assertThat(cache.size()).isEqualTo(0);\n \n       entry.setValue(3);\n-      assertEquals(1, cache.size());\n-      assertEquals(3, cache.getIfPresent(1));\n+      assertThat(cache.size()).isEqualTo(1);\n+      assertThat(cache.getIfPresent(1)).isEqualTo(3);\n       checkValidState(cache);\n \n       assertThrows(NullPointerException.class, () -> entry.setValue(null));\n@@ -356,25 +358,26 @@ private Entry<Object, Object> entryOf(Object key, Object value) {\n   }\n \n   private void assertMapSize(Map<?, ?> map, int size) {\n-    assertEquals(size, map.size());\n+    assertThat(map).hasSize(size);\n     if (size > 0) {\n-      assertFalse(map.isEmpty());\n+      assertThat(map.isEmpty()).isFalse();\n     } else {\n-      assertTrue(map.isEmpty());\n+      assertThat(map.isEmpty()).isTrue();\n     }\n     assertCollectionSize(map.keySet(), size);\n     assertCollectionSize(map.entrySet(), size);\n     assertCollectionSize(map.values(), size);\n   }\n \n+  @SuppressWarnings(\"IterablesSizeOfCollection\") // we are testing our iterator implementation\n   private void assertCollectionSize(Collection<?> collection, int size) {\n-    assertEquals(size, collection.size());\n+    assertThat(collection.size()).isEqualTo(size);\n     if (size > 0) {\n-      assertFalse(collection.isEmpty());\n+      assertThat(collection.isEmpty()).isFalse();\n     } else {\n-      assertTrue(collection.isEmpty());\n+      assertThat(collection.isEmpty()).isTrue();\n     }\n-    assertEquals(size, Iterables.size(collection));\n-    assertEquals(size, Iterators.size(collection.iterator()));\n+    assertThat(Iterables.size(collection)).isEqualTo(size);\n+    assertThat(Iterators.size(collection.iterator())).isEqualTo(size);\n   }\n }"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/AbstractCacheTest.java",
      "status": "modified",
      "additions": 24,
      "deletions": 26,
      "changes": 50,
      "patch": "@@ -21,7 +21,6 @@\n import com.google.common.cache.AbstractCache.SimpleStatsCounter;\n import com.google.common.cache.AbstractCache.StatsCounter;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -47,11 +46,11 @@ public void testGetIfPresent() {\n           }\n         };\n \n-    assertNull(cache.getIfPresent(new Object()));\n+    assertThat(cache.getIfPresent(new Object())).isNull();\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getIfPresent(new Object()));\n+    assertThat(cache.getIfPresent(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetAllPresent_empty() {\n@@ -63,7 +62,7 @@ public void testGetAllPresent_empty() {\n           }\n         };\n \n-    assertEquals(ImmutableMap.of(), cache.getAllPresent(ImmutableList.of(new Object())));\n+    assertThat(cache.getAllPresent(ImmutableList.of(new Object()))).isEmpty();\n   }\n \n   public void testGetAllPresent_cached() {\n@@ -77,9 +76,8 @@ public void testGetAllPresent_cached() {\n           }\n         };\n \n-    assertEquals(\n-        ImmutableMap.of(cachedKey, cachedValue),\n-        cache.getAllPresent(ImmutableList.of(cachedKey, new Object())));\n+    assertThat(cache.getAllPresent(ImmutableList.of(cachedKey, new Object())))\n+        .containsExactly(cachedKey, cachedValue);\n   }\n \n   public void testInvalidateAll() {\n@@ -99,23 +97,23 @@ public void invalidate(Object key) {\n \n     List<Integer> toInvalidate = ImmutableList.of(1, 2, 3, 4);\n     cache.invalidateAll(toInvalidate);\n-    assertEquals(toInvalidate, invalidated);\n+    assertThat(invalidated).isEqualTo(toInvalidate);\n   }\n \n   public void testEmptySimpleStats() {\n     StatsCounter counter = new SimpleStatsCounter();\n     CacheStats stats = counter.snapshot();\n-    assertEquals(0, stats.requestCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n     assertThat(stats.hitRate()).isEqualTo(1.0);\n-    assertEquals(0, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n     assertThat(stats.missRate()).isEqualTo(0.0);\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.loadCount());\n-    assertEquals(0, stats.totalLoadTime());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.loadCount()).isEqualTo(0);\n+    assertThat(stats.totalLoadTime()).isEqualTo(0);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n   }\n \n   public void testSingleSimpleStats() {\n@@ -137,26 +135,26 @@ public void testSingleSimpleStats() {\n     }\n     CacheStats stats = counter.snapshot();\n     int requestCount = 11 + 23;\n-    assertEquals(requestCount, stats.requestCount());\n-    assertEquals(11, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(requestCount);\n+    assertThat(stats.hitCount()).isEqualTo(11);\n     assertThat(stats.hitRate()).isEqualTo(11.0 / requestCount);\n     int missCount = 23;\n-    assertEquals(missCount, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(missCount);\n     assertThat(stats.missRate()).isEqualTo(((double) missCount) / requestCount);\n-    assertEquals(13, stats.loadSuccessCount());\n-    assertEquals(17, stats.loadExceptionCount());\n-    assertEquals(13 + 17, stats.loadCount());\n-    assertEquals(214, stats.totalLoadTime());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(13);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(17);\n+    assertThat(stats.loadCount()).isEqualTo(13 + 17);\n+    assertThat(stats.totalLoadTime()).isEqualTo(214);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(214.0 / (13 + 17));\n-    assertEquals(27, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(27);\n   }\n \n   public void testSimpleStatsOverflow() {\n     StatsCounter counter = new SimpleStatsCounter();\n     counter.recordLoadSuccess(Long.MAX_VALUE);\n     counter.recordLoadSuccess(1);\n     CacheStats stats = counter.snapshot();\n-    assertEquals(Long.MAX_VALUE, stats.totalLoadTime());\n+    assertThat(stats.totalLoadTime()).isEqualTo(Long.MAX_VALUE);\n   }\n \n   public void testSimpleStatsIncrementBy() {\n@@ -201,6 +199,6 @@ public void testSimpleStatsIncrementBy() {\n     }\n \n     counter1.incrementBy(counter2);\n-    assertEquals(new CacheStats(38, 60, 44, 54, totalLoadTime, 66), counter1.snapshot());\n+    assertThat(counter1.snapshot()).isEqualTo(new CacheStats(38, 60, 44, 54, totalLoadTime, 66));\n   }\n }"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "patch": "@@ -61,7 +61,7 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetUnchecked_unchecked() {\n@@ -90,7 +90,7 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetUnchecked_error() {\n@@ -119,7 +119,7 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetUnchecked_otherThrowable() {\n@@ -148,6 +148,6 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n }"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java",
      "status": "modified",
      "additions": 146,
      "deletions": 119,
      "changes": 265,
      "patch": "@@ -16,6 +16,7 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n \n import com.google.common.annotations.GwtCompatible;\n@@ -31,8 +32,11 @@\n import java.util.concurrent.Callable;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ExecutionException;\n-import junit.framework.TestCase;\n import org.jspecify.annotations.NullUnmarked;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n \n /**\n  * Test suite for {@link CacheBuilder}. TODO(cpovirk): merge into CacheBuilderTest?\n@@ -41,18 +45,18 @@\n  */\n @GwtCompatible\n @NullUnmarked\n-public class CacheBuilderGwtTest extends TestCase {\n+@RunWith(JUnit4.class)\n+public class CacheBuilderGwtTest {\n \n   private FakeTicker fakeTicker;\n \n-  @Override\n-  protected void setUp() throws Exception {\n-    super.setUp();\n-\n+  @Before\n+  public void setUp() {\n     fakeTicker = new FakeTicker();\n   }\n \n-  public void testLoader() throws ExecutionException {\n+  @Test\n+  public void loader() throws ExecutionException {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     Callable<Integer> loader =\n@@ -67,19 +71,20 @@ public Integer call() throws Exception {\n \n     cache.put(0, 10);\n \n-    assertEquals(Integer.valueOf(10), cache.get(0, loader));\n-    assertEquals(Integer.valueOf(1), cache.get(20, loader));\n-    assertEquals(Integer.valueOf(2), cache.get(34, loader));\n+    assertThat(cache.get(0, loader)).isEqualTo(10);\n+    assertThat(cache.get(20, loader)).isEqualTo(1);\n+    assertThat(cache.get(34, loader)).isEqualTo(2);\n \n     cache.invalidate(0);\n-    assertEquals(Integer.valueOf(3), cache.get(0, loader));\n+    assertThat(cache.get(0, loader)).isEqualTo(3);\n \n     cache.put(0, 10);\n     cache.invalidateAll();\n-    assertEquals(Integer.valueOf(4), cache.get(0, loader));\n+    assertThat(cache.get(0, loader)).isEqualTo(4);\n   }\n \n-  public void testSizeConstraint() {\n+  @Test\n+  public void sizeConstraint() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().maximumSize(4).build();\n \n     cache.put(1, 10);\n@@ -88,22 +93,24 @@ public void testSizeConstraint() {\n     cache.put(4, 40);\n     cache.put(5, 50);\n \n-    assertEquals(null, cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isNull();\n     // Order required to remove dependence on access order / write order constraint.\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));\n-    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(3)).isEqualTo(30);\n+    assertThat(cache.getIfPresent(4)).isEqualTo(40);\n+    assertThat(cache.getIfPresent(5)).isEqualTo(50);\n \n     cache.put(1, 10);\n-    assertEquals(Integer.valueOf(10), cache.getIfPresent(1));\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));\n-    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));\n-    assertEquals(null, cache.getIfPresent(2));\n+    assertThat(cache.getIfPresent(1)).isEqualTo(10);\n+    assertThat(cache.getIfPresent(3)).isEqualTo(30);\n+    assertThat(cache.getIfPresent(4)).isEqualTo(40);\n+    assertThat(cache.getIfPresent(5)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(2)).isNull();\n   }\n \n-  public void testLoadingCache() throws ExecutionException {\n+  @SuppressWarnings({\"deprecation\", \"LoadingCacheApply\"})\n+  @Test\n+  public void loadingCache() throws ExecutionException {\n     CacheLoader<Integer, Integer> loader =\n         new CacheLoader<Integer, Integer>() {\n           int i = 0;\n@@ -120,32 +127,34 @@ public Integer load(Integer key) throws Exception {\n \n     Map<Integer, Integer> map = cache.getAll(ImmutableList.of(10, 20, 30, 54, 443, 1));\n \n-    assertEquals(Integer.valueOf(20), map.get(10));\n-    assertEquals(Integer.valueOf(0), map.get(20));\n-    assertEquals(Integer.valueOf(1), map.get(30));\n-    assertEquals(Integer.valueOf(2), map.get(54));\n-    assertEquals(Integer.valueOf(3), map.get(443));\n-    assertEquals(Integer.valueOf(4), map.get(1));\n-    assertEquals(Integer.valueOf(5), cache.get(6));\n-    assertEquals(Integer.valueOf(6), cache.apply(7));\n+    assertThat(map).containsEntry(10, 20);\n+    assertThat(map).containsEntry(20, 0);\n+    assertThat(map).containsEntry(30, 1);\n+    assertThat(map).containsEntry(54, 2);\n+    assertThat(map).containsEntry(443, 3);\n+    assertThat(map).containsEntry(1, 4);\n+    assertThat(cache.get(6)).isEqualTo(5);\n+    assertThat(cache.apply(7)).isEqualTo(6);\n   }\n \n-  public void testExpireAfterAccess() {\n+  @Test\n+  public void expireAfterAccess() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterAccess(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n     cache.put(0, 10);\n     cache.put(2, 30);\n \n     fakeTicker.advance(999, MILLISECONDS);\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(30);\n     fakeTicker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(30);\n     fakeTicker.advance(1000, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(0));\n+    assertThat(cache.getIfPresent(0)).isNull();\n   }\n \n-  public void testExpireAfterWrite() {\n+  @Test\n+  public void expireAfterWrite() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -154,23 +163,24 @@ public void testExpireAfterWrite() {\n     cache.put(4, 2);\n \n     fakeTicker.advance(999, MILLISECONDS);\n-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));\n-    assertEquals(Integer.valueOf(2), cache.getIfPresent(4));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(100);\n+    assertThat(cache.getIfPresent(20)).isEqualTo(200);\n+    assertThat(cache.getIfPresent(4)).isEqualTo(2);\n \n     fakeTicker.advance(2, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n-    assertEquals(null, cache.getIfPresent(20));\n-    assertEquals(null, cache.getIfPresent(4));\n+    assertThat(cache.getIfPresent(10)).isNull();\n+    assertThat(cache.getIfPresent(20)).isNull();\n+    assertThat(cache.getIfPresent(4)).isNull();\n \n     cache.put(10, 20);\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(20);\n \n     fakeTicker.advance(1000, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isNull();\n   }\n \n-  public void testExpireAfterWriteAndAccess() {\n+  @Test\n+  public void expireAfterWriteAndAccess() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder()\n             .expireAfterWrite(1000, MILLISECONDS)\n@@ -183,26 +193,28 @@ public void testExpireAfterWriteAndAccess() {\n     cache.put(4, 2);\n \n     fakeTicker.advance(499, MILLISECONDS);\n-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(100);\n+    assertThat(cache.getIfPresent(20)).isEqualTo(200);\n \n     fakeTicker.advance(2, MILLISECONDS);\n-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));\n-    assertEquals(null, cache.getIfPresent(4));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(100);\n+    assertThat(cache.getIfPresent(20)).isEqualTo(200);\n+    assertThat(cache.getIfPresent(4)).isNull();\n \n     fakeTicker.advance(499, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n-    assertEquals(null, cache.getIfPresent(20));\n+    assertThat(cache.getIfPresent(10)).isNull();\n+    assertThat(cache.getIfPresent(20)).isNull();\n \n     cache.put(10, 20);\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(20);\n \n     fakeTicker.advance(500, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isNull();\n   }\n \n-  public void testMapMethods() {\n+  @SuppressWarnings(\"ContainsEntryAfterGetInteger\") // we are testing our implementation of Map.get\n+  @Test\n+  public void mapMethods() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     ConcurrentMap<Integer, Integer> asMap = cache.asMap();\n@@ -213,38 +225,39 @@ public void testMapMethods() {\n     asMap.replace(2, 79);\n     asMap.replace(3, 60);\n \n-    assertEquals(null, cache.getIfPresent(3));\n-    assertEquals(null, asMap.get(3));\n+    assertThat(cache.getIfPresent(3)).isNull();\n+    assertThat(asMap.get(3)).isNull();\n \n-    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(79), asMap.get(2));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(79);\n+    assertThat(asMap.get(2)).isEqualTo(79);\n \n     asMap.replace(10, 100, 50);\n     asMap.replace(2, 52, 99);\n \n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), asMap.get(10));\n-    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(79), asMap.get(2));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(asMap.get(10)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(2)).isEqualTo(79);\n+    assertThat(asMap.get(2)).isEqualTo(79);\n \n     asMap.remove(10, 100);\n     asMap.remove(2, 79);\n \n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), asMap.get(10));\n-    assertEquals(null, cache.getIfPresent(2));\n-    assertEquals(null, asMap.get(2));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(asMap.get(10)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(2)).isNull();\n+    assertThat(asMap.get(2)).isNull();\n \n     asMap.putIfAbsent(2, 20);\n     asMap.putIfAbsent(10, 20);\n \n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(20), asMap.get(2));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), asMap.get(10));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(20);\n+    assertThat(asMap.get(2)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(asMap.get(10)).isEqualTo(50);\n   }\n \n-  public void testRemovalListener() {\n+  @Test\n+  public void removalListener() {\n     int[] stats = new int[4];\n \n     RemovalListener<Integer, Integer> countingListener =\n@@ -303,30 +316,32 @@ public void onRemoval(RemovalNotification<Integer, Integer> notification) {\n \n     cache.invalidateAll();\n \n-    assertEquals(2, stats[0]);\n-    assertEquals(2, stats[1]);\n-    assertEquals(4, stats[2]);\n-    assertEquals(3, stats[3]);\n+    assertThat(stats[0]).isEqualTo(2);\n+    assertThat(stats[1]).isEqualTo(2);\n+    assertThat(stats[2]).isEqualTo(4);\n+    assertThat(stats[3]).isEqualTo(3);\n   }\n \n-  public void testPutAll() {\n+  @Test\n+  public void putAll() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     cache.putAll(ImmutableMap.of(10, 20, 30, 50, 60, 90));\n \n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(30));\n-    assertEquals(Integer.valueOf(90), cache.getIfPresent(60));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(30)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(60)).isEqualTo(90);\n \n     cache.asMap().putAll(ImmutableMap.of(10, 50, 30, 20, 60, 70, 5, 5));\n \n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(30));\n-    assertEquals(Integer.valueOf(70), cache.getIfPresent(60));\n-    assertEquals(Integer.valueOf(5), cache.getIfPresent(5));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(30)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(60)).isEqualTo(70);\n+    assertThat(cache.getIfPresent(5)).isEqualTo(5);\n   }\n \n-  public void testInvalidate() {\n+  @Test\n+  public void invalidate() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     cache.put(654, 2675);\n@@ -335,22 +350,23 @@ public void testInvalidate() {\n \n     cache.invalidate(654);\n \n-    assertFalse(cache.asMap().containsKey(654));\n-    assertTrue(cache.asMap().containsKey(2456));\n-    assertTrue(cache.asMap().containsKey(2));\n+    assertThat(cache.asMap().containsKey(654)).isFalse();\n+    assertThat(cache.asMap().containsKey(2456)).isTrue();\n+    assertThat(cache.asMap().containsKey(2)).isTrue();\n   }\n \n-  public void testInvalidateAll() {\n+  @Test\n+  public void invalidateAll() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     cache.put(654, 2675);\n     cache.put(2456, 56);\n     cache.put(2, 15);\n \n     cache.invalidateAll();\n-    assertFalse(cache.asMap().containsKey(654));\n-    assertFalse(cache.asMap().containsKey(2456));\n-    assertFalse(cache.asMap().containsKey(2));\n+    assertThat(cache.asMap().containsKey(654)).isFalse();\n+    assertThat(cache.asMap().containsKey(2456)).isFalse();\n+    assertThat(cache.asMap().containsKey(2)).isFalse();\n \n     cache.put(654, 2675);\n     cache.put(2456, 56);\n@@ -359,13 +375,14 @@ public void testInvalidateAll() {\n \n     cache.invalidateAll(ImmutableSet.of(1, 2));\n \n-    assertFalse(cache.asMap().containsKey(1));\n-    assertFalse(cache.asMap().containsKey(2));\n-    assertTrue(cache.asMap().containsKey(654));\n-    assertTrue(cache.asMap().containsKey(2456));\n+    assertThat(cache.asMap().containsKey(1)).isFalse();\n+    assertThat(cache.asMap().containsKey(2)).isFalse();\n+    assertThat(cache.asMap().containsKey(654)).isTrue();\n+    assertThat(cache.asMap().containsKey(2456)).isTrue();\n   }\n \n-  public void testAsMap_containsValue() {\n+  @Test\n+  public void asMap_containsValue() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(20000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -376,12 +393,15 @@ public void testAsMap_containsValue() {\n \n     fakeTicker.advance(10001, MILLISECONDS);\n \n-    assertTrue(cache.asMap().containsValue(15));\n-    assertTrue(cache.asMap().containsValue(56));\n-    assertFalse(cache.asMap().containsValue(2675));\n+    assertThat(cache.asMap().containsValue(15)).isTrue();\n+    assertThat(cache.asMap().containsValue(56)).isTrue();\n+    assertThat(cache.asMap().containsValue(2675)).isFalse();\n   }\n \n-  public void testAsMap_containsKey() {\n+  // we are testing our implementation of Map.containsKey\n+  @SuppressWarnings(\"ContainsEntryAfterGetInteger\")\n+  @Test\n+  public void asMap_containsKey() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(20000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -392,12 +412,15 @@ public void testAsMap_containsKey() {\n \n     fakeTicker.advance(10001, MILLISECONDS);\n \n-    assertTrue(cache.asMap().containsKey(2));\n-    assertTrue(cache.asMap().containsKey(2456));\n-    assertFalse(cache.asMap().containsKey(654));\n+    assertThat(cache.asMap().containsKey(2)).isTrue();\n+    assertThat(cache.asMap().containsKey(2456)).isTrue();\n+    assertThat(cache.asMap().containsKey(654)).isFalse();\n   }\n \n-  public void testAsMapValues_contains() {\n+  // we are testing our implementation of Map.values().contains\n+  @SuppressWarnings(\"ValuesContainsValue\")\n+  @Test\n+  public void asMapValues_contains() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -408,12 +431,13 @@ public void testAsMapValues_contains() {\n \n     fakeTicker.advance(501, MILLISECONDS);\n \n-    assertTrue(cache.asMap().values().contains(22));\n-    assertTrue(cache.asMap().values().contains(10));\n-    assertFalse(cache.asMap().values().contains(20));\n+    assertThat(cache.asMap().values().contains(22)).isTrue();\n+    assertThat(cache.asMap().values().contains(10)).isTrue();\n+    assertThat(cache.asMap().values().contains(20)).isFalse();\n   }\n \n-  public void testAsMapKeySet() {\n+  @Test\n+  public void asMapKeySet() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -426,10 +450,11 @@ public void testAsMapKeySet() {\n \n     Set<Integer> foundKeys = new HashSet<>(cache.asMap().keySet());\n \n-    assertEquals(ImmutableSet.of(20, 5), foundKeys);\n+    assertThat(foundKeys).containsExactly(20, 5);\n   }\n \n-  public void testAsMapKeySet_contains() {\n+  @Test\n+  public void asMapKeySet_contains() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -440,12 +465,13 @@ public void testAsMapKeySet_contains() {\n \n     fakeTicker.advance(501, MILLISECONDS);\n \n-    assertTrue(cache.asMap().keySet().contains(20));\n-    assertTrue(cache.asMap().keySet().contains(5));\n-    assertFalse(cache.asMap().keySet().contains(10));\n+    assertThat(cache.asMap().keySet().contains(20)).isTrue();\n+    assertThat(cache.asMap().keySet().contains(5)).isTrue();\n+    assertThat(cache.asMap().keySet().contains(10)).isFalse();\n   }\n \n-  public void testAsMapEntrySet() {\n+  @Test\n+  public void asMapEntrySet() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -460,10 +486,11 @@ public void testAsMapEntrySet() {\n     for (Entry<Integer, Integer> current : cache.asMap().entrySet()) {\n       sum += current.getKey() + current.getValue();\n     }\n-    assertEquals(57, sum);\n+    assertThat(sum).isEqualTo(57);\n   }\n \n-  public void testAsMapValues_iteratorRemove() {\n+  @Test\n+  public void asMapValues_iteratorRemove() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -472,6 +499,6 @@ public void testAsMapValues_iteratorRemove() {\n     iterator.next();\n     iterator.remove();\n \n-    assertEquals(0, cache.size());\n+    assertThat(cache.size()).isEqualTo(0);\n   }\n }"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java",
      "status": "modified",
      "additions": 157,
      "deletions": 136,
      "changes": 293,
      "patch": "@@ -18,6 +18,8 @@\n \n import static com.google.common.cache.CacheBuilderSpec.parse;\n import static com.google.common.cache.TestingWeighers.constantWeigher;\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.util.concurrent.TimeUnit.DAYS;\n import static java.util.concurrent.TimeUnit.HOURS;\n import static java.util.concurrent.TimeUnit.MINUTES;\n@@ -40,27 +42,27 @@\n public class CacheBuilderSpecTest extends TestCase {\n   public void testParse_empty() {\n     CacheBuilderSpec spec = parse(\"\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder(), CacheBuilder.from(spec));\n   }\n \n   public void testParse_initialCapacity() {\n     CacheBuilderSpec spec = parse(\"initialCapacity=10\");\n-    assertEquals(10, spec.initialCapacity.intValue());\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isEqualTo(10);\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().initialCapacity(10), CacheBuilder.from(spec));\n   }\n@@ -72,13 +74,13 @@ public void testParse_initialCapacityRepeated() {\n \n   public void testParse_maximumSize() {\n     CacheBuilderSpec spec = parse(\"maximumSize=9000\");\n-    assertNull(spec.initialCapacity);\n-    assertEquals(9000, spec.maximumSize.longValue());\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isEqualTo(9000L);\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().maximumSize(9000), CacheBuilder.from(spec));\n   }\n@@ -89,13 +91,13 @@ public void testParse_maximumSizeRepeated() {\n \n   public void testParse_maximumWeight() {\n     CacheBuilderSpec spec = parse(\"maximumWeight=9000\");\n-    assertNull(spec.initialCapacity);\n-    assertEquals(9000, spec.maximumWeight.longValue());\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumWeight).isEqualTo(9000L);\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().maximumWeight(9000), CacheBuilder.from(spec));\n   }\n@@ -110,14 +112,14 @@ public void testParse_maximumSizeAndMaximumWeight() {\n \n   public void testParse_concurrencyLevel() {\n     CacheBuilderSpec spec = parse(\"concurrencyLevel=32\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertEquals(32, spec.concurrencyLevel.intValue());\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isEqualTo(32);\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().concurrencyLevel(32), CacheBuilder.from(spec));\n   }\n@@ -129,14 +131,14 @@ public void testParse_concurrencyLevelRepeated() {\n \n   public void testParse_weakKeys() {\n     CacheBuilderSpec spec = parse(\"weakKeys\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertEquals(Strength.WEAK, spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().weakKeys(), CacheBuilder.from(spec));\n   }\n \n@@ -150,14 +152,14 @@ public void testParse_repeatedKeyStrength() {\n \n   public void testParse_softValues() {\n     CacheBuilderSpec spec = parse(\"softValues\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertEquals(Strength.SOFT, spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isEqualTo(Strength.SOFT);\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().softValues(), CacheBuilder.from(spec));\n   }\n \n@@ -167,14 +169,14 @@ public void testParse_softValuesCannotHaveValue() {\n \n   public void testParse_weakValues() {\n     CacheBuilderSpec spec = parse(\"weakValues\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertEquals(Strength.WEAK, spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().weakValues(), CacheBuilder.from(spec));\n   }\n \n@@ -194,39 +196,39 @@ public void testParse_repeatedValueStrength() {\n \n   public void testParse_writeExpirationDays() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=10d\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertEquals(DAYS, spec.writeExpirationTimeUnit);\n-    assertEquals(10L, spec.writeExpirationDuration);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(DAYS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(10L, DAYS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_writeExpirationHours() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=150h\");\n-    assertEquals(HOURS, spec.writeExpirationTimeUnit);\n-    assertEquals(150L, spec.writeExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(HOURS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(150L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(150L, HOURS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_writeExpirationMinutes() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=10m\");\n-    assertEquals(MINUTES, spec.writeExpirationTimeUnit);\n-    assertEquals(10L, spec.writeExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(10L, MINUTES), CacheBuilder.from(spec));\n   }\n \n   public void testParse_writeExpirationSeconds() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=10s\");\n-    assertEquals(SECONDS, spec.writeExpirationTimeUnit);\n-    assertEquals(10L, spec.writeExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(10L, SECONDS), CacheBuilder.from(spec));\n   }\n@@ -238,39 +240,39 @@ public void testParse_writeExpirationRepeated() {\n \n   public void testParse_accessExpirationDays() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10d\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertEquals(DAYS, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(DAYS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, DAYS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_accessExpirationHours() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=150h\");\n-    assertEquals(HOURS, spec.accessExpirationTimeUnit);\n-    assertEquals(150L, spec.accessExpirationDuration);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(HOURS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(150L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(150L, HOURS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_accessExpirationMinutes() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10m\");\n-    assertEquals(MINUTES, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, MINUTES), CacheBuilder.from(spec));\n   }\n \n   public void testParse_accessExpirationSeconds() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10s\");\n-    assertEquals(SECONDS, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, SECONDS), CacheBuilder.from(spec));\n   }\n@@ -282,7 +284,7 @@ public void testParse_accessExpirationRepeated() {\n \n   public void testParse_recordStats() {\n     CacheBuilderSpec spec = parse(\"recordStats\");\n-    assertTrue(spec.recordStats);\n+    assertThat(spec.recordStats).isTrue();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().recordStats(), CacheBuilder.from(spec));\n   }\n \n@@ -296,10 +298,10 @@ public void testParse_recordStatsRepeated() {\n \n   public void testParse_accessExpirationAndWriteExpiration() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10s,expireAfterWrite=9m\");\n-    assertEquals(MINUTES, spec.writeExpirationTimeUnit);\n-    assertEquals(9L, spec.writeExpirationDuration);\n-    assertEquals(SECONDS, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(9L);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, SECONDS).expireAfterWrite(9L, MINUTES),\n         CacheBuilder.from(spec));\n@@ -310,16 +312,16 @@ public void testParse_multipleKeys() {\n         parse(\n             \"initialCapacity=10,maximumSize=20,concurrencyLevel=30,\"\n                 + \"weakKeys,weakValues,expireAfterAccess=10m,expireAfterWrite=1h\");\n-    assertEquals(10, spec.initialCapacity.intValue());\n-    assertEquals(20, spec.maximumSize.intValue());\n-    assertNull(spec.maximumWeight);\n-    assertEquals(30, spec.concurrencyLevel.intValue());\n-    assertEquals(Strength.WEAK, spec.keyStrength);\n-    assertEquals(Strength.WEAK, spec.valueStrength);\n-    assertEquals(HOURS, spec.writeExpirationTimeUnit);\n-    assertEquals(MINUTES, spec.accessExpirationTimeUnit);\n-    assertEquals(1L, spec.writeExpirationDuration);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.initialCapacity).isEqualTo(10);\n+    assertThat(spec.maximumSize).isEqualTo(20);\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isEqualTo(30);\n+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.valueStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(HOURS);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(1L);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     CacheBuilder<?, ?> expected =\n         CacheBuilder.newBuilder()\n             .initialCapacity(10)\n@@ -337,15 +339,15 @@ public void testParse_whitespaceAllowed() {\n         parse(\n             \" initialCapacity=10,\\nmaximumSize=20,\\t\\r\"\n                 + \"weakKeys \\t ,softValues \\n , \\r  expireAfterWrite \\t =  15s\\n\\n\");\n-    assertEquals(10, spec.initialCapacity.intValue());\n-    assertEquals(20, spec.maximumSize.intValue());\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertEquals(Strength.WEAK, spec.keyStrength);\n-    assertEquals(Strength.SOFT, spec.valueStrength);\n-    assertEquals(SECONDS, spec.writeExpirationTimeUnit);\n-    assertEquals(15L, spec.writeExpirationDuration);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isEqualTo(10);\n+    assertThat(spec.maximumSize).isEqualTo(20);\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.valueStrength).isEqualTo(Strength.SOFT);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(15L);\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     CacheBuilder<?, ?> expected =\n         CacheBuilder.newBuilder()\n             .initialCapacity(10)\n@@ -424,9 +426,9 @@ public void testDisableCaching() {\n     Object value = new Object();\n     LoadingCache<Object, Object> cache =\n         builder.build(CacheLoader.from(Suppliers.ofInstance(value)));\n-    assertSame(value, cache.getUnchecked(key));\n-    assertEquals(0, cache.size());\n-    assertFalse(cache.asMap().containsKey(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);\n+    assertThat(cache.size()).isEqualTo(0);\n+    assertThat(cache.asMap().containsKey(key)).isFalse();\n   }\n \n   public void testCacheBuilderFrom_string() {\n@@ -445,22 +447,41 @@ public void testCacheBuilderFrom_string() {\n     assertCacheBuilderEquivalence(expected, fromString);\n   }\n \n-  private static void assertCacheBuilderEquivalence(CacheBuilder<?, ?> a, CacheBuilder<?, ?> b) {\n-    assertEquals(\"concurrencyLevel\", a.concurrencyLevel, b.concurrencyLevel);\n-    assertEquals(\"expireAfterAccessNanos\", a.expireAfterAccessNanos, b.expireAfterAccessNanos);\n-    assertEquals(\"expireAfterWriteNanos\", a.expireAfterWriteNanos, b.expireAfterWriteNanos);\n-    assertEquals(\"initialCapacity\", a.initialCapacity, b.initialCapacity);\n-    assertEquals(\"maximumSize\", a.maximumSize, b.maximumSize);\n-    assertEquals(\"maximumWeight\", a.maximumWeight, b.maximumWeight);\n-    assertEquals(\"refreshNanos\", a.refreshNanos, b.refreshNanos);\n-    assertEquals(\"keyEquivalence\", a.keyEquivalence, b.keyEquivalence);\n-    assertEquals(\"keyStrength\", a.keyStrength, b.keyStrength);\n-    assertEquals(\"removalListener\", a.removalListener, b.removalListener);\n-    assertEquals(\"weigher\", a.weigher, b.weigher);\n-    assertEquals(\"valueEquivalence\", a.valueEquivalence, b.valueEquivalence);\n-    assertEquals(\"valueStrength\", a.valueStrength, b.valueStrength);\n-    assertEquals(\"statsCounterSupplier\", a.statsCounterSupplier, b.statsCounterSupplier);\n-    assertEquals(\"ticker\", a.ticker, b.ticker);\n-    assertEquals(\"recordStats\", a.isRecordingStats(), b.isRecordingStats());\n+  private static void assertCacheBuilderEquivalence(\n+      CacheBuilder<?, ?> expected, CacheBuilder<?, ?> actual) {\n+    assertWithMessage(\"concurrencyLevel\")\n+        .that(actual.concurrencyLevel)\n+        .isEqualTo(expected.concurrencyLevel);\n+    assertWithMessage(\"expireAfterAccessNanos\")\n+        .that(actual.expireAfterAccessNanos)\n+        .isEqualTo(expected.expireAfterAccessNanos);\n+    assertWithMessage(\"expireAfterWriteNanos\")\n+        .that(actual.expireAfterWriteNanos)\n+        .isEqualTo(expected.expireAfterWriteNanos);\n+    assertWithMessage(\"initialCapacity\")\n+        .that(actual.initialCapacity)\n+        .isEqualTo(expected.initialCapacity);\n+    assertWithMessage(\"maximumSize\").that(actual.maximumSize).isEqualTo(expected.maximumSize);\n+    assertWithMessage(\"maximumWeight\").that(actual.maximumWeight).isEqualTo(expected.maximumWeight);\n+    assertWithMessage(\"refreshNanos\").that(actual.refreshNanos).isEqualTo(expected.refreshNanos);\n+    assertWithMessage(\"keyEquivalence\")\n+        .that(actual.keyEquivalence)\n+        .isEqualTo(expected.keyEquivalence);\n+    assertWithMessage(\"keyStrength\").that(actual.keyStrength).isEqualTo(expected.keyStrength);\n+    assertWithMessage(\"removalListener\")\n+        .that(actual.removalListener)\n+        .isEqualTo(expected.removalListener);\n+    assertWithMessage(\"weigher\").that(actual.weigher).isEqualTo(expected.weigher);\n+    assertWithMessage(\"valueEquivalence\")\n+        .that(actual.valueEquivalence)\n+        .isEqualTo(expected.valueEquivalence);\n+    assertWithMessage(\"valueStrength\").that(actual.valueStrength).isEqualTo(expected.valueStrength);\n+    assertWithMessage(\"statsCounterSupplier\")\n+        .that(actual.statsCounterSupplier)\n+        .isEqualTo(expected.statsCounterSupplier);\n+    assertWithMessage(\"ticker\").that(actual.ticker).isEqualTo(expected.ticker);\n+    assertWithMessage(\"recordStats\")\n+        .that(actual.isRecordingStats())\n+        .isEqualTo(expected.isRecordingStats());\n   }\n }"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/CacheBuilderTest.java",
      "status": "modified",
      "additions": 36,
      "deletions": 33,
      "changes": 69,
      "patch": "@@ -24,6 +24,7 @@\n import static com.google.common.cache.TestingRemovalListeners.queuingRemovalListener;\n import static com.google.common.cache.TestingWeighers.constantWeigher;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.util.concurrent.Executors.newFixedThreadPool;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n@@ -63,8 +64,8 @@ public void testNewBuilder() {\n     LoadingCache<String, Integer> cache =\n         CacheBuilder.newBuilder().removalListener(countingRemovalListener()).build(loader);\n \n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(\"one\"));\n-    assertEquals(1, cache.size());\n+    assertThat(cache.getUnchecked(\"one\")).isEqualTo(1);\n+    assertThat(cache.size()).isEqualTo(1);\n   }\n \n   public void testInitialCapacity_negative() {\n@@ -83,10 +84,10 @@ public void testInitialCapacity_small() {\n     LocalCache<?, ?> map = CacheTesting.toLocalCache(cache);\n \n     assertThat(map.segments).hasLength(4);\n-    assertEquals(2, map.segments[0].table.length());\n-    assertEquals(2, map.segments[1].table.length());\n-    assertEquals(2, map.segments[2].table.length());\n-    assertEquals(2, map.segments[3].table.length());\n+    assertThat(map.segments[0].table.length()).isEqualTo(2);\n+    assertThat(map.segments[1].table.length()).isEqualTo(2);\n+    assertThat(map.segments[2].table.length()).isEqualTo(2);\n+    assertThat(map.segments[3].table.length()).isEqualTo(2);\n   }\n \n   @GwtIncompatible // CacheTesting\n@@ -96,10 +97,10 @@ public void testInitialCapacity_smallest() {\n \n     assertThat(map.segments).hasLength(4);\n     // 1 is as low as it goes, not 0. it feels dirty to know this/test this.\n-    assertEquals(1, map.segments[0].table.length());\n-    assertEquals(1, map.segments[1].table.length());\n-    assertEquals(1, map.segments[2].table.length());\n-    assertEquals(1, map.segments[3].table.length());\n+    assertThat(map.segments[0].table.length()).isEqualTo(1);\n+    assertThat(map.segments[1].table.length()).isEqualTo(1);\n+    assertThat(map.segments[2].table.length()).isEqualTo(1);\n+    assertThat(map.segments[3].table.length()).isEqualTo(1);\n   }\n \n   public void testInitialCapacity_large() {\n@@ -327,19 +328,19 @@ public void testRemovalListener_setTwice() {\n   }\n \n   public void testValuesIsNotASet() {\n-    assertFalse(CacheBuilder.newBuilder().build().asMap().values() instanceof Set);\n+    assertThat(CacheBuilder.newBuilder().build().asMap().values() instanceof Set).isFalse();\n   }\n \n   @GwtIncompatible // CacheTesting\n   public void testNullCache() {\n     CountingRemovalListener<Object, Object> listener = countingRemovalListener();\n     LoadingCache<Object, Object> nullCache =\n         CacheBuilder.newBuilder().maximumSize(0).removalListener(listener).build(identityLoader());\n-    assertEquals(0, nullCache.size());\n+    assertThat(nullCache.size()).isEqualTo(0);\n     Object key = new Object();\n-    assertSame(key, nullCache.getUnchecked(key));\n-    assertEquals(1, listener.getCount());\n-    assertEquals(0, nullCache.size());\n+    assertThat(nullCache.getUnchecked(key)).isSameInstanceAs(key);\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(nullCache.size()).isEqualTo(0);\n     CacheTesting.checkEmpty(nullCache.asMap());\n   }\n \n@@ -396,12 +397,12 @@ public void run() {\n     // At this point, the listener should be holding the seed value (a -> a), and the map should\n     // contain the computed value (b -> b), since the clear() happened before the computation\n     // completed.\n-    assertEquals(1, listener.size());\n+    assertThat(listener).hasSize(1);\n     RemovalNotification<String, String> notification = listener.remove();\n-    assertEquals(\"a\", notification.getKey());\n-    assertEquals(\"a\", notification.getValue());\n-    assertEquals(1, cache.size());\n-    assertEquals(\"b\", cache.getUnchecked(\"b\"));\n+    assertThat(notification.getKey()).isEqualTo(\"a\");\n+    assertThat(notification.getValue()).isEqualTo(\"a\");\n+    assertThat(cache.size()).isEqualTo(1);\n+    assertThat(cache.getUnchecked(\"b\")).isEqualTo(\"b\");\n   }\n \n   // \"Basher tests\", where we throw a bunch of stuff at a LoadingCache and check basic invariants.\n@@ -476,22 +477,22 @@ public void run() {\n     Map<String, String> removalNotifications = new HashMap<>();\n     for (RemovalNotification<String, String> notification : listener) {\n       removalNotifications.put(notification.getKey(), notification.getValue());\n-      assertEquals(\n-          \"Unexpected key/value pair passed to removalListener\",\n-          notification.getKey(),\n-          notification.getValue());\n+      assertWithMessage(\"Unexpected key/value pair passed to removalListener\")\n+          .that(notification.getValue())\n+          .isEqualTo(notification.getKey());\n     }\n \n     // All of the seed values should have been visible, so we should have gotten removal\n     // notifications for all of them.\n     for (int i = 0; i < nSeededEntries; i++) {\n-      assertEquals(\"b\" + i, removalNotifications.get(\"b\" + i));\n+      assertThat(removalNotifications.get(\"b\" + i)).isEqualTo(\"b\" + i);\n     }\n \n     // Each of the values added to the map should either still be there, or have seen a removal\n     // notification.\n-    assertEquals(expectedKeys, Sets.union(cache.asMap().keySet(), removalNotifications.keySet()));\n-    assertTrue(Sets.intersection(cache.asMap().keySet(), removalNotifications.keySet()).isEmpty());\n+    assertThat(Sets.union(cache.asMap().keySet(), removalNotifications.keySet()))\n+        .isEqualTo(expectedKeys);\n+    assertThat(cache.asMap().keySet()).containsNoneIn(removalNotifications.keySet());\n     threadPool.shutdown();\n     threadPool.awaitTermination(300, SECONDS);\n   }\n@@ -570,15 +571,17 @@ public void run() {\n \n     // Verify that each received removal notification was valid\n     for (RemovalNotification<String, String> notification : removalListener) {\n-      assertEquals(\"Invalid removal notification\", notification.getKey(), notification.getValue());\n+      assertWithMessage(\"Invalid removal notification\")\n+          .that(notification.getValue())\n+          .isEqualTo(notification.getKey());\n     }\n \n     CacheStats stats = cache.stats();\n-    assertEquals(removalListener.size(), stats.evictionCount());\n-    assertEquals(computeCount.get(), stats.loadSuccessCount());\n-    assertEquals(exceptionCount.get() + computeNullCount.get(), stats.loadExceptionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(removalListener.size());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(computeCount.get());\n+    assertThat(stats.loadExceptionCount()).isEqualTo(exceptionCount.get() + computeNullCount.get());\n     // each computed value is still in the cache, or was passed to the removal listener\n-    assertEquals(computeCount.get(), cache.size() + removalListener.size());\n+    assertThat(cache.size() + removalListener.size()).isEqualTo(computeCount.get());\n   }\n \n   @GwtIncompatible // NullPointerTester\n@@ -593,7 +596,7 @@ public void testSizingDefaults() {\n     LoadingCache<?, ?> cache = CacheBuilder.newBuilder().build(identityLoader());\n     LocalCache<?, ?> map = CacheTesting.toLocalCache(cache);\n     assertThat(map.segments).hasLength(4); // concurrency level\n-    assertEquals(4, map.segments[0].table.length()); // capacity / conc level\n+    assertThat(map.segments[0].table.length()).isEqualTo(4); // capacity / conc level\n   }\n \n   @GwtIncompatible // CountDownLatch"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/CacheEvictionTest.java",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "patch": "@@ -45,7 +45,7 @@ public void testEviction_setMaxSegmentSize() {\n     IdentityLoader<Object> loader = identityLoader();\n     for (int i = 1; i < 1000; i++) {\n       LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().maximumSize(i).build(loader);\n-      assertEquals(i, CacheTesting.getTotalSegmentSize(cache));\n+      assertThat(CacheTesting.getTotalSegmentSize(cache)).isEqualTo(i);\n     }\n   }\n \n@@ -54,7 +54,7 @@ public void testEviction_setMaxSegmentWeight() {\n     for (int i = 1; i < 1000; i++) {\n       LoadingCache<Object, Object> cache =\n           CacheBuilder.newBuilder().maximumWeight(i).weigher(constantWeigher(1)).build(loader);\n-      assertEquals(i, CacheTesting.getTotalSegmentSize(cache));\n+      assertThat(CacheTesting.getTotalSegmentSize(cache)).isEqualTo(i);\n     }\n   }\n \n@@ -64,10 +64,10 @@ public void testEviction_maxSizeOneSegment() {\n         CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(MAX_SIZE).build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertEquals(min(i + 1, MAX_SIZE), cache.size());\n+      assertThat(cache.size()).isEqualTo(min(i + 1, MAX_SIZE));\n     }\n \n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -81,10 +81,10 @@ public void testEviction_maxWeightOneSegment() {\n             .build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertEquals(min(i + 1, MAX_SIZE), cache.size());\n+      assertThat(cache.size()).isEqualTo(min(i + 1, MAX_SIZE));\n     }\n \n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -98,13 +98,13 @@ public void testEviction_maxSize() {\n             .build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertTrue(cache.size() <= MAX_SIZE);\n+      assertThat(cache.size() <= MAX_SIZE).isTrue();\n     }\n \n-    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));\n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(CacheTesting.accessQueueSize(cache)).isEqualTo(MAX_SIZE);\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.processPendingNotifications(cache);\n-    assertEquals(MAX_SIZE, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -119,13 +119,13 @@ public void testEviction_maxWeight() {\n             .build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertTrue(cache.size() <= MAX_SIZE);\n+      assertThat(cache.size()).isAtMost(MAX_SIZE);\n     }\n \n-    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));\n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(CacheTesting.accessQueueSize(cache)).isEqualTo(MAX_SIZE);\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.processPendingNotifications(cache);\n-    assertEquals(MAX_SIZE, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -255,7 +255,7 @@ public void testEviction_overflow() {\n     cache.getUnchecked(objectWithHash(0));\n     cache.getUnchecked(objectWithHash(0));\n     CacheTesting.processPendingNotifications(cache);\n-    assertEquals(1, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(1);\n   }\n \n   public void testUpdateRecency_onGet() {"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/CacheExpirationTest.java",
      "status": "modified",
      "additions": 52,
      "deletions": 35,
      "changes": 87,
      "patch": "@@ -17,6 +17,7 @@\n import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.util.Arrays.asList;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static java.util.concurrent.TimeUnit.MINUTES;\n@@ -81,23 +82,29 @@ private void checkExpiration(\n       CountingRemovalListener<String, Integer> removalListener) {\n \n     for (int i = 0; i < 10; i++) {\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n     }\n \n     for (int i = 0; i < 10; i++) {\n       loader.reset();\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n-      assertFalse(\"Creator should not have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n+      assertWithMessage(\"Creator should not have been called @#%s\", i)\n+          .that(loader.wasCalled())\n+          .isFalse();\n     }\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n \n-    assertEquals(\"Map must be empty by now\", 0, cache.size());\n-    assertEquals(\"Eviction notifications must be received\", 10, removalListener.getCount());\n+    assertWithMessage(\"Map must be empty by now\").that(cache.size()).isEqualTo(0);\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(10);\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n     // ensure that no new notifications are sent\n-    assertEquals(\"Eviction notifications must be received\", 10, removalListener.getCount());\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(10);\n   }\n \n   public void testExpiringGet_expireAfterWrite() {\n@@ -133,13 +140,15 @@ private void runExpirationTest(\n       CountingRemovalListener<String, Integer> removalListener) {\n \n     for (int i = 0; i < 10; i++) {\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n     }\n \n     for (int i = 0; i < 10; i++) {\n       loader.reset();\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n-      assertFalse(\"Loader should NOT have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n+      assertWithMessage(\"Loader should NOT have been called @#%s\", i)\n+          .that(loader.wasCalled())\n+          .isFalse();\n     }\n \n     // wait for entries to expire, but don't call expireEntries\n@@ -149,31 +158,35 @@ private void runExpirationTest(\n     cache.getUnchecked(KEY_PREFIX + 11);\n \n     // collections views shouldn't expose expired entries\n-    assertEquals(1, Iterators.size(cache.asMap().entrySet().iterator()));\n-    assertEquals(1, Iterators.size(cache.asMap().keySet().iterator()));\n-    assertEquals(1, Iterators.size(cache.asMap().values().iterator()));\n+    assertThat(Iterators.size(cache.asMap().entrySet().iterator())).isEqualTo(1);\n+    assertThat(Iterators.size(cache.asMap().keySet().iterator())).isEqualTo(1);\n+    assertThat(Iterators.size(cache.asMap().values().iterator())).isEqualTo(1);\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n \n     for (int i = 0; i < 11; i++) {\n-      assertFalse(cache.asMap().containsKey(KEY_PREFIX + i));\n+      assertThat(cache.asMap().containsKey(KEY_PREFIX + i)).isFalse();\n     }\n-    assertEquals(11, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(11);\n \n     for (int i = 0; i < 10; i++) {\n-      assertFalse(cache.asMap().containsKey(KEY_PREFIX + i));\n+      assertThat(cache.asMap().containsKey(KEY_PREFIX + i)).isFalse();\n       loader.reset();\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n-      assertTrue(\"Creator should have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n+      assertWithMessage(\"Loader should have been called @#%s\", i).that(loader.wasCalled()).isTrue();\n     }\n \n     // expire new values we just created\n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n-    assertEquals(\"Eviction notifications must be received\", 21, removalListener.getCount());\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(21);\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n     // ensure that no new notifications are sent\n-    assertEquals(\"Eviction notifications must be received\", 21, removalListener.getCount());\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(21);\n   }\n \n   public void testRemovalListener_expireAfterWrite() {\n@@ -215,9 +228,9 @@ public AtomicInteger load(Integer key) {\n       ticker.advance(1, MILLISECONDS);\n     }\n \n-    assertEquals(evictionCount.get() + 1, applyCount.get());\n+    assertThat(applyCount.get()).isEqualTo(evictionCount.get() + 1);\n     int remaining = cache.getUnchecked(10).get();\n-    assertEquals(100, totalSum.get() + remaining);\n+    assertThat(totalSum.get() + remaining).isEqualTo(100);\n   }\n \n   public void testRemovalScheduler_expireAfterWrite() {\n@@ -435,46 +448,50 @@ private void runRemovalScheduler(\n       FakeTicker ticker,\n       String keyPrefix,\n       long ttl) {\n+    loader.setKeyPrefix(keyPrefix);\n \n     int shift1 = 10 + VALUE_PREFIX;\n     loader.setValuePrefix(shift1);\n     // fill with initial data\n     for (int i = 0; i < 10; i++) {\n-      assertEquals(Integer.valueOf(i + shift1), cache.getUnchecked(keyPrefix + i));\n+      assertThat(cache.getUnchecked(keyPrefix + i)).isEqualTo(i + shift1);\n     }\n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n \n     // wait, so that entries have just 10 ms to live\n     ticker.advance(ttl * 2 / 3, MILLISECONDS);\n \n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n \n     int shift2 = shift1 + 10;\n     loader.setValuePrefix(shift2);\n     // fill with new data - has to live for 20 ms more\n     for (int i = 0; i < 10; i++) {\n       cache.invalidate(keyPrefix + i);\n-      assertEquals(\n-          \"key: \" + keyPrefix + i, Integer.valueOf(i + shift2), cache.getUnchecked(keyPrefix + i));\n+      assertWithMessage(\"key: %s%s\", keyPrefix, i)\n+          .that(cache.getUnchecked(keyPrefix + i))\n+          .isEqualTo(i + shift2);\n     }\n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(10, removalListener.getCount()); // these are the invalidated ones\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(10); // these are the invalidated ones\n \n     // old timeouts must expire after this wait\n     ticker.advance(ttl * 2 / 3, MILLISECONDS);\n \n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(10, removalListener.getCount());\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(10);\n \n     // check that new values are still there - they still have 10 ms to live\n     for (int i = 0; i < 10; i++) {\n       loader.reset();\n-      assertEquals(Integer.valueOf(i + shift2), cache.getUnchecked(keyPrefix + i));\n-      assertFalse(\"Creator should NOT have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(keyPrefix + i)).isEqualTo(i + shift2);\n+      assertWithMessage(\"Creator should NOT have been called @#%s\", i)\n+          .that(loader.wasCalled())\n+          .isFalse();\n     }\n-    assertEquals(10, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(10);\n   }\n \n   private static void getAll(LoadingCache<Integer, Integer> cache, List<Integer> keys) {"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/CacheLoaderTest.java",
      "status": "modified",
      "additions": 13,
      "deletions": 12,
      "changes": 25,
      "patch": "@@ -16,6 +16,7 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.util.concurrent.Futures.immediateFuture;\n \n import com.google.common.collect.ImmutableList;\n@@ -77,17 +78,17 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {\n           }\n         };\n \n-    assertEquals(0, loadCount.get());\n-    assertEquals(0, reloadCount.get());\n-    assertEquals(0, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(0);\n+    assertThat(reloadCount.get()).isEqualTo(0);\n+    assertThat(loadAllCount.get()).isEqualTo(0);\n \n     Object unused1 = baseLoader.load(new Object());\n     @SuppressWarnings(\"unused\") // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n     Future<?> possiblyIgnoredError = baseLoader.reload(new Object(), new Object());\n     Map<Object, Object> unused2 = baseLoader.loadAll(ImmutableList.of(new Object()));\n-    assertEquals(1, loadCount.get());\n-    assertEquals(1, reloadCount.get());\n-    assertEquals(1, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(1);\n+    assertThat(reloadCount.get()).isEqualTo(1);\n+    assertThat(loadAllCount.get()).isEqualTo(1);\n \n     QueuingExecutor executor = new QueuingExecutor();\n     CacheLoader<Object, Object> asyncReloader = CacheLoader.asyncReloading(baseLoader, executor);\n@@ -96,13 +97,13 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {\n     @SuppressWarnings(\"unused\") // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n     Future<?> possiblyIgnoredError1 = asyncReloader.reload(new Object(), new Object());\n     Map<Object, Object> unused4 = asyncReloader.loadAll(ImmutableList.of(new Object()));\n-    assertEquals(2, loadCount.get());\n-    assertEquals(1, reloadCount.get());\n-    assertEquals(2, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(2);\n+    assertThat(reloadCount.get()).isEqualTo(1);\n+    assertThat(loadAllCount.get()).isEqualTo(2);\n \n     executor.runNext();\n-    assertEquals(2, loadCount.get());\n-    assertEquals(2, reloadCount.get());\n-    assertEquals(2, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(2);\n+    assertThat(reloadCount.get()).isEqualTo(2);\n+    assertThat(loadAllCount.get()).isEqualTo(2);\n   }\n }"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/CacheLoadingTest.java",
      "status": "modified",
      "additions": 651,
      "deletions": 661,
      "changes": 1312,
      "patch": "@@ -21,6 +21,7 @@\n import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static com.google.common.util.concurrent.Futures.immediateFailedFuture;\n import static com.google.common.util.concurrent.Futures.immediateFuture;\n import static java.util.Arrays.asList;\n@@ -33,7 +34,6 @@\n import com.google.common.cache.TestingCacheLoaders.IdentityLoader;\n import com.google.common.cache.TestingRemovalListeners.CountingRemovalListener;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Lists;\n import com.google.common.testing.FakeTicker;\n import com.google.common.testing.TestLogHandler;\n@@ -83,7 +83,7 @@ public void tearDown() throws Exception {\n \n   private Throwable popLoggedThrowable() {\n     List<LogRecord> logRecords = logHandler.getStoredLogRecords();\n-    assertEquals(1, logRecords.size());\n+    assertThat(logRecords).hasSize(1);\n     LogRecord logRecord = logRecords.get(0);\n     logHandler.clear();\n     return logRecord.getThrown();\n@@ -105,59 +105,59 @@ public void testLoad() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(identityLoader());\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Object key = new Object();\n-    assertSame(key, cache.get(key));\n+    assertThat(cache.get(key)).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     key = new Object();\n-    assertSame(key, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     key = new Object();\n     cache.refresh(key);\n     checkNothingLogged();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(key, cache.get(key));\n+    assertThat(cache.get(key)).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     Object value = new Object();\n     // callable is not called\n-    assertSame(key, cache.get(key, throwing(new Exception())));\n+    assertThat(cache.get(key, throwing(new Exception()))).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     key = new Object();\n-    assertSame(value, cache.get(key, Callables.returning(value)));\n+    assertThat(cache.get(key, Callables.returning(value))).isSameInstanceAs(value);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(4, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(4);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n   }\n \n   public void testReload() throws ExecutionException {\n@@ -179,32 +179,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkNothingLogged();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(two, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefresh() {\n@@ -232,41 +232,41 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testRefresh_getIfPresent() {\n@@ -294,41 +294,41 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getIfPresent(key));\n+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getIfPresent(key));\n+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getIfPresent(key));\n+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoad_default() throws ExecutionException {\n@@ -337,91 +337,91 @@ public void testBulkLoad_default() throws ExecutionException {\n             .recordStats()\n             .build(TestingCacheLoaders.<Integer>identityLoader());\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.<Integer>of()));\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(cache.getAll(ImmutableList.of())).isEmpty();\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));\n+    assertThat(cache.getAll(asList(1))).containsExactly(1, 1);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));\n+    assertThat(cache.getAll(asList(1, 2, 3, 4))).containsExactly(1, 1, 2, 2, 3, 3, 4, 4);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(4, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(4);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n-    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));\n+    assertThat(cache.getAll(asList(2, 3))).containsExactly(2, 2, 3, 3);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(4, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(4);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n \n     // duplicate keys are ignored, and don't impact stats\n-    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));\n+    assertThat(cache.getAll(asList(4, 5))).containsExactly(4, 4, 5, 5);\n     stats = cache.stats();\n-    assertEquals(5, stats.missCount());\n-    assertEquals(5, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(4, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(5);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(5);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(4);\n   }\n \n   public void testBulkLoad_loadAll() throws ExecutionException {\n     IdentityLoader<Integer> backingLoader = identityLoader();\n     CacheLoader<Integer, Integer> loader = bulkLoader(backingLoader);\n     LoadingCache<Integer, Integer> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.<Integer>of()));\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(cache.getAll(ImmutableList.<Integer>of())).containsExactly();\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));\n+    assertThat(cache.getAll(asList(1))).containsExactly(1, 1);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));\n+    assertThat(cache.getAll(asList(1, 2, 3, 4))).containsExactly(1, 1, 2, 2, 3, 3, 4, 4);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n-    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));\n+    assertThat(cache.getAll(asList(2, 3))).containsExactly(2, 2, 3, 3);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n \n     // duplicate keys are ignored, and don't impact stats\n-    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));\n+    assertThat(cache.getAll(asList(4, 5))).containsExactly(4, 4, 5, 5);\n     stats = cache.stats();\n-    assertEquals(5, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(4, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(5);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(4);\n   }\n \n   public void testBulkLoad_extra() throws ExecutionException {\n@@ -452,10 +452,10 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n     for (Entry<Object, Object> entry : result.entrySet()) {\n       Object key = entry.getKey();\n       Object value = entry.getValue();\n-      assertSame(value, result.get(key));\n-      assertNull(result.get(value));\n-      assertSame(value, cache.asMap().get(key));\n-      assertSame(key, cache.asMap().get(value));\n+      assertThat(result.get(key)).isSameInstanceAs(value);\n+      assertThat(result.get(value)).isNull();\n+      assertThat(cache.asMap().get(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().get(value)).isSameInstanceAs(key);\n     }\n   }\n \n@@ -482,19 +482,19 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n         };\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);\n     cache.asMap().put(extraKey, extraKey);\n-    assertSame(extraKey, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     Map<Object, Object> result = cache.getAll(asList(lookupKeys));\n     assertThat(result.keySet()).containsExactlyElementsIn(asList(lookupKeys));\n     for (Entry<Object, Object> entry : result.entrySet()) {\n       Object key = entry.getKey();\n       Object value = entry.getValue();\n-      assertSame(value, result.get(key));\n-      assertSame(value, cache.asMap().get(key));\n+      assertThat(result.get(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().get(key)).isSameInstanceAs(value);\n     }\n-    assertNull(result.get(extraKey));\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n+    assertThat(result.get(extraKey)).isNull();\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n   }\n \n   public void testBulkLoad_clobberNullValue() throws ExecutionException {\n@@ -521,16 +521,16 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n         };\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);\n     cache.asMap().put(extraKey, extraKey);\n-    assertSame(extraKey, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));\n \n     for (Object key : lookupKeys) {\n-      assertTrue(cache.asMap().containsKey(key));\n+      assertThat(cache.asMap().containsKey(key)).isTrue();\n     }\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n-    assertFalse(cache.asMap().containsKey(extraValue));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n+    assertThat(cache.asMap().containsKey(extraValue)).isFalse();\n   }\n \n   public void testBulkLoad_clobberNullKey() throws ExecutionException {\n@@ -557,16 +557,16 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n         };\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);\n     cache.asMap().put(extraKey, extraKey);\n-    assertSame(extraKey, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));\n \n     for (Object key : lookupKeys) {\n-      assertTrue(cache.asMap().containsKey(key));\n+      assertThat(cache.asMap().containsKey(key)).isTrue();\n     }\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n-    assertFalse(cache.asMap().containsValue(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n+    assertThat(cache.asMap().containsValue(extraKey)).isFalse();\n   }\n \n   public void testBulkLoad_partial() throws ExecutionException {\n@@ -591,54 +591,54 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n   }\n \n   public void testLoadNull() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(constantLoader(null));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.get(new Object()));\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(new Object()));\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedInvalidLoad();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(\n         InvalidCacheLoadException.class, () -> cache.get(new Object(), Callables.returning(null)));\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadNull() throws ExecutionException {\n@@ -659,32 +659,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedInvalidLoad();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadNullFuture() throws ExecutionException {\n@@ -705,32 +705,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedInvalidLoad();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshNull() {\n@@ -757,59 +757,59 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadNull() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(constantLoader(null)));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testBulkLoadNullMap() throws ExecutionException {\n@@ -830,52 +830,52 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {\n                 });\n \n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadError() throws ExecutionException {\n     Error e = new Error();\n     CacheLoader<Object, Object> loader = errorLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionError expected = assertThrows(ExecutionError.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionError.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Error callableError = new Error();\n     expected =\n@@ -892,18 +892,18 @@ public Object call() {\n                     }));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableError);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionError.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadError() throws ExecutionException {\n@@ -925,32 +925,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadFutureError() throws ExecutionException {\n@@ -972,32 +972,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshError() {\n@@ -1025,42 +1025,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadError() throws ExecutionException {\n@@ -1069,137 +1069,137 @@ public void testBulkLoadError() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionError expected =\n         assertThrows(ExecutionError.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadCheckedException() {\n     Exception e = new Exception();\n     CacheLoader<Object, Object> loader = exceptionLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception expected = assertThrows(ExecutionException.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception callableException = new Exception();\n     expected =\n         assertThrows(\n             ExecutionException.class, () -> cache.get(new Object(), throwing(callableException)));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadInterruptedException() {\n     Exception e = new InterruptedException();\n     CacheLoader<Object, Object> loader = exceptionLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     // Sanity check:\n-    assertFalse(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isFalse();\n \n     Exception expected = assertThrows(ExecutionException.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception callableException = new InterruptedException();\n     expected =\n         assertThrows(\n             ExecutionException.class, () -> cache.get(new Object(), throwing(callableException)));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadCheckedException() {\n@@ -1221,32 +1221,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) throws Excep\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadFutureCheckedException() {\n@@ -1268,32 +1268,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshCheckedException() {\n@@ -1321,42 +1321,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadCheckedException() {\n@@ -1365,19 +1365,19 @@ public void testBulkLoadCheckedException() {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionException expected =\n         assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testBulkLoadInterruptedException() {\n@@ -1386,57 +1386,57 @@ public void testBulkLoadInterruptedException() {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionException expected =\n         assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadUncheckedException() throws ExecutionException {\n     Exception e = new RuntimeException();\n     CacheLoader<Object, Object> loader = exceptionLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     UncheckedExecutionException expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception callableException = new RuntimeException();\n     expected =\n@@ -1445,19 +1445,19 @@ public void testLoadUncheckedException() throws ExecutionException {\n             () -> cache.get(new Object(), throwing(callableException)));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadUncheckedException() throws ExecutionException {\n@@ -1479,32 +1479,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) throws Excep\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadFutureUncheckedException() throws ExecutionException {\n@@ -1526,32 +1526,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshUncheckedException() {\n@@ -1579,42 +1579,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadUncheckedException() throws ExecutionException {\n@@ -1623,19 +1623,19 @@ public void testBulkLoadUncheckedException() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     UncheckedExecutionException expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadAfterFailure() throws ExecutionException {\n@@ -1660,15 +1660,15 @@ public String load(Integer key) throws Exception {\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(1));\n     assertThat(ue).hasCauseThat().isSameInstanceAs(e);\n \n-    assertEquals(\"1\", cache.getUnchecked(1));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(cache.getUnchecked(1)).isEqualTo(\"1\");\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n \n     count.set(0);\n     cache.refresh(2);\n     checkLoggedCause(e);\n \n-    assertEquals(\"2\", cache.getUnchecked(2));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(cache.getUnchecked(2)).isEqualTo(\"2\");\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n   }\n \n \n@@ -1693,7 +1693,7 @@ public void testReloadAfterValueReclamation() throws InterruptedException, Execu\n       Thread.sleep(i);\n       System.gc();\n     }\n-    assertEquals(expectedComputations, countingLoader.getCount());\n+    assertThat(countingLoader.getCount()).isEqualTo(expectedComputations);\n \n     for (int i = 0; i < iterations; i++) {\n       // The entry should get garbage collected and recomputed.\n@@ -1708,7 +1708,7 @@ public void testReloadAfterValueReclamation() throws InterruptedException, Execu\n       Thread.sleep(i);\n       System.gc();\n     }\n-    assertEquals(expectedComputations, countingLoader.getCount());\n+    assertThat(countingLoader.getCount()).isEqualTo(expectedComputations);\n   }\n \n   public void testReloadAfterSimulatedValueReclamation() throws ExecutionException {\n@@ -1717,20 +1717,20 @@ public void testReloadAfterSimulatedValueReclamation() throws ExecutionException\n         CacheBuilder.newBuilder().concurrencyLevel(1).weakValues().build(countingLoader);\n \n     Object key = new Object();\n-    assertNotNull(cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n \n     CacheTesting.simulateValueReclamation(cache, key);\n \n     // this blocks if computation can't deal with partially-collected values\n-    assertNotNull(cache.getUnchecked(key));\n-    assertEquals(1, cache.size());\n-    assertEquals(2, countingLoader.getCount());\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n+    assertThat(cache.size()).isEqualTo(1);\n+    assertThat(countingLoader.getCount()).isEqualTo(2);\n \n     CacheTesting.simulateValueReclamation(cache, key);\n     cache.refresh(key);\n     checkNothingLogged();\n-    assertEquals(1, cache.size());\n-    assertEquals(3, countingLoader.getCount());\n+    assertThat(cache.size()).isEqualTo(1);\n+    assertThat(countingLoader.getCount()).isEqualTo(3);\n   }\n \n   public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {\n@@ -1739,19 +1739,19 @@ public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {\n         CacheBuilder.newBuilder().concurrencyLevel(1).weakKeys().build(countingLoader);\n \n     Object key = new Object();\n-    assertNotNull(cache.getUnchecked(key));\n-    assertEquals(1, cache.size());\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n+    assertThat(cache.size()).isEqualTo(1);\n \n     CacheTesting.simulateKeyReclamation(cache, key);\n \n     // this blocks if computation can't deal with partially-collected values\n-    assertNotNull(cache.getUnchecked(key));\n-    assertEquals(2, countingLoader.getCount());\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n+    assertThat(countingLoader.getCount()).isEqualTo(2);\n \n     CacheTesting.simulateKeyReclamation(cache, key);\n     cache.refresh(key);\n     checkNothingLogged();\n-    assertEquals(3, countingLoader.getCount());\n+    assertThat(countingLoader.getCount()).isEqualTo(3);\n   }\n \n   /**\n@@ -1864,9 +1864,11 @@ public Object load(String key) throws InterruptedException {\n \n     List<Object> resultArray = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n-      assertSame(\"result(\" + i + \") didn't match expected\", result, resultArray.get(i));\n+      assertWithMessage(\"result(%s) didn't match expected\", i)\n+          .that(resultArray.get(i))\n+          .isSameInstanceAs(result);\n     }\n   }\n \n@@ -1896,18 +1898,14 @@ public String load(String key) throws InterruptedException {\n \n     List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n       assertThat(result.get(i)).isInstanceOf(InvalidCacheLoadException.class);\n     }\n \n     // subsequent calls should call the loader again, not get the old exception\n-    try {\n-      cache.getUnchecked(\"bar\");\n-      fail();\n-    } catch (InvalidCacheLoadException expected) {\n-    }\n-    assertEquals(2, callCount.get());\n+    assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(\"bar\"));\n+    assertThat(callCount.get()).isEqualTo(2);\n   }\n \n   /**\n@@ -1936,7 +1934,7 @@ public String load(String key) throws InterruptedException {\n \n     List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n       // doConcurrentGet alternates between calling getUnchecked and calling get, but an unchecked\n       // exception thrown by the loader is always wrapped as an UncheckedExecutionException.\n@@ -1945,12 +1943,8 @@ public String load(String key) throws InterruptedException {\n     }\n \n     // subsequent calls should call the loader again, not get the old exception\n-    try {\n-      cache.getUnchecked(\"bar\");\n-      fail();\n-    } catch (UncheckedExecutionException expected) {\n-    }\n-    assertEquals(2, callCount.get());\n+    assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(\"bar\"));\n+    assertThat(callCount.get()).isEqualTo(2);\n   }\n \n   /**\n@@ -1979,7 +1973,7 @@ public String load(String key) throws IOException, InterruptedException {\n \n     List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n       // doConcurrentGet alternates between calling getUnchecked and calling get. If we call get(),\n       // we should get an ExecutionException; if we call getUnchecked(), we should get an\n@@ -1995,12 +1989,8 @@ public String load(String key) throws IOException, InterruptedException {\n     }\n \n     // subsequent calls should call the loader again, not get the old exception\n-    try {\n-      cache.getUnchecked(\"bar\");\n-      fail();\n-    } catch (UncheckedExecutionException expected) {\n-    }\n-    assertEquals(2, callCount.get());\n+    assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(\"bar\"));\n+    assertThat(callCount.get()).isEqualTo(2);\n   }\n \n   /**\n@@ -2084,9 +2074,9 @@ public String load(String key) throws InterruptedException {\n     LoadingCache<String, String> cache = CacheBuilder.newBuilder().build(computeFunction);\n     ConcurrentMap<String, String> map = cache.asMap();\n     map.put(refreshKey, refreshKey);\n-    assertEquals(1, map.size());\n-    assertFalse(map.containsKey(getKey));\n-    assertSame(refreshKey, map.get(refreshKey));\n+    assertThat(map).hasSize(1);\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.get(refreshKey)).isSameInstanceAs(refreshKey);\n \n     new Thread() {\n       @Override\n@@ -2106,19 +2096,19 @@ public void run() {\n     getStartedSignal.await();\n \n     // computation is in progress; asMap shouldn't have changed\n-    assertEquals(1, map.size());\n-    assertFalse(map.containsKey(getKey));\n-    assertSame(refreshKey, map.get(refreshKey));\n+    assertThat(map).hasSize(1);\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.get(refreshKey)).isSameInstanceAs(refreshKey);\n \n     // let computation complete\n     letGetFinishSignal.countDown();\n     getFinishedSignal.await();\n     checkNothingLogged();\n \n     // asMap view should have been updated\n-    assertEquals(2, cache.size());\n-    assertEquals(getKey + suffix, map.get(getKey));\n-    assertEquals(refreshKey + suffix, map.get(refreshKey));\n+    assertThat(cache.size()).isEqualTo(2);\n+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);\n+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);\n   }\n \n   public void testInvalidateDuringLoading() throws InterruptedException, ExecutionException {\n@@ -2162,19 +2152,19 @@ public void run() {\n     computationStarted.await();\n     cache.invalidate(getKey);\n     cache.invalidate(refreshKey);\n-    assertFalse(map.containsKey(getKey));\n-    assertFalse(map.containsKey(refreshKey));\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.containsKey(refreshKey)).isFalse();\n \n     // let computation complete\n     letGetFinishSignal.countDown();\n     getFinishedSignal.await();\n     checkNothingLogged();\n \n     // results should be visible\n-    assertEquals(2, cache.size());\n-    assertEquals(getKey + suffix, map.get(getKey));\n-    assertEquals(refreshKey + suffix, map.get(refreshKey));\n-    assertEquals(2, cache.size());\n+    assertThat(cache.size()).isEqualTo(2);\n+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);\n+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);\n+    assertThat(cache.size()).isEqualTo(2);\n   }\n \n   public void testInvalidateAndReloadDuringLoading()\n@@ -2219,8 +2209,8 @@ public void run() {\n     computationStarted.await();\n     cache.invalidate(getKey);\n     cache.invalidate(refreshKey);\n-    assertFalse(map.containsKey(getKey));\n-    assertFalse(map.containsKey(refreshKey));\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.containsKey(refreshKey)).isFalse();\n \n     // start new computations\n     new Thread() {\n@@ -2244,9 +2234,9 @@ public void run() {\n     checkNothingLogged();\n \n     // results should be visible\n-    assertEquals(2, cache.size());\n-    assertEquals(getKey + suffix, map.get(getKey));\n-    assertEquals(refreshKey + suffix, map.get(refreshKey));\n+    assertThat(cache.size()).isEqualTo(2);\n+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);\n+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);\n   }\n \n   @SuppressWarnings(\"ThreadPriorityCheck\") // doing our best to test for races\n@@ -2331,11 +2321,11 @@ public void run() {\n     computeSignal.countDown();\n     doneSignal.await();\n \n-    assertTrue(callCount.get() == 1);\n-    assertEquals(\"barfoo\", result.get(0));\n-    assertEquals(\"barfoo\", result.get(1));\n-    assertEquals(\"barfoo\", result.get(2));\n-    assertEquals(\"barfoo\", cache.getUnchecked(key));\n+    assertThat(callCount.get()).isEqualTo(1);\n+    assertThat(result.get(0)).isEqualTo(\"barfoo\");\n+    assertThat(result.get(1)).isEqualTo(\"barfoo\");\n+    assertThat(result.get(2)).isEqualTo(\"barfoo\");\n+    assertThat(cache.getUnchecked(key)).isEqualTo(\"barfoo\");\n   }\n \n   // Test ignored because it is extremely flaky in CI builds\n@@ -2423,10 +2413,10 @@ public void run() {\n     computeSignal.countDown();\n     doneSignal.await();\n \n-    assertTrue(callCount.get() == 1);\n-    assertEquals(key, result.get(0));\n-    assertEquals(key, result.get(1));\n-    assertEquals(key + suffix, cache.getUnchecked(key));\n+    assertThat(callCount.get()).isEqualTo(1);\n+    assertThat(result.get(0)).isEqualTo(key);\n+    assertThat(result.get(1)).isEqualTo(key);\n+    assertThat(cache.getUnchecked(key)).isEqualTo(key + suffix);\n   }\n \n   static <T> Callable<T> throwing(Exception exception) {"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/CacheManualTest.java",
      "status": "modified",
      "additions": 86,
      "deletions": 84,
      "changes": 170,
      "patch": "@@ -14,6 +14,7 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.Arrays.asList;\n \n import com.google.common.collect.ImmutableList;\n@@ -30,126 +31,127 @@ public class CacheManualTest extends TestCase {\n   public void testGetIfPresent() {\n     Cache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Object one = new Object();\n     Object two = new Object();\n \n-    assertNull(cache.getIfPresent(one));\n+    assertThat(cache.getIfPresent(one)).isNull();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n-    assertNull(cache.asMap().get(one));\n-    assertFalse(cache.asMap().containsKey(one));\n-    assertFalse(cache.asMap().containsValue(two));\n-\n-    assertNull(cache.getIfPresent(two));\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n+    assertThat(cache.asMap().get(one)).isNull();\n+    assertThat(cache.asMap().containsKey(one)).isFalse();\n+    assertThat(cache.asMap().containsValue(two)).isFalse();\n+\n+    assertThat(cache.getIfPresent(two)).isNull();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n-    assertNull(cache.asMap().get(two));\n-    assertFalse(cache.asMap().containsKey(two));\n-    assertFalse(cache.asMap().containsValue(one));\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n+    assertThat(cache.asMap().get(two)).isNull();\n+    assertThat(cache.asMap().containsKey(two)).isFalse();\n+    assertThat(cache.asMap().containsValue(one)).isFalse();\n \n     cache.put(one, two);\n \n-    assertSame(two, cache.getIfPresent(one));\n+    assertThat(cache.getIfPresent(one)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n-    assertSame(two, cache.asMap().get(one));\n-    assertTrue(cache.asMap().containsKey(one));\n-    assertTrue(cache.asMap().containsValue(two));\n-\n-    assertNull(cache.getIfPresent(two));\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n+    assertThat(cache.asMap().get(one)).isSameInstanceAs(two);\n+    assertThat(cache.asMap().containsKey(one)).isTrue();\n+    assertThat(cache.asMap().containsValue(two)).isTrue();\n+\n+    assertThat(cache.getIfPresent(two)).isNull();\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n-    assertNull(cache.asMap().get(two));\n-    assertFalse(cache.asMap().containsKey(two));\n-    assertFalse(cache.asMap().containsValue(one));\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n+    assertThat(cache.asMap().get(two)).isNull();\n+    assertThat(cache.asMap().containsKey(two)).isFalse();\n+    assertThat(cache.asMap().containsValue(one)).isFalse();\n \n     cache.put(two, one);\n \n-    assertSame(two, cache.getIfPresent(one));\n+    assertThat(cache.getIfPresent(one)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n-    assertSame(two, cache.asMap().get(one));\n-    assertTrue(cache.asMap().containsKey(one));\n-    assertTrue(cache.asMap().containsValue(two));\n-\n-    assertSame(one, cache.getIfPresent(two));\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n+    assertThat(cache.asMap().get(one)).isSameInstanceAs(two);\n+    assertThat(cache.asMap().containsKey(one)).isTrue();\n+    assertThat(cache.asMap().containsValue(two)).isTrue();\n+\n+    assertThat(cache.getIfPresent(two)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n-    assertSame(one, cache.asMap().get(two));\n-    assertTrue(cache.asMap().containsKey(two));\n-    assertTrue(cache.asMap().containsValue(one));\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n+    assertThat(cache.asMap().get(two)).isSameInstanceAs(one);\n+    assertThat(cache.asMap().containsKey(two)).isTrue();\n+    assertThat(cache.asMap().containsValue(one)).isTrue();\n   }\n \n   public void testGetAllPresent() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().recordStats().build();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAllPresent(ImmutableList.<Integer>of()));\n+    assertThat(cache.getAllPresent(ImmutableList.<Integer>of())).isEmpty();\n     stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3))).isEqualTo(ImmutableMap.of());\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.put(2, 22);\n \n-    assertEquals(ImmutableMap.of(2, 22), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3))).containsExactly(2, 22);\n     stats = cache.stats();\n-    assertEquals(5, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(5);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     cache.put(3, 33);\n \n-    assertEquals(ImmutableMap.of(2, 22, 3, 33), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3))).containsExactly(2, 22, 3, 33);\n     stats = cache.stats();\n-    assertEquals(6, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(6);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n \n     cache.put(1, 11);\n \n-    assertEquals(ImmutableMap.of(1, 11, 2, 22, 3, 33), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3)))\n+        .isEqualTo(ImmutableMap.of(1, 11, 2, 22, 3, 33));\n     stats = cache.stats();\n-    assertEquals(6, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(6, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(6);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(6);\n   }\n }"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/CacheReferencesTest.java",
      "status": "modified",
      "additions": 22,
      "deletions": 23,
      "changes": 45,
      "patch": "@@ -66,24 +66,24 @@ public void testContainsKeyAndValue() {\n       // maintain strong refs so these won't be collected, regardless of cache's key/value strength\n       Key key = new Key(1);\n       String value = key.toString();\n-      assertSame(value, cache.getUnchecked(key));\n-      assertTrue(cache.asMap().containsKey(key));\n-      assertTrue(cache.asMap().containsValue(value));\n-      assertEquals(1, cache.size());\n+      assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().containsKey(key)).isTrue();\n+      assertThat(cache.asMap().containsValue(value)).isTrue();\n+      assertThat(cache.size()).isEqualTo(1);\n     }\n   }\n \n   public void testClear() {\n     for (LoadingCache<Key, String> cache : caches()) {\n       Key key = new Key(1);\n       String value = key.toString();\n-      assertSame(value, cache.getUnchecked(key));\n-      assertFalse(cache.asMap().isEmpty());\n+      assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().isEmpty()).isFalse();\n       cache.invalidateAll();\n-      assertEquals(0, cache.size());\n-      assertTrue(cache.asMap().isEmpty());\n-      assertFalse(cache.asMap().containsKey(key));\n-      assertFalse(cache.asMap().containsValue(value));\n+      assertThat(cache.size()).isEqualTo(0);\n+      assertThat(cache.asMap().isEmpty()).isTrue();\n+      assertThat(cache.asMap().containsKey(key)).isFalse();\n+      assertThat(cache.asMap().containsValue(value)).isFalse();\n     }\n   }\n \n@@ -93,13 +93,12 @@ public void testKeySetEntrySetValues() {\n       String value1 = key1.toString();\n       Key key2 = new Key(2);\n       String value2 = key2.toString();\n-      assertSame(value1, cache.getUnchecked(key1));\n-      assertSame(value2, cache.getUnchecked(key2));\n-      assertEquals(ImmutableSet.of(key1, key2), cache.asMap().keySet());\n+      assertThat(cache.getUnchecked(key1)).isSameInstanceAs(value1);\n+      assertThat(cache.getUnchecked(key2)).isSameInstanceAs(value2);\n+      assertThat(cache.asMap().keySet()).isEqualTo(ImmutableSet.of(key1, key2));\n       assertThat(cache.asMap().values()).containsExactly(value1, value2);\n-      assertEquals(\n-          ImmutableSet.of(immutableEntry(key1, value1), immutableEntry(key2, value2)),\n-          cache.asMap().entrySet());\n+      assertThat(cache.asMap().entrySet())\n+          .containsExactly(immutableEntry(key1, value1), immutableEntry(key2, value2));\n     }\n   }\n \n@@ -109,15 +108,15 @@ public void testInvalidate() {\n       String value1 = key1.toString();\n       Key key2 = new Key(2);\n       String value2 = key2.toString();\n-      assertSame(value1, cache.getUnchecked(key1));\n-      assertSame(value2, cache.getUnchecked(key2));\n+      assertThat(cache.getUnchecked(key1)).isSameInstanceAs(value1);\n+      assertThat(cache.getUnchecked(key2)).isSameInstanceAs(value2);\n       cache.invalidate(key1);\n-      assertFalse(cache.asMap().containsKey(key1));\n-      assertTrue(cache.asMap().containsKey(key2));\n-      assertEquals(1, cache.size());\n-      assertEquals(ImmutableSet.of(key2), cache.asMap().keySet());\n+      assertThat(cache.asMap().containsKey(key1)).isFalse();\n+      assertThat(cache.asMap().containsKey(key2)).isTrue();\n+      assertThat(cache.size()).isEqualTo(1);\n+      assertThat(cache.asMap().keySet()).isEqualTo(ImmutableSet.of(key2));\n       assertThat(cache.asMap().values()).contains(value2);\n-      assertEquals(ImmutableSet.of(immutableEntry(key2, value2)), cache.asMap().entrySet());\n+      assertThat(cache.asMap().entrySet()).containsExactly(immutableEntry(key2, value2));\n     }\n   }\n "
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/CacheRefreshTest.java",
      "status": "modified",
      "additions": 34,
      "deletions": 33,
      "changes": 67,
      "patch": "@@ -15,6 +15,7 @@\n package com.google.common.cache;\n \n import static com.google.common.cache.TestingCacheLoaders.incrementingLoader;\n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n \n import com.google.common.cache.TestingCacheLoaders.IncrementingLoader;\n@@ -42,61 +43,61 @@ public void testAutoRefresh() {\n     int expectedLoads = 0;\n     int expectedReloads = 0;\n     for (int i = 0; i < 3; i++) {\n-      assertEquals(Integer.valueOf(i), cache.getUnchecked(i));\n+      assertThat(cache.getUnchecked(i)).isEqualTo(i);\n       expectedLoads++;\n-      assertEquals(expectedLoads, loader.getLoadCount());\n-      assertEquals(expectedReloads, loader.getReloadCount());\n+      assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+      assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n       ticker.advance(1, MILLISECONDS);\n     }\n \n-    assertEquals(Integer.valueOf(0), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(0)).isEqualTo(0);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // refresh 0\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n     expectedReloads++;\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(1)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // write to 1 to delay its refresh\n     cache.asMap().put(1, -1);\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // refresh 2\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(3);\n     expectedReloads++;\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(3);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // refresh 0 and 1\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(0));\n+    assertThat(cache.getUnchecked(0)).isEqualTo(2);\n     expectedReloads++;\n-    assertEquals(Integer.valueOf(0), cache.getUnchecked(1));\n+    assertThat(cache.getUnchecked(1)).isEqualTo(0);\n     expectedReloads++;\n-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(2)).isEqualTo(3);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n   }\n }"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/CacheStatsTest.java",
      "status": "modified",
      "additions": 43,
      "deletions": 43,
      "changes": 86,
      "patch": "@@ -31,76 +31,76 @@ public class CacheStatsTest extends TestCase {\n \n   public void testEmpty() {\n     CacheStats stats = new CacheStats(0, 0, 0, 0, 0, 0);\n-    assertEquals(0, stats.requestCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n     assertThat(stats.hitRate()).isEqualTo(1.0);\n-    assertEquals(0, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n     assertThat(stats.missRate()).isEqualTo(0.0);\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n     assertThat(stats.loadExceptionRate()).isEqualTo(0.0);\n-    assertEquals(0, stats.loadCount());\n-    assertEquals(0, stats.totalLoadTime());\n+    assertThat(stats.loadCount()).isEqualTo(0);\n+    assertThat(stats.totalLoadTime()).isEqualTo(0);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n   }\n \n   public void testSingle() {\n     CacheStats stats = new CacheStats(11, 13, 17, 19, 23, 27);\n-    assertEquals(24, stats.requestCount());\n-    assertEquals(11, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(24);\n+    assertThat(stats.hitCount()).isEqualTo(11);\n     assertThat(stats.hitRate()).isEqualTo(11.0 / 24);\n-    assertEquals(13, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(13);\n     assertThat(stats.missRate()).isEqualTo(13.0 / 24);\n-    assertEquals(17, stats.loadSuccessCount());\n-    assertEquals(19, stats.loadExceptionCount());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(17);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(19);\n     assertThat(stats.loadExceptionRate()).isEqualTo(19.0 / 36);\n-    assertEquals(17 + 19, stats.loadCount());\n-    assertEquals(23, stats.totalLoadTime());\n+    assertThat(stats.loadCount()).isEqualTo(17 + 19);\n+    assertThat(stats.totalLoadTime()).isEqualTo(23);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(23.0 / (17 + 19));\n-    assertEquals(27, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(27);\n   }\n \n   public void testMinus() {\n     CacheStats one = new CacheStats(11, 13, 17, 19, 23, 27);\n     CacheStats two = new CacheStats(53, 47, 43, 41, 37, 31);\n \n     CacheStats diff = two.minus(one);\n-    assertEquals(76, diff.requestCount());\n-    assertEquals(42, diff.hitCount());\n+    assertThat(diff.requestCount()).isEqualTo(76);\n+    assertThat(diff.hitCount()).isEqualTo(42);\n     assertThat(diff.hitRate()).isEqualTo(42.0 / 76);\n-    assertEquals(34, diff.missCount());\n+    assertThat(diff.missCount()).isEqualTo(34);\n     assertThat(diff.missRate()).isEqualTo(34.0 / 76);\n-    assertEquals(26, diff.loadSuccessCount());\n-    assertEquals(22, diff.loadExceptionCount());\n+    assertThat(diff.loadSuccessCount()).isEqualTo(26);\n+    assertThat(diff.loadExceptionCount()).isEqualTo(22);\n     assertThat(diff.loadExceptionRate()).isEqualTo(22.0 / 48);\n-    assertEquals(26 + 22, diff.loadCount());\n-    assertEquals(14, diff.totalLoadTime());\n+    assertThat(diff.loadCount()).isEqualTo(26 + 22);\n+    assertThat(diff.totalLoadTime()).isEqualTo(14);\n     assertThat(diff.averageLoadPenalty()).isEqualTo(14.0 / (26 + 22));\n-    assertEquals(4, diff.evictionCount());\n+    assertThat(diff.evictionCount()).isEqualTo(4);\n \n-    assertEquals(new CacheStats(0, 0, 0, 0, 0, 0), one.minus(two));\n+    assertThat(one.minus(two)).isEqualTo(new CacheStats(0, 0, 0, 0, 0, 0));\n   }\n \n   public void testPlus() {\n     CacheStats one = new CacheStats(11, 13, 15, 13, 11, 9);\n     CacheStats two = new CacheStats(53, 47, 41, 39, 37, 35);\n \n     CacheStats sum = two.plus(one);\n-    assertEquals(124, sum.requestCount());\n-    assertEquals(64, sum.hitCount());\n+    assertThat(sum.requestCount()).isEqualTo(124);\n+    assertThat(sum.hitCount()).isEqualTo(64);\n     assertThat(sum.hitRate()).isEqualTo(64.0 / 124);\n-    assertEquals(60, sum.missCount());\n+    assertThat(sum.missCount()).isEqualTo(60);\n     assertThat(sum.missRate()).isEqualTo(60.0 / 124);\n-    assertEquals(56, sum.loadSuccessCount());\n-    assertEquals(52, sum.loadExceptionCount());\n+    assertThat(sum.loadSuccessCount()).isEqualTo(56);\n+    assertThat(sum.loadExceptionCount()).isEqualTo(52);\n     assertThat(sum.loadExceptionRate()).isEqualTo(52.0 / 108);\n-    assertEquals(56 + 52, sum.loadCount());\n-    assertEquals(48, sum.totalLoadTime());\n+    assertThat(sum.loadCount()).isEqualTo(56 + 52);\n+    assertThat(sum.totalLoadTime()).isEqualTo(48);\n     assertThat(sum.averageLoadPenalty()).isEqualTo(48.0 / (56 + 52));\n-    assertEquals(44, sum.evictionCount());\n+    assertThat(sum.evictionCount()).isEqualTo(44);\n \n-    assertEquals(sum, one.plus(two));\n+    assertThat(one.plus(two)).isEqualTo(sum);\n   }\n \n   public void testPlusLarge() {\n@@ -115,19 +115,19 @@ public void testPlusLarge() {\n     CacheStats smallCacheStats = new CacheStats(1, 1, 1, 1, 1, 1);\n \n     CacheStats sum = smallCacheStats.plus(maxCacheStats);\n-    assertEquals(Long.MAX_VALUE, sum.requestCount());\n-    assertEquals(Long.MAX_VALUE, sum.hitCount());\n+    assertThat(sum.requestCount()).isEqualTo(Long.MAX_VALUE);\n+    assertThat(sum.hitCount()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.hitRate()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.missCount());\n+    assertThat(sum.missCount()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.missRate()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.loadSuccessCount());\n-    assertEquals(Long.MAX_VALUE, sum.loadExceptionCount());\n+    assertThat(sum.loadSuccessCount()).isEqualTo(Long.MAX_VALUE);\n+    assertThat(sum.loadExceptionCount()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.loadExceptionRate()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.loadCount());\n-    assertEquals(Long.MAX_VALUE, sum.totalLoadTime());\n+    assertThat(sum.loadCount()).isEqualTo(Long.MAX_VALUE);\n+    assertThat(sum.totalLoadTime()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.averageLoadPenalty()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.evictionCount());\n+    assertThat(sum.evictionCount()).isEqualTo(Long.MAX_VALUE);\n \n-    assertEquals(sum, maxCacheStats.plus(smallCacheStats));\n+    assertThat(maxCacheStats.plus(smallCacheStats)).isEqualTo(sum);\n   }\n }"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/CacheTesting.java",
      "status": "modified",
      "additions": 56,
      "deletions": 57,
      "changes": 113,
      "patch": "@@ -16,15 +16,9 @@\n \n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.lang.Math.max;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n-import static junit.framework.Assert.assertEquals;\n-import static junit.framework.Assert.assertFalse;\n-import static junit.framework.Assert.assertNotNull;\n-import static junit.framework.Assert.assertNotSame;\n-import static junit.framework.Assert.assertNull;\n-import static junit.framework.Assert.assertSame;\n-import static junit.framework.Assert.assertTrue;\n \n import com.google.common.base.Preconditions;\n import com.google.common.cache.LocalCache.LocalLoadingCache;\n@@ -194,16 +188,16 @@ static void checkValidState(Cache<?, ?> cache) {\n   static void checkValidState(LocalCache<?, ?> cchm) {\n     for (Segment<?, ?> segment : cchm.segments) {\n       segment.cleanUp();\n-      assertFalse(segment.isLocked());\n+      assertThat(segment.isLocked()).isFalse();\n       Map<?, ?> table = segmentTable(segment);\n       // cleanup and then check count after we have a strong reference to all entries\n       segment.cleanUp();\n       // under high memory pressure keys/values may be nulled out but not yet enqueued\n       assertThat(table.size()).isAtMost(segment.count);\n       for (Entry<?, ?> entry : table.entrySet()) {\n-        assertNotNull(entry.getKey());\n-        assertNotNull(entry.getValue());\n-        assertSame(entry.getValue(), cchm.get(entry.getKey()));\n+        assertThat(entry.getKey()).isNotNull();\n+        assertThat(entry.getValue()).isNotNull();\n+        assertThat(cchm.get(entry.getKey())).isSameInstanceAs(entry.getValue());\n       }\n     }\n     checkEviction(cchm);\n@@ -228,46 +222,47 @@ static void checkExpiration(LocalCache<?, ?> cchm) {\n \n         ReferenceEntry<?, ?> prev = null;\n         for (ReferenceEntry<?, ?> current : segment.writeQueue) {\n-          assertTrue(entries.add(current));\n+          assertThat(entries.add(current)).isTrue();\n           if (prev != null) {\n-            assertSame(prev, current.getPreviousInWriteQueue());\n-            assertSame(prev.getNextInWriteQueue(), current);\n+            assertThat(current.getPreviousInWriteQueue()).isSameInstanceAs(prev);\n+            assertThat(current).isSameInstanceAs(prev.getNextInWriteQueue());\n             assertThat(prev.getWriteTime()).isAtMost(current.getWriteTime());\n           }\n           Object key = current.getKey();\n           if (key != null) {\n-            assertSame(current, segment.getEntry(key, current.getHash()));\n+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);\n           }\n           prev = current;\n         }\n-        assertEquals(segment.count, entries.size());\n+        assertThat(entries).hasSize(segment.count);\n       } else {\n-        assertTrue(segment.writeQueue.isEmpty());\n+        assertThat(segment.writeQueue.isEmpty()).isTrue();\n       }\n \n       if (cchm.usesAccessQueue()) {\n         Set<ReferenceEntry<?, ?>> entries = Sets.newIdentityHashSet();\n \n         ReferenceEntry<?, ?> prev = null;\n         for (ReferenceEntry<?, ?> current : segment.accessQueue) {\n-          assertTrue(entries.add(current));\n+          assertThat(entries.add(current)).isTrue();\n           if (prev != null) {\n-            assertSame(prev, current.getPreviousInAccessQueue());\n-            assertSame(prev.getNextInAccessQueue(), current);\n+            assertThat(current.getPreviousInAccessQueue()).isSameInstanceAs(prev);\n+            assertThat(current).isSameInstanceAs(prev.getNextInAccessQueue());\n             // read accesses may be slightly misordered\n-            assertTrue(\n-                prev.getAccessTime() <= current.getAccessTime()\n-                    || prev.getAccessTime() - current.getAccessTime() < 1000);\n+            assertThat(\n+                    prev.getAccessTime() <= current.getAccessTime()\n+                        || prev.getAccessTime() - current.getAccessTime() < 1000)\n+                .isTrue();\n           }\n           Object key = current.getKey();\n           if (key != null) {\n-            assertSame(current, segment.getEntry(key, current.getHash()));\n+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);\n           }\n           prev = current;\n         }\n-        assertEquals(segment.count, entries.size());\n+        assertThat(entries).hasSize(segment.count);\n       } else {\n-        assertTrue(segment.accessQueue.isEmpty());\n+        assertThat(segment.accessQueue).isEmpty();\n       }\n     }\n   }\n@@ -287,25 +282,25 @@ static void checkEviction(LocalCache<?, ?> map) {\n     if (map.evictsBySize()) {\n       for (Segment<?, ?> segment : map.segments) {\n         drainRecencyQueue(segment);\n-        assertEquals(0, segment.recencyQueue.size());\n-        assertEquals(0, segment.readCount.get());\n+        assertThat(segment.recencyQueue).isEmpty();\n+        assertThat(segment.readCount.get()).isEqualTo(0);\n \n         ReferenceEntry<?, ?> prev = null;\n         for (ReferenceEntry<?, ?> current : segment.accessQueue) {\n           if (prev != null) {\n-            assertSame(prev, current.getPreviousInAccessQueue());\n-            assertSame(prev.getNextInAccessQueue(), current);\n+            assertThat(current.getPreviousInAccessQueue()).isSameInstanceAs(prev);\n+            assertThat(current).isSameInstanceAs(prev.getNextInAccessQueue());\n           }\n           Object key = current.getKey();\n           if (key != null) {\n-            assertSame(current, segment.getEntry(key, current.getHash()));\n+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);\n           }\n           prev = current;\n         }\n       }\n     } else {\n       for (Segment<?, ?> segment : map.segments) {\n-        assertEquals(0, segment.recencyQueue.size());\n+        assertThat(segment.recencyQueue).isEmpty();\n       }\n     }\n   }\n@@ -323,7 +318,7 @@ static <K, V> Map<K, V> segmentTable(Segment<K, V> segment) {\n         K key = entry.getKey();\n         V value = entry.getValueReference().get();\n         if (key != null && value != null) {\n-          assertNull(map.put(key, value));\n+          assertThat(map.put(key, value)).isNull();\n         }\n       }\n     }\n@@ -390,17 +385,17 @@ static void checkRecency(\n       LocalCache<Integer, Integer> cchm = toLocalCache(cache);\n       Segment<?, ?> segment = cchm.segments[0];\n       drainRecencyQueue(segment);\n-      assertEquals(maxSize, accessQueueSize(cache));\n-      assertEquals(maxSize, cache.size());\n+      assertThat(accessQueueSize(cache)).isEqualTo(maxSize);\n+      assertThat(cache.size()).isEqualTo(maxSize);\n \n       ReferenceEntry<?, ?> originalHead = segment.accessQueue.peek();\n       @SuppressWarnings(\"unchecked\")\n       ReferenceEntry<Integer, Integer> entry = (ReferenceEntry<Integer, Integer>) originalHead;\n       operation.accept(entry);\n       drainRecencyQueue(segment);\n \n-      assertNotSame(originalHead, segment.accessQueue.peek());\n-      assertEquals(cache.size(), accessQueueSize(cache));\n+      assertThat(segment.accessQueue.peek()).isNotSameInstanceAs(originalHead);\n+      assertThat(accessQueueSize(cache)).isEqualTo(cache.size());\n     }\n   }\n \n@@ -428,9 +423,13 @@ static void expireEntries(LocalCache<?, ?> cchm, long expiringTime, FakeTicker t\n     long now = ticker.read();\n     for (Segment<?, ?> segment : cchm.segments) {\n       expireEntries(segment, now);\n-      assertEquals(\"Expiration queue must be empty by now\", 0, writeQueueSize(segment));\n-      assertEquals(\"Expiration queue must be empty by now\", 0, accessQueueSize(segment));\n-      assertEquals(\"Segments must be empty by now\", 0, segmentSize(segment));\n+      assertWithMessage(\"Expiration queue must be empty by now\")\n+          .that(writeQueueSize(segment))\n+          .isEqualTo(0);\n+      assertWithMessage(\"Expiration queue must be empty by now\")\n+          .that(accessQueueSize(segment))\n+          .isEqualTo(0);\n+      assertWithMessage(\"Segments must be empty by now\").that(segmentSize(segment)).isEqualTo(0);\n     }\n     cchm.processPendingNotifications();\n   }\n@@ -446,41 +445,41 @@ static void expireEntries(Segment<?, ?> segment, long now) {\n   }\n \n   static void checkEmpty(Cache<?, ?> cache) {\n-    assertEquals(0, cache.size());\n-    assertFalse(cache.asMap().containsKey(null));\n-    assertFalse(cache.asMap().containsKey(6));\n-    assertFalse(cache.asMap().containsValue(null));\n-    assertFalse(cache.asMap().containsValue(6));\n+    assertThat(cache.size()).isEqualTo(0);\n+    assertThat(cache.asMap().containsKey(null)).isFalse();\n+    assertThat(cache.asMap().containsKey(6)).isFalse();\n+    assertThat(cache.asMap().containsValue(null)).isFalse();\n+    assertThat(cache.asMap().containsValue(6)).isFalse();\n     checkEmpty(cache.asMap());\n   }\n \n   static void checkEmpty(ConcurrentMap<?, ?> map) {\n     checkEmpty(map.keySet());\n     checkEmpty(map.values());\n     checkEmpty(map.entrySet());\n-    assertEquals(ImmutableMap.of(), map);\n-    assertEquals(ImmutableMap.of().hashCode(), map.hashCode());\n-    assertEquals(ImmutableMap.of().toString(), map.toString());\n+    assertThat(map).isEqualTo(ImmutableMap.of());\n+    assertThat(map.hashCode()).isEqualTo(ImmutableMap.of().hashCode());\n+    assertThat(map.toString()).isEqualTo(ImmutableMap.of().toString());\n \n     if (map instanceof LocalCache) {\n       LocalCache<?, ?> cchm = (LocalCache<?, ?>) map;\n \n       checkValidState(cchm);\n-      assertTrue(cchm.isEmpty());\n-      assertEquals(0, cchm.size());\n+      assertThat(cchm.isEmpty()).isTrue();\n+      assertThat(cchm).isEmpty();\n       for (LocalCache.Segment<?, ?> segment : cchm.segments) {\n-        assertEquals(0, segment.count);\n-        assertEquals(0, segmentSize(segment));\n-        assertTrue(segment.writeQueue.isEmpty());\n-        assertTrue(segment.accessQueue.isEmpty());\n+        assertThat(segment.count).isEqualTo(0);\n+        assertThat(segmentSize(segment)).isEqualTo(0);\n+        assertThat(segment.writeQueue.isEmpty()).isTrue();\n+        assertThat(segment.accessQueue.isEmpty()).isTrue();\n       }\n     }\n   }\n \n   static void checkEmpty(Collection<?> collection) {\n-    assertTrue(collection.isEmpty());\n-    assertEquals(0, collection.size());\n-    assertFalse(collection.iterator().hasNext());\n+    assertThat(collection.isEmpty()).isTrue();\n+    assertThat(collection).isEmpty();\n+    assertThat(collection.iterator().hasNext()).isFalse();\n     assertThat(collection.toArray()).isEmpty();\n     assertThat(collection.toArray(new Object[0])).isEmpty();\n     if (collection instanceof Set) {"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/EmptyCachesTest.java",
      "status": "modified",
      "additions": 32,
      "deletions": 31,
      "changes": 63,
      "patch": "@@ -16,6 +16,7 @@\n \n import static com.google.common.cache.CacheTesting.checkEmpty;\n import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.Arrays.asList;\n import static java.util.concurrent.TimeUnit.DAYS;\n import static java.util.concurrent.TimeUnit.SECONDS;\n@@ -75,7 +76,7 @@ public void testInvalidateAll_empty() {\n \n   public void testEquals_null() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n-      assertFalse(cache.equals(null));\n+      assertThat(cache.equals(null)).isFalse();\n     }\n   }\n \n@@ -138,11 +139,11 @@ public void testKeySet_clear() {\n   public void testKeySet_empty_remove() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       Set<Object> keys = cache.asMap().keySet();\n-      assertFalse(keys.remove(null));\n-      assertFalse(keys.remove(6));\n-      assertFalse(keys.remove(-6));\n-      assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(keys.remove(null)).isFalse();\n+      assertThat(keys.remove(6)).isFalse();\n+      assertThat(keys.remove(-6)).isFalse();\n+      assertThat(keys.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(keys.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(keys);\n       checkEmpty(cache);\n     }\n@@ -158,11 +159,11 @@ public void testKeySet_remove() {\n       // values of these removes, but the cache should be empty after the removes, regardless.\n       keys.remove(1);\n       keys.remove(2);\n-      assertFalse(keys.remove(null));\n-      assertFalse(keys.remove(6));\n-      assertFalse(keys.remove(-6));\n-      assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(keys.remove(null)).isFalse();\n+      assertThat(keys.remove(6)).isFalse();\n+      assertThat(keys.remove(-6)).isFalse();\n+      assertThat(keys.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(keys.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(keys);\n       checkEmpty(cache);\n     }\n@@ -202,11 +203,11 @@ public void testValues_clear() {\n   public void testValues_empty_remove() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       Collection<Object> values = cache.asMap().values();\n-      assertFalse(values.remove(null));\n-      assertFalse(values.remove(6));\n-      assertFalse(values.remove(-6));\n-      assertFalse(values.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(values.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(values.remove(null)).isFalse();\n+      assertThat(values.remove(6)).isFalse();\n+      assertThat(values.remove(-6)).isFalse();\n+      assertThat(values.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(values.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(values);\n       checkEmpty(cache);\n     }\n@@ -222,11 +223,11 @@ public void testValues_remove() {\n       // values of these removes, but the cache should be empty after the removes, regardless.\n       values.remove(1);\n       values.remove(2);\n-      assertFalse(values.remove(null));\n-      assertFalse(values.remove(6));\n-      assertFalse(values.remove(-6));\n-      assertFalse(values.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(values.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(values.remove(null)).isFalse();\n+      assertThat(values.remove(6)).isFalse();\n+      assertThat(values.remove(-6)).isFalse();\n+      assertThat(values.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(values.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(values);\n       checkEmpty(cache);\n     }\n@@ -269,11 +270,11 @@ public void testEntrySet_clear() {\n   public void testEntrySet_empty_remove() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       Set<Entry<Object, Object>> entrySet = cache.asMap().entrySet();\n-      assertFalse(entrySet.remove(null));\n-      assertFalse(entrySet.remove(entryOf(6, 6)));\n-      assertFalse(entrySet.remove(entryOf(-6, -6)));\n-      assertFalse(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15))));\n-      assertFalse(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15))));\n+      assertThat(entrySet.remove(null)).isFalse();\n+      assertThat(entrySet.remove(entryOf(6, 6))).isFalse();\n+      assertThat(entrySet.remove(entryOf(-6, -6))).isFalse();\n+      assertThat(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15)))).isFalse();\n+      assertThat(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15)))).isFalse();\n       checkEmpty(entrySet);\n       checkEmpty(cache);\n     }\n@@ -289,11 +290,11 @@ public void testEntrySet_remove() {\n       // values of these removes, but the cache should be empty after the removes, regardless.\n       entrySet.remove(entryOf(1, 1));\n       entrySet.remove(entryOf(2, 2));\n-      assertFalse(entrySet.remove(null));\n-      assertFalse(entrySet.remove(entryOf(1, 1)));\n-      assertFalse(entrySet.remove(entryOf(6, 6)));\n-      assertFalse(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15))));\n-      assertFalse(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15))));\n+      assertThat(entrySet.remove(null)).isFalse();\n+      assertThat(entrySet.remove(entryOf(1, 1))).isFalse();\n+      assertThat(entrySet.remove(entryOf(6, 6))).isFalse();\n+      assertThat(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15)))).isFalse();\n+      assertThat(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15)))).isFalse();\n       checkEmpty(entrySet);\n       checkEmpty(cache);\n     }"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/ForwardingCacheTest.java",
      "status": "modified",
      "additions": 10,
      "deletions": 9,
      "changes": 19,
      "patch": "@@ -16,12 +16,14 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.errorprone.annotations.Keep;\n import java.util.concurrent.ExecutionException;\n import junit.framework.TestCase;\n import org.jspecify.annotations.NullUnmarked;\n@@ -56,15 +58,13 @@ protected Cache<String, Boolean> delegate() {\n   }\n \n   public void testGetIfPresent() throws ExecutionException {\n-    when(mock.getIfPresent(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.getIfPresent(\"key\"));\n+    when(mock.getIfPresent(\"key\")).thenReturn(true);\n+    assertThat(forward.getIfPresent(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testGetAllPresent() throws ExecutionException {\n-    when(mock.getAllPresent(ImmutableList.of(\"key\")))\n-        .thenReturn(ImmutableMap.of(\"key\", Boolean.TRUE));\n-    assertEquals(\n-        ImmutableMap.of(\"key\", Boolean.TRUE), forward.getAllPresent(ImmutableList.of(\"key\")));\n+    when(mock.getAllPresent(ImmutableList.of(\"key\"))).thenReturn(ImmutableMap.of(\"key\", true));\n+    assertThat(forward.getAllPresent(ImmutableList.of(\"key\"))).containsExactly(\"key\", true);\n   }\n \n   public void testInvalidate() {\n@@ -84,17 +84,17 @@ public void testInvalidateAll() {\n \n   public void testSize() {\n     when(mock.size()).thenReturn(0L);\n-    assertEquals(0, forward.size());\n+    assertThat(forward.size()).isEqualTo(0);\n   }\n \n   public void testStats() {\n     when(mock.stats()).thenReturn(null);\n-    assertNull(forward.stats());\n+    assertThat(forward.stats()).isNull();\n   }\n \n   public void testAsMap() {\n     when(mock.asMap()).thenReturn(null);\n-    assertNull(forward.asMap());\n+    assertThat(forward.asMap()).isNull();\n   }\n \n   public void testCleanUp() {\n@@ -103,6 +103,7 @@ public void testCleanUp() {\n   }\n \n   /** Make sure that all methods are forwarded. */\n+  @Keep\n   private static class OnlyGet<K, V> extends ForwardingCache<K, V> {\n     @Override\n     protected Cache<K, V> delegate() {"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java",
      "status": "modified",
      "additions": 13,
      "deletions": 10,
      "changes": 23,
      "patch": "@@ -16,12 +16,14 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.errorprone.annotations.Keep;\n import java.util.concurrent.ExecutionException;\n import junit.framework.TestCase;\n import org.jspecify.annotations.NullUnmarked;\n@@ -56,23 +58,23 @@ protected LoadingCache<String, Boolean> delegate() {\n   }\n \n   public void testGet() throws ExecutionException {\n-    when(mock.get(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.get(\"key\"));\n+    when(mock.get(\"key\")).thenReturn(true);\n+    assertThat(forward.get(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testGetUnchecked() {\n-    when(mock.getUnchecked(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.getUnchecked(\"key\"));\n+    when(mock.getUnchecked(\"key\")).thenReturn(true);\n+    assertThat(forward.getUnchecked(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testGetAll() throws ExecutionException {\n-    when(mock.getAll(ImmutableList.of(\"key\"))).thenReturn(ImmutableMap.of(\"key\", Boolean.TRUE));\n-    assertEquals(ImmutableMap.of(\"key\", Boolean.TRUE), forward.getAll(ImmutableList.of(\"key\")));\n+    when(mock.getAll(ImmutableList.of(\"key\"))).thenReturn(ImmutableMap.of(\"key\", true));\n+    assertThat(forward.getAll(ImmutableList.of(\"key\"))).containsExactly(\"key\", true);\n   }\n \n   public void testApply() {\n-    when(mock.apply(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.apply(\"key\"));\n+    when(mock.apply(\"key\")).thenReturn(true);\n+    assertThat(forward.apply(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testInvalidate() {\n@@ -97,12 +99,12 @@ public void testSize() {\n \n   public void testStats() {\n     when(mock.stats()).thenReturn(null);\n-    assertNull(forward.stats());\n+    assertThat(forward.stats()).isNull();\n   }\n \n   public void testAsMap() {\n     when(mock.asMap()).thenReturn(null);\n-    assertNull(forward.asMap());\n+    assertThat(forward.asMap()).isNull();\n   }\n \n   public void testCleanUp() {\n@@ -111,6 +113,7 @@ public void testCleanUp() {\n   }\n \n   /** Make sure that all methods are forwarded. */\n+  @Keep\n   private static class OnlyGet<K, V> extends ForwardingLoadingCache<K, V> {\n     @Override\n     protected LoadingCache<K, V> delegate() {"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/LocalCacheMapComputeTest.java",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "patch": "@@ -61,7 +61,7 @@ public void testComputeIfAbsent() {\n         n -> {\n           cache.asMap().computeIfAbsent(key, k -> \"value\" + n);\n         });\n-    assertEquals(1, cache.size());\n+    assertThat(cache.size()).isEqualTo(1);\n   }\n \n   public void testComputeIfAbsentEviction() {\n@@ -96,7 +96,7 @@ public void testComputeIfPresent() {\n         n -> {\n           cache.asMap().computeIfPresent(key, (k, v) -> v + delimiter + n);\n         });\n-    assertEquals(1, cache.size());\n+    assertThat(cache.size()).isEqualTo(1);\n     assertThat(cache.getIfPresent(key).split(delimiter)).hasLength(count + 1);\n   }\n \n@@ -161,7 +161,7 @@ public void testCompute() {\n         n -> {\n           cache.asMap().compute(key, (k, v) -> null);\n         });\n-    assertEquals(0, cache.size());\n+    assertThat(cache.size()).isEqualTo(0);\n   }\n \n   public void testComputeWithLoad() {"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/LocalCacheTest.java",
      "status": "modified",
      "additions": 521,
      "deletions": 502,
      "changes": 1023,
      "patch": "@@ -27,6 +27,7 @@\n import static com.google.common.cache.TestingWeighers.constantWeigher;\n import static com.google.common.collect.Maps.immutableEntry;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n import static java.lang.Math.max;\n import static java.lang.Thread.State.WAITING;\n@@ -247,18 +248,18 @@ public void tearDown() throws Exception {\n \n   private Throwable popLoggedThrowable() {\n     List<LogRecord> logRecords = logHandler.getStoredLogRecords();\n-    assertEquals(1, logRecords.size());\n+    assertThat(logRecords).hasSize(1);\n     LogRecord logRecord = logRecords.get(0);\n     logHandler.clear();\n     return logRecord.getThrown();\n   }\n \n   private void checkNothingLogged() {\n-    assertTrue(logHandler.getStoredLogRecords().isEmpty());\n+    assertThat(logHandler.getStoredLogRecords().isEmpty()).isTrue();\n   }\n \n   private void checkLogged(Throwable t) {\n-    assertSame(t, popLoggedThrowable());\n+    assertThat(popLoggedThrowable()).isSameInstanceAs(t);\n   }\n \n   /*\n@@ -288,33 +289,33 @@ private static CacheBuilder<Object, Object> createCacheBuilder() {\n   public void testDefaults() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n \n-    assertSame(Strength.STRONG, map.keyStrength);\n-    assertSame(Strength.STRONG, map.valueStrength);\n-    assertSame(map.keyStrength.defaultEquivalence(), map.keyEquivalence);\n-    assertSame(map.valueStrength.defaultEquivalence(), map.valueEquivalence);\n+    assertThat(map.keyStrength).isEqualTo(Strength.STRONG);\n+    assertThat(map.valueStrength).isEqualTo(Strength.STRONG);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(map.keyStrength.defaultEquivalence());\n+    assertThat(map.valueEquivalence).isSameInstanceAs(map.valueStrength.defaultEquivalence());\n \n-    assertEquals(0, map.expireAfterAccessNanos);\n-    assertEquals(0, map.expireAfterWriteNanos);\n-    assertEquals(0, map.refreshNanos);\n-    assertEquals(CacheBuilder.UNSET_INT, map.maxWeight);\n+    assertThat(map.expireAfterAccessNanos).isEqualTo(0);\n+    assertThat(map.expireAfterWriteNanos).isEqualTo(0);\n+    assertThat(map.refreshNanos).isEqualTo(0);\n+    assertThat(map.maxWeight).isEqualTo(CacheBuilder.UNSET_INT);\n \n-    assertSame(EntryFactory.STRONG, map.entryFactory);\n-    assertSame(CacheBuilder.NullListener.INSTANCE, map.removalListener);\n-    assertSame(DISCARDING_QUEUE, map.removalNotificationQueue);\n-    assertSame(NULL_TICKER, map.ticker);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);\n+    assertThat(map.removalListener).isSameInstanceAs(CacheBuilder.NullListener.INSTANCE);\n+    assertThat(map.removalNotificationQueue).isSameInstanceAs(DISCARDING_QUEUE);\n+    assertThat(map.ticker).isSameInstanceAs(NULL_TICKER);\n \n-    assertEquals(4, map.concurrencyLevel);\n+    assertThat(map.concurrencyLevel).isEqualTo(4);\n \n     // concurrency level\n     assertThat(map.segments).hasLength(4);\n     // initial capacity / concurrency level\n-    assertEquals(16 / map.segments.length, map.segments[0].table.length());\n+    assertThat(map.segments[0].table.length()).isEqualTo(16 / map.segments.length);\n \n-    assertFalse(map.evictsBySize());\n-    assertFalse(map.expires());\n-    assertFalse(map.expiresAfterWrite());\n-    assertFalse(map.expiresAfterAccess());\n-    assertFalse(map.refreshes());\n+    assertThat(map.evictsBySize()).isFalse();\n+    assertThat(map.expires()).isFalse();\n+    assertThat(map.expiresAfterWrite()).isFalse();\n+    assertThat(map.expiresAfterAccess()).isFalse();\n+    assertThat(map.refreshes()).isFalse();\n   }\n \n   public void testSetKeyEquivalence() {\n@@ -333,8 +334,8 @@ protected int doHash(Object t) {\n \n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().keyEquivalence(testEquivalence));\n-    assertSame(testEquivalence, map.keyEquivalence);\n-    assertSame(map.valueStrength.defaultEquivalence(), map.valueEquivalence);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(testEquivalence);\n+    assertThat(map.valueEquivalence).isSameInstanceAs(map.valueStrength.defaultEquivalence());\n   }\n \n   public void testSetValueEquivalence() {\n@@ -353,8 +354,8 @@ protected int doHash(Object t) {\n \n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().valueEquivalence(testEquivalence));\n-    assertSame(testEquivalence, map.valueEquivalence);\n-    assertSame(map.keyStrength.defaultEquivalence(), map.keyEquivalence);\n+    assertThat(map.valueEquivalence).isSameInstanceAs(testEquivalence);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(map.keyStrength.defaultEquivalence());\n   }\n \n   public void testSetConcurrencyLevel() {\n@@ -418,7 +419,7 @@ private static void checkInitialCapacity(\n                 .concurrencyLevel(concurrencyLevel)\n                 .initialCapacity(initialCapacity));\n     for (int i = 0; i < map.segments.length; i++) {\n-      assertEquals(segmentSize, map.segments[i].table.length());\n+      assertThat(map.segments[i].table.length()).isEqualTo(segmentSize);\n     }\n   }\n \n@@ -455,13 +456,15 @@ private static void checkMaximumSize(int concurrencyLevel, int initialCapacity,\n                 .initialCapacity(initialCapacity)\n                 .maximumSize(maxSize));\n     long totalCapacity = 0;\n-    assertTrue(\n-        \"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n-        map.segments.length <= max(1, maxSize / 10));\n+    assertWithMessage(\"segments=%s, maxSize=%s\", map.segments.length, maxSize)\n+        .that((long) map.segments.length)\n+        .isAtMost(max(1, maxSize / 10));\n     for (int i = 0; i < map.segments.length; i++) {\n       totalCapacity += map.segments[i].maxSegmentWeight;\n     }\n-    assertTrue(\"totalCapacity=\" + totalCapacity + \", maxSize=\" + maxSize, totalCapacity == maxSize);\n+    assertWithMessage(\"totalCapacity=%s, maxSize=%s\", totalCapacity, maxSize)\n+        .that(totalCapacity)\n+        .isEqualTo(maxSize);\n \n     map =\n         makeLocalCache(\n@@ -470,14 +473,16 @@ private static void checkMaximumSize(int concurrencyLevel, int initialCapacity,\n                 .initialCapacity(initialCapacity)\n                 .maximumWeight(maxSize)\n                 .weigher(constantWeigher(1)));\n-    assertTrue(\n-        \"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n-        map.segments.length <= max(1, maxSize / 10));\n+    assertWithMessage(\"segments=%s, maxSize=%s\", map.segments.length, maxSize)\n+        .that((long) map.segments.length)\n+        .isAtMost(max(1, maxSize / 10));\n     totalCapacity = 0;\n     for (int i = 0; i < map.segments.length; i++) {\n       totalCapacity += map.segments[i].maxSegmentWeight;\n     }\n-    assertTrue(\"totalCapacity=\" + totalCapacity + \", maxSize=\" + maxSize, totalCapacity == maxSize);\n+    assertWithMessage(\"totalCapacity=%s, maxSize=%s\", totalCapacity, maxSize)\n+        .that(totalCapacity)\n+        .isEqualTo(maxSize);\n   }\n \n   public void testSetWeigher() {\n@@ -490,57 +495,57 @@ public int weigh(Object key, Object value) {\n         };\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().maximumWeight(1).weigher(testWeigher));\n-    assertSame(testWeigher, map.weigher);\n+    assertThat(map.weigher).isSameInstanceAs(testWeigher);\n   }\n \n   public void testSetWeakKeys() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().weakKeys());\n     checkStrength(map, Strength.WEAK, Strength.STRONG);\n-    assertSame(EntryFactory.WEAK, map.entryFactory);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.WEAK);\n   }\n \n   public void testSetWeakValues() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().weakValues());\n     checkStrength(map, Strength.STRONG, Strength.WEAK);\n-    assertSame(EntryFactory.STRONG, map.entryFactory);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);\n   }\n \n   public void testSetSoftValues() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().softValues());\n     checkStrength(map, Strength.STRONG, Strength.SOFT);\n-    assertSame(EntryFactory.STRONG, map.entryFactory);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);\n   }\n \n   private static void checkStrength(\n       LocalCache<Object, Object> map, Strength keyStrength, Strength valueStrength) {\n-    assertSame(keyStrength, map.keyStrength);\n-    assertSame(valueStrength, map.valueStrength);\n-    assertSame(keyStrength.defaultEquivalence(), map.keyEquivalence);\n-    assertSame(valueStrength.defaultEquivalence(), map.valueEquivalence);\n+    assertThat(map.keyStrength).isSameInstanceAs(keyStrength);\n+    assertThat(map.valueStrength).isSameInstanceAs(valueStrength);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(keyStrength.defaultEquivalence());\n+    assertThat(map.valueEquivalence).isSameInstanceAs(valueStrength.defaultEquivalence());\n   }\n \n   public void testSetExpireAfterWrite() {\n     long duration = 42;\n     TimeUnit unit = SECONDS;\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().expireAfterWrite(duration, unit));\n-    assertEquals(unit.toNanos(duration), map.expireAfterWriteNanos);\n+    assertThat(map.expireAfterWriteNanos).isEqualTo(unit.toNanos(duration));\n   }\n \n   public void testSetExpireAfterAccess() {\n     long duration = 42;\n     TimeUnit unit = SECONDS;\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().expireAfterAccess(duration, unit));\n-    assertEquals(unit.toNanos(duration), map.expireAfterAccessNanos);\n+    assertThat(map.expireAfterAccessNanos).isEqualTo(unit.toNanos(duration));\n   }\n \n   public void testSetRefresh() {\n     long duration = 42;\n     TimeUnit unit = SECONDS;\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().refreshAfterWrite(duration, unit));\n-    assertEquals(unit.toNanos(duration), map.refreshNanos);\n+    assertThat(map.refreshNanos).isEqualTo(unit.toNanos(duration));\n   }\n \n   public void testLongAsyncRefresh() throws Exception {\n@@ -599,7 +604,7 @@ public void testSetRemovalListener() {\n     RemovalListener<Object, Object> testListener = TestingRemovalListeners.nullRemovalListener();\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().removalListener(testListener));\n-    assertSame(testListener, map.removalListener);\n+    assertThat(map.removalListener).isSameInstanceAs(testListener);\n   }\n \n   public void testSetTicker() {\n@@ -611,33 +616,40 @@ public long read() {\n           }\n         };\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().ticker(testTicker));\n-    assertSame(testTicker, map.ticker);\n+    assertThat(map.ticker).isSameInstanceAs(testTicker);\n   }\n \n   public void testEntryFactory() {\n-    assertSame(EntryFactory.STRONG, EntryFactory.getFactory(Strength.STRONG, false, false));\n-    assertSame(EntryFactory.STRONG_ACCESS, EntryFactory.getFactory(Strength.STRONG, true, false));\n-    assertSame(EntryFactory.STRONG_WRITE, EntryFactory.getFactory(Strength.STRONG, false, true));\n-    assertSame(\n-        EntryFactory.STRONG_ACCESS_WRITE, EntryFactory.getFactory(Strength.STRONG, true, true));\n-    assertSame(EntryFactory.WEAK, EntryFactory.getFactory(Strength.WEAK, false, false));\n-    assertSame(EntryFactory.WEAK_ACCESS, EntryFactory.getFactory(Strength.WEAK, true, false));\n-    assertSame(EntryFactory.WEAK_WRITE, EntryFactory.getFactory(Strength.WEAK, false, true));\n-    assertSame(EntryFactory.WEAK_ACCESS_WRITE, EntryFactory.getFactory(Strength.WEAK, true, true));\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, false, false))\n+        .isSameInstanceAs(EntryFactory.STRONG);\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, true, false))\n+        .isSameInstanceAs(EntryFactory.STRONG_ACCESS);\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, false, true))\n+        .isSameInstanceAs(EntryFactory.STRONG_WRITE);\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, true, true))\n+        .isSameInstanceAs(EntryFactory.STRONG_ACCESS_WRITE);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, false, false))\n+        .isSameInstanceAs(EntryFactory.WEAK);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, true, false))\n+        .isSameInstanceAs(EntryFactory.WEAK_ACCESS);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, false, true))\n+        .isSameInstanceAs(EntryFactory.WEAK_WRITE);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, true, true))\n+        .isSameInstanceAs(EntryFactory.WEAK_ACCESS_WRITE);\n   }\n \n   // computation tests\n \n   public void testCompute() throws ExecutionException {\n     CountingLoader loader = new CountingLoader();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     Object value = map.get(key, loader);\n-    assertEquals(1, loader.getCount());\n-    assertEquals(value, map.get(key, loader));\n-    assertEquals(1, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(1);\n+    assertThat(map.get(key, loader)).isEqualTo(value);\n+    assertThat(loader.getCount()).isEqualTo(1);\n   }\n \n   public void testRecordReadOnCompute() throws ExecutionException {\n@@ -659,7 +671,7 @@ public void testRecordReadOnCompute() throws ExecutionException {\n \n       checkEvictionQueues(map, segment, readOrder, writeOrder);\n       checkExpirationTimes(map);\n-      assertTrue(segment.recencyQueue.isEmpty());\n+      assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n       // access some of the elements\n       Random random = new Random();\n@@ -671,7 +683,7 @@ public void testRecordReadOnCompute() throws ExecutionException {\n           map.get(entry.getKey(), loader);\n           reads.add(entry);\n           i.remove();\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n       }\n       int undrainedIndex = reads.size() - segment.recencyQueue.size();\n@@ -686,14 +698,14 @@ public void testRecordReadOnCompute() throws ExecutionException {\n   public void testComputeExistingEntry() throws ExecutionException {\n     CountingLoader loader = new CountingLoader();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     Object value = new Object();\n     map.put(key, value);\n \n-    assertEquals(value, map.get(key, loader));\n-    assertEquals(0, loader.getCount());\n+    assertThat(map.get(key, loader)).isEqualTo(value);\n+    assertThat(loader.getCount()).isEqualTo(0);\n   }\n \n   public void testComputePartiallyCollectedKey() throws ExecutionException {\n@@ -702,7 +714,7 @@ public void testComputePartiallyCollectedKey() throws ExecutionException {\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     int hash = map.hash(key);\n@@ -715,14 +727,14 @@ public void testComputePartiallyCollectedKey() throws ExecutionException {\n     table.set(index, entry);\n     segment.count++;\n \n-    assertSame(value, map.get(key, loader));\n-    assertEquals(0, loader.getCount());\n-    assertEquals(1, segment.count);\n+    assertThat(map.get(key, loader)).isSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(1);\n \n     entry.clearKey();\n-    assertNotSame(value, map.get(key, loader));\n-    assertEquals(1, loader.getCount());\n-    assertEquals(2, segment.count);\n+    assertThat(map.get(key, loader)).isNotSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(1);\n+    assertThat(segment.count).isEqualTo(2);\n   }\n \n   public void testComputePartiallyCollectedValue() throws ExecutionException {\n@@ -731,7 +743,7 @@ public void testComputePartiallyCollectedValue() throws ExecutionException {\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     int hash = map.hash(key);\n@@ -744,40 +756,40 @@ public void testComputePartiallyCollectedValue() throws ExecutionException {\n     table.set(index, entry);\n     segment.count++;\n \n-    assertSame(value, map.get(key, loader));\n-    assertEquals(0, loader.getCount());\n-    assertEquals(1, segment.count);\n+    assertThat(map.get(key, loader)).isSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(1);\n \n     valueRef.clear();\n-    assertNotSame(value, map.get(key, loader));\n-    assertEquals(1, loader.getCount());\n-    assertEquals(1, segment.count);\n+    assertThat(map.get(key, loader)).isNotSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(1);\n+    assertThat(segment.count).isEqualTo(1);\n   }\n \n   @AndroidIncompatible // Perhaps emulator clock does not update between the two get() calls?\n   public void testComputeExpiredEntry() throws ExecutionException {\n     CacheBuilder<Object, Object> builder = createCacheBuilder().expireAfterWrite(1, NANOSECONDS);\n     CountingLoader loader = new CountingLoader();\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     Object one = map.get(key, loader);\n-    assertEquals(1, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(1);\n \n     Object two = map.get(key, loader);\n-    assertNotSame(one, two);\n-    assertEquals(2, loader.getCount());\n+    assertThat(two).isNotSameInstanceAs(one);\n+    assertThat(loader.getCount()).isEqualTo(2);\n   }\n \n   public void testValues() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n     map.put(\"foo\", \"bar\");\n     map.put(\"baz\", \"bar\");\n     map.put(\"quux\", \"quux\");\n-    assertFalse(map.values() instanceof Set);\n-    assertTrue(map.values().removeAll(ImmutableSet.of(\"bar\")));\n-    assertEquals(1, map.size());\n+    assertThat(map.values() instanceof Set).isFalse();\n+    assertThat(map.values().removeAll(ImmutableSet.of(\"bar\"))).isTrue();\n+    assertThat(map).hasSize(1);\n   }\n \n   public void testComputeIfAbsent_removalListener() {\n@@ -793,7 +805,7 @@ public void onRemoval(RemovalNotification<Object, Object> notification) {\n         CacheBuilder.newBuilder().removalListener(removalListener).build();\n     cache.put(\"a\", \"b\");\n     cache.asMap().computeIfAbsent(\"a\", k -> \"c\");\n-    assertTrue(notifications.toString(), notifications.isEmpty());\n+    assertThat(notifications).isEmpty();\n   }\n \n   public void testCopyEntry_computing() {\n@@ -818,7 +830,7 @@ public Object load(Object key) throws Exception {\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     int hash = map.hash(one);\n@@ -861,7 +873,7 @@ public void run() {\n     @SuppressWarnings(\"unchecked\")\n     LoadingValueReference<Object, Object> valueReference =\n         (LoadingValueReference) newEntry.getValueReference();\n-    assertFalse(valueReference.futureValue.isDone());\n+    assertThat(valueReference.futureValue.isDone()).isFalse();\n     startSignal.countDown();\n \n     try {\n@@ -871,10 +883,10 @@ public void run() {\n     }\n \n     map.cleanUp(); // force notifications\n-    assertTrue(listener.isEmpty());\n-    assertTrue(map.containsKey(one));\n-    assertEquals(1, map.size());\n-    assertSame(computedObject, map.get(one));\n+    assertThat(listener.isEmpty()).isTrue();\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map).hasSize(1);\n+    assertThat(map.get(one)).isSameInstanceAs(computedObject);\n   }\n \n   public void testRemovalListenerCheckedException() {\n@@ -916,7 +928,7 @@ public Object load(Object key) throws Exception {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     CacheBuilder<Object, Object> builder = createCacheBuilder().removalListener(listener);\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -940,7 +952,7 @@ public void run() {\n     }\n \n     map.put(one, two);\n-    assertSame(two, map.get(one));\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n     startSignal.countDown();\n \n     try {\n@@ -951,7 +963,7 @@ public void run() {\n \n     map.cleanUp(); // force notifications\n     assertNotified(listener, one, computedObject, RemovalCause.REPLACED);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testSegmentRefresh_duplicate() throws ExecutionException {\n@@ -977,7 +989,7 @@ public void testSegmentRefresh_duplicate() throws ExecutionException {\n   public void testRemovalListener_explicit() {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1012,13 +1024,13 @@ public void testRemovalListener_explicit() {\n     i.remove();\n     assertNotified(listener, five, six, RemovalCause.EXPLICIT);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testRemovalListener_replaced() {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1048,22 +1060,22 @@ public void testRemovalListener_collected() {\n         makeLocalCache(\n             createCacheBuilder().concurrencyLevel(1).softValues().removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n     Object three = new Object();\n \n     map.put(one, two);\n     map.put(two, three);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     int hash = map.hash(one);\n     ReferenceEntry<Object, Object> entry = segment.getEntry(one, hash);\n     map.reclaimValue(entry.getValueReference());\n     assertNotified(listener, one, two, RemovalCause.COLLECTED);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testRemovalListener_expired() {\n@@ -1076,7 +1088,7 @@ public void testRemovalListener_expired() {\n                 .expireAfterWrite(3, NANOSECONDS)\n                 .ticker(ticker)\n                 .removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1089,20 +1101,20 @@ public void testRemovalListener_expired() {\n     map.put(two, three);\n     ticker.advance(1);\n     map.put(three, four);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     ticker.advance(1);\n     map.put(four, five);\n     assertNotified(listener, one, two, RemovalCause.EXPIRED);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testRemovalListener_size() {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     LocalCache<Object, Object> map =\n         makeLocalCache(\n             createCacheBuilder().concurrencyLevel(1).maximumSize(2).removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1111,19 +1123,19 @@ public void testRemovalListener_size() {\n \n     map.put(one, two);\n     map.put(two, three);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     map.put(three, four);\n     assertNotified(listener, one, two, RemovalCause.SIZE);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   static <K, V> void assertNotified(\n       QueuingRemovalListener<K, V> listener, K key, V value, RemovalCause cause) {\n     RemovalNotification<K, V> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(value, notification.getValue());\n-    assertSame(cause, notification.getCause());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(value);\n+    assertThat(notification.getCause()).isSameInstanceAs(cause);\n   }\n \n   // Segment core tests\n@@ -1137,26 +1149,26 @@ public void testNewEntry() {\n       int hashOne = map.hash(keyOne);\n       ReferenceEntry<Object, Object> entryOne = map.newEntry(keyOne, hashOne, null);\n       ValueReference<Object, Object> valueRefOne = map.newValueReference(entryOne, valueOne, 1);\n-      assertSame(valueOne, valueRefOne.get());\n+      assertThat(valueRefOne.get()).isSameInstanceAs(valueOne);\n       entryOne.setValueReference(valueRefOne);\n \n-      assertSame(keyOne, entryOne.getKey());\n-      assertEquals(hashOne, entryOne.getHash());\n-      assertNull(entryOne.getNext());\n-      assertSame(valueRefOne, entryOne.getValueReference());\n+      assertThat(entryOne.getKey()).isSameInstanceAs(keyOne);\n+      assertThat(entryOne.getHash()).isEqualTo(hashOne);\n+      assertThat(entryOne.getNext()).isNull();\n+      assertThat(entryOne.getValueReference()).isSameInstanceAs(valueRefOne);\n \n       Object keyTwo = new Object();\n       Object valueTwo = new Object();\n       int hashTwo = map.hash(keyTwo);\n       ReferenceEntry<Object, Object> entryTwo = map.newEntry(keyTwo, hashTwo, entryOne);\n       ValueReference<Object, Object> valueRefTwo = map.newValueReference(entryTwo, valueTwo, 1);\n-      assertSame(valueTwo, valueRefTwo.get());\n+      assertThat(valueRefTwo.get()).isSameInstanceAs(valueTwo);\n       entryTwo.setValueReference(valueRefTwo);\n \n-      assertSame(keyTwo, entryTwo.getKey());\n-      assertEquals(hashTwo, entryTwo.getHash());\n-      assertSame(entryOne, entryTwo.getNext());\n-      assertSame(valueRefTwo, entryTwo.getValueReference());\n+      assertThat(entryTwo.getKey()).isSameInstanceAs(keyTwo);\n+      assertThat(entryTwo.getHash()).isEqualTo(hashTwo);\n+      assertThat(entryTwo.getNext()).isSameInstanceAs(entryOne);\n+      assertThat(entryTwo.getValueReference()).isSameInstanceAs(valueRefTwo);\n     }\n   }\n \n@@ -1184,28 +1196,28 @@ public void testCopyEntry() {\n       assertConnected(map, entryOne, entryTwo);\n \n       ReferenceEntry<Object, Object> copyOne = map.copyEntry(entryOne, null);\n-      assertSame(keyOne, entryOne.getKey());\n-      assertEquals(hashOne, entryOne.getHash());\n-      assertNull(entryOne.getNext());\n-      assertSame(valueOne, copyOne.getValueReference().get());\n+      assertThat(entryOne.getKey()).isSameInstanceAs(keyOne);\n+      assertThat(entryOne.getHash()).isEqualTo(hashOne);\n+      assertThat(entryOne.getNext()).isNull();\n+      assertThat(copyOne.getValueReference().get()).isSameInstanceAs(valueOne);\n       assertConnected(map, copyOne, entryTwo);\n \n       ReferenceEntry<Object, Object> copyTwo = map.copyEntry(entryTwo, copyOne);\n-      assertSame(keyTwo, copyTwo.getKey());\n-      assertEquals(hashTwo, copyTwo.getHash());\n-      assertSame(copyOne, copyTwo.getNext());\n-      assertSame(valueTwo, copyTwo.getValueReference().get());\n+      assertThat(copyTwo.getKey()).isSameInstanceAs(keyTwo);\n+      assertThat(copyTwo.getHash()).isEqualTo(hashTwo);\n+      assertThat(copyTwo.getNext()).isSameInstanceAs(copyOne);\n+      assertThat(copyTwo.getValueReference().get()).isSameInstanceAs(valueTwo);\n       assertConnected(map, copyOne, copyTwo);\n     }\n   }\n \n   private static <K, V> void assertConnected(\n       LocalCache<K, V> map, ReferenceEntry<K, V> one, ReferenceEntry<K, V> two) {\n     if (map.usesWriteQueue()) {\n-      assertSame(two, one.getNextInWriteQueue());\n+      assertThat(one.getNextInWriteQueue()).isSameInstanceAs(two);\n     }\n     if (map.usesAccessQueue()) {\n-      assertSame(two, one.getNextInAccessQueue());\n+      assertThat(one.getNextInAccessQueue()).isSameInstanceAs(two);\n     }\n   }\n \n@@ -1235,14 +1247,14 @@ public void testSegmentGetAndContains() {\n     // count == 0\n     table.set(index, entry);\n     assertNull(segment.get(key, hash));\n-    assertFalse(segment.containsKey(key, hash));\n-    assertFalse(segment.containsValue(value));\n+    assertThat(segment.containsKey(key, hash)).isFalse();\n+    assertThat(segment.containsValue(value)).isFalse();\n \n     // count == 1\n     segment.count++;\n-    assertSame(value, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n     // don't see absent values now that count > 0\n     assertNull(segment.get(new Object(), hash));\n \n@@ -1253,21 +1265,21 @@ public void testSegmentGetAndContains() {\n     nullEntry.setValueReference(nullValueRef);\n     table.set(index, nullEntry);\n     // skip the null key\n-    assertSame(value, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertFalse(segment.containsValue(nullValue));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(nullValue)).isFalse();\n \n     // hash collision\n     DummyEntry<Object, Object> dummy = DummyEntry.create(new Object(), hash, entry);\n     Object dummyValue = new Object();\n     ValueReference<Object, Object> dummyValueRef = map.newValueReference(dummy, dummyValue, 1);\n     dummy.setValueReference(dummyValueRef);\n     table.set(index, dummy);\n-    assertSame(value, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertTrue(segment.containsValue(dummyValue));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(dummyValue)).isTrue();\n \n     // key collision\n     dummy = DummyEntry.create(key, hash, entry);\n@@ -1276,17 +1288,17 @@ public void testSegmentGetAndContains() {\n     dummy.setValueReference(dummyValueRef);\n     table.set(index, dummy);\n     // returns the most recent entry\n-    assertSame(dummyValue, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertTrue(segment.containsValue(dummyValue));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(dummyValue);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(dummyValue)).isTrue();\n \n     // expired\n     dummy.setAccessTime(ticker.read() - 2);\n     assertNull(segment.get(key, hash));\n-    assertFalse(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertFalse(segment.containsValue(dummyValue));\n+    assertThat(segment.containsKey(key, hash)).isFalse();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(dummyValue)).isFalse();\n   }\n \n   public void testSegmentReplaceValue() {\n@@ -1307,29 +1319,29 @@ public void testSegmentReplaceValue() {\n     entry.setValueReference(oldValueRef);\n \n     // no entry\n-    assertFalse(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same value\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertTrue(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isTrue();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // different value\n-    assertFalse(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // cleared\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n-    assertFalse(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1352,23 +1364,23 @@ public void testSegmentReplace() {\n \n     // no entry\n     assertNull(segment.replace(key, hash, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same key\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertSame(oldValue, segment.replace(key, hash, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.replace(key, hash, newValue)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // cleared\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.replace(key, hash, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1384,24 +1396,24 @@ public void testSegmentPut() {\n     Object newValue = new Object();\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.put(key, hash, oldValue, false));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n \n     // same key\n-    assertSame(oldValue, segment.put(key, hash, newValue, false));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.put(key, hash, newValue, false)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // cleared\n     ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);\n     DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.put(key, hash, newValue, false));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n   }\n \n   public void testSegmentPutIfAbsent() {\n@@ -1416,39 +1428,39 @@ public void testSegmentPutIfAbsent() {\n     Object newValue = new Object();\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.put(key, hash, oldValue, true));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n \n     // same key\n-    assertSame(oldValue, segment.put(key, hash, newValue, true));\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.put(key, hash, newValue, true)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n \n     // cleared\n     ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);\n     DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.put(key, hash, newValue, true));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n   }\n \n   public void testSegmentPut_expand() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertEquals(1, segment.table.length());\n+    assertThat(segment.table.length()).isEqualTo(1);\n \n     int count = 1024;\n     for (int i = 0; i < count; i++) {\n       Object key = new Object();\n       Object value = new Object();\n       int hash = map.hash(key);\n       assertNull(segment.put(key, hash, value, false));\n-      assertTrue(segment.table.length() > i);\n+      assertThat(segment.table.length()).isGreaterThan(i);\n     }\n   }\n \n@@ -1470,7 +1482,7 @@ public void testSegmentPut_evict() {\n         it.next();\n         it.remove();\n       }\n-      assertEquals(originalMap, map);\n+      assertThat(map).isEqualTo(originalMap);\n     }\n   }\n \n@@ -1491,64 +1503,64 @@ public void testSegmentStoreComputedValue() {\n \n     // absent\n     Object value = new Object();\n-    assertTrue(listener.isEmpty());\n-    assertEquals(0, segment.count);\n+    assertThat(listener.isEmpty()).isTrue();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value));\n-    assertSame(value, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n-    assertTrue(listener.isEmpty());\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // clobbered\n     Object value2 = new Object();\n-    assertFalse(segment.storeLoadedValue(key, hash, valueRef, value2));\n-    assertEquals(1, segment.count);\n-    assertSame(value, segment.get(key, hash));\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value2)).isFalse();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertEquals(immutableEntry(key, value2), notification);\n-    assertEquals(RemovalCause.REPLACED, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification).isEqualTo(immutableEntry(key, value2));\n+    assertThat(notification.getCause()).isEqualTo(RemovalCause.REPLACED);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // inactive\n     Object value3 = new Object();\n     map.clear();\n     listener.clear();\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     table.set(index, entry);\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value3));\n-    assertSame(value3, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n-    assertTrue(listener.isEmpty());\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value3)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // replaced\n     Object value4 = new Object();\n     DummyValueReference<Object, Object> value3Ref = DummyValueReference.create(value3);\n     valueRef = new LoadingValueReference<>(value3Ref);\n     entry.setValueReference(valueRef);\n     table.set(index, entry);\n-    assertSame(value3, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));\n-    assertSame(value4, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value4)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value4);\n+    assertThat(segment.count).isEqualTo(1);\n     notification = listener.remove();\n-    assertEquals(immutableEntry(key, value3), notification);\n-    assertEquals(RemovalCause.REPLACED, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification).isEqualTo(immutableEntry(key, value3));\n+    assertThat(notification.getCause()).isEqualTo(RemovalCause.REPLACED);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // collected\n     entry.setValueReference(valueRef);\n     table.set(index, entry);\n-    assertSame(value3, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);\n+    assertThat(segment.count).isEqualTo(1);\n     value3Ref.clear();\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));\n-    assertSame(value4, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value4)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value4);\n+    assertThat(segment.count).isEqualTo(1);\n     notification = listener.remove();\n-    assertEquals(immutableEntry(key, null), notification);\n-    assertEquals(RemovalCause.COLLECTED, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification).isEqualTo(immutableEntry(key, null));\n+    assertThat(notification.getCause()).isEqualTo(RemovalCause.COLLECTED);\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testSegmentRemove() {\n@@ -1566,27 +1578,27 @@ public void testSegmentRemove() {\n     entry.setValueReference(oldValueRef);\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same key\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertSame(oldValue, segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.remove(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n \n     // cleared\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1606,41 +1618,41 @@ public void testSegmentRemoveValue() {\n     entry.setValueReference(oldValueRef);\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same value\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertTrue(segment.remove(key, hash, oldValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.remove(key, hash, oldValue)).isTrue();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n \n     // different value\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertFalse(segment.remove(key, hash, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.remove(key, hash, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n \n     // cleared\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n-    assertFalse(segment.remove(key, hash, oldValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.remove(key, hash, oldValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n   public void testExpand() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertEquals(1, segment.table.length());\n+    assertThat(segment.table.length()).isEqualTo(1);\n \n     // manually add elements to avoid expansion\n     int originalCount = 1024;\n@@ -1657,17 +1669,17 @@ public void testExpand() {\n     segment.table.set(0, entry);\n     segment.count = originalCount;\n     ImmutableMap<Object, Object> originalMap = ImmutableMap.copyOf(map);\n-    assertEquals(originalCount, originalMap.size());\n-    assertEquals(originalMap, map);\n+    assertThat(originalMap).hasSize(originalCount);\n+    assertThat(map).isEqualTo(originalMap);\n \n     for (int i = 1; i <= originalCount * 2; i *= 2) {\n       if (i > 1) {\n         segment.expand();\n       }\n-      assertEquals(i, segment.table.length());\n-      assertEquals(originalCount, countLiveEntries(map, 0));\n-      assertEquals(originalCount, segment.count);\n-      assertEquals(originalMap, map);\n+      assertThat(segment.table.length()).isEqualTo(i);\n+      assertThat(countLiveEntries(map, 0)).isEqualTo(originalCount);\n+      assertThat(segment.count).isEqualTo(originalCount);\n+      assertThat(map).isEqualTo(originalMap);\n     }\n   }\n \n@@ -1676,7 +1688,7 @@ public void testGetCausesExpansion() throws ExecutionException {\n       LocalCache<Object, Object> map =\n           makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n       Segment<Object, Object> segment = map.segments[0];\n-      assertEquals(1, segment.table.length());\n+      assertThat(segment.table.length()).isEqualTo(1);\n \n       for (int i = 0; i < count; i++) {\n         Object key = new Object();\n@@ -1691,37 +1703,37 @@ public Object load(Object key) {\n               }\n             });\n       }\n-      assertEquals(count, segment.count);\n-      assertTrue(count <= segment.threshold);\n-      assertTrue(count <= (segment.table.length() * 3 / 4));\n-      assertTrue(count > (segment.table.length() * 3 / 8));\n+      assertThat(segment.count).isEqualTo(count);\n+      assertThat(count).isAtMost(segment.threshold);\n+      assertThat(count).isAtMost((segment.table.length() * 3 / 4));\n+      assertThat(count).isGreaterThan(segment.table.length() * 3 / 8);\n     }\n   }\n \n   public void testGetOrDefault() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     map.put(1, 1);\n-    assertEquals(1, map.getOrDefault(1, 2));\n-    assertEquals(2, map.getOrDefault(2, 2));\n+    assertThat(map.getOrDefault(1, 2)).isEqualTo(1);\n+    assertThat(map.getOrDefault(2, 2)).isEqualTo(2);\n   }\n \n   public void testPutCausesExpansion() {\n     for (int count = 1; count <= 100; count++) {\n       LocalCache<Object, Object> map =\n           makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n       Segment<Object, Object> segment = map.segments[0];\n-      assertEquals(1, segment.table.length());\n+      assertThat(segment.table.length()).isEqualTo(1);\n \n       for (int i = 0; i < count; i++) {\n         Object key = new Object();\n         Object value = new Object();\n         segment.put(key, key.hashCode(), value, true);\n       }\n-      assertEquals(count, segment.count);\n-      assertTrue(count <= segment.threshold);\n-      assertTrue(count <= (segment.table.length() * 3 / 4));\n-      assertTrue(count > (segment.table.length() * 3 / 8));\n+      assertThat(segment.count).isEqualTo(count);\n+      assertThat(count).isAtMost(segment.threshold);\n+      assertThat(count).isAtMost((segment.table.length() * 3 / 4));\n+      assertThat(count).isGreaterThan(segment.table.length() * 3 / 8);\n     }\n   }\n \n@@ -1737,7 +1749,7 @@ public void testReclaimKey() {\n                 .removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     // create 3 objects and chain them together\n     Object keyOne = new Object();\n@@ -1755,28 +1767,28 @@ public void testReclaimKey() {\n         createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n \n     // absent\n-    assertEquals(0, listener.getCount());\n-    assertFalse(segment.reclaimKey(entryOne, hashOne));\n-    assertEquals(0, listener.getCount());\n+    assertThat(listener.getCount()).isEqualTo(0);\n+    assertThat(segment.reclaimKey(entryOne, hashOne)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(0);\n     table.set(0, entryOne);\n-    assertFalse(segment.reclaimKey(entryTwo, hashTwo));\n-    assertEquals(0, listener.getCount());\n+    assertThat(segment.reclaimKey(entryTwo, hashTwo)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(0);\n     table.set(0, entryTwo);\n-    assertFalse(segment.reclaimKey(entryThree, hashThree));\n-    assertEquals(0, listener.getCount());\n+    assertThat(segment.reclaimKey(entryThree, hashThree)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(0);\n \n     // present\n     table.set(0, entryOne);\n     segment.count = 1;\n-    assertTrue(segment.reclaimKey(entryOne, hashOne));\n-    assertEquals(1, listener.getCount());\n-    assertSame(keyOne, listener.getLastEvictedKey());\n-    assertSame(valueOne, listener.getLastEvictedValue());\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertFalse(segment.accessQueue.contains(entryOne));\n-    assertFalse(segment.writeQueue.contains(entryOne));\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(segment.reclaimKey(entryOne, hashOne)).isTrue();\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(keyOne);\n+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(valueOne);\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.accessQueue.contains(entryOne)).isFalse();\n+    assertThat(segment.writeQueue.contains(entryOne)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n   }\n \n   public void testRemoveEntryFromChain() {\n@@ -1802,32 +1814,32 @@ public void testRemoveEntryFromChain() {\n     assertNull(segment.removeEntryFromChain(entryOne, entryOne));\n \n     // head\n-    assertSame(entryOne, segment.removeEntryFromChain(entryTwo, entryTwo));\n+    assertThat(segment.removeEntryFromChain(entryTwo, entryTwo)).isSameInstanceAs(entryOne);\n \n     // middle\n     ReferenceEntry<Object, Object> newFirst = segment.removeEntryFromChain(entryThree, entryTwo);\n-    assertSame(keyThree, newFirst.getKey());\n-    assertSame(valueThree, newFirst.getValueReference().get());\n-    assertEquals(hashThree, newFirst.getHash());\n-    assertSame(entryOne, newFirst.getNext());\n+    assertThat(newFirst.getKey()).isSameInstanceAs(keyThree);\n+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueThree);\n+    assertThat(newFirst.getHash()).isEqualTo(hashThree);\n+    assertThat(newFirst.getNext()).isSameInstanceAs(entryOne);\n \n     // tail (remaining entries are copied in reverse order)\n     newFirst = segment.removeEntryFromChain(entryThree, entryOne);\n-    assertSame(keyTwo, newFirst.getKey());\n-    assertSame(valueTwo, newFirst.getValueReference().get());\n-    assertEquals(hashTwo, newFirst.getHash());\n+    assertThat(newFirst.getKey()).isSameInstanceAs(keyTwo);\n+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueTwo);\n+    assertThat(newFirst.getHash()).isEqualTo(hashTwo);\n     newFirst = newFirst.getNext();\n-    assertSame(keyThree, newFirst.getKey());\n-    assertSame(valueThree, newFirst.getValueReference().get());\n-    assertEquals(hashThree, newFirst.getHash());\n-    assertNull(newFirst.getNext());\n+    assertThat(newFirst.getKey()).isSameInstanceAs(keyThree);\n+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueThree);\n+    assertThat(newFirst.getHash()).isEqualTo(hashThree);\n+    assertThat(newFirst.getNext()).isNull();\n   }\n \n   public void testExpand_cleanup() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertEquals(1, segment.table.length());\n+    assertThat(segment.table.length()).isEqualTo(1);\n \n     // manually add elements to avoid expansion\n     // 1/3 null keys, 1/3 null values\n@@ -1848,22 +1860,22 @@ public void testExpand_cleanup() {\n     segment.table.set(0, entry);\n     segment.count = originalCount;\n     int liveCount = originalCount / 3;\n-    assertEquals(1, segment.table.length());\n-    assertEquals(liveCount, countLiveEntries(map, 0));\n+    assertThat(segment.table.length()).isEqualTo(1);\n+    assertThat(countLiveEntries(map, 0)).isEqualTo(liveCount);\n     ImmutableMap<Object, Object> originalMap = ImmutableMap.copyOf(map);\n-    assertEquals(liveCount, originalMap.size());\n+    assertThat(originalMap).hasSize(liveCount);\n     // can't compare map contents until cleanup occurs\n \n     for (int i = 1; i <= originalCount * 2; i *= 2) {\n       if (i > 1) {\n         segment.expand();\n       }\n-      assertEquals(i, segment.table.length());\n-      assertEquals(liveCount, countLiveEntries(map, 0));\n+      assertThat(segment.table.length()).isEqualTo(i);\n+      assertThat(countLiveEntries(map, 0)).isEqualTo(liveCount);\n       // expansion cleanup is sloppy, with a goal of avoiding unnecessary copies\n-      assertTrue(segment.count >= liveCount);\n-      assertTrue(segment.count <= originalCount);\n-      assertEquals(originalMap, ImmutableMap.copyOf(map));\n+      assertThat(segment.count).isAtLeast(liveCount);\n+      assertThat(segment.count).isAtMost(originalCount);\n+      assertThat(ImmutableMap.copyOf(map)).isEqualTo(originalMap);\n     }\n   }\n \n@@ -1883,8 +1895,8 @@ public void testRemoveIfWithConcurrentModification() {\n                 return false;\n               }\n             });\n-    assertEquals(3, map.size());\n-    assertFalse(map.containsValue(1));\n+    assertThat(map).hasSize(3);\n+    assertThat(map.containsValue(1)).isFalse();\n   }\n \n   public void testRemoveIfWithConcurrentRemoval() {\n@@ -1900,7 +1912,7 @@ public void testRemoveIfWithConcurrentRemoval() {\n               map.remove((entry.getKey() + 1) % 3);\n               return false;\n             });\n-    assertEquals(1, map.size());\n+    assertThat(map).hasSize(1);\n   }\n \n   private static <K, V> int countLiveEntries(LocalCache<K, V> map, long now) {\n@@ -1928,7 +1940,7 @@ public void testClear() {\n                 .expireAfterWrite(99999, SECONDS));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -1940,17 +1952,17 @@ public void testClear() {\n     segment.count = 1;\n     segment.totalWeight = 1;\n \n-    assertSame(entry, table.get(0));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertSame(entry, segment.writeQueue.peek());\n+    assertThat(table.get(0)).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n \n     segment.clear();\n-    assertNull(table.get(0));\n-    assertTrue(segment.accessQueue.isEmpty());\n-    assertTrue(segment.writeQueue.isEmpty());\n-    assertEquals(0, segment.readCount.get());\n-    assertEquals(0, segment.count);\n-    assertEquals(0, segment.totalWeight);\n+    assertThat(table.get(0)).isNull();\n+    assertThat(segment.accessQueue.isEmpty()).isTrue();\n+    assertThat(segment.writeQueue.isEmpty()).isTrue();\n+    assertThat(segment.readCount.get()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(segment.totalWeight).isEqualTo(0);\n   }\n \n   public void testClear_notification() {\n@@ -1965,7 +1977,7 @@ public void testClear_notification() {\n                 .removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -1977,17 +1989,17 @@ public void testClear_notification() {\n     segment.count = 1;\n     segment.totalWeight = 1;\n \n-    assertSame(entry, table.get(0));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertSame(entry, segment.writeQueue.peek());\n+    assertThat(table.get(0)).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n \n     segment.clear();\n-    assertNull(table.get(0));\n-    assertTrue(segment.accessQueue.isEmpty());\n-    assertTrue(segment.writeQueue.isEmpty());\n-    assertEquals(0, segment.readCount.get());\n-    assertEquals(0, segment.count);\n-    assertEquals(0, segment.totalWeight);\n+    assertThat(table.get(0)).isNull();\n+    assertThat(segment.accessQueue.isEmpty()).isTrue();\n+    assertThat(segment.writeQueue.isEmpty()).isTrue();\n+    assertThat(segment.readCount.get()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(segment.totalWeight).isEqualTo(0);\n     assertNotified(listener, key, value, RemovalCause.EXPLICIT);\n   }\n \n@@ -2002,27 +2014,27 @@ public void testRemoveEntry() {\n                 .removalListener(countingRemovalListener()));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n     int hash = map.hash(key);\n     DummyEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);\n \n     // remove absent\n-    assertFalse(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));\n+    assertThat(segment.removeEntry(entry, hash, RemovalCause.COLLECTED)).isFalse();\n \n     // remove live\n     segment.recordWrite(entry, 1, map.ticker.read());\n     table.set(0, entry);\n     segment.count = 1;\n-    assertTrue(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));\n+    assertThat(segment.removeEntry(entry, hash, RemovalCause.COLLECTED)).isTrue();\n     assertNotificationEnqueued(map, key, value);\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertFalse(segment.accessQueue.contains(entry));\n-    assertFalse(segment.writeQueue.contains(entry));\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.accessQueue.contains(entry)).isFalse();\n+    assertThat(segment.writeQueue.contains(entry)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n   }\n \n   public void testReclaimValue() {\n@@ -2037,7 +2049,7 @@ public void testReclaimValue() {\n                 .removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -2047,32 +2059,32 @@ public void testReclaimValue() {\n     entry.setValueReference(valueRef);\n \n     // reclaim absent\n-    assertFalse(segment.reclaimValue(key, hash, valueRef));\n+    assertThat(segment.reclaimValue(key, hash, valueRef)).isFalse();\n \n     // reclaim live\n     segment.recordWrite(entry, 1, map.ticker.read());\n     table.set(0, entry);\n     segment.count = 1;\n-    assertTrue(segment.reclaimValue(key, hash, valueRef));\n-    assertEquals(1, listener.getCount());\n-    assertSame(key, listener.getLastEvictedKey());\n-    assertSame(value, listener.getLastEvictedValue());\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertFalse(segment.accessQueue.contains(entry));\n-    assertFalse(segment.writeQueue.contains(entry));\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(segment.reclaimValue(key, hash, valueRef)).isTrue();\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(key);\n+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(value);\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.accessQueue.contains(entry)).isFalse();\n+    assertThat(segment.writeQueue.contains(entry)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n \n     // reclaim wrong value reference\n     table.set(0, entry);\n     DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);\n     entry.setValueReference(otherValueRef);\n-    assertFalse(segment.reclaimValue(key, hash, valueRef));\n-    assertEquals(1, listener.getCount());\n-    assertTrue(segment.reclaimValue(key, hash, otherValueRef));\n-    assertEquals(2, listener.getCount());\n-    assertSame(key, listener.getLastEvictedKey());\n-    assertSame(value, listener.getLastEvictedValue());\n+    assertThat(segment.reclaimValue(key, hash, valueRef)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(segment.reclaimValue(key, hash, otherValueRef)).isTrue();\n+    assertThat(listener.getCount()).isEqualTo(2);\n+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(key);\n+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(value);\n   }\n \n   public void testRemoveComputingValue() {\n@@ -2086,7 +2098,7 @@ public void testRemoveComputingValue() {\n                 .removalListener(countingRemovalListener()));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     int hash = map.hash(key);\n@@ -2095,16 +2107,16 @@ public void testRemoveComputingValue() {\n     entry.setValueReference(valueRef);\n \n     // absent\n-    assertFalse(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isFalse();\n \n     // live\n     table.set(0, entry);\n     // don't increment count; this is used during computation\n-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();\n     // no notification sent with removeLoadingValue\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n \n     // active\n     Object value = new Object();\n@@ -2113,23 +2125,23 @@ public void testRemoveComputingValue() {\n     entry.setValueReference(valueRef);\n     table.set(0, entry);\n     segment.count = 1;\n-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));\n-    assertSame(entry, table.get(0));\n-    assertSame(value, segment.get(key, hash));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();\n+    assertThat(table.get(0)).isSameInstanceAs(entry);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n \n     // wrong value reference\n     table.set(0, entry);\n     DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);\n     entry.setValueReference(otherValueRef);\n-    assertFalse(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isFalse();\n     entry.setValueReference(valueRef);\n-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();\n   }\n \n   private static <K, V> void assertNotificationEnqueued(LocalCache<K, V> map, K key, V value) {\n     RemovalNotification<K, V> notification = map.removalNotificationQueue.poll();\n-    assertSame(key, notification.getKey());\n-    assertSame(value, notification.getValue());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(value);\n   }\n \n   // Segment eviction tests\n@@ -2146,15 +2158,15 @@ public void testDrainRecencyQueueOnWrite() {\n         Object valueTwo = new Object();\n \n         map.put(keyOne, valueOne);\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {\n           map.get(keyOne);\n         }\n-        assertFalse(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isFalse();\n \n         map.put(keyTwo, valueTwo);\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n       }\n     }\n   }\n@@ -2171,33 +2183,33 @@ public void testDrainRecencyQueueOnRead() {\n         // repeated get of the same key\n \n         map.put(keyOne, valueOne);\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {\n           map.get(keyOne);\n         }\n-        assertFalse(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isFalse();\n \n         for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n           map.get(keyOne);\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n \n         // get over many different keys\n \n         for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n           map.put(new Object(), new Object());\n         }\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {\n           map.get(keyOne);\n         }\n-        assertFalse(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isFalse();\n \n         for (Object key : map.keySet()) {\n           map.get(key);\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n       }\n     }\n@@ -2263,7 +2275,7 @@ public void testRecordReadOnGet() {\n \n       checkEvictionQueues(map, segment, readOrder, writeOrder);\n       checkExpirationTimes(map);\n-      assertTrue(segment.recencyQueue.isEmpty());\n+      assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n       // access some of the elements\n       Random random = new Random();\n@@ -2275,7 +2287,7 @@ public void testRecordReadOnGet() {\n           map.get(entry.getKey());\n           reads.add(entry);\n           i.remove();\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n       }\n       int undrainedIndex = reads.size() - segment.recencyQueue.size();\n@@ -2349,12 +2361,13 @@ static <K, V> void checkEvictionQueues(\n   private static <K, V> void assertSameEntries(\n       List<ReferenceEntry<K, V>> expectedEntries, List<ReferenceEntry<K, V>> actualEntries) {\n     int size = expectedEntries.size();\n-    assertEquals(size, actualEntries.size());\n+    assertThat(actualEntries).hasSize(size);\n     for (int i = 0; i < size; i++) {\n       ReferenceEntry<K, V> expectedEntry = expectedEntries.get(i);\n       ReferenceEntry<K, V> actualEntry = actualEntries.get(i);\n-      assertSame(expectedEntry.getKey(), actualEntry.getKey());\n-      assertSame(expectedEntry.getValueReference().get(), actualEntry.getValueReference().get());\n+      assertThat(actualEntry.getKey()).isSameInstanceAs(expectedEntry.getKey());\n+      assertThat(actualEntry.getValueReference().get())\n+          .isSameInstanceAs(expectedEntry.getValueReference().get());\n     }\n   }\n \n@@ -2368,23 +2381,23 @@ static <K, V> void checkExpirationTimes(LocalCache<K, V> map) {\n       long lastWriteTime = 0;\n       for (ReferenceEntry<K, V> e : segment.recencyQueue) {\n         long accessTime = e.getAccessTime();\n-        assertTrue(accessTime >= lastAccessTime);\n+        assertThat(accessTime).isAtLeast(lastAccessTime);\n         lastAccessTime = accessTime;\n         long writeTime = e.getWriteTime();\n-        assertTrue(writeTime >= lastWriteTime);\n+        assertThat(writeTime).isAtLeast(lastWriteTime);\n         lastWriteTime = writeTime;\n       }\n \n       lastAccessTime = 0;\n       lastWriteTime = 0;\n       for (ReferenceEntry<K, V> e : segment.accessQueue) {\n         long accessTime = e.getAccessTime();\n-        assertTrue(accessTime >= lastAccessTime);\n+        assertThat(accessTime).isAtLeast(lastAccessTime);\n         lastAccessTime = accessTime;\n       }\n       for (ReferenceEntry<K, V> e : segment.writeQueue) {\n         long writeTime = e.getWriteTime();\n-        assertTrue(writeTime >= lastWriteTime);\n+        assertThat(writeTime).isAtLeast(lastWriteTime);\n         lastWriteTime = writeTime;\n       }\n     }\n@@ -2404,31 +2417,31 @@ public void testExpireAfterWrite() {\n     Object value = new Object();\n     map.put(key, value);\n     ReferenceEntry<Object, Object> entry = map.getEntry(key);\n-    assertTrue(map.isLive(entry, ticker.read()));\n+    assertThat(map.isLive(entry, ticker.read())).isTrue();\n \n     segment.writeQueue.add(entry);\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.writeQueue.peek());\n-    assertEquals(1, segment.writeQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue).hasSize(1);\n \n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.writeQueue.peek());\n-    assertEquals(1, segment.writeQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.writeQueue.peek());\n-    assertEquals(1, segment.writeQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue).hasSize(1);\n \n     ticker.advance(1);\n-    assertNull(map.get(key));\n+    assertThat(map.get(key)).isNull();\n     segment.expireEntries(ticker.read());\n-    assertNull(map.get(key));\n-    assertTrue(segment.writeQueue.isEmpty());\n+    assertThat(map.get(key)).isNull();\n+    assertThat(segment.writeQueue.isEmpty()).isTrue();\n   }\n \n   public void testExpireAfterAccess() {\n@@ -2445,46 +2458,46 @@ public void testExpireAfterAccess() {\n     Object value = new Object();\n     map.put(key, value);\n     ReferenceEntry<Object, Object> entry = map.getEntry(key);\n-    assertTrue(map.isLive(entry, ticker.read()));\n+    assertThat(map.isLive(entry, ticker.read())).isTrue();\n \n     segment.accessQueue.add(entry);\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n-    assertFalse(map.containsKey(key));\n-    assertNull(map.get(key));\n+    assertThat(map.containsKey(key)).isFalse();\n+    assertThat(map.get(key)).isNull();\n     segment.expireEntries(ticker.read());\n-    assertFalse(map.containsKey(key));\n-    assertNull(map.get(key));\n-    assertTrue(segment.accessQueue.isEmpty());\n+    assertThat(map.containsKey(key)).isFalse();\n+    assertThat(map.get(key)).isNull();\n+    assertThat(segment.accessQueue.isEmpty()).isTrue();\n   }\n \n   public void testEvictEntries() {\n@@ -2513,17 +2526,17 @@ public void testEvictEntries() {\n     }\n     segment.count = originalCount;\n     segment.totalWeight = originalCount;\n-    assertEquals(originalCount, map.size());\n-    assertEquals(originalMap, map);\n+    assertThat(map).hasSize(originalCount);\n+    assertThat(map).isEqualTo(originalMap);\n \n     Iterator<Object> it = originalMap.keySet().iterator();\n     for (int i = 0; i < originalCount - maxSize; i++) {\n       it.next();\n       it.remove();\n     }\n     segment.evictEntries(entry);\n-    assertEquals(maxSize, map.size());\n-    assertEquals(originalMap, map);\n+    assertThat(map).hasSize(maxSize);\n+    assertThat(map).isEqualTo(originalMap);\n   }\n \n   // reference queues\n@@ -2548,11 +2561,11 @@ public void testDrainKeyReferenceQueueOnWrite() {\n         reference.enqueue();\n \n         map.put(keyTwo, valueTwo);\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(1, map.size());\n-        assertNull(segment.keyReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).hasSize(1);\n+        assertThat(segment.keyReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2578,11 +2591,11 @@ public void testDrainValueReferenceQueueOnWrite() {\n         reference.enqueue();\n \n         map.put(keyTwo, valueTwo);\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(1, map.size());\n-        assertNull(segment.valueReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).hasSize(1);\n+        assertThat(segment.valueReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2608,11 +2621,11 @@ public void testDrainKeyReferenceQueueOnRead() {\n         for (int i = 0; i < SMALL_MAX_SIZE; i++) {\n           map.get(keyTwo);\n         }\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(0, map.size());\n-        assertNull(segment.keyReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).isEmpty();\n+        assertThat(segment.keyReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2639,11 +2652,11 @@ public void testDrainValueReferenceQueueOnRead() {\n         for (int i = 0; i < SMALL_MAX_SIZE; i++) {\n           map.get(keyTwo);\n         }\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(0, map.size());\n-        assertNull(segment.valueReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).isEmpty();\n+        assertThat(segment.valueReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2676,42 +2689,45 @@ public void testSerializationProxyLoading() {\n                 .build(loader);\n     // add a non-serializable entry\n     one.getUnchecked(new Object());\n-    assertEquals(1, one.size());\n-    assertFalse(one.asMap().isEmpty());\n+    assertThat(one.size()).isEqualTo(1);\n+    assertThat(one.asMap().isEmpty()).isFalse();\n     LocalLoadingCache<Object, Object> two = SerializableTester.reserialize(one);\n-    assertEquals(0, two.size());\n-    assertTrue(two.asMap().isEmpty());\n+    assertThat(two.size()).isEqualTo(0);\n+    assertThat(two.asMap().isEmpty()).isTrue();\n \n     LocalCache<Object, Object> localCacheOne = one.localCache;\n     LocalCache<Object, Object> localCacheTwo = two.localCache;\n \n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.maxWeight, localCacheTwo.maxWeight);\n-    assertEquals(localCacheOne.weigher, localCacheTwo.weigher);\n-    assertEquals(localCacheOne.expireAfterAccessNanos, localCacheTwo.expireAfterAccessNanos);\n-    assertEquals(localCacheOne.expireAfterWriteNanos, localCacheTwo.expireAfterWriteNanos);\n-    assertEquals(localCacheOne.refreshNanos, localCacheTwo.refreshNanos);\n-    assertEquals(localCacheOne.removalListener, localCacheTwo.removalListener);\n-    assertEquals(localCacheOne.ticker, localCacheTwo.ticker);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.maxWeight).isEqualTo(localCacheOne.maxWeight);\n+    assertThat(localCacheTwo.weigher).isEqualTo(localCacheOne.weigher);\n+    assertThat(localCacheTwo.expireAfterAccessNanos)\n+        .isEqualTo(localCacheOne.expireAfterAccessNanos);\n+    assertThat(localCacheTwo.expireAfterWriteNanos).isEqualTo(localCacheOne.expireAfterWriteNanos);\n+    assertThat(localCacheTwo.refreshNanos).isEqualTo(localCacheOne.refreshNanos);\n+    assertThat(localCacheTwo.removalListener).isEqualTo(localCacheOne.removalListener);\n+    assertThat(localCacheTwo.ticker).isEqualTo(localCacheOne.ticker);\n \n     // serialize the reconstituted version to be sure we haven't lost the ability to reserialize\n     LocalLoadingCache<Object, Object> three = SerializableTester.reserialize(two);\n     LocalCache<Object, Object> localCacheThree = three.localCache;\n \n-    assertEquals(localCacheTwo.defaultLoader, localCacheThree.defaultLoader);\n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.maxWeight, localCacheThree.maxWeight);\n-    assertEquals(localCacheTwo.weigher, localCacheThree.weigher);\n-    assertEquals(localCacheTwo.expireAfterAccessNanos, localCacheThree.expireAfterAccessNanos);\n-    assertEquals(localCacheTwo.expireAfterWriteNanos, localCacheThree.expireAfterWriteNanos);\n-    assertEquals(localCacheTwo.removalListener, localCacheThree.removalListener);\n-    assertEquals(localCacheTwo.ticker, localCacheThree.ticker);\n+    assertThat(localCacheThree.defaultLoader).isEqualTo(localCacheTwo.defaultLoader);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.maxWeight).isEqualTo(localCacheTwo.maxWeight);\n+    assertThat(localCacheThree.weigher).isEqualTo(localCacheTwo.weigher);\n+    assertThat(localCacheThree.expireAfterAccessNanos)\n+        .isEqualTo(localCacheTwo.expireAfterAccessNanos);\n+    assertThat(localCacheThree.expireAfterWriteNanos)\n+        .isEqualTo(localCacheTwo.expireAfterWriteNanos);\n+    assertThat(localCacheThree.removalListener).isEqualTo(localCacheTwo.removalListener);\n+    assertThat(localCacheThree.ticker).isEqualTo(localCacheTwo.ticker);\n   }\n \n   public void testSerializationProxyManual() {\n@@ -2733,57 +2749,60 @@ public void testSerializationProxyManual() {\n                 .build();\n     // add a non-serializable entry\n     one.put(new Object(), new Object());\n-    assertEquals(1, one.size());\n-    assertFalse(one.asMap().isEmpty());\n+    assertThat(one.size()).isEqualTo(1);\n+    assertThat(one.asMap().isEmpty()).isFalse();\n     LocalManualCache<Object, Object> two = SerializableTester.reserialize(one);\n-    assertEquals(0, two.size());\n-    assertTrue(two.asMap().isEmpty());\n+    assertThat(two.size()).isEqualTo(0);\n+    assertThat(two.asMap().isEmpty()).isTrue();\n \n     LocalCache<Object, Object> localCacheOne = one.localCache;\n     LocalCache<Object, Object> localCacheTwo = two.localCache;\n \n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.maxWeight, localCacheTwo.maxWeight);\n-    assertEquals(localCacheOne.weigher, localCacheTwo.weigher);\n-    assertEquals(localCacheOne.expireAfterAccessNanos, localCacheTwo.expireAfterAccessNanos);\n-    assertEquals(localCacheOne.expireAfterWriteNanos, localCacheTwo.expireAfterWriteNanos);\n-    assertEquals(localCacheOne.removalListener, localCacheTwo.removalListener);\n-    assertEquals(localCacheOne.ticker, localCacheTwo.ticker);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.maxWeight).isEqualTo(localCacheOne.maxWeight);\n+    assertThat(localCacheTwo.weigher).isEqualTo(localCacheOne.weigher);\n+    assertThat(localCacheTwo.expireAfterAccessNanos)\n+        .isEqualTo(localCacheOne.expireAfterAccessNanos);\n+    assertThat(localCacheTwo.expireAfterWriteNanos).isEqualTo(localCacheOne.expireAfterWriteNanos);\n+    assertThat(localCacheTwo.removalListener).isEqualTo(localCacheOne.removalListener);\n+    assertThat(localCacheTwo.ticker).isEqualTo(localCacheOne.ticker);\n \n     // serialize the reconstituted version to be sure we haven't lost the ability to reserialize\n     LocalManualCache<Object, Object> three = SerializableTester.reserialize(two);\n     LocalCache<Object, Object> localCacheThree = three.localCache;\n \n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.maxWeight, localCacheThree.maxWeight);\n-    assertEquals(localCacheTwo.weigher, localCacheThree.weigher);\n-    assertEquals(localCacheTwo.expireAfterAccessNanos, localCacheThree.expireAfterAccessNanos);\n-    assertEquals(localCacheTwo.expireAfterWriteNanos, localCacheThree.expireAfterWriteNanos);\n-    assertEquals(localCacheTwo.removalListener, localCacheThree.removalListener);\n-    assertEquals(localCacheTwo.ticker, localCacheThree.ticker);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.maxWeight).isEqualTo(localCacheTwo.maxWeight);\n+    assertThat(localCacheThree.weigher).isEqualTo(localCacheTwo.weigher);\n+    assertThat(localCacheThree.expireAfterAccessNanos)\n+        .isEqualTo(localCacheTwo.expireAfterAccessNanos);\n+    assertThat(localCacheThree.expireAfterWriteNanos)\n+        .isEqualTo(localCacheTwo.expireAfterWriteNanos);\n+    assertThat(localCacheThree.removalListener).isEqualTo(localCacheTwo.removalListener);\n+    assertThat(localCacheThree.ticker).isEqualTo(localCacheTwo.ticker);\n   }\n \n   public void testLoadDifferentKeyInLoader() throws ExecutionException, InterruptedException {\n     LocalCache<String, String> cache = makeLocalCache(createCacheBuilder());\n     String key1 = \"key1\";\n     String key2 = \"key2\";\n \n-    assertEquals(\n-        key2,\n-        cache.get(\n-            key1,\n-            new CacheLoader<String, String>() {\n-              @Override\n-              public String load(String key) throws Exception {\n-                return cache.get(key2, identityLoader()); // loads a different key, should work\n-              }\n-            }));\n+    assertThat(\n+            cache.get(\n+                key1,\n+                new CacheLoader<String, String>() {\n+                  @Override\n+                  public String load(String key) throws Exception {\n+                    return cache.get(key2, identityLoader()); // loads a different key, should work\n+                  }\n+                }))\n+        .isEqualTo(key2);\n   }\n \n   public void testRecursiveLoad() throws InterruptedException {"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java",
      "status": "modified",
      "additions": 92,
      "deletions": 92,
      "changes": 184,
      "patch": "@@ -62,7 +62,7 @@ public Object load(Object from) {\n           }\n         };\n     LocalLoadingCache<Object, Object> cache = makeCache(createCacheBuilder(), loader);\n-    assertSame(loader, cache.localCache.defaultLoader);\n+    assertThat(cache.localCache.defaultLoader).isSameInstanceAs(loader);\n   }\n \n   // null parameters test\n@@ -78,82 +78,82 @@ public void testNullParameters() throws Exception {\n   public void testStats() {\n     CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1).maximumSize(2);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     cache.getUnchecked(one);\n     CacheStats stats = cache.stats();\n-    assertEquals(1, stats.requestCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n     assertThat(stats.hitRate()).isEqualTo(0.0);\n-    assertEquals(1, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n     assertThat(stats.missRate()).isEqualTo(1.0);\n-    assertEquals(1, stats.loadCount());\n+    assertThat(stats.loadCount()).isEqualTo(1);\n     long totalLoadTime = stats.totalLoadTime();\n-    assertTrue(totalLoadTime >= 0);\n-    assertTrue(stats.averageLoadPenalty() >= 0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(totalLoadTime).isAtLeast(0);\n+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n \n     cache.getUnchecked(one);\n     stats = cache.stats();\n-    assertEquals(2, stats.requestCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n     assertThat(stats.hitRate()).isEqualTo(1.0 / 2);\n-    assertEquals(1, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n     assertThat(stats.missRate()).isEqualTo(1.0 / 2);\n-    assertEquals(1, stats.loadCount());\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.loadCount()).isEqualTo(1);\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n \n     Object two = new Object();\n     cache.getUnchecked(two);\n     stats = cache.stats();\n-    assertEquals(3, stats.requestCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n     assertThat(stats.hitRate()).isEqualTo(1.0 / 3);\n-    assertEquals(2, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n     assertThat(stats.missRate()).isEqualTo(2.0 / 3);\n-    assertEquals(2, stats.loadCount());\n-    assertTrue(stats.totalLoadTime() >= totalLoadTime);\n+    assertThat(stats.loadCount()).isEqualTo(2);\n+    assertThat(stats.totalLoadTime()).isAtLeast(totalLoadTime);\n     totalLoadTime = stats.totalLoadTime();\n-    assertTrue(stats.averageLoadPenalty() >= 0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n \n     Object three = new Object();\n     cache.getUnchecked(three);\n     stats = cache.stats();\n-    assertEquals(4, stats.requestCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n     assertThat(stats.hitRate()).isEqualTo(1.0 / 4);\n-    assertEquals(3, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n     assertThat(stats.missRate()).isEqualTo(3.0 / 4);\n-    assertEquals(3, stats.loadCount());\n-    assertTrue(stats.totalLoadTime() >= totalLoadTime);\n-    assertTrue(stats.averageLoadPenalty() >= 0.0);\n-    assertEquals(1, stats.evictionCount());\n+    assertThat(stats.loadCount()).isEqualTo(3);\n+    assertThat(stats.totalLoadTime()).isAtLeast(totalLoadTime);\n+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);\n+    assertThat(stats.evictionCount()).isEqualTo(1);\n   }\n \n   public void testStatsNoops() {\n     CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n     ConcurrentMap<Object, Object> map = cache.localCache; // modifiable map view\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     assertNull(map.put(one, one));\n-    assertSame(one, map.get(one));\n-    assertTrue(map.containsKey(one));\n-    assertTrue(map.containsValue(one));\n+    assertThat(map.get(one)).isSameInstanceAs(one);\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map.containsValue(one)).isTrue();\n     Object two = new Object();\n-    assertSame(one, map.replace(one, two));\n-    assertTrue(map.containsKey(one));\n-    assertFalse(map.containsValue(one));\n+    assertThat(map.replace(one, two)).isSameInstanceAs(one);\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map.containsValue(one)).isFalse();\n     Object three = new Object();\n-    assertTrue(map.replace(one, two, three));\n-    assertTrue(map.remove(one, three));\n-    assertFalse(map.containsKey(one));\n-    assertFalse(map.containsValue(one));\n+    assertThat(map.replace(one, two, three)).isTrue();\n+    assertThat(map.remove(one, three)).isTrue();\n+    assertThat(map.containsKey(one)).isFalse();\n+    assertThat(map.containsValue(one)).isFalse();\n     assertNull(map.putIfAbsent(two, three));\n-    assertSame(three, map.remove(two));\n+    assertThat(map.remove(two)).isSameInstanceAs(three);\n     assertNull(map.put(three, one));\n     assertNull(map.put(one, two));\n \n@@ -171,112 +171,112 @@ public void testStatsNoops() {\n \n     map.clear();\n \n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n   }\n \n   public void testNoStats() {\n     CacheBuilder<Object, Object> builder =\n         CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(2);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     cache.getUnchecked(one);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     cache.getUnchecked(one);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object two = new Object();\n     cache.getUnchecked(two);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object three = new Object();\n     cache.getUnchecked(three);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n   }\n \n   public void testRecordStats() {\n     CacheBuilder<Object, Object> builder =\n         createCacheBuilder().recordStats().concurrencyLevel(1).maximumSize(2);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(0, cache.stats().hitCount());\n-    assertEquals(0, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(0);\n+    assertThat(cache.stats().missCount()).isEqualTo(0);\n \n     Object one = new Object();\n     cache.getUnchecked(one);\n-    assertEquals(0, cache.stats().hitCount());\n-    assertEquals(1, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(0);\n+    assertThat(cache.stats().missCount()).isEqualTo(1);\n \n     cache.getUnchecked(one);\n-    assertEquals(1, cache.stats().hitCount());\n-    assertEquals(1, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(1);\n+    assertThat(cache.stats().missCount()).isEqualTo(1);\n \n     Object two = new Object();\n     cache.getUnchecked(two);\n-    assertEquals(1, cache.stats().hitCount());\n-    assertEquals(2, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(1);\n+    assertThat(cache.stats().missCount()).isEqualTo(2);\n \n     Object three = new Object();\n     cache.getUnchecked(three);\n-    assertEquals(1, cache.stats().hitCount());\n-    assertEquals(3, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(1);\n+    assertThat(cache.stats().missCount()).isEqualTo(3);\n   }\n \n   // asMap tests\n \n   public void testAsMap() {\n     CacheBuilder<Object, Object> builder = createCacheBuilder();\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     Object two = new Object();\n     Object three = new Object();\n \n     ConcurrentMap<Object, Object> map = cache.asMap();\n     assertNull(map.put(one, two));\n-    assertSame(two, map.get(one));\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n     map.putAll(ImmutableMap.of(two, three));\n-    assertSame(three, map.get(two));\n-    assertSame(two, map.putIfAbsent(one, three));\n-    assertSame(two, map.get(one));\n+    assertThat(map.get(two)).isSameInstanceAs(three);\n+    assertThat(map.putIfAbsent(one, three)).isSameInstanceAs(two);\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n     assertNull(map.putIfAbsent(three, one));\n-    assertSame(one, map.get(three));\n-    assertSame(two, map.replace(one, three));\n-    assertSame(three, map.get(one));\n-    assertFalse(map.replace(one, two, three));\n-    assertSame(three, map.get(one));\n-    assertTrue(map.replace(one, three, two));\n-    assertSame(two, map.get(one));\n-    assertEquals(3, map.size());\n+    assertThat(map.get(three)).isSameInstanceAs(one);\n+    assertThat(map.replace(one, three)).isSameInstanceAs(two);\n+    assertThat(map.get(one)).isSameInstanceAs(three);\n+    assertThat(map.replace(one, two, three)).isFalse();\n+    assertThat(map.get(one)).isSameInstanceAs(three);\n+    assertThat(map.replace(one, three, two)).isTrue();\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n+    assertThat(map).hasSize(3);\n \n     map.clear();\n-    assertTrue(map.isEmpty());\n-    assertEquals(0, map.size());\n+    assertThat(map.isEmpty()).isTrue();\n+    assertThat(map).isEmpty();\n \n     cache.getUnchecked(one);\n-    assertEquals(1, map.size());\n-    assertSame(one, map.get(one));\n-    assertTrue(map.containsKey(one));\n-    assertTrue(map.containsValue(one));\n-    assertSame(one, map.remove(one));\n-    assertEquals(0, map.size());\n+    assertThat(map).hasSize(1);\n+    assertThat(map.get(one)).isSameInstanceAs(one);\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map.containsValue(one)).isTrue();\n+    assertThat(map.remove(one)).isSameInstanceAs(one);\n+    assertThat(map).isEmpty();\n \n     cache.getUnchecked(one);\n-    assertEquals(1, map.size());\n-    assertFalse(map.remove(one, two));\n-    assertTrue(map.remove(one, one));\n-    assertEquals(0, map.size());\n+    assertThat(map).hasSize(1);\n+    assertThat(map.remove(one, two)).isFalse();\n+    assertThat(map.remove(one, one)).isTrue();\n+    assertThat(map).isEmpty();\n \n     cache.getUnchecked(one);\n     Map<Object, Object> newMap = ImmutableMap.of(one, one);\n-    assertEquals(newMap, map);\n-    assertEquals(newMap.entrySet(), map.entrySet());\n-    assertEquals(newMap.keySet(), map.keySet());\n+    assertThat(map).isEqualTo(newMap);\n+    assertThat(map.entrySet()).isEqualTo(newMap.entrySet());\n+    assertThat(map.keySet()).isEqualTo(newMap.keySet());\n     Set<Object> expectedValues = ImmutableSet.of(one);\n     Set<Object> actualValues = ImmutableSet.copyOf(map.values());\n-    assertEquals(expectedValues, actualValues);\n+    assertThat(actualValues).isEqualTo(expectedValues);\n   }\n \n   /** Lookups on the map view shouldn't impact the recency queue. */\n@@ -288,12 +288,12 @@ public void testAsMapRecency() {\n     ConcurrentMap<Object, Object> map = cache.asMap();\n \n     Object one = new Object();\n-    assertSame(one, cache.getUnchecked(one));\n-    assertTrue(segment.recencyQueue.isEmpty());\n-    assertSame(one, map.get(one));\n-    assertSame(one, segment.recencyQueue.peek().getKey());\n-    assertSame(one, cache.getUnchecked(one));\n-    assertFalse(segment.recencyQueue.isEmpty());\n+    assertThat(cache.getUnchecked(one)).isSameInstanceAs(one);\n+    assertThat(segment.recencyQueue.isEmpty()).isTrue();\n+    assertThat(map.get(one)).isSameInstanceAs(one);\n+    assertThat(segment.recencyQueue.peek().getKey()).isSameInstanceAs(one);\n+    assertThat(cache.getUnchecked(one)).isSameInstanceAs(one);\n+    assertThat(segment.recencyQueue.isEmpty()).isFalse();\n   }\n \n   public void testRecursiveComputation() throws InterruptedException {\n@@ -313,7 +313,7 @@ public String load(Integer key) {\n     LoadingCache<Integer, String> recursiveCache =\n         CacheBuilder.newBuilder().weakKeys().weakValues().build(recursiveLoader);\n     cacheRef.set(recursiveCache);\n-    assertEquals(\"3, 2, 1, 0\", recursiveCache.getUnchecked(3));\n+    assertThat(recursiveCache.getUnchecked(3)).isEqualTo(\"3, 2, 1, 0\");\n \n     recursiveLoader =\n         new CacheLoader<Integer, String>() {"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/NullCacheTest.java",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "patch": "@@ -51,12 +51,12 @@ public void testGet() {\n             .build(constantLoader(computed));\n \n     Object key = new Object();\n-    assertSame(computed, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(computed, notification.getValue());\n-    assertSame(RemovalCause.SIZE, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(computed);\n+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -69,12 +69,12 @@ public void testGet_expireAfterWrite() {\n             .build(constantLoader(computed));\n \n     Object key = new Object();\n-    assertSame(computed, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(computed, notification.getValue());\n-    assertSame(RemovalCause.SIZE, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(computed);\n+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -87,12 +87,12 @@ public void testGet_expireAfterAccess() {\n             .build(constantLoader(computed));\n \n     Object key = new Object();\n-    assertSame(computed, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(computed, notification.getValue());\n-    assertSame(RemovalCause.SIZE, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(computed);\n+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -105,7 +105,7 @@ public void testGet_computeNull() {\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(new Object()));\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -120,7 +120,7 @@ public void testGet_runtimeException() {\n     UncheckedExecutionException uee =\n         assertThrows(UncheckedExecutionException.class, () -> map.getUnchecked(new Object()));\n     assertThat(uee).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(map);\n   }\n }"
    },
    {
      "filename": "guava-tests/test/com/google/common/cache/PopulatedCachesTest.java",
      "status": "modified",
      "additions": 60,
      "deletions": 57,
      "changes": 117,
      "patch": "@@ -59,7 +59,7 @@ public void testSize_populated() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       // don't let the entries get GCed\n       List<Entry<Object, Object>> unused = warmUp(cache);\n-      assertEquals(WARMUP_SIZE, cache.size());\n+      assertThat(cache.size()).isEqualTo(WARMUP_SIZE);\n       assertMapSize(cache.asMap(), WARMUP_SIZE);\n       checkValidState(cache);\n     }\n@@ -71,12 +71,12 @@ public void testContainsKey_found() {\n       List<Entry<Object, Object>> warmed = warmUp(cache);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n-        assertTrue(cache.asMap().containsKey(entry.getKey()));\n-        assertTrue(cache.asMap().containsValue(entry.getValue()));\n+        assertThat(cache.asMap().containsKey(entry.getKey())).isTrue();\n+        assertThat(cache.asMap().containsValue(entry.getValue())).isTrue();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -88,18 +88,18 @@ public void testPut_populated() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object newValue = new Object();\n-        assertSame(entry.getValue(), cache.asMap().put(entry.getKey(), newValue));\n+        assertThat(cache.asMap().put(entry.getKey(), newValue)).isSameInstanceAs(entry.getValue());\n         // don't let the new entry get GCed\n         warmed.add(entryOf(entry.getKey(), newValue));\n         Object newKey = new Object();\n-        assertNull(cache.asMap().put(newKey, entry.getValue()));\n+        assertThat(cache.asMap().put(newKey, entry.getValue())).isNull();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(newValue, cache.getUnchecked(entry.getKey()));\n-        assertEquals(entry.getValue(), cache.getUnchecked(newKey));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(newValue);\n+        assertThat(cache.getUnchecked(newKey)).isEqualTo(entry.getValue());\n         // don't let the new entry get GCed\n         warmed.add(entryOf(newKey, entry.getValue()));\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -111,16 +111,17 @@ public void testPutIfAbsent_populated() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object newValue = new Object();\n-        assertSame(entry.getValue(), cache.asMap().putIfAbsent(entry.getKey(), newValue));\n+        assertThat(cache.asMap().putIfAbsent(entry.getKey(), newValue))\n+            .isSameInstanceAs(entry.getValue());\n         Object newKey = new Object();\n-        assertNull(cache.asMap().putIfAbsent(newKey, entry.getValue()));\n+        assertThat(cache.asMap().putIfAbsent(newKey, entry.getValue())).isNull();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));\n-        assertEquals(entry.getValue(), cache.getUnchecked(newKey));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());\n+        assertThat(cache.getUnchecked(newKey)).isEqualTo(entry.getValue());\n         // don't let the new entry get GCed\n         warmed.add(entryOf(newKey, entry.getValue()));\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -133,8 +134,8 @@ public void testPutAll_populated() {\n       Object newValue = new Object();\n       cache.asMap().putAll(ImmutableMap.of(newKey, newValue));\n       // this getUnchecked() call shouldn't be a cache miss; verified below\n-      assertEquals(newValue, cache.getUnchecked(newKey));\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.getUnchecked(newKey)).isEqualTo(newValue);\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -146,16 +147,17 @@ public void testReplace_populated() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object newValue = new Object();\n-        assertSame(entry.getValue(), cache.asMap().replace(entry.getKey(), newValue));\n-        assertTrue(cache.asMap().replace(entry.getKey(), newValue, entry.getValue()));\n+        assertThat(cache.asMap().replace(entry.getKey(), newValue))\n+            .isSameInstanceAs(entry.getValue());\n+        assertThat(cache.asMap().replace(entry.getKey(), newValue, entry.getValue())).isTrue();\n         Object newKey = new Object();\n-        assertNull(cache.asMap().replace(newKey, entry.getValue()));\n-        assertFalse(cache.asMap().replace(newKey, entry.getValue(), newValue));\n+        assertThat(cache.asMap().replace(newKey, entry.getValue())).isNull();\n+        assertThat(cache.asMap().replace(newKey, entry.getValue(), newValue)).isFalse();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));\n-        assertFalse(cache.asMap().containsKey(newKey));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());\n+        assertThat(cache.asMap().containsKey(newKey)).isFalse();\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -167,9 +169,9 @@ public void testRemove_byKey() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object key = entry.getKey();\n-        assertEquals(entry.getValue(), cache.asMap().remove(key));\n-        assertNull(cache.asMap().remove(key));\n-        assertFalse(cache.asMap().containsKey(key));\n+        assertThat(cache.asMap().remove(key)).isEqualTo(entry.getValue());\n+        assertThat(cache.asMap().remove(key)).isNull();\n+        assertThat(cache.asMap().containsKey(key)).isFalse();\n       }\n       checkEmpty(cache);\n     }\n@@ -182,10 +184,10 @@ public void testRemove_byKeyAndValue() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Object key = warmed.get(i - WARMUP_MIN).getKey();\n         Object value = warmed.get(i - WARMUP_MIN).getValue();\n-        assertFalse(cache.asMap().remove(key, -1));\n-        assertTrue(cache.asMap().remove(key, value));\n-        assertFalse(cache.asMap().remove(key, -1));\n-        assertFalse(cache.asMap().containsKey(key));\n+        assertThat(cache.asMap().remove(key, -1)).isFalse();\n+        assertThat(cache.asMap().remove(key, value)).isTrue();\n+        assertThat(cache.asMap().remove(key, -1)).isFalse();\n+        assertThat(cache.asMap().containsKey(key)).isFalse();\n       }\n       checkEmpty(cache);\n     }\n@@ -206,13 +208,13 @@ public void testKeySet_populated() {\n           .addEqualityGroup(cache.asMap().keySet(), keys)\n           .addEqualityGroup(ImmutableSet.of())\n           .testEquals();\n-      assertEquals(WARMUP_SIZE, keys.size());\n+      assertThat(keys).hasSize(WARMUP_SIZE);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Object key = warmed.get(i - WARMUP_MIN).getKey();\n-        assertTrue(keys.contains(key));\n-        assertTrue(keys.remove(key));\n-        assertFalse(keys.remove(key));\n-        assertFalse(keys.contains(key));\n+        assertThat(keys.contains(key)).isTrue();\n+        assertThat(keys.remove(key)).isTrue();\n+        assertThat(keys.remove(key)).isFalse();\n+        assertThat(keys.contains(key)).isFalse();\n       }\n       checkEmpty(keys);\n       checkEmpty(cache);\n@@ -229,13 +231,13 @@ public void testValues_populated() {\n       assertThat(values.toArray()).asList().containsExactlyElementsIn(expected);\n       assertThat(values.toArray(new Object[0])).asList().containsExactlyElementsIn(expected);\n \n-      assertEquals(WARMUP_SIZE, values.size());\n+      assertThat(values).hasSize(WARMUP_SIZE);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Object value = warmed.get(i - WARMUP_MIN).getValue();\n-        assertTrue(values.contains(value));\n-        assertTrue(values.remove(value));\n-        assertFalse(values.remove(value));\n-        assertFalse(values.contains(value));\n+        assertThat(values.contains(value)).isTrue();\n+        assertThat(values.remove(value)).isTrue();\n+        assertThat(values.remove(value)).isFalse();\n+        assertThat(values.contains(value)).isFalse();\n       }\n       checkEmpty(values);\n       checkEmpty(cache);\n@@ -257,13 +259,13 @@ public void testEntrySet_populated() {\n           .addEqualityGroup(cache.asMap().entrySet(), entries)\n           .addEqualityGroup(ImmutableSet.of())\n           .testEquals();\n-      assertEquals(WARMUP_SIZE, entries.size());\n+      assertThat(entries).hasSize(WARMUP_SIZE);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> newEntry = warmed.get(i - WARMUP_MIN);\n-        assertTrue(entries.contains(newEntry));\n-        assertTrue(entries.remove(newEntry));\n-        assertFalse(entries.remove(newEntry));\n-        assertFalse(entries.contains(newEntry));\n+        assertThat(entries.contains(newEntry)).isTrue();\n+        assertThat(entries.remove(newEntry)).isTrue();\n+        assertThat(entries.remove(newEntry)).isFalse();\n+        assertThat(entries.contains(newEntry)).isFalse();\n       }\n       checkEmpty(entries);\n       checkEmpty(cache);\n@@ -276,11 +278,11 @@ public void testWriteThroughEntry() {\n       Entry<Object, Object> entry = Iterables.getOnlyElement(cache.asMap().entrySet());\n \n       cache.invalidate(1);\n-      assertEquals(0, cache.size());\n+      assertThat(cache.size()).isEqualTo(0);\n \n       entry.setValue(3);\n-      assertEquals(1, cache.size());\n-      assertEquals(3, cache.getIfPresent(1));\n+      assertThat(cache.size()).isEqualTo(1);\n+      assertThat(cache.getIfPresent(1)).isEqualTo(3);\n       checkValidState(cache);\n \n       assertThrows(NullPointerException.class, () -> entry.setValue(null));\n@@ -356,25 +358,26 @@ private Entry<Object, Object> entryOf(Object key, Object value) {\n   }\n \n   private void assertMapSize(Map<?, ?> map, int size) {\n-    assertEquals(size, map.size());\n+    assertThat(map).hasSize(size);\n     if (size > 0) {\n-      assertFalse(map.isEmpty());\n+      assertThat(map.isEmpty()).isFalse();\n     } else {\n-      assertTrue(map.isEmpty());\n+      assertThat(map.isEmpty()).isTrue();\n     }\n     assertCollectionSize(map.keySet(), size);\n     assertCollectionSize(map.entrySet(), size);\n     assertCollectionSize(map.values(), size);\n   }\n \n+  @SuppressWarnings(\"IterablesSizeOfCollection\") // we are testing our iterator implementation\n   private void assertCollectionSize(Collection<?> collection, int size) {\n-    assertEquals(size, collection.size());\n+    assertThat(collection.size()).isEqualTo(size);\n     if (size > 0) {\n-      assertFalse(collection.isEmpty());\n+      assertThat(collection.isEmpty()).isFalse();\n     } else {\n-      assertTrue(collection.isEmpty());\n+      assertThat(collection.isEmpty()).isTrue();\n     }\n-    assertEquals(size, Iterables.size(collection));\n-    assertEquals(size, Iterators.size(collection.iterator()));\n+    assertThat(Iterables.size(collection)).isEqualTo(size);\n+    assertThat(Iterators.size(collection.iterator())).isEqualTo(size);\n   }\n }"
    }
  ],
  "diff": "diff --git a/android/guava-tests/test/com/google/common/cache/AbstractCacheTest.java b/android/guava-tests/test/com/google/common/cache/AbstractCacheTest.java\nindex f803fccedfe7..6a1fc772cf57 100644\n--- a/android/guava-tests/test/com/google/common/cache/AbstractCacheTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/AbstractCacheTest.java\n@@ -21,7 +21,6 @@\n import com.google.common.cache.AbstractCache.SimpleStatsCounter;\n import com.google.common.cache.AbstractCache.StatsCounter;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -47,11 +46,11 @@ public void testGetIfPresent() {\n           }\n         };\n \n-    assertNull(cache.getIfPresent(new Object()));\n+    assertThat(cache.getIfPresent(new Object())).isNull();\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getIfPresent(new Object()));\n+    assertThat(cache.getIfPresent(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetAllPresent_empty() {\n@@ -63,7 +62,7 @@ public void testGetAllPresent_empty() {\n           }\n         };\n \n-    assertEquals(ImmutableMap.of(), cache.getAllPresent(ImmutableList.of(new Object())));\n+    assertThat(cache.getAllPresent(ImmutableList.of(new Object()))).isEmpty();\n   }\n \n   public void testGetAllPresent_cached() {\n@@ -77,9 +76,8 @@ public void testGetAllPresent_cached() {\n           }\n         };\n \n-    assertEquals(\n-        ImmutableMap.of(cachedKey, cachedValue),\n-        cache.getAllPresent(ImmutableList.of(cachedKey, new Object())));\n+    assertThat(cache.getAllPresent(ImmutableList.of(cachedKey, new Object())))\n+        .containsExactly(cachedKey, cachedValue);\n   }\n \n   public void testInvalidateAll() {\n@@ -99,23 +97,23 @@ public void invalidate(Object key) {\n \n     List<Integer> toInvalidate = ImmutableList.of(1, 2, 3, 4);\n     cache.invalidateAll(toInvalidate);\n-    assertEquals(toInvalidate, invalidated);\n+    assertThat(invalidated).isEqualTo(toInvalidate);\n   }\n \n   public void testEmptySimpleStats() {\n     StatsCounter counter = new SimpleStatsCounter();\n     CacheStats stats = counter.snapshot();\n-    assertEquals(0, stats.requestCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n     assertThat(stats.hitRate()).isEqualTo(1.0);\n-    assertEquals(0, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n     assertThat(stats.missRate()).isEqualTo(0.0);\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.loadCount());\n-    assertEquals(0, stats.totalLoadTime());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.loadCount()).isEqualTo(0);\n+    assertThat(stats.totalLoadTime()).isEqualTo(0);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n   }\n \n   public void testSingleSimpleStats() {\n@@ -137,18 +135,18 @@ public void testSingleSimpleStats() {\n     }\n     CacheStats stats = counter.snapshot();\n     int requestCount = 11 + 23;\n-    assertEquals(requestCount, stats.requestCount());\n-    assertEquals(11, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(requestCount);\n+    assertThat(stats.hitCount()).isEqualTo(11);\n     assertThat(stats.hitRate()).isEqualTo(11.0 / requestCount);\n     int missCount = 23;\n-    assertEquals(missCount, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(missCount);\n     assertThat(stats.missRate()).isEqualTo(((double) missCount) / requestCount);\n-    assertEquals(13, stats.loadSuccessCount());\n-    assertEquals(17, stats.loadExceptionCount());\n-    assertEquals(13 + 17, stats.loadCount());\n-    assertEquals(214, stats.totalLoadTime());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(13);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(17);\n+    assertThat(stats.loadCount()).isEqualTo(13 + 17);\n+    assertThat(stats.totalLoadTime()).isEqualTo(214);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(214.0 / (13 + 17));\n-    assertEquals(27, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(27);\n   }\n \n   public void testSimpleStatsOverflow() {\n@@ -156,7 +154,7 @@ public void testSimpleStatsOverflow() {\n     counter.recordLoadSuccess(Long.MAX_VALUE);\n     counter.recordLoadSuccess(1);\n     CacheStats stats = counter.snapshot();\n-    assertEquals(Long.MAX_VALUE, stats.totalLoadTime());\n+    assertThat(stats.totalLoadTime()).isEqualTo(Long.MAX_VALUE);\n   }\n \n   public void testSimpleStatsIncrementBy() {\n@@ -201,6 +199,6 @@ public void testSimpleStatsIncrementBy() {\n     }\n \n     counter1.incrementBy(counter2);\n-    assertEquals(new CacheStats(38, 60, 44, 54, totalLoadTime, 66), counter1.snapshot());\n+    assertThat(counter1.snapshot()).isEqualTo(new CacheStats(38, 60, 44, 54, totalLoadTime, 66));\n   }\n }\ndiff --git a/android/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java b/android/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java\nindex 6548982acc49..85b37bf24ed6 100644\n--- a/android/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java\n@@ -61,7 +61,7 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetUnchecked_unchecked() {\n@@ -90,7 +90,7 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetUnchecked_error() {\n@@ -119,7 +119,7 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetUnchecked_otherThrowable() {\n@@ -148,6 +148,6 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n }\ndiff --git a/android/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java b/android/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java\nindex 20cfb8311aff..116d6e66327f 100644\n--- a/android/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java\n@@ -16,6 +16,7 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n \n import com.google.common.annotations.GwtCompatible;\n@@ -31,8 +32,11 @@\n import java.util.concurrent.Callable;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ExecutionException;\n-import junit.framework.TestCase;\n import org.jspecify.annotations.NullUnmarked;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n \n /**\n  * Test suite for {@link CacheBuilder}. TODO(cpovirk): merge into CacheBuilderTest?\n@@ -41,18 +45,18 @@\n  */\n @GwtCompatible\n @NullUnmarked\n-public class CacheBuilderGwtTest extends TestCase {\n+@RunWith(JUnit4.class)\n+public class CacheBuilderGwtTest {\n \n   private FakeTicker fakeTicker;\n \n-  @Override\n-  protected void setUp() throws Exception {\n-    super.setUp();\n-\n+  @Before\n+  public void setUp() {\n     fakeTicker = new FakeTicker();\n   }\n \n-  public void testLoader() throws ExecutionException {\n+  @Test\n+  public void loader() throws ExecutionException {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     Callable<Integer> loader =\n@@ -67,19 +71,20 @@ public Integer call() throws Exception {\n \n     cache.put(0, 10);\n \n-    assertEquals(Integer.valueOf(10), cache.get(0, loader));\n-    assertEquals(Integer.valueOf(1), cache.get(20, loader));\n-    assertEquals(Integer.valueOf(2), cache.get(34, loader));\n+    assertThat(cache.get(0, loader)).isEqualTo(10);\n+    assertThat(cache.get(20, loader)).isEqualTo(1);\n+    assertThat(cache.get(34, loader)).isEqualTo(2);\n \n     cache.invalidate(0);\n-    assertEquals(Integer.valueOf(3), cache.get(0, loader));\n+    assertThat(cache.get(0, loader)).isEqualTo(3);\n \n     cache.put(0, 10);\n     cache.invalidateAll();\n-    assertEquals(Integer.valueOf(4), cache.get(0, loader));\n+    assertThat(cache.get(0, loader)).isEqualTo(4);\n   }\n \n-  public void testSizeConstraint() {\n+  @Test\n+  public void sizeConstraint() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().maximumSize(4).build();\n \n     cache.put(1, 10);\n@@ -88,22 +93,24 @@ public void testSizeConstraint() {\n     cache.put(4, 40);\n     cache.put(5, 50);\n \n-    assertEquals(null, cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isNull();\n     // Order required to remove dependence on access order / write order constraint.\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));\n-    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(3)).isEqualTo(30);\n+    assertThat(cache.getIfPresent(4)).isEqualTo(40);\n+    assertThat(cache.getIfPresent(5)).isEqualTo(50);\n \n     cache.put(1, 10);\n-    assertEquals(Integer.valueOf(10), cache.getIfPresent(1));\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));\n-    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));\n-    assertEquals(null, cache.getIfPresent(2));\n+    assertThat(cache.getIfPresent(1)).isEqualTo(10);\n+    assertThat(cache.getIfPresent(3)).isEqualTo(30);\n+    assertThat(cache.getIfPresent(4)).isEqualTo(40);\n+    assertThat(cache.getIfPresent(5)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(2)).isNull();\n   }\n \n-  public void testLoadingCache() throws ExecutionException {\n+  @SuppressWarnings({\"deprecation\", \"LoadingCacheApply\"})\n+  @Test\n+  public void loadingCache() throws ExecutionException {\n     CacheLoader<Integer, Integer> loader =\n         new CacheLoader<Integer, Integer>() {\n           int i = 0;\n@@ -120,17 +127,18 @@ public Integer load(Integer key) throws Exception {\n \n     Map<Integer, Integer> map = cache.getAll(ImmutableList.of(10, 20, 30, 54, 443, 1));\n \n-    assertEquals(Integer.valueOf(20), map.get(10));\n-    assertEquals(Integer.valueOf(0), map.get(20));\n-    assertEquals(Integer.valueOf(1), map.get(30));\n-    assertEquals(Integer.valueOf(2), map.get(54));\n-    assertEquals(Integer.valueOf(3), map.get(443));\n-    assertEquals(Integer.valueOf(4), map.get(1));\n-    assertEquals(Integer.valueOf(5), cache.get(6));\n-    assertEquals(Integer.valueOf(6), cache.apply(7));\n+    assertThat(map).containsEntry(10, 20);\n+    assertThat(map).containsEntry(20, 0);\n+    assertThat(map).containsEntry(30, 1);\n+    assertThat(map).containsEntry(54, 2);\n+    assertThat(map).containsEntry(443, 3);\n+    assertThat(map).containsEntry(1, 4);\n+    assertThat(cache.get(6)).isEqualTo(5);\n+    assertThat(cache.apply(7)).isEqualTo(6);\n   }\n \n-  public void testExpireAfterAccess() {\n+  @Test\n+  public void expireAfterAccess() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterAccess(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -138,14 +146,15 @@ public void testExpireAfterAccess() {\n     cache.put(2, 30);\n \n     fakeTicker.advance(999, MILLISECONDS);\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(30);\n     fakeTicker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(30);\n     fakeTicker.advance(1000, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(0));\n+    assertThat(cache.getIfPresent(0)).isNull();\n   }\n \n-  public void testExpireAfterWrite() {\n+  @Test\n+  public void expireAfterWrite() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -154,23 +163,24 @@ public void testExpireAfterWrite() {\n     cache.put(4, 2);\n \n     fakeTicker.advance(999, MILLISECONDS);\n-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));\n-    assertEquals(Integer.valueOf(2), cache.getIfPresent(4));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(100);\n+    assertThat(cache.getIfPresent(20)).isEqualTo(200);\n+    assertThat(cache.getIfPresent(4)).isEqualTo(2);\n \n     fakeTicker.advance(2, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n-    assertEquals(null, cache.getIfPresent(20));\n-    assertEquals(null, cache.getIfPresent(4));\n+    assertThat(cache.getIfPresent(10)).isNull();\n+    assertThat(cache.getIfPresent(20)).isNull();\n+    assertThat(cache.getIfPresent(4)).isNull();\n \n     cache.put(10, 20);\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(20);\n \n     fakeTicker.advance(1000, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isNull();\n   }\n \n-  public void testExpireAfterWriteAndAccess() {\n+  @Test\n+  public void expireAfterWriteAndAccess() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder()\n             .expireAfterWrite(1000, MILLISECONDS)\n@@ -183,26 +193,28 @@ public void testExpireAfterWriteAndAccess() {\n     cache.put(4, 2);\n \n     fakeTicker.advance(499, MILLISECONDS);\n-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(100);\n+    assertThat(cache.getIfPresent(20)).isEqualTo(200);\n \n     fakeTicker.advance(2, MILLISECONDS);\n-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));\n-    assertEquals(null, cache.getIfPresent(4));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(100);\n+    assertThat(cache.getIfPresent(20)).isEqualTo(200);\n+    assertThat(cache.getIfPresent(4)).isNull();\n \n     fakeTicker.advance(499, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n-    assertEquals(null, cache.getIfPresent(20));\n+    assertThat(cache.getIfPresent(10)).isNull();\n+    assertThat(cache.getIfPresent(20)).isNull();\n \n     cache.put(10, 20);\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(20);\n \n     fakeTicker.advance(500, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isNull();\n   }\n \n-  public void testMapMethods() {\n+  @SuppressWarnings(\"ContainsEntryAfterGetInteger\") // we are testing our implementation of Map.get\n+  @Test\n+  public void mapMethods() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     ConcurrentMap<Integer, Integer> asMap = cache.asMap();\n@@ -213,38 +225,39 @@ public void testMapMethods() {\n     asMap.replace(2, 79);\n     asMap.replace(3, 60);\n \n-    assertEquals(null, cache.getIfPresent(3));\n-    assertEquals(null, asMap.get(3));\n+    assertThat(cache.getIfPresent(3)).isNull();\n+    assertThat(asMap.get(3)).isNull();\n \n-    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(79), asMap.get(2));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(79);\n+    assertThat(asMap.get(2)).isEqualTo(79);\n \n     asMap.replace(10, 100, 50);\n     asMap.replace(2, 52, 99);\n \n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), asMap.get(10));\n-    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(79), asMap.get(2));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(asMap.get(10)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(2)).isEqualTo(79);\n+    assertThat(asMap.get(2)).isEqualTo(79);\n \n     asMap.remove(10, 100);\n     asMap.remove(2, 79);\n \n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), asMap.get(10));\n-    assertEquals(null, cache.getIfPresent(2));\n-    assertEquals(null, asMap.get(2));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(asMap.get(10)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(2)).isNull();\n+    assertThat(asMap.get(2)).isNull();\n \n     asMap.putIfAbsent(2, 20);\n     asMap.putIfAbsent(10, 20);\n \n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(20), asMap.get(2));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), asMap.get(10));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(20);\n+    assertThat(asMap.get(2)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(asMap.get(10)).isEqualTo(50);\n   }\n \n-  public void testRemovalListener() {\n+  @Test\n+  public void removalListener() {\n     int[] stats = new int[4];\n \n     RemovalListener<Integer, Integer> countingListener =\n@@ -303,30 +316,32 @@ public void onRemoval(RemovalNotification<Integer, Integer> notification) {\n \n     cache.invalidateAll();\n \n-    assertEquals(2, stats[0]);\n-    assertEquals(2, stats[1]);\n-    assertEquals(4, stats[2]);\n-    assertEquals(3, stats[3]);\n+    assertThat(stats[0]).isEqualTo(2);\n+    assertThat(stats[1]).isEqualTo(2);\n+    assertThat(stats[2]).isEqualTo(4);\n+    assertThat(stats[3]).isEqualTo(3);\n   }\n \n-  public void testPutAll() {\n+  @Test\n+  public void putAll() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     cache.putAll(ImmutableMap.of(10, 20, 30, 50, 60, 90));\n \n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(30));\n-    assertEquals(Integer.valueOf(90), cache.getIfPresent(60));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(30)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(60)).isEqualTo(90);\n \n     cache.asMap().putAll(ImmutableMap.of(10, 50, 30, 20, 60, 70, 5, 5));\n \n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(30));\n-    assertEquals(Integer.valueOf(70), cache.getIfPresent(60));\n-    assertEquals(Integer.valueOf(5), cache.getIfPresent(5));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(30)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(60)).isEqualTo(70);\n+    assertThat(cache.getIfPresent(5)).isEqualTo(5);\n   }\n \n-  public void testInvalidate() {\n+  @Test\n+  public void invalidate() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     cache.put(654, 2675);\n@@ -335,12 +350,13 @@ public void testInvalidate() {\n \n     cache.invalidate(654);\n \n-    assertFalse(cache.asMap().containsKey(654));\n-    assertTrue(cache.asMap().containsKey(2456));\n-    assertTrue(cache.asMap().containsKey(2));\n+    assertThat(cache.asMap().containsKey(654)).isFalse();\n+    assertThat(cache.asMap().containsKey(2456)).isTrue();\n+    assertThat(cache.asMap().containsKey(2)).isTrue();\n   }\n \n-  public void testInvalidateAll() {\n+  @Test\n+  public void invalidateAll() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     cache.put(654, 2675);\n@@ -348,9 +364,9 @@ public void testInvalidateAll() {\n     cache.put(2, 15);\n \n     cache.invalidateAll();\n-    assertFalse(cache.asMap().containsKey(654));\n-    assertFalse(cache.asMap().containsKey(2456));\n-    assertFalse(cache.asMap().containsKey(2));\n+    assertThat(cache.asMap().containsKey(654)).isFalse();\n+    assertThat(cache.asMap().containsKey(2456)).isFalse();\n+    assertThat(cache.asMap().containsKey(2)).isFalse();\n \n     cache.put(654, 2675);\n     cache.put(2456, 56);\n@@ -359,13 +375,14 @@ public void testInvalidateAll() {\n \n     cache.invalidateAll(ImmutableSet.of(1, 2));\n \n-    assertFalse(cache.asMap().containsKey(1));\n-    assertFalse(cache.asMap().containsKey(2));\n-    assertTrue(cache.asMap().containsKey(654));\n-    assertTrue(cache.asMap().containsKey(2456));\n+    assertThat(cache.asMap().containsKey(1)).isFalse();\n+    assertThat(cache.asMap().containsKey(2)).isFalse();\n+    assertThat(cache.asMap().containsKey(654)).isTrue();\n+    assertThat(cache.asMap().containsKey(2456)).isTrue();\n   }\n \n-  public void testAsMap_containsValue() {\n+  @Test\n+  public void asMap_containsValue() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(20000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -376,12 +393,15 @@ public void testAsMap_containsValue() {\n \n     fakeTicker.advance(10001, MILLISECONDS);\n \n-    assertTrue(cache.asMap().containsValue(15));\n-    assertTrue(cache.asMap().containsValue(56));\n-    assertFalse(cache.asMap().containsValue(2675));\n+    assertThat(cache.asMap().containsValue(15)).isTrue();\n+    assertThat(cache.asMap().containsValue(56)).isTrue();\n+    assertThat(cache.asMap().containsValue(2675)).isFalse();\n   }\n \n-  public void testAsMap_containsKey() {\n+  // we are testing our implementation of Map.containsKey\n+  @SuppressWarnings(\"ContainsEntryAfterGetInteger\")\n+  @Test\n+  public void asMap_containsKey() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(20000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -392,12 +412,15 @@ public void testAsMap_containsKey() {\n \n     fakeTicker.advance(10001, MILLISECONDS);\n \n-    assertTrue(cache.asMap().containsKey(2));\n-    assertTrue(cache.asMap().containsKey(2456));\n-    assertFalse(cache.asMap().containsKey(654));\n+    assertThat(cache.asMap().containsKey(2)).isTrue();\n+    assertThat(cache.asMap().containsKey(2456)).isTrue();\n+    assertThat(cache.asMap().containsKey(654)).isFalse();\n   }\n \n-  public void testAsMapValues_contains() {\n+  // we are testing our implementation of Map.values().contains\n+  @SuppressWarnings(\"ValuesContainsValue\")\n+  @Test\n+  public void asMapValues_contains() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -408,12 +431,13 @@ public void testAsMapValues_contains() {\n \n     fakeTicker.advance(501, MILLISECONDS);\n \n-    assertTrue(cache.asMap().values().contains(22));\n-    assertTrue(cache.asMap().values().contains(10));\n-    assertFalse(cache.asMap().values().contains(20));\n+    assertThat(cache.asMap().values().contains(22)).isTrue();\n+    assertThat(cache.asMap().values().contains(10)).isTrue();\n+    assertThat(cache.asMap().values().contains(20)).isFalse();\n   }\n \n-  public void testAsMapKeySet() {\n+  @Test\n+  public void asMapKeySet() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -426,10 +450,11 @@ public void testAsMapKeySet() {\n \n     Set<Integer> foundKeys = new HashSet<>(cache.asMap().keySet());\n \n-    assertEquals(ImmutableSet.of(20, 5), foundKeys);\n+    assertThat(foundKeys).containsExactly(20, 5);\n   }\n \n-  public void testAsMapKeySet_contains() {\n+  @Test\n+  public void asMapKeySet_contains() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -440,12 +465,13 @@ public void testAsMapKeySet_contains() {\n \n     fakeTicker.advance(501, MILLISECONDS);\n \n-    assertTrue(cache.asMap().keySet().contains(20));\n-    assertTrue(cache.asMap().keySet().contains(5));\n-    assertFalse(cache.asMap().keySet().contains(10));\n+    assertThat(cache.asMap().keySet().contains(20)).isTrue();\n+    assertThat(cache.asMap().keySet().contains(5)).isTrue();\n+    assertThat(cache.asMap().keySet().contains(10)).isFalse();\n   }\n \n-  public void testAsMapEntrySet() {\n+  @Test\n+  public void asMapEntrySet() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -460,10 +486,11 @@ public void testAsMapEntrySet() {\n     for (Entry<Integer, Integer> current : cache.asMap().entrySet()) {\n       sum += current.getKey() + current.getValue();\n     }\n-    assertEquals(57, sum);\n+    assertThat(sum).isEqualTo(57);\n   }\n \n-  public void testAsMapValues_iteratorRemove() {\n+  @Test\n+  public void asMapValues_iteratorRemove() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -472,6 +499,6 @@ public void testAsMapValues_iteratorRemove() {\n     iterator.next();\n     iterator.remove();\n \n-    assertEquals(0, cache.size());\n+    assertThat(cache.size()).isEqualTo(0);\n   }\n }\ndiff --git a/android/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java b/android/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java\nindex 670275b08252..7948e82f89f3 100644\n--- a/android/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java\n@@ -18,6 +18,8 @@\n \n import static com.google.common.cache.CacheBuilderSpec.parse;\n import static com.google.common.cache.TestingWeighers.constantWeigher;\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.util.concurrent.TimeUnit.DAYS;\n import static java.util.concurrent.TimeUnit.HOURS;\n import static java.util.concurrent.TimeUnit.MINUTES;\n@@ -40,27 +42,27 @@\n public class CacheBuilderSpecTest extends TestCase {\n   public void testParse_empty() {\n     CacheBuilderSpec spec = parse(\"\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder(), CacheBuilder.from(spec));\n   }\n \n   public void testParse_initialCapacity() {\n     CacheBuilderSpec spec = parse(\"initialCapacity=10\");\n-    assertEquals(10, spec.initialCapacity.intValue());\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isEqualTo(10);\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().initialCapacity(10), CacheBuilder.from(spec));\n   }\n@@ -72,13 +74,13 @@ public void testParse_initialCapacityRepeated() {\n \n   public void testParse_maximumSize() {\n     CacheBuilderSpec spec = parse(\"maximumSize=9000\");\n-    assertNull(spec.initialCapacity);\n-    assertEquals(9000, spec.maximumSize.longValue());\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isEqualTo(9000L);\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().maximumSize(9000), CacheBuilder.from(spec));\n   }\n@@ -89,13 +91,13 @@ public void testParse_maximumSizeRepeated() {\n \n   public void testParse_maximumWeight() {\n     CacheBuilderSpec spec = parse(\"maximumWeight=9000\");\n-    assertNull(spec.initialCapacity);\n-    assertEquals(9000, spec.maximumWeight.longValue());\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumWeight).isEqualTo(9000L);\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().maximumWeight(9000), CacheBuilder.from(spec));\n   }\n@@ -110,14 +112,14 @@ public void testParse_maximumSizeAndMaximumWeight() {\n \n   public void testParse_concurrencyLevel() {\n     CacheBuilderSpec spec = parse(\"concurrencyLevel=32\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertEquals(32, spec.concurrencyLevel.intValue());\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isEqualTo(32);\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().concurrencyLevel(32), CacheBuilder.from(spec));\n   }\n@@ -129,14 +131,14 @@ public void testParse_concurrencyLevelRepeated() {\n \n   public void testParse_weakKeys() {\n     CacheBuilderSpec spec = parse(\"weakKeys\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertEquals(Strength.WEAK, spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().weakKeys(), CacheBuilder.from(spec));\n   }\n \n@@ -150,14 +152,14 @@ public void testParse_repeatedKeyStrength() {\n \n   public void testParse_softValues() {\n     CacheBuilderSpec spec = parse(\"softValues\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertEquals(Strength.SOFT, spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isEqualTo(Strength.SOFT);\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().softValues(), CacheBuilder.from(spec));\n   }\n \n@@ -167,14 +169,14 @@ public void testParse_softValuesCannotHaveValue() {\n \n   public void testParse_weakValues() {\n     CacheBuilderSpec spec = parse(\"weakValues\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertEquals(Strength.WEAK, spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().weakValues(), CacheBuilder.from(spec));\n   }\n \n@@ -194,39 +196,39 @@ public void testParse_repeatedValueStrength() {\n \n   public void testParse_writeExpirationDays() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=10d\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertEquals(DAYS, spec.writeExpirationTimeUnit);\n-    assertEquals(10L, spec.writeExpirationDuration);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(DAYS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(10L, DAYS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_writeExpirationHours() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=150h\");\n-    assertEquals(HOURS, spec.writeExpirationTimeUnit);\n-    assertEquals(150L, spec.writeExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(HOURS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(150L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(150L, HOURS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_writeExpirationMinutes() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=10m\");\n-    assertEquals(MINUTES, spec.writeExpirationTimeUnit);\n-    assertEquals(10L, spec.writeExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(10L, MINUTES), CacheBuilder.from(spec));\n   }\n \n   public void testParse_writeExpirationSeconds() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=10s\");\n-    assertEquals(SECONDS, spec.writeExpirationTimeUnit);\n-    assertEquals(10L, spec.writeExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(10L, SECONDS), CacheBuilder.from(spec));\n   }\n@@ -238,39 +240,39 @@ public void testParse_writeExpirationRepeated() {\n \n   public void testParse_accessExpirationDays() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10d\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertEquals(DAYS, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(DAYS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, DAYS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_accessExpirationHours() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=150h\");\n-    assertEquals(HOURS, spec.accessExpirationTimeUnit);\n-    assertEquals(150L, spec.accessExpirationDuration);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(HOURS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(150L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(150L, HOURS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_accessExpirationMinutes() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10m\");\n-    assertEquals(MINUTES, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, MINUTES), CacheBuilder.from(spec));\n   }\n \n   public void testParse_accessExpirationSeconds() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10s\");\n-    assertEquals(SECONDS, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, SECONDS), CacheBuilder.from(spec));\n   }\n@@ -282,7 +284,7 @@ public void testParse_accessExpirationRepeated() {\n \n   public void testParse_recordStats() {\n     CacheBuilderSpec spec = parse(\"recordStats\");\n-    assertTrue(spec.recordStats);\n+    assertThat(spec.recordStats).isTrue();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().recordStats(), CacheBuilder.from(spec));\n   }\n \n@@ -296,10 +298,10 @@ public void testParse_recordStatsRepeated() {\n \n   public void testParse_accessExpirationAndWriteExpiration() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10s,expireAfterWrite=9m\");\n-    assertEquals(MINUTES, spec.writeExpirationTimeUnit);\n-    assertEquals(9L, spec.writeExpirationDuration);\n-    assertEquals(SECONDS, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(9L);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, SECONDS).expireAfterWrite(9L, MINUTES),\n         CacheBuilder.from(spec));\n@@ -310,16 +312,16 @@ public void testParse_multipleKeys() {\n         parse(\n             \"initialCapacity=10,maximumSize=20,concurrencyLevel=30,\"\n                 + \"weakKeys,weakValues,expireAfterAccess=10m,expireAfterWrite=1h\");\n-    assertEquals(10, spec.initialCapacity.intValue());\n-    assertEquals(20, spec.maximumSize.intValue());\n-    assertNull(spec.maximumWeight);\n-    assertEquals(30, spec.concurrencyLevel.intValue());\n-    assertEquals(Strength.WEAK, spec.keyStrength);\n-    assertEquals(Strength.WEAK, spec.valueStrength);\n-    assertEquals(HOURS, spec.writeExpirationTimeUnit);\n-    assertEquals(MINUTES, spec.accessExpirationTimeUnit);\n-    assertEquals(1L, spec.writeExpirationDuration);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.initialCapacity).isEqualTo(10);\n+    assertThat(spec.maximumSize).isEqualTo(20);\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isEqualTo(30);\n+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.valueStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(HOURS);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(1L);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     CacheBuilder<?, ?> expected =\n         CacheBuilder.newBuilder()\n             .initialCapacity(10)\n@@ -337,15 +339,15 @@ public void testParse_whitespaceAllowed() {\n         parse(\n             \" initialCapacity=10,\\nmaximumSize=20,\\t\\r\"\n                 + \"weakKeys \\t ,softValues \\n , \\r  expireAfterWrite \\t =  15s\\n\\n\");\n-    assertEquals(10, spec.initialCapacity.intValue());\n-    assertEquals(20, spec.maximumSize.intValue());\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertEquals(Strength.WEAK, spec.keyStrength);\n-    assertEquals(Strength.SOFT, spec.valueStrength);\n-    assertEquals(SECONDS, spec.writeExpirationTimeUnit);\n-    assertEquals(15L, spec.writeExpirationDuration);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isEqualTo(10);\n+    assertThat(spec.maximumSize).isEqualTo(20);\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.valueStrength).isEqualTo(Strength.SOFT);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(15L);\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     CacheBuilder<?, ?> expected =\n         CacheBuilder.newBuilder()\n             .initialCapacity(10)\n@@ -424,9 +426,9 @@ public void testDisableCaching() {\n     Object value = new Object();\n     LoadingCache<Object, Object> cache =\n         builder.build(CacheLoader.from(Suppliers.ofInstance(value)));\n-    assertSame(value, cache.getUnchecked(key));\n-    assertEquals(0, cache.size());\n-    assertFalse(cache.asMap().containsKey(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);\n+    assertThat(cache.size()).isEqualTo(0);\n+    assertThat(cache.asMap().containsKey(key)).isFalse();\n   }\n \n   public void testCacheBuilderFrom_string() {\n@@ -445,22 +447,41 @@ public void testCacheBuilderFrom_string() {\n     assertCacheBuilderEquivalence(expected, fromString);\n   }\n \n-  private static void assertCacheBuilderEquivalence(CacheBuilder<?, ?> a, CacheBuilder<?, ?> b) {\n-    assertEquals(\"concurrencyLevel\", a.concurrencyLevel, b.concurrencyLevel);\n-    assertEquals(\"expireAfterAccessNanos\", a.expireAfterAccessNanos, b.expireAfterAccessNanos);\n-    assertEquals(\"expireAfterWriteNanos\", a.expireAfterWriteNanos, b.expireAfterWriteNanos);\n-    assertEquals(\"initialCapacity\", a.initialCapacity, b.initialCapacity);\n-    assertEquals(\"maximumSize\", a.maximumSize, b.maximumSize);\n-    assertEquals(\"maximumWeight\", a.maximumWeight, b.maximumWeight);\n-    assertEquals(\"refreshNanos\", a.refreshNanos, b.refreshNanos);\n-    assertEquals(\"keyEquivalence\", a.keyEquivalence, b.keyEquivalence);\n-    assertEquals(\"keyStrength\", a.keyStrength, b.keyStrength);\n-    assertEquals(\"removalListener\", a.removalListener, b.removalListener);\n-    assertEquals(\"weigher\", a.weigher, b.weigher);\n-    assertEquals(\"valueEquivalence\", a.valueEquivalence, b.valueEquivalence);\n-    assertEquals(\"valueStrength\", a.valueStrength, b.valueStrength);\n-    assertEquals(\"statsCounterSupplier\", a.statsCounterSupplier, b.statsCounterSupplier);\n-    assertEquals(\"ticker\", a.ticker, b.ticker);\n-    assertEquals(\"recordStats\", a.isRecordingStats(), b.isRecordingStats());\n+  private static void assertCacheBuilderEquivalence(\n+      CacheBuilder<?, ?> expected, CacheBuilder<?, ?> actual) {\n+    assertWithMessage(\"concurrencyLevel\")\n+        .that(actual.concurrencyLevel)\n+        .isEqualTo(expected.concurrencyLevel);\n+    assertWithMessage(\"expireAfterAccessNanos\")\n+        .that(actual.expireAfterAccessNanos)\n+        .isEqualTo(expected.expireAfterAccessNanos);\n+    assertWithMessage(\"expireAfterWriteNanos\")\n+        .that(actual.expireAfterWriteNanos)\n+        .isEqualTo(expected.expireAfterWriteNanos);\n+    assertWithMessage(\"initialCapacity\")\n+        .that(actual.initialCapacity)\n+        .isEqualTo(expected.initialCapacity);\n+    assertWithMessage(\"maximumSize\").that(actual.maximumSize).isEqualTo(expected.maximumSize);\n+    assertWithMessage(\"maximumWeight\").that(actual.maximumWeight).isEqualTo(expected.maximumWeight);\n+    assertWithMessage(\"refreshNanos\").that(actual.refreshNanos).isEqualTo(expected.refreshNanos);\n+    assertWithMessage(\"keyEquivalence\")\n+        .that(actual.keyEquivalence)\n+        .isEqualTo(expected.keyEquivalence);\n+    assertWithMessage(\"keyStrength\").that(actual.keyStrength).isEqualTo(expected.keyStrength);\n+    assertWithMessage(\"removalListener\")\n+        .that(actual.removalListener)\n+        .isEqualTo(expected.removalListener);\n+    assertWithMessage(\"weigher\").that(actual.weigher).isEqualTo(expected.weigher);\n+    assertWithMessage(\"valueEquivalence\")\n+        .that(actual.valueEquivalence)\n+        .isEqualTo(expected.valueEquivalence);\n+    assertWithMessage(\"valueStrength\").that(actual.valueStrength).isEqualTo(expected.valueStrength);\n+    assertWithMessage(\"statsCounterSupplier\")\n+        .that(actual.statsCounterSupplier)\n+        .isEqualTo(expected.statsCounterSupplier);\n+    assertWithMessage(\"ticker\").that(actual.ticker).isEqualTo(expected.ticker);\n+    assertWithMessage(\"recordStats\")\n+        .that(actual.isRecordingStats())\n+        .isEqualTo(expected.isRecordingStats());\n   }\n }\ndiff --git a/android/guava-tests/test/com/google/common/cache/CacheBuilderTest.java b/android/guava-tests/test/com/google/common/cache/CacheBuilderTest.java\nindex d7ec57c94565..cbc2e6b4ed11 100644\n--- a/android/guava-tests/test/com/google/common/cache/CacheBuilderTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/CacheBuilderTest.java\n@@ -24,6 +24,7 @@\n import static com.google.common.cache.TestingRemovalListeners.queuingRemovalListener;\n import static com.google.common.cache.TestingWeighers.constantWeigher;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.util.concurrent.Executors.newFixedThreadPool;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n@@ -63,8 +64,8 @@ public void testNewBuilder() {\n     LoadingCache<String, Integer> cache =\n         CacheBuilder.newBuilder().removalListener(countingRemovalListener()).build(loader);\n \n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(\"one\"));\n-    assertEquals(1, cache.size());\n+    assertThat(cache.getUnchecked(\"one\")).isEqualTo(1);\n+    assertThat(cache.size()).isEqualTo(1);\n   }\n \n   public void testInitialCapacity_negative() {\n@@ -83,10 +84,10 @@ public void testInitialCapacity_small() {\n     LocalCache<?, ?> map = CacheTesting.toLocalCache(cache);\n \n     assertThat(map.segments).hasLength(4);\n-    assertEquals(2, map.segments[0].table.length());\n-    assertEquals(2, map.segments[1].table.length());\n-    assertEquals(2, map.segments[2].table.length());\n-    assertEquals(2, map.segments[3].table.length());\n+    assertThat(map.segments[0].table.length()).isEqualTo(2);\n+    assertThat(map.segments[1].table.length()).isEqualTo(2);\n+    assertThat(map.segments[2].table.length()).isEqualTo(2);\n+    assertThat(map.segments[3].table.length()).isEqualTo(2);\n   }\n \n   @GwtIncompatible // CacheTesting\n@@ -96,10 +97,10 @@ public void testInitialCapacity_smallest() {\n \n     assertThat(map.segments).hasLength(4);\n     // 1 is as low as it goes, not 0. it feels dirty to know this/test this.\n-    assertEquals(1, map.segments[0].table.length());\n-    assertEquals(1, map.segments[1].table.length());\n-    assertEquals(1, map.segments[2].table.length());\n-    assertEquals(1, map.segments[3].table.length());\n+    assertThat(map.segments[0].table.length()).isEqualTo(1);\n+    assertThat(map.segments[1].table.length()).isEqualTo(1);\n+    assertThat(map.segments[2].table.length()).isEqualTo(1);\n+    assertThat(map.segments[3].table.length()).isEqualTo(1);\n   }\n \n   public void testInitialCapacity_large() {\n@@ -328,7 +329,7 @@ public void testRemovalListener_setTwice() {\n   }\n \n   public void testValuesIsNotASet() {\n-    assertFalse(CacheBuilder.newBuilder().build().asMap().values() instanceof Set);\n+    assertThat(CacheBuilder.newBuilder().build().asMap().values() instanceof Set).isFalse();\n   }\n \n   @GwtIncompatible // CacheTesting\n@@ -336,11 +337,11 @@ public void testNullCache() {\n     CountingRemovalListener<Object, Object> listener = countingRemovalListener();\n     LoadingCache<Object, Object> nullCache =\n         CacheBuilder.newBuilder().maximumSize(0).removalListener(listener).build(identityLoader());\n-    assertEquals(0, nullCache.size());\n+    assertThat(nullCache.size()).isEqualTo(0);\n     Object key = new Object();\n-    assertSame(key, nullCache.getUnchecked(key));\n-    assertEquals(1, listener.getCount());\n-    assertEquals(0, nullCache.size());\n+    assertThat(nullCache.getUnchecked(key)).isSameInstanceAs(key);\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(nullCache.size()).isEqualTo(0);\n     CacheTesting.checkEmpty(nullCache.asMap());\n   }\n \n@@ -397,12 +398,12 @@ public void run() {\n     // At this point, the listener should be holding the seed value (a -> a), and the map should\n     // contain the computed value (b -> b), since the clear() happened before the computation\n     // completed.\n-    assertEquals(1, listener.size());\n+    assertThat(listener).hasSize(1);\n     RemovalNotification<String, String> notification = listener.remove();\n-    assertEquals(\"a\", notification.getKey());\n-    assertEquals(\"a\", notification.getValue());\n-    assertEquals(1, cache.size());\n-    assertEquals(\"b\", cache.getUnchecked(\"b\"));\n+    assertThat(notification.getKey()).isEqualTo(\"a\");\n+    assertThat(notification.getValue()).isEqualTo(\"a\");\n+    assertThat(cache.size()).isEqualTo(1);\n+    assertThat(cache.getUnchecked(\"b\")).isEqualTo(\"b\");\n   }\n \n   // \"Basher tests\", where we throw a bunch of stuff at a LoadingCache and check basic invariants.\n@@ -477,22 +478,22 @@ public void run() {\n     Map<String, String> removalNotifications = new HashMap<>();\n     for (RemovalNotification<String, String> notification : listener) {\n       removalNotifications.put(notification.getKey(), notification.getValue());\n-      assertEquals(\n-          \"Unexpected key/value pair passed to removalListener\",\n-          notification.getKey(),\n-          notification.getValue());\n+      assertWithMessage(\"Unexpected key/value pair passed to removalListener\")\n+          .that(notification.getValue())\n+          .isEqualTo(notification.getKey());\n     }\n \n     // All of the seed values should have been visible, so we should have gotten removal\n     // notifications for all of them.\n     for (int i = 0; i < nSeededEntries; i++) {\n-      assertEquals(\"b\" + i, removalNotifications.get(\"b\" + i));\n+      assertThat(removalNotifications.get(\"b\" + i)).isEqualTo(\"b\" + i);\n     }\n \n     // Each of the values added to the map should either still be there, or have seen a removal\n     // notification.\n-    assertEquals(expectedKeys, Sets.union(cache.asMap().keySet(), removalNotifications.keySet()));\n-    assertTrue(Sets.intersection(cache.asMap().keySet(), removalNotifications.keySet()).isEmpty());\n+    assertThat(Sets.union(cache.asMap().keySet(), removalNotifications.keySet()))\n+        .isEqualTo(expectedKeys);\n+    assertThat(cache.asMap().keySet()).containsNoneIn(removalNotifications.keySet());\n     threadPool.shutdown();\n     threadPool.awaitTermination(300, SECONDS);\n   }\n@@ -571,15 +572,17 @@ public void run() {\n \n     // Verify that each received removal notification was valid\n     for (RemovalNotification<String, String> notification : removalListener) {\n-      assertEquals(\"Invalid removal notification\", notification.getKey(), notification.getValue());\n+      assertWithMessage(\"Invalid removal notification\")\n+          .that(notification.getValue())\n+          .isEqualTo(notification.getKey());\n     }\n \n     CacheStats stats = cache.stats();\n-    assertEquals(removalListener.size(), stats.evictionCount());\n-    assertEquals(computeCount.get(), stats.loadSuccessCount());\n-    assertEquals(exceptionCount.get() + computeNullCount.get(), stats.loadExceptionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(removalListener.size());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(computeCount.get());\n+    assertThat(stats.loadExceptionCount()).isEqualTo(exceptionCount.get() + computeNullCount.get());\n     // each computed value is still in the cache, or was passed to the removal listener\n-    assertEquals(computeCount.get(), cache.size() + removalListener.size());\n+    assertThat(cache.size() + removalListener.size()).isEqualTo(computeCount.get());\n   }\n \n   @GwtIncompatible // NullPointerTester\n@@ -594,7 +597,7 @@ public void testSizingDefaults() {\n     LoadingCache<?, ?> cache = CacheBuilder.newBuilder().build(identityLoader());\n     LocalCache<?, ?> map = CacheTesting.toLocalCache(cache);\n     assertThat(map.segments).hasLength(4); // concurrency level\n-    assertEquals(4, map.segments[0].table.length()); // capacity / conc level\n+    assertThat(map.segments[0].table.length()).isEqualTo(4); // capacity / conc level\n   }\n \n   @GwtIncompatible // CountDownLatch\ndiff --git a/android/guava-tests/test/com/google/common/cache/CacheEvictionTest.java b/android/guava-tests/test/com/google/common/cache/CacheEvictionTest.java\nindex a6d97f881001..8f83959eb8f6 100644\n--- a/android/guava-tests/test/com/google/common/cache/CacheEvictionTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/CacheEvictionTest.java\n@@ -45,7 +45,7 @@ public void testEviction_setMaxSegmentSize() {\n     IdentityLoader<Object> loader = identityLoader();\n     for (int i = 1; i < 1000; i++) {\n       LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().maximumSize(i).build(loader);\n-      assertEquals(i, CacheTesting.getTotalSegmentSize(cache));\n+      assertThat(CacheTesting.getTotalSegmentSize(cache)).isEqualTo(i);\n     }\n   }\n \n@@ -54,7 +54,7 @@ public void testEviction_setMaxSegmentWeight() {\n     for (int i = 1; i < 1000; i++) {\n       LoadingCache<Object, Object> cache =\n           CacheBuilder.newBuilder().maximumWeight(i).weigher(constantWeigher(1)).build(loader);\n-      assertEquals(i, CacheTesting.getTotalSegmentSize(cache));\n+      assertThat(CacheTesting.getTotalSegmentSize(cache)).isEqualTo(i);\n     }\n   }\n \n@@ -64,10 +64,10 @@ public void testEviction_maxSizeOneSegment() {\n         CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(MAX_SIZE).build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertEquals(min(i + 1, MAX_SIZE), cache.size());\n+      assertThat(cache.size()).isEqualTo(min(i + 1, MAX_SIZE));\n     }\n \n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -81,10 +81,10 @@ public void testEviction_maxWeightOneSegment() {\n             .build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertEquals(min(i + 1, MAX_SIZE), cache.size());\n+      assertThat(cache.size()).isEqualTo(min(i + 1, MAX_SIZE));\n     }\n \n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -98,13 +98,13 @@ public void testEviction_maxSize() {\n             .build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertTrue(cache.size() <= MAX_SIZE);\n+      assertThat(cache.size() <= MAX_SIZE).isTrue();\n     }\n \n-    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));\n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(CacheTesting.accessQueueSize(cache)).isEqualTo(MAX_SIZE);\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.processPendingNotifications(cache);\n-    assertEquals(MAX_SIZE, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -119,13 +119,13 @@ public void testEviction_maxWeight() {\n             .build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertTrue(cache.size() <= MAX_SIZE);\n+      assertThat(cache.size()).isAtMost(MAX_SIZE);\n     }\n \n-    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));\n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(CacheTesting.accessQueueSize(cache)).isEqualTo(MAX_SIZE);\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.processPendingNotifications(cache);\n-    assertEquals(MAX_SIZE, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -255,7 +255,7 @@ public void testEviction_overflow() {\n     cache.getUnchecked(objectWithHash(0));\n     cache.getUnchecked(objectWithHash(0));\n     CacheTesting.processPendingNotifications(cache);\n-    assertEquals(1, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(1);\n   }\n \n   public void testUpdateRecency_onGet() {\ndiff --git a/android/guava-tests/test/com/google/common/cache/CacheExpirationTest.java b/android/guava-tests/test/com/google/common/cache/CacheExpirationTest.java\nindex 8122c68514e8..75095b28e0b6 100644\n--- a/android/guava-tests/test/com/google/common/cache/CacheExpirationTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/CacheExpirationTest.java\n@@ -17,6 +17,7 @@\n import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.util.Arrays.asList;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static java.util.concurrent.TimeUnit.MINUTES;\n@@ -81,23 +82,29 @@ private void checkExpiration(\n       CountingRemovalListener<String, Integer> removalListener) {\n \n     for (int i = 0; i < 10; i++) {\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n     }\n \n     for (int i = 0; i < 10; i++) {\n       loader.reset();\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n-      assertFalse(\"Creator should not have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n+      assertWithMessage(\"Creator should not have been called @#%s\", i)\n+          .that(loader.wasCalled())\n+          .isFalse();\n     }\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n \n-    assertEquals(\"Map must be empty by now\", 0, cache.size());\n-    assertEquals(\"Eviction notifications must be received\", 10, removalListener.getCount());\n+    assertWithMessage(\"Map must be empty by now\").that(cache.size()).isEqualTo(0);\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(10);\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n     // ensure that no new notifications are sent\n-    assertEquals(\"Eviction notifications must be received\", 10, removalListener.getCount());\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(10);\n   }\n \n   public void testExpiringGet_expireAfterWrite() {\n@@ -133,13 +140,15 @@ private void runExpirationTest(\n       CountingRemovalListener<String, Integer> removalListener) {\n \n     for (int i = 0; i < 10; i++) {\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n     }\n \n     for (int i = 0; i < 10; i++) {\n       loader.reset();\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n-      assertFalse(\"Loader should NOT have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n+      assertWithMessage(\"Loader should NOT have been called @#%s\", i)\n+          .that(loader.wasCalled())\n+          .isFalse();\n     }\n \n     // wait for entries to expire, but don't call expireEntries\n@@ -149,31 +158,35 @@ private void runExpirationTest(\n     cache.getUnchecked(KEY_PREFIX + 11);\n \n     // collections views shouldn't expose expired entries\n-    assertEquals(1, Iterators.size(cache.asMap().entrySet().iterator()));\n-    assertEquals(1, Iterators.size(cache.asMap().keySet().iterator()));\n-    assertEquals(1, Iterators.size(cache.asMap().values().iterator()));\n+    assertThat(Iterators.size(cache.asMap().entrySet().iterator())).isEqualTo(1);\n+    assertThat(Iterators.size(cache.asMap().keySet().iterator())).isEqualTo(1);\n+    assertThat(Iterators.size(cache.asMap().values().iterator())).isEqualTo(1);\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n \n     for (int i = 0; i < 11; i++) {\n-      assertFalse(cache.asMap().containsKey(KEY_PREFIX + i));\n+      assertThat(cache.asMap().containsKey(KEY_PREFIX + i)).isFalse();\n     }\n-    assertEquals(11, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(11);\n \n     for (int i = 0; i < 10; i++) {\n-      assertFalse(cache.asMap().containsKey(KEY_PREFIX + i));\n+      assertThat(cache.asMap().containsKey(KEY_PREFIX + i)).isFalse();\n       loader.reset();\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n-      assertTrue(\"Creator should have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n+      assertWithMessage(\"Loader should have been called @#%s\", i).that(loader.wasCalled()).isTrue();\n     }\n \n     // expire new values we just created\n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n-    assertEquals(\"Eviction notifications must be received\", 21, removalListener.getCount());\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(21);\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n     // ensure that no new notifications are sent\n-    assertEquals(\"Eviction notifications must be received\", 21, removalListener.getCount());\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(21);\n   }\n \n   public void testRemovalListener_expireAfterWrite() {\n@@ -215,9 +228,9 @@ public AtomicInteger load(Integer key) {\n       ticker.advance(1, MILLISECONDS);\n     }\n \n-    assertEquals(evictionCount.get() + 1, applyCount.get());\n+    assertThat(applyCount.get()).isEqualTo(evictionCount.get() + 1);\n     int remaining = cache.getUnchecked(10).get();\n-    assertEquals(100, totalSum.get() + remaining);\n+    assertThat(totalSum.get() + remaining).isEqualTo(100);\n   }\n \n   public void testRemovalScheduler_expireAfterWrite() {\n@@ -435,46 +448,50 @@ private void runRemovalScheduler(\n       FakeTicker ticker,\n       String keyPrefix,\n       long ttl) {\n+    loader.setKeyPrefix(keyPrefix);\n \n     int shift1 = 10 + VALUE_PREFIX;\n     loader.setValuePrefix(shift1);\n     // fill with initial data\n     for (int i = 0; i < 10; i++) {\n-      assertEquals(Integer.valueOf(i + shift1), cache.getUnchecked(keyPrefix + i));\n+      assertThat(cache.getUnchecked(keyPrefix + i)).isEqualTo(i + shift1);\n     }\n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n \n     // wait, so that entries have just 10 ms to live\n     ticker.advance(ttl * 2 / 3, MILLISECONDS);\n \n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n \n     int shift2 = shift1 + 10;\n     loader.setValuePrefix(shift2);\n     // fill with new data - has to live for 20 ms more\n     for (int i = 0; i < 10; i++) {\n       cache.invalidate(keyPrefix + i);\n-      assertEquals(\n-          \"key: \" + keyPrefix + i, Integer.valueOf(i + shift2), cache.getUnchecked(keyPrefix + i));\n+      assertWithMessage(\"key: %s%s\", keyPrefix, i)\n+          .that(cache.getUnchecked(keyPrefix + i))\n+          .isEqualTo(i + shift2);\n     }\n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(10, removalListener.getCount()); // these are the invalidated ones\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(10); // these are the invalidated ones\n \n     // old timeouts must expire after this wait\n     ticker.advance(ttl * 2 / 3, MILLISECONDS);\n \n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(10, removalListener.getCount());\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(10);\n \n     // check that new values are still there - they still have 10 ms to live\n     for (int i = 0; i < 10; i++) {\n       loader.reset();\n-      assertEquals(Integer.valueOf(i + shift2), cache.getUnchecked(keyPrefix + i));\n-      assertFalse(\"Creator should NOT have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(keyPrefix + i)).isEqualTo(i + shift2);\n+      assertWithMessage(\"Creator should NOT have been called @#%s\", i)\n+          .that(loader.wasCalled())\n+          .isFalse();\n     }\n-    assertEquals(10, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(10);\n   }\n \n   private static void getAll(LoadingCache<Integer, Integer> cache, List<Integer> keys) {\ndiff --git a/android/guava-tests/test/com/google/common/cache/CacheLoaderTest.java b/android/guava-tests/test/com/google/common/cache/CacheLoaderTest.java\nindex 70918db35fe7..8125ff117a6a 100644\n--- a/android/guava-tests/test/com/google/common/cache/CacheLoaderTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/CacheLoaderTest.java\n@@ -16,6 +16,7 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.util.concurrent.Futures.immediateFuture;\n \n import com.google.common.collect.ImmutableList;\n@@ -77,17 +78,17 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {\n           }\n         };\n \n-    assertEquals(0, loadCount.get());\n-    assertEquals(0, reloadCount.get());\n-    assertEquals(0, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(0);\n+    assertThat(reloadCount.get()).isEqualTo(0);\n+    assertThat(loadAllCount.get()).isEqualTo(0);\n \n     Object unused1 = baseLoader.load(new Object());\n     @SuppressWarnings(\"unused\") // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n     Future<?> possiblyIgnoredError = baseLoader.reload(new Object(), new Object());\n     Map<Object, Object> unused2 = baseLoader.loadAll(ImmutableList.of(new Object()));\n-    assertEquals(1, loadCount.get());\n-    assertEquals(1, reloadCount.get());\n-    assertEquals(1, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(1);\n+    assertThat(reloadCount.get()).isEqualTo(1);\n+    assertThat(loadAllCount.get()).isEqualTo(1);\n \n     QueuingExecutor executor = new QueuingExecutor();\n     CacheLoader<Object, Object> asyncReloader = CacheLoader.asyncReloading(baseLoader, executor);\n@@ -96,13 +97,13 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {\n     @SuppressWarnings(\"unused\") // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n     Future<?> possiblyIgnoredError1 = asyncReloader.reload(new Object(), new Object());\n     Map<Object, Object> unused4 = asyncReloader.loadAll(ImmutableList.of(new Object()));\n-    assertEquals(2, loadCount.get());\n-    assertEquals(1, reloadCount.get());\n-    assertEquals(2, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(2);\n+    assertThat(reloadCount.get()).isEqualTo(1);\n+    assertThat(loadAllCount.get()).isEqualTo(2);\n \n     executor.runNext();\n-    assertEquals(2, loadCount.get());\n-    assertEquals(2, reloadCount.get());\n-    assertEquals(2, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(2);\n+    assertThat(reloadCount.get()).isEqualTo(2);\n+    assertThat(loadAllCount.get()).isEqualTo(2);\n   }\n }\ndiff --git a/android/guava-tests/test/com/google/common/cache/CacheLoadingTest.java b/android/guava-tests/test/com/google/common/cache/CacheLoadingTest.java\nindex a2e3883d95b9..7dc674ae919c 100644\n--- a/android/guava-tests/test/com/google/common/cache/CacheLoadingTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/CacheLoadingTest.java\n@@ -21,6 +21,7 @@\n import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static com.google.common.util.concurrent.Futures.immediateFailedFuture;\n import static com.google.common.util.concurrent.Futures.immediateFuture;\n import static java.util.Arrays.asList;\n@@ -33,7 +34,6 @@\n import com.google.common.cache.TestingCacheLoaders.IdentityLoader;\n import com.google.common.cache.TestingRemovalListeners.CountingRemovalListener;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Lists;\n import com.google.common.testing.FakeTicker;\n import com.google.common.testing.TestLogHandler;\n@@ -83,7 +83,7 @@ public void tearDown() throws Exception {\n \n   private Throwable popLoggedThrowable() {\n     List<LogRecord> logRecords = logHandler.getStoredLogRecords();\n-    assertEquals(1, logRecords.size());\n+    assertThat(logRecords).hasSize(1);\n     LogRecord logRecord = logRecords.get(0);\n     logHandler.clear();\n     return logRecord.getThrown();\n@@ -105,59 +105,59 @@ public void testLoad() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(identityLoader());\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Object key = new Object();\n-    assertSame(key, cache.get(key));\n+    assertThat(cache.get(key)).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     key = new Object();\n-    assertSame(key, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     key = new Object();\n     cache.refresh(key);\n     checkNothingLogged();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(key, cache.get(key));\n+    assertThat(cache.get(key)).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     Object value = new Object();\n     // callable is not called\n-    assertSame(key, cache.get(key, throwing(new Exception())));\n+    assertThat(cache.get(key, throwing(new Exception()))).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     key = new Object();\n-    assertSame(value, cache.get(key, Callables.returning(value)));\n+    assertThat(cache.get(key, Callables.returning(value))).isSameInstanceAs(value);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(4, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(4);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n   }\n \n   public void testReload() throws ExecutionException {\n@@ -179,32 +179,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkNothingLogged();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(two, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefresh() {\n@@ -232,41 +232,41 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testRefresh_getIfPresent() {\n@@ -294,41 +294,41 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getIfPresent(key));\n+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getIfPresent(key));\n+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getIfPresent(key));\n+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoad_default() throws ExecutionException {\n@@ -337,45 +337,45 @@ public void testBulkLoad_default() throws ExecutionException {\n             .recordStats()\n             .build(TestingCacheLoaders.<Integer>identityLoader());\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.<Integer>of()));\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(cache.getAll(ImmutableList.of())).isEmpty();\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));\n+    assertThat(cache.getAll(asList(1))).containsExactly(1, 1);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));\n+    assertThat(cache.getAll(asList(1, 2, 3, 4))).containsExactly(1, 1, 2, 2, 3, 3, 4, 4);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(4, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(4);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n-    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));\n+    assertThat(cache.getAll(asList(2, 3))).containsExactly(2, 2, 3, 3);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(4, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(4);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n \n     // duplicate keys are ignored, and don't impact stats\n-    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));\n+    assertThat(cache.getAll(asList(4, 5))).containsExactly(4, 4, 5, 5);\n     stats = cache.stats();\n-    assertEquals(5, stats.missCount());\n-    assertEquals(5, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(4, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(5);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(5);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(4);\n   }\n \n   public void testBulkLoad_loadAll() throws ExecutionException {\n@@ -383,45 +383,45 @@ public void testBulkLoad_loadAll() throws ExecutionException {\n     CacheLoader<Integer, Integer> loader = bulkLoader(backingLoader);\n     LoadingCache<Integer, Integer> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.<Integer>of()));\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(cache.getAll(ImmutableList.<Integer>of())).containsExactly();\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));\n+    assertThat(cache.getAll(asList(1))).containsExactly(1, 1);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));\n+    assertThat(cache.getAll(asList(1, 2, 3, 4))).containsExactly(1, 1, 2, 2, 3, 3, 4, 4);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n-    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));\n+    assertThat(cache.getAll(asList(2, 3))).containsExactly(2, 2, 3, 3);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n \n     // duplicate keys are ignored, and don't impact stats\n-    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));\n+    assertThat(cache.getAll(asList(4, 5))).containsExactly(4, 4, 5, 5);\n     stats = cache.stats();\n-    assertEquals(5, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(4, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(5);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(4);\n   }\n \n   public void testBulkLoad_extra() throws ExecutionException {\n@@ -452,10 +452,10 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n     for (Entry<Object, Object> entry : result.entrySet()) {\n       Object key = entry.getKey();\n       Object value = entry.getValue();\n-      assertSame(value, result.get(key));\n-      assertNull(result.get(value));\n-      assertSame(value, cache.asMap().get(key));\n-      assertSame(key, cache.asMap().get(value));\n+      assertThat(result.get(key)).isSameInstanceAs(value);\n+      assertThat(result.get(value)).isNull();\n+      assertThat(cache.asMap().get(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().get(value)).isSameInstanceAs(key);\n     }\n   }\n \n@@ -482,7 +482,7 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n         };\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);\n     cache.asMap().put(extraKey, extraKey);\n-    assertSame(extraKey, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     Map<Object, Object> result = cache.getAll(asList(lookupKeys));\n@@ -490,11 +490,11 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n     for (Entry<Object, Object> entry : result.entrySet()) {\n       Object key = entry.getKey();\n       Object value = entry.getValue();\n-      assertSame(value, result.get(key));\n-      assertSame(value, cache.asMap().get(key));\n+      assertThat(result.get(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().get(key)).isSameInstanceAs(value);\n     }\n-    assertNull(result.get(extraKey));\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n+    assertThat(result.get(extraKey)).isNull();\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n   }\n \n   public void testBulkLoad_clobberNullValue() throws ExecutionException {\n@@ -521,16 +521,16 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n         };\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);\n     cache.asMap().put(extraKey, extraKey);\n-    assertSame(extraKey, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));\n \n     for (Object key : lookupKeys) {\n-      assertTrue(cache.asMap().containsKey(key));\n+      assertThat(cache.asMap().containsKey(key)).isTrue();\n     }\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n-    assertFalse(cache.asMap().containsKey(extraValue));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n+    assertThat(cache.asMap().containsKey(extraValue)).isFalse();\n   }\n \n   public void testBulkLoad_clobberNullKey() throws ExecutionException {\n@@ -557,16 +557,16 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n         };\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);\n     cache.asMap().put(extraKey, extraKey);\n-    assertSame(extraKey, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));\n \n     for (Object key : lookupKeys) {\n-      assertTrue(cache.asMap().containsKey(key));\n+      assertThat(cache.asMap().containsKey(key)).isTrue();\n     }\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n-    assertFalse(cache.asMap().containsValue(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n+    assertThat(cache.asMap().containsValue(extraKey)).isFalse();\n   }\n \n   public void testBulkLoad_partial() throws ExecutionException {\n@@ -591,54 +591,54 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n   }\n \n   public void testLoadNull() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(constantLoader(null));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.get(new Object()));\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(new Object()));\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedInvalidLoad();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(\n         InvalidCacheLoadException.class, () -> cache.get(new Object(), Callables.returning(null)));\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadNull() throws ExecutionException {\n@@ -659,32 +659,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedInvalidLoad();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadNullFuture() throws ExecutionException {\n@@ -705,32 +705,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedInvalidLoad();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshNull() {\n@@ -757,59 +757,59 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadNull() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(constantLoader(null)));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testBulkLoadNullMap() throws ExecutionException {\n@@ -830,17 +830,17 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {\n                 });\n \n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadError() throws ExecutionException {\n@@ -848,34 +848,34 @@ public void testLoadError() throws ExecutionException {\n     CacheLoader<Object, Object> loader = errorLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionError expected = assertThrows(ExecutionError.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionError.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Error callableError = new Error();\n     expected =\n@@ -892,18 +892,18 @@ public Object call() {\n                     }));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableError);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionError.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadError() throws ExecutionException {\n@@ -925,32 +925,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadFutureError() throws ExecutionException {\n@@ -972,32 +972,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshError() {\n@@ -1025,42 +1025,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadError() throws ExecutionException {\n@@ -1069,19 +1069,19 @@ public void testBulkLoadError() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionError expected =\n         assertThrows(ExecutionError.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadCheckedException() {\n@@ -1089,35 +1089,35 @@ public void testLoadCheckedException() {\n     CacheLoader<Object, Object> loader = exceptionLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception expected = assertThrows(ExecutionException.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception callableException = new Exception();\n     expected =\n@@ -1125,18 +1125,18 @@ public void testLoadCheckedException() {\n             ExecutionException.class, () -> cache.get(new Object(), throwing(callableException)));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadInterruptedException() {\n@@ -1144,62 +1144,62 @@ public void testLoadInterruptedException() {\n     CacheLoader<Object, Object> loader = exceptionLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     // Sanity check:\n-    assertFalse(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isFalse();\n \n     Exception expected = assertThrows(ExecutionException.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception callableException = new InterruptedException();\n     expected =\n         assertThrows(\n             ExecutionException.class, () -> cache.get(new Object(), throwing(callableException)));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadCheckedException() {\n@@ -1221,32 +1221,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) throws Excep\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadFutureCheckedException() {\n@@ -1268,32 +1268,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshCheckedException() {\n@@ -1321,42 +1321,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadCheckedException() {\n@@ -1365,19 +1365,19 @@ public void testBulkLoadCheckedException() {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionException expected =\n         assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testBulkLoadInterruptedException() {\n@@ -1386,20 +1386,20 @@ public void testBulkLoadInterruptedException() {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionException expected =\n         assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadUncheckedException() throws ExecutionException {\n@@ -1407,36 +1407,36 @@ public void testLoadUncheckedException() throws ExecutionException {\n     CacheLoader<Object, Object> loader = exceptionLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     UncheckedExecutionException expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception callableException = new RuntimeException();\n     expected =\n@@ -1445,19 +1445,19 @@ public void testLoadUncheckedException() throws ExecutionException {\n             () -> cache.get(new Object(), throwing(callableException)));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadUncheckedException() throws ExecutionException {\n@@ -1479,32 +1479,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) throws Excep\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadFutureUncheckedException() throws ExecutionException {\n@@ -1526,32 +1526,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshUncheckedException() {\n@@ -1579,42 +1579,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadUncheckedException() throws ExecutionException {\n@@ -1623,19 +1623,19 @@ public void testBulkLoadUncheckedException() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     UncheckedExecutionException expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadAfterFailure() throws ExecutionException {\n@@ -1660,15 +1660,15 @@ public String load(Integer key) throws Exception {\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(1));\n     assertThat(ue).hasCauseThat().isSameInstanceAs(e);\n \n-    assertEquals(\"1\", cache.getUnchecked(1));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(cache.getUnchecked(1)).isEqualTo(\"1\");\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n \n     count.set(0);\n     cache.refresh(2);\n     checkLoggedCause(e);\n \n-    assertEquals(\"2\", cache.getUnchecked(2));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(cache.getUnchecked(2)).isEqualTo(\"2\");\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n   }\n \n \n@@ -1693,7 +1693,7 @@ public void testReloadAfterValueReclamation() throws InterruptedException, Execu\n       Thread.sleep(i);\n       System.gc();\n     }\n-    assertEquals(expectedComputations, countingLoader.getCount());\n+    assertThat(countingLoader.getCount()).isEqualTo(expectedComputations);\n \n     for (int i = 0; i < iterations; i++) {\n       // The entry should get garbage collected and recomputed.\n@@ -1708,7 +1708,7 @@ public void testReloadAfterValueReclamation() throws InterruptedException, Execu\n       Thread.sleep(i);\n       System.gc();\n     }\n-    assertEquals(expectedComputations, countingLoader.getCount());\n+    assertThat(countingLoader.getCount()).isEqualTo(expectedComputations);\n   }\n \n   public void testReloadAfterSimulatedValueReclamation() throws ExecutionException {\n@@ -1717,20 +1717,20 @@ public void testReloadAfterSimulatedValueReclamation() throws ExecutionException\n         CacheBuilder.newBuilder().concurrencyLevel(1).weakValues().build(countingLoader);\n \n     Object key = new Object();\n-    assertNotNull(cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n \n     CacheTesting.simulateValueReclamation(cache, key);\n \n     // this blocks if computation can't deal with partially-collected values\n-    assertNotNull(cache.getUnchecked(key));\n-    assertEquals(1, cache.size());\n-    assertEquals(2, countingLoader.getCount());\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n+    assertThat(cache.size()).isEqualTo(1);\n+    assertThat(countingLoader.getCount()).isEqualTo(2);\n \n     CacheTesting.simulateValueReclamation(cache, key);\n     cache.refresh(key);\n     checkNothingLogged();\n-    assertEquals(1, cache.size());\n-    assertEquals(3, countingLoader.getCount());\n+    assertThat(cache.size()).isEqualTo(1);\n+    assertThat(countingLoader.getCount()).isEqualTo(3);\n   }\n \n   public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {\n@@ -1739,19 +1739,19 @@ public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {\n         CacheBuilder.newBuilder().concurrencyLevel(1).weakKeys().build(countingLoader);\n \n     Object key = new Object();\n-    assertNotNull(cache.getUnchecked(key));\n-    assertEquals(1, cache.size());\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n+    assertThat(cache.size()).isEqualTo(1);\n \n     CacheTesting.simulateKeyReclamation(cache, key);\n \n     // this blocks if computation can't deal with partially-collected values\n-    assertNotNull(cache.getUnchecked(key));\n-    assertEquals(2, countingLoader.getCount());\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n+    assertThat(countingLoader.getCount()).isEqualTo(2);\n \n     CacheTesting.simulateKeyReclamation(cache, key);\n     cache.refresh(key);\n     checkNothingLogged();\n-    assertEquals(3, countingLoader.getCount());\n+    assertThat(countingLoader.getCount()).isEqualTo(3);\n   }\n \n   /**\n@@ -1864,9 +1864,11 @@ public Object load(String key) throws InterruptedException {\n \n     List<Object> resultArray = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n-      assertSame(\"result(\" + i + \") didn't match expected\", result, resultArray.get(i));\n+      assertWithMessage(\"result(%s) didn't match expected\", i)\n+          .that(resultArray.get(i))\n+          .isSameInstanceAs(result);\n     }\n   }\n \n@@ -1896,18 +1898,14 @@ public String load(String key) throws InterruptedException {\n \n     List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n       assertThat(result.get(i)).isInstanceOf(InvalidCacheLoadException.class);\n     }\n \n     // subsequent calls should call the loader again, not get the old exception\n-    try {\n-      cache.getUnchecked(\"bar\");\n-      fail();\n-    } catch (InvalidCacheLoadException expected) {\n-    }\n-    assertEquals(2, callCount.get());\n+    assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(\"bar\"));\n+    assertThat(callCount.get()).isEqualTo(2);\n   }\n \n   /**\n@@ -1936,7 +1934,7 @@ public String load(String key) throws InterruptedException {\n \n     List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n       // doConcurrentGet alternates between calling getUnchecked and calling get, but an unchecked\n       // exception thrown by the loader is always wrapped as an UncheckedExecutionException.\n@@ -1945,12 +1943,8 @@ public String load(String key) throws InterruptedException {\n     }\n \n     // subsequent calls should call the loader again, not get the old exception\n-    try {\n-      cache.getUnchecked(\"bar\");\n-      fail();\n-    } catch (UncheckedExecutionException expected) {\n-    }\n-    assertEquals(2, callCount.get());\n+    assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(\"bar\"));\n+    assertThat(callCount.get()).isEqualTo(2);\n   }\n \n   /**\n@@ -1979,7 +1973,7 @@ public String load(String key) throws IOException, InterruptedException {\n \n     List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n       // doConcurrentGet alternates between calling getUnchecked and calling get. If we call get(),\n       // we should get an ExecutionException; if we call getUnchecked(), we should get an\n@@ -1995,12 +1989,8 @@ public String load(String key) throws IOException, InterruptedException {\n     }\n \n     // subsequent calls should call the loader again, not get the old exception\n-    try {\n-      cache.getUnchecked(\"bar\");\n-      fail();\n-    } catch (UncheckedExecutionException expected) {\n-    }\n-    assertEquals(2, callCount.get());\n+    assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(\"bar\"));\n+    assertThat(callCount.get()).isEqualTo(2);\n   }\n \n   /**\n@@ -2084,9 +2074,9 @@ public String load(String key) throws InterruptedException {\n     LoadingCache<String, String> cache = CacheBuilder.newBuilder().build(computeFunction);\n     ConcurrentMap<String, String> map = cache.asMap();\n     map.put(refreshKey, refreshKey);\n-    assertEquals(1, map.size());\n-    assertFalse(map.containsKey(getKey));\n-    assertSame(refreshKey, map.get(refreshKey));\n+    assertThat(map).hasSize(1);\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.get(refreshKey)).isSameInstanceAs(refreshKey);\n \n     new Thread() {\n       @Override\n@@ -2106,9 +2096,9 @@ public void run() {\n     getStartedSignal.await();\n \n     // computation is in progress; asMap shouldn't have changed\n-    assertEquals(1, map.size());\n-    assertFalse(map.containsKey(getKey));\n-    assertSame(refreshKey, map.get(refreshKey));\n+    assertThat(map).hasSize(1);\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.get(refreshKey)).isSameInstanceAs(refreshKey);\n \n     // let computation complete\n     letGetFinishSignal.countDown();\n@@ -2116,9 +2106,9 @@ public void run() {\n     checkNothingLogged();\n \n     // asMap view should have been updated\n-    assertEquals(2, cache.size());\n-    assertEquals(getKey + suffix, map.get(getKey));\n-    assertEquals(refreshKey + suffix, map.get(refreshKey));\n+    assertThat(cache.size()).isEqualTo(2);\n+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);\n+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);\n   }\n \n   public void testInvalidateDuringLoading() throws InterruptedException, ExecutionException {\n@@ -2162,8 +2152,8 @@ public void run() {\n     computationStarted.await();\n     cache.invalidate(getKey);\n     cache.invalidate(refreshKey);\n-    assertFalse(map.containsKey(getKey));\n-    assertFalse(map.containsKey(refreshKey));\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.containsKey(refreshKey)).isFalse();\n \n     // let computation complete\n     letGetFinishSignal.countDown();\n@@ -2171,10 +2161,10 @@ public void run() {\n     checkNothingLogged();\n \n     // results should be visible\n-    assertEquals(2, cache.size());\n-    assertEquals(getKey + suffix, map.get(getKey));\n-    assertEquals(refreshKey + suffix, map.get(refreshKey));\n-    assertEquals(2, cache.size());\n+    assertThat(cache.size()).isEqualTo(2);\n+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);\n+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);\n+    assertThat(cache.size()).isEqualTo(2);\n   }\n \n   public void testInvalidateAndReloadDuringLoading()\n@@ -2219,8 +2209,8 @@ public void run() {\n     computationStarted.await();\n     cache.invalidate(getKey);\n     cache.invalidate(refreshKey);\n-    assertFalse(map.containsKey(getKey));\n-    assertFalse(map.containsKey(refreshKey));\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.containsKey(refreshKey)).isFalse();\n \n     // start new computations\n     new Thread() {\n@@ -2244,9 +2234,9 @@ public void run() {\n     checkNothingLogged();\n \n     // results should be visible\n-    assertEquals(2, cache.size());\n-    assertEquals(getKey + suffix, map.get(getKey));\n-    assertEquals(refreshKey + suffix, map.get(refreshKey));\n+    assertThat(cache.size()).isEqualTo(2);\n+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);\n+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);\n   }\n \n   @SuppressWarnings(\"ThreadPriorityCheck\") // doing our best to test for races\n@@ -2331,11 +2321,11 @@ public void run() {\n     computeSignal.countDown();\n     doneSignal.await();\n \n-    assertTrue(callCount.get() == 1);\n-    assertEquals(\"barfoo\", result.get(0));\n-    assertEquals(\"barfoo\", result.get(1));\n-    assertEquals(\"barfoo\", result.get(2));\n-    assertEquals(\"barfoo\", cache.getUnchecked(key));\n+    assertThat(callCount.get()).isEqualTo(1);\n+    assertThat(result.get(0)).isEqualTo(\"barfoo\");\n+    assertThat(result.get(1)).isEqualTo(\"barfoo\");\n+    assertThat(result.get(2)).isEqualTo(\"barfoo\");\n+    assertThat(cache.getUnchecked(key)).isEqualTo(\"barfoo\");\n   }\n \n   // Test ignored because it is extremely flaky in CI builds\n@@ -2423,10 +2413,10 @@ public void run() {\n     computeSignal.countDown();\n     doneSignal.await();\n \n-    assertTrue(callCount.get() == 1);\n-    assertEquals(key, result.get(0));\n-    assertEquals(key, result.get(1));\n-    assertEquals(key + suffix, cache.getUnchecked(key));\n+    assertThat(callCount.get()).isEqualTo(1);\n+    assertThat(result.get(0)).isEqualTo(key);\n+    assertThat(result.get(1)).isEqualTo(key);\n+    assertThat(cache.getUnchecked(key)).isEqualTo(key + suffix);\n   }\n \n   static <T> Callable<T> throwing(Exception exception) {\ndiff --git a/android/guava-tests/test/com/google/common/cache/CacheManualTest.java b/android/guava-tests/test/com/google/common/cache/CacheManualTest.java\nindex a2cf24dcef28..e3b358a738b0 100644\n--- a/android/guava-tests/test/com/google/common/cache/CacheManualTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/CacheManualTest.java\n@@ -14,6 +14,7 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.Arrays.asList;\n \n import com.google.common.collect.ImmutableList;\n@@ -30,126 +31,127 @@ public class CacheManualTest extends TestCase {\n   public void testGetIfPresent() {\n     Cache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Object one = new Object();\n     Object two = new Object();\n \n-    assertNull(cache.getIfPresent(one));\n+    assertThat(cache.getIfPresent(one)).isNull();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n-    assertNull(cache.asMap().get(one));\n-    assertFalse(cache.asMap().containsKey(one));\n-    assertFalse(cache.asMap().containsValue(two));\n-\n-    assertNull(cache.getIfPresent(two));\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n+    assertThat(cache.asMap().get(one)).isNull();\n+    assertThat(cache.asMap().containsKey(one)).isFalse();\n+    assertThat(cache.asMap().containsValue(two)).isFalse();\n+\n+    assertThat(cache.getIfPresent(two)).isNull();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n-    assertNull(cache.asMap().get(two));\n-    assertFalse(cache.asMap().containsKey(two));\n-    assertFalse(cache.asMap().containsValue(one));\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n+    assertThat(cache.asMap().get(two)).isNull();\n+    assertThat(cache.asMap().containsKey(two)).isFalse();\n+    assertThat(cache.asMap().containsValue(one)).isFalse();\n \n     cache.put(one, two);\n \n-    assertSame(two, cache.getIfPresent(one));\n+    assertThat(cache.getIfPresent(one)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n-    assertSame(two, cache.asMap().get(one));\n-    assertTrue(cache.asMap().containsKey(one));\n-    assertTrue(cache.asMap().containsValue(two));\n-\n-    assertNull(cache.getIfPresent(two));\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n+    assertThat(cache.asMap().get(one)).isSameInstanceAs(two);\n+    assertThat(cache.asMap().containsKey(one)).isTrue();\n+    assertThat(cache.asMap().containsValue(two)).isTrue();\n+\n+    assertThat(cache.getIfPresent(two)).isNull();\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n-    assertNull(cache.asMap().get(two));\n-    assertFalse(cache.asMap().containsKey(two));\n-    assertFalse(cache.asMap().containsValue(one));\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n+    assertThat(cache.asMap().get(two)).isNull();\n+    assertThat(cache.asMap().containsKey(two)).isFalse();\n+    assertThat(cache.asMap().containsValue(one)).isFalse();\n \n     cache.put(two, one);\n \n-    assertSame(two, cache.getIfPresent(one));\n+    assertThat(cache.getIfPresent(one)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n-    assertSame(two, cache.asMap().get(one));\n-    assertTrue(cache.asMap().containsKey(one));\n-    assertTrue(cache.asMap().containsValue(two));\n-\n-    assertSame(one, cache.getIfPresent(two));\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n+    assertThat(cache.asMap().get(one)).isSameInstanceAs(two);\n+    assertThat(cache.asMap().containsKey(one)).isTrue();\n+    assertThat(cache.asMap().containsValue(two)).isTrue();\n+\n+    assertThat(cache.getIfPresent(two)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n-    assertSame(one, cache.asMap().get(two));\n-    assertTrue(cache.asMap().containsKey(two));\n-    assertTrue(cache.asMap().containsValue(one));\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n+    assertThat(cache.asMap().get(two)).isSameInstanceAs(one);\n+    assertThat(cache.asMap().containsKey(two)).isTrue();\n+    assertThat(cache.asMap().containsValue(one)).isTrue();\n   }\n \n   public void testGetAllPresent() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().recordStats().build();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAllPresent(ImmutableList.<Integer>of()));\n+    assertThat(cache.getAllPresent(ImmutableList.<Integer>of())).isEmpty();\n     stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3))).isEqualTo(ImmutableMap.of());\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.put(2, 22);\n \n-    assertEquals(ImmutableMap.of(2, 22), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3))).containsExactly(2, 22);\n     stats = cache.stats();\n-    assertEquals(5, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(5);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     cache.put(3, 33);\n \n-    assertEquals(ImmutableMap.of(2, 22, 3, 33), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3))).containsExactly(2, 22, 3, 33);\n     stats = cache.stats();\n-    assertEquals(6, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(6);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n \n     cache.put(1, 11);\n \n-    assertEquals(ImmutableMap.of(1, 11, 2, 22, 3, 33), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3)))\n+        .isEqualTo(ImmutableMap.of(1, 11, 2, 22, 3, 33));\n     stats = cache.stats();\n-    assertEquals(6, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(6, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(6);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(6);\n   }\n }\ndiff --git a/android/guava-tests/test/com/google/common/cache/CacheReferencesTest.java b/android/guava-tests/test/com/google/common/cache/CacheReferencesTest.java\nindex 5426d29141f5..11ce62e0a0b1 100644\n--- a/android/guava-tests/test/com/google/common/cache/CacheReferencesTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/CacheReferencesTest.java\n@@ -66,10 +66,10 @@ public void testContainsKeyAndValue() {\n       // maintain strong refs so these won't be collected, regardless of cache's key/value strength\n       Key key = new Key(1);\n       String value = key.toString();\n-      assertSame(value, cache.getUnchecked(key));\n-      assertTrue(cache.asMap().containsKey(key));\n-      assertTrue(cache.asMap().containsValue(value));\n-      assertEquals(1, cache.size());\n+      assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().containsKey(key)).isTrue();\n+      assertThat(cache.asMap().containsValue(value)).isTrue();\n+      assertThat(cache.size()).isEqualTo(1);\n     }\n   }\n \n@@ -77,13 +77,13 @@ public void testClear() {\n     for (LoadingCache<Key, String> cache : caches()) {\n       Key key = new Key(1);\n       String value = key.toString();\n-      assertSame(value, cache.getUnchecked(key));\n-      assertFalse(cache.asMap().isEmpty());\n+      assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().isEmpty()).isFalse();\n       cache.invalidateAll();\n-      assertEquals(0, cache.size());\n-      assertTrue(cache.asMap().isEmpty());\n-      assertFalse(cache.asMap().containsKey(key));\n-      assertFalse(cache.asMap().containsValue(value));\n+      assertThat(cache.size()).isEqualTo(0);\n+      assertThat(cache.asMap().isEmpty()).isTrue();\n+      assertThat(cache.asMap().containsKey(key)).isFalse();\n+      assertThat(cache.asMap().containsValue(value)).isFalse();\n     }\n   }\n \n@@ -93,13 +93,12 @@ public void testKeySetEntrySetValues() {\n       String value1 = key1.toString();\n       Key key2 = new Key(2);\n       String value2 = key2.toString();\n-      assertSame(value1, cache.getUnchecked(key1));\n-      assertSame(value2, cache.getUnchecked(key2));\n-      assertEquals(ImmutableSet.of(key1, key2), cache.asMap().keySet());\n+      assertThat(cache.getUnchecked(key1)).isSameInstanceAs(value1);\n+      assertThat(cache.getUnchecked(key2)).isSameInstanceAs(value2);\n+      assertThat(cache.asMap().keySet()).isEqualTo(ImmutableSet.of(key1, key2));\n       assertThat(cache.asMap().values()).containsExactly(value1, value2);\n-      assertEquals(\n-          ImmutableSet.of(immutableEntry(key1, value1), immutableEntry(key2, value2)),\n-          cache.asMap().entrySet());\n+      assertThat(cache.asMap().entrySet())\n+          .containsExactly(immutableEntry(key1, value1), immutableEntry(key2, value2));\n     }\n   }\n \n@@ -109,15 +108,15 @@ public void testInvalidate() {\n       String value1 = key1.toString();\n       Key key2 = new Key(2);\n       String value2 = key2.toString();\n-      assertSame(value1, cache.getUnchecked(key1));\n-      assertSame(value2, cache.getUnchecked(key2));\n+      assertThat(cache.getUnchecked(key1)).isSameInstanceAs(value1);\n+      assertThat(cache.getUnchecked(key2)).isSameInstanceAs(value2);\n       cache.invalidate(key1);\n-      assertFalse(cache.asMap().containsKey(key1));\n-      assertTrue(cache.asMap().containsKey(key2));\n-      assertEquals(1, cache.size());\n-      assertEquals(ImmutableSet.of(key2), cache.asMap().keySet());\n+      assertThat(cache.asMap().containsKey(key1)).isFalse();\n+      assertThat(cache.asMap().containsKey(key2)).isTrue();\n+      assertThat(cache.size()).isEqualTo(1);\n+      assertThat(cache.asMap().keySet()).isEqualTo(ImmutableSet.of(key2));\n       assertThat(cache.asMap().values()).contains(value2);\n-      assertEquals(ImmutableSet.of(immutableEntry(key2, value2)), cache.asMap().entrySet());\n+      assertThat(cache.asMap().entrySet()).containsExactly(immutableEntry(key2, value2));\n     }\n   }\n \ndiff --git a/android/guava-tests/test/com/google/common/cache/CacheRefreshTest.java b/android/guava-tests/test/com/google/common/cache/CacheRefreshTest.java\nindex 6a7948c470dc..83c3ea3b5777 100644\n--- a/android/guava-tests/test/com/google/common/cache/CacheRefreshTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/CacheRefreshTest.java\n@@ -15,6 +15,7 @@\n package com.google.common.cache;\n \n import static com.google.common.cache.TestingCacheLoaders.incrementingLoader;\n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n \n import com.google.common.cache.TestingCacheLoaders.IncrementingLoader;\n@@ -42,61 +43,61 @@ public void testAutoRefresh() {\n     int expectedLoads = 0;\n     int expectedReloads = 0;\n     for (int i = 0; i < 3; i++) {\n-      assertEquals(Integer.valueOf(i), cache.getUnchecked(i));\n+      assertThat(cache.getUnchecked(i)).isEqualTo(i);\n       expectedLoads++;\n-      assertEquals(expectedLoads, loader.getLoadCount());\n-      assertEquals(expectedReloads, loader.getReloadCount());\n+      assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+      assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n       ticker.advance(1, MILLISECONDS);\n     }\n \n-    assertEquals(Integer.valueOf(0), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(0)).isEqualTo(0);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // refresh 0\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n     expectedReloads++;\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(1)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // write to 1 to delay its refresh\n     cache.asMap().put(1, -1);\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // refresh 2\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(3);\n     expectedReloads++;\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(3);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // refresh 0 and 1\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(0));\n+    assertThat(cache.getUnchecked(0)).isEqualTo(2);\n     expectedReloads++;\n-    assertEquals(Integer.valueOf(0), cache.getUnchecked(1));\n+    assertThat(cache.getUnchecked(1)).isEqualTo(0);\n     expectedReloads++;\n-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(2)).isEqualTo(3);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n   }\n }\ndiff --git a/android/guava-tests/test/com/google/common/cache/CacheStatsTest.java b/android/guava-tests/test/com/google/common/cache/CacheStatsTest.java\nindex cfd174aea242..72cbfee29807 100644\n--- a/android/guava-tests/test/com/google/common/cache/CacheStatsTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/CacheStatsTest.java\n@@ -31,34 +31,34 @@ public class CacheStatsTest extends TestCase {\n \n   public void testEmpty() {\n     CacheStats stats = new CacheStats(0, 0, 0, 0, 0, 0);\n-    assertEquals(0, stats.requestCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n     assertThat(stats.hitRate()).isEqualTo(1.0);\n-    assertEquals(0, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n     assertThat(stats.missRate()).isEqualTo(0.0);\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n     assertThat(stats.loadExceptionRate()).isEqualTo(0.0);\n-    assertEquals(0, stats.loadCount());\n-    assertEquals(0, stats.totalLoadTime());\n+    assertThat(stats.loadCount()).isEqualTo(0);\n+    assertThat(stats.totalLoadTime()).isEqualTo(0);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n   }\n \n   public void testSingle() {\n     CacheStats stats = new CacheStats(11, 13, 17, 19, 23, 27);\n-    assertEquals(24, stats.requestCount());\n-    assertEquals(11, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(24);\n+    assertThat(stats.hitCount()).isEqualTo(11);\n     assertThat(stats.hitRate()).isEqualTo(11.0 / 24);\n-    assertEquals(13, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(13);\n     assertThat(stats.missRate()).isEqualTo(13.0 / 24);\n-    assertEquals(17, stats.loadSuccessCount());\n-    assertEquals(19, stats.loadExceptionCount());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(17);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(19);\n     assertThat(stats.loadExceptionRate()).isEqualTo(19.0 / 36);\n-    assertEquals(17 + 19, stats.loadCount());\n-    assertEquals(23, stats.totalLoadTime());\n+    assertThat(stats.loadCount()).isEqualTo(17 + 19);\n+    assertThat(stats.totalLoadTime()).isEqualTo(23);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(23.0 / (17 + 19));\n-    assertEquals(27, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(27);\n   }\n \n   public void testMinus() {\n@@ -66,20 +66,20 @@ public void testMinus() {\n     CacheStats two = new CacheStats(53, 47, 43, 41, 37, 31);\n \n     CacheStats diff = two.minus(one);\n-    assertEquals(76, diff.requestCount());\n-    assertEquals(42, diff.hitCount());\n+    assertThat(diff.requestCount()).isEqualTo(76);\n+    assertThat(diff.hitCount()).isEqualTo(42);\n     assertThat(diff.hitRate()).isEqualTo(42.0 / 76);\n-    assertEquals(34, diff.missCount());\n+    assertThat(diff.missCount()).isEqualTo(34);\n     assertThat(diff.missRate()).isEqualTo(34.0 / 76);\n-    assertEquals(26, diff.loadSuccessCount());\n-    assertEquals(22, diff.loadExceptionCount());\n+    assertThat(diff.loadSuccessCount()).isEqualTo(26);\n+    assertThat(diff.loadExceptionCount()).isEqualTo(22);\n     assertThat(diff.loadExceptionRate()).isEqualTo(22.0 / 48);\n-    assertEquals(26 + 22, diff.loadCount());\n-    assertEquals(14, diff.totalLoadTime());\n+    assertThat(diff.loadCount()).isEqualTo(26 + 22);\n+    assertThat(diff.totalLoadTime()).isEqualTo(14);\n     assertThat(diff.averageLoadPenalty()).isEqualTo(14.0 / (26 + 22));\n-    assertEquals(4, diff.evictionCount());\n+    assertThat(diff.evictionCount()).isEqualTo(4);\n \n-    assertEquals(new CacheStats(0, 0, 0, 0, 0, 0), one.minus(two));\n+    assertThat(one.minus(two)).isEqualTo(new CacheStats(0, 0, 0, 0, 0, 0));\n   }\n \n   public void testPlus() {\n@@ -87,20 +87,20 @@ public void testPlus() {\n     CacheStats two = new CacheStats(53, 47, 41, 39, 37, 35);\n \n     CacheStats sum = two.plus(one);\n-    assertEquals(124, sum.requestCount());\n-    assertEquals(64, sum.hitCount());\n+    assertThat(sum.requestCount()).isEqualTo(124);\n+    assertThat(sum.hitCount()).isEqualTo(64);\n     assertThat(sum.hitRate()).isEqualTo(64.0 / 124);\n-    assertEquals(60, sum.missCount());\n+    assertThat(sum.missCount()).isEqualTo(60);\n     assertThat(sum.missRate()).isEqualTo(60.0 / 124);\n-    assertEquals(56, sum.loadSuccessCount());\n-    assertEquals(52, sum.loadExceptionCount());\n+    assertThat(sum.loadSuccessCount()).isEqualTo(56);\n+    assertThat(sum.loadExceptionCount()).isEqualTo(52);\n     assertThat(sum.loadExceptionRate()).isEqualTo(52.0 / 108);\n-    assertEquals(56 + 52, sum.loadCount());\n-    assertEquals(48, sum.totalLoadTime());\n+    assertThat(sum.loadCount()).isEqualTo(56 + 52);\n+    assertThat(sum.totalLoadTime()).isEqualTo(48);\n     assertThat(sum.averageLoadPenalty()).isEqualTo(48.0 / (56 + 52));\n-    assertEquals(44, sum.evictionCount());\n+    assertThat(sum.evictionCount()).isEqualTo(44);\n \n-    assertEquals(sum, one.plus(two));\n+    assertThat(one.plus(two)).isEqualTo(sum);\n   }\n \n   public void testPlusLarge() {\n@@ -115,19 +115,19 @@ public void testPlusLarge() {\n     CacheStats smallCacheStats = new CacheStats(1, 1, 1, 1, 1, 1);\n \n     CacheStats sum = smallCacheStats.plus(maxCacheStats);\n-    assertEquals(Long.MAX_VALUE, sum.requestCount());\n-    assertEquals(Long.MAX_VALUE, sum.hitCount());\n+    assertThat(sum.requestCount()).isEqualTo(Long.MAX_VALUE);\n+    assertThat(sum.hitCount()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.hitRate()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.missCount());\n+    assertThat(sum.missCount()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.missRate()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.loadSuccessCount());\n-    assertEquals(Long.MAX_VALUE, sum.loadExceptionCount());\n+    assertThat(sum.loadSuccessCount()).isEqualTo(Long.MAX_VALUE);\n+    assertThat(sum.loadExceptionCount()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.loadExceptionRate()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.loadCount());\n-    assertEquals(Long.MAX_VALUE, sum.totalLoadTime());\n+    assertThat(sum.loadCount()).isEqualTo(Long.MAX_VALUE);\n+    assertThat(sum.totalLoadTime()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.averageLoadPenalty()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.evictionCount());\n+    assertThat(sum.evictionCount()).isEqualTo(Long.MAX_VALUE);\n \n-    assertEquals(sum, maxCacheStats.plus(smallCacheStats));\n+    assertThat(maxCacheStats.plus(smallCacheStats)).isEqualTo(sum);\n   }\n }\ndiff --git a/android/guava-tests/test/com/google/common/cache/CacheTesting.java b/android/guava-tests/test/com/google/common/cache/CacheTesting.java\nindex 5c27308ed868..6c33cde9d009 100644\n--- a/android/guava-tests/test/com/google/common/cache/CacheTesting.java\n+++ b/android/guava-tests/test/com/google/common/cache/CacheTesting.java\n@@ -16,15 +16,9 @@\n \n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.lang.Math.max;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n-import static junit.framework.Assert.assertEquals;\n-import static junit.framework.Assert.assertFalse;\n-import static junit.framework.Assert.assertNotNull;\n-import static junit.framework.Assert.assertNotSame;\n-import static junit.framework.Assert.assertNull;\n-import static junit.framework.Assert.assertSame;\n-import static junit.framework.Assert.assertTrue;\n \n import com.google.common.base.Preconditions;\n import com.google.common.cache.LocalCache.LocalLoadingCache;\n@@ -194,16 +188,16 @@ static void checkValidState(Cache<?, ?> cache) {\n   static void checkValidState(LocalCache<?, ?> cchm) {\n     for (Segment<?, ?> segment : cchm.segments) {\n       segment.cleanUp();\n-      assertFalse(segment.isLocked());\n+      assertThat(segment.isLocked()).isFalse();\n       Map<?, ?> table = segmentTable(segment);\n       // cleanup and then check count after we have a strong reference to all entries\n       segment.cleanUp();\n       // under high memory pressure keys/values may be nulled out but not yet enqueued\n       assertThat(table.size()).isAtMost(segment.count);\n       for (Entry<?, ?> entry : table.entrySet()) {\n-        assertNotNull(entry.getKey());\n-        assertNotNull(entry.getValue());\n-        assertSame(entry.getValue(), cchm.get(entry.getKey()));\n+        assertThat(entry.getKey()).isNotNull();\n+        assertThat(entry.getValue()).isNotNull();\n+        assertThat(cchm.get(entry.getKey())).isSameInstanceAs(entry.getValue());\n       }\n     }\n     checkEviction(cchm);\n@@ -228,21 +222,21 @@ static void checkExpiration(LocalCache<?, ?> cchm) {\n \n         ReferenceEntry<?, ?> prev = null;\n         for (ReferenceEntry<?, ?> current : segment.writeQueue) {\n-          assertTrue(entries.add(current));\n+          assertThat(entries.add(current)).isTrue();\n           if (prev != null) {\n-            assertSame(prev, current.getPreviousInWriteQueue());\n-            assertSame(prev.getNextInWriteQueue(), current);\n+            assertThat(current.getPreviousInWriteQueue()).isSameInstanceAs(prev);\n+            assertThat(current).isSameInstanceAs(prev.getNextInWriteQueue());\n             assertThat(prev.getWriteTime()).isAtMost(current.getWriteTime());\n           }\n           Object key = current.getKey();\n           if (key != null) {\n-            assertSame(current, segment.getEntry(key, current.getHash()));\n+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);\n           }\n           prev = current;\n         }\n-        assertEquals(segment.count, entries.size());\n+        assertThat(entries).hasSize(segment.count);\n       } else {\n-        assertTrue(segment.writeQueue.isEmpty());\n+        assertThat(segment.writeQueue.isEmpty()).isTrue();\n       }\n \n       if (cchm.usesAccessQueue()) {\n@@ -250,24 +244,25 @@ static void checkExpiration(LocalCache<?, ?> cchm) {\n \n         ReferenceEntry<?, ?> prev = null;\n         for (ReferenceEntry<?, ?> current : segment.accessQueue) {\n-          assertTrue(entries.add(current));\n+          assertThat(entries.add(current)).isTrue();\n           if (prev != null) {\n-            assertSame(prev, current.getPreviousInAccessQueue());\n-            assertSame(prev.getNextInAccessQueue(), current);\n+            assertThat(current.getPreviousInAccessQueue()).isSameInstanceAs(prev);\n+            assertThat(current).isSameInstanceAs(prev.getNextInAccessQueue());\n             // read accesses may be slightly misordered\n-            assertTrue(\n-                prev.getAccessTime() <= current.getAccessTime()\n-                    || prev.getAccessTime() - current.getAccessTime() < 1000);\n+            assertThat(\n+                    prev.getAccessTime() <= current.getAccessTime()\n+                        || prev.getAccessTime() - current.getAccessTime() < 1000)\n+                .isTrue();\n           }\n           Object key = current.getKey();\n           if (key != null) {\n-            assertSame(current, segment.getEntry(key, current.getHash()));\n+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);\n           }\n           prev = current;\n         }\n-        assertEquals(segment.count, entries.size());\n+        assertThat(entries).hasSize(segment.count);\n       } else {\n-        assertTrue(segment.accessQueue.isEmpty());\n+        assertThat(segment.accessQueue).isEmpty();\n       }\n     }\n   }\n@@ -287,25 +282,25 @@ static void checkEviction(LocalCache<?, ?> map) {\n     if (map.evictsBySize()) {\n       for (Segment<?, ?> segment : map.segments) {\n         drainRecencyQueue(segment);\n-        assertEquals(0, segment.recencyQueue.size());\n-        assertEquals(0, segment.readCount.get());\n+        assertThat(segment.recencyQueue).isEmpty();\n+        assertThat(segment.readCount.get()).isEqualTo(0);\n \n         ReferenceEntry<?, ?> prev = null;\n         for (ReferenceEntry<?, ?> current : segment.accessQueue) {\n           if (prev != null) {\n-            assertSame(prev, current.getPreviousInAccessQueue());\n-            assertSame(prev.getNextInAccessQueue(), current);\n+            assertThat(current.getPreviousInAccessQueue()).isSameInstanceAs(prev);\n+            assertThat(current).isSameInstanceAs(prev.getNextInAccessQueue());\n           }\n           Object key = current.getKey();\n           if (key != null) {\n-            assertSame(current, segment.getEntry(key, current.getHash()));\n+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);\n           }\n           prev = current;\n         }\n       }\n     } else {\n       for (Segment<?, ?> segment : map.segments) {\n-        assertEquals(0, segment.recencyQueue.size());\n+        assertThat(segment.recencyQueue).isEmpty();\n       }\n     }\n   }\n@@ -323,7 +318,7 @@ static <K, V> Map<K, V> segmentTable(Segment<K, V> segment) {\n         K key = entry.getKey();\n         V value = entry.getValueReference().get();\n         if (key != null && value != null) {\n-          assertNull(map.put(key, value));\n+          assertThat(map.put(key, value)).isNull();\n         }\n       }\n     }\n@@ -390,8 +385,8 @@ static void checkRecency(\n       LocalCache<Integer, Integer> cchm = toLocalCache(cache);\n       Segment<?, ?> segment = cchm.segments[0];\n       drainRecencyQueue(segment);\n-      assertEquals(maxSize, accessQueueSize(cache));\n-      assertEquals(maxSize, cache.size());\n+      assertThat(accessQueueSize(cache)).isEqualTo(maxSize);\n+      assertThat(cache.size()).isEqualTo(maxSize);\n \n       ReferenceEntry<?, ?> originalHead = segment.accessQueue.peek();\n       @SuppressWarnings(\"unchecked\")\n@@ -399,8 +394,8 @@ static void checkRecency(\n       operation.accept(entry);\n       drainRecencyQueue(segment);\n \n-      assertNotSame(originalHead, segment.accessQueue.peek());\n-      assertEquals(cache.size(), accessQueueSize(cache));\n+      assertThat(segment.accessQueue.peek()).isNotSameInstanceAs(originalHead);\n+      assertThat(accessQueueSize(cache)).isEqualTo(cache.size());\n     }\n   }\n \n@@ -428,9 +423,13 @@ static void expireEntries(LocalCache<?, ?> cchm, long expiringTime, FakeTicker t\n     long now = ticker.read();\n     for (Segment<?, ?> segment : cchm.segments) {\n       expireEntries(segment, now);\n-      assertEquals(\"Expiration queue must be empty by now\", 0, writeQueueSize(segment));\n-      assertEquals(\"Expiration queue must be empty by now\", 0, accessQueueSize(segment));\n-      assertEquals(\"Segments must be empty by now\", 0, segmentSize(segment));\n+      assertWithMessage(\"Expiration queue must be empty by now\")\n+          .that(writeQueueSize(segment))\n+          .isEqualTo(0);\n+      assertWithMessage(\"Expiration queue must be empty by now\")\n+          .that(accessQueueSize(segment))\n+          .isEqualTo(0);\n+      assertWithMessage(\"Segments must be empty by now\").that(segmentSize(segment)).isEqualTo(0);\n     }\n     cchm.processPendingNotifications();\n   }\n@@ -446,11 +445,11 @@ static void expireEntries(Segment<?, ?> segment, long now) {\n   }\n \n   static void checkEmpty(Cache<?, ?> cache) {\n-    assertEquals(0, cache.size());\n-    assertFalse(cache.asMap().containsKey(null));\n-    assertFalse(cache.asMap().containsKey(6));\n-    assertFalse(cache.asMap().containsValue(null));\n-    assertFalse(cache.asMap().containsValue(6));\n+    assertThat(cache.size()).isEqualTo(0);\n+    assertThat(cache.asMap().containsKey(null)).isFalse();\n+    assertThat(cache.asMap().containsKey(6)).isFalse();\n+    assertThat(cache.asMap().containsValue(null)).isFalse();\n+    assertThat(cache.asMap().containsValue(6)).isFalse();\n     checkEmpty(cache.asMap());\n   }\n \n@@ -458,29 +457,29 @@ static void checkEmpty(ConcurrentMap<?, ?> map) {\n     checkEmpty(map.keySet());\n     checkEmpty(map.values());\n     checkEmpty(map.entrySet());\n-    assertEquals(ImmutableMap.of(), map);\n-    assertEquals(ImmutableMap.of().hashCode(), map.hashCode());\n-    assertEquals(ImmutableMap.of().toString(), map.toString());\n+    assertThat(map).isEqualTo(ImmutableMap.of());\n+    assertThat(map.hashCode()).isEqualTo(ImmutableMap.of().hashCode());\n+    assertThat(map.toString()).isEqualTo(ImmutableMap.of().toString());\n \n     if (map instanceof LocalCache) {\n       LocalCache<?, ?> cchm = (LocalCache<?, ?>) map;\n \n       checkValidState(cchm);\n-      assertTrue(cchm.isEmpty());\n-      assertEquals(0, cchm.size());\n+      assertThat(cchm.isEmpty()).isTrue();\n+      assertThat(cchm).isEmpty();\n       for (LocalCache.Segment<?, ?> segment : cchm.segments) {\n-        assertEquals(0, segment.count);\n-        assertEquals(0, segmentSize(segment));\n-        assertTrue(segment.writeQueue.isEmpty());\n-        assertTrue(segment.accessQueue.isEmpty());\n+        assertThat(segment.count).isEqualTo(0);\n+        assertThat(segmentSize(segment)).isEqualTo(0);\n+        assertThat(segment.writeQueue.isEmpty()).isTrue();\n+        assertThat(segment.accessQueue.isEmpty()).isTrue();\n       }\n     }\n   }\n \n   static void checkEmpty(Collection<?> collection) {\n-    assertTrue(collection.isEmpty());\n-    assertEquals(0, collection.size());\n-    assertFalse(collection.iterator().hasNext());\n+    assertThat(collection.isEmpty()).isTrue();\n+    assertThat(collection).isEmpty();\n+    assertThat(collection.iterator().hasNext()).isFalse();\n     assertThat(collection.toArray()).isEmpty();\n     assertThat(collection.toArray(new Object[0])).isEmpty();\n     if (collection instanceof Set) {\ndiff --git a/android/guava-tests/test/com/google/common/cache/EmptyCachesTest.java b/android/guava-tests/test/com/google/common/cache/EmptyCachesTest.java\nindex f93568bc29a5..94a912347d9d 100644\n--- a/android/guava-tests/test/com/google/common/cache/EmptyCachesTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/EmptyCachesTest.java\n@@ -16,6 +16,7 @@\n \n import static com.google.common.cache.CacheTesting.checkEmpty;\n import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.Arrays.asList;\n import static java.util.concurrent.TimeUnit.DAYS;\n import static java.util.concurrent.TimeUnit.SECONDS;\n@@ -75,7 +76,7 @@ public void testInvalidateAll_empty() {\n \n   public void testEquals_null() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n-      assertFalse(cache.equals(null));\n+      assertThat(cache.equals(null)).isFalse();\n     }\n   }\n \n@@ -138,11 +139,11 @@ public void testKeySet_clear() {\n   public void testKeySet_empty_remove() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       Set<Object> keys = cache.asMap().keySet();\n-      assertFalse(keys.remove(null));\n-      assertFalse(keys.remove(6));\n-      assertFalse(keys.remove(-6));\n-      assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(keys.remove(null)).isFalse();\n+      assertThat(keys.remove(6)).isFalse();\n+      assertThat(keys.remove(-6)).isFalse();\n+      assertThat(keys.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(keys.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(keys);\n       checkEmpty(cache);\n     }\n@@ -158,11 +159,11 @@ public void testKeySet_remove() {\n       // values of these removes, but the cache should be empty after the removes, regardless.\n       keys.remove(1);\n       keys.remove(2);\n-      assertFalse(keys.remove(null));\n-      assertFalse(keys.remove(6));\n-      assertFalse(keys.remove(-6));\n-      assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(keys.remove(null)).isFalse();\n+      assertThat(keys.remove(6)).isFalse();\n+      assertThat(keys.remove(-6)).isFalse();\n+      assertThat(keys.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(keys.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(keys);\n       checkEmpty(cache);\n     }\n@@ -202,11 +203,11 @@ public void testValues_clear() {\n   public void testValues_empty_remove() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       Collection<Object> values = cache.asMap().values();\n-      assertFalse(values.remove(null));\n-      assertFalse(values.remove(6));\n-      assertFalse(values.remove(-6));\n-      assertFalse(values.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(values.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(values.remove(null)).isFalse();\n+      assertThat(values.remove(6)).isFalse();\n+      assertThat(values.remove(-6)).isFalse();\n+      assertThat(values.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(values.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(values);\n       checkEmpty(cache);\n     }\n@@ -222,11 +223,11 @@ public void testValues_remove() {\n       // values of these removes, but the cache should be empty after the removes, regardless.\n       values.remove(1);\n       values.remove(2);\n-      assertFalse(values.remove(null));\n-      assertFalse(values.remove(6));\n-      assertFalse(values.remove(-6));\n-      assertFalse(values.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(values.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(values.remove(null)).isFalse();\n+      assertThat(values.remove(6)).isFalse();\n+      assertThat(values.remove(-6)).isFalse();\n+      assertThat(values.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(values.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(values);\n       checkEmpty(cache);\n     }\n@@ -269,11 +270,11 @@ public void testEntrySet_clear() {\n   public void testEntrySet_empty_remove() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       Set<Entry<Object, Object>> entrySet = cache.asMap().entrySet();\n-      assertFalse(entrySet.remove(null));\n-      assertFalse(entrySet.remove(entryOf(6, 6)));\n-      assertFalse(entrySet.remove(entryOf(-6, -6)));\n-      assertFalse(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15))));\n-      assertFalse(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15))));\n+      assertThat(entrySet.remove(null)).isFalse();\n+      assertThat(entrySet.remove(entryOf(6, 6))).isFalse();\n+      assertThat(entrySet.remove(entryOf(-6, -6))).isFalse();\n+      assertThat(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15)))).isFalse();\n+      assertThat(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15)))).isFalse();\n       checkEmpty(entrySet);\n       checkEmpty(cache);\n     }\n@@ -289,11 +290,11 @@ public void testEntrySet_remove() {\n       // values of these removes, but the cache should be empty after the removes, regardless.\n       entrySet.remove(entryOf(1, 1));\n       entrySet.remove(entryOf(2, 2));\n-      assertFalse(entrySet.remove(null));\n-      assertFalse(entrySet.remove(entryOf(1, 1)));\n-      assertFalse(entrySet.remove(entryOf(6, 6)));\n-      assertFalse(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15))));\n-      assertFalse(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15))));\n+      assertThat(entrySet.remove(null)).isFalse();\n+      assertThat(entrySet.remove(entryOf(1, 1))).isFalse();\n+      assertThat(entrySet.remove(entryOf(6, 6))).isFalse();\n+      assertThat(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15)))).isFalse();\n+      assertThat(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15)))).isFalse();\n       checkEmpty(entrySet);\n       checkEmpty(cache);\n     }\ndiff --git a/android/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java b/android/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java\nindex 76de76c3707c..9eb3fe7e33c7 100644\n--- a/android/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java\n@@ -16,12 +16,14 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.errorprone.annotations.Keep;\n import java.util.concurrent.ExecutionException;\n import junit.framework.TestCase;\n import org.jspecify.annotations.NullUnmarked;\n@@ -56,15 +58,13 @@ protected Cache<String, Boolean> delegate() {\n   }\n \n   public void testGetIfPresent() throws ExecutionException {\n-    when(mock.getIfPresent(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.getIfPresent(\"key\"));\n+    when(mock.getIfPresent(\"key\")).thenReturn(true);\n+    assertThat(forward.getIfPresent(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testGetAllPresent() throws ExecutionException {\n-    when(mock.getAllPresent(ImmutableList.of(\"key\")))\n-        .thenReturn(ImmutableMap.of(\"key\", Boolean.TRUE));\n-    assertEquals(\n-        ImmutableMap.of(\"key\", Boolean.TRUE), forward.getAllPresent(ImmutableList.of(\"key\")));\n+    when(mock.getAllPresent(ImmutableList.of(\"key\"))).thenReturn(ImmutableMap.of(\"key\", true));\n+    assertThat(forward.getAllPresent(ImmutableList.of(\"key\"))).containsExactly(\"key\", true);\n   }\n \n   public void testInvalidate() {\n@@ -84,17 +84,17 @@ public void testInvalidateAll() {\n \n   public void testSize() {\n     when(mock.size()).thenReturn(0L);\n-    assertEquals(0, forward.size());\n+    assertThat(forward.size()).isEqualTo(0);\n   }\n \n   public void testStats() {\n     when(mock.stats()).thenReturn(null);\n-    assertNull(forward.stats());\n+    assertThat(forward.stats()).isNull();\n   }\n \n   public void testAsMap() {\n     when(mock.asMap()).thenReturn(null);\n-    assertNull(forward.asMap());\n+    assertThat(forward.asMap()).isNull();\n   }\n \n   public void testCleanUp() {\n@@ -103,6 +103,7 @@ public void testCleanUp() {\n   }\n \n   /** Make sure that all methods are forwarded. */\n+  @Keep\n   private static class OnlyGet<K, V> extends ForwardingCache<K, V> {\n     @Override\n     protected Cache<K, V> delegate() {\ndiff --git a/android/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java b/android/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java\nindex cdef91afe699..89029ab0ef67 100644\n--- a/android/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java\n@@ -16,12 +16,14 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.errorprone.annotations.Keep;\n import java.util.concurrent.ExecutionException;\n import junit.framework.TestCase;\n import org.jspecify.annotations.NullUnmarked;\n@@ -56,23 +58,23 @@ protected LoadingCache<String, Boolean> delegate() {\n   }\n \n   public void testGet() throws ExecutionException {\n-    when(mock.get(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.get(\"key\"));\n+    when(mock.get(\"key\")).thenReturn(true);\n+    assertThat(forward.get(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testGetUnchecked() {\n-    when(mock.getUnchecked(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.getUnchecked(\"key\"));\n+    when(mock.getUnchecked(\"key\")).thenReturn(true);\n+    assertThat(forward.getUnchecked(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testGetAll() throws ExecutionException {\n-    when(mock.getAll(ImmutableList.of(\"key\"))).thenReturn(ImmutableMap.of(\"key\", Boolean.TRUE));\n-    assertEquals(ImmutableMap.of(\"key\", Boolean.TRUE), forward.getAll(ImmutableList.of(\"key\")));\n+    when(mock.getAll(ImmutableList.of(\"key\"))).thenReturn(ImmutableMap.of(\"key\", true));\n+    assertThat(forward.getAll(ImmutableList.of(\"key\"))).containsExactly(\"key\", true);\n   }\n \n   public void testApply() {\n-    when(mock.apply(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.apply(\"key\"));\n+    when(mock.apply(\"key\")).thenReturn(true);\n+    assertThat(forward.apply(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testInvalidate() {\n@@ -97,12 +99,12 @@ public void testSize() {\n \n   public void testStats() {\n     when(mock.stats()).thenReturn(null);\n-    assertNull(forward.stats());\n+    assertThat(forward.stats()).isNull();\n   }\n \n   public void testAsMap() {\n     when(mock.asMap()).thenReturn(null);\n-    assertNull(forward.asMap());\n+    assertThat(forward.asMap()).isNull();\n   }\n \n   public void testCleanUp() {\n@@ -111,6 +113,7 @@ public void testCleanUp() {\n   }\n \n   /** Make sure that all methods are forwarded. */\n+  @Keep\n   private static class OnlyGet<K, V> extends ForwardingLoadingCache<K, V> {\n     @Override\n     protected LoadingCache<K, V> delegate() {\ndiff --git a/android/guava-tests/test/com/google/common/cache/LocalCacheTest.java b/android/guava-tests/test/com/google/common/cache/LocalCacheTest.java\nindex cf9739a7640b..017209eb4d6e 100644\n--- a/android/guava-tests/test/com/google/common/cache/LocalCacheTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/LocalCacheTest.java\n@@ -27,6 +27,7 @@\n import static com.google.common.cache.TestingWeighers.constantWeigher;\n import static com.google.common.collect.Maps.immutableEntry;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n import static java.lang.Math.max;\n import static java.lang.Thread.State.WAITING;\n@@ -247,18 +248,18 @@ public void tearDown() throws Exception {\n \n   private Throwable popLoggedThrowable() {\n     List<LogRecord> logRecords = logHandler.getStoredLogRecords();\n-    assertEquals(1, logRecords.size());\n+    assertThat(logRecords).hasSize(1);\n     LogRecord logRecord = logRecords.get(0);\n     logHandler.clear();\n     return logRecord.getThrown();\n   }\n \n   private void checkNothingLogged() {\n-    assertTrue(logHandler.getStoredLogRecords().isEmpty());\n+    assertThat(logHandler.getStoredLogRecords().isEmpty()).isTrue();\n   }\n \n   private void checkLogged(Throwable t) {\n-    assertSame(t, popLoggedThrowable());\n+    assertThat(popLoggedThrowable()).isSameInstanceAs(t);\n   }\n \n   /*\n@@ -288,33 +289,33 @@ private static CacheBuilder<Object, Object> createCacheBuilder() {\n   public void testDefaults() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n \n-    assertSame(Strength.STRONG, map.keyStrength);\n-    assertSame(Strength.STRONG, map.valueStrength);\n-    assertSame(map.keyStrength.defaultEquivalence(), map.keyEquivalence);\n-    assertSame(map.valueStrength.defaultEquivalence(), map.valueEquivalence);\n+    assertThat(map.keyStrength).isEqualTo(Strength.STRONG);\n+    assertThat(map.valueStrength).isEqualTo(Strength.STRONG);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(map.keyStrength.defaultEquivalence());\n+    assertThat(map.valueEquivalence).isSameInstanceAs(map.valueStrength.defaultEquivalence());\n \n-    assertEquals(0, map.expireAfterAccessNanos);\n-    assertEquals(0, map.expireAfterWriteNanos);\n-    assertEquals(0, map.refreshNanos);\n-    assertEquals(CacheBuilder.UNSET_INT, map.maxWeight);\n+    assertThat(map.expireAfterAccessNanos).isEqualTo(0);\n+    assertThat(map.expireAfterWriteNanos).isEqualTo(0);\n+    assertThat(map.refreshNanos).isEqualTo(0);\n+    assertThat(map.maxWeight).isEqualTo(CacheBuilder.UNSET_INT);\n \n-    assertSame(EntryFactory.STRONG, map.entryFactory);\n-    assertSame(CacheBuilder.NullListener.INSTANCE, map.removalListener);\n-    assertSame(DISCARDING_QUEUE, map.removalNotificationQueue);\n-    assertSame(NULL_TICKER, map.ticker);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);\n+    assertThat(map.removalListener).isSameInstanceAs(CacheBuilder.NullListener.INSTANCE);\n+    assertThat(map.removalNotificationQueue).isSameInstanceAs(DISCARDING_QUEUE);\n+    assertThat(map.ticker).isSameInstanceAs(NULL_TICKER);\n \n-    assertEquals(4, map.concurrencyLevel);\n+    assertThat(map.concurrencyLevel).isEqualTo(4);\n \n     // concurrency level\n     assertThat(map.segments).hasLength(4);\n     // initial capacity / concurrency level\n-    assertEquals(16 / map.segments.length, map.segments[0].table.length());\n+    assertThat(map.segments[0].table.length()).isEqualTo(16 / map.segments.length);\n \n-    assertFalse(map.evictsBySize());\n-    assertFalse(map.expires());\n-    assertFalse(map.expiresAfterWrite());\n-    assertFalse(map.expiresAfterAccess());\n-    assertFalse(map.refreshes());\n+    assertThat(map.evictsBySize()).isFalse();\n+    assertThat(map.expires()).isFalse();\n+    assertThat(map.expiresAfterWrite()).isFalse();\n+    assertThat(map.expiresAfterAccess()).isFalse();\n+    assertThat(map.refreshes()).isFalse();\n   }\n \n   public void testSetKeyEquivalence() {\n@@ -333,8 +334,8 @@ protected int doHash(Object t) {\n \n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().keyEquivalence(testEquivalence));\n-    assertSame(testEquivalence, map.keyEquivalence);\n-    assertSame(map.valueStrength.defaultEquivalence(), map.valueEquivalence);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(testEquivalence);\n+    assertThat(map.valueEquivalence).isSameInstanceAs(map.valueStrength.defaultEquivalence());\n   }\n \n   public void testSetValueEquivalence() {\n@@ -353,8 +354,8 @@ protected int doHash(Object t) {\n \n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().valueEquivalence(testEquivalence));\n-    assertSame(testEquivalence, map.valueEquivalence);\n-    assertSame(map.keyStrength.defaultEquivalence(), map.keyEquivalence);\n+    assertThat(map.valueEquivalence).isSameInstanceAs(testEquivalence);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(map.keyStrength.defaultEquivalence());\n   }\n \n   public void testSetConcurrencyLevel() {\n@@ -418,7 +419,7 @@ private static void checkInitialCapacity(\n                 .concurrencyLevel(concurrencyLevel)\n                 .initialCapacity(initialCapacity));\n     for (int i = 0; i < map.segments.length; i++) {\n-      assertEquals(segmentSize, map.segments[i].table.length());\n+      assertThat(map.segments[i].table.length()).isEqualTo(segmentSize);\n     }\n   }\n \n@@ -455,13 +456,15 @@ private static void checkMaximumSize(int concurrencyLevel, int initialCapacity,\n                 .initialCapacity(initialCapacity)\n                 .maximumSize(maxSize));\n     long totalCapacity = 0;\n-    assertTrue(\n-        \"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n-        map.segments.length <= max(1, maxSize / 10));\n+    assertWithMessage(\"segments=%s, maxSize=%s\", map.segments.length, maxSize)\n+        .that((long) map.segments.length)\n+        .isAtMost(max(1, maxSize / 10));\n     for (int i = 0; i < map.segments.length; i++) {\n       totalCapacity += map.segments[i].maxSegmentWeight;\n     }\n-    assertTrue(\"totalCapacity=\" + totalCapacity + \", maxSize=\" + maxSize, totalCapacity == maxSize);\n+    assertWithMessage(\"totalCapacity=%s, maxSize=%s\", totalCapacity, maxSize)\n+        .that(totalCapacity)\n+        .isEqualTo(maxSize);\n \n     map =\n         makeLocalCache(\n@@ -470,14 +473,16 @@ private static void checkMaximumSize(int concurrencyLevel, int initialCapacity,\n                 .initialCapacity(initialCapacity)\n                 .maximumWeight(maxSize)\n                 .weigher(constantWeigher(1)));\n-    assertTrue(\n-        \"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n-        map.segments.length <= max(1, maxSize / 10));\n+    assertWithMessage(\"segments=%s, maxSize=%s\", map.segments.length, maxSize)\n+        .that((long) map.segments.length)\n+        .isAtMost(max(1, maxSize / 10));\n     totalCapacity = 0;\n     for (int i = 0; i < map.segments.length; i++) {\n       totalCapacity += map.segments[i].maxSegmentWeight;\n     }\n-    assertTrue(\"totalCapacity=\" + totalCapacity + \", maxSize=\" + maxSize, totalCapacity == maxSize);\n+    assertWithMessage(\"totalCapacity=%s, maxSize=%s\", totalCapacity, maxSize)\n+        .that(totalCapacity)\n+        .isEqualTo(maxSize);\n   }\n \n   public void testSetWeigher() {\n@@ -490,33 +495,33 @@ public int weigh(Object key, Object value) {\n         };\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().maximumWeight(1).weigher(testWeigher));\n-    assertSame(testWeigher, map.weigher);\n+    assertThat(map.weigher).isSameInstanceAs(testWeigher);\n   }\n \n   public void testSetWeakKeys() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().weakKeys());\n     checkStrength(map, Strength.WEAK, Strength.STRONG);\n-    assertSame(EntryFactory.WEAK, map.entryFactory);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.WEAK);\n   }\n \n   public void testSetWeakValues() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().weakValues());\n     checkStrength(map, Strength.STRONG, Strength.WEAK);\n-    assertSame(EntryFactory.STRONG, map.entryFactory);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);\n   }\n \n   public void testSetSoftValues() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().softValues());\n     checkStrength(map, Strength.STRONG, Strength.SOFT);\n-    assertSame(EntryFactory.STRONG, map.entryFactory);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);\n   }\n \n   private static void checkStrength(\n       LocalCache<Object, Object> map, Strength keyStrength, Strength valueStrength) {\n-    assertSame(keyStrength, map.keyStrength);\n-    assertSame(valueStrength, map.valueStrength);\n-    assertSame(keyStrength.defaultEquivalence(), map.keyEquivalence);\n-    assertSame(valueStrength.defaultEquivalence(), map.valueEquivalence);\n+    assertThat(map.keyStrength).isSameInstanceAs(keyStrength);\n+    assertThat(map.valueStrength).isSameInstanceAs(valueStrength);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(keyStrength.defaultEquivalence());\n+    assertThat(map.valueEquivalence).isSameInstanceAs(valueStrength.defaultEquivalence());\n   }\n \n   public void testSetExpireAfterWrite() {\n@@ -524,7 +529,7 @@ public void testSetExpireAfterWrite() {\n     TimeUnit unit = SECONDS;\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().expireAfterWrite(duration, unit));\n-    assertEquals(unit.toNanos(duration), map.expireAfterWriteNanos);\n+    assertThat(map.expireAfterWriteNanos).isEqualTo(unit.toNanos(duration));\n   }\n \n   public void testSetExpireAfterAccess() {\n@@ -532,7 +537,7 @@ public void testSetExpireAfterAccess() {\n     TimeUnit unit = SECONDS;\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().expireAfterAccess(duration, unit));\n-    assertEquals(unit.toNanos(duration), map.expireAfterAccessNanos);\n+    assertThat(map.expireAfterAccessNanos).isEqualTo(unit.toNanos(duration));\n   }\n \n   public void testSetRefresh() {\n@@ -540,7 +545,7 @@ public void testSetRefresh() {\n     TimeUnit unit = SECONDS;\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().refreshAfterWrite(duration, unit));\n-    assertEquals(unit.toNanos(duration), map.refreshNanos);\n+    assertThat(map.refreshNanos).isEqualTo(unit.toNanos(duration));\n   }\n \n   public void testLongAsyncRefresh() throws Exception {\n@@ -599,7 +604,7 @@ public void testSetRemovalListener() {\n     RemovalListener<Object, Object> testListener = TestingRemovalListeners.nullRemovalListener();\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().removalListener(testListener));\n-    assertSame(testListener, map.removalListener);\n+    assertThat(map.removalListener).isSameInstanceAs(testListener);\n   }\n \n   public void testSetTicker() {\n@@ -611,19 +616,26 @@ public long read() {\n           }\n         };\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().ticker(testTicker));\n-    assertSame(testTicker, map.ticker);\n+    assertThat(map.ticker).isSameInstanceAs(testTicker);\n   }\n \n   public void testEntryFactory() {\n-    assertSame(EntryFactory.STRONG, EntryFactory.getFactory(Strength.STRONG, false, false));\n-    assertSame(EntryFactory.STRONG_ACCESS, EntryFactory.getFactory(Strength.STRONG, true, false));\n-    assertSame(EntryFactory.STRONG_WRITE, EntryFactory.getFactory(Strength.STRONG, false, true));\n-    assertSame(\n-        EntryFactory.STRONG_ACCESS_WRITE, EntryFactory.getFactory(Strength.STRONG, true, true));\n-    assertSame(EntryFactory.WEAK, EntryFactory.getFactory(Strength.WEAK, false, false));\n-    assertSame(EntryFactory.WEAK_ACCESS, EntryFactory.getFactory(Strength.WEAK, true, false));\n-    assertSame(EntryFactory.WEAK_WRITE, EntryFactory.getFactory(Strength.WEAK, false, true));\n-    assertSame(EntryFactory.WEAK_ACCESS_WRITE, EntryFactory.getFactory(Strength.WEAK, true, true));\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, false, false))\n+        .isSameInstanceAs(EntryFactory.STRONG);\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, true, false))\n+        .isSameInstanceAs(EntryFactory.STRONG_ACCESS);\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, false, true))\n+        .isSameInstanceAs(EntryFactory.STRONG_WRITE);\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, true, true))\n+        .isSameInstanceAs(EntryFactory.STRONG_ACCESS_WRITE);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, false, false))\n+        .isSameInstanceAs(EntryFactory.WEAK);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, true, false))\n+        .isSameInstanceAs(EntryFactory.WEAK_ACCESS);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, false, true))\n+        .isSameInstanceAs(EntryFactory.WEAK_WRITE);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, true, true))\n+        .isSameInstanceAs(EntryFactory.WEAK_ACCESS_WRITE);\n   }\n \n   // computation tests\n@@ -631,13 +643,13 @@ public void testEntryFactory() {\n   public void testCompute() throws ExecutionException {\n     CountingLoader loader = new CountingLoader();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     Object value = map.get(key, loader);\n-    assertEquals(1, loader.getCount());\n-    assertEquals(value, map.get(key, loader));\n-    assertEquals(1, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(1);\n+    assertThat(map.get(key, loader)).isEqualTo(value);\n+    assertThat(loader.getCount()).isEqualTo(1);\n   }\n \n   public void testRecordReadOnCompute() throws ExecutionException {\n@@ -659,7 +671,7 @@ public void testRecordReadOnCompute() throws ExecutionException {\n \n       checkEvictionQueues(map, segment, readOrder, writeOrder);\n       checkExpirationTimes(map);\n-      assertTrue(segment.recencyQueue.isEmpty());\n+      assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n       // access some of the elements\n       Random random = new Random();\n@@ -671,7 +683,7 @@ public void testRecordReadOnCompute() throws ExecutionException {\n           map.get(entry.getKey(), loader);\n           reads.add(entry);\n           i.remove();\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n       }\n       int undrainedIndex = reads.size() - segment.recencyQueue.size();\n@@ -686,14 +698,14 @@ public void testRecordReadOnCompute() throws ExecutionException {\n   public void testComputeExistingEntry() throws ExecutionException {\n     CountingLoader loader = new CountingLoader();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     Object value = new Object();\n     map.put(key, value);\n \n-    assertEquals(value, map.get(key, loader));\n-    assertEquals(0, loader.getCount());\n+    assertThat(map.get(key, loader)).isEqualTo(value);\n+    assertThat(loader.getCount()).isEqualTo(0);\n   }\n \n   public void testComputePartiallyCollectedKey() throws ExecutionException {\n@@ -702,7 +714,7 @@ public void testComputePartiallyCollectedKey() throws ExecutionException {\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     int hash = map.hash(key);\n@@ -715,14 +727,14 @@ public void testComputePartiallyCollectedKey() throws ExecutionException {\n     table.set(index, entry);\n     segment.count++;\n \n-    assertSame(value, map.get(key, loader));\n-    assertEquals(0, loader.getCount());\n-    assertEquals(1, segment.count);\n+    assertThat(map.get(key, loader)).isSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(1);\n \n     entry.clearKey();\n-    assertNotSame(value, map.get(key, loader));\n-    assertEquals(1, loader.getCount());\n-    assertEquals(2, segment.count);\n+    assertThat(map.get(key, loader)).isNotSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(1);\n+    assertThat(segment.count).isEqualTo(2);\n   }\n \n   public void testComputePartiallyCollectedValue() throws ExecutionException {\n@@ -731,7 +743,7 @@ public void testComputePartiallyCollectedValue() throws ExecutionException {\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     int hash = map.hash(key);\n@@ -744,14 +756,14 @@ public void testComputePartiallyCollectedValue() throws ExecutionException {\n     table.set(index, entry);\n     segment.count++;\n \n-    assertSame(value, map.get(key, loader));\n-    assertEquals(0, loader.getCount());\n-    assertEquals(1, segment.count);\n+    assertThat(map.get(key, loader)).isSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(1);\n \n     valueRef.clear();\n-    assertNotSame(value, map.get(key, loader));\n-    assertEquals(1, loader.getCount());\n-    assertEquals(1, segment.count);\n+    assertThat(map.get(key, loader)).isNotSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(1);\n+    assertThat(segment.count).isEqualTo(1);\n   }\n \n   @AndroidIncompatible // Perhaps emulator clock does not update between the two get() calls?\n@@ -759,15 +771,15 @@ public void testComputeExpiredEntry() throws ExecutionException {\n     CacheBuilder<Object, Object> builder = createCacheBuilder().expireAfterWrite(1, NANOSECONDS);\n     CountingLoader loader = new CountingLoader();\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     Object one = map.get(key, loader);\n-    assertEquals(1, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(1);\n \n     Object two = map.get(key, loader);\n-    assertNotSame(one, two);\n-    assertEquals(2, loader.getCount());\n+    assertThat(two).isNotSameInstanceAs(one);\n+    assertThat(loader.getCount()).isEqualTo(2);\n   }\n \n   public void testValues() {\n@@ -775,9 +787,9 @@ public void testValues() {\n     map.put(\"foo\", \"bar\");\n     map.put(\"baz\", \"bar\");\n     map.put(\"quux\", \"quux\");\n-    assertFalse(map.values() instanceof Set);\n-    assertTrue(map.values().removeAll(ImmutableSet.of(\"bar\")));\n-    assertEquals(1, map.size());\n+    assertThat(map.values() instanceof Set).isFalse();\n+    assertThat(map.values().removeAll(ImmutableSet.of(\"bar\"))).isTrue();\n+    assertThat(map).hasSize(1);\n   }\n \n   public void testCopyEntry_computing() {\n@@ -802,7 +814,7 @@ public Object load(Object key) throws Exception {\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     int hash = map.hash(one);\n@@ -845,7 +857,7 @@ public void run() {\n     @SuppressWarnings(\"unchecked\")\n     LoadingValueReference<Object, Object> valueReference =\n         (LoadingValueReference) newEntry.getValueReference();\n-    assertFalse(valueReference.futureValue.isDone());\n+    assertThat(valueReference.futureValue.isDone()).isFalse();\n     startSignal.countDown();\n \n     try {\n@@ -855,10 +867,10 @@ public void run() {\n     }\n \n     map.cleanUp(); // force notifications\n-    assertTrue(listener.isEmpty());\n-    assertTrue(map.containsKey(one));\n-    assertEquals(1, map.size());\n-    assertSame(computedObject, map.get(one));\n+    assertThat(listener.isEmpty()).isTrue();\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map).hasSize(1);\n+    assertThat(map.get(one)).isSameInstanceAs(computedObject);\n   }\n \n   public void testRemovalListenerCheckedException() {\n@@ -900,7 +912,7 @@ public Object load(Object key) throws Exception {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     CacheBuilder<Object, Object> builder = createCacheBuilder().removalListener(listener);\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -924,7 +936,7 @@ public void run() {\n     }\n \n     map.put(one, two);\n-    assertSame(two, map.get(one));\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n     startSignal.countDown();\n \n     try {\n@@ -935,7 +947,7 @@ public void run() {\n \n     map.cleanUp(); // force notifications\n     assertNotified(listener, one, computedObject, RemovalCause.REPLACED);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testSegmentRefresh_duplicate() throws ExecutionException {\n@@ -961,7 +973,7 @@ public void testSegmentRefresh_duplicate() throws ExecutionException {\n   public void testRemovalListener_explicit() {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -996,13 +1008,13 @@ public void testRemovalListener_explicit() {\n     i.remove();\n     assertNotified(listener, five, six, RemovalCause.EXPLICIT);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testRemovalListener_replaced() {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1032,7 +1044,7 @@ public void testRemovalListener_collected() {\n         makeLocalCache(\n             createCacheBuilder().concurrencyLevel(1).softValues().removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1040,14 +1052,14 @@ public void testRemovalListener_collected() {\n \n     map.put(one, two);\n     map.put(two, three);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     int hash = map.hash(one);\n     ReferenceEntry<Object, Object> entry = segment.getEntry(one, hash);\n     map.reclaimValue(entry.getValueReference());\n     assertNotified(listener, one, two, RemovalCause.COLLECTED);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testRemovalListener_expired() {\n@@ -1060,7 +1072,7 @@ public void testRemovalListener_expired() {\n                 .expireAfterWrite(3, NANOSECONDS)\n                 .ticker(ticker)\n                 .removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1073,12 +1085,12 @@ public void testRemovalListener_expired() {\n     map.put(two, three);\n     ticker.advance(1);\n     map.put(three, four);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     ticker.advance(1);\n     map.put(four, five);\n     assertNotified(listener, one, two, RemovalCause.EXPIRED);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testRemovalListener_size() {\n@@ -1086,7 +1098,7 @@ public void testRemovalListener_size() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(\n             createCacheBuilder().concurrencyLevel(1).maximumSize(2).removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1095,19 +1107,19 @@ public void testRemovalListener_size() {\n \n     map.put(one, two);\n     map.put(two, three);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     map.put(three, four);\n     assertNotified(listener, one, two, RemovalCause.SIZE);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   static <K, V> void assertNotified(\n       QueuingRemovalListener<K, V> listener, K key, V value, RemovalCause cause) {\n     RemovalNotification<K, V> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(value, notification.getValue());\n-    assertSame(cause, notification.getCause());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(value);\n+    assertThat(notification.getCause()).isSameInstanceAs(cause);\n   }\n \n   // Segment core tests\n@@ -1121,26 +1133,26 @@ public void testNewEntry() {\n       int hashOne = map.hash(keyOne);\n       ReferenceEntry<Object, Object> entryOne = map.newEntry(keyOne, hashOne, null);\n       ValueReference<Object, Object> valueRefOne = map.newValueReference(entryOne, valueOne, 1);\n-      assertSame(valueOne, valueRefOne.get());\n+      assertThat(valueRefOne.get()).isSameInstanceAs(valueOne);\n       entryOne.setValueReference(valueRefOne);\n \n-      assertSame(keyOne, entryOne.getKey());\n-      assertEquals(hashOne, entryOne.getHash());\n-      assertNull(entryOne.getNext());\n-      assertSame(valueRefOne, entryOne.getValueReference());\n+      assertThat(entryOne.getKey()).isSameInstanceAs(keyOne);\n+      assertThat(entryOne.getHash()).isEqualTo(hashOne);\n+      assertThat(entryOne.getNext()).isNull();\n+      assertThat(entryOne.getValueReference()).isSameInstanceAs(valueRefOne);\n \n       Object keyTwo = new Object();\n       Object valueTwo = new Object();\n       int hashTwo = map.hash(keyTwo);\n       ReferenceEntry<Object, Object> entryTwo = map.newEntry(keyTwo, hashTwo, entryOne);\n       ValueReference<Object, Object> valueRefTwo = map.newValueReference(entryTwo, valueTwo, 1);\n-      assertSame(valueTwo, valueRefTwo.get());\n+      assertThat(valueRefTwo.get()).isSameInstanceAs(valueTwo);\n       entryTwo.setValueReference(valueRefTwo);\n \n-      assertSame(keyTwo, entryTwo.getKey());\n-      assertEquals(hashTwo, entryTwo.getHash());\n-      assertSame(entryOne, entryTwo.getNext());\n-      assertSame(valueRefTwo, entryTwo.getValueReference());\n+      assertThat(entryTwo.getKey()).isSameInstanceAs(keyTwo);\n+      assertThat(entryTwo.getHash()).isEqualTo(hashTwo);\n+      assertThat(entryTwo.getNext()).isSameInstanceAs(entryOne);\n+      assertThat(entryTwo.getValueReference()).isSameInstanceAs(valueRefTwo);\n     }\n   }\n \n@@ -1168,17 +1180,17 @@ public void testCopyEntry() {\n       assertConnected(map, entryOne, entryTwo);\n \n       ReferenceEntry<Object, Object> copyOne = map.copyEntry(entryOne, null);\n-      assertSame(keyOne, entryOne.getKey());\n-      assertEquals(hashOne, entryOne.getHash());\n-      assertNull(entryOne.getNext());\n-      assertSame(valueOne, copyOne.getValueReference().get());\n+      assertThat(entryOne.getKey()).isSameInstanceAs(keyOne);\n+      assertThat(entryOne.getHash()).isEqualTo(hashOne);\n+      assertThat(entryOne.getNext()).isNull();\n+      assertThat(copyOne.getValueReference().get()).isSameInstanceAs(valueOne);\n       assertConnected(map, copyOne, entryTwo);\n \n       ReferenceEntry<Object, Object> copyTwo = map.copyEntry(entryTwo, copyOne);\n-      assertSame(keyTwo, copyTwo.getKey());\n-      assertEquals(hashTwo, copyTwo.getHash());\n-      assertSame(copyOne, copyTwo.getNext());\n-      assertSame(valueTwo, copyTwo.getValueReference().get());\n+      assertThat(copyTwo.getKey()).isSameInstanceAs(keyTwo);\n+      assertThat(copyTwo.getHash()).isEqualTo(hashTwo);\n+      assertThat(copyTwo.getNext()).isSameInstanceAs(copyOne);\n+      assertThat(copyTwo.getValueReference().get()).isSameInstanceAs(valueTwo);\n       assertConnected(map, copyOne, copyTwo);\n     }\n   }\n@@ -1186,10 +1198,10 @@ public void testCopyEntry() {\n   private static <K, V> void assertConnected(\n       LocalCache<K, V> map, ReferenceEntry<K, V> one, ReferenceEntry<K, V> two) {\n     if (map.usesWriteQueue()) {\n-      assertSame(two, one.getNextInWriteQueue());\n+      assertThat(one.getNextInWriteQueue()).isSameInstanceAs(two);\n     }\n     if (map.usesAccessQueue()) {\n-      assertSame(two, one.getNextInAccessQueue());\n+      assertThat(one.getNextInAccessQueue()).isSameInstanceAs(two);\n     }\n   }\n \n@@ -1219,14 +1231,14 @@ public void testSegmentGetAndContains() {\n     // count == 0\n     table.set(index, entry);\n     assertNull(segment.get(key, hash));\n-    assertFalse(segment.containsKey(key, hash));\n-    assertFalse(segment.containsValue(value));\n+    assertThat(segment.containsKey(key, hash)).isFalse();\n+    assertThat(segment.containsValue(value)).isFalse();\n \n     // count == 1\n     segment.count++;\n-    assertSame(value, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n     // don't see absent values now that count > 0\n     assertNull(segment.get(new Object(), hash));\n \n@@ -1237,10 +1249,10 @@ public void testSegmentGetAndContains() {\n     nullEntry.setValueReference(nullValueRef);\n     table.set(index, nullEntry);\n     // skip the null key\n-    assertSame(value, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertFalse(segment.containsValue(nullValue));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(nullValue)).isFalse();\n \n     // hash collision\n     DummyEntry<Object, Object> dummy = DummyEntry.create(new Object(), hash, entry);\n@@ -1248,10 +1260,10 @@ public void testSegmentGetAndContains() {\n     ValueReference<Object, Object> dummyValueRef = map.newValueReference(dummy, dummyValue, 1);\n     dummy.setValueReference(dummyValueRef);\n     table.set(index, dummy);\n-    assertSame(value, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertTrue(segment.containsValue(dummyValue));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(dummyValue)).isTrue();\n \n     // key collision\n     dummy = DummyEntry.create(key, hash, entry);\n@@ -1260,17 +1272,17 @@ public void testSegmentGetAndContains() {\n     dummy.setValueReference(dummyValueRef);\n     table.set(index, dummy);\n     // returns the most recent entry\n-    assertSame(dummyValue, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertTrue(segment.containsValue(dummyValue));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(dummyValue);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(dummyValue)).isTrue();\n \n     // expired\n     dummy.setAccessTime(ticker.read() - 2);\n     assertNull(segment.get(key, hash));\n-    assertFalse(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertFalse(segment.containsValue(dummyValue));\n+    assertThat(segment.containsKey(key, hash)).isFalse();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(dummyValue)).isFalse();\n   }\n \n   public void testSegmentReplaceValue() {\n@@ -1291,29 +1303,29 @@ public void testSegmentReplaceValue() {\n     entry.setValueReference(oldValueRef);\n \n     // no entry\n-    assertFalse(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same value\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertTrue(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isTrue();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // different value\n-    assertFalse(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // cleared\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n-    assertFalse(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1336,23 +1348,23 @@ public void testSegmentReplace() {\n \n     // no entry\n     assertNull(segment.replace(key, hash, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same key\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertSame(oldValue, segment.replace(key, hash, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.replace(key, hash, newValue)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // cleared\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.replace(key, hash, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1368,24 +1380,24 @@ public void testSegmentPut() {\n     Object newValue = new Object();\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.put(key, hash, oldValue, false));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n \n     // same key\n-    assertSame(oldValue, segment.put(key, hash, newValue, false));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.put(key, hash, newValue, false)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // cleared\n     ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);\n     DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.put(key, hash, newValue, false));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n   }\n \n   public void testSegmentPutIfAbsent() {\n@@ -1400,31 +1412,31 @@ public void testSegmentPutIfAbsent() {\n     Object newValue = new Object();\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.put(key, hash, oldValue, true));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n \n     // same key\n-    assertSame(oldValue, segment.put(key, hash, newValue, true));\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.put(key, hash, newValue, true)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n \n     // cleared\n     ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);\n     DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.put(key, hash, newValue, true));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n   }\n \n   public void testSegmentPut_expand() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertEquals(1, segment.table.length());\n+    assertThat(segment.table.length()).isEqualTo(1);\n \n     int count = 1024;\n     for (int i = 0; i < count; i++) {\n@@ -1432,7 +1444,7 @@ public void testSegmentPut_expand() {\n       Object value = new Object();\n       int hash = map.hash(key);\n       assertNull(segment.put(key, hash, value, false));\n-      assertTrue(segment.table.length() > i);\n+      assertThat(segment.table.length()).isGreaterThan(i);\n     }\n   }\n \n@@ -1454,7 +1466,7 @@ public void testSegmentPut_evict() {\n         it.next();\n         it.remove();\n       }\n-      assertEquals(originalMap, map);\n+      assertThat(map).isEqualTo(originalMap);\n     }\n   }\n \n@@ -1475,34 +1487,34 @@ public void testSegmentStoreComputedValue() {\n \n     // absent\n     Object value = new Object();\n-    assertTrue(listener.isEmpty());\n-    assertEquals(0, segment.count);\n+    assertThat(listener.isEmpty()).isTrue();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value));\n-    assertSame(value, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n-    assertTrue(listener.isEmpty());\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // clobbered\n     Object value2 = new Object();\n-    assertFalse(segment.storeLoadedValue(key, hash, valueRef, value2));\n-    assertEquals(1, segment.count);\n-    assertSame(value, segment.get(key, hash));\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value2)).isFalse();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertEquals(immutableEntry(key, value2), notification);\n-    assertEquals(RemovalCause.REPLACED, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification).isEqualTo(immutableEntry(key, value2));\n+    assertThat(notification.getCause()).isEqualTo(RemovalCause.REPLACED);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // inactive\n     Object value3 = new Object();\n     map.clear();\n     listener.clear();\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     table.set(index, entry);\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value3));\n-    assertSame(value3, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n-    assertTrue(listener.isEmpty());\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value3)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // replaced\n     Object value4 = new Object();\n@@ -1510,29 +1522,29 @@ public void testSegmentStoreComputedValue() {\n     valueRef = new LoadingValueReference<>(value3Ref);\n     entry.setValueReference(valueRef);\n     table.set(index, entry);\n-    assertSame(value3, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));\n-    assertSame(value4, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value4)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value4);\n+    assertThat(segment.count).isEqualTo(1);\n     notification = listener.remove();\n-    assertEquals(immutableEntry(key, value3), notification);\n-    assertEquals(RemovalCause.REPLACED, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification).isEqualTo(immutableEntry(key, value3));\n+    assertThat(notification.getCause()).isEqualTo(RemovalCause.REPLACED);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // collected\n     entry.setValueReference(valueRef);\n     table.set(index, entry);\n-    assertSame(value3, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);\n+    assertThat(segment.count).isEqualTo(1);\n     value3Ref.clear();\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));\n-    assertSame(value4, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value4)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value4);\n+    assertThat(segment.count).isEqualTo(1);\n     notification = listener.remove();\n-    assertEquals(immutableEntry(key, null), notification);\n-    assertEquals(RemovalCause.COLLECTED, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification).isEqualTo(immutableEntry(key, null));\n+    assertThat(notification.getCause()).isEqualTo(RemovalCause.COLLECTED);\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testSegmentRemove() {\n@@ -1550,27 +1562,27 @@ public void testSegmentRemove() {\n     entry.setValueReference(oldValueRef);\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same key\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertSame(oldValue, segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.remove(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n \n     // cleared\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1590,33 +1602,33 @@ public void testSegmentRemoveValue() {\n     entry.setValueReference(oldValueRef);\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same value\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertTrue(segment.remove(key, hash, oldValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.remove(key, hash, oldValue)).isTrue();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n \n     // different value\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertFalse(segment.remove(key, hash, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.remove(key, hash, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n \n     // cleared\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n-    assertFalse(segment.remove(key, hash, oldValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.remove(key, hash, oldValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1624,7 +1636,7 @@ public void testExpand() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertEquals(1, segment.table.length());\n+    assertThat(segment.table.length()).isEqualTo(1);\n \n     // manually add elements to avoid expansion\n     int originalCount = 1024;\n@@ -1641,17 +1653,17 @@ public void testExpand() {\n     segment.table.set(0, entry);\n     segment.count = originalCount;\n     ImmutableMap<Object, Object> originalMap = ImmutableMap.copyOf(map);\n-    assertEquals(originalCount, originalMap.size());\n-    assertEquals(originalMap, map);\n+    assertThat(originalMap).hasSize(originalCount);\n+    assertThat(map).isEqualTo(originalMap);\n \n     for (int i = 1; i <= originalCount * 2; i *= 2) {\n       if (i > 1) {\n         segment.expand();\n       }\n-      assertEquals(i, segment.table.length());\n-      assertEquals(originalCount, countLiveEntries(map, 0));\n-      assertEquals(originalCount, segment.count);\n-      assertEquals(originalMap, map);\n+      assertThat(segment.table.length()).isEqualTo(i);\n+      assertThat(countLiveEntries(map, 0)).isEqualTo(originalCount);\n+      assertThat(segment.count).isEqualTo(originalCount);\n+      assertThat(map).isEqualTo(originalMap);\n     }\n   }\n \n@@ -1660,7 +1672,7 @@ public void testGetCausesExpansion() throws ExecutionException {\n       LocalCache<Object, Object> map =\n           makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n       Segment<Object, Object> segment = map.segments[0];\n-      assertEquals(1, segment.table.length());\n+      assertThat(segment.table.length()).isEqualTo(1);\n \n       for (int i = 0; i < count; i++) {\n         Object key = new Object();\n@@ -1675,10 +1687,10 @@ public Object load(Object key) {\n               }\n             });\n       }\n-      assertEquals(count, segment.count);\n-      assertTrue(count <= segment.threshold);\n-      assertTrue(count <= (segment.table.length() * 3 / 4));\n-      assertTrue(count > (segment.table.length() * 3 / 8));\n+      assertThat(segment.count).isEqualTo(count);\n+      assertThat(count).isAtMost(segment.threshold);\n+      assertThat(count).isAtMost((segment.table.length() * 3 / 4));\n+      assertThat(count).isGreaterThan(segment.table.length() * 3 / 8);\n     }\n   }\n \n@@ -1686,8 +1698,8 @@ public void testGetOrDefault() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     map.put(1, 1);\n-    assertEquals(1, map.getOrDefault(1, 2));\n-    assertEquals(2, map.getOrDefault(2, 2));\n+    assertThat(map.getOrDefault(1, 2)).isEqualTo(1);\n+    assertThat(map.getOrDefault(2, 2)).isEqualTo(2);\n   }\n \n   public void testPutCausesExpansion() {\n@@ -1695,17 +1707,17 @@ public void testPutCausesExpansion() {\n       LocalCache<Object, Object> map =\n           makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n       Segment<Object, Object> segment = map.segments[0];\n-      assertEquals(1, segment.table.length());\n+      assertThat(segment.table.length()).isEqualTo(1);\n \n       for (int i = 0; i < count; i++) {\n         Object key = new Object();\n         Object value = new Object();\n         segment.put(key, key.hashCode(), value, true);\n       }\n-      assertEquals(count, segment.count);\n-      assertTrue(count <= segment.threshold);\n-      assertTrue(count <= (segment.table.length() * 3 / 4));\n-      assertTrue(count > (segment.table.length() * 3 / 8));\n+      assertThat(segment.count).isEqualTo(count);\n+      assertThat(count).isAtMost(segment.threshold);\n+      assertThat(count).isAtMost((segment.table.length() * 3 / 4));\n+      assertThat(count).isGreaterThan(segment.table.length() * 3 / 8);\n     }\n   }\n \n@@ -1721,7 +1733,7 @@ public void testReclaimKey() {\n                 .removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     // create 3 objects and chain them together\n     Object keyOne = new Object();\n@@ -1739,28 +1751,28 @@ public void testReclaimKey() {\n         createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n \n     // absent\n-    assertEquals(0, listener.getCount());\n-    assertFalse(segment.reclaimKey(entryOne, hashOne));\n-    assertEquals(0, listener.getCount());\n+    assertThat(listener.getCount()).isEqualTo(0);\n+    assertThat(segment.reclaimKey(entryOne, hashOne)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(0);\n     table.set(0, entryOne);\n-    assertFalse(segment.reclaimKey(entryTwo, hashTwo));\n-    assertEquals(0, listener.getCount());\n+    assertThat(segment.reclaimKey(entryTwo, hashTwo)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(0);\n     table.set(0, entryTwo);\n-    assertFalse(segment.reclaimKey(entryThree, hashThree));\n-    assertEquals(0, listener.getCount());\n+    assertThat(segment.reclaimKey(entryThree, hashThree)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(0);\n \n     // present\n     table.set(0, entryOne);\n     segment.count = 1;\n-    assertTrue(segment.reclaimKey(entryOne, hashOne));\n-    assertEquals(1, listener.getCount());\n-    assertSame(keyOne, listener.getLastEvictedKey());\n-    assertSame(valueOne, listener.getLastEvictedValue());\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertFalse(segment.accessQueue.contains(entryOne));\n-    assertFalse(segment.writeQueue.contains(entryOne));\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(segment.reclaimKey(entryOne, hashOne)).isTrue();\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(keyOne);\n+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(valueOne);\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.accessQueue.contains(entryOne)).isFalse();\n+    assertThat(segment.writeQueue.contains(entryOne)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n   }\n \n   public void testRemoveEntryFromChain() {\n@@ -1786,32 +1798,32 @@ public void testRemoveEntryFromChain() {\n     assertNull(segment.removeEntryFromChain(entryOne, entryOne));\n \n     // head\n-    assertSame(entryOne, segment.removeEntryFromChain(entryTwo, entryTwo));\n+    assertThat(segment.removeEntryFromChain(entryTwo, entryTwo)).isSameInstanceAs(entryOne);\n \n     // middle\n     ReferenceEntry<Object, Object> newFirst = segment.removeEntryFromChain(entryThree, entryTwo);\n-    assertSame(keyThree, newFirst.getKey());\n-    assertSame(valueThree, newFirst.getValueReference().get());\n-    assertEquals(hashThree, newFirst.getHash());\n-    assertSame(entryOne, newFirst.getNext());\n+    assertThat(newFirst.getKey()).isSameInstanceAs(keyThree);\n+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueThree);\n+    assertThat(newFirst.getHash()).isEqualTo(hashThree);\n+    assertThat(newFirst.getNext()).isSameInstanceAs(entryOne);\n \n     // tail (remaining entries are copied in reverse order)\n     newFirst = segment.removeEntryFromChain(entryThree, entryOne);\n-    assertSame(keyTwo, newFirst.getKey());\n-    assertSame(valueTwo, newFirst.getValueReference().get());\n-    assertEquals(hashTwo, newFirst.getHash());\n+    assertThat(newFirst.getKey()).isSameInstanceAs(keyTwo);\n+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueTwo);\n+    assertThat(newFirst.getHash()).isEqualTo(hashTwo);\n     newFirst = newFirst.getNext();\n-    assertSame(keyThree, newFirst.getKey());\n-    assertSame(valueThree, newFirst.getValueReference().get());\n-    assertEquals(hashThree, newFirst.getHash());\n-    assertNull(newFirst.getNext());\n+    assertThat(newFirst.getKey()).isSameInstanceAs(keyThree);\n+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueThree);\n+    assertThat(newFirst.getHash()).isEqualTo(hashThree);\n+    assertThat(newFirst.getNext()).isNull();\n   }\n \n   public void testExpand_cleanup() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertEquals(1, segment.table.length());\n+    assertThat(segment.table.length()).isEqualTo(1);\n \n     // manually add elements to avoid expansion\n     // 1/3 null keys, 1/3 null values\n@@ -1832,22 +1844,22 @@ public void testExpand_cleanup() {\n     segment.table.set(0, entry);\n     segment.count = originalCount;\n     int liveCount = originalCount / 3;\n-    assertEquals(1, segment.table.length());\n-    assertEquals(liveCount, countLiveEntries(map, 0));\n+    assertThat(segment.table.length()).isEqualTo(1);\n+    assertThat(countLiveEntries(map, 0)).isEqualTo(liveCount);\n     ImmutableMap<Object, Object> originalMap = ImmutableMap.copyOf(map);\n-    assertEquals(liveCount, originalMap.size());\n+    assertThat(originalMap).hasSize(liveCount);\n     // can't compare map contents until cleanup occurs\n \n     for (int i = 1; i <= originalCount * 2; i *= 2) {\n       if (i > 1) {\n         segment.expand();\n       }\n-      assertEquals(i, segment.table.length());\n-      assertEquals(liveCount, countLiveEntries(map, 0));\n+      assertThat(segment.table.length()).isEqualTo(i);\n+      assertThat(countLiveEntries(map, 0)).isEqualTo(liveCount);\n       // expansion cleanup is sloppy, with a goal of avoiding unnecessary copies\n-      assertTrue(segment.count >= liveCount);\n-      assertTrue(segment.count <= originalCount);\n-      assertEquals(originalMap, ImmutableMap.copyOf(map));\n+      assertThat(segment.count).isAtLeast(liveCount);\n+      assertThat(segment.count).isAtMost(originalCount);\n+      assertThat(ImmutableMap.copyOf(map)).isEqualTo(originalMap);\n     }\n   }\n \n@@ -1876,7 +1888,7 @@ public void testClear() {\n                 .expireAfterWrite(99999, SECONDS));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -1888,17 +1900,17 @@ public void testClear() {\n     segment.count = 1;\n     segment.totalWeight = 1;\n \n-    assertSame(entry, table.get(0));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertSame(entry, segment.writeQueue.peek());\n+    assertThat(table.get(0)).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n \n     segment.clear();\n-    assertNull(table.get(0));\n-    assertTrue(segment.accessQueue.isEmpty());\n-    assertTrue(segment.writeQueue.isEmpty());\n-    assertEquals(0, segment.readCount.get());\n-    assertEquals(0, segment.count);\n-    assertEquals(0, segment.totalWeight);\n+    assertThat(table.get(0)).isNull();\n+    assertThat(segment.accessQueue.isEmpty()).isTrue();\n+    assertThat(segment.writeQueue.isEmpty()).isTrue();\n+    assertThat(segment.readCount.get()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(segment.totalWeight).isEqualTo(0);\n   }\n \n   public void testClear_notification() {\n@@ -1913,7 +1925,7 @@ public void testClear_notification() {\n                 .removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -1925,17 +1937,17 @@ public void testClear_notification() {\n     segment.count = 1;\n     segment.totalWeight = 1;\n \n-    assertSame(entry, table.get(0));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertSame(entry, segment.writeQueue.peek());\n+    assertThat(table.get(0)).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n \n     segment.clear();\n-    assertNull(table.get(0));\n-    assertTrue(segment.accessQueue.isEmpty());\n-    assertTrue(segment.writeQueue.isEmpty());\n-    assertEquals(0, segment.readCount.get());\n-    assertEquals(0, segment.count);\n-    assertEquals(0, segment.totalWeight);\n+    assertThat(table.get(0)).isNull();\n+    assertThat(segment.accessQueue.isEmpty()).isTrue();\n+    assertThat(segment.writeQueue.isEmpty()).isTrue();\n+    assertThat(segment.readCount.get()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(segment.totalWeight).isEqualTo(0);\n     assertNotified(listener, key, value, RemovalCause.EXPLICIT);\n   }\n \n@@ -1950,7 +1962,7 @@ public void testRemoveEntry() {\n                 .removalListener(countingRemovalListener()));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -1958,19 +1970,19 @@ public void testRemoveEntry() {\n     DummyEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);\n \n     // remove absent\n-    assertFalse(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));\n+    assertThat(segment.removeEntry(entry, hash, RemovalCause.COLLECTED)).isFalse();\n \n     // remove live\n     segment.recordWrite(entry, 1, map.ticker.read());\n     table.set(0, entry);\n     segment.count = 1;\n-    assertTrue(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));\n+    assertThat(segment.removeEntry(entry, hash, RemovalCause.COLLECTED)).isTrue();\n     assertNotificationEnqueued(map, key, value);\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertFalse(segment.accessQueue.contains(entry));\n-    assertFalse(segment.writeQueue.contains(entry));\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.accessQueue.contains(entry)).isFalse();\n+    assertThat(segment.writeQueue.contains(entry)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n   }\n \n   public void testReclaimValue() {\n@@ -1985,7 +1997,7 @@ public void testReclaimValue() {\n                 .removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -1995,32 +2007,32 @@ public void testReclaimValue() {\n     entry.setValueReference(valueRef);\n \n     // reclaim absent\n-    assertFalse(segment.reclaimValue(key, hash, valueRef));\n+    assertThat(segment.reclaimValue(key, hash, valueRef)).isFalse();\n \n     // reclaim live\n     segment.recordWrite(entry, 1, map.ticker.read());\n     table.set(0, entry);\n     segment.count = 1;\n-    assertTrue(segment.reclaimValue(key, hash, valueRef));\n-    assertEquals(1, listener.getCount());\n-    assertSame(key, listener.getLastEvictedKey());\n-    assertSame(value, listener.getLastEvictedValue());\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertFalse(segment.accessQueue.contains(entry));\n-    assertFalse(segment.writeQueue.contains(entry));\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(segment.reclaimValue(key, hash, valueRef)).isTrue();\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(key);\n+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(value);\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.accessQueue.contains(entry)).isFalse();\n+    assertThat(segment.writeQueue.contains(entry)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n \n     // reclaim wrong value reference\n     table.set(0, entry);\n     DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);\n     entry.setValueReference(otherValueRef);\n-    assertFalse(segment.reclaimValue(key, hash, valueRef));\n-    assertEquals(1, listener.getCount());\n-    assertTrue(segment.reclaimValue(key, hash, otherValueRef));\n-    assertEquals(2, listener.getCount());\n-    assertSame(key, listener.getLastEvictedKey());\n-    assertSame(value, listener.getLastEvictedValue());\n+    assertThat(segment.reclaimValue(key, hash, valueRef)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(segment.reclaimValue(key, hash, otherValueRef)).isTrue();\n+    assertThat(listener.getCount()).isEqualTo(2);\n+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(key);\n+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(value);\n   }\n \n   public void testRemoveComputingValue() {\n@@ -2034,7 +2046,7 @@ public void testRemoveComputingValue() {\n                 .removalListener(countingRemovalListener()));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     int hash = map.hash(key);\n@@ -2043,16 +2055,16 @@ public void testRemoveComputingValue() {\n     entry.setValueReference(valueRef);\n \n     // absent\n-    assertFalse(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isFalse();\n \n     // live\n     table.set(0, entry);\n     // don't increment count; this is used during computation\n-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();\n     // no notification sent with removeLoadingValue\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n \n     // active\n     Object value = new Object();\n@@ -2061,23 +2073,23 @@ public void testRemoveComputingValue() {\n     entry.setValueReference(valueRef);\n     table.set(0, entry);\n     segment.count = 1;\n-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));\n-    assertSame(entry, table.get(0));\n-    assertSame(value, segment.get(key, hash));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();\n+    assertThat(table.get(0)).isSameInstanceAs(entry);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n \n     // wrong value reference\n     table.set(0, entry);\n     DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);\n     entry.setValueReference(otherValueRef);\n-    assertFalse(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isFalse();\n     entry.setValueReference(valueRef);\n-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();\n   }\n \n   private static <K, V> void assertNotificationEnqueued(LocalCache<K, V> map, K key, V value) {\n     RemovalNotification<K, V> notification = map.removalNotificationQueue.poll();\n-    assertSame(key, notification.getKey());\n-    assertSame(value, notification.getValue());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(value);\n   }\n \n   // Segment eviction tests\n@@ -2094,15 +2106,15 @@ public void testDrainRecencyQueueOnWrite() {\n         Object valueTwo = new Object();\n \n         map.put(keyOne, valueOne);\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {\n           map.get(keyOne);\n         }\n-        assertFalse(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isFalse();\n \n         map.put(keyTwo, valueTwo);\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n       }\n     }\n   }\n@@ -2119,16 +2131,16 @@ public void testDrainRecencyQueueOnRead() {\n         // repeated get of the same key\n \n         map.put(keyOne, valueOne);\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {\n           map.get(keyOne);\n         }\n-        assertFalse(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isFalse();\n \n         for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n           map.get(keyOne);\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n \n         // get over many different keys\n@@ -2136,16 +2148,16 @@ public void testDrainRecencyQueueOnRead() {\n         for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n           map.put(new Object(), new Object());\n         }\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {\n           map.get(keyOne);\n         }\n-        assertFalse(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isFalse();\n \n         for (Object key : map.keySet()) {\n           map.get(key);\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n       }\n     }\n@@ -2211,7 +2223,7 @@ public void testRecordReadOnGet() {\n \n       checkEvictionQueues(map, segment, readOrder, writeOrder);\n       checkExpirationTimes(map);\n-      assertTrue(segment.recencyQueue.isEmpty());\n+      assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n       // access some of the elements\n       Random random = new Random();\n@@ -2223,7 +2235,7 @@ public void testRecordReadOnGet() {\n           map.get(entry.getKey());\n           reads.add(entry);\n           i.remove();\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n       }\n       int undrainedIndex = reads.size() - segment.recencyQueue.size();\n@@ -2297,12 +2309,13 @@ static <K, V> void checkEvictionQueues(\n   private static <K, V> void assertSameEntries(\n       List<ReferenceEntry<K, V>> expectedEntries, List<ReferenceEntry<K, V>> actualEntries) {\n     int size = expectedEntries.size();\n-    assertEquals(size, actualEntries.size());\n+    assertThat(actualEntries).hasSize(size);\n     for (int i = 0; i < size; i++) {\n       ReferenceEntry<K, V> expectedEntry = expectedEntries.get(i);\n       ReferenceEntry<K, V> actualEntry = actualEntries.get(i);\n-      assertSame(expectedEntry.getKey(), actualEntry.getKey());\n-      assertSame(expectedEntry.getValueReference().get(), actualEntry.getValueReference().get());\n+      assertThat(actualEntry.getKey()).isSameInstanceAs(expectedEntry.getKey());\n+      assertThat(actualEntry.getValueReference().get())\n+          .isSameInstanceAs(expectedEntry.getValueReference().get());\n     }\n   }\n \n@@ -2316,10 +2329,10 @@ static <K, V> void checkExpirationTimes(LocalCache<K, V> map) {\n       long lastWriteTime = 0;\n       for (ReferenceEntry<K, V> e : segment.recencyQueue) {\n         long accessTime = e.getAccessTime();\n-        assertTrue(accessTime >= lastAccessTime);\n+        assertThat(accessTime).isAtLeast(lastAccessTime);\n         lastAccessTime = accessTime;\n         long writeTime = e.getWriteTime();\n-        assertTrue(writeTime >= lastWriteTime);\n+        assertThat(writeTime).isAtLeast(lastWriteTime);\n         lastWriteTime = writeTime;\n       }\n \n@@ -2327,12 +2340,12 @@ static <K, V> void checkExpirationTimes(LocalCache<K, V> map) {\n       lastWriteTime = 0;\n       for (ReferenceEntry<K, V> e : segment.accessQueue) {\n         long accessTime = e.getAccessTime();\n-        assertTrue(accessTime >= lastAccessTime);\n+        assertThat(accessTime).isAtLeast(lastAccessTime);\n         lastAccessTime = accessTime;\n       }\n       for (ReferenceEntry<K, V> e : segment.writeQueue) {\n         long writeTime = e.getWriteTime();\n-        assertTrue(writeTime >= lastWriteTime);\n+        assertThat(writeTime).isAtLeast(lastWriteTime);\n         lastWriteTime = writeTime;\n       }\n     }\n@@ -2352,31 +2365,31 @@ public void testExpireAfterWrite() {\n     Object value = new Object();\n     map.put(key, value);\n     ReferenceEntry<Object, Object> entry = map.getEntry(key);\n-    assertTrue(map.isLive(entry, ticker.read()));\n+    assertThat(map.isLive(entry, ticker.read())).isTrue();\n \n     segment.writeQueue.add(entry);\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.writeQueue.peek());\n-    assertEquals(1, segment.writeQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue).hasSize(1);\n \n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.writeQueue.peek());\n-    assertEquals(1, segment.writeQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.writeQueue.peek());\n-    assertEquals(1, segment.writeQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue).hasSize(1);\n \n     ticker.advance(1);\n-    assertNull(map.get(key));\n+    assertThat(map.get(key)).isNull();\n     segment.expireEntries(ticker.read());\n-    assertNull(map.get(key));\n-    assertTrue(segment.writeQueue.isEmpty());\n+    assertThat(map.get(key)).isNull();\n+    assertThat(segment.writeQueue.isEmpty()).isTrue();\n   }\n \n   public void testExpireAfterAccess() {\n@@ -2393,46 +2406,46 @@ public void testExpireAfterAccess() {\n     Object value = new Object();\n     map.put(key, value);\n     ReferenceEntry<Object, Object> entry = map.getEntry(key);\n-    assertTrue(map.isLive(entry, ticker.read()));\n+    assertThat(map.isLive(entry, ticker.read())).isTrue();\n \n     segment.accessQueue.add(entry);\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n-    assertFalse(map.containsKey(key));\n-    assertNull(map.get(key));\n+    assertThat(map.containsKey(key)).isFalse();\n+    assertThat(map.get(key)).isNull();\n     segment.expireEntries(ticker.read());\n-    assertFalse(map.containsKey(key));\n-    assertNull(map.get(key));\n-    assertTrue(segment.accessQueue.isEmpty());\n+    assertThat(map.containsKey(key)).isFalse();\n+    assertThat(map.get(key)).isNull();\n+    assertThat(segment.accessQueue.isEmpty()).isTrue();\n   }\n \n   public void testEvictEntries() {\n@@ -2461,8 +2474,8 @@ public void testEvictEntries() {\n     }\n     segment.count = originalCount;\n     segment.totalWeight = originalCount;\n-    assertEquals(originalCount, map.size());\n-    assertEquals(originalMap, map);\n+    assertThat(map).hasSize(originalCount);\n+    assertThat(map).isEqualTo(originalMap);\n \n     Iterator<Object> it = originalMap.keySet().iterator();\n     for (int i = 0; i < originalCount - maxSize; i++) {\n@@ -2470,8 +2483,8 @@ public void testEvictEntries() {\n       it.remove();\n     }\n     segment.evictEntries(entry);\n-    assertEquals(maxSize, map.size());\n-    assertEquals(originalMap, map);\n+    assertThat(map).hasSize(maxSize);\n+    assertThat(map).isEqualTo(originalMap);\n   }\n \n   // reference queues\n@@ -2496,11 +2509,11 @@ public void testDrainKeyReferenceQueueOnWrite() {\n         reference.enqueue();\n \n         map.put(keyTwo, valueTwo);\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(1, map.size());\n-        assertNull(segment.keyReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).hasSize(1);\n+        assertThat(segment.keyReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2526,11 +2539,11 @@ public void testDrainValueReferenceQueueOnWrite() {\n         reference.enqueue();\n \n         map.put(keyTwo, valueTwo);\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(1, map.size());\n-        assertNull(segment.valueReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).hasSize(1);\n+        assertThat(segment.valueReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2556,11 +2569,11 @@ public void testDrainKeyReferenceQueueOnRead() {\n         for (int i = 0; i < SMALL_MAX_SIZE; i++) {\n           map.get(keyTwo);\n         }\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(0, map.size());\n-        assertNull(segment.keyReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).isEmpty();\n+        assertThat(segment.keyReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2587,11 +2600,11 @@ public void testDrainValueReferenceQueueOnRead() {\n         for (int i = 0; i < SMALL_MAX_SIZE; i++) {\n           map.get(keyTwo);\n         }\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(0, map.size());\n-        assertNull(segment.valueReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).isEmpty();\n+        assertThat(segment.valueReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2624,42 +2637,45 @@ public void testSerializationProxyLoading() {\n                 .build(loader);\n     // add a non-serializable entry\n     one.getUnchecked(new Object());\n-    assertEquals(1, one.size());\n-    assertFalse(one.asMap().isEmpty());\n+    assertThat(one.size()).isEqualTo(1);\n+    assertThat(one.asMap().isEmpty()).isFalse();\n     LocalLoadingCache<Object, Object> two = SerializableTester.reserialize(one);\n-    assertEquals(0, two.size());\n-    assertTrue(two.asMap().isEmpty());\n+    assertThat(two.size()).isEqualTo(0);\n+    assertThat(two.asMap().isEmpty()).isTrue();\n \n     LocalCache<Object, Object> localCacheOne = one.localCache;\n     LocalCache<Object, Object> localCacheTwo = two.localCache;\n \n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.maxWeight, localCacheTwo.maxWeight);\n-    assertEquals(localCacheOne.weigher, localCacheTwo.weigher);\n-    assertEquals(localCacheOne.expireAfterAccessNanos, localCacheTwo.expireAfterAccessNanos);\n-    assertEquals(localCacheOne.expireAfterWriteNanos, localCacheTwo.expireAfterWriteNanos);\n-    assertEquals(localCacheOne.refreshNanos, localCacheTwo.refreshNanos);\n-    assertEquals(localCacheOne.removalListener, localCacheTwo.removalListener);\n-    assertEquals(localCacheOne.ticker, localCacheTwo.ticker);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.maxWeight).isEqualTo(localCacheOne.maxWeight);\n+    assertThat(localCacheTwo.weigher).isEqualTo(localCacheOne.weigher);\n+    assertThat(localCacheTwo.expireAfterAccessNanos)\n+        .isEqualTo(localCacheOne.expireAfterAccessNanos);\n+    assertThat(localCacheTwo.expireAfterWriteNanos).isEqualTo(localCacheOne.expireAfterWriteNanos);\n+    assertThat(localCacheTwo.refreshNanos).isEqualTo(localCacheOne.refreshNanos);\n+    assertThat(localCacheTwo.removalListener).isEqualTo(localCacheOne.removalListener);\n+    assertThat(localCacheTwo.ticker).isEqualTo(localCacheOne.ticker);\n \n     // serialize the reconstituted version to be sure we haven't lost the ability to reserialize\n     LocalLoadingCache<Object, Object> three = SerializableTester.reserialize(two);\n     LocalCache<Object, Object> localCacheThree = three.localCache;\n \n-    assertEquals(localCacheTwo.defaultLoader, localCacheThree.defaultLoader);\n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.maxWeight, localCacheThree.maxWeight);\n-    assertEquals(localCacheTwo.weigher, localCacheThree.weigher);\n-    assertEquals(localCacheTwo.expireAfterAccessNanos, localCacheThree.expireAfterAccessNanos);\n-    assertEquals(localCacheTwo.expireAfterWriteNanos, localCacheThree.expireAfterWriteNanos);\n-    assertEquals(localCacheTwo.removalListener, localCacheThree.removalListener);\n-    assertEquals(localCacheTwo.ticker, localCacheThree.ticker);\n+    assertThat(localCacheThree.defaultLoader).isEqualTo(localCacheTwo.defaultLoader);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.maxWeight).isEqualTo(localCacheTwo.maxWeight);\n+    assertThat(localCacheThree.weigher).isEqualTo(localCacheTwo.weigher);\n+    assertThat(localCacheThree.expireAfterAccessNanos)\n+        .isEqualTo(localCacheTwo.expireAfterAccessNanos);\n+    assertThat(localCacheThree.expireAfterWriteNanos)\n+        .isEqualTo(localCacheTwo.expireAfterWriteNanos);\n+    assertThat(localCacheThree.removalListener).isEqualTo(localCacheTwo.removalListener);\n+    assertThat(localCacheThree.ticker).isEqualTo(localCacheTwo.ticker);\n   }\n \n   public void testSerializationProxyManual() {\n@@ -2681,40 +2697,43 @@ public void testSerializationProxyManual() {\n                 .build();\n     // add a non-serializable entry\n     one.put(new Object(), new Object());\n-    assertEquals(1, one.size());\n-    assertFalse(one.asMap().isEmpty());\n+    assertThat(one.size()).isEqualTo(1);\n+    assertThat(one.asMap().isEmpty()).isFalse();\n     LocalManualCache<Object, Object> two = SerializableTester.reserialize(one);\n-    assertEquals(0, two.size());\n-    assertTrue(two.asMap().isEmpty());\n+    assertThat(two.size()).isEqualTo(0);\n+    assertThat(two.asMap().isEmpty()).isTrue();\n \n     LocalCache<Object, Object> localCacheOne = one.localCache;\n     LocalCache<Object, Object> localCacheTwo = two.localCache;\n \n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.maxWeight, localCacheTwo.maxWeight);\n-    assertEquals(localCacheOne.weigher, localCacheTwo.weigher);\n-    assertEquals(localCacheOne.expireAfterAccessNanos, localCacheTwo.expireAfterAccessNanos);\n-    assertEquals(localCacheOne.expireAfterWriteNanos, localCacheTwo.expireAfterWriteNanos);\n-    assertEquals(localCacheOne.removalListener, localCacheTwo.removalListener);\n-    assertEquals(localCacheOne.ticker, localCacheTwo.ticker);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.maxWeight).isEqualTo(localCacheOne.maxWeight);\n+    assertThat(localCacheTwo.weigher).isEqualTo(localCacheOne.weigher);\n+    assertThat(localCacheTwo.expireAfterAccessNanos)\n+        .isEqualTo(localCacheOne.expireAfterAccessNanos);\n+    assertThat(localCacheTwo.expireAfterWriteNanos).isEqualTo(localCacheOne.expireAfterWriteNanos);\n+    assertThat(localCacheTwo.removalListener).isEqualTo(localCacheOne.removalListener);\n+    assertThat(localCacheTwo.ticker).isEqualTo(localCacheOne.ticker);\n \n     // serialize the reconstituted version to be sure we haven't lost the ability to reserialize\n     LocalManualCache<Object, Object> three = SerializableTester.reserialize(two);\n     LocalCache<Object, Object> localCacheThree = three.localCache;\n \n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.maxWeight, localCacheThree.maxWeight);\n-    assertEquals(localCacheTwo.weigher, localCacheThree.weigher);\n-    assertEquals(localCacheTwo.expireAfterAccessNanos, localCacheThree.expireAfterAccessNanos);\n-    assertEquals(localCacheTwo.expireAfterWriteNanos, localCacheThree.expireAfterWriteNanos);\n-    assertEquals(localCacheTwo.removalListener, localCacheThree.removalListener);\n-    assertEquals(localCacheTwo.ticker, localCacheThree.ticker);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.maxWeight).isEqualTo(localCacheTwo.maxWeight);\n+    assertThat(localCacheThree.weigher).isEqualTo(localCacheTwo.weigher);\n+    assertThat(localCacheThree.expireAfterAccessNanos)\n+        .isEqualTo(localCacheTwo.expireAfterAccessNanos);\n+    assertThat(localCacheThree.expireAfterWriteNanos)\n+        .isEqualTo(localCacheTwo.expireAfterWriteNanos);\n+    assertThat(localCacheThree.removalListener).isEqualTo(localCacheTwo.removalListener);\n+    assertThat(localCacheThree.ticker).isEqualTo(localCacheTwo.ticker);\n   }\n \n   public void testLoadDifferentKeyInLoader() throws ExecutionException, InterruptedException {\n@@ -2722,16 +2741,16 @@ public void testLoadDifferentKeyInLoader() throws ExecutionException, Interrupte\n     String key1 = \"key1\";\n     String key2 = \"key2\";\n \n-    assertEquals(\n-        key2,\n-        cache.get(\n-            key1,\n-            new CacheLoader<String, String>() {\n-              @Override\n-              public String load(String key) throws Exception {\n-                return cache.get(key2, identityLoader()); // loads a different key, should work\n-              }\n-            }));\n+    assertThat(\n+            cache.get(\n+                key1,\n+                new CacheLoader<String, String>() {\n+                  @Override\n+                  public String load(String key) throws Exception {\n+                    return cache.get(key2, identityLoader()); // loads a different key, should work\n+                  }\n+                }))\n+        .isEqualTo(key2);\n   }\n \n   public void testRecursiveLoad() throws InterruptedException {\ndiff --git a/android/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java b/android/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java\nindex 1f927b731894..20dce52c426b 100644\n--- a/android/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java\n@@ -62,7 +62,7 @@ public Object load(Object from) {\n           }\n         };\n     LocalLoadingCache<Object, Object> cache = makeCache(createCacheBuilder(), loader);\n-    assertSame(loader, cache.localCache.defaultLoader);\n+    assertThat(cache.localCache.defaultLoader).isSameInstanceAs(loader);\n   }\n \n   // null parameters test\n@@ -78,82 +78,82 @@ public void testNullParameters() throws Exception {\n   public void testStats() {\n     CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1).maximumSize(2);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     cache.getUnchecked(one);\n     CacheStats stats = cache.stats();\n-    assertEquals(1, stats.requestCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n     assertThat(stats.hitRate()).isEqualTo(0.0);\n-    assertEquals(1, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n     assertThat(stats.missRate()).isEqualTo(1.0);\n-    assertEquals(1, stats.loadCount());\n+    assertThat(stats.loadCount()).isEqualTo(1);\n     long totalLoadTime = stats.totalLoadTime();\n-    assertTrue(totalLoadTime >= 0);\n-    assertTrue(stats.averageLoadPenalty() >= 0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(totalLoadTime).isAtLeast(0);\n+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n \n     cache.getUnchecked(one);\n     stats = cache.stats();\n-    assertEquals(2, stats.requestCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n     assertThat(stats.hitRate()).isEqualTo(1.0 / 2);\n-    assertEquals(1, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n     assertThat(stats.missRate()).isEqualTo(1.0 / 2);\n-    assertEquals(1, stats.loadCount());\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.loadCount()).isEqualTo(1);\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n \n     Object two = new Object();\n     cache.getUnchecked(two);\n     stats = cache.stats();\n-    assertEquals(3, stats.requestCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n     assertThat(stats.hitRate()).isEqualTo(1.0 / 3);\n-    assertEquals(2, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n     assertThat(stats.missRate()).isEqualTo(2.0 / 3);\n-    assertEquals(2, stats.loadCount());\n-    assertTrue(stats.totalLoadTime() >= totalLoadTime);\n+    assertThat(stats.loadCount()).isEqualTo(2);\n+    assertThat(stats.totalLoadTime()).isAtLeast(totalLoadTime);\n     totalLoadTime = stats.totalLoadTime();\n-    assertTrue(stats.averageLoadPenalty() >= 0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n \n     Object three = new Object();\n     cache.getUnchecked(three);\n     stats = cache.stats();\n-    assertEquals(4, stats.requestCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n     assertThat(stats.hitRate()).isEqualTo(1.0 / 4);\n-    assertEquals(3, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n     assertThat(stats.missRate()).isEqualTo(3.0 / 4);\n-    assertEquals(3, stats.loadCount());\n-    assertTrue(stats.totalLoadTime() >= totalLoadTime);\n-    assertTrue(stats.averageLoadPenalty() >= 0.0);\n-    assertEquals(1, stats.evictionCount());\n+    assertThat(stats.loadCount()).isEqualTo(3);\n+    assertThat(stats.totalLoadTime()).isAtLeast(totalLoadTime);\n+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);\n+    assertThat(stats.evictionCount()).isEqualTo(1);\n   }\n \n   public void testStatsNoops() {\n     CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n     ConcurrentMap<Object, Object> map = cache.localCache; // modifiable map view\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     assertNull(map.put(one, one));\n-    assertSame(one, map.get(one));\n-    assertTrue(map.containsKey(one));\n-    assertTrue(map.containsValue(one));\n+    assertThat(map.get(one)).isSameInstanceAs(one);\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map.containsValue(one)).isTrue();\n     Object two = new Object();\n-    assertSame(one, map.replace(one, two));\n-    assertTrue(map.containsKey(one));\n-    assertFalse(map.containsValue(one));\n+    assertThat(map.replace(one, two)).isSameInstanceAs(one);\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map.containsValue(one)).isFalse();\n     Object three = new Object();\n-    assertTrue(map.replace(one, two, three));\n-    assertTrue(map.remove(one, three));\n-    assertFalse(map.containsKey(one));\n-    assertFalse(map.containsValue(one));\n+    assertThat(map.replace(one, two, three)).isTrue();\n+    assertThat(map.remove(one, three)).isTrue();\n+    assertThat(map.containsKey(one)).isFalse();\n+    assertThat(map.containsValue(one)).isFalse();\n     assertNull(map.putIfAbsent(two, three));\n-    assertSame(three, map.remove(two));\n+    assertThat(map.remove(two)).isSameInstanceAs(three);\n     assertNull(map.put(three, one));\n     assertNull(map.put(one, two));\n \n@@ -171,56 +171,56 @@ public void testStatsNoops() {\n \n     map.clear();\n \n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n   }\n \n   public void testNoStats() {\n     CacheBuilder<Object, Object> builder =\n         CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(2);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     cache.getUnchecked(one);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     cache.getUnchecked(one);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object two = new Object();\n     cache.getUnchecked(two);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object three = new Object();\n     cache.getUnchecked(three);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n   }\n \n   public void testRecordStats() {\n     CacheBuilder<Object, Object> builder =\n         createCacheBuilder().recordStats().concurrencyLevel(1).maximumSize(2);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(0, cache.stats().hitCount());\n-    assertEquals(0, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(0);\n+    assertThat(cache.stats().missCount()).isEqualTo(0);\n \n     Object one = new Object();\n     cache.getUnchecked(one);\n-    assertEquals(0, cache.stats().hitCount());\n-    assertEquals(1, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(0);\n+    assertThat(cache.stats().missCount()).isEqualTo(1);\n \n     cache.getUnchecked(one);\n-    assertEquals(1, cache.stats().hitCount());\n-    assertEquals(1, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(1);\n+    assertThat(cache.stats().missCount()).isEqualTo(1);\n \n     Object two = new Object();\n     cache.getUnchecked(two);\n-    assertEquals(1, cache.stats().hitCount());\n-    assertEquals(2, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(1);\n+    assertThat(cache.stats().missCount()).isEqualTo(2);\n \n     Object three = new Object();\n     cache.getUnchecked(three);\n-    assertEquals(1, cache.stats().hitCount());\n-    assertEquals(3, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(1);\n+    assertThat(cache.stats().missCount()).isEqualTo(3);\n   }\n \n   // asMap tests\n@@ -228,7 +228,7 @@ public void testRecordStats() {\n   public void testAsMap() {\n     CacheBuilder<Object, Object> builder = createCacheBuilder();\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -236,47 +236,47 @@ public void testAsMap() {\n \n     ConcurrentMap<Object, Object> map = cache.asMap();\n     assertNull(map.put(one, two));\n-    assertSame(two, map.get(one));\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n     map.putAll(ImmutableMap.of(two, three));\n-    assertSame(three, map.get(two));\n-    assertSame(two, map.putIfAbsent(one, three));\n-    assertSame(two, map.get(one));\n+    assertThat(map.get(two)).isSameInstanceAs(three);\n+    assertThat(map.putIfAbsent(one, three)).isSameInstanceAs(two);\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n     assertNull(map.putIfAbsent(three, one));\n-    assertSame(one, map.get(three));\n-    assertSame(two, map.replace(one, three));\n-    assertSame(three, map.get(one));\n-    assertFalse(map.replace(one, two, three));\n-    assertSame(three, map.get(one));\n-    assertTrue(map.replace(one, three, two));\n-    assertSame(two, map.get(one));\n-    assertEquals(3, map.size());\n+    assertThat(map.get(three)).isSameInstanceAs(one);\n+    assertThat(map.replace(one, three)).isSameInstanceAs(two);\n+    assertThat(map.get(one)).isSameInstanceAs(three);\n+    assertThat(map.replace(one, two, three)).isFalse();\n+    assertThat(map.get(one)).isSameInstanceAs(three);\n+    assertThat(map.replace(one, three, two)).isTrue();\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n+    assertThat(map).hasSize(3);\n \n     map.clear();\n-    assertTrue(map.isEmpty());\n-    assertEquals(0, map.size());\n+    assertThat(map.isEmpty()).isTrue();\n+    assertThat(map).isEmpty();\n \n     cache.getUnchecked(one);\n-    assertEquals(1, map.size());\n-    assertSame(one, map.get(one));\n-    assertTrue(map.containsKey(one));\n-    assertTrue(map.containsValue(one));\n-    assertSame(one, map.remove(one));\n-    assertEquals(0, map.size());\n+    assertThat(map).hasSize(1);\n+    assertThat(map.get(one)).isSameInstanceAs(one);\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map.containsValue(one)).isTrue();\n+    assertThat(map.remove(one)).isSameInstanceAs(one);\n+    assertThat(map).isEmpty();\n \n     cache.getUnchecked(one);\n-    assertEquals(1, map.size());\n-    assertFalse(map.remove(one, two));\n-    assertTrue(map.remove(one, one));\n-    assertEquals(0, map.size());\n+    assertThat(map).hasSize(1);\n+    assertThat(map.remove(one, two)).isFalse();\n+    assertThat(map.remove(one, one)).isTrue();\n+    assertThat(map).isEmpty();\n \n     cache.getUnchecked(one);\n     Map<Object, Object> newMap = ImmutableMap.of(one, one);\n-    assertEquals(newMap, map);\n-    assertEquals(newMap.entrySet(), map.entrySet());\n-    assertEquals(newMap.keySet(), map.keySet());\n+    assertThat(map).isEqualTo(newMap);\n+    assertThat(map.entrySet()).isEqualTo(newMap.entrySet());\n+    assertThat(map.keySet()).isEqualTo(newMap.keySet());\n     Set<Object> expectedValues = ImmutableSet.of(one);\n     Set<Object> actualValues = ImmutableSet.copyOf(map.values());\n-    assertEquals(expectedValues, actualValues);\n+    assertThat(actualValues).isEqualTo(expectedValues);\n   }\n \n   /** Lookups on the map view shouldn't impact the recency queue. */\n@@ -288,12 +288,12 @@ public void testAsMapRecency() {\n     ConcurrentMap<Object, Object> map = cache.asMap();\n \n     Object one = new Object();\n-    assertSame(one, cache.getUnchecked(one));\n-    assertTrue(segment.recencyQueue.isEmpty());\n-    assertSame(one, map.get(one));\n-    assertSame(one, segment.recencyQueue.peek().getKey());\n-    assertSame(one, cache.getUnchecked(one));\n-    assertFalse(segment.recencyQueue.isEmpty());\n+    assertThat(cache.getUnchecked(one)).isSameInstanceAs(one);\n+    assertThat(segment.recencyQueue.isEmpty()).isTrue();\n+    assertThat(map.get(one)).isSameInstanceAs(one);\n+    assertThat(segment.recencyQueue.peek().getKey()).isSameInstanceAs(one);\n+    assertThat(cache.getUnchecked(one)).isSameInstanceAs(one);\n+    assertThat(segment.recencyQueue.isEmpty()).isFalse();\n   }\n \n   public void testRecursiveComputation() throws InterruptedException {\n@@ -313,7 +313,7 @@ public String load(Integer key) {\n     LoadingCache<Integer, String> recursiveCache =\n         CacheBuilder.newBuilder().weakKeys().weakValues().build(recursiveLoader);\n     cacheRef.set(recursiveCache);\n-    assertEquals(\"3, 2, 1, 0\", recursiveCache.getUnchecked(3));\n+    assertThat(recursiveCache.getUnchecked(3)).isEqualTo(\"3, 2, 1, 0\");\n \n     recursiveLoader =\n         new CacheLoader<Integer, String>() {\ndiff --git a/android/guava-tests/test/com/google/common/cache/NullCacheTest.java b/android/guava-tests/test/com/google/common/cache/NullCacheTest.java\nindex ae49a5366394..5def1a0ac218 100644\n--- a/android/guava-tests/test/com/google/common/cache/NullCacheTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/NullCacheTest.java\n@@ -51,12 +51,12 @@ public void testGet() {\n             .build(constantLoader(computed));\n \n     Object key = new Object();\n-    assertSame(computed, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(computed, notification.getValue());\n-    assertSame(RemovalCause.SIZE, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(computed);\n+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -69,12 +69,12 @@ public void testGet_expireAfterWrite() {\n             .build(constantLoader(computed));\n \n     Object key = new Object();\n-    assertSame(computed, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(computed, notification.getValue());\n-    assertSame(RemovalCause.SIZE, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(computed);\n+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -87,12 +87,12 @@ public void testGet_expireAfterAccess() {\n             .build(constantLoader(computed));\n \n     Object key = new Object();\n-    assertSame(computed, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(computed, notification.getValue());\n-    assertSame(RemovalCause.SIZE, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(computed);\n+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -105,7 +105,7 @@ public void testGet_computeNull() {\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(new Object()));\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -120,7 +120,7 @@ public void testGet_runtimeException() {\n     UncheckedExecutionException uee =\n         assertThrows(UncheckedExecutionException.class, () -> map.getUnchecked(new Object()));\n     assertThat(uee).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(map);\n   }\n }\ndiff --git a/android/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java b/android/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java\nindex ea2066d1b09a..0c529574f1d1 100644\n--- a/android/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java\n+++ b/android/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java\n@@ -59,7 +59,7 @@ public void testSize_populated() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       // don't let the entries get GCed\n       List<Entry<Object, Object>> unused = warmUp(cache);\n-      assertEquals(WARMUP_SIZE, cache.size());\n+      assertThat(cache.size()).isEqualTo(WARMUP_SIZE);\n       assertMapSize(cache.asMap(), WARMUP_SIZE);\n       checkValidState(cache);\n     }\n@@ -71,12 +71,12 @@ public void testContainsKey_found() {\n       List<Entry<Object, Object>> warmed = warmUp(cache);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n-        assertTrue(cache.asMap().containsKey(entry.getKey()));\n-        assertTrue(cache.asMap().containsValue(entry.getValue()));\n+        assertThat(cache.asMap().containsKey(entry.getKey())).isTrue();\n+        assertThat(cache.asMap().containsValue(entry.getValue())).isTrue();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -88,18 +88,18 @@ public void testPut_populated() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object newValue = new Object();\n-        assertSame(entry.getValue(), cache.asMap().put(entry.getKey(), newValue));\n+        assertThat(cache.asMap().put(entry.getKey(), newValue)).isSameInstanceAs(entry.getValue());\n         // don't let the new entry get GCed\n         warmed.add(entryOf(entry.getKey(), newValue));\n         Object newKey = new Object();\n-        assertNull(cache.asMap().put(newKey, entry.getValue()));\n+        assertThat(cache.asMap().put(newKey, entry.getValue())).isNull();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(newValue, cache.getUnchecked(entry.getKey()));\n-        assertEquals(entry.getValue(), cache.getUnchecked(newKey));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(newValue);\n+        assertThat(cache.getUnchecked(newKey)).isEqualTo(entry.getValue());\n         // don't let the new entry get GCed\n         warmed.add(entryOf(newKey, entry.getValue()));\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -111,16 +111,17 @@ public void testPutIfAbsent_populated() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object newValue = new Object();\n-        assertSame(entry.getValue(), cache.asMap().putIfAbsent(entry.getKey(), newValue));\n+        assertThat(cache.asMap().putIfAbsent(entry.getKey(), newValue))\n+            .isSameInstanceAs(entry.getValue());\n         Object newKey = new Object();\n-        assertNull(cache.asMap().putIfAbsent(newKey, entry.getValue()));\n+        assertThat(cache.asMap().putIfAbsent(newKey, entry.getValue())).isNull();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));\n-        assertEquals(entry.getValue(), cache.getUnchecked(newKey));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());\n+        assertThat(cache.getUnchecked(newKey)).isEqualTo(entry.getValue());\n         // don't let the new entry get GCed\n         warmed.add(entryOf(newKey, entry.getValue()));\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -133,8 +134,8 @@ public void testPutAll_populated() {\n       Object newValue = new Object();\n       cache.asMap().putAll(ImmutableMap.of(newKey, newValue));\n       // this getUnchecked() call shouldn't be a cache miss; verified below\n-      assertEquals(newValue, cache.getUnchecked(newKey));\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.getUnchecked(newKey)).isEqualTo(newValue);\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -146,16 +147,17 @@ public void testReplace_populated() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object newValue = new Object();\n-        assertSame(entry.getValue(), cache.asMap().replace(entry.getKey(), newValue));\n-        assertTrue(cache.asMap().replace(entry.getKey(), newValue, entry.getValue()));\n+        assertThat(cache.asMap().replace(entry.getKey(), newValue))\n+            .isSameInstanceAs(entry.getValue());\n+        assertThat(cache.asMap().replace(entry.getKey(), newValue, entry.getValue())).isTrue();\n         Object newKey = new Object();\n-        assertNull(cache.asMap().replace(newKey, entry.getValue()));\n-        assertFalse(cache.asMap().replace(newKey, entry.getValue(), newValue));\n+        assertThat(cache.asMap().replace(newKey, entry.getValue())).isNull();\n+        assertThat(cache.asMap().replace(newKey, entry.getValue(), newValue)).isFalse();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));\n-        assertFalse(cache.asMap().containsKey(newKey));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());\n+        assertThat(cache.asMap().containsKey(newKey)).isFalse();\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -167,9 +169,9 @@ public void testRemove_byKey() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object key = entry.getKey();\n-        assertEquals(entry.getValue(), cache.asMap().remove(key));\n-        assertNull(cache.asMap().remove(key));\n-        assertFalse(cache.asMap().containsKey(key));\n+        assertThat(cache.asMap().remove(key)).isEqualTo(entry.getValue());\n+        assertThat(cache.asMap().remove(key)).isNull();\n+        assertThat(cache.asMap().containsKey(key)).isFalse();\n       }\n       checkEmpty(cache);\n     }\n@@ -182,10 +184,10 @@ public void testRemove_byKeyAndValue() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Object key = warmed.get(i - WARMUP_MIN).getKey();\n         Object value = warmed.get(i - WARMUP_MIN).getValue();\n-        assertFalse(cache.asMap().remove(key, -1));\n-        assertTrue(cache.asMap().remove(key, value));\n-        assertFalse(cache.asMap().remove(key, -1));\n-        assertFalse(cache.asMap().containsKey(key));\n+        assertThat(cache.asMap().remove(key, -1)).isFalse();\n+        assertThat(cache.asMap().remove(key, value)).isTrue();\n+        assertThat(cache.asMap().remove(key, -1)).isFalse();\n+        assertThat(cache.asMap().containsKey(key)).isFalse();\n       }\n       checkEmpty(cache);\n     }\n@@ -206,13 +208,13 @@ public void testKeySet_populated() {\n           .addEqualityGroup(cache.asMap().keySet(), keys)\n           .addEqualityGroup(ImmutableSet.of())\n           .testEquals();\n-      assertEquals(WARMUP_SIZE, keys.size());\n+      assertThat(keys).hasSize(WARMUP_SIZE);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Object key = warmed.get(i - WARMUP_MIN).getKey();\n-        assertTrue(keys.contains(key));\n-        assertTrue(keys.remove(key));\n-        assertFalse(keys.remove(key));\n-        assertFalse(keys.contains(key));\n+        assertThat(keys.contains(key)).isTrue();\n+        assertThat(keys.remove(key)).isTrue();\n+        assertThat(keys.remove(key)).isFalse();\n+        assertThat(keys.contains(key)).isFalse();\n       }\n       checkEmpty(keys);\n       checkEmpty(cache);\n@@ -229,13 +231,13 @@ public void testValues_populated() {\n       assertThat(values.toArray()).asList().containsExactlyElementsIn(expected);\n       assertThat(values.toArray(new Object[0])).asList().containsExactlyElementsIn(expected);\n \n-      assertEquals(WARMUP_SIZE, values.size());\n+      assertThat(values).hasSize(WARMUP_SIZE);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Object value = warmed.get(i - WARMUP_MIN).getValue();\n-        assertTrue(values.contains(value));\n-        assertTrue(values.remove(value));\n-        assertFalse(values.remove(value));\n-        assertFalse(values.contains(value));\n+        assertThat(values.contains(value)).isTrue();\n+        assertThat(values.remove(value)).isTrue();\n+        assertThat(values.remove(value)).isFalse();\n+        assertThat(values.contains(value)).isFalse();\n       }\n       checkEmpty(values);\n       checkEmpty(cache);\n@@ -257,13 +259,13 @@ public void testEntrySet_populated() {\n           .addEqualityGroup(cache.asMap().entrySet(), entries)\n           .addEqualityGroup(ImmutableSet.of())\n           .testEquals();\n-      assertEquals(WARMUP_SIZE, entries.size());\n+      assertThat(entries).hasSize(WARMUP_SIZE);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> newEntry = warmed.get(i - WARMUP_MIN);\n-        assertTrue(entries.contains(newEntry));\n-        assertTrue(entries.remove(newEntry));\n-        assertFalse(entries.remove(newEntry));\n-        assertFalse(entries.contains(newEntry));\n+        assertThat(entries.contains(newEntry)).isTrue();\n+        assertThat(entries.remove(newEntry)).isTrue();\n+        assertThat(entries.remove(newEntry)).isFalse();\n+        assertThat(entries.contains(newEntry)).isFalse();\n       }\n       checkEmpty(entries);\n       checkEmpty(cache);\n@@ -276,11 +278,11 @@ public void testWriteThroughEntry() {\n       Entry<Object, Object> entry = Iterables.getOnlyElement(cache.asMap().entrySet());\n \n       cache.invalidate(1);\n-      assertEquals(0, cache.size());\n+      assertThat(cache.size()).isEqualTo(0);\n \n       entry.setValue(3);\n-      assertEquals(1, cache.size());\n-      assertEquals(3, cache.getIfPresent(1));\n+      assertThat(cache.size()).isEqualTo(1);\n+      assertThat(cache.getIfPresent(1)).isEqualTo(3);\n       checkValidState(cache);\n \n       assertThrows(NullPointerException.class, () -> entry.setValue(null));\n@@ -356,25 +358,26 @@ private Entry<Object, Object> entryOf(Object key, Object value) {\n   }\n \n   private void assertMapSize(Map<?, ?> map, int size) {\n-    assertEquals(size, map.size());\n+    assertThat(map).hasSize(size);\n     if (size > 0) {\n-      assertFalse(map.isEmpty());\n+      assertThat(map.isEmpty()).isFalse();\n     } else {\n-      assertTrue(map.isEmpty());\n+      assertThat(map.isEmpty()).isTrue();\n     }\n     assertCollectionSize(map.keySet(), size);\n     assertCollectionSize(map.entrySet(), size);\n     assertCollectionSize(map.values(), size);\n   }\n \n+  @SuppressWarnings(\"IterablesSizeOfCollection\") // we are testing our iterator implementation\n   private void assertCollectionSize(Collection<?> collection, int size) {\n-    assertEquals(size, collection.size());\n+    assertThat(collection.size()).isEqualTo(size);\n     if (size > 0) {\n-      assertFalse(collection.isEmpty());\n+      assertThat(collection.isEmpty()).isFalse();\n     } else {\n-      assertTrue(collection.isEmpty());\n+      assertThat(collection.isEmpty()).isTrue();\n     }\n-    assertEquals(size, Iterables.size(collection));\n-    assertEquals(size, Iterators.size(collection.iterator()));\n+    assertThat(Iterables.size(collection)).isEqualTo(size);\n+    assertThat(Iterators.size(collection.iterator())).isEqualTo(size);\n   }\n }\ndiff --git a/guava-tests/test/com/google/common/cache/AbstractCacheTest.java b/guava-tests/test/com/google/common/cache/AbstractCacheTest.java\nindex f803fccedfe7..6a1fc772cf57 100644\n--- a/guava-tests/test/com/google/common/cache/AbstractCacheTest.java\n+++ b/guava-tests/test/com/google/common/cache/AbstractCacheTest.java\n@@ -21,7 +21,6 @@\n import com.google.common.cache.AbstractCache.SimpleStatsCounter;\n import com.google.common.cache.AbstractCache.StatsCounter;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -47,11 +46,11 @@ public void testGetIfPresent() {\n           }\n         };\n \n-    assertNull(cache.getIfPresent(new Object()));\n+    assertThat(cache.getIfPresent(new Object())).isNull();\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getIfPresent(new Object()));\n+    assertThat(cache.getIfPresent(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetAllPresent_empty() {\n@@ -63,7 +62,7 @@ public void testGetAllPresent_empty() {\n           }\n         };\n \n-    assertEquals(ImmutableMap.of(), cache.getAllPresent(ImmutableList.of(new Object())));\n+    assertThat(cache.getAllPresent(ImmutableList.of(new Object()))).isEmpty();\n   }\n \n   public void testGetAllPresent_cached() {\n@@ -77,9 +76,8 @@ public void testGetAllPresent_cached() {\n           }\n         };\n \n-    assertEquals(\n-        ImmutableMap.of(cachedKey, cachedValue),\n-        cache.getAllPresent(ImmutableList.of(cachedKey, new Object())));\n+    assertThat(cache.getAllPresent(ImmutableList.of(cachedKey, new Object())))\n+        .containsExactly(cachedKey, cachedValue);\n   }\n \n   public void testInvalidateAll() {\n@@ -99,23 +97,23 @@ public void invalidate(Object key) {\n \n     List<Integer> toInvalidate = ImmutableList.of(1, 2, 3, 4);\n     cache.invalidateAll(toInvalidate);\n-    assertEquals(toInvalidate, invalidated);\n+    assertThat(invalidated).isEqualTo(toInvalidate);\n   }\n \n   public void testEmptySimpleStats() {\n     StatsCounter counter = new SimpleStatsCounter();\n     CacheStats stats = counter.snapshot();\n-    assertEquals(0, stats.requestCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n     assertThat(stats.hitRate()).isEqualTo(1.0);\n-    assertEquals(0, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n     assertThat(stats.missRate()).isEqualTo(0.0);\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.loadCount());\n-    assertEquals(0, stats.totalLoadTime());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.loadCount()).isEqualTo(0);\n+    assertThat(stats.totalLoadTime()).isEqualTo(0);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n   }\n \n   public void testSingleSimpleStats() {\n@@ -137,18 +135,18 @@ public void testSingleSimpleStats() {\n     }\n     CacheStats stats = counter.snapshot();\n     int requestCount = 11 + 23;\n-    assertEquals(requestCount, stats.requestCount());\n-    assertEquals(11, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(requestCount);\n+    assertThat(stats.hitCount()).isEqualTo(11);\n     assertThat(stats.hitRate()).isEqualTo(11.0 / requestCount);\n     int missCount = 23;\n-    assertEquals(missCount, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(missCount);\n     assertThat(stats.missRate()).isEqualTo(((double) missCount) / requestCount);\n-    assertEquals(13, stats.loadSuccessCount());\n-    assertEquals(17, stats.loadExceptionCount());\n-    assertEquals(13 + 17, stats.loadCount());\n-    assertEquals(214, stats.totalLoadTime());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(13);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(17);\n+    assertThat(stats.loadCount()).isEqualTo(13 + 17);\n+    assertThat(stats.totalLoadTime()).isEqualTo(214);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(214.0 / (13 + 17));\n-    assertEquals(27, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(27);\n   }\n \n   public void testSimpleStatsOverflow() {\n@@ -156,7 +154,7 @@ public void testSimpleStatsOverflow() {\n     counter.recordLoadSuccess(Long.MAX_VALUE);\n     counter.recordLoadSuccess(1);\n     CacheStats stats = counter.snapshot();\n-    assertEquals(Long.MAX_VALUE, stats.totalLoadTime());\n+    assertThat(stats.totalLoadTime()).isEqualTo(Long.MAX_VALUE);\n   }\n \n   public void testSimpleStatsIncrementBy() {\n@@ -201,6 +199,6 @@ public void testSimpleStatsIncrementBy() {\n     }\n \n     counter1.incrementBy(counter2);\n-    assertEquals(new CacheStats(38, 60, 44, 54, totalLoadTime, 66), counter1.snapshot());\n+    assertThat(counter1.snapshot()).isEqualTo(new CacheStats(38, 60, 44, 54, totalLoadTime, 66));\n   }\n }\ndiff --git a/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java b/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java\nindex 6548982acc49..85b37bf24ed6 100644\n--- a/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java\n+++ b/guava-tests/test/com/google/common/cache/AbstractLoadingCacheTest.java\n@@ -61,7 +61,7 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetUnchecked_unchecked() {\n@@ -90,7 +90,7 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetUnchecked_error() {\n@@ -119,7 +119,7 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n \n   public void testGetUnchecked_otherThrowable() {\n@@ -148,6 +148,6 @@ public Object get(Object key) throws ExecutionException {\n \n     Object newValue = new Object();\n     valueRef.set(newValue);\n-    assertSame(newValue, cache.getUnchecked(new Object()));\n+    assertThat(cache.getUnchecked(new Object())).isSameInstanceAs(newValue);\n   }\n }\ndiff --git a/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java b/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java\nindex e1dee691ac29..600a85bbc82c 100644\n--- a/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java\n+++ b/guava-tests/test/com/google/common/cache/CacheBuilderGwtTest.java\n@@ -16,6 +16,7 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n \n import com.google.common.annotations.GwtCompatible;\n@@ -31,8 +32,11 @@\n import java.util.concurrent.Callable;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.ExecutionException;\n-import junit.framework.TestCase;\n import org.jspecify.annotations.NullUnmarked;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n \n /**\n  * Test suite for {@link CacheBuilder}. TODO(cpovirk): merge into CacheBuilderTest?\n@@ -41,18 +45,18 @@\n  */\n @GwtCompatible\n @NullUnmarked\n-public class CacheBuilderGwtTest extends TestCase {\n+@RunWith(JUnit4.class)\n+public class CacheBuilderGwtTest {\n \n   private FakeTicker fakeTicker;\n \n-  @Override\n-  protected void setUp() throws Exception {\n-    super.setUp();\n-\n+  @Before\n+  public void setUp() {\n     fakeTicker = new FakeTicker();\n   }\n \n-  public void testLoader() throws ExecutionException {\n+  @Test\n+  public void loader() throws ExecutionException {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     Callable<Integer> loader =\n@@ -67,19 +71,20 @@ public Integer call() throws Exception {\n \n     cache.put(0, 10);\n \n-    assertEquals(Integer.valueOf(10), cache.get(0, loader));\n-    assertEquals(Integer.valueOf(1), cache.get(20, loader));\n-    assertEquals(Integer.valueOf(2), cache.get(34, loader));\n+    assertThat(cache.get(0, loader)).isEqualTo(10);\n+    assertThat(cache.get(20, loader)).isEqualTo(1);\n+    assertThat(cache.get(34, loader)).isEqualTo(2);\n \n     cache.invalidate(0);\n-    assertEquals(Integer.valueOf(3), cache.get(0, loader));\n+    assertThat(cache.get(0, loader)).isEqualTo(3);\n \n     cache.put(0, 10);\n     cache.invalidateAll();\n-    assertEquals(Integer.valueOf(4), cache.get(0, loader));\n+    assertThat(cache.get(0, loader)).isEqualTo(4);\n   }\n \n-  public void testSizeConstraint() {\n+  @Test\n+  public void sizeConstraint() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().maximumSize(4).build();\n \n     cache.put(1, 10);\n@@ -88,22 +93,24 @@ public void testSizeConstraint() {\n     cache.put(4, 40);\n     cache.put(5, 50);\n \n-    assertEquals(null, cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isNull();\n     // Order required to remove dependence on access order / write order constraint.\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));\n-    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(3)).isEqualTo(30);\n+    assertThat(cache.getIfPresent(4)).isEqualTo(40);\n+    assertThat(cache.getIfPresent(5)).isEqualTo(50);\n \n     cache.put(1, 10);\n-    assertEquals(Integer.valueOf(10), cache.getIfPresent(1));\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(3));\n-    assertEquals(Integer.valueOf(40), cache.getIfPresent(4));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(5));\n-    assertEquals(null, cache.getIfPresent(2));\n+    assertThat(cache.getIfPresent(1)).isEqualTo(10);\n+    assertThat(cache.getIfPresent(3)).isEqualTo(30);\n+    assertThat(cache.getIfPresent(4)).isEqualTo(40);\n+    assertThat(cache.getIfPresent(5)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(2)).isNull();\n   }\n \n-  public void testLoadingCache() throws ExecutionException {\n+  @SuppressWarnings({\"deprecation\", \"LoadingCacheApply\"})\n+  @Test\n+  public void loadingCache() throws ExecutionException {\n     CacheLoader<Integer, Integer> loader =\n         new CacheLoader<Integer, Integer>() {\n           int i = 0;\n@@ -120,17 +127,18 @@ public Integer load(Integer key) throws Exception {\n \n     Map<Integer, Integer> map = cache.getAll(ImmutableList.of(10, 20, 30, 54, 443, 1));\n \n-    assertEquals(Integer.valueOf(20), map.get(10));\n-    assertEquals(Integer.valueOf(0), map.get(20));\n-    assertEquals(Integer.valueOf(1), map.get(30));\n-    assertEquals(Integer.valueOf(2), map.get(54));\n-    assertEquals(Integer.valueOf(3), map.get(443));\n-    assertEquals(Integer.valueOf(4), map.get(1));\n-    assertEquals(Integer.valueOf(5), cache.get(6));\n-    assertEquals(Integer.valueOf(6), cache.apply(7));\n+    assertThat(map).containsEntry(10, 20);\n+    assertThat(map).containsEntry(20, 0);\n+    assertThat(map).containsEntry(30, 1);\n+    assertThat(map).containsEntry(54, 2);\n+    assertThat(map).containsEntry(443, 3);\n+    assertThat(map).containsEntry(1, 4);\n+    assertThat(cache.get(6)).isEqualTo(5);\n+    assertThat(cache.apply(7)).isEqualTo(6);\n   }\n \n-  public void testExpireAfterAccess() {\n+  @Test\n+  public void expireAfterAccess() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterAccess(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -138,14 +146,15 @@ public void testExpireAfterAccess() {\n     cache.put(2, 30);\n \n     fakeTicker.advance(999, MILLISECONDS);\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(30);\n     fakeTicker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(30), cache.getIfPresent(2));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(30);\n     fakeTicker.advance(1000, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(0));\n+    assertThat(cache.getIfPresent(0)).isNull();\n   }\n \n-  public void testExpireAfterWrite() {\n+  @Test\n+  public void expireAfterWrite() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -154,23 +163,24 @@ public void testExpireAfterWrite() {\n     cache.put(4, 2);\n \n     fakeTicker.advance(999, MILLISECONDS);\n-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));\n-    assertEquals(Integer.valueOf(2), cache.getIfPresent(4));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(100);\n+    assertThat(cache.getIfPresent(20)).isEqualTo(200);\n+    assertThat(cache.getIfPresent(4)).isEqualTo(2);\n \n     fakeTicker.advance(2, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n-    assertEquals(null, cache.getIfPresent(20));\n-    assertEquals(null, cache.getIfPresent(4));\n+    assertThat(cache.getIfPresent(10)).isNull();\n+    assertThat(cache.getIfPresent(20)).isNull();\n+    assertThat(cache.getIfPresent(4)).isNull();\n \n     cache.put(10, 20);\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(20);\n \n     fakeTicker.advance(1000, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isNull();\n   }\n \n-  public void testExpireAfterWriteAndAccess() {\n+  @Test\n+  public void expireAfterWriteAndAccess() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder()\n             .expireAfterWrite(1000, MILLISECONDS)\n@@ -183,26 +193,28 @@ public void testExpireAfterWriteAndAccess() {\n     cache.put(4, 2);\n \n     fakeTicker.advance(499, MILLISECONDS);\n-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(100);\n+    assertThat(cache.getIfPresent(20)).isEqualTo(200);\n \n     fakeTicker.advance(2, MILLISECONDS);\n-    assertEquals(Integer.valueOf(100), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(200), cache.getIfPresent(20));\n-    assertEquals(null, cache.getIfPresent(4));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(100);\n+    assertThat(cache.getIfPresent(20)).isEqualTo(200);\n+    assertThat(cache.getIfPresent(4)).isNull();\n \n     fakeTicker.advance(499, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n-    assertEquals(null, cache.getIfPresent(20));\n+    assertThat(cache.getIfPresent(10)).isNull();\n+    assertThat(cache.getIfPresent(20)).isNull();\n \n     cache.put(10, 20);\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(20);\n \n     fakeTicker.advance(500, MILLISECONDS);\n-    assertEquals(null, cache.getIfPresent(10));\n+    assertThat(cache.getIfPresent(10)).isNull();\n   }\n \n-  public void testMapMethods() {\n+  @SuppressWarnings(\"ContainsEntryAfterGetInteger\") // we are testing our implementation of Map.get\n+  @Test\n+  public void mapMethods() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     ConcurrentMap<Integer, Integer> asMap = cache.asMap();\n@@ -213,38 +225,39 @@ public void testMapMethods() {\n     asMap.replace(2, 79);\n     asMap.replace(3, 60);\n \n-    assertEquals(null, cache.getIfPresent(3));\n-    assertEquals(null, asMap.get(3));\n+    assertThat(cache.getIfPresent(3)).isNull();\n+    assertThat(asMap.get(3)).isNull();\n \n-    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(79), asMap.get(2));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(79);\n+    assertThat(asMap.get(2)).isEqualTo(79);\n \n     asMap.replace(10, 100, 50);\n     asMap.replace(2, 52, 99);\n \n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), asMap.get(10));\n-    assertEquals(Integer.valueOf(79), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(79), asMap.get(2));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(asMap.get(10)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(2)).isEqualTo(79);\n+    assertThat(asMap.get(2)).isEqualTo(79);\n \n     asMap.remove(10, 100);\n     asMap.remove(2, 79);\n \n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), asMap.get(10));\n-    assertEquals(null, cache.getIfPresent(2));\n-    assertEquals(null, asMap.get(2));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(asMap.get(10)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(2)).isNull();\n+    assertThat(asMap.get(2)).isNull();\n \n     asMap.putIfAbsent(2, 20);\n     asMap.putIfAbsent(10, 20);\n \n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(2));\n-    assertEquals(Integer.valueOf(20), asMap.get(2));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), asMap.get(10));\n+    assertThat(cache.getIfPresent(2)).isEqualTo(20);\n+    assertThat(asMap.get(2)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(asMap.get(10)).isEqualTo(50);\n   }\n \n-  public void testRemovalListener() {\n+  @Test\n+  public void removalListener() {\n     int[] stats = new int[4];\n \n     RemovalListener<Integer, Integer> countingListener =\n@@ -303,30 +316,32 @@ public void onRemoval(RemovalNotification<Integer, Integer> notification) {\n \n     cache.invalidateAll();\n \n-    assertEquals(2, stats[0]);\n-    assertEquals(2, stats[1]);\n-    assertEquals(4, stats[2]);\n-    assertEquals(3, stats[3]);\n+    assertThat(stats[0]).isEqualTo(2);\n+    assertThat(stats[1]).isEqualTo(2);\n+    assertThat(stats[2]).isEqualTo(4);\n+    assertThat(stats[3]).isEqualTo(3);\n   }\n \n-  public void testPutAll() {\n+  @Test\n+  public void putAll() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     cache.putAll(ImmutableMap.of(10, 20, 30, 50, 60, 90));\n \n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(30));\n-    assertEquals(Integer.valueOf(90), cache.getIfPresent(60));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(30)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(60)).isEqualTo(90);\n \n     cache.asMap().putAll(ImmutableMap.of(10, 50, 30, 20, 60, 70, 5, 5));\n \n-    assertEquals(Integer.valueOf(50), cache.getIfPresent(10));\n-    assertEquals(Integer.valueOf(20), cache.getIfPresent(30));\n-    assertEquals(Integer.valueOf(70), cache.getIfPresent(60));\n-    assertEquals(Integer.valueOf(5), cache.getIfPresent(5));\n+    assertThat(cache.getIfPresent(10)).isEqualTo(50);\n+    assertThat(cache.getIfPresent(30)).isEqualTo(20);\n+    assertThat(cache.getIfPresent(60)).isEqualTo(70);\n+    assertThat(cache.getIfPresent(5)).isEqualTo(5);\n   }\n \n-  public void testInvalidate() {\n+  @Test\n+  public void invalidate() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     cache.put(654, 2675);\n@@ -335,12 +350,13 @@ public void testInvalidate() {\n \n     cache.invalidate(654);\n \n-    assertFalse(cache.asMap().containsKey(654));\n-    assertTrue(cache.asMap().containsKey(2456));\n-    assertTrue(cache.asMap().containsKey(2));\n+    assertThat(cache.asMap().containsKey(654)).isFalse();\n+    assertThat(cache.asMap().containsKey(2456)).isTrue();\n+    assertThat(cache.asMap().containsKey(2)).isTrue();\n   }\n \n-  public void testInvalidateAll() {\n+  @Test\n+  public void invalidateAll() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().build();\n \n     cache.put(654, 2675);\n@@ -348,9 +364,9 @@ public void testInvalidateAll() {\n     cache.put(2, 15);\n \n     cache.invalidateAll();\n-    assertFalse(cache.asMap().containsKey(654));\n-    assertFalse(cache.asMap().containsKey(2456));\n-    assertFalse(cache.asMap().containsKey(2));\n+    assertThat(cache.asMap().containsKey(654)).isFalse();\n+    assertThat(cache.asMap().containsKey(2456)).isFalse();\n+    assertThat(cache.asMap().containsKey(2)).isFalse();\n \n     cache.put(654, 2675);\n     cache.put(2456, 56);\n@@ -359,13 +375,14 @@ public void testInvalidateAll() {\n \n     cache.invalidateAll(ImmutableSet.of(1, 2));\n \n-    assertFalse(cache.asMap().containsKey(1));\n-    assertFalse(cache.asMap().containsKey(2));\n-    assertTrue(cache.asMap().containsKey(654));\n-    assertTrue(cache.asMap().containsKey(2456));\n+    assertThat(cache.asMap().containsKey(1)).isFalse();\n+    assertThat(cache.asMap().containsKey(2)).isFalse();\n+    assertThat(cache.asMap().containsKey(654)).isTrue();\n+    assertThat(cache.asMap().containsKey(2456)).isTrue();\n   }\n \n-  public void testAsMap_containsValue() {\n+  @Test\n+  public void asMap_containsValue() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(20000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -376,12 +393,15 @@ public void testAsMap_containsValue() {\n \n     fakeTicker.advance(10001, MILLISECONDS);\n \n-    assertTrue(cache.asMap().containsValue(15));\n-    assertTrue(cache.asMap().containsValue(56));\n-    assertFalse(cache.asMap().containsValue(2675));\n+    assertThat(cache.asMap().containsValue(15)).isTrue();\n+    assertThat(cache.asMap().containsValue(56)).isTrue();\n+    assertThat(cache.asMap().containsValue(2675)).isFalse();\n   }\n \n-  public void testAsMap_containsKey() {\n+  // we are testing our implementation of Map.containsKey\n+  @SuppressWarnings(\"ContainsEntryAfterGetInteger\")\n+  @Test\n+  public void asMap_containsKey() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(20000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -392,12 +412,15 @@ public void testAsMap_containsKey() {\n \n     fakeTicker.advance(10001, MILLISECONDS);\n \n-    assertTrue(cache.asMap().containsKey(2));\n-    assertTrue(cache.asMap().containsKey(2456));\n-    assertFalse(cache.asMap().containsKey(654));\n+    assertThat(cache.asMap().containsKey(2)).isTrue();\n+    assertThat(cache.asMap().containsKey(2456)).isTrue();\n+    assertThat(cache.asMap().containsKey(654)).isFalse();\n   }\n \n-  public void testAsMapValues_contains() {\n+  // we are testing our implementation of Map.values().contains\n+  @SuppressWarnings(\"ValuesContainsValue\")\n+  @Test\n+  public void asMapValues_contains() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -408,12 +431,13 @@ public void testAsMapValues_contains() {\n \n     fakeTicker.advance(501, MILLISECONDS);\n \n-    assertTrue(cache.asMap().values().contains(22));\n-    assertTrue(cache.asMap().values().contains(10));\n-    assertFalse(cache.asMap().values().contains(20));\n+    assertThat(cache.asMap().values().contains(22)).isTrue();\n+    assertThat(cache.asMap().values().contains(10)).isTrue();\n+    assertThat(cache.asMap().values().contains(20)).isFalse();\n   }\n \n-  public void testAsMapKeySet() {\n+  @Test\n+  public void asMapKeySet() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -426,10 +450,11 @@ public void testAsMapKeySet() {\n \n     Set<Integer> foundKeys = new HashSet<>(cache.asMap().keySet());\n \n-    assertEquals(ImmutableSet.of(20, 5), foundKeys);\n+    assertThat(foundKeys).containsExactly(20, 5);\n   }\n \n-  public void testAsMapKeySet_contains() {\n+  @Test\n+  public void asMapKeySet_contains() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -440,12 +465,13 @@ public void testAsMapKeySet_contains() {\n \n     fakeTicker.advance(501, MILLISECONDS);\n \n-    assertTrue(cache.asMap().keySet().contains(20));\n-    assertTrue(cache.asMap().keySet().contains(5));\n-    assertFalse(cache.asMap().keySet().contains(10));\n+    assertThat(cache.asMap().keySet().contains(20)).isTrue();\n+    assertThat(cache.asMap().keySet().contains(5)).isTrue();\n+    assertThat(cache.asMap().keySet().contains(10)).isFalse();\n   }\n \n-  public void testAsMapEntrySet() {\n+  @Test\n+  public void asMapEntrySet() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -460,10 +486,11 @@ public void testAsMapEntrySet() {\n     for (Entry<Integer, Integer> current : cache.asMap().entrySet()) {\n       sum += current.getKey() + current.getValue();\n     }\n-    assertEquals(57, sum);\n+    assertThat(sum).isEqualTo(57);\n   }\n \n-  public void testAsMapValues_iteratorRemove() {\n+  @Test\n+  public void asMapValues_iteratorRemove() {\n     Cache<Integer, Integer> cache =\n         CacheBuilder.newBuilder().expireAfterWrite(1000, MILLISECONDS).ticker(fakeTicker).build();\n \n@@ -472,6 +499,6 @@ public void testAsMapValues_iteratorRemove() {\n     iterator.next();\n     iterator.remove();\n \n-    assertEquals(0, cache.size());\n+    assertThat(cache.size()).isEqualTo(0);\n   }\n }\ndiff --git a/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java b/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java\nindex 670275b08252..7948e82f89f3 100644\n--- a/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java\n+++ b/guava-tests/test/com/google/common/cache/CacheBuilderSpecTest.java\n@@ -18,6 +18,8 @@\n \n import static com.google.common.cache.CacheBuilderSpec.parse;\n import static com.google.common.cache.TestingWeighers.constantWeigher;\n+import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.util.concurrent.TimeUnit.DAYS;\n import static java.util.concurrent.TimeUnit.HOURS;\n import static java.util.concurrent.TimeUnit.MINUTES;\n@@ -40,27 +42,27 @@\n public class CacheBuilderSpecTest extends TestCase {\n   public void testParse_empty() {\n     CacheBuilderSpec spec = parse(\"\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder(), CacheBuilder.from(spec));\n   }\n \n   public void testParse_initialCapacity() {\n     CacheBuilderSpec spec = parse(\"initialCapacity=10\");\n-    assertEquals(10, spec.initialCapacity.intValue());\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isEqualTo(10);\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().initialCapacity(10), CacheBuilder.from(spec));\n   }\n@@ -72,13 +74,13 @@ public void testParse_initialCapacityRepeated() {\n \n   public void testParse_maximumSize() {\n     CacheBuilderSpec spec = parse(\"maximumSize=9000\");\n-    assertNull(spec.initialCapacity);\n-    assertEquals(9000, spec.maximumSize.longValue());\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isEqualTo(9000L);\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().maximumSize(9000), CacheBuilder.from(spec));\n   }\n@@ -89,13 +91,13 @@ public void testParse_maximumSizeRepeated() {\n \n   public void testParse_maximumWeight() {\n     CacheBuilderSpec spec = parse(\"maximumWeight=9000\");\n-    assertNull(spec.initialCapacity);\n-    assertEquals(9000, spec.maximumWeight.longValue());\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumWeight).isEqualTo(9000L);\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().maximumWeight(9000), CacheBuilder.from(spec));\n   }\n@@ -110,14 +112,14 @@ public void testParse_maximumSizeAndMaximumWeight() {\n \n   public void testParse_concurrencyLevel() {\n     CacheBuilderSpec spec = parse(\"concurrencyLevel=32\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertEquals(32, spec.concurrencyLevel.intValue());\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isEqualTo(32);\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().concurrencyLevel(32), CacheBuilder.from(spec));\n   }\n@@ -129,14 +131,14 @@ public void testParse_concurrencyLevelRepeated() {\n \n   public void testParse_weakKeys() {\n     CacheBuilderSpec spec = parse(\"weakKeys\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertEquals(Strength.WEAK, spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().weakKeys(), CacheBuilder.from(spec));\n   }\n \n@@ -150,14 +152,14 @@ public void testParse_repeatedKeyStrength() {\n \n   public void testParse_softValues() {\n     CacheBuilderSpec spec = parse(\"softValues\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertEquals(Strength.SOFT, spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isEqualTo(Strength.SOFT);\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().softValues(), CacheBuilder.from(spec));\n   }\n \n@@ -167,14 +169,14 @@ public void testParse_softValuesCannotHaveValue() {\n \n   public void testParse_weakValues() {\n     CacheBuilderSpec spec = parse(\"weakValues\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertEquals(Strength.WEAK, spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().weakValues(), CacheBuilder.from(spec));\n   }\n \n@@ -194,39 +196,39 @@ public void testParse_repeatedValueStrength() {\n \n   public void testParse_writeExpirationDays() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=10d\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertEquals(DAYS, spec.writeExpirationTimeUnit);\n-    assertEquals(10L, spec.writeExpirationDuration);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(DAYS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(10L, DAYS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_writeExpirationHours() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=150h\");\n-    assertEquals(HOURS, spec.writeExpirationTimeUnit);\n-    assertEquals(150L, spec.writeExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(HOURS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(150L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(150L, HOURS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_writeExpirationMinutes() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=10m\");\n-    assertEquals(MINUTES, spec.writeExpirationTimeUnit);\n-    assertEquals(10L, spec.writeExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(10L, MINUTES), CacheBuilder.from(spec));\n   }\n \n   public void testParse_writeExpirationSeconds() {\n     CacheBuilderSpec spec = parse(\"expireAfterWrite=10s\");\n-    assertEquals(SECONDS, spec.writeExpirationTimeUnit);\n-    assertEquals(10L, spec.writeExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterWrite(10L, SECONDS), CacheBuilder.from(spec));\n   }\n@@ -238,39 +240,39 @@ public void testParse_writeExpirationRepeated() {\n \n   public void testParse_accessExpirationDays() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10d\");\n-    assertNull(spec.initialCapacity);\n-    assertNull(spec.maximumSize);\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertNull(spec.keyStrength);\n-    assertNull(spec.valueStrength);\n-    assertNull(spec.writeExpirationTimeUnit);\n-    assertEquals(DAYS, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.initialCapacity).isNull();\n+    assertThat(spec.maximumSize).isNull();\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isNull();\n+    assertThat(spec.valueStrength).isNull();\n+    assertThat(spec.writeExpirationTimeUnit).isNull();\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(DAYS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, DAYS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_accessExpirationHours() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=150h\");\n-    assertEquals(HOURS, spec.accessExpirationTimeUnit);\n-    assertEquals(150L, spec.accessExpirationDuration);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(HOURS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(150L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(150L, HOURS), CacheBuilder.from(spec));\n   }\n \n   public void testParse_accessExpirationMinutes() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10m\");\n-    assertEquals(MINUTES, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, MINUTES), CacheBuilder.from(spec));\n   }\n \n   public void testParse_accessExpirationSeconds() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10s\");\n-    assertEquals(SECONDS, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, SECONDS), CacheBuilder.from(spec));\n   }\n@@ -282,7 +284,7 @@ public void testParse_accessExpirationRepeated() {\n \n   public void testParse_recordStats() {\n     CacheBuilderSpec spec = parse(\"recordStats\");\n-    assertTrue(spec.recordStats);\n+    assertThat(spec.recordStats).isTrue();\n     assertCacheBuilderEquivalence(CacheBuilder.newBuilder().recordStats(), CacheBuilder.from(spec));\n   }\n \n@@ -296,10 +298,10 @@ public void testParse_recordStatsRepeated() {\n \n   public void testParse_accessExpirationAndWriteExpiration() {\n     CacheBuilderSpec spec = parse(\"expireAfterAccess=10s,expireAfterWrite=9m\");\n-    assertEquals(MINUTES, spec.writeExpirationTimeUnit);\n-    assertEquals(9L, spec.writeExpirationDuration);\n-    assertEquals(SECONDS, spec.accessExpirationTimeUnit);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(9L);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     assertCacheBuilderEquivalence(\n         CacheBuilder.newBuilder().expireAfterAccess(10L, SECONDS).expireAfterWrite(9L, MINUTES),\n         CacheBuilder.from(spec));\n@@ -310,16 +312,16 @@ public void testParse_multipleKeys() {\n         parse(\n             \"initialCapacity=10,maximumSize=20,concurrencyLevel=30,\"\n                 + \"weakKeys,weakValues,expireAfterAccess=10m,expireAfterWrite=1h\");\n-    assertEquals(10, spec.initialCapacity.intValue());\n-    assertEquals(20, spec.maximumSize.intValue());\n-    assertNull(spec.maximumWeight);\n-    assertEquals(30, spec.concurrencyLevel.intValue());\n-    assertEquals(Strength.WEAK, spec.keyStrength);\n-    assertEquals(Strength.WEAK, spec.valueStrength);\n-    assertEquals(HOURS, spec.writeExpirationTimeUnit);\n-    assertEquals(MINUTES, spec.accessExpirationTimeUnit);\n-    assertEquals(1L, spec.writeExpirationDuration);\n-    assertEquals(10L, spec.accessExpirationDuration);\n+    assertThat(spec.initialCapacity).isEqualTo(10);\n+    assertThat(spec.maximumSize).isEqualTo(20);\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isEqualTo(30);\n+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.valueStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(HOURS);\n+    assertThat(spec.accessExpirationTimeUnit).isEqualTo(MINUTES);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(1L);\n+    assertThat(spec.accessExpirationDuration).isEqualTo(10L);\n     CacheBuilder<?, ?> expected =\n         CacheBuilder.newBuilder()\n             .initialCapacity(10)\n@@ -337,15 +339,15 @@ public void testParse_whitespaceAllowed() {\n         parse(\n             \" initialCapacity=10,\\nmaximumSize=20,\\t\\r\"\n                 + \"weakKeys \\t ,softValues \\n , \\r  expireAfterWrite \\t =  15s\\n\\n\");\n-    assertEquals(10, spec.initialCapacity.intValue());\n-    assertEquals(20, spec.maximumSize.intValue());\n-    assertNull(spec.maximumWeight);\n-    assertNull(spec.concurrencyLevel);\n-    assertEquals(Strength.WEAK, spec.keyStrength);\n-    assertEquals(Strength.SOFT, spec.valueStrength);\n-    assertEquals(SECONDS, spec.writeExpirationTimeUnit);\n-    assertEquals(15L, spec.writeExpirationDuration);\n-    assertNull(spec.accessExpirationTimeUnit);\n+    assertThat(spec.initialCapacity).isEqualTo(10);\n+    assertThat(spec.maximumSize).isEqualTo(20);\n+    assertThat(spec.maximumWeight).isNull();\n+    assertThat(spec.concurrencyLevel).isNull();\n+    assertThat(spec.keyStrength).isEqualTo(Strength.WEAK);\n+    assertThat(spec.valueStrength).isEqualTo(Strength.SOFT);\n+    assertThat(spec.writeExpirationTimeUnit).isEqualTo(SECONDS);\n+    assertThat(spec.writeExpirationDuration).isEqualTo(15L);\n+    assertThat(spec.accessExpirationTimeUnit).isNull();\n     CacheBuilder<?, ?> expected =\n         CacheBuilder.newBuilder()\n             .initialCapacity(10)\n@@ -424,9 +426,9 @@ public void testDisableCaching() {\n     Object value = new Object();\n     LoadingCache<Object, Object> cache =\n         builder.build(CacheLoader.from(Suppliers.ofInstance(value)));\n-    assertSame(value, cache.getUnchecked(key));\n-    assertEquals(0, cache.size());\n-    assertFalse(cache.asMap().containsKey(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);\n+    assertThat(cache.size()).isEqualTo(0);\n+    assertThat(cache.asMap().containsKey(key)).isFalse();\n   }\n \n   public void testCacheBuilderFrom_string() {\n@@ -445,22 +447,41 @@ public void testCacheBuilderFrom_string() {\n     assertCacheBuilderEquivalence(expected, fromString);\n   }\n \n-  private static void assertCacheBuilderEquivalence(CacheBuilder<?, ?> a, CacheBuilder<?, ?> b) {\n-    assertEquals(\"concurrencyLevel\", a.concurrencyLevel, b.concurrencyLevel);\n-    assertEquals(\"expireAfterAccessNanos\", a.expireAfterAccessNanos, b.expireAfterAccessNanos);\n-    assertEquals(\"expireAfterWriteNanos\", a.expireAfterWriteNanos, b.expireAfterWriteNanos);\n-    assertEquals(\"initialCapacity\", a.initialCapacity, b.initialCapacity);\n-    assertEquals(\"maximumSize\", a.maximumSize, b.maximumSize);\n-    assertEquals(\"maximumWeight\", a.maximumWeight, b.maximumWeight);\n-    assertEquals(\"refreshNanos\", a.refreshNanos, b.refreshNanos);\n-    assertEquals(\"keyEquivalence\", a.keyEquivalence, b.keyEquivalence);\n-    assertEquals(\"keyStrength\", a.keyStrength, b.keyStrength);\n-    assertEquals(\"removalListener\", a.removalListener, b.removalListener);\n-    assertEquals(\"weigher\", a.weigher, b.weigher);\n-    assertEquals(\"valueEquivalence\", a.valueEquivalence, b.valueEquivalence);\n-    assertEquals(\"valueStrength\", a.valueStrength, b.valueStrength);\n-    assertEquals(\"statsCounterSupplier\", a.statsCounterSupplier, b.statsCounterSupplier);\n-    assertEquals(\"ticker\", a.ticker, b.ticker);\n-    assertEquals(\"recordStats\", a.isRecordingStats(), b.isRecordingStats());\n+  private static void assertCacheBuilderEquivalence(\n+      CacheBuilder<?, ?> expected, CacheBuilder<?, ?> actual) {\n+    assertWithMessage(\"concurrencyLevel\")\n+        .that(actual.concurrencyLevel)\n+        .isEqualTo(expected.concurrencyLevel);\n+    assertWithMessage(\"expireAfterAccessNanos\")\n+        .that(actual.expireAfterAccessNanos)\n+        .isEqualTo(expected.expireAfterAccessNanos);\n+    assertWithMessage(\"expireAfterWriteNanos\")\n+        .that(actual.expireAfterWriteNanos)\n+        .isEqualTo(expected.expireAfterWriteNanos);\n+    assertWithMessage(\"initialCapacity\")\n+        .that(actual.initialCapacity)\n+        .isEqualTo(expected.initialCapacity);\n+    assertWithMessage(\"maximumSize\").that(actual.maximumSize).isEqualTo(expected.maximumSize);\n+    assertWithMessage(\"maximumWeight\").that(actual.maximumWeight).isEqualTo(expected.maximumWeight);\n+    assertWithMessage(\"refreshNanos\").that(actual.refreshNanos).isEqualTo(expected.refreshNanos);\n+    assertWithMessage(\"keyEquivalence\")\n+        .that(actual.keyEquivalence)\n+        .isEqualTo(expected.keyEquivalence);\n+    assertWithMessage(\"keyStrength\").that(actual.keyStrength).isEqualTo(expected.keyStrength);\n+    assertWithMessage(\"removalListener\")\n+        .that(actual.removalListener)\n+        .isEqualTo(expected.removalListener);\n+    assertWithMessage(\"weigher\").that(actual.weigher).isEqualTo(expected.weigher);\n+    assertWithMessage(\"valueEquivalence\")\n+        .that(actual.valueEquivalence)\n+        .isEqualTo(expected.valueEquivalence);\n+    assertWithMessage(\"valueStrength\").that(actual.valueStrength).isEqualTo(expected.valueStrength);\n+    assertWithMessage(\"statsCounterSupplier\")\n+        .that(actual.statsCounterSupplier)\n+        .isEqualTo(expected.statsCounterSupplier);\n+    assertWithMessage(\"ticker\").that(actual.ticker).isEqualTo(expected.ticker);\n+    assertWithMessage(\"recordStats\")\n+        .that(actual.isRecordingStats())\n+        .isEqualTo(expected.isRecordingStats());\n   }\n }\ndiff --git a/guava-tests/test/com/google/common/cache/CacheBuilderTest.java b/guava-tests/test/com/google/common/cache/CacheBuilderTest.java\nindex 63653d58a993..0466bb017b3b 100644\n--- a/guava-tests/test/com/google/common/cache/CacheBuilderTest.java\n+++ b/guava-tests/test/com/google/common/cache/CacheBuilderTest.java\n@@ -24,6 +24,7 @@\n import static com.google.common.cache.TestingRemovalListeners.queuingRemovalListener;\n import static com.google.common.cache.TestingWeighers.constantWeigher;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.util.concurrent.Executors.newFixedThreadPool;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static java.util.concurrent.TimeUnit.NANOSECONDS;\n@@ -63,8 +64,8 @@ public void testNewBuilder() {\n     LoadingCache<String, Integer> cache =\n         CacheBuilder.newBuilder().removalListener(countingRemovalListener()).build(loader);\n \n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(\"one\"));\n-    assertEquals(1, cache.size());\n+    assertThat(cache.getUnchecked(\"one\")).isEqualTo(1);\n+    assertThat(cache.size()).isEqualTo(1);\n   }\n \n   public void testInitialCapacity_negative() {\n@@ -83,10 +84,10 @@ public void testInitialCapacity_small() {\n     LocalCache<?, ?> map = CacheTesting.toLocalCache(cache);\n \n     assertThat(map.segments).hasLength(4);\n-    assertEquals(2, map.segments[0].table.length());\n-    assertEquals(2, map.segments[1].table.length());\n-    assertEquals(2, map.segments[2].table.length());\n-    assertEquals(2, map.segments[3].table.length());\n+    assertThat(map.segments[0].table.length()).isEqualTo(2);\n+    assertThat(map.segments[1].table.length()).isEqualTo(2);\n+    assertThat(map.segments[2].table.length()).isEqualTo(2);\n+    assertThat(map.segments[3].table.length()).isEqualTo(2);\n   }\n \n   @GwtIncompatible // CacheTesting\n@@ -96,10 +97,10 @@ public void testInitialCapacity_smallest() {\n \n     assertThat(map.segments).hasLength(4);\n     // 1 is as low as it goes, not 0. it feels dirty to know this/test this.\n-    assertEquals(1, map.segments[0].table.length());\n-    assertEquals(1, map.segments[1].table.length());\n-    assertEquals(1, map.segments[2].table.length());\n-    assertEquals(1, map.segments[3].table.length());\n+    assertThat(map.segments[0].table.length()).isEqualTo(1);\n+    assertThat(map.segments[1].table.length()).isEqualTo(1);\n+    assertThat(map.segments[2].table.length()).isEqualTo(1);\n+    assertThat(map.segments[3].table.length()).isEqualTo(1);\n   }\n \n   public void testInitialCapacity_large() {\n@@ -327,7 +328,7 @@ public void testRemovalListener_setTwice() {\n   }\n \n   public void testValuesIsNotASet() {\n-    assertFalse(CacheBuilder.newBuilder().build().asMap().values() instanceof Set);\n+    assertThat(CacheBuilder.newBuilder().build().asMap().values() instanceof Set).isFalse();\n   }\n \n   @GwtIncompatible // CacheTesting\n@@ -335,11 +336,11 @@ public void testNullCache() {\n     CountingRemovalListener<Object, Object> listener = countingRemovalListener();\n     LoadingCache<Object, Object> nullCache =\n         CacheBuilder.newBuilder().maximumSize(0).removalListener(listener).build(identityLoader());\n-    assertEquals(0, nullCache.size());\n+    assertThat(nullCache.size()).isEqualTo(0);\n     Object key = new Object();\n-    assertSame(key, nullCache.getUnchecked(key));\n-    assertEquals(1, listener.getCount());\n-    assertEquals(0, nullCache.size());\n+    assertThat(nullCache.getUnchecked(key)).isSameInstanceAs(key);\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(nullCache.size()).isEqualTo(0);\n     CacheTesting.checkEmpty(nullCache.asMap());\n   }\n \n@@ -396,12 +397,12 @@ public void run() {\n     // At this point, the listener should be holding the seed value (a -> a), and the map should\n     // contain the computed value (b -> b), since the clear() happened before the computation\n     // completed.\n-    assertEquals(1, listener.size());\n+    assertThat(listener).hasSize(1);\n     RemovalNotification<String, String> notification = listener.remove();\n-    assertEquals(\"a\", notification.getKey());\n-    assertEquals(\"a\", notification.getValue());\n-    assertEquals(1, cache.size());\n-    assertEquals(\"b\", cache.getUnchecked(\"b\"));\n+    assertThat(notification.getKey()).isEqualTo(\"a\");\n+    assertThat(notification.getValue()).isEqualTo(\"a\");\n+    assertThat(cache.size()).isEqualTo(1);\n+    assertThat(cache.getUnchecked(\"b\")).isEqualTo(\"b\");\n   }\n \n   // \"Basher tests\", where we throw a bunch of stuff at a LoadingCache and check basic invariants.\n@@ -476,22 +477,22 @@ public void run() {\n     Map<String, String> removalNotifications = new HashMap<>();\n     for (RemovalNotification<String, String> notification : listener) {\n       removalNotifications.put(notification.getKey(), notification.getValue());\n-      assertEquals(\n-          \"Unexpected key/value pair passed to removalListener\",\n-          notification.getKey(),\n-          notification.getValue());\n+      assertWithMessage(\"Unexpected key/value pair passed to removalListener\")\n+          .that(notification.getValue())\n+          .isEqualTo(notification.getKey());\n     }\n \n     // All of the seed values should have been visible, so we should have gotten removal\n     // notifications for all of them.\n     for (int i = 0; i < nSeededEntries; i++) {\n-      assertEquals(\"b\" + i, removalNotifications.get(\"b\" + i));\n+      assertThat(removalNotifications.get(\"b\" + i)).isEqualTo(\"b\" + i);\n     }\n \n     // Each of the values added to the map should either still be there, or have seen a removal\n     // notification.\n-    assertEquals(expectedKeys, Sets.union(cache.asMap().keySet(), removalNotifications.keySet()));\n-    assertTrue(Sets.intersection(cache.asMap().keySet(), removalNotifications.keySet()).isEmpty());\n+    assertThat(Sets.union(cache.asMap().keySet(), removalNotifications.keySet()))\n+        .isEqualTo(expectedKeys);\n+    assertThat(cache.asMap().keySet()).containsNoneIn(removalNotifications.keySet());\n     threadPool.shutdown();\n     threadPool.awaitTermination(300, SECONDS);\n   }\n@@ -570,15 +571,17 @@ public void run() {\n \n     // Verify that each received removal notification was valid\n     for (RemovalNotification<String, String> notification : removalListener) {\n-      assertEquals(\"Invalid removal notification\", notification.getKey(), notification.getValue());\n+      assertWithMessage(\"Invalid removal notification\")\n+          .that(notification.getValue())\n+          .isEqualTo(notification.getKey());\n     }\n \n     CacheStats stats = cache.stats();\n-    assertEquals(removalListener.size(), stats.evictionCount());\n-    assertEquals(computeCount.get(), stats.loadSuccessCount());\n-    assertEquals(exceptionCount.get() + computeNullCount.get(), stats.loadExceptionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(removalListener.size());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(computeCount.get());\n+    assertThat(stats.loadExceptionCount()).isEqualTo(exceptionCount.get() + computeNullCount.get());\n     // each computed value is still in the cache, or was passed to the removal listener\n-    assertEquals(computeCount.get(), cache.size() + removalListener.size());\n+    assertThat(cache.size() + removalListener.size()).isEqualTo(computeCount.get());\n   }\n \n   @GwtIncompatible // NullPointerTester\n@@ -593,7 +596,7 @@ public void testSizingDefaults() {\n     LoadingCache<?, ?> cache = CacheBuilder.newBuilder().build(identityLoader());\n     LocalCache<?, ?> map = CacheTesting.toLocalCache(cache);\n     assertThat(map.segments).hasLength(4); // concurrency level\n-    assertEquals(4, map.segments[0].table.length()); // capacity / conc level\n+    assertThat(map.segments[0].table.length()).isEqualTo(4); // capacity / conc level\n   }\n \n   @GwtIncompatible // CountDownLatch\ndiff --git a/guava-tests/test/com/google/common/cache/CacheEvictionTest.java b/guava-tests/test/com/google/common/cache/CacheEvictionTest.java\nindex a6d97f881001..8f83959eb8f6 100644\n--- a/guava-tests/test/com/google/common/cache/CacheEvictionTest.java\n+++ b/guava-tests/test/com/google/common/cache/CacheEvictionTest.java\n@@ -45,7 +45,7 @@ public void testEviction_setMaxSegmentSize() {\n     IdentityLoader<Object> loader = identityLoader();\n     for (int i = 1; i < 1000; i++) {\n       LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().maximumSize(i).build(loader);\n-      assertEquals(i, CacheTesting.getTotalSegmentSize(cache));\n+      assertThat(CacheTesting.getTotalSegmentSize(cache)).isEqualTo(i);\n     }\n   }\n \n@@ -54,7 +54,7 @@ public void testEviction_setMaxSegmentWeight() {\n     for (int i = 1; i < 1000; i++) {\n       LoadingCache<Object, Object> cache =\n           CacheBuilder.newBuilder().maximumWeight(i).weigher(constantWeigher(1)).build(loader);\n-      assertEquals(i, CacheTesting.getTotalSegmentSize(cache));\n+      assertThat(CacheTesting.getTotalSegmentSize(cache)).isEqualTo(i);\n     }\n   }\n \n@@ -64,10 +64,10 @@ public void testEviction_maxSizeOneSegment() {\n         CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(MAX_SIZE).build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertEquals(min(i + 1, MAX_SIZE), cache.size());\n+      assertThat(cache.size()).isEqualTo(min(i + 1, MAX_SIZE));\n     }\n \n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -81,10 +81,10 @@ public void testEviction_maxWeightOneSegment() {\n             .build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertEquals(min(i + 1, MAX_SIZE), cache.size());\n+      assertThat(cache.size()).isEqualTo(min(i + 1, MAX_SIZE));\n     }\n \n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -98,13 +98,13 @@ public void testEviction_maxSize() {\n             .build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertTrue(cache.size() <= MAX_SIZE);\n+      assertThat(cache.size() <= MAX_SIZE).isTrue();\n     }\n \n-    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));\n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(CacheTesting.accessQueueSize(cache)).isEqualTo(MAX_SIZE);\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.processPendingNotifications(cache);\n-    assertEquals(MAX_SIZE, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -119,13 +119,13 @@ public void testEviction_maxWeight() {\n             .build(loader);\n     for (int i = 0; i < 2 * MAX_SIZE; i++) {\n       cache.getUnchecked(i);\n-      assertTrue(cache.size() <= MAX_SIZE);\n+      assertThat(cache.size()).isAtMost(MAX_SIZE);\n     }\n \n-    assertEquals(MAX_SIZE, CacheTesting.accessQueueSize(cache));\n-    assertEquals(MAX_SIZE, cache.size());\n+    assertThat(CacheTesting.accessQueueSize(cache)).isEqualTo(MAX_SIZE);\n+    assertThat(cache.size()).isEqualTo(MAX_SIZE);\n     CacheTesting.processPendingNotifications(cache);\n-    assertEquals(MAX_SIZE, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(MAX_SIZE);\n     CacheTesting.checkValidState(cache);\n   }\n \n@@ -255,7 +255,7 @@ public void testEviction_overflow() {\n     cache.getUnchecked(objectWithHash(0));\n     cache.getUnchecked(objectWithHash(0));\n     CacheTesting.processPendingNotifications(cache);\n-    assertEquals(1, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(1);\n   }\n \n   public void testUpdateRecency_onGet() {\ndiff --git a/guava-tests/test/com/google/common/cache/CacheExpirationTest.java b/guava-tests/test/com/google/common/cache/CacheExpirationTest.java\nindex 8122c68514e8..75095b28e0b6 100644\n--- a/guava-tests/test/com/google/common/cache/CacheExpirationTest.java\n+++ b/guava-tests/test/com/google/common/cache/CacheExpirationTest.java\n@@ -17,6 +17,7 @@\n import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.util.Arrays.asList;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static java.util.concurrent.TimeUnit.MINUTES;\n@@ -81,23 +82,29 @@ private void checkExpiration(\n       CountingRemovalListener<String, Integer> removalListener) {\n \n     for (int i = 0; i < 10; i++) {\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n     }\n \n     for (int i = 0; i < 10; i++) {\n       loader.reset();\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n-      assertFalse(\"Creator should not have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n+      assertWithMessage(\"Creator should not have been called @#%s\", i)\n+          .that(loader.wasCalled())\n+          .isFalse();\n     }\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n \n-    assertEquals(\"Map must be empty by now\", 0, cache.size());\n-    assertEquals(\"Eviction notifications must be received\", 10, removalListener.getCount());\n+    assertWithMessage(\"Map must be empty by now\").that(cache.size()).isEqualTo(0);\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(10);\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n     // ensure that no new notifications are sent\n-    assertEquals(\"Eviction notifications must be received\", 10, removalListener.getCount());\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(10);\n   }\n \n   public void testExpiringGet_expireAfterWrite() {\n@@ -133,13 +140,15 @@ private void runExpirationTest(\n       CountingRemovalListener<String, Integer> removalListener) {\n \n     for (int i = 0; i < 10; i++) {\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n     }\n \n     for (int i = 0; i < 10; i++) {\n       loader.reset();\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n-      assertFalse(\"Loader should NOT have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n+      assertWithMessage(\"Loader should NOT have been called @#%s\", i)\n+          .that(loader.wasCalled())\n+          .isFalse();\n     }\n \n     // wait for entries to expire, but don't call expireEntries\n@@ -149,31 +158,35 @@ private void runExpirationTest(\n     cache.getUnchecked(KEY_PREFIX + 11);\n \n     // collections views shouldn't expose expired entries\n-    assertEquals(1, Iterators.size(cache.asMap().entrySet().iterator()));\n-    assertEquals(1, Iterators.size(cache.asMap().keySet().iterator()));\n-    assertEquals(1, Iterators.size(cache.asMap().values().iterator()));\n+    assertThat(Iterators.size(cache.asMap().entrySet().iterator())).isEqualTo(1);\n+    assertThat(Iterators.size(cache.asMap().keySet().iterator())).isEqualTo(1);\n+    assertThat(Iterators.size(cache.asMap().values().iterator())).isEqualTo(1);\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n \n     for (int i = 0; i < 11; i++) {\n-      assertFalse(cache.asMap().containsKey(KEY_PREFIX + i));\n+      assertThat(cache.asMap().containsKey(KEY_PREFIX + i)).isFalse();\n     }\n-    assertEquals(11, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(11);\n \n     for (int i = 0; i < 10; i++) {\n-      assertFalse(cache.asMap().containsKey(KEY_PREFIX + i));\n+      assertThat(cache.asMap().containsKey(KEY_PREFIX + i)).isFalse();\n       loader.reset();\n-      assertEquals(Integer.valueOf(VALUE_PREFIX + i), cache.getUnchecked(KEY_PREFIX + i));\n-      assertTrue(\"Creator should have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(KEY_PREFIX + i)).isEqualTo(VALUE_PREFIX + i);\n+      assertWithMessage(\"Loader should have been called @#%s\", i).that(loader.wasCalled()).isTrue();\n     }\n \n     // expire new values we just created\n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n-    assertEquals(\"Eviction notifications must be received\", 21, removalListener.getCount());\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(21);\n \n     CacheTesting.expireEntries((LoadingCache<?, ?>) cache, EXPIRING_TIME, ticker);\n     // ensure that no new notifications are sent\n-    assertEquals(\"Eviction notifications must be received\", 21, removalListener.getCount());\n+    assertWithMessage(\"Eviction notifications must be received\")\n+        .that(removalListener.getCount())\n+        .isEqualTo(21);\n   }\n \n   public void testRemovalListener_expireAfterWrite() {\n@@ -215,9 +228,9 @@ public AtomicInteger load(Integer key) {\n       ticker.advance(1, MILLISECONDS);\n     }\n \n-    assertEquals(evictionCount.get() + 1, applyCount.get());\n+    assertThat(applyCount.get()).isEqualTo(evictionCount.get() + 1);\n     int remaining = cache.getUnchecked(10).get();\n-    assertEquals(100, totalSum.get() + remaining);\n+    assertThat(totalSum.get() + remaining).isEqualTo(100);\n   }\n \n   public void testRemovalScheduler_expireAfterWrite() {\n@@ -435,46 +448,50 @@ private void runRemovalScheduler(\n       FakeTicker ticker,\n       String keyPrefix,\n       long ttl) {\n+    loader.setKeyPrefix(keyPrefix);\n \n     int shift1 = 10 + VALUE_PREFIX;\n     loader.setValuePrefix(shift1);\n     // fill with initial data\n     for (int i = 0; i < 10; i++) {\n-      assertEquals(Integer.valueOf(i + shift1), cache.getUnchecked(keyPrefix + i));\n+      assertThat(cache.getUnchecked(keyPrefix + i)).isEqualTo(i + shift1);\n     }\n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n \n     // wait, so that entries have just 10 ms to live\n     ticker.advance(ttl * 2 / 3, MILLISECONDS);\n \n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n \n     int shift2 = shift1 + 10;\n     loader.setValuePrefix(shift2);\n     // fill with new data - has to live for 20 ms more\n     for (int i = 0; i < 10; i++) {\n       cache.invalidate(keyPrefix + i);\n-      assertEquals(\n-          \"key: \" + keyPrefix + i, Integer.valueOf(i + shift2), cache.getUnchecked(keyPrefix + i));\n+      assertWithMessage(\"key: %s%s\", keyPrefix, i)\n+          .that(cache.getUnchecked(keyPrefix + i))\n+          .isEqualTo(i + shift2);\n     }\n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(10, removalListener.getCount()); // these are the invalidated ones\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(10); // these are the invalidated ones\n \n     // old timeouts must expire after this wait\n     ticker.advance(ttl * 2 / 3, MILLISECONDS);\n \n-    assertEquals(10, CacheTesting.expirationQueueSize(cache));\n-    assertEquals(10, removalListener.getCount());\n+    assertThat(CacheTesting.expirationQueueSize(cache)).isEqualTo(10);\n+    assertThat(removalListener.getCount()).isEqualTo(10);\n \n     // check that new values are still there - they still have 10 ms to live\n     for (int i = 0; i < 10; i++) {\n       loader.reset();\n-      assertEquals(Integer.valueOf(i + shift2), cache.getUnchecked(keyPrefix + i));\n-      assertFalse(\"Creator should NOT have been called @#\" + i, loader.wasCalled());\n+      assertThat(cache.getUnchecked(keyPrefix + i)).isEqualTo(i + shift2);\n+      assertWithMessage(\"Creator should NOT have been called @#%s\", i)\n+          .that(loader.wasCalled())\n+          .isFalse();\n     }\n-    assertEquals(10, removalListener.getCount());\n+    assertThat(removalListener.getCount()).isEqualTo(10);\n   }\n \n   private static void getAll(LoadingCache<Integer, Integer> cache, List<Integer> keys) {\ndiff --git a/guava-tests/test/com/google/common/cache/CacheLoaderTest.java b/guava-tests/test/com/google/common/cache/CacheLoaderTest.java\nindex 70918db35fe7..8125ff117a6a 100644\n--- a/guava-tests/test/com/google/common/cache/CacheLoaderTest.java\n+++ b/guava-tests/test/com/google/common/cache/CacheLoaderTest.java\n@@ -16,6 +16,7 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static com.google.common.util.concurrent.Futures.immediateFuture;\n \n import com.google.common.collect.ImmutableList;\n@@ -77,17 +78,17 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {\n           }\n         };\n \n-    assertEquals(0, loadCount.get());\n-    assertEquals(0, reloadCount.get());\n-    assertEquals(0, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(0);\n+    assertThat(reloadCount.get()).isEqualTo(0);\n+    assertThat(loadAllCount.get()).isEqualTo(0);\n \n     Object unused1 = baseLoader.load(new Object());\n     @SuppressWarnings(\"unused\") // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n     Future<?> possiblyIgnoredError = baseLoader.reload(new Object(), new Object());\n     Map<Object, Object> unused2 = baseLoader.loadAll(ImmutableList.of(new Object()));\n-    assertEquals(1, loadCount.get());\n-    assertEquals(1, reloadCount.get());\n-    assertEquals(1, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(1);\n+    assertThat(reloadCount.get()).isEqualTo(1);\n+    assertThat(loadAllCount.get()).isEqualTo(1);\n \n     QueuingExecutor executor = new QueuingExecutor();\n     CacheLoader<Object, Object> asyncReloader = CacheLoader.asyncReloading(baseLoader, executor);\n@@ -96,13 +97,13 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {\n     @SuppressWarnings(\"unused\") // https://errorprone.info/bugpattern/FutureReturnValueIgnored\n     Future<?> possiblyIgnoredError1 = asyncReloader.reload(new Object(), new Object());\n     Map<Object, Object> unused4 = asyncReloader.loadAll(ImmutableList.of(new Object()));\n-    assertEquals(2, loadCount.get());\n-    assertEquals(1, reloadCount.get());\n-    assertEquals(2, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(2);\n+    assertThat(reloadCount.get()).isEqualTo(1);\n+    assertThat(loadAllCount.get()).isEqualTo(2);\n \n     executor.runNext();\n-    assertEquals(2, loadCount.get());\n-    assertEquals(2, reloadCount.get());\n-    assertEquals(2, loadAllCount.get());\n+    assertThat(loadCount.get()).isEqualTo(2);\n+    assertThat(reloadCount.get()).isEqualTo(2);\n+    assertThat(loadAllCount.get()).isEqualTo(2);\n   }\n }\ndiff --git a/guava-tests/test/com/google/common/cache/CacheLoadingTest.java b/guava-tests/test/com/google/common/cache/CacheLoadingTest.java\nindex a2e3883d95b9..7dc674ae919c 100644\n--- a/guava-tests/test/com/google/common/cache/CacheLoadingTest.java\n+++ b/guava-tests/test/com/google/common/cache/CacheLoadingTest.java\n@@ -21,6 +21,7 @@\n import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n import static com.google.common.cache.TestingRemovalListeners.countingRemovalListener;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static com.google.common.util.concurrent.Futures.immediateFailedFuture;\n import static com.google.common.util.concurrent.Futures.immediateFuture;\n import static java.util.Arrays.asList;\n@@ -33,7 +34,6 @@\n import com.google.common.cache.TestingCacheLoaders.IdentityLoader;\n import com.google.common.cache.TestingRemovalListeners.CountingRemovalListener;\n import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Lists;\n import com.google.common.testing.FakeTicker;\n import com.google.common.testing.TestLogHandler;\n@@ -83,7 +83,7 @@ public void tearDown() throws Exception {\n \n   private Throwable popLoggedThrowable() {\n     List<LogRecord> logRecords = logHandler.getStoredLogRecords();\n-    assertEquals(1, logRecords.size());\n+    assertThat(logRecords).hasSize(1);\n     LogRecord logRecord = logRecords.get(0);\n     logHandler.clear();\n     return logRecord.getThrown();\n@@ -105,59 +105,59 @@ public void testLoad() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(identityLoader());\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Object key = new Object();\n-    assertSame(key, cache.get(key));\n+    assertThat(cache.get(key)).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     key = new Object();\n-    assertSame(key, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     key = new Object();\n     cache.refresh(key);\n     checkNothingLogged();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(key, cache.get(key));\n+    assertThat(cache.get(key)).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     Object value = new Object();\n     // callable is not called\n-    assertSame(key, cache.get(key, throwing(new Exception())));\n+    assertThat(cache.get(key, throwing(new Exception()))).isSameInstanceAs(key);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     key = new Object();\n-    assertSame(value, cache.get(key, Callables.returning(value)));\n+    assertThat(cache.get(key, Callables.returning(value))).isSameInstanceAs(value);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(4, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(4);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n   }\n \n   public void testReload() throws ExecutionException {\n@@ -179,32 +179,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkNothingLogged();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(two, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefresh() {\n@@ -232,41 +232,41 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testRefresh_getIfPresent() {\n@@ -294,41 +294,41 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getIfPresent(key));\n+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getIfPresent(key));\n+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(two, cache.getIfPresent(key));\n+    assertThat(cache.getIfPresent(key)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoad_default() throws ExecutionException {\n@@ -337,45 +337,45 @@ public void testBulkLoad_default() throws ExecutionException {\n             .recordStats()\n             .build(TestingCacheLoaders.<Integer>identityLoader());\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.<Integer>of()));\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(cache.getAll(ImmutableList.of())).isEmpty();\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));\n+    assertThat(cache.getAll(asList(1))).containsExactly(1, 1);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));\n+    assertThat(cache.getAll(asList(1, 2, 3, 4))).containsExactly(1, 1, 2, 2, 3, 3, 4, 4);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(4, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(4);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n-    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));\n+    assertThat(cache.getAll(asList(2, 3))).containsExactly(2, 2, 3, 3);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(4, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(4);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n \n     // duplicate keys are ignored, and don't impact stats\n-    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));\n+    assertThat(cache.getAll(asList(4, 5))).containsExactly(4, 4, 5, 5);\n     stats = cache.stats();\n-    assertEquals(5, stats.missCount());\n-    assertEquals(5, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(4, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(5);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(5);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(4);\n   }\n \n   public void testBulkLoad_loadAll() throws ExecutionException {\n@@ -383,45 +383,45 @@ public void testBulkLoad_loadAll() throws ExecutionException {\n     CacheLoader<Integer, Integer> loader = bulkLoader(backingLoader);\n     LoadingCache<Integer, Integer> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAll(ImmutableList.<Integer>of()));\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(cache.getAll(ImmutableList.<Integer>of())).containsExactly();\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1), cache.getAll(asList(1)));\n+    assertThat(cache.getAll(asList(1))).containsExactly(1, 1);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(1, 1, 2, 2, 3, 3, 4, 4), cache.getAll(asList(1, 2, 3, 4)));\n+    assertThat(cache.getAll(asList(1, 2, 3, 4))).containsExactly(1, 1, 2, 2, 3, 3, 4, 4);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n-    assertEquals(ImmutableMap.of(2, 2, 3, 3), cache.getAll(asList(2, 3)));\n+    assertThat(cache.getAll(asList(2, 3))).containsExactly(2, 2, 3, 3);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(2, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(2);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n \n     // duplicate keys are ignored, and don't impact stats\n-    assertEquals(ImmutableMap.of(4, 4, 5, 5), cache.getAll(asList(4, 5)));\n+    assertThat(cache.getAll(asList(4, 5))).containsExactly(4, 4, 5, 5);\n     stats = cache.stats();\n-    assertEquals(5, stats.missCount());\n-    assertEquals(3, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(4, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(5);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(3);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(4);\n   }\n \n   public void testBulkLoad_extra() throws ExecutionException {\n@@ -452,10 +452,10 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n     for (Entry<Object, Object> entry : result.entrySet()) {\n       Object key = entry.getKey();\n       Object value = entry.getValue();\n-      assertSame(value, result.get(key));\n-      assertNull(result.get(value));\n-      assertSame(value, cache.asMap().get(key));\n-      assertSame(key, cache.asMap().get(value));\n+      assertThat(result.get(key)).isSameInstanceAs(value);\n+      assertThat(result.get(value)).isNull();\n+      assertThat(cache.asMap().get(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().get(value)).isSameInstanceAs(key);\n     }\n   }\n \n@@ -482,7 +482,7 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n         };\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);\n     cache.asMap().put(extraKey, extraKey);\n-    assertSame(extraKey, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     Map<Object, Object> result = cache.getAll(asList(lookupKeys));\n@@ -490,11 +490,11 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n     for (Entry<Object, Object> entry : result.entrySet()) {\n       Object key = entry.getKey();\n       Object value = entry.getValue();\n-      assertSame(value, result.get(key));\n-      assertSame(value, cache.asMap().get(key));\n+      assertThat(result.get(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().get(key)).isSameInstanceAs(value);\n     }\n-    assertNull(result.get(extraKey));\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n+    assertThat(result.get(extraKey)).isNull();\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n   }\n \n   public void testBulkLoad_clobberNullValue() throws ExecutionException {\n@@ -521,16 +521,16 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n         };\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);\n     cache.asMap().put(extraKey, extraKey);\n-    assertSame(extraKey, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));\n \n     for (Object key : lookupKeys) {\n-      assertTrue(cache.asMap().containsKey(key));\n+      assertThat(cache.asMap().containsKey(key)).isTrue();\n     }\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n-    assertFalse(cache.asMap().containsKey(extraValue));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n+    assertThat(cache.asMap().containsKey(extraValue)).isFalse();\n   }\n \n   public void testBulkLoad_clobberNullKey() throws ExecutionException {\n@@ -557,16 +557,16 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n         };\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().build(loader);\n     cache.asMap().put(extraKey, extraKey);\n-    assertSame(extraKey, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraKey);\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));\n \n     for (Object key : lookupKeys) {\n-      assertTrue(cache.asMap().containsKey(key));\n+      assertThat(cache.asMap().containsKey(key)).isTrue();\n     }\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n-    assertFalse(cache.asMap().containsValue(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n+    assertThat(cache.asMap().containsValue(extraKey)).isFalse();\n   }\n \n   public void testBulkLoad_partial() throws ExecutionException {\n@@ -591,54 +591,54 @@ public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {\n \n     Object[] lookupKeys = new Object[] {new Object(), new Object(), new Object()};\n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(lookupKeys)));\n-    assertSame(extraValue, cache.asMap().get(extraKey));\n+    assertThat(cache.asMap().get(extraKey)).isSameInstanceAs(extraValue);\n   }\n \n   public void testLoadNull() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(constantLoader(null));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.get(new Object()));\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(new Object()));\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedInvalidLoad();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(\n         InvalidCacheLoadException.class, () -> cache.get(new Object(), Callables.returning(null)));\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadNull() throws ExecutionException {\n@@ -659,32 +659,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedInvalidLoad();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadNullFuture() throws ExecutionException {\n@@ -705,32 +705,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedInvalidLoad();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshNull() {\n@@ -757,59 +757,59 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadNull() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(constantLoader(null)));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testBulkLoadNullMap() throws ExecutionException {\n@@ -830,17 +830,17 @@ public Map<Object, Object> loadAll(Iterable<?> keys) {\n                 });\n \n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getAll(asList(new Object())));\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadError() throws ExecutionException {\n@@ -848,34 +848,34 @@ public void testLoadError() throws ExecutionException {\n     CacheLoader<Object, Object> loader = errorLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionError expected = assertThrows(ExecutionError.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionError.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Error callableError = new Error();\n     expected =\n@@ -892,18 +892,18 @@ public Object call() {\n                     }));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableError);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionError.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadError() throws ExecutionException {\n@@ -925,32 +925,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadFutureError() throws ExecutionException {\n@@ -972,32 +972,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshError() {\n@@ -1025,42 +1025,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadError() throws ExecutionException {\n@@ -1069,19 +1069,19 @@ public void testBulkLoadError() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionError expected =\n         assertThrows(ExecutionError.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadCheckedException() {\n@@ -1089,35 +1089,35 @@ public void testLoadCheckedException() {\n     CacheLoader<Object, Object> loader = exceptionLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception expected = assertThrows(ExecutionException.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception callableException = new Exception();\n     expected =\n@@ -1125,18 +1125,18 @@ public void testLoadCheckedException() {\n             ExecutionException.class, () -> cache.get(new Object(), throwing(callableException)));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadInterruptedException() {\n@@ -1144,62 +1144,62 @@ public void testLoadInterruptedException() {\n     CacheLoader<Object, Object> loader = exceptionLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     // Sanity check:\n-    assertFalse(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isFalse();\n \n     Exception expected = assertThrows(ExecutionException.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception callableException = new InterruptedException();\n     expected =\n         assertThrows(\n             ExecutionException.class, () -> cache.get(new Object(), throwing(callableException)));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected = assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadCheckedException() {\n@@ -1221,32 +1221,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) throws Excep\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadFutureCheckedException() {\n@@ -1268,32 +1268,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshCheckedException() {\n@@ -1321,42 +1321,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadCheckedException() {\n@@ -1365,19 +1365,19 @@ public void testBulkLoadCheckedException() {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionException expected =\n         assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testBulkLoadInterruptedException() {\n@@ -1386,20 +1386,20 @@ public void testBulkLoadInterruptedException() {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ExecutionException expected =\n         assertThrows(ExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(Thread.interrupted());\n+    assertThat(Thread.interrupted()).isTrue();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testLoadUncheckedException() throws ExecutionException {\n@@ -1407,36 +1407,36 @@ public void testLoadUncheckedException() throws ExecutionException {\n     CacheLoader<Object, Object> loader = exceptionLoader(e);\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     UncheckedExecutionException expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.get(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(new Object()));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(new Object());\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(3, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Exception callableException = new RuntimeException();\n     expected =\n@@ -1445,19 +1445,19 @@ public void testLoadUncheckedException() throws ExecutionException {\n             () -> cache.get(new Object(), throwing(callableException)));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(callableException);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(4, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(4, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(5, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(4);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(5);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadUncheckedException() throws ExecutionException {\n@@ -1479,32 +1479,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) throws Excep\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testReloadFutureUncheckedException() throws ExecutionException {\n@@ -1526,32 +1526,32 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n     LoadingCache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.refresh(key);\n     checkLoggedCause(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n   }\n \n   public void testRefreshUncheckedException() {\n@@ -1579,42 +1579,42 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {\n             .build(loader);\n     Object key = new Object();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     // refreshed\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertSame(one, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(1, stats.loadSuccessCount());\n-    assertEquals(2, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(1);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n   }\n \n   public void testBulkLoadUncheckedException() throws ExecutionException {\n@@ -1623,19 +1623,19 @@ public void testBulkLoadUncheckedException() throws ExecutionException {\n     LoadingCache<Object, Object> cache =\n         CacheBuilder.newBuilder().recordStats().build(bulkLoader(loader));\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     UncheckedExecutionException expected =\n         assertThrows(UncheckedExecutionException.class, () -> cache.getAll(asList(new Object())));\n     assertThat(expected).hasCauseThat().isSameInstanceAs(e);\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(1, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n   }\n \n   public void testReloadAfterFailure() throws ExecutionException {\n@@ -1660,15 +1660,15 @@ public String load(Integer key) throws Exception {\n         assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(1));\n     assertThat(ue).hasCauseThat().isSameInstanceAs(e);\n \n-    assertEquals(\"1\", cache.getUnchecked(1));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(cache.getUnchecked(1)).isEqualTo(\"1\");\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n \n     count.set(0);\n     cache.refresh(2);\n     checkLoggedCause(e);\n \n-    assertEquals(\"2\", cache.getUnchecked(2));\n-    assertEquals(0, removalListener.getCount());\n+    assertThat(cache.getUnchecked(2)).isEqualTo(\"2\");\n+    assertThat(removalListener.getCount()).isEqualTo(0);\n   }\n \n \n@@ -1693,7 +1693,7 @@ public void testReloadAfterValueReclamation() throws InterruptedException, Execu\n       Thread.sleep(i);\n       System.gc();\n     }\n-    assertEquals(expectedComputations, countingLoader.getCount());\n+    assertThat(countingLoader.getCount()).isEqualTo(expectedComputations);\n \n     for (int i = 0; i < iterations; i++) {\n       // The entry should get garbage collected and recomputed.\n@@ -1708,7 +1708,7 @@ public void testReloadAfterValueReclamation() throws InterruptedException, Execu\n       Thread.sleep(i);\n       System.gc();\n     }\n-    assertEquals(expectedComputations, countingLoader.getCount());\n+    assertThat(countingLoader.getCount()).isEqualTo(expectedComputations);\n   }\n \n   public void testReloadAfterSimulatedValueReclamation() throws ExecutionException {\n@@ -1717,20 +1717,20 @@ public void testReloadAfterSimulatedValueReclamation() throws ExecutionException\n         CacheBuilder.newBuilder().concurrencyLevel(1).weakValues().build(countingLoader);\n \n     Object key = new Object();\n-    assertNotNull(cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n \n     CacheTesting.simulateValueReclamation(cache, key);\n \n     // this blocks if computation can't deal with partially-collected values\n-    assertNotNull(cache.getUnchecked(key));\n-    assertEquals(1, cache.size());\n-    assertEquals(2, countingLoader.getCount());\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n+    assertThat(cache.size()).isEqualTo(1);\n+    assertThat(countingLoader.getCount()).isEqualTo(2);\n \n     CacheTesting.simulateValueReclamation(cache, key);\n     cache.refresh(key);\n     checkNothingLogged();\n-    assertEquals(1, cache.size());\n-    assertEquals(3, countingLoader.getCount());\n+    assertThat(cache.size()).isEqualTo(1);\n+    assertThat(countingLoader.getCount()).isEqualTo(3);\n   }\n \n   public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {\n@@ -1739,19 +1739,19 @@ public void testReloadAfterSimulatedKeyReclamation() throws ExecutionException {\n         CacheBuilder.newBuilder().concurrencyLevel(1).weakKeys().build(countingLoader);\n \n     Object key = new Object();\n-    assertNotNull(cache.getUnchecked(key));\n-    assertEquals(1, cache.size());\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n+    assertThat(cache.size()).isEqualTo(1);\n \n     CacheTesting.simulateKeyReclamation(cache, key);\n \n     // this blocks if computation can't deal with partially-collected values\n-    assertNotNull(cache.getUnchecked(key));\n-    assertEquals(2, countingLoader.getCount());\n+    assertThat(cache.getUnchecked(key)).isNotNull();\n+    assertThat(countingLoader.getCount()).isEqualTo(2);\n \n     CacheTesting.simulateKeyReclamation(cache, key);\n     cache.refresh(key);\n     checkNothingLogged();\n-    assertEquals(3, countingLoader.getCount());\n+    assertThat(countingLoader.getCount()).isEqualTo(3);\n   }\n \n   /**\n@@ -1864,9 +1864,11 @@ public Object load(String key) throws InterruptedException {\n \n     List<Object> resultArray = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n-      assertSame(\"result(\" + i + \") didn't match expected\", result, resultArray.get(i));\n+      assertWithMessage(\"result(%s) didn't match expected\", i)\n+          .that(resultArray.get(i))\n+          .isSameInstanceAs(result);\n     }\n   }\n \n@@ -1896,18 +1898,14 @@ public String load(String key) throws InterruptedException {\n \n     List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n       assertThat(result.get(i)).isInstanceOf(InvalidCacheLoadException.class);\n     }\n \n     // subsequent calls should call the loader again, not get the old exception\n-    try {\n-      cache.getUnchecked(\"bar\");\n-      fail();\n-    } catch (InvalidCacheLoadException expected) {\n-    }\n-    assertEquals(2, callCount.get());\n+    assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(\"bar\"));\n+    assertThat(callCount.get()).isEqualTo(2);\n   }\n \n   /**\n@@ -1936,7 +1934,7 @@ public String load(String key) throws InterruptedException {\n \n     List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n       // doConcurrentGet alternates between calling getUnchecked and calling get, but an unchecked\n       // exception thrown by the loader is always wrapped as an UncheckedExecutionException.\n@@ -1945,12 +1943,8 @@ public String load(String key) throws InterruptedException {\n     }\n \n     // subsequent calls should call the loader again, not get the old exception\n-    try {\n-      cache.getUnchecked(\"bar\");\n-      fail();\n-    } catch (UncheckedExecutionException expected) {\n-    }\n-    assertEquals(2, callCount.get());\n+    assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(\"bar\"));\n+    assertThat(callCount.get()).isEqualTo(2);\n   }\n \n   /**\n@@ -1979,7 +1973,7 @@ public String load(String key) throws IOException, InterruptedException {\n \n     List<Object> result = doConcurrentGet(cache, \"bar\", count, startSignal);\n \n-    assertEquals(1, callCount.get());\n+    assertThat(callCount.get()).isEqualTo(1);\n     for (int i = 0; i < count; i++) {\n       // doConcurrentGet alternates between calling getUnchecked and calling get. If we call get(),\n       // we should get an ExecutionException; if we call getUnchecked(), we should get an\n@@ -1995,12 +1989,8 @@ public String load(String key) throws IOException, InterruptedException {\n     }\n \n     // subsequent calls should call the loader again, not get the old exception\n-    try {\n-      cache.getUnchecked(\"bar\");\n-      fail();\n-    } catch (UncheckedExecutionException expected) {\n-    }\n-    assertEquals(2, callCount.get());\n+    assertThrows(UncheckedExecutionException.class, () -> cache.getUnchecked(\"bar\"));\n+    assertThat(callCount.get()).isEqualTo(2);\n   }\n \n   /**\n@@ -2084,9 +2074,9 @@ public String load(String key) throws InterruptedException {\n     LoadingCache<String, String> cache = CacheBuilder.newBuilder().build(computeFunction);\n     ConcurrentMap<String, String> map = cache.asMap();\n     map.put(refreshKey, refreshKey);\n-    assertEquals(1, map.size());\n-    assertFalse(map.containsKey(getKey));\n-    assertSame(refreshKey, map.get(refreshKey));\n+    assertThat(map).hasSize(1);\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.get(refreshKey)).isSameInstanceAs(refreshKey);\n \n     new Thread() {\n       @Override\n@@ -2106,9 +2096,9 @@ public void run() {\n     getStartedSignal.await();\n \n     // computation is in progress; asMap shouldn't have changed\n-    assertEquals(1, map.size());\n-    assertFalse(map.containsKey(getKey));\n-    assertSame(refreshKey, map.get(refreshKey));\n+    assertThat(map).hasSize(1);\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.get(refreshKey)).isSameInstanceAs(refreshKey);\n \n     // let computation complete\n     letGetFinishSignal.countDown();\n@@ -2116,9 +2106,9 @@ public void run() {\n     checkNothingLogged();\n \n     // asMap view should have been updated\n-    assertEquals(2, cache.size());\n-    assertEquals(getKey + suffix, map.get(getKey));\n-    assertEquals(refreshKey + suffix, map.get(refreshKey));\n+    assertThat(cache.size()).isEqualTo(2);\n+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);\n+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);\n   }\n \n   public void testInvalidateDuringLoading() throws InterruptedException, ExecutionException {\n@@ -2162,8 +2152,8 @@ public void run() {\n     computationStarted.await();\n     cache.invalidate(getKey);\n     cache.invalidate(refreshKey);\n-    assertFalse(map.containsKey(getKey));\n-    assertFalse(map.containsKey(refreshKey));\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.containsKey(refreshKey)).isFalse();\n \n     // let computation complete\n     letGetFinishSignal.countDown();\n@@ -2171,10 +2161,10 @@ public void run() {\n     checkNothingLogged();\n \n     // results should be visible\n-    assertEquals(2, cache.size());\n-    assertEquals(getKey + suffix, map.get(getKey));\n-    assertEquals(refreshKey + suffix, map.get(refreshKey));\n-    assertEquals(2, cache.size());\n+    assertThat(cache.size()).isEqualTo(2);\n+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);\n+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);\n+    assertThat(cache.size()).isEqualTo(2);\n   }\n \n   public void testInvalidateAndReloadDuringLoading()\n@@ -2219,8 +2209,8 @@ public void run() {\n     computationStarted.await();\n     cache.invalidate(getKey);\n     cache.invalidate(refreshKey);\n-    assertFalse(map.containsKey(getKey));\n-    assertFalse(map.containsKey(refreshKey));\n+    assertThat(map.containsKey(getKey)).isFalse();\n+    assertThat(map.containsKey(refreshKey)).isFalse();\n \n     // start new computations\n     new Thread() {\n@@ -2244,9 +2234,9 @@ public void run() {\n     checkNothingLogged();\n \n     // results should be visible\n-    assertEquals(2, cache.size());\n-    assertEquals(getKey + suffix, map.get(getKey));\n-    assertEquals(refreshKey + suffix, map.get(refreshKey));\n+    assertThat(cache.size()).isEqualTo(2);\n+    assertThat(map.get(getKey)).isEqualTo(getKey + suffix);\n+    assertThat(map.get(refreshKey)).isEqualTo(refreshKey + suffix);\n   }\n \n   @SuppressWarnings(\"ThreadPriorityCheck\") // doing our best to test for races\n@@ -2331,11 +2321,11 @@ public void run() {\n     computeSignal.countDown();\n     doneSignal.await();\n \n-    assertTrue(callCount.get() == 1);\n-    assertEquals(\"barfoo\", result.get(0));\n-    assertEquals(\"barfoo\", result.get(1));\n-    assertEquals(\"barfoo\", result.get(2));\n-    assertEquals(\"barfoo\", cache.getUnchecked(key));\n+    assertThat(callCount.get()).isEqualTo(1);\n+    assertThat(result.get(0)).isEqualTo(\"barfoo\");\n+    assertThat(result.get(1)).isEqualTo(\"barfoo\");\n+    assertThat(result.get(2)).isEqualTo(\"barfoo\");\n+    assertThat(cache.getUnchecked(key)).isEqualTo(\"barfoo\");\n   }\n \n   // Test ignored because it is extremely flaky in CI builds\n@@ -2423,10 +2413,10 @@ public void run() {\n     computeSignal.countDown();\n     doneSignal.await();\n \n-    assertTrue(callCount.get() == 1);\n-    assertEquals(key, result.get(0));\n-    assertEquals(key, result.get(1));\n-    assertEquals(key + suffix, cache.getUnchecked(key));\n+    assertThat(callCount.get()).isEqualTo(1);\n+    assertThat(result.get(0)).isEqualTo(key);\n+    assertThat(result.get(1)).isEqualTo(key);\n+    assertThat(cache.getUnchecked(key)).isEqualTo(key + suffix);\n   }\n \n   static <T> Callable<T> throwing(Exception exception) {\ndiff --git a/guava-tests/test/com/google/common/cache/CacheManualTest.java b/guava-tests/test/com/google/common/cache/CacheManualTest.java\nindex a2cf24dcef28..e3b358a738b0 100644\n--- a/guava-tests/test/com/google/common/cache/CacheManualTest.java\n+++ b/guava-tests/test/com/google/common/cache/CacheManualTest.java\n@@ -14,6 +14,7 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.Arrays.asList;\n \n import com.google.common.collect.ImmutableList;\n@@ -30,126 +31,127 @@ public class CacheManualTest extends TestCase {\n   public void testGetIfPresent() {\n     Cache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     Object one = new Object();\n     Object two = new Object();\n \n-    assertNull(cache.getIfPresent(one));\n+    assertThat(cache.getIfPresent(one)).isNull();\n     stats = cache.stats();\n-    assertEquals(1, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n-    assertNull(cache.asMap().get(one));\n-    assertFalse(cache.asMap().containsKey(one));\n-    assertFalse(cache.asMap().containsValue(two));\n-\n-    assertNull(cache.getIfPresent(two));\n+    assertThat(stats.missCount()).isEqualTo(1);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n+    assertThat(cache.asMap().get(one)).isNull();\n+    assertThat(cache.asMap().containsKey(one)).isFalse();\n+    assertThat(cache.asMap().containsValue(two)).isFalse();\n+\n+    assertThat(cache.getIfPresent(two)).isNull();\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n-    assertNull(cache.asMap().get(two));\n-    assertFalse(cache.asMap().containsKey(two));\n-    assertFalse(cache.asMap().containsValue(one));\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n+    assertThat(cache.asMap().get(two)).isNull();\n+    assertThat(cache.asMap().containsKey(two)).isFalse();\n+    assertThat(cache.asMap().containsValue(one)).isFalse();\n \n     cache.put(one, two);\n \n-    assertSame(two, cache.getIfPresent(one));\n+    assertThat(cache.getIfPresent(one)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(2, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n-    assertSame(two, cache.asMap().get(one));\n-    assertTrue(cache.asMap().containsKey(one));\n-    assertTrue(cache.asMap().containsValue(two));\n-\n-    assertNull(cache.getIfPresent(two));\n+    assertThat(stats.missCount()).isEqualTo(2);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n+    assertThat(cache.asMap().get(one)).isSameInstanceAs(two);\n+    assertThat(cache.asMap().containsKey(one)).isTrue();\n+    assertThat(cache.asMap().containsValue(two)).isTrue();\n+\n+    assertThat(cache.getIfPresent(two)).isNull();\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n-    assertNull(cache.asMap().get(two));\n-    assertFalse(cache.asMap().containsKey(two));\n-    assertFalse(cache.asMap().containsValue(one));\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n+    assertThat(cache.asMap().get(two)).isNull();\n+    assertThat(cache.asMap().containsKey(two)).isFalse();\n+    assertThat(cache.asMap().containsValue(one)).isFalse();\n \n     cache.put(two, one);\n \n-    assertSame(two, cache.getIfPresent(one));\n+    assertThat(cache.getIfPresent(one)).isSameInstanceAs(two);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(2, stats.hitCount());\n-    assertSame(two, cache.asMap().get(one));\n-    assertTrue(cache.asMap().containsKey(one));\n-    assertTrue(cache.asMap().containsValue(two));\n-\n-    assertSame(one, cache.getIfPresent(two));\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(2);\n+    assertThat(cache.asMap().get(one)).isSameInstanceAs(two);\n+    assertThat(cache.asMap().containsKey(one)).isTrue();\n+    assertThat(cache.asMap().containsValue(two)).isTrue();\n+\n+    assertThat(cache.getIfPresent(two)).isSameInstanceAs(one);\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n-    assertSame(one, cache.asMap().get(two));\n-    assertTrue(cache.asMap().containsKey(two));\n-    assertTrue(cache.asMap().containsValue(one));\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n+    assertThat(cache.asMap().get(two)).isSameInstanceAs(one);\n+    assertThat(cache.asMap().containsKey(two)).isTrue();\n+    assertThat(cache.asMap().containsValue(one)).isTrue();\n   }\n \n   public void testGetAllPresent() {\n     Cache<Integer, Integer> cache = CacheBuilder.newBuilder().recordStats().build();\n     CacheStats stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAllPresent(ImmutableList.<Integer>of()));\n+    assertThat(cache.getAllPresent(ImmutableList.<Integer>of())).isEmpty();\n     stats = cache.stats();\n-    assertEquals(0, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n-    assertEquals(ImmutableMap.of(), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3))).isEqualTo(ImmutableMap.of());\n     stats = cache.stats();\n-    assertEquals(3, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n \n     cache.put(2, 22);\n \n-    assertEquals(ImmutableMap.of(2, 22), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3))).containsExactly(2, 22);\n     stats = cache.stats();\n-    assertEquals(5, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(5);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n \n     cache.put(3, 33);\n \n-    assertEquals(ImmutableMap.of(2, 22, 3, 33), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3))).containsExactly(2, 22, 3, 33);\n     stats = cache.stats();\n-    assertEquals(6, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(3, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(6);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(3);\n \n     cache.put(1, 11);\n \n-    assertEquals(ImmutableMap.of(1, 11, 2, 22, 3, 33), cache.getAllPresent(asList(1, 2, 3)));\n+    assertThat(cache.getAllPresent(asList(1, 2, 3)))\n+        .isEqualTo(ImmutableMap.of(1, 11, 2, 22, 3, 33));\n     stats = cache.stats();\n-    assertEquals(6, stats.missCount());\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n-    assertEquals(6, stats.hitCount());\n+    assertThat(stats.missCount()).isEqualTo(6);\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(6);\n   }\n }\ndiff --git a/guava-tests/test/com/google/common/cache/CacheReferencesTest.java b/guava-tests/test/com/google/common/cache/CacheReferencesTest.java\nindex 5426d29141f5..11ce62e0a0b1 100644\n--- a/guava-tests/test/com/google/common/cache/CacheReferencesTest.java\n+++ b/guava-tests/test/com/google/common/cache/CacheReferencesTest.java\n@@ -66,10 +66,10 @@ public void testContainsKeyAndValue() {\n       // maintain strong refs so these won't be collected, regardless of cache's key/value strength\n       Key key = new Key(1);\n       String value = key.toString();\n-      assertSame(value, cache.getUnchecked(key));\n-      assertTrue(cache.asMap().containsKey(key));\n-      assertTrue(cache.asMap().containsValue(value));\n-      assertEquals(1, cache.size());\n+      assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().containsKey(key)).isTrue();\n+      assertThat(cache.asMap().containsValue(value)).isTrue();\n+      assertThat(cache.size()).isEqualTo(1);\n     }\n   }\n \n@@ -77,13 +77,13 @@ public void testClear() {\n     for (LoadingCache<Key, String> cache : caches()) {\n       Key key = new Key(1);\n       String value = key.toString();\n-      assertSame(value, cache.getUnchecked(key));\n-      assertFalse(cache.asMap().isEmpty());\n+      assertThat(cache.getUnchecked(key)).isSameInstanceAs(value);\n+      assertThat(cache.asMap().isEmpty()).isFalse();\n       cache.invalidateAll();\n-      assertEquals(0, cache.size());\n-      assertTrue(cache.asMap().isEmpty());\n-      assertFalse(cache.asMap().containsKey(key));\n-      assertFalse(cache.asMap().containsValue(value));\n+      assertThat(cache.size()).isEqualTo(0);\n+      assertThat(cache.asMap().isEmpty()).isTrue();\n+      assertThat(cache.asMap().containsKey(key)).isFalse();\n+      assertThat(cache.asMap().containsValue(value)).isFalse();\n     }\n   }\n \n@@ -93,13 +93,12 @@ public void testKeySetEntrySetValues() {\n       String value1 = key1.toString();\n       Key key2 = new Key(2);\n       String value2 = key2.toString();\n-      assertSame(value1, cache.getUnchecked(key1));\n-      assertSame(value2, cache.getUnchecked(key2));\n-      assertEquals(ImmutableSet.of(key1, key2), cache.asMap().keySet());\n+      assertThat(cache.getUnchecked(key1)).isSameInstanceAs(value1);\n+      assertThat(cache.getUnchecked(key2)).isSameInstanceAs(value2);\n+      assertThat(cache.asMap().keySet()).isEqualTo(ImmutableSet.of(key1, key2));\n       assertThat(cache.asMap().values()).containsExactly(value1, value2);\n-      assertEquals(\n-          ImmutableSet.of(immutableEntry(key1, value1), immutableEntry(key2, value2)),\n-          cache.asMap().entrySet());\n+      assertThat(cache.asMap().entrySet())\n+          .containsExactly(immutableEntry(key1, value1), immutableEntry(key2, value2));\n     }\n   }\n \n@@ -109,15 +108,15 @@ public void testInvalidate() {\n       String value1 = key1.toString();\n       Key key2 = new Key(2);\n       String value2 = key2.toString();\n-      assertSame(value1, cache.getUnchecked(key1));\n-      assertSame(value2, cache.getUnchecked(key2));\n+      assertThat(cache.getUnchecked(key1)).isSameInstanceAs(value1);\n+      assertThat(cache.getUnchecked(key2)).isSameInstanceAs(value2);\n       cache.invalidate(key1);\n-      assertFalse(cache.asMap().containsKey(key1));\n-      assertTrue(cache.asMap().containsKey(key2));\n-      assertEquals(1, cache.size());\n-      assertEquals(ImmutableSet.of(key2), cache.asMap().keySet());\n+      assertThat(cache.asMap().containsKey(key1)).isFalse();\n+      assertThat(cache.asMap().containsKey(key2)).isTrue();\n+      assertThat(cache.size()).isEqualTo(1);\n+      assertThat(cache.asMap().keySet()).isEqualTo(ImmutableSet.of(key2));\n       assertThat(cache.asMap().values()).contains(value2);\n-      assertEquals(ImmutableSet.of(immutableEntry(key2, value2)), cache.asMap().entrySet());\n+      assertThat(cache.asMap().entrySet()).containsExactly(immutableEntry(key2, value2));\n     }\n   }\n \ndiff --git a/guava-tests/test/com/google/common/cache/CacheRefreshTest.java b/guava-tests/test/com/google/common/cache/CacheRefreshTest.java\nindex 6a7948c470dc..83c3ea3b5777 100644\n--- a/guava-tests/test/com/google/common/cache/CacheRefreshTest.java\n+++ b/guava-tests/test/com/google/common/cache/CacheRefreshTest.java\n@@ -15,6 +15,7 @@\n package com.google.common.cache;\n \n import static com.google.common.cache.TestingCacheLoaders.incrementingLoader;\n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n \n import com.google.common.cache.TestingCacheLoaders.IncrementingLoader;\n@@ -42,61 +43,61 @@ public void testAutoRefresh() {\n     int expectedLoads = 0;\n     int expectedReloads = 0;\n     for (int i = 0; i < 3; i++) {\n-      assertEquals(Integer.valueOf(i), cache.getUnchecked(i));\n+      assertThat(cache.getUnchecked(i)).isEqualTo(i);\n       expectedLoads++;\n-      assertEquals(expectedLoads, loader.getLoadCount());\n-      assertEquals(expectedReloads, loader.getReloadCount());\n+      assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+      assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n       ticker.advance(1, MILLISECONDS);\n     }\n \n-    assertEquals(Integer.valueOf(0), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(0)).isEqualTo(0);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // refresh 0\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n     expectedReloads++;\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(1)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // write to 1 to delay its refresh\n     cache.asMap().put(1, -1);\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(2);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // refresh 2\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(3);\n     expectedReloads++;\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(1), cache.getUnchecked(0));\n-    assertEquals(Integer.valueOf(-1), cache.getUnchecked(1));\n-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(0)).isEqualTo(1);\n+    assertThat(cache.getUnchecked(1)).isEqualTo(-1);\n+    assertThat(cache.getUnchecked(2)).isEqualTo(3);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n \n     // refresh 0 and 1\n     ticker.advance(1, MILLISECONDS);\n-    assertEquals(Integer.valueOf(2), cache.getUnchecked(0));\n+    assertThat(cache.getUnchecked(0)).isEqualTo(2);\n     expectedReloads++;\n-    assertEquals(Integer.valueOf(0), cache.getUnchecked(1));\n+    assertThat(cache.getUnchecked(1)).isEqualTo(0);\n     expectedReloads++;\n-    assertEquals(Integer.valueOf(3), cache.getUnchecked(2));\n-    assertEquals(expectedLoads, loader.getLoadCount());\n-    assertEquals(expectedReloads, loader.getReloadCount());\n+    assertThat(cache.getUnchecked(2)).isEqualTo(3);\n+    assertThat(loader.getLoadCount()).isEqualTo(expectedLoads);\n+    assertThat(loader.getReloadCount()).isEqualTo(expectedReloads);\n   }\n }\ndiff --git a/guava-tests/test/com/google/common/cache/CacheStatsTest.java b/guava-tests/test/com/google/common/cache/CacheStatsTest.java\nindex cfd174aea242..72cbfee29807 100644\n--- a/guava-tests/test/com/google/common/cache/CacheStatsTest.java\n+++ b/guava-tests/test/com/google/common/cache/CacheStatsTest.java\n@@ -31,34 +31,34 @@ public class CacheStatsTest extends TestCase {\n \n   public void testEmpty() {\n     CacheStats stats = new CacheStats(0, 0, 0, 0, 0, 0);\n-    assertEquals(0, stats.requestCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(0);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n     assertThat(stats.hitRate()).isEqualTo(1.0);\n-    assertEquals(0, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(0);\n     assertThat(stats.missRate()).isEqualTo(0.0);\n-    assertEquals(0, stats.loadSuccessCount());\n-    assertEquals(0, stats.loadExceptionCount());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(0);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(0);\n     assertThat(stats.loadExceptionRate()).isEqualTo(0.0);\n-    assertEquals(0, stats.loadCount());\n-    assertEquals(0, stats.totalLoadTime());\n+    assertThat(stats.loadCount()).isEqualTo(0);\n+    assertThat(stats.totalLoadTime()).isEqualTo(0);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n   }\n \n   public void testSingle() {\n     CacheStats stats = new CacheStats(11, 13, 17, 19, 23, 27);\n-    assertEquals(24, stats.requestCount());\n-    assertEquals(11, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(24);\n+    assertThat(stats.hitCount()).isEqualTo(11);\n     assertThat(stats.hitRate()).isEqualTo(11.0 / 24);\n-    assertEquals(13, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(13);\n     assertThat(stats.missRate()).isEqualTo(13.0 / 24);\n-    assertEquals(17, stats.loadSuccessCount());\n-    assertEquals(19, stats.loadExceptionCount());\n+    assertThat(stats.loadSuccessCount()).isEqualTo(17);\n+    assertThat(stats.loadExceptionCount()).isEqualTo(19);\n     assertThat(stats.loadExceptionRate()).isEqualTo(19.0 / 36);\n-    assertEquals(17 + 19, stats.loadCount());\n-    assertEquals(23, stats.totalLoadTime());\n+    assertThat(stats.loadCount()).isEqualTo(17 + 19);\n+    assertThat(stats.totalLoadTime()).isEqualTo(23);\n     assertThat(stats.averageLoadPenalty()).isEqualTo(23.0 / (17 + 19));\n-    assertEquals(27, stats.evictionCount());\n+    assertThat(stats.evictionCount()).isEqualTo(27);\n   }\n \n   public void testMinus() {\n@@ -66,20 +66,20 @@ public void testMinus() {\n     CacheStats two = new CacheStats(53, 47, 43, 41, 37, 31);\n \n     CacheStats diff = two.minus(one);\n-    assertEquals(76, diff.requestCount());\n-    assertEquals(42, diff.hitCount());\n+    assertThat(diff.requestCount()).isEqualTo(76);\n+    assertThat(diff.hitCount()).isEqualTo(42);\n     assertThat(diff.hitRate()).isEqualTo(42.0 / 76);\n-    assertEquals(34, diff.missCount());\n+    assertThat(diff.missCount()).isEqualTo(34);\n     assertThat(diff.missRate()).isEqualTo(34.0 / 76);\n-    assertEquals(26, diff.loadSuccessCount());\n-    assertEquals(22, diff.loadExceptionCount());\n+    assertThat(diff.loadSuccessCount()).isEqualTo(26);\n+    assertThat(diff.loadExceptionCount()).isEqualTo(22);\n     assertThat(diff.loadExceptionRate()).isEqualTo(22.0 / 48);\n-    assertEquals(26 + 22, diff.loadCount());\n-    assertEquals(14, diff.totalLoadTime());\n+    assertThat(diff.loadCount()).isEqualTo(26 + 22);\n+    assertThat(diff.totalLoadTime()).isEqualTo(14);\n     assertThat(diff.averageLoadPenalty()).isEqualTo(14.0 / (26 + 22));\n-    assertEquals(4, diff.evictionCount());\n+    assertThat(diff.evictionCount()).isEqualTo(4);\n \n-    assertEquals(new CacheStats(0, 0, 0, 0, 0, 0), one.minus(two));\n+    assertThat(one.minus(two)).isEqualTo(new CacheStats(0, 0, 0, 0, 0, 0));\n   }\n \n   public void testPlus() {\n@@ -87,20 +87,20 @@ public void testPlus() {\n     CacheStats two = new CacheStats(53, 47, 41, 39, 37, 35);\n \n     CacheStats sum = two.plus(one);\n-    assertEquals(124, sum.requestCount());\n-    assertEquals(64, sum.hitCount());\n+    assertThat(sum.requestCount()).isEqualTo(124);\n+    assertThat(sum.hitCount()).isEqualTo(64);\n     assertThat(sum.hitRate()).isEqualTo(64.0 / 124);\n-    assertEquals(60, sum.missCount());\n+    assertThat(sum.missCount()).isEqualTo(60);\n     assertThat(sum.missRate()).isEqualTo(60.0 / 124);\n-    assertEquals(56, sum.loadSuccessCount());\n-    assertEquals(52, sum.loadExceptionCount());\n+    assertThat(sum.loadSuccessCount()).isEqualTo(56);\n+    assertThat(sum.loadExceptionCount()).isEqualTo(52);\n     assertThat(sum.loadExceptionRate()).isEqualTo(52.0 / 108);\n-    assertEquals(56 + 52, sum.loadCount());\n-    assertEquals(48, sum.totalLoadTime());\n+    assertThat(sum.loadCount()).isEqualTo(56 + 52);\n+    assertThat(sum.totalLoadTime()).isEqualTo(48);\n     assertThat(sum.averageLoadPenalty()).isEqualTo(48.0 / (56 + 52));\n-    assertEquals(44, sum.evictionCount());\n+    assertThat(sum.evictionCount()).isEqualTo(44);\n \n-    assertEquals(sum, one.plus(two));\n+    assertThat(one.plus(two)).isEqualTo(sum);\n   }\n \n   public void testPlusLarge() {\n@@ -115,19 +115,19 @@ public void testPlusLarge() {\n     CacheStats smallCacheStats = new CacheStats(1, 1, 1, 1, 1, 1);\n \n     CacheStats sum = smallCacheStats.plus(maxCacheStats);\n-    assertEquals(Long.MAX_VALUE, sum.requestCount());\n-    assertEquals(Long.MAX_VALUE, sum.hitCount());\n+    assertThat(sum.requestCount()).isEqualTo(Long.MAX_VALUE);\n+    assertThat(sum.hitCount()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.hitRate()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.missCount());\n+    assertThat(sum.missCount()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.missRate()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.loadSuccessCount());\n-    assertEquals(Long.MAX_VALUE, sum.loadExceptionCount());\n+    assertThat(sum.loadSuccessCount()).isEqualTo(Long.MAX_VALUE);\n+    assertThat(sum.loadExceptionCount()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.loadExceptionRate()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.loadCount());\n-    assertEquals(Long.MAX_VALUE, sum.totalLoadTime());\n+    assertThat(sum.loadCount()).isEqualTo(Long.MAX_VALUE);\n+    assertThat(sum.totalLoadTime()).isEqualTo(Long.MAX_VALUE);\n     assertThat(sum.averageLoadPenalty()).isEqualTo(1.0);\n-    assertEquals(Long.MAX_VALUE, sum.evictionCount());\n+    assertThat(sum.evictionCount()).isEqualTo(Long.MAX_VALUE);\n \n-    assertEquals(sum, maxCacheStats.plus(smallCacheStats));\n+    assertThat(maxCacheStats.plus(smallCacheStats)).isEqualTo(sum);\n   }\n }\ndiff --git a/guava-tests/test/com/google/common/cache/CacheTesting.java b/guava-tests/test/com/google/common/cache/CacheTesting.java\nindex 5c27308ed868..6c33cde9d009 100644\n--- a/guava-tests/test/com/google/common/cache/CacheTesting.java\n+++ b/guava-tests/test/com/google/common/cache/CacheTesting.java\n@@ -16,15 +16,9 @@\n \n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static java.lang.Math.max;\n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n-import static junit.framework.Assert.assertEquals;\n-import static junit.framework.Assert.assertFalse;\n-import static junit.framework.Assert.assertNotNull;\n-import static junit.framework.Assert.assertNotSame;\n-import static junit.framework.Assert.assertNull;\n-import static junit.framework.Assert.assertSame;\n-import static junit.framework.Assert.assertTrue;\n \n import com.google.common.base.Preconditions;\n import com.google.common.cache.LocalCache.LocalLoadingCache;\n@@ -194,16 +188,16 @@ static void checkValidState(Cache<?, ?> cache) {\n   static void checkValidState(LocalCache<?, ?> cchm) {\n     for (Segment<?, ?> segment : cchm.segments) {\n       segment.cleanUp();\n-      assertFalse(segment.isLocked());\n+      assertThat(segment.isLocked()).isFalse();\n       Map<?, ?> table = segmentTable(segment);\n       // cleanup and then check count after we have a strong reference to all entries\n       segment.cleanUp();\n       // under high memory pressure keys/values may be nulled out but not yet enqueued\n       assertThat(table.size()).isAtMost(segment.count);\n       for (Entry<?, ?> entry : table.entrySet()) {\n-        assertNotNull(entry.getKey());\n-        assertNotNull(entry.getValue());\n-        assertSame(entry.getValue(), cchm.get(entry.getKey()));\n+        assertThat(entry.getKey()).isNotNull();\n+        assertThat(entry.getValue()).isNotNull();\n+        assertThat(cchm.get(entry.getKey())).isSameInstanceAs(entry.getValue());\n       }\n     }\n     checkEviction(cchm);\n@@ -228,21 +222,21 @@ static void checkExpiration(LocalCache<?, ?> cchm) {\n \n         ReferenceEntry<?, ?> prev = null;\n         for (ReferenceEntry<?, ?> current : segment.writeQueue) {\n-          assertTrue(entries.add(current));\n+          assertThat(entries.add(current)).isTrue();\n           if (prev != null) {\n-            assertSame(prev, current.getPreviousInWriteQueue());\n-            assertSame(prev.getNextInWriteQueue(), current);\n+            assertThat(current.getPreviousInWriteQueue()).isSameInstanceAs(prev);\n+            assertThat(current).isSameInstanceAs(prev.getNextInWriteQueue());\n             assertThat(prev.getWriteTime()).isAtMost(current.getWriteTime());\n           }\n           Object key = current.getKey();\n           if (key != null) {\n-            assertSame(current, segment.getEntry(key, current.getHash()));\n+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);\n           }\n           prev = current;\n         }\n-        assertEquals(segment.count, entries.size());\n+        assertThat(entries).hasSize(segment.count);\n       } else {\n-        assertTrue(segment.writeQueue.isEmpty());\n+        assertThat(segment.writeQueue.isEmpty()).isTrue();\n       }\n \n       if (cchm.usesAccessQueue()) {\n@@ -250,24 +244,25 @@ static void checkExpiration(LocalCache<?, ?> cchm) {\n \n         ReferenceEntry<?, ?> prev = null;\n         for (ReferenceEntry<?, ?> current : segment.accessQueue) {\n-          assertTrue(entries.add(current));\n+          assertThat(entries.add(current)).isTrue();\n           if (prev != null) {\n-            assertSame(prev, current.getPreviousInAccessQueue());\n-            assertSame(prev.getNextInAccessQueue(), current);\n+            assertThat(current.getPreviousInAccessQueue()).isSameInstanceAs(prev);\n+            assertThat(current).isSameInstanceAs(prev.getNextInAccessQueue());\n             // read accesses may be slightly misordered\n-            assertTrue(\n-                prev.getAccessTime() <= current.getAccessTime()\n-                    || prev.getAccessTime() - current.getAccessTime() < 1000);\n+            assertThat(\n+                    prev.getAccessTime() <= current.getAccessTime()\n+                        || prev.getAccessTime() - current.getAccessTime() < 1000)\n+                .isTrue();\n           }\n           Object key = current.getKey();\n           if (key != null) {\n-            assertSame(current, segment.getEntry(key, current.getHash()));\n+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);\n           }\n           prev = current;\n         }\n-        assertEquals(segment.count, entries.size());\n+        assertThat(entries).hasSize(segment.count);\n       } else {\n-        assertTrue(segment.accessQueue.isEmpty());\n+        assertThat(segment.accessQueue).isEmpty();\n       }\n     }\n   }\n@@ -287,25 +282,25 @@ static void checkEviction(LocalCache<?, ?> map) {\n     if (map.evictsBySize()) {\n       for (Segment<?, ?> segment : map.segments) {\n         drainRecencyQueue(segment);\n-        assertEquals(0, segment.recencyQueue.size());\n-        assertEquals(0, segment.readCount.get());\n+        assertThat(segment.recencyQueue).isEmpty();\n+        assertThat(segment.readCount.get()).isEqualTo(0);\n \n         ReferenceEntry<?, ?> prev = null;\n         for (ReferenceEntry<?, ?> current : segment.accessQueue) {\n           if (prev != null) {\n-            assertSame(prev, current.getPreviousInAccessQueue());\n-            assertSame(prev.getNextInAccessQueue(), current);\n+            assertThat(current.getPreviousInAccessQueue()).isSameInstanceAs(prev);\n+            assertThat(current).isSameInstanceAs(prev.getNextInAccessQueue());\n           }\n           Object key = current.getKey();\n           if (key != null) {\n-            assertSame(current, segment.getEntry(key, current.getHash()));\n+            assertThat(segment.getEntry(key, current.getHash())).isSameInstanceAs(current);\n           }\n           prev = current;\n         }\n       }\n     } else {\n       for (Segment<?, ?> segment : map.segments) {\n-        assertEquals(0, segment.recencyQueue.size());\n+        assertThat(segment.recencyQueue).isEmpty();\n       }\n     }\n   }\n@@ -323,7 +318,7 @@ static <K, V> Map<K, V> segmentTable(Segment<K, V> segment) {\n         K key = entry.getKey();\n         V value = entry.getValueReference().get();\n         if (key != null && value != null) {\n-          assertNull(map.put(key, value));\n+          assertThat(map.put(key, value)).isNull();\n         }\n       }\n     }\n@@ -390,8 +385,8 @@ static void checkRecency(\n       LocalCache<Integer, Integer> cchm = toLocalCache(cache);\n       Segment<?, ?> segment = cchm.segments[0];\n       drainRecencyQueue(segment);\n-      assertEquals(maxSize, accessQueueSize(cache));\n-      assertEquals(maxSize, cache.size());\n+      assertThat(accessQueueSize(cache)).isEqualTo(maxSize);\n+      assertThat(cache.size()).isEqualTo(maxSize);\n \n       ReferenceEntry<?, ?> originalHead = segment.accessQueue.peek();\n       @SuppressWarnings(\"unchecked\")\n@@ -399,8 +394,8 @@ static void checkRecency(\n       operation.accept(entry);\n       drainRecencyQueue(segment);\n \n-      assertNotSame(originalHead, segment.accessQueue.peek());\n-      assertEquals(cache.size(), accessQueueSize(cache));\n+      assertThat(segment.accessQueue.peek()).isNotSameInstanceAs(originalHead);\n+      assertThat(accessQueueSize(cache)).isEqualTo(cache.size());\n     }\n   }\n \n@@ -428,9 +423,13 @@ static void expireEntries(LocalCache<?, ?> cchm, long expiringTime, FakeTicker t\n     long now = ticker.read();\n     for (Segment<?, ?> segment : cchm.segments) {\n       expireEntries(segment, now);\n-      assertEquals(\"Expiration queue must be empty by now\", 0, writeQueueSize(segment));\n-      assertEquals(\"Expiration queue must be empty by now\", 0, accessQueueSize(segment));\n-      assertEquals(\"Segments must be empty by now\", 0, segmentSize(segment));\n+      assertWithMessage(\"Expiration queue must be empty by now\")\n+          .that(writeQueueSize(segment))\n+          .isEqualTo(0);\n+      assertWithMessage(\"Expiration queue must be empty by now\")\n+          .that(accessQueueSize(segment))\n+          .isEqualTo(0);\n+      assertWithMessage(\"Segments must be empty by now\").that(segmentSize(segment)).isEqualTo(0);\n     }\n     cchm.processPendingNotifications();\n   }\n@@ -446,11 +445,11 @@ static void expireEntries(Segment<?, ?> segment, long now) {\n   }\n \n   static void checkEmpty(Cache<?, ?> cache) {\n-    assertEquals(0, cache.size());\n-    assertFalse(cache.asMap().containsKey(null));\n-    assertFalse(cache.asMap().containsKey(6));\n-    assertFalse(cache.asMap().containsValue(null));\n-    assertFalse(cache.asMap().containsValue(6));\n+    assertThat(cache.size()).isEqualTo(0);\n+    assertThat(cache.asMap().containsKey(null)).isFalse();\n+    assertThat(cache.asMap().containsKey(6)).isFalse();\n+    assertThat(cache.asMap().containsValue(null)).isFalse();\n+    assertThat(cache.asMap().containsValue(6)).isFalse();\n     checkEmpty(cache.asMap());\n   }\n \n@@ -458,29 +457,29 @@ static void checkEmpty(ConcurrentMap<?, ?> map) {\n     checkEmpty(map.keySet());\n     checkEmpty(map.values());\n     checkEmpty(map.entrySet());\n-    assertEquals(ImmutableMap.of(), map);\n-    assertEquals(ImmutableMap.of().hashCode(), map.hashCode());\n-    assertEquals(ImmutableMap.of().toString(), map.toString());\n+    assertThat(map).isEqualTo(ImmutableMap.of());\n+    assertThat(map.hashCode()).isEqualTo(ImmutableMap.of().hashCode());\n+    assertThat(map.toString()).isEqualTo(ImmutableMap.of().toString());\n \n     if (map instanceof LocalCache) {\n       LocalCache<?, ?> cchm = (LocalCache<?, ?>) map;\n \n       checkValidState(cchm);\n-      assertTrue(cchm.isEmpty());\n-      assertEquals(0, cchm.size());\n+      assertThat(cchm.isEmpty()).isTrue();\n+      assertThat(cchm).isEmpty();\n       for (LocalCache.Segment<?, ?> segment : cchm.segments) {\n-        assertEquals(0, segment.count);\n-        assertEquals(0, segmentSize(segment));\n-        assertTrue(segment.writeQueue.isEmpty());\n-        assertTrue(segment.accessQueue.isEmpty());\n+        assertThat(segment.count).isEqualTo(0);\n+        assertThat(segmentSize(segment)).isEqualTo(0);\n+        assertThat(segment.writeQueue.isEmpty()).isTrue();\n+        assertThat(segment.accessQueue.isEmpty()).isTrue();\n       }\n     }\n   }\n \n   static void checkEmpty(Collection<?> collection) {\n-    assertTrue(collection.isEmpty());\n-    assertEquals(0, collection.size());\n-    assertFalse(collection.iterator().hasNext());\n+    assertThat(collection.isEmpty()).isTrue();\n+    assertThat(collection).isEmpty();\n+    assertThat(collection.iterator().hasNext()).isFalse();\n     assertThat(collection.toArray()).isEmpty();\n     assertThat(collection.toArray(new Object[0])).isEmpty();\n     if (collection instanceof Set) {\ndiff --git a/guava-tests/test/com/google/common/cache/EmptyCachesTest.java b/guava-tests/test/com/google/common/cache/EmptyCachesTest.java\nindex f93568bc29a5..94a912347d9d 100644\n--- a/guava-tests/test/com/google/common/cache/EmptyCachesTest.java\n+++ b/guava-tests/test/com/google/common/cache/EmptyCachesTest.java\n@@ -16,6 +16,7 @@\n \n import static com.google.common.cache.CacheTesting.checkEmpty;\n import static com.google.common.cache.TestingCacheLoaders.identityLoader;\n+import static com.google.common.truth.Truth.assertThat;\n import static java.util.Arrays.asList;\n import static java.util.concurrent.TimeUnit.DAYS;\n import static java.util.concurrent.TimeUnit.SECONDS;\n@@ -75,7 +76,7 @@ public void testInvalidateAll_empty() {\n \n   public void testEquals_null() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n-      assertFalse(cache.equals(null));\n+      assertThat(cache.equals(null)).isFalse();\n     }\n   }\n \n@@ -138,11 +139,11 @@ public void testKeySet_clear() {\n   public void testKeySet_empty_remove() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       Set<Object> keys = cache.asMap().keySet();\n-      assertFalse(keys.remove(null));\n-      assertFalse(keys.remove(6));\n-      assertFalse(keys.remove(-6));\n-      assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(keys.remove(null)).isFalse();\n+      assertThat(keys.remove(6)).isFalse();\n+      assertThat(keys.remove(-6)).isFalse();\n+      assertThat(keys.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(keys.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(keys);\n       checkEmpty(cache);\n     }\n@@ -158,11 +159,11 @@ public void testKeySet_remove() {\n       // values of these removes, but the cache should be empty after the removes, regardless.\n       keys.remove(1);\n       keys.remove(2);\n-      assertFalse(keys.remove(null));\n-      assertFalse(keys.remove(6));\n-      assertFalse(keys.remove(-6));\n-      assertFalse(keys.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(keys.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(keys.remove(null)).isFalse();\n+      assertThat(keys.remove(6)).isFalse();\n+      assertThat(keys.remove(-6)).isFalse();\n+      assertThat(keys.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(keys.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(keys);\n       checkEmpty(cache);\n     }\n@@ -202,11 +203,11 @@ public void testValues_clear() {\n   public void testValues_empty_remove() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       Collection<Object> values = cache.asMap().values();\n-      assertFalse(values.remove(null));\n-      assertFalse(values.remove(6));\n-      assertFalse(values.remove(-6));\n-      assertFalse(values.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(values.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(values.remove(null)).isFalse();\n+      assertThat(values.remove(6)).isFalse();\n+      assertThat(values.remove(-6)).isFalse();\n+      assertThat(values.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(values.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(values);\n       checkEmpty(cache);\n     }\n@@ -222,11 +223,11 @@ public void testValues_remove() {\n       // values of these removes, but the cache should be empty after the removes, regardless.\n       values.remove(1);\n       values.remove(2);\n-      assertFalse(values.remove(null));\n-      assertFalse(values.remove(6));\n-      assertFalse(values.remove(-6));\n-      assertFalse(values.removeAll(asList(null, 0, 15, 1500)));\n-      assertFalse(values.retainAll(asList(null, 0, 15, 1500)));\n+      assertThat(values.remove(null)).isFalse();\n+      assertThat(values.remove(6)).isFalse();\n+      assertThat(values.remove(-6)).isFalse();\n+      assertThat(values.removeAll(asList(null, 0, 15, 1500))).isFalse();\n+      assertThat(values.retainAll(asList(null, 0, 15, 1500))).isFalse();\n       checkEmpty(values);\n       checkEmpty(cache);\n     }\n@@ -269,11 +270,11 @@ public void testEntrySet_clear() {\n   public void testEntrySet_empty_remove() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       Set<Entry<Object, Object>> entrySet = cache.asMap().entrySet();\n-      assertFalse(entrySet.remove(null));\n-      assertFalse(entrySet.remove(entryOf(6, 6)));\n-      assertFalse(entrySet.remove(entryOf(-6, -6)));\n-      assertFalse(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15))));\n-      assertFalse(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15))));\n+      assertThat(entrySet.remove(null)).isFalse();\n+      assertThat(entrySet.remove(entryOf(6, 6))).isFalse();\n+      assertThat(entrySet.remove(entryOf(-6, -6))).isFalse();\n+      assertThat(entrySet.removeAll(asList(null, entryOf(0, 0), entryOf(15, 15)))).isFalse();\n+      assertThat(entrySet.retainAll(asList(null, entryOf(0, 0), entryOf(15, 15)))).isFalse();\n       checkEmpty(entrySet);\n       checkEmpty(cache);\n     }\n@@ -289,11 +290,11 @@ public void testEntrySet_remove() {\n       // values of these removes, but the cache should be empty after the removes, regardless.\n       entrySet.remove(entryOf(1, 1));\n       entrySet.remove(entryOf(2, 2));\n-      assertFalse(entrySet.remove(null));\n-      assertFalse(entrySet.remove(entryOf(1, 1)));\n-      assertFalse(entrySet.remove(entryOf(6, 6)));\n-      assertFalse(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15))));\n-      assertFalse(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15))));\n+      assertThat(entrySet.remove(null)).isFalse();\n+      assertThat(entrySet.remove(entryOf(1, 1))).isFalse();\n+      assertThat(entrySet.remove(entryOf(6, 6))).isFalse();\n+      assertThat(entrySet.removeAll(asList(null, entryOf(1, 1), entryOf(15, 15)))).isFalse();\n+      assertThat(entrySet.retainAll(asList(null, entryOf(1, 1), entryOf(15, 15)))).isFalse();\n       checkEmpty(entrySet);\n       checkEmpty(cache);\n     }\ndiff --git a/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java b/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java\nindex 76de76c3707c..9eb3fe7e33c7 100644\n--- a/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java\n+++ b/guava-tests/test/com/google/common/cache/ForwardingCacheTest.java\n@@ -16,12 +16,14 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.errorprone.annotations.Keep;\n import java.util.concurrent.ExecutionException;\n import junit.framework.TestCase;\n import org.jspecify.annotations.NullUnmarked;\n@@ -56,15 +58,13 @@ protected Cache<String, Boolean> delegate() {\n   }\n \n   public void testGetIfPresent() throws ExecutionException {\n-    when(mock.getIfPresent(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.getIfPresent(\"key\"));\n+    when(mock.getIfPresent(\"key\")).thenReturn(true);\n+    assertThat(forward.getIfPresent(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testGetAllPresent() throws ExecutionException {\n-    when(mock.getAllPresent(ImmutableList.of(\"key\")))\n-        .thenReturn(ImmutableMap.of(\"key\", Boolean.TRUE));\n-    assertEquals(\n-        ImmutableMap.of(\"key\", Boolean.TRUE), forward.getAllPresent(ImmutableList.of(\"key\")));\n+    when(mock.getAllPresent(ImmutableList.of(\"key\"))).thenReturn(ImmutableMap.of(\"key\", true));\n+    assertThat(forward.getAllPresent(ImmutableList.of(\"key\"))).containsExactly(\"key\", true);\n   }\n \n   public void testInvalidate() {\n@@ -84,17 +84,17 @@ public void testInvalidateAll() {\n \n   public void testSize() {\n     when(mock.size()).thenReturn(0L);\n-    assertEquals(0, forward.size());\n+    assertThat(forward.size()).isEqualTo(0);\n   }\n \n   public void testStats() {\n     when(mock.stats()).thenReturn(null);\n-    assertNull(forward.stats());\n+    assertThat(forward.stats()).isNull();\n   }\n \n   public void testAsMap() {\n     when(mock.asMap()).thenReturn(null);\n-    assertNull(forward.asMap());\n+    assertThat(forward.asMap()).isNull();\n   }\n \n   public void testCleanUp() {\n@@ -103,6 +103,7 @@ public void testCleanUp() {\n   }\n \n   /** Make sure that all methods are forwarded. */\n+  @Keep\n   private static class OnlyGet<K, V> extends ForwardingCache<K, V> {\n     @Override\n     protected Cache<K, V> delegate() {\ndiff --git a/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java b/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java\nindex cdef91afe699..89029ab0ef67 100644\n--- a/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java\n+++ b/guava-tests/test/com/google/common/cache/ForwardingLoadingCacheTest.java\n@@ -16,12 +16,14 @@\n \n package com.google.common.cache;\n \n+import static com.google.common.truth.Truth.assertThat;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.errorprone.annotations.Keep;\n import java.util.concurrent.ExecutionException;\n import junit.framework.TestCase;\n import org.jspecify.annotations.NullUnmarked;\n@@ -56,23 +58,23 @@ protected LoadingCache<String, Boolean> delegate() {\n   }\n \n   public void testGet() throws ExecutionException {\n-    when(mock.get(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.get(\"key\"));\n+    when(mock.get(\"key\")).thenReturn(true);\n+    assertThat(forward.get(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testGetUnchecked() {\n-    when(mock.getUnchecked(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.getUnchecked(\"key\"));\n+    when(mock.getUnchecked(\"key\")).thenReturn(true);\n+    assertThat(forward.getUnchecked(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testGetAll() throws ExecutionException {\n-    when(mock.getAll(ImmutableList.of(\"key\"))).thenReturn(ImmutableMap.of(\"key\", Boolean.TRUE));\n-    assertEquals(ImmutableMap.of(\"key\", Boolean.TRUE), forward.getAll(ImmutableList.of(\"key\")));\n+    when(mock.getAll(ImmutableList.of(\"key\"))).thenReturn(ImmutableMap.of(\"key\", true));\n+    assertThat(forward.getAll(ImmutableList.of(\"key\"))).containsExactly(\"key\", true);\n   }\n \n   public void testApply() {\n-    when(mock.apply(\"key\")).thenReturn(Boolean.TRUE);\n-    assertSame(Boolean.TRUE, forward.apply(\"key\"));\n+    when(mock.apply(\"key\")).thenReturn(true);\n+    assertThat(forward.apply(\"key\")).isSameInstanceAs(true);\n   }\n \n   public void testInvalidate() {\n@@ -97,12 +99,12 @@ public void testSize() {\n \n   public void testStats() {\n     when(mock.stats()).thenReturn(null);\n-    assertNull(forward.stats());\n+    assertThat(forward.stats()).isNull();\n   }\n \n   public void testAsMap() {\n     when(mock.asMap()).thenReturn(null);\n-    assertNull(forward.asMap());\n+    assertThat(forward.asMap()).isNull();\n   }\n \n   public void testCleanUp() {\n@@ -111,6 +113,7 @@ public void testCleanUp() {\n   }\n \n   /** Make sure that all methods are forwarded. */\n+  @Keep\n   private static class OnlyGet<K, V> extends ForwardingLoadingCache<K, V> {\n     @Override\n     protected LoadingCache<K, V> delegate() {\ndiff --git a/guava-tests/test/com/google/common/cache/LocalCacheMapComputeTest.java b/guava-tests/test/com/google/common/cache/LocalCacheMapComputeTest.java\nindex 0ca0a13f746c..474aab6a13c7 100644\n--- a/guava-tests/test/com/google/common/cache/LocalCacheMapComputeTest.java\n+++ b/guava-tests/test/com/google/common/cache/LocalCacheMapComputeTest.java\n@@ -61,7 +61,7 @@ public void testComputeIfAbsent() {\n         n -> {\n           cache.asMap().computeIfAbsent(key, k -> \"value\" + n);\n         });\n-    assertEquals(1, cache.size());\n+    assertThat(cache.size()).isEqualTo(1);\n   }\n \n   public void testComputeIfAbsentEviction() {\n@@ -96,7 +96,7 @@ public void testComputeIfPresent() {\n         n -> {\n           cache.asMap().computeIfPresent(key, (k, v) -> v + delimiter + n);\n         });\n-    assertEquals(1, cache.size());\n+    assertThat(cache.size()).isEqualTo(1);\n     assertThat(cache.getIfPresent(key).split(delimiter)).hasLength(count + 1);\n   }\n \n@@ -161,7 +161,7 @@ public void testCompute() {\n         n -> {\n           cache.asMap().compute(key, (k, v) -> null);\n         });\n-    assertEquals(0, cache.size());\n+    assertThat(cache.size()).isEqualTo(0);\n   }\n \n   public void testComputeWithLoad() {\ndiff --git a/guava-tests/test/com/google/common/cache/LocalCacheTest.java b/guava-tests/test/com/google/common/cache/LocalCacheTest.java\nindex 789536226b48..9eed4e73b959 100644\n--- a/guava-tests/test/com/google/common/cache/LocalCacheTest.java\n+++ b/guava-tests/test/com/google/common/cache/LocalCacheTest.java\n@@ -27,6 +27,7 @@\n import static com.google.common.cache.TestingWeighers.constantWeigher;\n import static com.google.common.collect.Maps.immutableEntry;\n import static com.google.common.truth.Truth.assertThat;\n+import static com.google.common.truth.Truth.assertWithMessage;\n import static com.google.common.util.concurrent.MoreExecutors.listeningDecorator;\n import static java.lang.Math.max;\n import static java.lang.Thread.State.WAITING;\n@@ -247,18 +248,18 @@ public void tearDown() throws Exception {\n \n   private Throwable popLoggedThrowable() {\n     List<LogRecord> logRecords = logHandler.getStoredLogRecords();\n-    assertEquals(1, logRecords.size());\n+    assertThat(logRecords).hasSize(1);\n     LogRecord logRecord = logRecords.get(0);\n     logHandler.clear();\n     return logRecord.getThrown();\n   }\n \n   private void checkNothingLogged() {\n-    assertTrue(logHandler.getStoredLogRecords().isEmpty());\n+    assertThat(logHandler.getStoredLogRecords().isEmpty()).isTrue();\n   }\n \n   private void checkLogged(Throwable t) {\n-    assertSame(t, popLoggedThrowable());\n+    assertThat(popLoggedThrowable()).isSameInstanceAs(t);\n   }\n \n   /*\n@@ -288,33 +289,33 @@ private static CacheBuilder<Object, Object> createCacheBuilder() {\n   public void testDefaults() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n \n-    assertSame(Strength.STRONG, map.keyStrength);\n-    assertSame(Strength.STRONG, map.valueStrength);\n-    assertSame(map.keyStrength.defaultEquivalence(), map.keyEquivalence);\n-    assertSame(map.valueStrength.defaultEquivalence(), map.valueEquivalence);\n+    assertThat(map.keyStrength).isEqualTo(Strength.STRONG);\n+    assertThat(map.valueStrength).isEqualTo(Strength.STRONG);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(map.keyStrength.defaultEquivalence());\n+    assertThat(map.valueEquivalence).isSameInstanceAs(map.valueStrength.defaultEquivalence());\n \n-    assertEquals(0, map.expireAfterAccessNanos);\n-    assertEquals(0, map.expireAfterWriteNanos);\n-    assertEquals(0, map.refreshNanos);\n-    assertEquals(CacheBuilder.UNSET_INT, map.maxWeight);\n+    assertThat(map.expireAfterAccessNanos).isEqualTo(0);\n+    assertThat(map.expireAfterWriteNanos).isEqualTo(0);\n+    assertThat(map.refreshNanos).isEqualTo(0);\n+    assertThat(map.maxWeight).isEqualTo(CacheBuilder.UNSET_INT);\n \n-    assertSame(EntryFactory.STRONG, map.entryFactory);\n-    assertSame(CacheBuilder.NullListener.INSTANCE, map.removalListener);\n-    assertSame(DISCARDING_QUEUE, map.removalNotificationQueue);\n-    assertSame(NULL_TICKER, map.ticker);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);\n+    assertThat(map.removalListener).isSameInstanceAs(CacheBuilder.NullListener.INSTANCE);\n+    assertThat(map.removalNotificationQueue).isSameInstanceAs(DISCARDING_QUEUE);\n+    assertThat(map.ticker).isSameInstanceAs(NULL_TICKER);\n \n-    assertEquals(4, map.concurrencyLevel);\n+    assertThat(map.concurrencyLevel).isEqualTo(4);\n \n     // concurrency level\n     assertThat(map.segments).hasLength(4);\n     // initial capacity / concurrency level\n-    assertEquals(16 / map.segments.length, map.segments[0].table.length());\n+    assertThat(map.segments[0].table.length()).isEqualTo(16 / map.segments.length);\n \n-    assertFalse(map.evictsBySize());\n-    assertFalse(map.expires());\n-    assertFalse(map.expiresAfterWrite());\n-    assertFalse(map.expiresAfterAccess());\n-    assertFalse(map.refreshes());\n+    assertThat(map.evictsBySize()).isFalse();\n+    assertThat(map.expires()).isFalse();\n+    assertThat(map.expiresAfterWrite()).isFalse();\n+    assertThat(map.expiresAfterAccess()).isFalse();\n+    assertThat(map.refreshes()).isFalse();\n   }\n \n   public void testSetKeyEquivalence() {\n@@ -333,8 +334,8 @@ protected int doHash(Object t) {\n \n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().keyEquivalence(testEquivalence));\n-    assertSame(testEquivalence, map.keyEquivalence);\n-    assertSame(map.valueStrength.defaultEquivalence(), map.valueEquivalence);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(testEquivalence);\n+    assertThat(map.valueEquivalence).isSameInstanceAs(map.valueStrength.defaultEquivalence());\n   }\n \n   public void testSetValueEquivalence() {\n@@ -353,8 +354,8 @@ protected int doHash(Object t) {\n \n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().valueEquivalence(testEquivalence));\n-    assertSame(testEquivalence, map.valueEquivalence);\n-    assertSame(map.keyStrength.defaultEquivalence(), map.keyEquivalence);\n+    assertThat(map.valueEquivalence).isSameInstanceAs(testEquivalence);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(map.keyStrength.defaultEquivalence());\n   }\n \n   public void testSetConcurrencyLevel() {\n@@ -418,7 +419,7 @@ private static void checkInitialCapacity(\n                 .concurrencyLevel(concurrencyLevel)\n                 .initialCapacity(initialCapacity));\n     for (int i = 0; i < map.segments.length; i++) {\n-      assertEquals(segmentSize, map.segments[i].table.length());\n+      assertThat(map.segments[i].table.length()).isEqualTo(segmentSize);\n     }\n   }\n \n@@ -455,13 +456,15 @@ private static void checkMaximumSize(int concurrencyLevel, int initialCapacity,\n                 .initialCapacity(initialCapacity)\n                 .maximumSize(maxSize));\n     long totalCapacity = 0;\n-    assertTrue(\n-        \"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n-        map.segments.length <= max(1, maxSize / 10));\n+    assertWithMessage(\"segments=%s, maxSize=%s\", map.segments.length, maxSize)\n+        .that((long) map.segments.length)\n+        .isAtMost(max(1, maxSize / 10));\n     for (int i = 0; i < map.segments.length; i++) {\n       totalCapacity += map.segments[i].maxSegmentWeight;\n     }\n-    assertTrue(\"totalCapacity=\" + totalCapacity + \", maxSize=\" + maxSize, totalCapacity == maxSize);\n+    assertWithMessage(\"totalCapacity=%s, maxSize=%s\", totalCapacity, maxSize)\n+        .that(totalCapacity)\n+        .isEqualTo(maxSize);\n \n     map =\n         makeLocalCache(\n@@ -470,14 +473,16 @@ private static void checkMaximumSize(int concurrencyLevel, int initialCapacity,\n                 .initialCapacity(initialCapacity)\n                 .maximumWeight(maxSize)\n                 .weigher(constantWeigher(1)));\n-    assertTrue(\n-        \"segments=\" + map.segments.length + \", maxSize=\" + maxSize,\n-        map.segments.length <= max(1, maxSize / 10));\n+    assertWithMessage(\"segments=%s, maxSize=%s\", map.segments.length, maxSize)\n+        .that((long) map.segments.length)\n+        .isAtMost(max(1, maxSize / 10));\n     totalCapacity = 0;\n     for (int i = 0; i < map.segments.length; i++) {\n       totalCapacity += map.segments[i].maxSegmentWeight;\n     }\n-    assertTrue(\"totalCapacity=\" + totalCapacity + \", maxSize=\" + maxSize, totalCapacity == maxSize);\n+    assertWithMessage(\"totalCapacity=%s, maxSize=%s\", totalCapacity, maxSize)\n+        .that(totalCapacity)\n+        .isEqualTo(maxSize);\n   }\n \n   public void testSetWeigher() {\n@@ -490,33 +495,33 @@ public int weigh(Object key, Object value) {\n         };\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().maximumWeight(1).weigher(testWeigher));\n-    assertSame(testWeigher, map.weigher);\n+    assertThat(map.weigher).isSameInstanceAs(testWeigher);\n   }\n \n   public void testSetWeakKeys() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().weakKeys());\n     checkStrength(map, Strength.WEAK, Strength.STRONG);\n-    assertSame(EntryFactory.WEAK, map.entryFactory);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.WEAK);\n   }\n \n   public void testSetWeakValues() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().weakValues());\n     checkStrength(map, Strength.STRONG, Strength.WEAK);\n-    assertSame(EntryFactory.STRONG, map.entryFactory);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);\n   }\n \n   public void testSetSoftValues() {\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().softValues());\n     checkStrength(map, Strength.STRONG, Strength.SOFT);\n-    assertSame(EntryFactory.STRONG, map.entryFactory);\n+    assertThat(map.entryFactory).isSameInstanceAs(EntryFactory.STRONG);\n   }\n \n   private static void checkStrength(\n       LocalCache<Object, Object> map, Strength keyStrength, Strength valueStrength) {\n-    assertSame(keyStrength, map.keyStrength);\n-    assertSame(valueStrength, map.valueStrength);\n-    assertSame(keyStrength.defaultEquivalence(), map.keyEquivalence);\n-    assertSame(valueStrength.defaultEquivalence(), map.valueEquivalence);\n+    assertThat(map.keyStrength).isSameInstanceAs(keyStrength);\n+    assertThat(map.valueStrength).isSameInstanceAs(valueStrength);\n+    assertThat(map.keyEquivalence).isSameInstanceAs(keyStrength.defaultEquivalence());\n+    assertThat(map.valueEquivalence).isSameInstanceAs(valueStrength.defaultEquivalence());\n   }\n \n   public void testSetExpireAfterWrite() {\n@@ -524,7 +529,7 @@ public void testSetExpireAfterWrite() {\n     TimeUnit unit = SECONDS;\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().expireAfterWrite(duration, unit));\n-    assertEquals(unit.toNanos(duration), map.expireAfterWriteNanos);\n+    assertThat(map.expireAfterWriteNanos).isEqualTo(unit.toNanos(duration));\n   }\n \n   public void testSetExpireAfterAccess() {\n@@ -532,7 +537,7 @@ public void testSetExpireAfterAccess() {\n     TimeUnit unit = SECONDS;\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().expireAfterAccess(duration, unit));\n-    assertEquals(unit.toNanos(duration), map.expireAfterAccessNanos);\n+    assertThat(map.expireAfterAccessNanos).isEqualTo(unit.toNanos(duration));\n   }\n \n   public void testSetRefresh() {\n@@ -540,7 +545,7 @@ public void testSetRefresh() {\n     TimeUnit unit = SECONDS;\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().refreshAfterWrite(duration, unit));\n-    assertEquals(unit.toNanos(duration), map.refreshNanos);\n+    assertThat(map.refreshNanos).isEqualTo(unit.toNanos(duration));\n   }\n \n   public void testLongAsyncRefresh() throws Exception {\n@@ -599,7 +604,7 @@ public void testSetRemovalListener() {\n     RemovalListener<Object, Object> testListener = TestingRemovalListeners.nullRemovalListener();\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().removalListener(testListener));\n-    assertSame(testListener, map.removalListener);\n+    assertThat(map.removalListener).isSameInstanceAs(testListener);\n   }\n \n   public void testSetTicker() {\n@@ -611,19 +616,26 @@ public long read() {\n           }\n         };\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().ticker(testTicker));\n-    assertSame(testTicker, map.ticker);\n+    assertThat(map.ticker).isSameInstanceAs(testTicker);\n   }\n \n   public void testEntryFactory() {\n-    assertSame(EntryFactory.STRONG, EntryFactory.getFactory(Strength.STRONG, false, false));\n-    assertSame(EntryFactory.STRONG_ACCESS, EntryFactory.getFactory(Strength.STRONG, true, false));\n-    assertSame(EntryFactory.STRONG_WRITE, EntryFactory.getFactory(Strength.STRONG, false, true));\n-    assertSame(\n-        EntryFactory.STRONG_ACCESS_WRITE, EntryFactory.getFactory(Strength.STRONG, true, true));\n-    assertSame(EntryFactory.WEAK, EntryFactory.getFactory(Strength.WEAK, false, false));\n-    assertSame(EntryFactory.WEAK_ACCESS, EntryFactory.getFactory(Strength.WEAK, true, false));\n-    assertSame(EntryFactory.WEAK_WRITE, EntryFactory.getFactory(Strength.WEAK, false, true));\n-    assertSame(EntryFactory.WEAK_ACCESS_WRITE, EntryFactory.getFactory(Strength.WEAK, true, true));\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, false, false))\n+        .isSameInstanceAs(EntryFactory.STRONG);\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, true, false))\n+        .isSameInstanceAs(EntryFactory.STRONG_ACCESS);\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, false, true))\n+        .isSameInstanceAs(EntryFactory.STRONG_WRITE);\n+    assertThat(EntryFactory.getFactory(Strength.STRONG, true, true))\n+        .isSameInstanceAs(EntryFactory.STRONG_ACCESS_WRITE);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, false, false))\n+        .isSameInstanceAs(EntryFactory.WEAK);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, true, false))\n+        .isSameInstanceAs(EntryFactory.WEAK_ACCESS);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, false, true))\n+        .isSameInstanceAs(EntryFactory.WEAK_WRITE);\n+    assertThat(EntryFactory.getFactory(Strength.WEAK, true, true))\n+        .isSameInstanceAs(EntryFactory.WEAK_ACCESS_WRITE);\n   }\n \n   // computation tests\n@@ -631,13 +643,13 @@ public void testEntryFactory() {\n   public void testCompute() throws ExecutionException {\n     CountingLoader loader = new CountingLoader();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     Object value = map.get(key, loader);\n-    assertEquals(1, loader.getCount());\n-    assertEquals(value, map.get(key, loader));\n-    assertEquals(1, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(1);\n+    assertThat(map.get(key, loader)).isEqualTo(value);\n+    assertThat(loader.getCount()).isEqualTo(1);\n   }\n \n   public void testRecordReadOnCompute() throws ExecutionException {\n@@ -659,7 +671,7 @@ public void testRecordReadOnCompute() throws ExecutionException {\n \n       checkEvictionQueues(map, segment, readOrder, writeOrder);\n       checkExpirationTimes(map);\n-      assertTrue(segment.recencyQueue.isEmpty());\n+      assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n       // access some of the elements\n       Random random = new Random();\n@@ -671,7 +683,7 @@ public void testRecordReadOnCompute() throws ExecutionException {\n           map.get(entry.getKey(), loader);\n           reads.add(entry);\n           i.remove();\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n       }\n       int undrainedIndex = reads.size() - segment.recencyQueue.size();\n@@ -686,14 +698,14 @@ public void testRecordReadOnCompute() throws ExecutionException {\n   public void testComputeExistingEntry() throws ExecutionException {\n     CountingLoader loader = new CountingLoader();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder());\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     Object value = new Object();\n     map.put(key, value);\n \n-    assertEquals(value, map.get(key, loader));\n-    assertEquals(0, loader.getCount());\n+    assertThat(map.get(key, loader)).isEqualTo(value);\n+    assertThat(loader.getCount()).isEqualTo(0);\n   }\n \n   public void testComputePartiallyCollectedKey() throws ExecutionException {\n@@ -702,7 +714,7 @@ public void testComputePartiallyCollectedKey() throws ExecutionException {\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     int hash = map.hash(key);\n@@ -715,14 +727,14 @@ public void testComputePartiallyCollectedKey() throws ExecutionException {\n     table.set(index, entry);\n     segment.count++;\n \n-    assertSame(value, map.get(key, loader));\n-    assertEquals(0, loader.getCount());\n-    assertEquals(1, segment.count);\n+    assertThat(map.get(key, loader)).isSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(1);\n \n     entry.clearKey();\n-    assertNotSame(value, map.get(key, loader));\n-    assertEquals(1, loader.getCount());\n-    assertEquals(2, segment.count);\n+    assertThat(map.get(key, loader)).isNotSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(1);\n+    assertThat(segment.count).isEqualTo(2);\n   }\n \n   public void testComputePartiallyCollectedValue() throws ExecutionException {\n@@ -731,7 +743,7 @@ public void testComputePartiallyCollectedValue() throws ExecutionException {\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     int hash = map.hash(key);\n@@ -744,14 +756,14 @@ public void testComputePartiallyCollectedValue() throws ExecutionException {\n     table.set(index, entry);\n     segment.count++;\n \n-    assertSame(value, map.get(key, loader));\n-    assertEquals(0, loader.getCount());\n-    assertEquals(1, segment.count);\n+    assertThat(map.get(key, loader)).isSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(1);\n \n     valueRef.clear();\n-    assertNotSame(value, map.get(key, loader));\n-    assertEquals(1, loader.getCount());\n-    assertEquals(1, segment.count);\n+    assertThat(map.get(key, loader)).isNotSameInstanceAs(value);\n+    assertThat(loader.getCount()).isEqualTo(1);\n+    assertThat(segment.count).isEqualTo(1);\n   }\n \n   @AndroidIncompatible // Perhaps emulator clock does not update between the two get() calls?\n@@ -759,15 +771,15 @@ public void testComputeExpiredEntry() throws ExecutionException {\n     CacheBuilder<Object, Object> builder = createCacheBuilder().expireAfterWrite(1, NANOSECONDS);\n     CountingLoader loader = new CountingLoader();\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n-    assertEquals(0, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(0);\n \n     Object key = new Object();\n     Object one = map.get(key, loader);\n-    assertEquals(1, loader.getCount());\n+    assertThat(loader.getCount()).isEqualTo(1);\n \n     Object two = map.get(key, loader);\n-    assertNotSame(one, two);\n-    assertEquals(2, loader.getCount());\n+    assertThat(two).isNotSameInstanceAs(one);\n+    assertThat(loader.getCount()).isEqualTo(2);\n   }\n \n   public void testValues() {\n@@ -775,9 +787,9 @@ public void testValues() {\n     map.put(\"foo\", \"bar\");\n     map.put(\"baz\", \"bar\");\n     map.put(\"quux\", \"quux\");\n-    assertFalse(map.values() instanceof Set);\n-    assertTrue(map.values().removeAll(ImmutableSet.of(\"bar\")));\n-    assertEquals(1, map.size());\n+    assertThat(map.values() instanceof Set).isFalse();\n+    assertThat(map.values().removeAll(ImmutableSet.of(\"bar\"))).isTrue();\n+    assertThat(map).hasSize(1);\n   }\n \n   public void testComputeIfAbsent_removalListener() {\n@@ -793,7 +805,7 @@ public void onRemoval(RemovalNotification<Object, Object> notification) {\n         CacheBuilder.newBuilder().removalListener(removalListener).build();\n     cache.put(\"a\", \"b\");\n     cache.asMap().computeIfAbsent(\"a\", k -> \"c\");\n-    assertTrue(notifications.toString(), notifications.isEmpty());\n+    assertThat(notifications).isEmpty();\n   }\n \n   public void testCopyEntry_computing() {\n@@ -818,7 +830,7 @@ public Object load(Object key) throws Exception {\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     int hash = map.hash(one);\n@@ -861,7 +873,7 @@ public void run() {\n     @SuppressWarnings(\"unchecked\")\n     LoadingValueReference<Object, Object> valueReference =\n         (LoadingValueReference) newEntry.getValueReference();\n-    assertFalse(valueReference.futureValue.isDone());\n+    assertThat(valueReference.futureValue.isDone()).isFalse();\n     startSignal.countDown();\n \n     try {\n@@ -871,10 +883,10 @@ public void run() {\n     }\n \n     map.cleanUp(); // force notifications\n-    assertTrue(listener.isEmpty());\n-    assertTrue(map.containsKey(one));\n-    assertEquals(1, map.size());\n-    assertSame(computedObject, map.get(one));\n+    assertThat(listener.isEmpty()).isTrue();\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map).hasSize(1);\n+    assertThat(map.get(one)).isSameInstanceAs(computedObject);\n   }\n \n   public void testRemovalListenerCheckedException() {\n@@ -916,7 +928,7 @@ public Object load(Object key) throws Exception {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     CacheBuilder<Object, Object> builder = createCacheBuilder().removalListener(listener);\n     LocalCache<Object, Object> map = makeLocalCache(builder);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -940,7 +952,7 @@ public void run() {\n     }\n \n     map.put(one, two);\n-    assertSame(two, map.get(one));\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n     startSignal.countDown();\n \n     try {\n@@ -951,7 +963,7 @@ public void run() {\n \n     map.cleanUp(); // force notifications\n     assertNotified(listener, one, computedObject, RemovalCause.REPLACED);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testSegmentRefresh_duplicate() throws ExecutionException {\n@@ -977,7 +989,7 @@ public void testSegmentRefresh_duplicate() throws ExecutionException {\n   public void testRemovalListener_explicit() {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1012,13 +1024,13 @@ public void testRemovalListener_explicit() {\n     i.remove();\n     assertNotified(listener, five, six, RemovalCause.EXPLICIT);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testRemovalListener_replaced() {\n     QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();\n     LocalCache<Object, Object> map = makeLocalCache(createCacheBuilder().removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1048,7 +1060,7 @@ public void testRemovalListener_collected() {\n         makeLocalCache(\n             createCacheBuilder().concurrencyLevel(1).softValues().removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1056,14 +1068,14 @@ public void testRemovalListener_collected() {\n \n     map.put(one, two);\n     map.put(two, three);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     int hash = map.hash(one);\n     ReferenceEntry<Object, Object> entry = segment.getEntry(one, hash);\n     map.reclaimValue(entry.getValueReference());\n     assertNotified(listener, one, two, RemovalCause.COLLECTED);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testRemovalListener_expired() {\n@@ -1076,7 +1088,7 @@ public void testRemovalListener_expired() {\n                 .expireAfterWrite(3, NANOSECONDS)\n                 .ticker(ticker)\n                 .removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1089,12 +1101,12 @@ public void testRemovalListener_expired() {\n     map.put(two, three);\n     ticker.advance(1);\n     map.put(three, four);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     ticker.advance(1);\n     map.put(four, five);\n     assertNotified(listener, one, two, RemovalCause.EXPIRED);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testRemovalListener_size() {\n@@ -1102,7 +1114,7 @@ public void testRemovalListener_size() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(\n             createCacheBuilder().concurrencyLevel(1).maximumSize(2).removalListener(listener));\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -1111,19 +1123,19 @@ public void testRemovalListener_size() {\n \n     map.put(one, two);\n     map.put(two, three);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     map.put(three, four);\n     assertNotified(listener, one, two, RemovalCause.SIZE);\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   static <K, V> void assertNotified(\n       QueuingRemovalListener<K, V> listener, K key, V value, RemovalCause cause) {\n     RemovalNotification<K, V> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(value, notification.getValue());\n-    assertSame(cause, notification.getCause());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(value);\n+    assertThat(notification.getCause()).isSameInstanceAs(cause);\n   }\n \n   // Segment core tests\n@@ -1137,26 +1149,26 @@ public void testNewEntry() {\n       int hashOne = map.hash(keyOne);\n       ReferenceEntry<Object, Object> entryOne = map.newEntry(keyOne, hashOne, null);\n       ValueReference<Object, Object> valueRefOne = map.newValueReference(entryOne, valueOne, 1);\n-      assertSame(valueOne, valueRefOne.get());\n+      assertThat(valueRefOne.get()).isSameInstanceAs(valueOne);\n       entryOne.setValueReference(valueRefOne);\n \n-      assertSame(keyOne, entryOne.getKey());\n-      assertEquals(hashOne, entryOne.getHash());\n-      assertNull(entryOne.getNext());\n-      assertSame(valueRefOne, entryOne.getValueReference());\n+      assertThat(entryOne.getKey()).isSameInstanceAs(keyOne);\n+      assertThat(entryOne.getHash()).isEqualTo(hashOne);\n+      assertThat(entryOne.getNext()).isNull();\n+      assertThat(entryOne.getValueReference()).isSameInstanceAs(valueRefOne);\n \n       Object keyTwo = new Object();\n       Object valueTwo = new Object();\n       int hashTwo = map.hash(keyTwo);\n       ReferenceEntry<Object, Object> entryTwo = map.newEntry(keyTwo, hashTwo, entryOne);\n       ValueReference<Object, Object> valueRefTwo = map.newValueReference(entryTwo, valueTwo, 1);\n-      assertSame(valueTwo, valueRefTwo.get());\n+      assertThat(valueRefTwo.get()).isSameInstanceAs(valueTwo);\n       entryTwo.setValueReference(valueRefTwo);\n \n-      assertSame(keyTwo, entryTwo.getKey());\n-      assertEquals(hashTwo, entryTwo.getHash());\n-      assertSame(entryOne, entryTwo.getNext());\n-      assertSame(valueRefTwo, entryTwo.getValueReference());\n+      assertThat(entryTwo.getKey()).isSameInstanceAs(keyTwo);\n+      assertThat(entryTwo.getHash()).isEqualTo(hashTwo);\n+      assertThat(entryTwo.getNext()).isSameInstanceAs(entryOne);\n+      assertThat(entryTwo.getValueReference()).isSameInstanceAs(valueRefTwo);\n     }\n   }\n \n@@ -1184,17 +1196,17 @@ public void testCopyEntry() {\n       assertConnected(map, entryOne, entryTwo);\n \n       ReferenceEntry<Object, Object> copyOne = map.copyEntry(entryOne, null);\n-      assertSame(keyOne, entryOne.getKey());\n-      assertEquals(hashOne, entryOne.getHash());\n-      assertNull(entryOne.getNext());\n-      assertSame(valueOne, copyOne.getValueReference().get());\n+      assertThat(entryOne.getKey()).isSameInstanceAs(keyOne);\n+      assertThat(entryOne.getHash()).isEqualTo(hashOne);\n+      assertThat(entryOne.getNext()).isNull();\n+      assertThat(copyOne.getValueReference().get()).isSameInstanceAs(valueOne);\n       assertConnected(map, copyOne, entryTwo);\n \n       ReferenceEntry<Object, Object> copyTwo = map.copyEntry(entryTwo, copyOne);\n-      assertSame(keyTwo, copyTwo.getKey());\n-      assertEquals(hashTwo, copyTwo.getHash());\n-      assertSame(copyOne, copyTwo.getNext());\n-      assertSame(valueTwo, copyTwo.getValueReference().get());\n+      assertThat(copyTwo.getKey()).isSameInstanceAs(keyTwo);\n+      assertThat(copyTwo.getHash()).isEqualTo(hashTwo);\n+      assertThat(copyTwo.getNext()).isSameInstanceAs(copyOne);\n+      assertThat(copyTwo.getValueReference().get()).isSameInstanceAs(valueTwo);\n       assertConnected(map, copyOne, copyTwo);\n     }\n   }\n@@ -1202,10 +1214,10 @@ public void testCopyEntry() {\n   private static <K, V> void assertConnected(\n       LocalCache<K, V> map, ReferenceEntry<K, V> one, ReferenceEntry<K, V> two) {\n     if (map.usesWriteQueue()) {\n-      assertSame(two, one.getNextInWriteQueue());\n+      assertThat(one.getNextInWriteQueue()).isSameInstanceAs(two);\n     }\n     if (map.usesAccessQueue()) {\n-      assertSame(two, one.getNextInAccessQueue());\n+      assertThat(one.getNextInAccessQueue()).isSameInstanceAs(two);\n     }\n   }\n \n@@ -1235,14 +1247,14 @@ public void testSegmentGetAndContains() {\n     // count == 0\n     table.set(index, entry);\n     assertNull(segment.get(key, hash));\n-    assertFalse(segment.containsKey(key, hash));\n-    assertFalse(segment.containsValue(value));\n+    assertThat(segment.containsKey(key, hash)).isFalse();\n+    assertThat(segment.containsValue(value)).isFalse();\n \n     // count == 1\n     segment.count++;\n-    assertSame(value, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n     // don't see absent values now that count > 0\n     assertNull(segment.get(new Object(), hash));\n \n@@ -1253,10 +1265,10 @@ public void testSegmentGetAndContains() {\n     nullEntry.setValueReference(nullValueRef);\n     table.set(index, nullEntry);\n     // skip the null key\n-    assertSame(value, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertFalse(segment.containsValue(nullValue));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(nullValue)).isFalse();\n \n     // hash collision\n     DummyEntry<Object, Object> dummy = DummyEntry.create(new Object(), hash, entry);\n@@ -1264,10 +1276,10 @@ public void testSegmentGetAndContains() {\n     ValueReference<Object, Object> dummyValueRef = map.newValueReference(dummy, dummyValue, 1);\n     dummy.setValueReference(dummyValueRef);\n     table.set(index, dummy);\n-    assertSame(value, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertTrue(segment.containsValue(dummyValue));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(dummyValue)).isTrue();\n \n     // key collision\n     dummy = DummyEntry.create(key, hash, entry);\n@@ -1276,17 +1288,17 @@ public void testSegmentGetAndContains() {\n     dummy.setValueReference(dummyValueRef);\n     table.set(index, dummy);\n     // returns the most recent entry\n-    assertSame(dummyValue, segment.get(key, hash));\n-    assertTrue(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertTrue(segment.containsValue(dummyValue));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(dummyValue);\n+    assertThat(segment.containsKey(key, hash)).isTrue();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(dummyValue)).isTrue();\n \n     // expired\n     dummy.setAccessTime(ticker.read() - 2);\n     assertNull(segment.get(key, hash));\n-    assertFalse(segment.containsKey(key, hash));\n-    assertTrue(segment.containsValue(value));\n-    assertFalse(segment.containsValue(dummyValue));\n+    assertThat(segment.containsKey(key, hash)).isFalse();\n+    assertThat(segment.containsValue(value)).isTrue();\n+    assertThat(segment.containsValue(dummyValue)).isFalse();\n   }\n \n   public void testSegmentReplaceValue() {\n@@ -1307,29 +1319,29 @@ public void testSegmentReplaceValue() {\n     entry.setValueReference(oldValueRef);\n \n     // no entry\n-    assertFalse(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same value\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertTrue(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isTrue();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // different value\n-    assertFalse(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // cleared\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n-    assertFalse(segment.replace(key, hash, oldValue, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.replace(key, hash, oldValue, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1352,23 +1364,23 @@ public void testSegmentReplace() {\n \n     // no entry\n     assertNull(segment.replace(key, hash, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same key\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertSame(oldValue, segment.replace(key, hash, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.replace(key, hash, newValue)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // cleared\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.replace(key, hash, newValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1384,24 +1396,24 @@ public void testSegmentPut() {\n     Object newValue = new Object();\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.put(key, hash, oldValue, false));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n \n     // same key\n-    assertSame(oldValue, segment.put(key, hash, newValue, false));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.put(key, hash, newValue, false)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n \n     // cleared\n     ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);\n     DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.put(key, hash, newValue, false));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n   }\n \n   public void testSegmentPutIfAbsent() {\n@@ -1416,31 +1428,31 @@ public void testSegmentPutIfAbsent() {\n     Object newValue = new Object();\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.put(key, hash, oldValue, true));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n \n     // same key\n-    assertSame(oldValue, segment.put(key, hash, newValue, true));\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.put(key, hash, newValue, true)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n \n     // cleared\n     ReferenceEntry<Object, Object> entry = segment.getEntry(key, hash);\n     DummyValueReference<Object, Object> oldValueRef = DummyValueReference.create(oldValue);\n     entry.setValueReference(oldValueRef);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.put(key, hash, newValue, true));\n-    assertEquals(1, segment.count);\n-    assertSame(newValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(newValue);\n   }\n \n   public void testSegmentPut_expand() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertEquals(1, segment.table.length());\n+    assertThat(segment.table.length()).isEqualTo(1);\n \n     int count = 1024;\n     for (int i = 0; i < count; i++) {\n@@ -1448,7 +1460,7 @@ public void testSegmentPut_expand() {\n       Object value = new Object();\n       int hash = map.hash(key);\n       assertNull(segment.put(key, hash, value, false));\n-      assertTrue(segment.table.length() > i);\n+      assertThat(segment.table.length()).isGreaterThan(i);\n     }\n   }\n \n@@ -1470,7 +1482,7 @@ public void testSegmentPut_evict() {\n         it.next();\n         it.remove();\n       }\n-      assertEquals(originalMap, map);\n+      assertThat(map).isEqualTo(originalMap);\n     }\n   }\n \n@@ -1491,34 +1503,34 @@ public void testSegmentStoreComputedValue() {\n \n     // absent\n     Object value = new Object();\n-    assertTrue(listener.isEmpty());\n-    assertEquals(0, segment.count);\n+    assertThat(listener.isEmpty()).isTrue();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value));\n-    assertSame(value, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n-    assertTrue(listener.isEmpty());\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // clobbered\n     Object value2 = new Object();\n-    assertFalse(segment.storeLoadedValue(key, hash, valueRef, value2));\n-    assertEquals(1, segment.count);\n-    assertSame(value, segment.get(key, hash));\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value2)).isFalse();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertEquals(immutableEntry(key, value2), notification);\n-    assertEquals(RemovalCause.REPLACED, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification).isEqualTo(immutableEntry(key, value2));\n+    assertThat(notification.getCause()).isEqualTo(RemovalCause.REPLACED);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // inactive\n     Object value3 = new Object();\n     map.clear();\n     listener.clear();\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     table.set(index, entry);\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value3));\n-    assertSame(value3, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n-    assertTrue(listener.isEmpty());\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value3)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // replaced\n     Object value4 = new Object();\n@@ -1526,29 +1538,29 @@ public void testSegmentStoreComputedValue() {\n     valueRef = new LoadingValueReference<>(value3Ref);\n     entry.setValueReference(valueRef);\n     table.set(index, entry);\n-    assertSame(value3, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));\n-    assertSame(value4, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value4)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value4);\n+    assertThat(segment.count).isEqualTo(1);\n     notification = listener.remove();\n-    assertEquals(immutableEntry(key, value3), notification);\n-    assertEquals(RemovalCause.REPLACED, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification).isEqualTo(immutableEntry(key, value3));\n+    assertThat(notification.getCause()).isEqualTo(RemovalCause.REPLACED);\n+    assertThat(listener.isEmpty()).isTrue();\n \n     // collected\n     entry.setValueReference(valueRef);\n     table.set(index, entry);\n-    assertSame(value3, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value3);\n+    assertThat(segment.count).isEqualTo(1);\n     value3Ref.clear();\n-    assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));\n-    assertSame(value4, segment.get(key, hash));\n-    assertEquals(1, segment.count);\n+    assertThat(segment.storeLoadedValue(key, hash, valueRef, value4)).isTrue();\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value4);\n+    assertThat(segment.count).isEqualTo(1);\n     notification = listener.remove();\n-    assertEquals(immutableEntry(key, null), notification);\n-    assertEquals(RemovalCause.COLLECTED, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification).isEqualTo(immutableEntry(key, null));\n+    assertThat(notification.getCause()).isEqualTo(RemovalCause.COLLECTED);\n+    assertThat(listener.isEmpty()).isTrue();\n   }\n \n   public void testSegmentRemove() {\n@@ -1566,27 +1578,27 @@ public void testSegmentRemove() {\n     entry.setValueReference(oldValueRef);\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same key\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertSame(oldValue, segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.remove(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n \n     // cleared\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n     assertNull(segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1606,33 +1618,33 @@ public void testSegmentRemoveValue() {\n     entry.setValueReference(oldValueRef);\n \n     // no entry\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.remove(key, hash));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(0);\n \n     // same value\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertTrue(segment.remove(key, hash, oldValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.remove(key, hash, oldValue)).isTrue();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n \n     // different value\n     table.set(index, entry);\n     segment.count++;\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n-    assertFalse(segment.remove(key, hash, newValue));\n-    assertEquals(1, segment.count);\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n+    assertThat(segment.remove(key, hash, newValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(1);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n \n     // cleared\n-    assertSame(oldValue, segment.get(key, hash));\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(oldValue);\n     oldValueRef.clear();\n-    assertFalse(segment.remove(key, hash, oldValue));\n-    assertEquals(0, segment.count);\n+    assertThat(segment.remove(key, hash, oldValue)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n     assertNull(segment.get(key, hash));\n   }\n \n@@ -1640,7 +1652,7 @@ public void testExpand() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertEquals(1, segment.table.length());\n+    assertThat(segment.table.length()).isEqualTo(1);\n \n     // manually add elements to avoid expansion\n     int originalCount = 1024;\n@@ -1657,17 +1669,17 @@ public void testExpand() {\n     segment.table.set(0, entry);\n     segment.count = originalCount;\n     ImmutableMap<Object, Object> originalMap = ImmutableMap.copyOf(map);\n-    assertEquals(originalCount, originalMap.size());\n-    assertEquals(originalMap, map);\n+    assertThat(originalMap).hasSize(originalCount);\n+    assertThat(map).isEqualTo(originalMap);\n \n     for (int i = 1; i <= originalCount * 2; i *= 2) {\n       if (i > 1) {\n         segment.expand();\n       }\n-      assertEquals(i, segment.table.length());\n-      assertEquals(originalCount, countLiveEntries(map, 0));\n-      assertEquals(originalCount, segment.count);\n-      assertEquals(originalMap, map);\n+      assertThat(segment.table.length()).isEqualTo(i);\n+      assertThat(countLiveEntries(map, 0)).isEqualTo(originalCount);\n+      assertThat(segment.count).isEqualTo(originalCount);\n+      assertThat(map).isEqualTo(originalMap);\n     }\n   }\n \n@@ -1676,7 +1688,7 @@ public void testGetCausesExpansion() throws ExecutionException {\n       LocalCache<Object, Object> map =\n           makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n       Segment<Object, Object> segment = map.segments[0];\n-      assertEquals(1, segment.table.length());\n+      assertThat(segment.table.length()).isEqualTo(1);\n \n       for (int i = 0; i < count; i++) {\n         Object key = new Object();\n@@ -1691,10 +1703,10 @@ public Object load(Object key) {\n               }\n             });\n       }\n-      assertEquals(count, segment.count);\n-      assertTrue(count <= segment.threshold);\n-      assertTrue(count <= (segment.table.length() * 3 / 4));\n-      assertTrue(count > (segment.table.length() * 3 / 8));\n+      assertThat(segment.count).isEqualTo(count);\n+      assertThat(count).isAtMost(segment.threshold);\n+      assertThat(count).isAtMost((segment.table.length() * 3 / 4));\n+      assertThat(count).isGreaterThan(segment.table.length() * 3 / 8);\n     }\n   }\n \n@@ -1702,8 +1714,8 @@ public void testGetOrDefault() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     map.put(1, 1);\n-    assertEquals(1, map.getOrDefault(1, 2));\n-    assertEquals(2, map.getOrDefault(2, 2));\n+    assertThat(map.getOrDefault(1, 2)).isEqualTo(1);\n+    assertThat(map.getOrDefault(2, 2)).isEqualTo(2);\n   }\n \n   public void testPutCausesExpansion() {\n@@ -1711,17 +1723,17 @@ public void testPutCausesExpansion() {\n       LocalCache<Object, Object> map =\n           makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n       Segment<Object, Object> segment = map.segments[0];\n-      assertEquals(1, segment.table.length());\n+      assertThat(segment.table.length()).isEqualTo(1);\n \n       for (int i = 0; i < count; i++) {\n         Object key = new Object();\n         Object value = new Object();\n         segment.put(key, key.hashCode(), value, true);\n       }\n-      assertEquals(count, segment.count);\n-      assertTrue(count <= segment.threshold);\n-      assertTrue(count <= (segment.table.length() * 3 / 4));\n-      assertTrue(count > (segment.table.length() * 3 / 8));\n+      assertThat(segment.count).isEqualTo(count);\n+      assertThat(count).isAtMost(segment.threshold);\n+      assertThat(count).isAtMost((segment.table.length() * 3 / 4));\n+      assertThat(count).isGreaterThan(segment.table.length() * 3 / 8);\n     }\n   }\n \n@@ -1737,7 +1749,7 @@ public void testReclaimKey() {\n                 .removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     // create 3 objects and chain them together\n     Object keyOne = new Object();\n@@ -1755,28 +1767,28 @@ public void testReclaimKey() {\n         createDummyEntry(keyThree, hashThree, valueThree, entryTwo);\n \n     // absent\n-    assertEquals(0, listener.getCount());\n-    assertFalse(segment.reclaimKey(entryOne, hashOne));\n-    assertEquals(0, listener.getCount());\n+    assertThat(listener.getCount()).isEqualTo(0);\n+    assertThat(segment.reclaimKey(entryOne, hashOne)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(0);\n     table.set(0, entryOne);\n-    assertFalse(segment.reclaimKey(entryTwo, hashTwo));\n-    assertEquals(0, listener.getCount());\n+    assertThat(segment.reclaimKey(entryTwo, hashTwo)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(0);\n     table.set(0, entryTwo);\n-    assertFalse(segment.reclaimKey(entryThree, hashThree));\n-    assertEquals(0, listener.getCount());\n+    assertThat(segment.reclaimKey(entryThree, hashThree)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(0);\n \n     // present\n     table.set(0, entryOne);\n     segment.count = 1;\n-    assertTrue(segment.reclaimKey(entryOne, hashOne));\n-    assertEquals(1, listener.getCount());\n-    assertSame(keyOne, listener.getLastEvictedKey());\n-    assertSame(valueOne, listener.getLastEvictedValue());\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertFalse(segment.accessQueue.contains(entryOne));\n-    assertFalse(segment.writeQueue.contains(entryOne));\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(segment.reclaimKey(entryOne, hashOne)).isTrue();\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(keyOne);\n+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(valueOne);\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.accessQueue.contains(entryOne)).isFalse();\n+    assertThat(segment.writeQueue.contains(entryOne)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n   }\n \n   public void testRemoveEntryFromChain() {\n@@ -1802,32 +1814,32 @@ public void testRemoveEntryFromChain() {\n     assertNull(segment.removeEntryFromChain(entryOne, entryOne));\n \n     // head\n-    assertSame(entryOne, segment.removeEntryFromChain(entryTwo, entryTwo));\n+    assertThat(segment.removeEntryFromChain(entryTwo, entryTwo)).isSameInstanceAs(entryOne);\n \n     // middle\n     ReferenceEntry<Object, Object> newFirst = segment.removeEntryFromChain(entryThree, entryTwo);\n-    assertSame(keyThree, newFirst.getKey());\n-    assertSame(valueThree, newFirst.getValueReference().get());\n-    assertEquals(hashThree, newFirst.getHash());\n-    assertSame(entryOne, newFirst.getNext());\n+    assertThat(newFirst.getKey()).isSameInstanceAs(keyThree);\n+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueThree);\n+    assertThat(newFirst.getHash()).isEqualTo(hashThree);\n+    assertThat(newFirst.getNext()).isSameInstanceAs(entryOne);\n \n     // tail (remaining entries are copied in reverse order)\n     newFirst = segment.removeEntryFromChain(entryThree, entryOne);\n-    assertSame(keyTwo, newFirst.getKey());\n-    assertSame(valueTwo, newFirst.getValueReference().get());\n-    assertEquals(hashTwo, newFirst.getHash());\n+    assertThat(newFirst.getKey()).isSameInstanceAs(keyTwo);\n+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueTwo);\n+    assertThat(newFirst.getHash()).isEqualTo(hashTwo);\n     newFirst = newFirst.getNext();\n-    assertSame(keyThree, newFirst.getKey());\n-    assertSame(valueThree, newFirst.getValueReference().get());\n-    assertEquals(hashThree, newFirst.getHash());\n-    assertNull(newFirst.getNext());\n+    assertThat(newFirst.getKey()).isSameInstanceAs(keyThree);\n+    assertThat(newFirst.getValueReference().get()).isSameInstanceAs(valueThree);\n+    assertThat(newFirst.getHash()).isEqualTo(hashThree);\n+    assertThat(newFirst.getNext()).isNull();\n   }\n \n   public void testExpand_cleanup() {\n     LocalCache<Object, Object> map =\n         makeLocalCache(createCacheBuilder().concurrencyLevel(1).initialCapacity(1));\n     Segment<Object, Object> segment = map.segments[0];\n-    assertEquals(1, segment.table.length());\n+    assertThat(segment.table.length()).isEqualTo(1);\n \n     // manually add elements to avoid expansion\n     // 1/3 null keys, 1/3 null values\n@@ -1848,22 +1860,22 @@ public void testExpand_cleanup() {\n     segment.table.set(0, entry);\n     segment.count = originalCount;\n     int liveCount = originalCount / 3;\n-    assertEquals(1, segment.table.length());\n-    assertEquals(liveCount, countLiveEntries(map, 0));\n+    assertThat(segment.table.length()).isEqualTo(1);\n+    assertThat(countLiveEntries(map, 0)).isEqualTo(liveCount);\n     ImmutableMap<Object, Object> originalMap = ImmutableMap.copyOf(map);\n-    assertEquals(liveCount, originalMap.size());\n+    assertThat(originalMap).hasSize(liveCount);\n     // can't compare map contents until cleanup occurs\n \n     for (int i = 1; i <= originalCount * 2; i *= 2) {\n       if (i > 1) {\n         segment.expand();\n       }\n-      assertEquals(i, segment.table.length());\n-      assertEquals(liveCount, countLiveEntries(map, 0));\n+      assertThat(segment.table.length()).isEqualTo(i);\n+      assertThat(countLiveEntries(map, 0)).isEqualTo(liveCount);\n       // expansion cleanup is sloppy, with a goal of avoiding unnecessary copies\n-      assertTrue(segment.count >= liveCount);\n-      assertTrue(segment.count <= originalCount);\n-      assertEquals(originalMap, ImmutableMap.copyOf(map));\n+      assertThat(segment.count).isAtLeast(liveCount);\n+      assertThat(segment.count).isAtMost(originalCount);\n+      assertThat(ImmutableMap.copyOf(map)).isEqualTo(originalMap);\n     }\n   }\n \n@@ -1883,8 +1895,8 @@ public void testRemoveIfWithConcurrentModification() {\n                 return false;\n               }\n             });\n-    assertEquals(3, map.size());\n-    assertFalse(map.containsValue(1));\n+    assertThat(map).hasSize(3);\n+    assertThat(map.containsValue(1)).isFalse();\n   }\n \n   public void testRemoveIfWithConcurrentRemoval() {\n@@ -1900,7 +1912,7 @@ public void testRemoveIfWithConcurrentRemoval() {\n               map.remove((entry.getKey() + 1) % 3);\n               return false;\n             });\n-    assertEquals(1, map.size());\n+    assertThat(map).hasSize(1);\n   }\n \n   private static <K, V> int countLiveEntries(LocalCache<K, V> map, long now) {\n@@ -1928,7 +1940,7 @@ public void testClear() {\n                 .expireAfterWrite(99999, SECONDS));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -1940,17 +1952,17 @@ public void testClear() {\n     segment.count = 1;\n     segment.totalWeight = 1;\n \n-    assertSame(entry, table.get(0));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertSame(entry, segment.writeQueue.peek());\n+    assertThat(table.get(0)).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n \n     segment.clear();\n-    assertNull(table.get(0));\n-    assertTrue(segment.accessQueue.isEmpty());\n-    assertTrue(segment.writeQueue.isEmpty());\n-    assertEquals(0, segment.readCount.get());\n-    assertEquals(0, segment.count);\n-    assertEquals(0, segment.totalWeight);\n+    assertThat(table.get(0)).isNull();\n+    assertThat(segment.accessQueue.isEmpty()).isTrue();\n+    assertThat(segment.writeQueue.isEmpty()).isTrue();\n+    assertThat(segment.readCount.get()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(segment.totalWeight).isEqualTo(0);\n   }\n \n   public void testClear_notification() {\n@@ -1965,7 +1977,7 @@ public void testClear_notification() {\n                 .removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -1977,17 +1989,17 @@ public void testClear_notification() {\n     segment.count = 1;\n     segment.totalWeight = 1;\n \n-    assertSame(entry, table.get(0));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertSame(entry, segment.writeQueue.peek());\n+    assertThat(table.get(0)).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n \n     segment.clear();\n-    assertNull(table.get(0));\n-    assertTrue(segment.accessQueue.isEmpty());\n-    assertTrue(segment.writeQueue.isEmpty());\n-    assertEquals(0, segment.readCount.get());\n-    assertEquals(0, segment.count);\n-    assertEquals(0, segment.totalWeight);\n+    assertThat(table.get(0)).isNull();\n+    assertThat(segment.accessQueue.isEmpty()).isTrue();\n+    assertThat(segment.writeQueue.isEmpty()).isTrue();\n+    assertThat(segment.readCount.get()).isEqualTo(0);\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(segment.totalWeight).isEqualTo(0);\n     assertNotified(listener, key, value, RemovalCause.EXPLICIT);\n   }\n \n@@ -2002,7 +2014,7 @@ public void testRemoveEntry() {\n                 .removalListener(countingRemovalListener()));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -2010,19 +2022,19 @@ public void testRemoveEntry() {\n     DummyEntry<Object, Object> entry = createDummyEntry(key, hash, value, null);\n \n     // remove absent\n-    assertFalse(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));\n+    assertThat(segment.removeEntry(entry, hash, RemovalCause.COLLECTED)).isFalse();\n \n     // remove live\n     segment.recordWrite(entry, 1, map.ticker.read());\n     table.set(0, entry);\n     segment.count = 1;\n-    assertTrue(segment.removeEntry(entry, hash, RemovalCause.COLLECTED));\n+    assertThat(segment.removeEntry(entry, hash, RemovalCause.COLLECTED)).isTrue();\n     assertNotificationEnqueued(map, key, value);\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertFalse(segment.accessQueue.contains(entry));\n-    assertFalse(segment.writeQueue.contains(entry));\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.accessQueue.contains(entry)).isFalse();\n+    assertThat(segment.writeQueue.contains(entry)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n   }\n \n   public void testReclaimValue() {\n@@ -2037,7 +2049,7 @@ public void testReclaimValue() {\n                 .removalListener(listener));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     Object value = new Object();\n@@ -2047,32 +2059,32 @@ public void testReclaimValue() {\n     entry.setValueReference(valueRef);\n \n     // reclaim absent\n-    assertFalse(segment.reclaimValue(key, hash, valueRef));\n+    assertThat(segment.reclaimValue(key, hash, valueRef)).isFalse();\n \n     // reclaim live\n     segment.recordWrite(entry, 1, map.ticker.read());\n     table.set(0, entry);\n     segment.count = 1;\n-    assertTrue(segment.reclaimValue(key, hash, valueRef));\n-    assertEquals(1, listener.getCount());\n-    assertSame(key, listener.getLastEvictedKey());\n-    assertSame(value, listener.getLastEvictedValue());\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertFalse(segment.accessQueue.contains(entry));\n-    assertFalse(segment.writeQueue.contains(entry));\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(segment.reclaimValue(key, hash, valueRef)).isTrue();\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(key);\n+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(value);\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.accessQueue.contains(entry)).isFalse();\n+    assertThat(segment.writeQueue.contains(entry)).isFalse();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n \n     // reclaim wrong value reference\n     table.set(0, entry);\n     DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);\n     entry.setValueReference(otherValueRef);\n-    assertFalse(segment.reclaimValue(key, hash, valueRef));\n-    assertEquals(1, listener.getCount());\n-    assertTrue(segment.reclaimValue(key, hash, otherValueRef));\n-    assertEquals(2, listener.getCount());\n-    assertSame(key, listener.getLastEvictedKey());\n-    assertSame(value, listener.getLastEvictedValue());\n+    assertThat(segment.reclaimValue(key, hash, valueRef)).isFalse();\n+    assertThat(listener.getCount()).isEqualTo(1);\n+    assertThat(segment.reclaimValue(key, hash, otherValueRef)).isTrue();\n+    assertThat(listener.getCount()).isEqualTo(2);\n+    assertThat(listener.getLastEvictedKey()).isSameInstanceAs(key);\n+    assertThat(listener.getLastEvictedValue()).isSameInstanceAs(value);\n   }\n \n   public void testRemoveComputingValue() {\n@@ -2086,7 +2098,7 @@ public void testRemoveComputingValue() {\n                 .removalListener(countingRemovalListener()));\n     Segment<Object, Object> segment = map.segments[0];\n     AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;\n-    assertEquals(1, table.length());\n+    assertThat(table.length()).isEqualTo(1);\n \n     Object key = new Object();\n     int hash = map.hash(key);\n@@ -2095,16 +2107,16 @@ public void testRemoveComputingValue() {\n     entry.setValueReference(valueRef);\n \n     // absent\n-    assertFalse(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isFalse();\n \n     // live\n     table.set(0, entry);\n     // don't increment count; this is used during computation\n-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();\n     // no notification sent with removeLoadingValue\n-    assertTrue(map.removalNotificationQueue.isEmpty());\n-    assertEquals(0, segment.count);\n-    assertNull(table.get(0));\n+    assertThat(map.removalNotificationQueue.isEmpty()).isTrue();\n+    assertThat(segment.count).isEqualTo(0);\n+    assertThat(table.get(0)).isNull();\n \n     // active\n     Object value = new Object();\n@@ -2113,23 +2125,23 @@ public void testRemoveComputingValue() {\n     entry.setValueReference(valueRef);\n     table.set(0, entry);\n     segment.count = 1;\n-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));\n-    assertSame(entry, table.get(0));\n-    assertSame(value, segment.get(key, hash));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();\n+    assertThat(table.get(0)).isSameInstanceAs(entry);\n+    assertThat(segment.get(key, hash)).isSameInstanceAs(value);\n \n     // wrong value reference\n     table.set(0, entry);\n     DummyValueReference<Object, Object> otherValueRef = DummyValueReference.create(value);\n     entry.setValueReference(otherValueRef);\n-    assertFalse(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isFalse();\n     entry.setValueReference(valueRef);\n-    assertTrue(segment.removeLoadingValue(key, hash, valueRef));\n+    assertThat(segment.removeLoadingValue(key, hash, valueRef)).isTrue();\n   }\n \n   private static <K, V> void assertNotificationEnqueued(LocalCache<K, V> map, K key, V value) {\n     RemovalNotification<K, V> notification = map.removalNotificationQueue.poll();\n-    assertSame(key, notification.getKey());\n-    assertSame(value, notification.getValue());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(value);\n   }\n \n   // Segment eviction tests\n@@ -2146,15 +2158,15 @@ public void testDrainRecencyQueueOnWrite() {\n         Object valueTwo = new Object();\n \n         map.put(keyOne, valueOne);\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {\n           map.get(keyOne);\n         }\n-        assertFalse(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isFalse();\n \n         map.put(keyTwo, valueTwo);\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n       }\n     }\n   }\n@@ -2171,16 +2183,16 @@ public void testDrainRecencyQueueOnRead() {\n         // repeated get of the same key\n \n         map.put(keyOne, valueOne);\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {\n           map.get(keyOne);\n         }\n-        assertFalse(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isFalse();\n \n         for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n           map.get(keyOne);\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n \n         // get over many different keys\n@@ -2188,16 +2200,16 @@ public void testDrainRecencyQueueOnRead() {\n         for (int i = 0; i < DRAIN_THRESHOLD * 2; i++) {\n           map.put(new Object(), new Object());\n         }\n-        assertTrue(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n         for (int i = 0; i < DRAIN_THRESHOLD / 2; i++) {\n           map.get(keyOne);\n         }\n-        assertFalse(segment.recencyQueue.isEmpty());\n+        assertThat(segment.recencyQueue.isEmpty()).isFalse();\n \n         for (Object key : map.keySet()) {\n           map.get(key);\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n       }\n     }\n@@ -2263,7 +2275,7 @@ public void testRecordReadOnGet() {\n \n       checkEvictionQueues(map, segment, readOrder, writeOrder);\n       checkExpirationTimes(map);\n-      assertTrue(segment.recencyQueue.isEmpty());\n+      assertThat(segment.recencyQueue.isEmpty()).isTrue();\n \n       // access some of the elements\n       Random random = new Random();\n@@ -2275,7 +2287,7 @@ public void testRecordReadOnGet() {\n           map.get(entry.getKey());\n           reads.add(entry);\n           i.remove();\n-          assertTrue(segment.recencyQueue.size() <= DRAIN_THRESHOLD);\n+          assertThat(segment.recencyQueue.size()).isAtMost(DRAIN_THRESHOLD);\n         }\n       }\n       int undrainedIndex = reads.size() - segment.recencyQueue.size();\n@@ -2349,12 +2361,13 @@ static <K, V> void checkEvictionQueues(\n   private static <K, V> void assertSameEntries(\n       List<ReferenceEntry<K, V>> expectedEntries, List<ReferenceEntry<K, V>> actualEntries) {\n     int size = expectedEntries.size();\n-    assertEquals(size, actualEntries.size());\n+    assertThat(actualEntries).hasSize(size);\n     for (int i = 0; i < size; i++) {\n       ReferenceEntry<K, V> expectedEntry = expectedEntries.get(i);\n       ReferenceEntry<K, V> actualEntry = actualEntries.get(i);\n-      assertSame(expectedEntry.getKey(), actualEntry.getKey());\n-      assertSame(expectedEntry.getValueReference().get(), actualEntry.getValueReference().get());\n+      assertThat(actualEntry.getKey()).isSameInstanceAs(expectedEntry.getKey());\n+      assertThat(actualEntry.getValueReference().get())\n+          .isSameInstanceAs(expectedEntry.getValueReference().get());\n     }\n   }\n \n@@ -2368,10 +2381,10 @@ static <K, V> void checkExpirationTimes(LocalCache<K, V> map) {\n       long lastWriteTime = 0;\n       for (ReferenceEntry<K, V> e : segment.recencyQueue) {\n         long accessTime = e.getAccessTime();\n-        assertTrue(accessTime >= lastAccessTime);\n+        assertThat(accessTime).isAtLeast(lastAccessTime);\n         lastAccessTime = accessTime;\n         long writeTime = e.getWriteTime();\n-        assertTrue(writeTime >= lastWriteTime);\n+        assertThat(writeTime).isAtLeast(lastWriteTime);\n         lastWriteTime = writeTime;\n       }\n \n@@ -2379,12 +2392,12 @@ static <K, V> void checkExpirationTimes(LocalCache<K, V> map) {\n       lastWriteTime = 0;\n       for (ReferenceEntry<K, V> e : segment.accessQueue) {\n         long accessTime = e.getAccessTime();\n-        assertTrue(accessTime >= lastAccessTime);\n+        assertThat(accessTime).isAtLeast(lastAccessTime);\n         lastAccessTime = accessTime;\n       }\n       for (ReferenceEntry<K, V> e : segment.writeQueue) {\n         long writeTime = e.getWriteTime();\n-        assertTrue(writeTime >= lastWriteTime);\n+        assertThat(writeTime).isAtLeast(lastWriteTime);\n         lastWriteTime = writeTime;\n       }\n     }\n@@ -2404,31 +2417,31 @@ public void testExpireAfterWrite() {\n     Object value = new Object();\n     map.put(key, value);\n     ReferenceEntry<Object, Object> entry = map.getEntry(key);\n-    assertTrue(map.isLive(entry, ticker.read()));\n+    assertThat(map.isLive(entry, ticker.read())).isTrue();\n \n     segment.writeQueue.add(entry);\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.writeQueue.peek());\n-    assertEquals(1, segment.writeQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue).hasSize(1);\n \n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.writeQueue.peek());\n-    assertEquals(1, segment.writeQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.writeQueue.peek());\n-    assertEquals(1, segment.writeQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.writeQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.writeQueue).hasSize(1);\n \n     ticker.advance(1);\n-    assertNull(map.get(key));\n+    assertThat(map.get(key)).isNull();\n     segment.expireEntries(ticker.read());\n-    assertNull(map.get(key));\n-    assertTrue(segment.writeQueue.isEmpty());\n+    assertThat(map.get(key)).isNull();\n+    assertThat(segment.writeQueue.isEmpty()).isTrue();\n   }\n \n   public void testExpireAfterAccess() {\n@@ -2445,46 +2458,46 @@ public void testExpireAfterAccess() {\n     Object value = new Object();\n     map.put(key, value);\n     ReferenceEntry<Object, Object> entry = map.getEntry(key);\n-    assertTrue(map.isLive(entry, ticker.read()));\n+    assertThat(map.isLive(entry, ticker.read())).isTrue();\n \n     segment.accessQueue.add(entry);\n-    assertSame(value, map.get(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.get(key)).isSameInstanceAs(value);\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.recordRead(entry, ticker.read());\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n     segment.expireEntries(ticker.read());\n-    assertTrue(map.containsKey(key));\n-    assertSame(entry, segment.accessQueue.peek());\n-    assertEquals(1, segment.accessQueue.size());\n+    assertThat(map.containsKey(key)).isTrue();\n+    assertThat(segment.accessQueue.peek()).isSameInstanceAs(entry);\n+    assertThat(segment.accessQueue).hasSize(1);\n \n     ticker.advance(1);\n-    assertFalse(map.containsKey(key));\n-    assertNull(map.get(key));\n+    assertThat(map.containsKey(key)).isFalse();\n+    assertThat(map.get(key)).isNull();\n     segment.expireEntries(ticker.read());\n-    assertFalse(map.containsKey(key));\n-    assertNull(map.get(key));\n-    assertTrue(segment.accessQueue.isEmpty());\n+    assertThat(map.containsKey(key)).isFalse();\n+    assertThat(map.get(key)).isNull();\n+    assertThat(segment.accessQueue.isEmpty()).isTrue();\n   }\n \n   public void testEvictEntries() {\n@@ -2513,8 +2526,8 @@ public void testEvictEntries() {\n     }\n     segment.count = originalCount;\n     segment.totalWeight = originalCount;\n-    assertEquals(originalCount, map.size());\n-    assertEquals(originalMap, map);\n+    assertThat(map).hasSize(originalCount);\n+    assertThat(map).isEqualTo(originalMap);\n \n     Iterator<Object> it = originalMap.keySet().iterator();\n     for (int i = 0; i < originalCount - maxSize; i++) {\n@@ -2522,8 +2535,8 @@ public void testEvictEntries() {\n       it.remove();\n     }\n     segment.evictEntries(entry);\n-    assertEquals(maxSize, map.size());\n-    assertEquals(originalMap, map);\n+    assertThat(map).hasSize(maxSize);\n+    assertThat(map).isEqualTo(originalMap);\n   }\n \n   // reference queues\n@@ -2548,11 +2561,11 @@ public void testDrainKeyReferenceQueueOnWrite() {\n         reference.enqueue();\n \n         map.put(keyTwo, valueTwo);\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(1, map.size());\n-        assertNull(segment.keyReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).hasSize(1);\n+        assertThat(segment.keyReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2578,11 +2591,11 @@ public void testDrainValueReferenceQueueOnWrite() {\n         reference.enqueue();\n \n         map.put(keyTwo, valueTwo);\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(1, map.size());\n-        assertNull(segment.valueReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).hasSize(1);\n+        assertThat(segment.valueReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2608,11 +2621,11 @@ public void testDrainKeyReferenceQueueOnRead() {\n         for (int i = 0; i < SMALL_MAX_SIZE; i++) {\n           map.get(keyTwo);\n         }\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(0, map.size());\n-        assertNull(segment.keyReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).isEmpty();\n+        assertThat(segment.keyReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2639,11 +2652,11 @@ public void testDrainValueReferenceQueueOnRead() {\n         for (int i = 0; i < SMALL_MAX_SIZE; i++) {\n           map.get(keyTwo);\n         }\n-        assertFalse(map.containsKey(keyOne));\n-        assertFalse(map.containsValue(valueOne));\n-        assertNull(map.get(keyOne));\n-        assertEquals(0, map.size());\n-        assertNull(segment.valueReferenceQueue.poll());\n+        assertThat(map.containsKey(keyOne)).isFalse();\n+        assertThat(map.containsValue(valueOne)).isFalse();\n+        assertThat(map.get(keyOne)).isNull();\n+        assertThat(map).isEmpty();\n+        assertThat(segment.valueReferenceQueue.poll()).isNull();\n       }\n     }\n   }\n@@ -2676,42 +2689,45 @@ public void testSerializationProxyLoading() {\n                 .build(loader);\n     // add a non-serializable entry\n     one.getUnchecked(new Object());\n-    assertEquals(1, one.size());\n-    assertFalse(one.asMap().isEmpty());\n+    assertThat(one.size()).isEqualTo(1);\n+    assertThat(one.asMap().isEmpty()).isFalse();\n     LocalLoadingCache<Object, Object> two = SerializableTester.reserialize(one);\n-    assertEquals(0, two.size());\n-    assertTrue(two.asMap().isEmpty());\n+    assertThat(two.size()).isEqualTo(0);\n+    assertThat(two.asMap().isEmpty()).isTrue();\n \n     LocalCache<Object, Object> localCacheOne = one.localCache;\n     LocalCache<Object, Object> localCacheTwo = two.localCache;\n \n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.maxWeight, localCacheTwo.maxWeight);\n-    assertEquals(localCacheOne.weigher, localCacheTwo.weigher);\n-    assertEquals(localCacheOne.expireAfterAccessNanos, localCacheTwo.expireAfterAccessNanos);\n-    assertEquals(localCacheOne.expireAfterWriteNanos, localCacheTwo.expireAfterWriteNanos);\n-    assertEquals(localCacheOne.refreshNanos, localCacheTwo.refreshNanos);\n-    assertEquals(localCacheOne.removalListener, localCacheTwo.removalListener);\n-    assertEquals(localCacheOne.ticker, localCacheTwo.ticker);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.maxWeight).isEqualTo(localCacheOne.maxWeight);\n+    assertThat(localCacheTwo.weigher).isEqualTo(localCacheOne.weigher);\n+    assertThat(localCacheTwo.expireAfterAccessNanos)\n+        .isEqualTo(localCacheOne.expireAfterAccessNanos);\n+    assertThat(localCacheTwo.expireAfterWriteNanos).isEqualTo(localCacheOne.expireAfterWriteNanos);\n+    assertThat(localCacheTwo.refreshNanos).isEqualTo(localCacheOne.refreshNanos);\n+    assertThat(localCacheTwo.removalListener).isEqualTo(localCacheOne.removalListener);\n+    assertThat(localCacheTwo.ticker).isEqualTo(localCacheOne.ticker);\n \n     // serialize the reconstituted version to be sure we haven't lost the ability to reserialize\n     LocalLoadingCache<Object, Object> three = SerializableTester.reserialize(two);\n     LocalCache<Object, Object> localCacheThree = three.localCache;\n \n-    assertEquals(localCacheTwo.defaultLoader, localCacheThree.defaultLoader);\n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.maxWeight, localCacheThree.maxWeight);\n-    assertEquals(localCacheTwo.weigher, localCacheThree.weigher);\n-    assertEquals(localCacheTwo.expireAfterAccessNanos, localCacheThree.expireAfterAccessNanos);\n-    assertEquals(localCacheTwo.expireAfterWriteNanos, localCacheThree.expireAfterWriteNanos);\n-    assertEquals(localCacheTwo.removalListener, localCacheThree.removalListener);\n-    assertEquals(localCacheTwo.ticker, localCacheThree.ticker);\n+    assertThat(localCacheThree.defaultLoader).isEqualTo(localCacheTwo.defaultLoader);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.maxWeight).isEqualTo(localCacheTwo.maxWeight);\n+    assertThat(localCacheThree.weigher).isEqualTo(localCacheTwo.weigher);\n+    assertThat(localCacheThree.expireAfterAccessNanos)\n+        .isEqualTo(localCacheTwo.expireAfterAccessNanos);\n+    assertThat(localCacheThree.expireAfterWriteNanos)\n+        .isEqualTo(localCacheTwo.expireAfterWriteNanos);\n+    assertThat(localCacheThree.removalListener).isEqualTo(localCacheTwo.removalListener);\n+    assertThat(localCacheThree.ticker).isEqualTo(localCacheTwo.ticker);\n   }\n \n   public void testSerializationProxyManual() {\n@@ -2733,40 +2749,43 @@ public void testSerializationProxyManual() {\n                 .build();\n     // add a non-serializable entry\n     one.put(new Object(), new Object());\n-    assertEquals(1, one.size());\n-    assertFalse(one.asMap().isEmpty());\n+    assertThat(one.size()).isEqualTo(1);\n+    assertThat(one.asMap().isEmpty()).isFalse();\n     LocalManualCache<Object, Object> two = SerializableTester.reserialize(one);\n-    assertEquals(0, two.size());\n-    assertTrue(two.asMap().isEmpty());\n+    assertThat(two.size()).isEqualTo(0);\n+    assertThat(two.asMap().isEmpty()).isTrue();\n \n     LocalCache<Object, Object> localCacheOne = one.localCache;\n     LocalCache<Object, Object> localCacheTwo = two.localCache;\n \n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.keyStrength, localCacheTwo.keyStrength);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.valueEquivalence, localCacheTwo.valueEquivalence);\n-    assertEquals(localCacheOne.maxWeight, localCacheTwo.maxWeight);\n-    assertEquals(localCacheOne.weigher, localCacheTwo.weigher);\n-    assertEquals(localCacheOne.expireAfterAccessNanos, localCacheTwo.expireAfterAccessNanos);\n-    assertEquals(localCacheOne.expireAfterWriteNanos, localCacheTwo.expireAfterWriteNanos);\n-    assertEquals(localCacheOne.removalListener, localCacheTwo.removalListener);\n-    assertEquals(localCacheOne.ticker, localCacheTwo.ticker);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.keyStrength).isEqualTo(localCacheOne.keyStrength);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.valueEquivalence).isEqualTo(localCacheOne.valueEquivalence);\n+    assertThat(localCacheTwo.maxWeight).isEqualTo(localCacheOne.maxWeight);\n+    assertThat(localCacheTwo.weigher).isEqualTo(localCacheOne.weigher);\n+    assertThat(localCacheTwo.expireAfterAccessNanos)\n+        .isEqualTo(localCacheOne.expireAfterAccessNanos);\n+    assertThat(localCacheTwo.expireAfterWriteNanos).isEqualTo(localCacheOne.expireAfterWriteNanos);\n+    assertThat(localCacheTwo.removalListener).isEqualTo(localCacheOne.removalListener);\n+    assertThat(localCacheTwo.ticker).isEqualTo(localCacheOne.ticker);\n \n     // serialize the reconstituted version to be sure we haven't lost the ability to reserialize\n     LocalManualCache<Object, Object> three = SerializableTester.reserialize(two);\n     LocalCache<Object, Object> localCacheThree = three.localCache;\n \n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.keyStrength, localCacheThree.keyStrength);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.valueEquivalence, localCacheThree.valueEquivalence);\n-    assertEquals(localCacheTwo.maxWeight, localCacheThree.maxWeight);\n-    assertEquals(localCacheTwo.weigher, localCacheThree.weigher);\n-    assertEquals(localCacheTwo.expireAfterAccessNanos, localCacheThree.expireAfterAccessNanos);\n-    assertEquals(localCacheTwo.expireAfterWriteNanos, localCacheThree.expireAfterWriteNanos);\n-    assertEquals(localCacheTwo.removalListener, localCacheThree.removalListener);\n-    assertEquals(localCacheTwo.ticker, localCacheThree.ticker);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.keyStrength).isEqualTo(localCacheTwo.keyStrength);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.valueEquivalence).isEqualTo(localCacheTwo.valueEquivalence);\n+    assertThat(localCacheThree.maxWeight).isEqualTo(localCacheTwo.maxWeight);\n+    assertThat(localCacheThree.weigher).isEqualTo(localCacheTwo.weigher);\n+    assertThat(localCacheThree.expireAfterAccessNanos)\n+        .isEqualTo(localCacheTwo.expireAfterAccessNanos);\n+    assertThat(localCacheThree.expireAfterWriteNanos)\n+        .isEqualTo(localCacheTwo.expireAfterWriteNanos);\n+    assertThat(localCacheThree.removalListener).isEqualTo(localCacheTwo.removalListener);\n+    assertThat(localCacheThree.ticker).isEqualTo(localCacheTwo.ticker);\n   }\n \n   public void testLoadDifferentKeyInLoader() throws ExecutionException, InterruptedException {\n@@ -2774,16 +2793,16 @@ public void testLoadDifferentKeyInLoader() throws ExecutionException, Interrupte\n     String key1 = \"key1\";\n     String key2 = \"key2\";\n \n-    assertEquals(\n-        key2,\n-        cache.get(\n-            key1,\n-            new CacheLoader<String, String>() {\n-              @Override\n-              public String load(String key) throws Exception {\n-                return cache.get(key2, identityLoader()); // loads a different key, should work\n-              }\n-            }));\n+    assertThat(\n+            cache.get(\n+                key1,\n+                new CacheLoader<String, String>() {\n+                  @Override\n+                  public String load(String key) throws Exception {\n+                    return cache.get(key2, identityLoader()); // loads a different key, should work\n+                  }\n+                }))\n+        .isEqualTo(key2);\n   }\n \n   public void testRecursiveLoad() throws InterruptedException {\ndiff --git a/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java b/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java\nindex 1f927b731894..20dce52c426b 100644\n--- a/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java\n+++ b/guava-tests/test/com/google/common/cache/LocalLoadingCacheTest.java\n@@ -62,7 +62,7 @@ public Object load(Object from) {\n           }\n         };\n     LocalLoadingCache<Object, Object> cache = makeCache(createCacheBuilder(), loader);\n-    assertSame(loader, cache.localCache.defaultLoader);\n+    assertThat(cache.localCache.defaultLoader).isSameInstanceAs(loader);\n   }\n \n   // null parameters test\n@@ -78,82 +78,82 @@ public void testNullParameters() throws Exception {\n   public void testStats() {\n     CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1).maximumSize(2);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     cache.getUnchecked(one);\n     CacheStats stats = cache.stats();\n-    assertEquals(1, stats.requestCount());\n-    assertEquals(0, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(1);\n+    assertThat(stats.hitCount()).isEqualTo(0);\n     assertThat(stats.hitRate()).isEqualTo(0.0);\n-    assertEquals(1, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n     assertThat(stats.missRate()).isEqualTo(1.0);\n-    assertEquals(1, stats.loadCount());\n+    assertThat(stats.loadCount()).isEqualTo(1);\n     long totalLoadTime = stats.totalLoadTime();\n-    assertTrue(totalLoadTime >= 0);\n-    assertTrue(stats.averageLoadPenalty() >= 0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(totalLoadTime).isAtLeast(0);\n+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n \n     cache.getUnchecked(one);\n     stats = cache.stats();\n-    assertEquals(2, stats.requestCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(2);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n     assertThat(stats.hitRate()).isEqualTo(1.0 / 2);\n-    assertEquals(1, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(1);\n     assertThat(stats.missRate()).isEqualTo(1.0 / 2);\n-    assertEquals(1, stats.loadCount());\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.loadCount()).isEqualTo(1);\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n \n     Object two = new Object();\n     cache.getUnchecked(two);\n     stats = cache.stats();\n-    assertEquals(3, stats.requestCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(3);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n     assertThat(stats.hitRate()).isEqualTo(1.0 / 3);\n-    assertEquals(2, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(2);\n     assertThat(stats.missRate()).isEqualTo(2.0 / 3);\n-    assertEquals(2, stats.loadCount());\n-    assertTrue(stats.totalLoadTime() >= totalLoadTime);\n+    assertThat(stats.loadCount()).isEqualTo(2);\n+    assertThat(stats.totalLoadTime()).isAtLeast(totalLoadTime);\n     totalLoadTime = stats.totalLoadTime();\n-    assertTrue(stats.averageLoadPenalty() >= 0.0);\n-    assertEquals(0, stats.evictionCount());\n+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);\n+    assertThat(stats.evictionCount()).isEqualTo(0);\n \n     Object three = new Object();\n     cache.getUnchecked(three);\n     stats = cache.stats();\n-    assertEquals(4, stats.requestCount());\n-    assertEquals(1, stats.hitCount());\n+    assertThat(stats.requestCount()).isEqualTo(4);\n+    assertThat(stats.hitCount()).isEqualTo(1);\n     assertThat(stats.hitRate()).isEqualTo(1.0 / 4);\n-    assertEquals(3, stats.missCount());\n+    assertThat(stats.missCount()).isEqualTo(3);\n     assertThat(stats.missRate()).isEqualTo(3.0 / 4);\n-    assertEquals(3, stats.loadCount());\n-    assertTrue(stats.totalLoadTime() >= totalLoadTime);\n-    assertTrue(stats.averageLoadPenalty() >= 0.0);\n-    assertEquals(1, stats.evictionCount());\n+    assertThat(stats.loadCount()).isEqualTo(3);\n+    assertThat(stats.totalLoadTime()).isAtLeast(totalLoadTime);\n+    assertThat(stats.averageLoadPenalty()).isAtLeast(0.0);\n+    assertThat(stats.evictionCount()).isEqualTo(1);\n   }\n \n   public void testStatsNoops() {\n     CacheBuilder<Object, Object> builder = createCacheBuilder().concurrencyLevel(1);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n     ConcurrentMap<Object, Object> map = cache.localCache; // modifiable map view\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     assertNull(map.put(one, one));\n-    assertSame(one, map.get(one));\n-    assertTrue(map.containsKey(one));\n-    assertTrue(map.containsValue(one));\n+    assertThat(map.get(one)).isSameInstanceAs(one);\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map.containsValue(one)).isTrue();\n     Object two = new Object();\n-    assertSame(one, map.replace(one, two));\n-    assertTrue(map.containsKey(one));\n-    assertFalse(map.containsValue(one));\n+    assertThat(map.replace(one, two)).isSameInstanceAs(one);\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map.containsValue(one)).isFalse();\n     Object three = new Object();\n-    assertTrue(map.replace(one, two, three));\n-    assertTrue(map.remove(one, three));\n-    assertFalse(map.containsKey(one));\n-    assertFalse(map.containsValue(one));\n+    assertThat(map.replace(one, two, three)).isTrue();\n+    assertThat(map.remove(one, three)).isTrue();\n+    assertThat(map.containsKey(one)).isFalse();\n+    assertThat(map.containsValue(one)).isFalse();\n     assertNull(map.putIfAbsent(two, three));\n-    assertSame(three, map.remove(two));\n+    assertThat(map.remove(two)).isSameInstanceAs(three);\n     assertNull(map.put(three, one));\n     assertNull(map.put(one, two));\n \n@@ -171,56 +171,56 @@ public void testStatsNoops() {\n \n     map.clear();\n \n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n   }\n \n   public void testNoStats() {\n     CacheBuilder<Object, Object> builder =\n         CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(2);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     cache.getUnchecked(one);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     cache.getUnchecked(one);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object two = new Object();\n     cache.getUnchecked(two);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object three = new Object();\n     cache.getUnchecked(three);\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n   }\n \n   public void testRecordStats() {\n     CacheBuilder<Object, Object> builder =\n         createCacheBuilder().recordStats().concurrencyLevel(1).maximumSize(2);\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(0, cache.stats().hitCount());\n-    assertEquals(0, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(0);\n+    assertThat(cache.stats().missCount()).isEqualTo(0);\n \n     Object one = new Object();\n     cache.getUnchecked(one);\n-    assertEquals(0, cache.stats().hitCount());\n-    assertEquals(1, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(0);\n+    assertThat(cache.stats().missCount()).isEqualTo(1);\n \n     cache.getUnchecked(one);\n-    assertEquals(1, cache.stats().hitCount());\n-    assertEquals(1, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(1);\n+    assertThat(cache.stats().missCount()).isEqualTo(1);\n \n     Object two = new Object();\n     cache.getUnchecked(two);\n-    assertEquals(1, cache.stats().hitCount());\n-    assertEquals(2, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(1);\n+    assertThat(cache.stats().missCount()).isEqualTo(2);\n \n     Object three = new Object();\n     cache.getUnchecked(three);\n-    assertEquals(1, cache.stats().hitCount());\n-    assertEquals(3, cache.stats().missCount());\n+    assertThat(cache.stats().hitCount()).isEqualTo(1);\n+    assertThat(cache.stats().missCount()).isEqualTo(3);\n   }\n \n   // asMap tests\n@@ -228,7 +228,7 @@ public void testRecordStats() {\n   public void testAsMap() {\n     CacheBuilder<Object, Object> builder = createCacheBuilder();\n     LocalLoadingCache<Object, Object> cache = makeCache(builder, identityLoader());\n-    assertEquals(EMPTY_STATS, cache.stats());\n+    assertThat(cache.stats()).isEqualTo(EMPTY_STATS);\n \n     Object one = new Object();\n     Object two = new Object();\n@@ -236,47 +236,47 @@ public void testAsMap() {\n \n     ConcurrentMap<Object, Object> map = cache.asMap();\n     assertNull(map.put(one, two));\n-    assertSame(two, map.get(one));\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n     map.putAll(ImmutableMap.of(two, three));\n-    assertSame(three, map.get(two));\n-    assertSame(two, map.putIfAbsent(one, three));\n-    assertSame(two, map.get(one));\n+    assertThat(map.get(two)).isSameInstanceAs(three);\n+    assertThat(map.putIfAbsent(one, three)).isSameInstanceAs(two);\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n     assertNull(map.putIfAbsent(three, one));\n-    assertSame(one, map.get(three));\n-    assertSame(two, map.replace(one, three));\n-    assertSame(three, map.get(one));\n-    assertFalse(map.replace(one, two, three));\n-    assertSame(three, map.get(one));\n-    assertTrue(map.replace(one, three, two));\n-    assertSame(two, map.get(one));\n-    assertEquals(3, map.size());\n+    assertThat(map.get(three)).isSameInstanceAs(one);\n+    assertThat(map.replace(one, three)).isSameInstanceAs(two);\n+    assertThat(map.get(one)).isSameInstanceAs(three);\n+    assertThat(map.replace(one, two, three)).isFalse();\n+    assertThat(map.get(one)).isSameInstanceAs(three);\n+    assertThat(map.replace(one, three, two)).isTrue();\n+    assertThat(map.get(one)).isSameInstanceAs(two);\n+    assertThat(map).hasSize(3);\n \n     map.clear();\n-    assertTrue(map.isEmpty());\n-    assertEquals(0, map.size());\n+    assertThat(map.isEmpty()).isTrue();\n+    assertThat(map).isEmpty();\n \n     cache.getUnchecked(one);\n-    assertEquals(1, map.size());\n-    assertSame(one, map.get(one));\n-    assertTrue(map.containsKey(one));\n-    assertTrue(map.containsValue(one));\n-    assertSame(one, map.remove(one));\n-    assertEquals(0, map.size());\n+    assertThat(map).hasSize(1);\n+    assertThat(map.get(one)).isSameInstanceAs(one);\n+    assertThat(map.containsKey(one)).isTrue();\n+    assertThat(map.containsValue(one)).isTrue();\n+    assertThat(map.remove(one)).isSameInstanceAs(one);\n+    assertThat(map).isEmpty();\n \n     cache.getUnchecked(one);\n-    assertEquals(1, map.size());\n-    assertFalse(map.remove(one, two));\n-    assertTrue(map.remove(one, one));\n-    assertEquals(0, map.size());\n+    assertThat(map).hasSize(1);\n+    assertThat(map.remove(one, two)).isFalse();\n+    assertThat(map.remove(one, one)).isTrue();\n+    assertThat(map).isEmpty();\n \n     cache.getUnchecked(one);\n     Map<Object, Object> newMap = ImmutableMap.of(one, one);\n-    assertEquals(newMap, map);\n-    assertEquals(newMap.entrySet(), map.entrySet());\n-    assertEquals(newMap.keySet(), map.keySet());\n+    assertThat(map).isEqualTo(newMap);\n+    assertThat(map.entrySet()).isEqualTo(newMap.entrySet());\n+    assertThat(map.keySet()).isEqualTo(newMap.keySet());\n     Set<Object> expectedValues = ImmutableSet.of(one);\n     Set<Object> actualValues = ImmutableSet.copyOf(map.values());\n-    assertEquals(expectedValues, actualValues);\n+    assertThat(actualValues).isEqualTo(expectedValues);\n   }\n \n   /** Lookups on the map view shouldn't impact the recency queue. */\n@@ -288,12 +288,12 @@ public void testAsMapRecency() {\n     ConcurrentMap<Object, Object> map = cache.asMap();\n \n     Object one = new Object();\n-    assertSame(one, cache.getUnchecked(one));\n-    assertTrue(segment.recencyQueue.isEmpty());\n-    assertSame(one, map.get(one));\n-    assertSame(one, segment.recencyQueue.peek().getKey());\n-    assertSame(one, cache.getUnchecked(one));\n-    assertFalse(segment.recencyQueue.isEmpty());\n+    assertThat(cache.getUnchecked(one)).isSameInstanceAs(one);\n+    assertThat(segment.recencyQueue.isEmpty()).isTrue();\n+    assertThat(map.get(one)).isSameInstanceAs(one);\n+    assertThat(segment.recencyQueue.peek().getKey()).isSameInstanceAs(one);\n+    assertThat(cache.getUnchecked(one)).isSameInstanceAs(one);\n+    assertThat(segment.recencyQueue.isEmpty()).isFalse();\n   }\n \n   public void testRecursiveComputation() throws InterruptedException {\n@@ -313,7 +313,7 @@ public String load(Integer key) {\n     LoadingCache<Integer, String> recursiveCache =\n         CacheBuilder.newBuilder().weakKeys().weakValues().build(recursiveLoader);\n     cacheRef.set(recursiveCache);\n-    assertEquals(\"3, 2, 1, 0\", recursiveCache.getUnchecked(3));\n+    assertThat(recursiveCache.getUnchecked(3)).isEqualTo(\"3, 2, 1, 0\");\n \n     recursiveLoader =\n         new CacheLoader<Integer, String>() {\ndiff --git a/guava-tests/test/com/google/common/cache/NullCacheTest.java b/guava-tests/test/com/google/common/cache/NullCacheTest.java\nindex ae49a5366394..5def1a0ac218 100644\n--- a/guava-tests/test/com/google/common/cache/NullCacheTest.java\n+++ b/guava-tests/test/com/google/common/cache/NullCacheTest.java\n@@ -51,12 +51,12 @@ public void testGet() {\n             .build(constantLoader(computed));\n \n     Object key = new Object();\n-    assertSame(computed, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(computed, notification.getValue());\n-    assertSame(RemovalCause.SIZE, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(computed);\n+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -69,12 +69,12 @@ public void testGet_expireAfterWrite() {\n             .build(constantLoader(computed));\n \n     Object key = new Object();\n-    assertSame(computed, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(computed, notification.getValue());\n-    assertSame(RemovalCause.SIZE, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(computed);\n+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -87,12 +87,12 @@ public void testGet_expireAfterAccess() {\n             .build(constantLoader(computed));\n \n     Object key = new Object();\n-    assertSame(computed, cache.getUnchecked(key));\n+    assertThat(cache.getUnchecked(key)).isSameInstanceAs(computed);\n     RemovalNotification<Object, Object> notification = listener.remove();\n-    assertSame(key, notification.getKey());\n-    assertSame(computed, notification.getValue());\n-    assertSame(RemovalCause.SIZE, notification.getCause());\n-    assertTrue(listener.isEmpty());\n+    assertThat(notification.getKey()).isSameInstanceAs(key);\n+    assertThat(notification.getValue()).isSameInstanceAs(computed);\n+    assertThat(notification.getCause()).isSameInstanceAs(RemovalCause.SIZE);\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -105,7 +105,7 @@ public void testGet_computeNull() {\n \n     assertThrows(InvalidCacheLoadException.class, () -> cache.getUnchecked(new Object()));\n \n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(cache);\n   }\n \n@@ -120,7 +120,7 @@ public void testGet_runtimeException() {\n     UncheckedExecutionException uee =\n         assertThrows(UncheckedExecutionException.class, () -> map.getUnchecked(new Object()));\n     assertThat(uee).hasCauseThat().isSameInstanceAs(e);\n-    assertTrue(listener.isEmpty());\n+    assertThat(listener.isEmpty()).isTrue();\n     checkEmpty(map);\n   }\n }\ndiff --git a/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java b/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java\nindex ea2066d1b09a..0c529574f1d1 100644\n--- a/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java\n+++ b/guava-tests/test/com/google/common/cache/PopulatedCachesTest.java\n@@ -59,7 +59,7 @@ public void testSize_populated() {\n     for (LoadingCache<Object, Object> cache : caches()) {\n       // don't let the entries get GCed\n       List<Entry<Object, Object>> unused = warmUp(cache);\n-      assertEquals(WARMUP_SIZE, cache.size());\n+      assertThat(cache.size()).isEqualTo(WARMUP_SIZE);\n       assertMapSize(cache.asMap(), WARMUP_SIZE);\n       checkValidState(cache);\n     }\n@@ -71,12 +71,12 @@ public void testContainsKey_found() {\n       List<Entry<Object, Object>> warmed = warmUp(cache);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n-        assertTrue(cache.asMap().containsKey(entry.getKey()));\n-        assertTrue(cache.asMap().containsValue(entry.getValue()));\n+        assertThat(cache.asMap().containsKey(entry.getKey())).isTrue();\n+        assertThat(cache.asMap().containsValue(entry.getValue())).isTrue();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -88,18 +88,18 @@ public void testPut_populated() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object newValue = new Object();\n-        assertSame(entry.getValue(), cache.asMap().put(entry.getKey(), newValue));\n+        assertThat(cache.asMap().put(entry.getKey(), newValue)).isSameInstanceAs(entry.getValue());\n         // don't let the new entry get GCed\n         warmed.add(entryOf(entry.getKey(), newValue));\n         Object newKey = new Object();\n-        assertNull(cache.asMap().put(newKey, entry.getValue()));\n+        assertThat(cache.asMap().put(newKey, entry.getValue())).isNull();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(newValue, cache.getUnchecked(entry.getKey()));\n-        assertEquals(entry.getValue(), cache.getUnchecked(newKey));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(newValue);\n+        assertThat(cache.getUnchecked(newKey)).isEqualTo(entry.getValue());\n         // don't let the new entry get GCed\n         warmed.add(entryOf(newKey, entry.getValue()));\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -111,16 +111,17 @@ public void testPutIfAbsent_populated() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object newValue = new Object();\n-        assertSame(entry.getValue(), cache.asMap().putIfAbsent(entry.getKey(), newValue));\n+        assertThat(cache.asMap().putIfAbsent(entry.getKey(), newValue))\n+            .isSameInstanceAs(entry.getValue());\n         Object newKey = new Object();\n-        assertNull(cache.asMap().putIfAbsent(newKey, entry.getValue()));\n+        assertThat(cache.asMap().putIfAbsent(newKey, entry.getValue())).isNull();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));\n-        assertEquals(entry.getValue(), cache.getUnchecked(newKey));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());\n+        assertThat(cache.getUnchecked(newKey)).isEqualTo(entry.getValue());\n         // don't let the new entry get GCed\n         warmed.add(entryOf(newKey, entry.getValue()));\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -133,8 +134,8 @@ public void testPutAll_populated() {\n       Object newValue = new Object();\n       cache.asMap().putAll(ImmutableMap.of(newKey, newValue));\n       // this getUnchecked() call shouldn't be a cache miss; verified below\n-      assertEquals(newValue, cache.getUnchecked(newKey));\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.getUnchecked(newKey)).isEqualTo(newValue);\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -146,16 +147,17 @@ public void testReplace_populated() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object newValue = new Object();\n-        assertSame(entry.getValue(), cache.asMap().replace(entry.getKey(), newValue));\n-        assertTrue(cache.asMap().replace(entry.getKey(), newValue, entry.getValue()));\n+        assertThat(cache.asMap().replace(entry.getKey(), newValue))\n+            .isSameInstanceAs(entry.getValue());\n+        assertThat(cache.asMap().replace(entry.getKey(), newValue, entry.getValue())).isTrue();\n         Object newKey = new Object();\n-        assertNull(cache.asMap().replace(newKey, entry.getValue()));\n-        assertFalse(cache.asMap().replace(newKey, entry.getValue(), newValue));\n+        assertThat(cache.asMap().replace(newKey, entry.getValue())).isNull();\n+        assertThat(cache.asMap().replace(newKey, entry.getValue(), newValue)).isFalse();\n         // this getUnchecked() call shouldn't be a cache miss; verified below\n-        assertEquals(entry.getValue(), cache.getUnchecked(entry.getKey()));\n-        assertFalse(cache.asMap().containsKey(newKey));\n+        assertThat(cache.getUnchecked(entry.getKey())).isEqualTo(entry.getValue());\n+        assertThat(cache.asMap().containsKey(newKey)).isFalse();\n       }\n-      assertEquals(WARMUP_SIZE, cache.stats().missCount());\n+      assertThat(cache.stats().missCount()).isEqualTo(WARMUP_SIZE);\n       checkValidState(cache);\n     }\n   }\n@@ -167,9 +169,9 @@ public void testRemove_byKey() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> entry = warmed.get(i - WARMUP_MIN);\n         Object key = entry.getKey();\n-        assertEquals(entry.getValue(), cache.asMap().remove(key));\n-        assertNull(cache.asMap().remove(key));\n-        assertFalse(cache.asMap().containsKey(key));\n+        assertThat(cache.asMap().remove(key)).isEqualTo(entry.getValue());\n+        assertThat(cache.asMap().remove(key)).isNull();\n+        assertThat(cache.asMap().containsKey(key)).isFalse();\n       }\n       checkEmpty(cache);\n     }\n@@ -182,10 +184,10 @@ public void testRemove_byKeyAndValue() {\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Object key = warmed.get(i - WARMUP_MIN).getKey();\n         Object value = warmed.get(i - WARMUP_MIN).getValue();\n-        assertFalse(cache.asMap().remove(key, -1));\n-        assertTrue(cache.asMap().remove(key, value));\n-        assertFalse(cache.asMap().remove(key, -1));\n-        assertFalse(cache.asMap().containsKey(key));\n+        assertThat(cache.asMap().remove(key, -1)).isFalse();\n+        assertThat(cache.asMap().remove(key, value)).isTrue();\n+        assertThat(cache.asMap().remove(key, -1)).isFalse();\n+        assertThat(cache.asMap().containsKey(key)).isFalse();\n       }\n       checkEmpty(cache);\n     }\n@@ -206,13 +208,13 @@ public void testKeySet_populated() {\n           .addEqualityGroup(cache.asMap().keySet(), keys)\n           .addEqualityGroup(ImmutableSet.of())\n           .testEquals();\n-      assertEquals(WARMUP_SIZE, keys.size());\n+      assertThat(keys).hasSize(WARMUP_SIZE);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Object key = warmed.get(i - WARMUP_MIN).getKey();\n-        assertTrue(keys.contains(key));\n-        assertTrue(keys.remove(key));\n-        assertFalse(keys.remove(key));\n-        assertFalse(keys.contains(key));\n+        assertThat(keys.contains(key)).isTrue();\n+        assertThat(keys.remove(key)).isTrue();\n+        assertThat(keys.remove(key)).isFalse();\n+        assertThat(keys.contains(key)).isFalse();\n       }\n       checkEmpty(keys);\n       checkEmpty(cache);\n@@ -229,13 +231,13 @@ public void testValues_populated() {\n       assertThat(values.toArray()).asList().containsExactlyElementsIn(expected);\n       assertThat(values.toArray(new Object[0])).asList().containsExactlyElementsIn(expected);\n \n-      assertEquals(WARMUP_SIZE, values.size());\n+      assertThat(values).hasSize(WARMUP_SIZE);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Object value = warmed.get(i - WARMUP_MIN).getValue();\n-        assertTrue(values.contains(value));\n-        assertTrue(values.remove(value));\n-        assertFalse(values.remove(value));\n-        assertFalse(values.contains(value));\n+        assertThat(values.contains(value)).isTrue();\n+        assertThat(values.remove(value)).isTrue();\n+        assertThat(values.remove(value)).isFalse();\n+        assertThat(values.contains(value)).isFalse();\n       }\n       checkEmpty(values);\n       checkEmpty(cache);\n@@ -257,13 +259,13 @@ public void testEntrySet_populated() {\n           .addEqualityGroup(cache.asMap().entrySet(), entries)\n           .addEqualityGroup(ImmutableSet.of())\n           .testEquals();\n-      assertEquals(WARMUP_SIZE, entries.size());\n+      assertThat(entries).hasSize(WARMUP_SIZE);\n       for (int i = WARMUP_MIN; i < WARMUP_MAX; i++) {\n         Entry<Object, Object> newEntry = warmed.get(i - WARMUP_MIN);\n-        assertTrue(entries.contains(newEntry));\n-        assertTrue(entries.remove(newEntry));\n-        assertFalse(entries.remove(newEntry));\n-        assertFalse(entries.contains(newEntry));\n+        assertThat(entries.contains(newEntry)).isTrue();\n+        assertThat(entries.remove(newEntry)).isTrue();\n+        assertThat(entries.remove(newEntry)).isFalse();\n+        assertThat(entries.contains(newEntry)).isFalse();\n       }\n       checkEmpty(entries);\n       checkEmpty(cache);\n@@ -276,11 +278,11 @@ public void testWriteThroughEntry() {\n       Entry<Object, Object> entry = Iterables.getOnlyElement(cache.asMap().entrySet());\n \n       cache.invalidate(1);\n-      assertEquals(0, cache.size());\n+      assertThat(cache.size()).isEqualTo(0);\n \n       entry.setValue(3);\n-      assertEquals(1, cache.size());\n-      assertEquals(3, cache.getIfPresent(1));\n+      assertThat(cache.size()).isEqualTo(1);\n+      assertThat(cache.getIfPresent(1)).isEqualTo(3);\n       checkValidState(cache);\n \n       assertThrows(NullPointerException.class, () -> entry.setValue(null));\n@@ -356,25 +358,26 @@ private Entry<Object, Object> entryOf(Object key, Object value) {\n   }\n \n   private void assertMapSize(Map<?, ?> map, int size) {\n-    assertEquals(size, map.size());\n+    assertThat(map).hasSize(size);\n     if (size > 0) {\n-      assertFalse(map.isEmpty());\n+      assertThat(map.isEmpty()).isFalse();\n     } else {\n-      assertTrue(map.isEmpty());\n+      assertThat(map.isEmpty()).isTrue();\n     }\n     assertCollectionSize(map.keySet(), size);\n     assertCollectionSize(map.entrySet(), size);\n     assertCollectionSize(map.values(), size);\n   }\n \n+  @SuppressWarnings(\"IterablesSizeOfCollection\") // we are testing our iterator implementation\n   private void assertCollectionSize(Collection<?> collection, int size) {\n-    assertEquals(size, collection.size());\n+    assertThat(collection.size()).isEqualTo(size);\n     if (size > 0) {\n-      assertFalse(collection.isEmpty());\n+      assertThat(collection.isEmpty()).isFalse();\n     } else {\n-      assertTrue(collection.isEmpty());\n+      assertThat(collection.isEmpty()).isTrue();\n     }\n-    assertEquals(size, Iterables.size(collection));\n-    assertEquals(size, Iterators.size(collection.iterator()));\n+    assertThat(Iterables.size(collection)).isEqualTo(size);\n+    assertThat(Iterators.size(collection.iterator())).isEqualTo(size);\n   }\n }\n",
  "additions": 4167,
  "deletions": 3997,
  "changed_files": 43,
  "url": "https://github.com/google/guava/pull/8028",
  "mined_at": "2025-10-25T12:52:04.048830"
}