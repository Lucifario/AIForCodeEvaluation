{
  "id": 7996,
  "repository": "google/guava",
  "title": "Fix `Iterators.mergeSorted()` to preserve stability for equal elements.",
  "body": "Fix `Iterators.mergeSorted()` to preserve stability for equal elements.\n\nFixes #7989\nFixes #5773\n\nRELNOTES=`collect`: Improved `Iterators.mergeSorted()` to preserve stability for equal elements.\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-09-16T12:42:19+00:00",
  "created_at": "2025-09-16T01:43:35+00:00",
  "updated_at": "2025-09-16T12:42:19+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "84aca22862f318e1e96a351ec9c3c62fdaec7576",
  "head_sha": "4dc93be9a8f85ea7bc751fd6cc6f2b07ab327dea",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava-tests/test/com/google/common/collect/IteratorsTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "patch": "@@ -1568,7 +1568,8 @@ public void testMergeSorted_stable_issue5773Example() {\n             new TestDatum(\"A\", 2),\n             new TestDatum(\"B\", 1),\n             new TestDatum(\"C\", 1),\n-            new TestDatum(\"C\", 2));\n+            new TestDatum(\"C\", 2))\n+        .inOrder();\n   }\n \n   public void testMergeSorted_stable_allEqual() {\n@@ -1587,7 +1588,8 @@ public void testMergeSorted_stable_allEqual() {\n             new TestDatum(\"A\", 1),\n             new TestDatum(\"A\", 2),\n             new TestDatum(\"A\", 3),\n-            new TestDatum(\"A\", 4));\n+            new TestDatum(\"A\", 4))\n+        .inOrder();\n   }\n \n   private static final class TestDatum {"
    },
    {
      "filename": "android/guava/src/com/google/common/collect/Iterators.java",
      "status": "modified",
      "additions": 29,
      "deletions": 10,
      "changes": 39,
      "patch": "@@ -1294,8 +1294,9 @@ public E peek() {\n    * <p>Callers must ensure that the source {@code iterators} are in non-descending order as this\n    * method does not sort its input.\n    *\n-   * <p>For any equivalent elements across all {@code iterators}, it is undefined which element is\n-   * returned first.\n+   * <p>For any equivalent elements across all {@code iterators}, elements are returned in the order\n+   * of their source iterators. That is, if element A from iterator 1 and element B from iterator 2\n+   * compare as equal, A will be returned before B if iterator 1 was passed before iterator 2.\n    *\n    * @since 11.0\n    */\n@@ -1318,21 +1319,38 @@ public E peek() {\n    */\n   private static final class MergingIterator<T extends @Nullable Object>\n       extends UnmodifiableIterator<T> {\n-    final Queue<PeekingIterator<T>> queue;\n+\n+    // Wrapper class to track insertion order for stable sorting\n+    private static class IndexedIterator<E extends @Nullable Object> {\n+      final PeekingIterator<E> iterator;\n+      final int index;\n+\n+      IndexedIterator(PeekingIterator<E> iterator, int index) {\n+        this.iterator = iterator;\n+        this.index = index;\n+      }\n+    }\n+\n+    final Queue<IndexedIterator<T>> queue;\n \n     MergingIterator(\n         Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> itemComparator) {\n       // A comparator that's used by the heap, allowing the heap\n-      // to be sorted based on the top of each iterator.\n-      Comparator<PeekingIterator<T>> heapComparator =\n-          (PeekingIterator<T> o1, PeekingIterator<T> o2) ->\n-              itemComparator.compare(o1.peek(), o2.peek());\n+      // to be sorted based on the top of each iterator, with insertion order as tiebreaker\n+      Comparator<IndexedIterator<T>> heapComparator =\n+          (o1, o2) ->\n+              ComparisonChain.start()\n+                  .compare(o1.iterator.peek(), o2.iterator.peek(), itemComparator)\n+                  // When elements are equal, use insertion order to maintain stability\n+                  .compare(o1.index, o2.index)\n+                  .result();\n \n       queue = new PriorityQueue<>(2, heapComparator);\n \n+      int index = 0;\n       for (Iterator<? extends T> iterator : iterators) {\n         if (iterator.hasNext()) {\n-          queue.add(Iterators.peekingIterator(iterator));\n+          queue.add(new IndexedIterator<>(peekingIterator(iterator), index++));\n         }\n       }\n     }\n@@ -1345,10 +1363,11 @@ public boolean hasNext() {\n     @Override\n     @ParametricNullness\n     public T next() {\n-      PeekingIterator<T> nextIter = queue.remove();\n+      IndexedIterator<T> nextIndexed = queue.remove();\n+      PeekingIterator<T> nextIter = nextIndexed.iterator;\n       T next = nextIter.next();\n       if (nextIter.hasNext()) {\n-        queue.add(nextIter);\n+        queue.add(nextIndexed);\n       }\n       return next;\n     }"
    },
    {
      "filename": "guava-tests/test/com/google/common/collect/IteratorsTest.java",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "patch": "@@ -1568,7 +1568,8 @@ public void testMergeSorted_stable_issue5773Example() {\n             new TestDatum(\"A\", 2),\n             new TestDatum(\"B\", 1),\n             new TestDatum(\"C\", 1),\n-            new TestDatum(\"C\", 2));\n+            new TestDatum(\"C\", 2))\n+        .inOrder();\n   }\n \n   public void testMergeSorted_stable_allEqual() {\n@@ -1587,7 +1588,8 @@ public void testMergeSorted_stable_allEqual() {\n             new TestDatum(\"A\", 1),\n             new TestDatum(\"A\", 2),\n             new TestDatum(\"A\", 3),\n-            new TestDatum(\"A\", 4));\n+            new TestDatum(\"A\", 4))\n+        .inOrder();\n   }\n \n   private static final class TestDatum {"
    },
    {
      "filename": "guava/src/com/google/common/collect/Iterators.java",
      "status": "modified",
      "additions": 29,
      "deletions": 10,
      "changes": 39,
      "patch": "@@ -1294,8 +1294,9 @@ public E peek() {\n    * <p>Callers must ensure that the source {@code iterators} are in non-descending order as this\n    * method does not sort its input.\n    *\n-   * <p>For any equivalent elements across all {@code iterators}, it is undefined which element is\n-   * returned first.\n+   * <p>For any equivalent elements across all {@code iterators}, elements are returned in the order\n+   * of their source iterators. That is, if element A from iterator 1 and element B from iterator 2\n+   * compare as equal, A will be returned before B if iterator 1 was passed before iterator 2.\n    *\n    * @since 11.0\n    */\n@@ -1318,21 +1319,38 @@ public E peek() {\n    */\n   private static final class MergingIterator<T extends @Nullable Object>\n       extends UnmodifiableIterator<T> {\n-    final Queue<PeekingIterator<T>> queue;\n+\n+    // Wrapper class to track insertion order for stable sorting\n+    private static class IndexedIterator<E extends @Nullable Object> {\n+      final PeekingIterator<E> iterator;\n+      final int index;\n+\n+      IndexedIterator(PeekingIterator<E> iterator, int index) {\n+        this.iterator = iterator;\n+        this.index = index;\n+      }\n+    }\n+\n+    final Queue<IndexedIterator<T>> queue;\n \n     MergingIterator(\n         Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> itemComparator) {\n       // A comparator that's used by the heap, allowing the heap\n-      // to be sorted based on the top of each iterator.\n-      Comparator<PeekingIterator<T>> heapComparator =\n-          (PeekingIterator<T> o1, PeekingIterator<T> o2) ->\n-              itemComparator.compare(o1.peek(), o2.peek());\n+      // to be sorted based on the top of each iterator, with insertion order as tiebreaker\n+      Comparator<IndexedIterator<T>> heapComparator =\n+          (o1, o2) ->\n+              ComparisonChain.start()\n+                  .compare(o1.iterator.peek(), o2.iterator.peek(), itemComparator)\n+                  // When elements are equal, use insertion order to maintain stability\n+                  .compare(o1.index, o2.index)\n+                  .result();\n \n       queue = new PriorityQueue<>(2, heapComparator);\n \n+      int index = 0;\n       for (Iterator<? extends T> iterator : iterators) {\n         if (iterator.hasNext()) {\n-          queue.add(Iterators.peekingIterator(iterator));\n+          queue.add(new IndexedIterator<>(peekingIterator(iterator), index++));\n         }\n       }\n     }\n@@ -1345,10 +1363,11 @@ public boolean hasNext() {\n     @Override\n     @ParametricNullness\n     public T next() {\n-      PeekingIterator<T> nextIter = queue.remove();\n+      IndexedIterator<T> nextIndexed = queue.remove();\n+      PeekingIterator<T> nextIter = nextIndexed.iterator;\n       T next = nextIter.next();\n       if (nextIter.hasNext()) {\n-        queue.add(nextIter);\n+        queue.add(nextIndexed);\n       }\n       return next;\n     }"
    }
  ],
  "diff": "diff --git a/android/guava-tests/test/com/google/common/collect/IteratorsTest.java b/android/guava-tests/test/com/google/common/collect/IteratorsTest.java\nindex bb7fbb44fde4..330328c30a56 100644\n--- a/android/guava-tests/test/com/google/common/collect/IteratorsTest.java\n+++ b/android/guava-tests/test/com/google/common/collect/IteratorsTest.java\n@@ -1568,7 +1568,8 @@ public void testMergeSorted_stable_issue5773Example() {\n             new TestDatum(\"A\", 2),\n             new TestDatum(\"B\", 1),\n             new TestDatum(\"C\", 1),\n-            new TestDatum(\"C\", 2));\n+            new TestDatum(\"C\", 2))\n+        .inOrder();\n   }\n \n   public void testMergeSorted_stable_allEqual() {\n@@ -1587,7 +1588,8 @@ public void testMergeSorted_stable_allEqual() {\n             new TestDatum(\"A\", 1),\n             new TestDatum(\"A\", 2),\n             new TestDatum(\"A\", 3),\n-            new TestDatum(\"A\", 4));\n+            new TestDatum(\"A\", 4))\n+        .inOrder();\n   }\n \n   private static final class TestDatum {\ndiff --git a/android/guava/src/com/google/common/collect/Iterators.java b/android/guava/src/com/google/common/collect/Iterators.java\nindex 0fa2cf03f674..4beae8ba07b3 100644\n--- a/android/guava/src/com/google/common/collect/Iterators.java\n+++ b/android/guava/src/com/google/common/collect/Iterators.java\n@@ -1294,8 +1294,9 @@ public E peek() {\n    * <p>Callers must ensure that the source {@code iterators} are in non-descending order as this\n    * method does not sort its input.\n    *\n-   * <p>For any equivalent elements across all {@code iterators}, it is undefined which element is\n-   * returned first.\n+   * <p>For any equivalent elements across all {@code iterators}, elements are returned in the order\n+   * of their source iterators. That is, if element A from iterator 1 and element B from iterator 2\n+   * compare as equal, A will be returned before B if iterator 1 was passed before iterator 2.\n    *\n    * @since 11.0\n    */\n@@ -1318,21 +1319,38 @@ public E peek() {\n    */\n   private static final class MergingIterator<T extends @Nullable Object>\n       extends UnmodifiableIterator<T> {\n-    final Queue<PeekingIterator<T>> queue;\n+\n+    // Wrapper class to track insertion order for stable sorting\n+    private static class IndexedIterator<E extends @Nullable Object> {\n+      final PeekingIterator<E> iterator;\n+      final int index;\n+\n+      IndexedIterator(PeekingIterator<E> iterator, int index) {\n+        this.iterator = iterator;\n+        this.index = index;\n+      }\n+    }\n+\n+    final Queue<IndexedIterator<T>> queue;\n \n     MergingIterator(\n         Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> itemComparator) {\n       // A comparator that's used by the heap, allowing the heap\n-      // to be sorted based on the top of each iterator.\n-      Comparator<PeekingIterator<T>> heapComparator =\n-          (PeekingIterator<T> o1, PeekingIterator<T> o2) ->\n-              itemComparator.compare(o1.peek(), o2.peek());\n+      // to be sorted based on the top of each iterator, with insertion order as tiebreaker\n+      Comparator<IndexedIterator<T>> heapComparator =\n+          (o1, o2) ->\n+              ComparisonChain.start()\n+                  .compare(o1.iterator.peek(), o2.iterator.peek(), itemComparator)\n+                  // When elements are equal, use insertion order to maintain stability\n+                  .compare(o1.index, o2.index)\n+                  .result();\n \n       queue = new PriorityQueue<>(2, heapComparator);\n \n+      int index = 0;\n       for (Iterator<? extends T> iterator : iterators) {\n         if (iterator.hasNext()) {\n-          queue.add(Iterators.peekingIterator(iterator));\n+          queue.add(new IndexedIterator<>(peekingIterator(iterator), index++));\n         }\n       }\n     }\n@@ -1345,10 +1363,11 @@ public boolean hasNext() {\n     @Override\n     @ParametricNullness\n     public T next() {\n-      PeekingIterator<T> nextIter = queue.remove();\n+      IndexedIterator<T> nextIndexed = queue.remove();\n+      PeekingIterator<T> nextIter = nextIndexed.iterator;\n       T next = nextIter.next();\n       if (nextIter.hasNext()) {\n-        queue.add(nextIter);\n+        queue.add(nextIndexed);\n       }\n       return next;\n     }\ndiff --git a/guava-tests/test/com/google/common/collect/IteratorsTest.java b/guava-tests/test/com/google/common/collect/IteratorsTest.java\nindex bb7fbb44fde4..330328c30a56 100644\n--- a/guava-tests/test/com/google/common/collect/IteratorsTest.java\n+++ b/guava-tests/test/com/google/common/collect/IteratorsTest.java\n@@ -1568,7 +1568,8 @@ public void testMergeSorted_stable_issue5773Example() {\n             new TestDatum(\"A\", 2),\n             new TestDatum(\"B\", 1),\n             new TestDatum(\"C\", 1),\n-            new TestDatum(\"C\", 2));\n+            new TestDatum(\"C\", 2))\n+        .inOrder();\n   }\n \n   public void testMergeSorted_stable_allEqual() {\n@@ -1587,7 +1588,8 @@ public void testMergeSorted_stable_allEqual() {\n             new TestDatum(\"A\", 1),\n             new TestDatum(\"A\", 2),\n             new TestDatum(\"A\", 3),\n-            new TestDatum(\"A\", 4));\n+            new TestDatum(\"A\", 4))\n+        .inOrder();\n   }\n \n   private static final class TestDatum {\ndiff --git a/guava/src/com/google/common/collect/Iterators.java b/guava/src/com/google/common/collect/Iterators.java\nindex 0fa2cf03f674..4beae8ba07b3 100644\n--- a/guava/src/com/google/common/collect/Iterators.java\n+++ b/guava/src/com/google/common/collect/Iterators.java\n@@ -1294,8 +1294,9 @@ public E peek() {\n    * <p>Callers must ensure that the source {@code iterators} are in non-descending order as this\n    * method does not sort its input.\n    *\n-   * <p>For any equivalent elements across all {@code iterators}, it is undefined which element is\n-   * returned first.\n+   * <p>For any equivalent elements across all {@code iterators}, elements are returned in the order\n+   * of their source iterators. That is, if element A from iterator 1 and element B from iterator 2\n+   * compare as equal, A will be returned before B if iterator 1 was passed before iterator 2.\n    *\n    * @since 11.0\n    */\n@@ -1318,21 +1319,38 @@ public E peek() {\n    */\n   private static final class MergingIterator<T extends @Nullable Object>\n       extends UnmodifiableIterator<T> {\n-    final Queue<PeekingIterator<T>> queue;\n+\n+    // Wrapper class to track insertion order for stable sorting\n+    private static class IndexedIterator<E extends @Nullable Object> {\n+      final PeekingIterator<E> iterator;\n+      final int index;\n+\n+      IndexedIterator(PeekingIterator<E> iterator, int index) {\n+        this.iterator = iterator;\n+        this.index = index;\n+      }\n+    }\n+\n+    final Queue<IndexedIterator<T>> queue;\n \n     MergingIterator(\n         Iterable<? extends Iterator<? extends T>> iterators, Comparator<? super T> itemComparator) {\n       // A comparator that's used by the heap, allowing the heap\n-      // to be sorted based on the top of each iterator.\n-      Comparator<PeekingIterator<T>> heapComparator =\n-          (PeekingIterator<T> o1, PeekingIterator<T> o2) ->\n-              itemComparator.compare(o1.peek(), o2.peek());\n+      // to be sorted based on the top of each iterator, with insertion order as tiebreaker\n+      Comparator<IndexedIterator<T>> heapComparator =\n+          (o1, o2) ->\n+              ComparisonChain.start()\n+                  .compare(o1.iterator.peek(), o2.iterator.peek(), itemComparator)\n+                  // When elements are equal, use insertion order to maintain stability\n+                  .compare(o1.index, o2.index)\n+                  .result();\n \n       queue = new PriorityQueue<>(2, heapComparator);\n \n+      int index = 0;\n       for (Iterator<? extends T> iterator : iterators) {\n         if (iterator.hasNext()) {\n-          queue.add(Iterators.peekingIterator(iterator));\n+          queue.add(new IndexedIterator<>(peekingIterator(iterator), index++));\n         }\n       }\n     }\n@@ -1345,10 +1363,11 @@ public boolean hasNext() {\n     @Override\n     @ParametricNullness\n     public T next() {\n-      PeekingIterator<T> nextIter = queue.remove();\n+      IndexedIterator<T> nextIndexed = queue.remove();\n+      PeekingIterator<T> nextIter = nextIndexed.iterator;\n       T next = nextIter.next();\n       if (nextIter.hasNext()) {\n-        queue.add(nextIter);\n+        queue.add(nextIndexed);\n       }\n       return next;\n     }\n",
  "additions": 66,
  "deletions": 24,
  "changed_files": 4,
  "url": "https://github.com/google/guava/pull/7996",
  "mined_at": "2025-10-25T13:02:58.574592"
}