diff --git a/android/guava-tests/test/com/google/common/graph/GraphsTest.java b/android/guava-tests/test/com/google/common/graph/GraphsTest.java
index 20199ee8feb3..293ac4529273 100644
--- a/android/guava-tests/test/com/google/common/graph/GraphsTest.java
+++ b/android/guava-tests/test/com/google/common/graph/GraphsTest.java
@@ -16,16 +16,16 @@
 
 package com.google.common.graph;
 
+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_ALWAYS;
+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_FOR_CYCLES;
 import static com.google.common.graph.Graphs.copyOf;
 import static com.google.common.graph.Graphs.inducedSubgraph;
-import static com.google.common.graph.Graphs.reachableNodes;
 import static com.google.common.graph.Graphs.transitiveClosure;
 import static com.google.common.graph.Graphs.transpose;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
 import com.google.common.collect.ImmutableSet;
-import java.util.Set;
 import org.jspecify.annotations.NullUnmarked;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -61,7 +61,7 @@ public class GraphsTest {
   static final String ERROR_SELF_LOOP = "self-loops are not allowed";
 
   @Test
-  public void transitiveClosure_directedGraph() {
+  public void transitiveClosure_directedGraph_addSelfLoopsAlways() {
     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();
     directedGraph.putEdge(N1, N2);
     directedGraph.putEdge(N1, N3);
@@ -77,11 +77,30 @@ public void transitiveClosure_directedGraph() {
     expectedClosure.putEdge(N3, N3);
     expectedClosure.putEdge(N4, N4);
 
-    checkTransitiveClosure(directedGraph, expectedClosure);
+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);
   }
 
   @Test
-  public void transitiveClosure_undirectedGraph() {
+  public void transitiveClosure_directedGraph_addSelfLoopsForCycles() {
+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();
+    directedGraph.putEdge(N1, N2);
+    directedGraph.putEdge(N1, N3);
+    directedGraph.putEdge(N2, N3);
+    directedGraph.addNode(N4);
+
+    // the above graph is its own transitive closure
+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();
+    expectedClosure.putEdge(N1, N2);
+    expectedClosure.putEdge(N1, N3);
+    expectedClosure.putEdge(N2, N3);
+    expectedClosure.addNode(N4);
+
+    assertThat(
+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);
+  }
+
+  @Test
+  public void transitiveClosure_undirectedGraph_addSelfLoopsAlways() {
     MutableGraph<Integer> undirectedGraph =
         GraphBuilder.undirected().allowsSelfLoops(false).build();
     undirectedGraph.putEdge(N1, N2);
@@ -98,11 +117,34 @@ public void transitiveClosure_undirectedGraph() {
     expectedClosure.putEdge(N3, N3);
     expectedClosure.putEdge(N4, N4);
 
-    checkTransitiveClosure(undirectedGraph, expectedClosure);
+    assertThat(
+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);
   }
 
   @Test
-  public void transitiveClosure_directedPathGraph() {
+  public void transitiveClosure_undirectedGraph_addSelfLoopsForCycles() {
+    MutableGraph<Integer> undirectedGraph =
+        GraphBuilder.undirected().allowsSelfLoops(false).build();
+    undirectedGraph.putEdge(N1, N2);
+    undirectedGraph.putEdge(N1, N3);
+    undirectedGraph.putEdge(N2, N3);
+    undirectedGraph.addNode(N4);
+
+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();
+    expectedClosure.putEdge(N1, N1);
+    expectedClosure.putEdge(N1, N2);
+    expectedClosure.putEdge(N1, N3);
+    expectedClosure.putEdge(N2, N2);
+    expectedClosure.putEdge(N2, N3);
+    expectedClosure.putEdge(N3, N3);
+    expectedClosure.addNode(N4); // N4 is isolated => no incident edges in this transitive closure
+
+    assertThat(
+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);
+  }
+
+  @Test
+  public void transitiveClosure_directedPathGraph_addSelfLoopsAlways() {
     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();
     directedGraph.putEdge(N1, N2);
     directedGraph.putEdge(N2, N3);
@@ -120,7 +162,26 @@ public void transitiveClosure_directedPathGraph() {
     expectedClosure.putEdge(N3, N4);
     expectedClosure.putEdge(N4, N4);
 
-    checkTransitiveClosure(directedGraph, expectedClosure);
+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);
+  }
+
+  @Test
+  public void transitiveClosure_directedPathGraph_addSelfLoopsForCycles() {
+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();
+    directedGraph.putEdge(N1, N2);
+    directedGraph.putEdge(N2, N3);
+    directedGraph.putEdge(N3, N4);
+
+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();
+    expectedClosure.putEdge(N1, N2);
+    expectedClosure.putEdge(N1, N3);
+    expectedClosure.putEdge(N1, N4);
+    expectedClosure.putEdge(N2, N3);
+    expectedClosure.putEdge(N2, N4);
+    expectedClosure.putEdge(N3, N4);
+
+    assertThat(
+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);
   }
 
   @Test
@@ -143,11 +204,65 @@ public void transitiveClosure_undirectedPathGraph() {
     expectedClosure.putEdge(N3, N4);
     expectedClosure.putEdge(N4, N4);
 
-    checkTransitiveClosure(undirectedGraph, expectedClosure);
+    assertThat(
+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);
   }
 
   @Test
-  public void transitiveClosure_directedCycleGraph() {
+  public void transitiveClosure_undirectedPathGraph_addSelfLoopsForCycles() {
+    MutableGraph<Integer> undirectedGraph =
+        GraphBuilder.undirected().allowsSelfLoops(false).build();
+    undirectedGraph.putEdge(N1, N2);
+    undirectedGraph.putEdge(N2, N3);
+    undirectedGraph.putEdge(N3, N4);
+
+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();
+    expectedClosure.putEdge(N1, N1);
+    expectedClosure.putEdge(N1, N2);
+    expectedClosure.putEdge(N1, N3);
+    expectedClosure.putEdge(N1, N4);
+    expectedClosure.putEdge(N2, N2);
+    expectedClosure.putEdge(N2, N3);
+    expectedClosure.putEdge(N2, N4);
+    expectedClosure.putEdge(N3, N3);
+    expectedClosure.putEdge(N3, N4);
+    expectedClosure.putEdge(N4, N4);
+
+    assertThat(
+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);
+  }
+
+  @Test
+  public void transitiveClosure_directedCycleGraph_addSelfLoopsAlways() {
+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();
+    directedGraph.putEdge(N1, N2);
+    directedGraph.putEdge(N2, N3);
+    directedGraph.putEdge(N3, N4);
+    directedGraph.putEdge(N4, N1);
+
+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();
+    expectedClosure.putEdge(N1, N1);
+    expectedClosure.putEdge(N1, N2);
+    expectedClosure.putEdge(N1, N3);
+    expectedClosure.putEdge(N1, N4);
+    expectedClosure.putEdge(N2, N1);
+    expectedClosure.putEdge(N2, N2);
+    expectedClosure.putEdge(N2, N3);
+    expectedClosure.putEdge(N2, N4);
+    expectedClosure.putEdge(N3, N1);
+    expectedClosure.putEdge(N3, N2);
+    expectedClosure.putEdge(N3, N3);
+    expectedClosure.putEdge(N3, N4);
+    expectedClosure.putEdge(N4, N1);
+    expectedClosure.putEdge(N4, N2);
+    expectedClosure.putEdge(N4, N3);
+    expectedClosure.putEdge(N4, N4);
+
+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);
+  }
+
+  @Test
+  public void transitiveClosure_directedCycleGraph_addSelfLoopsForCycles() {
     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();
     directedGraph.putEdge(N1, N2);
     directedGraph.putEdge(N2, N3);
@@ -172,11 +287,37 @@ public void transitiveClosure_directedCycleGraph() {
     expectedClosure.putEdge(N4, N3);
     expectedClosure.putEdge(N4, N4);
 
-    checkTransitiveClosure(directedGraph, expectedClosure);
+    assertThat(
+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);
+  }
+
+  @Test
+  public void transitiveClosure_undirectedCycleGraph_addSelfLoopsAlways() {
+    MutableGraph<Integer> undirectedGraph =
+        GraphBuilder.undirected().allowsSelfLoops(false).build();
+    undirectedGraph.putEdge(N1, N2);
+    undirectedGraph.putEdge(N2, N3);
+    undirectedGraph.putEdge(N3, N4);
+    undirectedGraph.putEdge(N4, N1);
+
+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();
+    expectedClosure.putEdge(N1, N1);
+    expectedClosure.putEdge(N1, N2);
+    expectedClosure.putEdge(N1, N3);
+    expectedClosure.putEdge(N1, N4);
+    expectedClosure.putEdge(N2, N2);
+    expectedClosure.putEdge(N2, N3);
+    expectedClosure.putEdge(N2, N4);
+    expectedClosure.putEdge(N3, N3);
+    expectedClosure.putEdge(N3, N4);
+    expectedClosure.putEdge(N4, N4);
+
+    assertThat(
+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);
   }
 
   @Test
-  public void transitiveClosure_undirectedCycleGraph() {
+  public void transitiveClosure_undirectedCycleGraph_addSelfLoopsForCycles() {
     MutableGraph<Integer> undirectedGraph =
         GraphBuilder.undirected().allowsSelfLoops(false).build();
     undirectedGraph.putEdge(N1, N2);
@@ -196,7 +337,8 @@ public void transitiveClosure_undirectedCycleGraph() {
     expectedClosure.putEdge(N3, N4);
     expectedClosure.putEdge(N4, N4);
 
-    checkTransitiveClosure(undirectedGraph, expectedClosure);
+    assertThat(
+        transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);
   }
 
   @Test
@@ -334,7 +476,7 @@ public void transpose_directedNetwork() {
 
   @Test
   public void inducedSubgraph_graph() {
-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);
+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);
 
     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();
     directedGraph.putEdge(N1, N2);
@@ -353,7 +495,7 @@ public void inducedSubgraph_graph() {
 
   @Test
   public void inducedSubgraph_valueGraph() {
-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);
+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);
 
     MutableValueGraph<Integer, String> directedGraph =
         ValueGraphBuilder.directed().allowsSelfLoops(true).build();
@@ -374,7 +516,7 @@ public void inducedSubgraph_valueGraph() {
 
   @Test
   public void inducedSubgraph_network() {
-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);
+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);
 
     MutableNetwork<Integer, String> directedGraph =
         NetworkBuilder.directed().allowsSelfLoops(true).build();
@@ -570,13 +712,6 @@ public void builder_expectedEdgeCount_negative() {
     assertThat(e).hasMessageThat().contains(ERROR_NEGATIVE_COUNT);
   }
 
-  private static <N> void checkTransitiveClosure(Graph<N> originalGraph, Graph<N> expectedClosure) {
-    for (N node : originalGraph.nodes()) {
-      assertThat(reachableNodes(originalGraph, node)).isEqualTo(expectedClosure.successors(node));
-    }
-    assertThat(transitiveClosure(originalGraph)).isEqualTo(expectedClosure);
-  }
-
   private static MutableGraph<Integer> buildDirectedGraph() {
     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();
     directedGraph.putEdge(N1, N1);
diff --git a/android/guava/src/com/google/common/graph/Graphs.java b/android/guava/src/com/google/common/graph/Graphs.java
index bca410aaa209..ead5bdc90f87 100644
--- a/android/guava/src/com/google/common/graph/Graphs.java
+++ b/android/guava/src/com/google/common/graph/Graphs.java
@@ -18,18 +18,17 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.graph.GraphConstants.NODE_NOT_IN_GRAPH;
+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_ALWAYS;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Maps;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Objects;
@@ -174,51 +173,91 @@ private static boolean canTraverseWithoutReusingEdge(
   }
 
   /**
-   * Returns the transitive closure of {@code graph}. The transitive closure of a graph is another
-   * graph with an edge connecting node A to node B if node B is {@link #reachableNodes(Graph,
-   * Object) reachable} from node A.
+   * Returns the transitive closure of {@code graph}. The transitive closure of a graph {@code G} is
+   * a graph {@code T} that is a supergraph of {@code G}, augmented by, for each pair of nodes A and
+   * B, an edge connecting node A to node B if there is a sequence of edges in {@code G} starting at
+   * A and ending at B.
+   *
+   * <p>{@code strategy} defines the circumstances under which self-loops will be added to the
+   * transitive closure graph.
    *
    * <p>This is a "snapshot" based on the current topology of {@code graph}, rather than a live view
    * of the transitive closure of {@code graph}. In other words, the returned {@link Graph} will not
    * be updated after modifications to {@code graph}.
    *
-   * @since 33.1.0 (present with return type {@code Graph} since 20.0)
+   * @since NEXT
    */
-  // TODO(b/31438252): Consider potential optimizations for this algorithm.
-  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {
+  // TODO(b/31438252): Consider optimizing for undirected graphs.
+  public static <N> ImmutableGraph<N> transitiveClosure(
+      Graph<N> graph, TransitiveClosureSelfLoopStrategy strategy) {
     ImmutableGraph.Builder<N> transitiveClosure =
         GraphBuilder.from(graph).allowsSelfLoops(true).<N>immutable();
-    // Every node is, at a minimum, reachable from itself. Since the resulting transitive closure
-    // will have no isolated nodes, we can skip adding nodes explicitly and let putEdge() do it.
-
-    if (graph.isDirected()) {
-      // Note: works for both directed and undirected graphs, but we only use in the directed case.
-      for (N node : graph.nodes()) {
-        for (N reachableNode : reachableNodes(graph, node)) {
-          transitiveClosure.putEdge(node, reachableNode);
-        }
-      }
-    } else {
-      // An optimization for the undirected case: for every node B reachable from node A,
-      // node A and node B have the same reachability set.
-      Set<N> visitedNodes = new HashSet<>();
-      for (N node : graph.nodes()) {
-        if (!visitedNodes.contains(node)) {
-          Set<N> reachableNodes = reachableNodes(graph, node);
-          visitedNodes.addAll(reachableNodes);
-          int pairwiseMatch = 1; // start at 1 to include self-loops
-          for (N nodeU : reachableNodes) {
-            for (N nodeV : Iterables.limit(reachableNodes, pairwiseMatch++)) {
-              transitiveClosure.putEdge(nodeU, nodeV);
-            }
-          }
-        }
+
+    for (N node : graph.nodes()) {
+      // add each node explicitly to include isolated nodes
+      transitiveClosure.addNode(node);
+      for (N reachableNode : getReachableNodes(graph, node, strategy)) {
+        transitiveClosure.putEdge(node, reachableNode);
       }
     }
-
     return transitiveClosure.build();
   }
 
+  /**
+   * Equivalent to {@code transitiveClosure(graph, ADD_SELF_LOOPS_ALWAYS)}. Callers should look at
+   * the different strategy options that the new method supports rather than simply migrating to the
+   * new method with the existing behavior; we believe that most callers will want to use the {@code
+   * ADD_SELF_LOOPS_FOR_CYCLES} strategy.
+   *
+   * @since 33.1.0 (present with return type {@code Graph} since 20.0)
+   * @deprecated Use {@link #transitiveClosure(Graph, TransitiveClosureSelfLoopStrategy)} instead.
+   */
+  @SuppressWarnings("InlineMeSuggester") // We expect most users to want to change behavior.
+  @Deprecated
+  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {
+    return transitiveClosure(graph, ADD_SELF_LOOPS_ALWAYS);
+  }
+
+  /**
+   * Returns the nodes reachable from {@code node} in {@code graph}, according to the given {@code
+   * strategy}.
+   */
+  private static <N> Iterable<N> getReachableNodes(
+      Graph<N> graph, N node, TransitiveClosureSelfLoopStrategy strategy) {
+    Traverser<N> traverser = Traverser.forGraph(graph);
+    switch (strategy) {
+      case ADD_SELF_LOOPS_ALWAYS: // always include 'node'
+        return traverser.breadthFirst(node);
+      case ADD_SELF_LOOPS_FOR_CYCLES: // include 'node' iff there's an incident cycle
+        // note that if 'node' has a self-loop, it will appear in its successors
+        return traverser.breadthFirst(graph.successors(node));
+    }
+    throw new IllegalArgumentException("Unrecognized strategy: " + strategy);
+  }
+
+  /**
+   * A strategy for adding self-loops to {@linkplain #transitiveClosure(Graph,
+   * TransitiveClosureSelfLoopStrategy) the transitive closure graph}. All strategies preserve
+   * self-loops that are present in the original graph.
+   *
+   * <p>The strategies differ based on how they define "cycle incident to a node".
+   *
+   * @since NEXT
+   */
+  public enum TransitiveClosureSelfLoopStrategy {
+    /**
+     * Add a self-loop to each node in the original graph; this is based on a definition of "cycle
+     * incident to a node" that includes zero-length cycles. This matches the behavior of the
+     * now-deprecated {@link #transitiveClosure(Graph)} method.
+     */
+    ADD_SELF_LOOPS_ALWAYS,
+    /**
+     * Add a self-loop to each node that is incident to a cycle of length one or greater in the
+     * original graph.
+     */
+    ADD_SELF_LOOPS_FOR_CYCLES
+  }
+
   /**
    * Returns the set of nodes that are reachable from {@code node}. Specifically, it returns all
    * nodes {@code v} such that there exists a path (a sequence of adjacent outgoing edges) starting
diff --git a/guava-tests/test/com/google/common/graph/GraphsTest.java b/guava-tests/test/com/google/common/graph/GraphsTest.java
index 4be09009d080..15d5f13bdcfd 100644
--- a/guava-tests/test/com/google/common/graph/GraphsTest.java
+++ b/guava-tests/test/com/google/common/graph/GraphsTest.java
@@ -16,16 +16,16 @@
 
 package com.google.common.graph;
 
+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_ALWAYS;
+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_FOR_CYCLES;
 import static com.google.common.graph.Graphs.copyOf;
 import static com.google.common.graph.Graphs.inducedSubgraph;
-import static com.google.common.graph.Graphs.reachableNodes;
 import static com.google.common.graph.Graphs.transitiveClosure;
 import static com.google.common.graph.Graphs.transpose;
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
 import com.google.common.collect.ImmutableSet;
-import java.util.Set;
 import org.jspecify.annotations.NullUnmarked;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -61,7 +61,7 @@ public class GraphsTest {
   static final String ERROR_SELF_LOOP = "self-loops are not allowed";
 
   @Test
-  public void transitiveClosure_directedGraph() {
+  public void transitiveClosure_directedGraph_addSelfLoopsAlways() {
     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();
     directedGraph.putEdge(N1, N2);
     directedGraph.putEdge(N1, N3);
@@ -77,11 +77,30 @@ public void transitiveClosure_directedGraph() {
     expectedClosure.putEdge(N3, N3);
     expectedClosure.putEdge(N4, N4);
 
-    checkTransitiveClosure(directedGraph, expectedClosure);
+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);
   }
 
   @Test
-  public void transitiveClosure_undirectedGraph() {
+  public void transitiveClosure_directedGraph_addSelfLoopsForCycles() {
+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();
+    directedGraph.putEdge(N1, N2);
+    directedGraph.putEdge(N1, N3);
+    directedGraph.putEdge(N2, N3);
+    directedGraph.addNode(N4);
+
+    // the above graph is its own transitive closure
+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();
+    expectedClosure.putEdge(N1, N2);
+    expectedClosure.putEdge(N1, N3);
+    expectedClosure.putEdge(N2, N3);
+    expectedClosure.addNode(N4);
+
+    assertThat(
+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);
+  }
+
+  @Test
+  public void transitiveClosure_undirectedGraph_addSelfLoopsAlways() {
     MutableGraph<Integer> undirectedGraph =
         GraphBuilder.undirected().allowsSelfLoops(false).build();
     undirectedGraph.putEdge(N1, N2);
@@ -98,11 +117,34 @@ public void transitiveClosure_undirectedGraph() {
     expectedClosure.putEdge(N3, N3);
     expectedClosure.putEdge(N4, N4);
 
-    checkTransitiveClosure(undirectedGraph, expectedClosure);
+    assertThat(
+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);
   }
 
   @Test
-  public void transitiveClosure_directedPathGraph() {
+  public void transitiveClosure_undirectedGraph_addSelfLoopsForCycles() {
+    MutableGraph<Integer> undirectedGraph =
+        GraphBuilder.undirected().allowsSelfLoops(false).build();
+    undirectedGraph.putEdge(N1, N2);
+    undirectedGraph.putEdge(N1, N3);
+    undirectedGraph.putEdge(N2, N3);
+    undirectedGraph.addNode(N4);
+
+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();
+    expectedClosure.putEdge(N1, N1);
+    expectedClosure.putEdge(N1, N2);
+    expectedClosure.putEdge(N1, N3);
+    expectedClosure.putEdge(N2, N2);
+    expectedClosure.putEdge(N2, N3);
+    expectedClosure.putEdge(N3, N3);
+    expectedClosure.addNode(N4); // N4 is isolated => no incident edges in this transitive closure
+
+    assertThat(
+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);
+  }
+
+  @Test
+  public void transitiveClosure_directedPathGraph_addSelfLoopsAlways() {
     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();
     directedGraph.putEdge(N1, N2);
     directedGraph.putEdge(N2, N3);
@@ -120,7 +162,26 @@ public void transitiveClosure_directedPathGraph() {
     expectedClosure.putEdge(N3, N4);
     expectedClosure.putEdge(N4, N4);
 
-    checkTransitiveClosure(directedGraph, expectedClosure);
+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);
+  }
+
+  @Test
+  public void transitiveClosure_directedPathGraph_addSelfLoopsForCycles() {
+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();
+    directedGraph.putEdge(N1, N2);
+    directedGraph.putEdge(N2, N3);
+    directedGraph.putEdge(N3, N4);
+
+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();
+    expectedClosure.putEdge(N1, N2);
+    expectedClosure.putEdge(N1, N3);
+    expectedClosure.putEdge(N1, N4);
+    expectedClosure.putEdge(N2, N3);
+    expectedClosure.putEdge(N2, N4);
+    expectedClosure.putEdge(N3, N4);
+
+    assertThat(
+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);
   }
 
   @Test
@@ -143,11 +204,65 @@ public void transitiveClosure_undirectedPathGraph() {
     expectedClosure.putEdge(N3, N4);
     expectedClosure.putEdge(N4, N4);
 
-    checkTransitiveClosure(undirectedGraph, expectedClosure);
+    assertThat(
+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);
   }
 
   @Test
-  public void transitiveClosure_directedCycleGraph() {
+  public void transitiveClosure_undirectedPathGraph_addSelfLoopsForCycles() {
+    MutableGraph<Integer> undirectedGraph =
+        GraphBuilder.undirected().allowsSelfLoops(false).build();
+    undirectedGraph.putEdge(N1, N2);
+    undirectedGraph.putEdge(N2, N3);
+    undirectedGraph.putEdge(N3, N4);
+
+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();
+    expectedClosure.putEdge(N1, N1);
+    expectedClosure.putEdge(N1, N2);
+    expectedClosure.putEdge(N1, N3);
+    expectedClosure.putEdge(N1, N4);
+    expectedClosure.putEdge(N2, N2);
+    expectedClosure.putEdge(N2, N3);
+    expectedClosure.putEdge(N2, N4);
+    expectedClosure.putEdge(N3, N3);
+    expectedClosure.putEdge(N3, N4);
+    expectedClosure.putEdge(N4, N4);
+
+    assertThat(
+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);
+  }
+
+  @Test
+  public void transitiveClosure_directedCycleGraph_addSelfLoopsAlways() {
+    MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();
+    directedGraph.putEdge(N1, N2);
+    directedGraph.putEdge(N2, N3);
+    directedGraph.putEdge(N3, N4);
+    directedGraph.putEdge(N4, N1);
+
+    MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();
+    expectedClosure.putEdge(N1, N1);
+    expectedClosure.putEdge(N1, N2);
+    expectedClosure.putEdge(N1, N3);
+    expectedClosure.putEdge(N1, N4);
+    expectedClosure.putEdge(N2, N1);
+    expectedClosure.putEdge(N2, N2);
+    expectedClosure.putEdge(N2, N3);
+    expectedClosure.putEdge(N2, N4);
+    expectedClosure.putEdge(N3, N1);
+    expectedClosure.putEdge(N3, N2);
+    expectedClosure.putEdge(N3, N3);
+    expectedClosure.putEdge(N3, N4);
+    expectedClosure.putEdge(N4, N1);
+    expectedClosure.putEdge(N4, N2);
+    expectedClosure.putEdge(N4, N3);
+    expectedClosure.putEdge(N4, N4);
+
+    assertThat(transitiveClosure(directedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);
+  }
+
+  @Test
+  public void transitiveClosure_directedCycleGraph_addSelfLoopsForCycles() {
     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build();
     directedGraph.putEdge(N1, N2);
     directedGraph.putEdge(N2, N3);
@@ -172,11 +287,37 @@ public void transitiveClosure_directedCycleGraph() {
     expectedClosure.putEdge(N4, N3);
     expectedClosure.putEdge(N4, N4);
 
-    checkTransitiveClosure(directedGraph, expectedClosure);
+    assertThat(
+        transitiveClosure(directedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);
+  }
+
+  @Test
+  public void transitiveClosure_undirectedCycleGraph_addSelfLoopsAlways() {
+    MutableGraph<Integer> undirectedGraph =
+        GraphBuilder.undirected().allowsSelfLoops(false).build();
+    undirectedGraph.putEdge(N1, N2);
+    undirectedGraph.putEdge(N2, N3);
+    undirectedGraph.putEdge(N3, N4);
+    undirectedGraph.putEdge(N4, N1);
+
+    MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();
+    expectedClosure.putEdge(N1, N1);
+    expectedClosure.putEdge(N1, N2);
+    expectedClosure.putEdge(N1, N3);
+    expectedClosure.putEdge(N1, N4);
+    expectedClosure.putEdge(N2, N2);
+    expectedClosure.putEdge(N2, N3);
+    expectedClosure.putEdge(N2, N4);
+    expectedClosure.putEdge(N3, N3);
+    expectedClosure.putEdge(N3, N4);
+    expectedClosure.putEdge(N4, N4);
+
+    assertThat(
+      transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_ALWAYS)).isEqualTo(expectedClosure);
   }
 
   @Test
-  public void transitiveClosure_undirectedCycleGraph() {
+  public void transitiveClosure_undirectedCycleGraph_addSelfLoopsForCycles() {
     MutableGraph<Integer> undirectedGraph =
         GraphBuilder.undirected().allowsSelfLoops(false).build();
     undirectedGraph.putEdge(N1, N2);
@@ -196,7 +337,8 @@ public void transitiveClosure_undirectedCycleGraph() {
     expectedClosure.putEdge(N3, N4);
     expectedClosure.putEdge(N4, N4);
 
-    checkTransitiveClosure(undirectedGraph, expectedClosure);
+    assertThat(
+        transitiveClosure(undirectedGraph, ADD_SELF_LOOPS_FOR_CYCLES)).isEqualTo(expectedClosure);
   }
 
   @Test
@@ -335,7 +477,7 @@ public void transpose_directedNetwork() {
 
   @Test
   public void inducedSubgraph_graph() {
-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);
+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);
 
     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();
     directedGraph.putEdge(N1, N2);
@@ -354,7 +496,7 @@ public void inducedSubgraph_graph() {
 
   @Test
   public void inducedSubgraph_valueGraph() {
-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);
+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);
 
     MutableValueGraph<Integer, String> directedGraph =
         ValueGraphBuilder.directed().allowsSelfLoops(true).build();
@@ -375,7 +517,7 @@ public void inducedSubgraph_valueGraph() {
 
   @Test
   public void inducedSubgraph_network() {
-    Set<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);
+    ImmutableSet<Integer> nodeSubset = ImmutableSet.of(N1, N2, N4);
 
     MutableNetwork<Integer, String> directedGraph =
         NetworkBuilder.directed().allowsSelfLoops(true).build();
@@ -571,13 +713,6 @@ public void builder_expectedEdgeCount_negative() {
     assertThat(e).hasMessageThat().contains(ERROR_NEGATIVE_COUNT);
   }
 
-  private static <N> void checkTransitiveClosure(Graph<N> originalGraph, Graph<N> expectedClosure) {
-    for (N node : originalGraph.nodes()) {
-      assertThat(reachableNodes(originalGraph, node)).isEqualTo(expectedClosure.successors(node));
-    }
-    assertThat(transitiveClosure(originalGraph)).isEqualTo(expectedClosure);
-  }
-
   private static MutableGraph<Integer> buildDirectedGraph() {
     MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(true).build();
     directedGraph.putEdge(N1, N1);
diff --git a/guava/src/com/google/common/graph/Graphs.java b/guava/src/com/google/common/graph/Graphs.java
index 2b0e7eb83298..ee54e392c1de 100644
--- a/guava/src/com/google/common/graph/Graphs.java
+++ b/guava/src/com/google/common/graph/Graphs.java
@@ -18,18 +18,17 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.graph.GraphConstants.NODE_NOT_IN_GRAPH;
+import static com.google.common.graph.Graphs.TransitiveClosureSelfLoopStrategy.ADD_SELF_LOOPS_ALWAYS;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.Beta;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Maps;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Objects;
@@ -175,51 +174,91 @@ private static boolean canTraverseWithoutReusingEdge(
   }
 
   /**
-   * Returns the transitive closure of {@code graph}. The transitive closure of a graph is another
-   * graph with an edge connecting node A to node B if node B is {@link #reachableNodes(Graph,
-   * Object) reachable} from node A.
+   * Returns the transitive closure of {@code graph}. The transitive closure of a graph {@code G} is
+   * a graph {@code T} that is a supergraph of {@code G}, augmented by, for each pair of nodes A and
+   * B, an edge connecting node A to node B if there is a sequence of edges in {@code G} starting at
+   * A and ending at B.
+   *
+   * <p>{@code strategy} defines the circumstances under which self-loops will be added to the
+   * transitive closure graph.
    *
    * <p>This is a "snapshot" based on the current topology of {@code graph}, rather than a live view
    * of the transitive closure of {@code graph}. In other words, the returned {@link Graph} will not
    * be updated after modifications to {@code graph}.
    *
-   * @since 33.1.0 (present with return type {@code Graph} since 20.0)
+   * @since NEXT
    */
-  // TODO(b/31438252): Consider potential optimizations for this algorithm.
-  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {
+  // TODO(b/31438252): Consider optimizing for undirected graphs.
+  public static <N> ImmutableGraph<N> transitiveClosure(
+      Graph<N> graph, TransitiveClosureSelfLoopStrategy strategy) {
     ImmutableGraph.Builder<N> transitiveClosure =
         GraphBuilder.from(graph).allowsSelfLoops(true).<N>immutable();
-    // Every node is, at a minimum, reachable from itself. Since the resulting transitive closure
-    // will have no isolated nodes, we can skip adding nodes explicitly and let putEdge() do it.
-
-    if (graph.isDirected()) {
-      // Note: works for both directed and undirected graphs, but we only use in the directed case.
-      for (N node : graph.nodes()) {
-        for (N reachableNode : reachableNodes(graph, node)) {
-          transitiveClosure.putEdge(node, reachableNode);
-        }
-      }
-    } else {
-      // An optimization for the undirected case: for every node B reachable from node A,
-      // node A and node B have the same reachability set.
-      Set<N> visitedNodes = new HashSet<>();
-      for (N node : graph.nodes()) {
-        if (!visitedNodes.contains(node)) {
-          Set<N> reachableNodes = reachableNodes(graph, node);
-          visitedNodes.addAll(reachableNodes);
-          int pairwiseMatch = 1; // start at 1 to include self-loops
-          for (N nodeU : reachableNodes) {
-            for (N nodeV : Iterables.limit(reachableNodes, pairwiseMatch++)) {
-              transitiveClosure.putEdge(nodeU, nodeV);
-            }
-          }
-        }
+
+    for (N node : graph.nodes()) {
+      // add each node explicitly to include isolated nodes
+      transitiveClosure.addNode(node);
+      for (N reachableNode : getReachableNodes(graph, node, strategy)) {
+        transitiveClosure.putEdge(node, reachableNode);
       }
     }
-
     return transitiveClosure.build();
   }
 
+  /**
+   * Equivalent to {@code transitiveClosure(graph, ADD_SELF_LOOPS_ALWAYS)}. Callers should look at
+   * the different strategy options that the new method supports rather than simply migrating to the
+   * new method with the existing behavior; we believe that most callers will want to use the {@code
+   * ADD_SELF_LOOPS_FOR_CYCLES} strategy.
+   *
+   * @since 33.1.0 (present with return type {@code Graph} since 20.0)
+   * @deprecated Use {@link #transitiveClosure(Graph, TransitiveClosureSelfLoopStrategy)} instead.
+   */
+  @SuppressWarnings("InlineMeSuggester") // We expect most users to want to change behavior.
+  @Deprecated
+  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {
+    return transitiveClosure(graph, ADD_SELF_LOOPS_ALWAYS);
+  }
+
+  /**
+   * Returns the nodes reachable from {@code node} in {@code graph}, according to the given {@code
+   * strategy}.
+   */
+  private static <N> Iterable<N> getReachableNodes(
+      Graph<N> graph, N node, TransitiveClosureSelfLoopStrategy strategy) {
+    Traverser<N> traverser = Traverser.forGraph(graph);
+    switch (strategy) {
+      case ADD_SELF_LOOPS_ALWAYS: // always include 'node'
+        return traverser.breadthFirst(node);
+      case ADD_SELF_LOOPS_FOR_CYCLES: // include 'node' iff there's an incident cycle
+        // note that if 'node' has a self-loop, it will appear in its successors
+        return traverser.breadthFirst(graph.successors(node));
+    }
+    throw new IllegalArgumentException("Unrecognized strategy: " + strategy);
+  }
+
+  /**
+   * A strategy for adding self-loops to {@linkplain #transitiveClosure(Graph,
+   * TransitiveClosureSelfLoopStrategy) the transitive closure graph}. All strategies preserve
+   * self-loops that are present in the original graph.
+   *
+   * <p>The strategies differ based on how they define "cycle incident to a node".
+   *
+   * @since NEXT
+   */
+  public enum TransitiveClosureSelfLoopStrategy {
+    /**
+     * Add a self-loop to each node in the original graph; this is based on a definition of "cycle
+     * incident to a node" that includes zero-length cycles. This matches the behavior of the
+     * now-deprecated {@link #transitiveClosure(Graph)} method.
+     */
+    ADD_SELF_LOOPS_ALWAYS,
+    /**
+     * Add a self-loop to each node that is incident to a cycle of length one or greater in the
+     * original graph.
+     */
+    ADD_SELF_LOOPS_FOR_CYCLES
+  }
+
   /**
    * Returns the set of nodes that are reachable from {@code node}. Specifically, it returns all
    * nodes {@code v} such that there exists a path (a sequence of adjacent outgoing edges) starting
