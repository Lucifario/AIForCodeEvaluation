{
  "id": 8015,
  "repository": "google/guava",
  "title": "Remove some unnecessary type arguments.",
  "body": "Remove some unnecessary type arguments.\n\nThis is another CL that comes courtesy of IntelliJ, which even removed unnecessary type arguments _in Javadoc_.\n\nI then went through the file and removed some unnecessary `Maps.` qualifiers from usages in this file. This isn't even a case of using static imports; this is just a case of not writing things like `Maps.keyFunction` when we're inside `Maps`. I did need to leave the qualifier in place for a nested class's `class KeySet extends Maps.KeySet<K, V>` for obvious reasons.\n\nRELNOTES=n/a\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-09-22T21:11:30+00:00",
  "created_at": "2025-09-22T20:46:56+00:00",
  "updated_at": "2025-09-22T21:11:30+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "c1ffb313fd084c865e539c9b6dc795edade21d6a",
  "head_sha": "cb0e7e0cb1c62012934d998ca4d0222a758a9831",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava/src/com/google/common/collect/Maps.java",
      "status": "modified",
      "additions": 33,
      "deletions": 40,
      "changes": 73,
      "patch": "@@ -531,7 +531,7 @@ MapDifference<K, V> difference(\n     Map<K, V> onlyOnLeft = new LinkedHashMap<>();\n     Map<K, V> onlyOnRight = new LinkedHashMap<>(right); // will whittle it down\n     Map<K, V> onBoth = new LinkedHashMap<>();\n-    Map<K, MapDifference.ValueDifference<V>> differences = new LinkedHashMap<>();\n+    Map<K, ValueDifference<V>> differences = new LinkedHashMap<>();\n     doDifference(left, right, valueEquivalence, onlyOnLeft, onlyOnRight, onBoth, differences);\n     return new MapDifferenceImpl<>(onlyOnLeft, onlyOnRight, onBoth, differences);\n   }\n@@ -559,11 +559,11 @@ SortedMapDifference<K, V> difference(\n     checkNotNull(left);\n     checkNotNull(right);\n     Comparator<? super K> comparator = orNaturalOrder(left.comparator());\n-    SortedMap<K, V> onlyOnLeft = Maps.newTreeMap(comparator);\n-    SortedMap<K, V> onlyOnRight = Maps.newTreeMap(comparator);\n+    SortedMap<K, V> onlyOnLeft = newTreeMap(comparator);\n+    SortedMap<K, V> onlyOnRight = newTreeMap(comparator);\n     onlyOnRight.putAll(right); // will whittle it down\n-    SortedMap<K, V> onBoth = Maps.newTreeMap(comparator);\n-    SortedMap<K, MapDifference.ValueDifference<V>> differences = Maps.newTreeMap(comparator);\n+    SortedMap<K, V> onBoth = newTreeMap(comparator);\n+    SortedMap<K, ValueDifference<V>> differences = newTreeMap(comparator);\n \n     doDifference(left, right, Equivalence.equals(), onlyOnLeft, onlyOnRight, onBoth, differences);\n     return new SortedMapDifferenceImpl<>(onlyOnLeft, onlyOnRight, onBoth, differences);\n@@ -576,7 +576,7 @@ SortedMapDifference<K, V> difference(\n       Map<K, V> onlyOnLeft,\n       Map<K, V> onlyOnRight,\n       Map<K, V> onBoth,\n-      Map<K, MapDifference.ValueDifference<V>> differences) {\n+      Map<K, ValueDifference<V>> differences) {\n     for (Entry<? extends K, ? extends V> entry : left.entrySet()) {\n       K leftKey = entry.getKey();\n       V leftValue = entry.getValue();\n@@ -696,8 +696,7 @@ public String toString() {\n     }\n   }\n \n-  static final class ValueDifferenceImpl<V extends @Nullable Object>\n-      implements MapDifference.ValueDifference<V> {\n+  static final class ValueDifferenceImpl<V extends @Nullable Object> implements ValueDifference<V> {\n     @ParametricNullness private final V left;\n     @ParametricNullness private final V right;\n \n@@ -725,8 +724,8 @@ public V rightValue() {\n \n     @Override\n     public boolean equals(@Nullable Object object) {\n-      if (object instanceof MapDifference.ValueDifference) {\n-        MapDifference.ValueDifference<?> that = (MapDifference.ValueDifference<?>) object;\n+      if (object instanceof ValueDifference) {\n+        ValueDifference<?> that = (ValueDifference<?>) object;\n         return Objects.equals(this.left, that.leftValue())\n             && Objects.equals(this.right, that.rightValue());\n       }\n@@ -1627,8 +1626,7 @@ public String toString() {\n    * of its collection views:\n    *\n    * {@snippet :\n-   * BiMap<Long, String> map = Maps.synchronizedBiMap(\n-   *     HashBiMap.<Long, String>create());\n+   * BiMap<Long, String> map = Maps.synchronizedBiMap(HashBiMap.create());\n    * ...\n    * Set<Long> set = map.keySet();  // Needn't be in synchronized block\n    * ...\n@@ -2109,7 +2107,7 @@ public Set<K> keySet() {\n     @Override\n     Iterator<Entry<K, V2>> entryIterator() {\n       return Iterators.transform(\n-          fromMap.entrySet().iterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));\n+          fromMap.entrySet().iterator(), asEntryToEntryFunction(transformer));\n     }\n \n     @Override\n@@ -2296,12 +2294,12 @@ protected NavigableMap<K, V1> fromMap() {\n \n   static <K extends @Nullable Object> Predicate<Entry<K, ?>> keyPredicateOnEntries(\n       Predicate<? super K> keyPredicate) {\n-    return compose(keyPredicate, Maps.<K>keyFunction());\n+    return compose(keyPredicate, keyFunction());\n   }\n \n   static <V extends @Nullable Object> Predicate<Entry<?, V>> valuePredicateOnEntries(\n       Predicate<? super V> valuePredicate) {\n-    return compose(valuePredicate, Maps.<V>valueFunction());\n+    return compose(valuePredicate, valueFunction());\n   }\n \n   /**\n@@ -2364,9 +2362,8 @@ protected NavigableMap<K, V1> fromMap() {\n    */\n   public static <K extends @Nullable Object, V extends @Nullable Object> SortedMap<K, V> filterKeys(\n       SortedMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {\n-    // TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better\n-    // performance.\n-    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n+    // TODO(lowasser): Return a subclass of FilteredKeyMap for slightly better performance.\n+    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));\n   }\n \n   /**\n@@ -2399,9 +2396,8 @@ protected NavigableMap<K, V1> fromMap() {\n   public static <K extends @Nullable Object, V extends @Nullable Object>\n       NavigableMap<K, V> filterKeys(\n           NavigableMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {\n-    // TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better\n-    // performance.\n-    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n+    // TODO(lowasser): Return a subclass of FilteredKeyMap for slightly better performance.\n+    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));\n   }\n \n   /**\n@@ -2431,7 +2427,7 @@ NavigableMap<K, V> filterKeys(\n   public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterKeys(\n       BiMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {\n     checkNotNull(keyPredicate);\n-    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n+    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));\n   }\n \n   /**\n@@ -2459,7 +2455,7 @@ NavigableMap<K, V> filterKeys(\n    */\n   public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterValues(\n       Map<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2491,7 +2487,7 @@ NavigableMap<K, V> filterKeys(\n   public static <K extends @Nullable Object, V extends @Nullable Object>\n       SortedMap<K, V> filterValues(\n           SortedMap<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2524,7 +2520,7 @@ SortedMap<K, V> filterValues(\n   public static <K extends @Nullable Object, V extends @Nullable Object>\n       NavigableMap<K, V> filterValues(\n           NavigableMap<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2556,7 +2552,7 @@ NavigableMap<K, V> filterValues(\n    */\n   public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterValues(\n       BiMap<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2704,8 +2700,7 @@ NavigableMap<K, V> filterEntries(\n    */\n   private static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterFiltered(\n       AbstractFilteredMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    return new FilteredEntryMap<>(\n-        map.unfiltered, Predicates.<Entry<K, V>>and(map.predicate, entryPredicate));\n+    return new FilteredEntryMap<>(map.unfiltered, Predicates.and(map.predicate, entryPredicate));\n   }\n \n   /**\n@@ -2715,7 +2710,7 @@ NavigableMap<K, V> filterEntries(\n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       SortedMap<K, V> filterFiltered(\n           FilteredEntrySortedMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);\n+    Predicate<Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);\n     return new FilteredEntrySortedMap<>(map.sortedMap(), predicate);\n   }\n \n@@ -2727,8 +2722,7 @@ SortedMap<K, V> filterFiltered(\n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       NavigableMap<K, V> filterFiltered(\n           FilteredEntryNavigableMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    Predicate<Entry<K, V>> predicate =\n-        Predicates.<Entry<K, V>>and(map.entryPredicate, entryPredicate);\n+    Predicate<Entry<K, V>> predicate = Predicates.and(map.entryPredicate, entryPredicate);\n     return new FilteredEntryNavigableMap<>(map.unfiltered, predicate);\n   }\n \n@@ -2739,7 +2733,7 @@ NavigableMap<K, V> filterFiltered(\n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       BiMap<K, V> filterFiltered(\n           FilteredEntryBiMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);\n+    Predicate<Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);\n     return new FilteredEntryBiMap<>(map.unfiltered(), predicate);\n   }\n \n@@ -2805,7 +2799,7 @@ Collection<V> createValues() {\n \n   private static final class FilteredMapValues<\n           K extends @Nullable Object, V extends @Nullable Object>\n-      extends Maps.Values<K, V> {\n+      extends Values<K, V> {\n     final Map<K, V> unfiltered;\n     final Predicate<? super Entry<K, V>> predicate;\n \n@@ -3151,7 +3145,7 @@ private static final class FilteredEntryNavigableMap<\n \n     @Override\n     public NavigableSet<K> navigableKeySet() {\n-      return new Maps.NavigableKeySet<K, V>(this) {\n+      return new NavigableKeySet<K, V>(this) {\n         @Override\n         public boolean removeAll(Collection<?> collection) {\n           return FilteredEntryMap.removeAllKeys(unfiltered, entryPredicate, collection);\n@@ -3336,7 +3330,7 @@ NavigableMap<K, V> unmodifiableNavigableMap(NavigableMap<K, ? extends V> map) {\n \n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       @Nullable Entry<K, V> unmodifiableOrNull(@Nullable Entry<K, ? extends V> entry) {\n-    return (entry == null) ? null : Maps.unmodifiableEntry(entry);\n+    return (entry == null) ? null : unmodifiableEntry(entry);\n   }\n \n   @GwtIncompatible // NavigableMap\n@@ -3456,8 +3450,7 @@ public NavigableMap<K, V> subMap(\n         boolean fromInclusive,\n         @ParametricNullness K toKey,\n         boolean toInclusive) {\n-      return Maps.unmodifiableNavigableMap(\n-          delegate.subMap(fromKey, fromInclusive, toKey, toInclusive));\n+      return unmodifiableNavigableMap(delegate.subMap(fromKey, fromInclusive, toKey, toInclusive));\n     }\n \n     @Override\n@@ -3467,7 +3460,7 @@ public SortedMap<K, V> headMap(@ParametricNullness K toKey) {\n \n     @Override\n     public NavigableMap<K, V> headMap(@ParametricNullness K toKey, boolean inclusive) {\n-      return Maps.unmodifiableNavigableMap(delegate.headMap(toKey, inclusive));\n+      return unmodifiableNavigableMap(delegate.headMap(toKey, inclusive));\n     }\n \n     @Override\n@@ -3477,7 +3470,7 @@ public SortedMap<K, V> tailMap(@ParametricNullness K fromKey) {\n \n     @Override\n     public NavigableMap<K, V> tailMap(@ParametricNullness K fromKey, boolean inclusive) {\n-      return Maps.unmodifiableNavigableMap(delegate.tailMap(fromKey, inclusive));\n+      return unmodifiableNavigableMap(delegate.tailMap(fromKey, inclusive));\n     }\n   }\n \n@@ -4021,7 +4014,7 @@ public boolean contains(@Nullable Object o) {\n       if (o instanceof Entry) {\n         Entry<?, ?> entry = (Entry<?, ?>) o;\n         Object key = entry.getKey();\n-        V value = Maps.safeGet(map(), key);\n+        V value = safeGet(map(), key);\n         return Objects.equals(value, entry.getValue()) && (value != null || map().containsKey(key));\n       }\n       return false;"
    },
    {
      "filename": "guava/src/com/google/common/collect/Maps.java",
      "status": "modified",
      "additions": 34,
      "deletions": 41,
      "changes": 75,
      "patch": "@@ -534,7 +534,7 @@ MapDifference<K, V> difference(\n     Map<K, V> onlyOnLeft = new LinkedHashMap<>();\n     Map<K, V> onlyOnRight = new LinkedHashMap<>(right); // will whittle it down\n     Map<K, V> onBoth = new LinkedHashMap<>();\n-    Map<K, MapDifference.ValueDifference<V>> differences = new LinkedHashMap<>();\n+    Map<K, ValueDifference<V>> differences = new LinkedHashMap<>();\n     doDifference(left, right, valueEquivalence, onlyOnLeft, onlyOnRight, onBoth, differences);\n     return new MapDifferenceImpl<>(onlyOnLeft, onlyOnRight, onBoth, differences);\n   }\n@@ -562,11 +562,11 @@ SortedMapDifference<K, V> difference(\n     checkNotNull(left);\n     checkNotNull(right);\n     Comparator<? super K> comparator = orNaturalOrder(left.comparator());\n-    SortedMap<K, V> onlyOnLeft = Maps.newTreeMap(comparator);\n-    SortedMap<K, V> onlyOnRight = Maps.newTreeMap(comparator);\n+    SortedMap<K, V> onlyOnLeft = newTreeMap(comparator);\n+    SortedMap<K, V> onlyOnRight = newTreeMap(comparator);\n     onlyOnRight.putAll(right); // will whittle it down\n-    SortedMap<K, V> onBoth = Maps.newTreeMap(comparator);\n-    SortedMap<K, MapDifference.ValueDifference<V>> differences = Maps.newTreeMap(comparator);\n+    SortedMap<K, V> onBoth = newTreeMap(comparator);\n+    SortedMap<K, ValueDifference<V>> differences = newTreeMap(comparator);\n \n     doDifference(left, right, Equivalence.equals(), onlyOnLeft, onlyOnRight, onBoth, differences);\n     return new SortedMapDifferenceImpl<>(onlyOnLeft, onlyOnRight, onBoth, differences);\n@@ -579,7 +579,7 @@ SortedMapDifference<K, V> difference(\n       Map<K, V> onlyOnLeft,\n       Map<K, V> onlyOnRight,\n       Map<K, V> onBoth,\n-      Map<K, MapDifference.ValueDifference<V>> differences) {\n+      Map<K, ValueDifference<V>> differences) {\n     for (Entry<? extends K, ? extends V> entry : left.entrySet()) {\n       K leftKey = entry.getKey();\n       V leftValue = entry.getValue();\n@@ -699,8 +699,7 @@ public String toString() {\n     }\n   }\n \n-  static final class ValueDifferenceImpl<V extends @Nullable Object>\n-      implements MapDifference.ValueDifference<V> {\n+  static final class ValueDifferenceImpl<V extends @Nullable Object> implements ValueDifference<V> {\n     @ParametricNullness private final V left;\n     @ParametricNullness private final V right;\n \n@@ -728,8 +727,8 @@ public V rightValue() {\n \n     @Override\n     public boolean equals(@Nullable Object object) {\n-      if (object instanceof MapDifference.ValueDifference) {\n-        MapDifference.ValueDifference<?> that = (MapDifference.ValueDifference<?>) object;\n+      if (object instanceof ValueDifference) {\n+        ValueDifference<?> that = (ValueDifference<?>) object;\n         return Objects.equals(this.left, that.leftValue())\n             && Objects.equals(this.right, that.rightValue());\n       }\n@@ -1657,8 +1656,7 @@ public String toString() {\n    * of its collection views:\n    *\n    * {@snippet :\n-   * BiMap<Long, String> map = Maps.synchronizedBiMap(\n-   *     HashBiMap.<Long, String>create());\n+   * BiMap<Long, String> map = Maps.synchronizedBiMap(HashBiMap.create());\n    * ...\n    * Set<Long> set = map.keySet();  // Needn't be in synchronized block\n    * ...\n@@ -2197,13 +2195,13 @@ public Set<K> keySet() {\n     @Override\n     Iterator<Entry<K, V2>> entryIterator() {\n       return Iterators.transform(\n-          fromMap.entrySet().iterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));\n+          fromMap.entrySet().iterator(), asEntryToEntryFunction(transformer));\n     }\n \n     @Override\n     Spliterator<Entry<K, V2>> entrySpliterator() {\n       return CollectSpliterators.map(\n-          fromMap.entrySet().spliterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));\n+          fromMap.entrySet().spliterator(), asEntryToEntryFunction(transformer));\n     }\n \n     @Override\n@@ -2397,12 +2395,12 @@ protected NavigableMap<K, V1> fromMap() {\n \n   static <K extends @Nullable Object> Predicate<Entry<K, ?>> keyPredicateOnEntries(\n       Predicate<? super K> keyPredicate) {\n-    return compose(keyPredicate, Maps.<K>keyFunction());\n+    return compose(keyPredicate, keyFunction());\n   }\n \n   static <V extends @Nullable Object> Predicate<Entry<?, V>> valuePredicateOnEntries(\n       Predicate<? super V> valuePredicate) {\n-    return compose(valuePredicate, Maps.<V>valueFunction());\n+    return compose(valuePredicate, valueFunction());\n   }\n \n   /**\n@@ -2465,9 +2463,8 @@ protected NavigableMap<K, V1> fromMap() {\n    */\n   public static <K extends @Nullable Object, V extends @Nullable Object> SortedMap<K, V> filterKeys(\n       SortedMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {\n-    // TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better\n-    // performance.\n-    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n+    // TODO(lowasser): Return a subclass of FilteredKeyMap for slightly better performance.\n+    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));\n   }\n \n   /**\n@@ -2500,9 +2497,8 @@ protected NavigableMap<K, V1> fromMap() {\n   public static <K extends @Nullable Object, V extends @Nullable Object>\n       NavigableMap<K, V> filterKeys(\n           NavigableMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {\n-    // TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better\n-    // performance.\n-    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n+    // TODO(lowasser): Return a subclass of FilteredKeyMap for slightly better performance.\n+    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));\n   }\n \n   /**\n@@ -2532,7 +2528,7 @@ NavigableMap<K, V> filterKeys(\n   public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterKeys(\n       BiMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {\n     checkNotNull(keyPredicate);\n-    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n+    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));\n   }\n \n   /**\n@@ -2560,7 +2556,7 @@ NavigableMap<K, V> filterKeys(\n    */\n   public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterValues(\n       Map<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2592,7 +2588,7 @@ NavigableMap<K, V> filterKeys(\n   public static <K extends @Nullable Object, V extends @Nullable Object>\n       SortedMap<K, V> filterValues(\n           SortedMap<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2625,7 +2621,7 @@ SortedMap<K, V> filterValues(\n   public static <K extends @Nullable Object, V extends @Nullable Object>\n       NavigableMap<K, V> filterValues(\n           NavigableMap<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2657,7 +2653,7 @@ NavigableMap<K, V> filterValues(\n    */\n   public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterValues(\n       BiMap<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2805,8 +2801,7 @@ NavigableMap<K, V> filterEntries(\n    */\n   private static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterFiltered(\n       AbstractFilteredMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    return new FilteredEntryMap<>(\n-        map.unfiltered, Predicates.<Entry<K, V>>and(map.predicate, entryPredicate));\n+    return new FilteredEntryMap<>(map.unfiltered, Predicates.and(map.predicate, entryPredicate));\n   }\n \n   /**\n@@ -2816,7 +2811,7 @@ NavigableMap<K, V> filterEntries(\n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       SortedMap<K, V> filterFiltered(\n           FilteredEntrySortedMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);\n+    Predicate<Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);\n     return new FilteredEntrySortedMap<>(map.sortedMap(), predicate);\n   }\n \n@@ -2828,8 +2823,7 @@ SortedMap<K, V> filterFiltered(\n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       NavigableMap<K, V> filterFiltered(\n           FilteredEntryNavigableMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    Predicate<Entry<K, V>> predicate =\n-        Predicates.<Entry<K, V>>and(map.entryPredicate, entryPredicate);\n+    Predicate<Entry<K, V>> predicate = Predicates.and(map.entryPredicate, entryPredicate);\n     return new FilteredEntryNavigableMap<>(map.unfiltered, predicate);\n   }\n \n@@ -2840,7 +2834,7 @@ NavigableMap<K, V> filterFiltered(\n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       BiMap<K, V> filterFiltered(\n           FilteredEntryBiMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);\n+    Predicate<Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);\n     return new FilteredEntryBiMap<>(map.unfiltered(), predicate);\n   }\n \n@@ -2906,7 +2900,7 @@ Collection<V> createValues() {\n \n   private static final class FilteredMapValues<\n           K extends @Nullable Object, V extends @Nullable Object>\n-      extends Maps.Values<K, V> {\n+      extends Values<K, V> {\n     final Map<K, V> unfiltered;\n     final Predicate<? super Entry<K, V>> predicate;\n \n@@ -3252,7 +3246,7 @@ private static final class FilteredEntryNavigableMap<\n \n     @Override\n     public NavigableSet<K> navigableKeySet() {\n-      return new Maps.NavigableKeySet<K, V>(this) {\n+      return new NavigableKeySet<K, V>(this) {\n         @Override\n         public boolean removeAll(Collection<?> collection) {\n           return FilteredEntryMap.removeAllKeys(unfiltered, entryPredicate, collection);\n@@ -3447,7 +3441,7 @@ NavigableMap<K, V> unmodifiableNavigableMap(NavigableMap<K, ? extends V> map) {\n \n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       @Nullable Entry<K, V> unmodifiableOrNull(@Nullable Entry<K, ? extends V> entry) {\n-    return (entry == null) ? null : Maps.unmodifiableEntry(entry);\n+    return (entry == null) ? null : unmodifiableEntry(entry);\n   }\n \n   @GwtIncompatible // NavigableMap\n@@ -3619,8 +3613,7 @@ public NavigableMap<K, V> subMap(\n         boolean fromInclusive,\n         @ParametricNullness K toKey,\n         boolean toInclusive) {\n-      return Maps.unmodifiableNavigableMap(\n-          delegate.subMap(fromKey, fromInclusive, toKey, toInclusive));\n+      return unmodifiableNavigableMap(delegate.subMap(fromKey, fromInclusive, toKey, toInclusive));\n     }\n \n     @Override\n@@ -3630,7 +3623,7 @@ public SortedMap<K, V> headMap(@ParametricNullness K toKey) {\n \n     @Override\n     public NavigableMap<K, V> headMap(@ParametricNullness K toKey, boolean inclusive) {\n-      return Maps.unmodifiableNavigableMap(delegate.headMap(toKey, inclusive));\n+      return unmodifiableNavigableMap(delegate.headMap(toKey, inclusive));\n     }\n \n     @Override\n@@ -3640,7 +3633,7 @@ public SortedMap<K, V> tailMap(@ParametricNullness K fromKey) {\n \n     @Override\n     public NavigableMap<K, V> tailMap(@ParametricNullness K fromKey, boolean inclusive) {\n-      return Maps.unmodifiableNavigableMap(delegate.tailMap(fromKey, inclusive));\n+      return unmodifiableNavigableMap(delegate.tailMap(fromKey, inclusive));\n     }\n   }\n \n@@ -4217,7 +4210,7 @@ public boolean contains(@Nullable Object o) {\n       if (o instanceof Entry) {\n         Entry<?, ?> entry = (Entry<?, ?>) o;\n         Object key = entry.getKey();\n-        V value = Maps.safeGet(map(), key);\n+        V value = safeGet(map(), key);\n         return Objects.equals(value, entry.getValue()) && (value != null || map().containsKey(key));\n       }\n       return false;"
    }
  ],
  "diff": "diff --git a/android/guava/src/com/google/common/collect/Maps.java b/android/guava/src/com/google/common/collect/Maps.java\nindex 7b29fd5714a0..1c75888c388e 100644\n--- a/android/guava/src/com/google/common/collect/Maps.java\n+++ b/android/guava/src/com/google/common/collect/Maps.java\n@@ -531,7 +531,7 @@ MapDifference<K, V> difference(\n     Map<K, V> onlyOnLeft = new LinkedHashMap<>();\n     Map<K, V> onlyOnRight = new LinkedHashMap<>(right); // will whittle it down\n     Map<K, V> onBoth = new LinkedHashMap<>();\n-    Map<K, MapDifference.ValueDifference<V>> differences = new LinkedHashMap<>();\n+    Map<K, ValueDifference<V>> differences = new LinkedHashMap<>();\n     doDifference(left, right, valueEquivalence, onlyOnLeft, onlyOnRight, onBoth, differences);\n     return new MapDifferenceImpl<>(onlyOnLeft, onlyOnRight, onBoth, differences);\n   }\n@@ -559,11 +559,11 @@ SortedMapDifference<K, V> difference(\n     checkNotNull(left);\n     checkNotNull(right);\n     Comparator<? super K> comparator = orNaturalOrder(left.comparator());\n-    SortedMap<K, V> onlyOnLeft = Maps.newTreeMap(comparator);\n-    SortedMap<K, V> onlyOnRight = Maps.newTreeMap(comparator);\n+    SortedMap<K, V> onlyOnLeft = newTreeMap(comparator);\n+    SortedMap<K, V> onlyOnRight = newTreeMap(comparator);\n     onlyOnRight.putAll(right); // will whittle it down\n-    SortedMap<K, V> onBoth = Maps.newTreeMap(comparator);\n-    SortedMap<K, MapDifference.ValueDifference<V>> differences = Maps.newTreeMap(comparator);\n+    SortedMap<K, V> onBoth = newTreeMap(comparator);\n+    SortedMap<K, ValueDifference<V>> differences = newTreeMap(comparator);\n \n     doDifference(left, right, Equivalence.equals(), onlyOnLeft, onlyOnRight, onBoth, differences);\n     return new SortedMapDifferenceImpl<>(onlyOnLeft, onlyOnRight, onBoth, differences);\n@@ -576,7 +576,7 @@ SortedMapDifference<K, V> difference(\n       Map<K, V> onlyOnLeft,\n       Map<K, V> onlyOnRight,\n       Map<K, V> onBoth,\n-      Map<K, MapDifference.ValueDifference<V>> differences) {\n+      Map<K, ValueDifference<V>> differences) {\n     for (Entry<? extends K, ? extends V> entry : left.entrySet()) {\n       K leftKey = entry.getKey();\n       V leftValue = entry.getValue();\n@@ -696,8 +696,7 @@ public String toString() {\n     }\n   }\n \n-  static final class ValueDifferenceImpl<V extends @Nullable Object>\n-      implements MapDifference.ValueDifference<V> {\n+  static final class ValueDifferenceImpl<V extends @Nullable Object> implements ValueDifference<V> {\n     @ParametricNullness private final V left;\n     @ParametricNullness private final V right;\n \n@@ -725,8 +724,8 @@ public V rightValue() {\n \n     @Override\n     public boolean equals(@Nullable Object object) {\n-      if (object instanceof MapDifference.ValueDifference) {\n-        MapDifference.ValueDifference<?> that = (MapDifference.ValueDifference<?>) object;\n+      if (object instanceof ValueDifference) {\n+        ValueDifference<?> that = (ValueDifference<?>) object;\n         return Objects.equals(this.left, that.leftValue())\n             && Objects.equals(this.right, that.rightValue());\n       }\n@@ -1627,8 +1626,7 @@ public String toString() {\n    * of its collection views:\n    *\n    * {@snippet :\n-   * BiMap<Long, String> map = Maps.synchronizedBiMap(\n-   *     HashBiMap.<Long, String>create());\n+   * BiMap<Long, String> map = Maps.synchronizedBiMap(HashBiMap.create());\n    * ...\n    * Set<Long> set = map.keySet();  // Needn't be in synchronized block\n    * ...\n@@ -2109,7 +2107,7 @@ public Set<K> keySet() {\n     @Override\n     Iterator<Entry<K, V2>> entryIterator() {\n       return Iterators.transform(\n-          fromMap.entrySet().iterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));\n+          fromMap.entrySet().iterator(), asEntryToEntryFunction(transformer));\n     }\n \n     @Override\n@@ -2296,12 +2294,12 @@ protected NavigableMap<K, V1> fromMap() {\n \n   static <K extends @Nullable Object> Predicate<Entry<K, ?>> keyPredicateOnEntries(\n       Predicate<? super K> keyPredicate) {\n-    return compose(keyPredicate, Maps.<K>keyFunction());\n+    return compose(keyPredicate, keyFunction());\n   }\n \n   static <V extends @Nullable Object> Predicate<Entry<?, V>> valuePredicateOnEntries(\n       Predicate<? super V> valuePredicate) {\n-    return compose(valuePredicate, Maps.<V>valueFunction());\n+    return compose(valuePredicate, valueFunction());\n   }\n \n   /**\n@@ -2364,9 +2362,8 @@ protected NavigableMap<K, V1> fromMap() {\n    */\n   public static <K extends @Nullable Object, V extends @Nullable Object> SortedMap<K, V> filterKeys(\n       SortedMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {\n-    // TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better\n-    // performance.\n-    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n+    // TODO(lowasser): Return a subclass of FilteredKeyMap for slightly better performance.\n+    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));\n   }\n \n   /**\n@@ -2399,9 +2396,8 @@ protected NavigableMap<K, V1> fromMap() {\n   public static <K extends @Nullable Object, V extends @Nullable Object>\n       NavigableMap<K, V> filterKeys(\n           NavigableMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {\n-    // TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better\n-    // performance.\n-    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n+    // TODO(lowasser): Return a subclass of FilteredKeyMap for slightly better performance.\n+    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));\n   }\n \n   /**\n@@ -2431,7 +2427,7 @@ NavigableMap<K, V> filterKeys(\n   public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterKeys(\n       BiMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {\n     checkNotNull(keyPredicate);\n-    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n+    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));\n   }\n \n   /**\n@@ -2459,7 +2455,7 @@ NavigableMap<K, V> filterKeys(\n    */\n   public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterValues(\n       Map<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2491,7 +2487,7 @@ NavigableMap<K, V> filterKeys(\n   public static <K extends @Nullable Object, V extends @Nullable Object>\n       SortedMap<K, V> filterValues(\n           SortedMap<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2524,7 +2520,7 @@ SortedMap<K, V> filterValues(\n   public static <K extends @Nullable Object, V extends @Nullable Object>\n       NavigableMap<K, V> filterValues(\n           NavigableMap<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2556,7 +2552,7 @@ NavigableMap<K, V> filterValues(\n    */\n   public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterValues(\n       BiMap<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2704,8 +2700,7 @@ NavigableMap<K, V> filterEntries(\n    */\n   private static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterFiltered(\n       AbstractFilteredMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    return new FilteredEntryMap<>(\n-        map.unfiltered, Predicates.<Entry<K, V>>and(map.predicate, entryPredicate));\n+    return new FilteredEntryMap<>(map.unfiltered, Predicates.and(map.predicate, entryPredicate));\n   }\n \n   /**\n@@ -2715,7 +2710,7 @@ NavigableMap<K, V> filterEntries(\n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       SortedMap<K, V> filterFiltered(\n           FilteredEntrySortedMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);\n+    Predicate<Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);\n     return new FilteredEntrySortedMap<>(map.sortedMap(), predicate);\n   }\n \n@@ -2727,8 +2722,7 @@ SortedMap<K, V> filterFiltered(\n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       NavigableMap<K, V> filterFiltered(\n           FilteredEntryNavigableMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    Predicate<Entry<K, V>> predicate =\n-        Predicates.<Entry<K, V>>and(map.entryPredicate, entryPredicate);\n+    Predicate<Entry<K, V>> predicate = Predicates.and(map.entryPredicate, entryPredicate);\n     return new FilteredEntryNavigableMap<>(map.unfiltered, predicate);\n   }\n \n@@ -2739,7 +2733,7 @@ NavigableMap<K, V> filterFiltered(\n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       BiMap<K, V> filterFiltered(\n           FilteredEntryBiMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);\n+    Predicate<Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);\n     return new FilteredEntryBiMap<>(map.unfiltered(), predicate);\n   }\n \n@@ -2805,7 +2799,7 @@ Collection<V> createValues() {\n \n   private static final class FilteredMapValues<\n           K extends @Nullable Object, V extends @Nullable Object>\n-      extends Maps.Values<K, V> {\n+      extends Values<K, V> {\n     final Map<K, V> unfiltered;\n     final Predicate<? super Entry<K, V>> predicate;\n \n@@ -3151,7 +3145,7 @@ private static final class FilteredEntryNavigableMap<\n \n     @Override\n     public NavigableSet<K> navigableKeySet() {\n-      return new Maps.NavigableKeySet<K, V>(this) {\n+      return new NavigableKeySet<K, V>(this) {\n         @Override\n         public boolean removeAll(Collection<?> collection) {\n           return FilteredEntryMap.removeAllKeys(unfiltered, entryPredicate, collection);\n@@ -3336,7 +3330,7 @@ NavigableMap<K, V> unmodifiableNavigableMap(NavigableMap<K, ? extends V> map) {\n \n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       @Nullable Entry<K, V> unmodifiableOrNull(@Nullable Entry<K, ? extends V> entry) {\n-    return (entry == null) ? null : Maps.unmodifiableEntry(entry);\n+    return (entry == null) ? null : unmodifiableEntry(entry);\n   }\n \n   @GwtIncompatible // NavigableMap\n@@ -3456,8 +3450,7 @@ public NavigableMap<K, V> subMap(\n         boolean fromInclusive,\n         @ParametricNullness K toKey,\n         boolean toInclusive) {\n-      return Maps.unmodifiableNavigableMap(\n-          delegate.subMap(fromKey, fromInclusive, toKey, toInclusive));\n+      return unmodifiableNavigableMap(delegate.subMap(fromKey, fromInclusive, toKey, toInclusive));\n     }\n \n     @Override\n@@ -3467,7 +3460,7 @@ public SortedMap<K, V> headMap(@ParametricNullness K toKey) {\n \n     @Override\n     public NavigableMap<K, V> headMap(@ParametricNullness K toKey, boolean inclusive) {\n-      return Maps.unmodifiableNavigableMap(delegate.headMap(toKey, inclusive));\n+      return unmodifiableNavigableMap(delegate.headMap(toKey, inclusive));\n     }\n \n     @Override\n@@ -3477,7 +3470,7 @@ public SortedMap<K, V> tailMap(@ParametricNullness K fromKey) {\n \n     @Override\n     public NavigableMap<K, V> tailMap(@ParametricNullness K fromKey, boolean inclusive) {\n-      return Maps.unmodifiableNavigableMap(delegate.tailMap(fromKey, inclusive));\n+      return unmodifiableNavigableMap(delegate.tailMap(fromKey, inclusive));\n     }\n   }\n \n@@ -4021,7 +4014,7 @@ public boolean contains(@Nullable Object o) {\n       if (o instanceof Entry) {\n         Entry<?, ?> entry = (Entry<?, ?>) o;\n         Object key = entry.getKey();\n-        V value = Maps.safeGet(map(), key);\n+        V value = safeGet(map(), key);\n         return Objects.equals(value, entry.getValue()) && (value != null || map().containsKey(key));\n       }\n       return false;\ndiff --git a/guava/src/com/google/common/collect/Maps.java b/guava/src/com/google/common/collect/Maps.java\nindex bfaf6bd0c323..d26913393048 100644\n--- a/guava/src/com/google/common/collect/Maps.java\n+++ b/guava/src/com/google/common/collect/Maps.java\n@@ -534,7 +534,7 @@ MapDifference<K, V> difference(\n     Map<K, V> onlyOnLeft = new LinkedHashMap<>();\n     Map<K, V> onlyOnRight = new LinkedHashMap<>(right); // will whittle it down\n     Map<K, V> onBoth = new LinkedHashMap<>();\n-    Map<K, MapDifference.ValueDifference<V>> differences = new LinkedHashMap<>();\n+    Map<K, ValueDifference<V>> differences = new LinkedHashMap<>();\n     doDifference(left, right, valueEquivalence, onlyOnLeft, onlyOnRight, onBoth, differences);\n     return new MapDifferenceImpl<>(onlyOnLeft, onlyOnRight, onBoth, differences);\n   }\n@@ -562,11 +562,11 @@ SortedMapDifference<K, V> difference(\n     checkNotNull(left);\n     checkNotNull(right);\n     Comparator<? super K> comparator = orNaturalOrder(left.comparator());\n-    SortedMap<K, V> onlyOnLeft = Maps.newTreeMap(comparator);\n-    SortedMap<K, V> onlyOnRight = Maps.newTreeMap(comparator);\n+    SortedMap<K, V> onlyOnLeft = newTreeMap(comparator);\n+    SortedMap<K, V> onlyOnRight = newTreeMap(comparator);\n     onlyOnRight.putAll(right); // will whittle it down\n-    SortedMap<K, V> onBoth = Maps.newTreeMap(comparator);\n-    SortedMap<K, MapDifference.ValueDifference<V>> differences = Maps.newTreeMap(comparator);\n+    SortedMap<K, V> onBoth = newTreeMap(comparator);\n+    SortedMap<K, ValueDifference<V>> differences = newTreeMap(comparator);\n \n     doDifference(left, right, Equivalence.equals(), onlyOnLeft, onlyOnRight, onBoth, differences);\n     return new SortedMapDifferenceImpl<>(onlyOnLeft, onlyOnRight, onBoth, differences);\n@@ -579,7 +579,7 @@ SortedMapDifference<K, V> difference(\n       Map<K, V> onlyOnLeft,\n       Map<K, V> onlyOnRight,\n       Map<K, V> onBoth,\n-      Map<K, MapDifference.ValueDifference<V>> differences) {\n+      Map<K, ValueDifference<V>> differences) {\n     for (Entry<? extends K, ? extends V> entry : left.entrySet()) {\n       K leftKey = entry.getKey();\n       V leftValue = entry.getValue();\n@@ -699,8 +699,7 @@ public String toString() {\n     }\n   }\n \n-  static final class ValueDifferenceImpl<V extends @Nullable Object>\n-      implements MapDifference.ValueDifference<V> {\n+  static final class ValueDifferenceImpl<V extends @Nullable Object> implements ValueDifference<V> {\n     @ParametricNullness private final V left;\n     @ParametricNullness private final V right;\n \n@@ -728,8 +727,8 @@ public V rightValue() {\n \n     @Override\n     public boolean equals(@Nullable Object object) {\n-      if (object instanceof MapDifference.ValueDifference) {\n-        MapDifference.ValueDifference<?> that = (MapDifference.ValueDifference<?>) object;\n+      if (object instanceof ValueDifference) {\n+        ValueDifference<?> that = (ValueDifference<?>) object;\n         return Objects.equals(this.left, that.leftValue())\n             && Objects.equals(this.right, that.rightValue());\n       }\n@@ -1657,8 +1656,7 @@ public String toString() {\n    * of its collection views:\n    *\n    * {@snippet :\n-   * BiMap<Long, String> map = Maps.synchronizedBiMap(\n-   *     HashBiMap.<Long, String>create());\n+   * BiMap<Long, String> map = Maps.synchronizedBiMap(HashBiMap.create());\n    * ...\n    * Set<Long> set = map.keySet();  // Needn't be in synchronized block\n    * ...\n@@ -2197,13 +2195,13 @@ public Set<K> keySet() {\n     @Override\n     Iterator<Entry<K, V2>> entryIterator() {\n       return Iterators.transform(\n-          fromMap.entrySet().iterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));\n+          fromMap.entrySet().iterator(), asEntryToEntryFunction(transformer));\n     }\n \n     @Override\n     Spliterator<Entry<K, V2>> entrySpliterator() {\n       return CollectSpliterators.map(\n-          fromMap.entrySet().spliterator(), Maps.<K, V1, V2>asEntryToEntryFunction(transformer));\n+          fromMap.entrySet().spliterator(), asEntryToEntryFunction(transformer));\n     }\n \n     @Override\n@@ -2397,12 +2395,12 @@ protected NavigableMap<K, V1> fromMap() {\n \n   static <K extends @Nullable Object> Predicate<Entry<K, ?>> keyPredicateOnEntries(\n       Predicate<? super K> keyPredicate) {\n-    return compose(keyPredicate, Maps.<K>keyFunction());\n+    return compose(keyPredicate, keyFunction());\n   }\n \n   static <V extends @Nullable Object> Predicate<Entry<?, V>> valuePredicateOnEntries(\n       Predicate<? super V> valuePredicate) {\n-    return compose(valuePredicate, Maps.<V>valueFunction());\n+    return compose(valuePredicate, valueFunction());\n   }\n \n   /**\n@@ -2465,9 +2463,8 @@ protected NavigableMap<K, V1> fromMap() {\n    */\n   public static <K extends @Nullable Object, V extends @Nullable Object> SortedMap<K, V> filterKeys(\n       SortedMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {\n-    // TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better\n-    // performance.\n-    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n+    // TODO(lowasser): Return a subclass of FilteredKeyMap for slightly better performance.\n+    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));\n   }\n \n   /**\n@@ -2500,9 +2497,8 @@ protected NavigableMap<K, V1> fromMap() {\n   public static <K extends @Nullable Object, V extends @Nullable Object>\n       NavigableMap<K, V> filterKeys(\n           NavigableMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {\n-    // TODO(lowasser): Return a subclass of Maps.FilteredKeyMap for slightly better\n-    // performance.\n-    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n+    // TODO(lowasser): Return a subclass of FilteredKeyMap for slightly better performance.\n+    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));\n   }\n \n   /**\n@@ -2532,7 +2528,7 @@ NavigableMap<K, V> filterKeys(\n   public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterKeys(\n       BiMap<K, V> unfiltered, Predicate<? super K> keyPredicate) {\n     checkNotNull(keyPredicate);\n-    return filterEntries(unfiltered, Maps.<K>keyPredicateOnEntries(keyPredicate));\n+    return filterEntries(unfiltered, keyPredicateOnEntries(keyPredicate));\n   }\n \n   /**\n@@ -2560,7 +2556,7 @@ NavigableMap<K, V> filterKeys(\n    */\n   public static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterValues(\n       Map<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2592,7 +2588,7 @@ NavigableMap<K, V> filterKeys(\n   public static <K extends @Nullable Object, V extends @Nullable Object>\n       SortedMap<K, V> filterValues(\n           SortedMap<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2625,7 +2621,7 @@ SortedMap<K, V> filterValues(\n   public static <K extends @Nullable Object, V extends @Nullable Object>\n       NavigableMap<K, V> filterValues(\n           NavigableMap<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2657,7 +2653,7 @@ NavigableMap<K, V> filterValues(\n    */\n   public static <K extends @Nullable Object, V extends @Nullable Object> BiMap<K, V> filterValues(\n       BiMap<K, V> unfiltered, Predicate<? super V> valuePredicate) {\n-    return filterEntries(unfiltered, Maps.<V>valuePredicateOnEntries(valuePredicate));\n+    return filterEntries(unfiltered, valuePredicateOnEntries(valuePredicate));\n   }\n \n   /**\n@@ -2805,8 +2801,7 @@ NavigableMap<K, V> filterEntries(\n    */\n   private static <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> filterFiltered(\n       AbstractFilteredMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    return new FilteredEntryMap<>(\n-        map.unfiltered, Predicates.<Entry<K, V>>and(map.predicate, entryPredicate));\n+    return new FilteredEntryMap<>(map.unfiltered, Predicates.and(map.predicate, entryPredicate));\n   }\n \n   /**\n@@ -2816,7 +2811,7 @@ NavigableMap<K, V> filterEntries(\n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       SortedMap<K, V> filterFiltered(\n           FilteredEntrySortedMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);\n+    Predicate<Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);\n     return new FilteredEntrySortedMap<>(map.sortedMap(), predicate);\n   }\n \n@@ -2828,8 +2823,7 @@ SortedMap<K, V> filterFiltered(\n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       NavigableMap<K, V> filterFiltered(\n           FilteredEntryNavigableMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    Predicate<Entry<K, V>> predicate =\n-        Predicates.<Entry<K, V>>and(map.entryPredicate, entryPredicate);\n+    Predicate<Entry<K, V>> predicate = Predicates.and(map.entryPredicate, entryPredicate);\n     return new FilteredEntryNavigableMap<>(map.unfiltered, predicate);\n   }\n \n@@ -2840,7 +2834,7 @@ NavigableMap<K, V> filterFiltered(\n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       BiMap<K, V> filterFiltered(\n           FilteredEntryBiMap<K, V> map, Predicate<? super Entry<K, V>> entryPredicate) {\n-    Predicate<Entry<K, V>> predicate = Predicates.<Entry<K, V>>and(map.predicate, entryPredicate);\n+    Predicate<Entry<K, V>> predicate = Predicates.and(map.predicate, entryPredicate);\n     return new FilteredEntryBiMap<>(map.unfiltered(), predicate);\n   }\n \n@@ -2906,7 +2900,7 @@ Collection<V> createValues() {\n \n   private static final class FilteredMapValues<\n           K extends @Nullable Object, V extends @Nullable Object>\n-      extends Maps.Values<K, V> {\n+      extends Values<K, V> {\n     final Map<K, V> unfiltered;\n     final Predicate<? super Entry<K, V>> predicate;\n \n@@ -3252,7 +3246,7 @@ private static final class FilteredEntryNavigableMap<\n \n     @Override\n     public NavigableSet<K> navigableKeySet() {\n-      return new Maps.NavigableKeySet<K, V>(this) {\n+      return new NavigableKeySet<K, V>(this) {\n         @Override\n         public boolean removeAll(Collection<?> collection) {\n           return FilteredEntryMap.removeAllKeys(unfiltered, entryPredicate, collection);\n@@ -3447,7 +3441,7 @@ NavigableMap<K, V> unmodifiableNavigableMap(NavigableMap<K, ? extends V> map) {\n \n   private static <K extends @Nullable Object, V extends @Nullable Object>\n       @Nullable Entry<K, V> unmodifiableOrNull(@Nullable Entry<K, ? extends V> entry) {\n-    return (entry == null) ? null : Maps.unmodifiableEntry(entry);\n+    return (entry == null) ? null : unmodifiableEntry(entry);\n   }\n \n   @GwtIncompatible // NavigableMap\n@@ -3619,8 +3613,7 @@ public NavigableMap<K, V> subMap(\n         boolean fromInclusive,\n         @ParametricNullness K toKey,\n         boolean toInclusive) {\n-      return Maps.unmodifiableNavigableMap(\n-          delegate.subMap(fromKey, fromInclusive, toKey, toInclusive));\n+      return unmodifiableNavigableMap(delegate.subMap(fromKey, fromInclusive, toKey, toInclusive));\n     }\n \n     @Override\n@@ -3630,7 +3623,7 @@ public SortedMap<K, V> headMap(@ParametricNullness K toKey) {\n \n     @Override\n     public NavigableMap<K, V> headMap(@ParametricNullness K toKey, boolean inclusive) {\n-      return Maps.unmodifiableNavigableMap(delegate.headMap(toKey, inclusive));\n+      return unmodifiableNavigableMap(delegate.headMap(toKey, inclusive));\n     }\n \n     @Override\n@@ -3640,7 +3633,7 @@ public SortedMap<K, V> tailMap(@ParametricNullness K fromKey) {\n \n     @Override\n     public NavigableMap<K, V> tailMap(@ParametricNullness K fromKey, boolean inclusive) {\n-      return Maps.unmodifiableNavigableMap(delegate.tailMap(fromKey, inclusive));\n+      return unmodifiableNavigableMap(delegate.tailMap(fromKey, inclusive));\n     }\n   }\n \n@@ -4217,7 +4210,7 @@ public boolean contains(@Nullable Object o) {\n       if (o instanceof Entry) {\n         Entry<?, ?> entry = (Entry<?, ?>) o;\n         Object key = entry.getKey();\n-        V value = Maps.safeGet(map(), key);\n+        V value = safeGet(map(), key);\n         return Objects.equals(value, entry.getValue()) && (value != null || map().containsKey(key));\n       }\n       return false;\n",
  "additions": 67,
  "deletions": 81,
  "changed_files": 2,
  "url": "https://github.com/google/guava/pull/8015",
  "mined_at": "2025-10-25T12:57:25.916174"
}