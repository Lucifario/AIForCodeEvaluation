{
  "id": 8019,
  "repository": "google/guava",
  "title": "Improve exception messages for annotation-related methods on synthetic `TypeVariable` instances.",
  "body": "Improve exception messages for annotation-related methods on synthetic `TypeVariable` instances.\n\nFixes #7974\n\nRELNOTES=n/a\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-09-23T22:30:10+00:00",
  "created_at": "2025-09-23T22:06:44+00:00",
  "updated_at": "2025-09-23T22:30:11+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "f5d8ecc5ed3aa368f54ebb83c6064fa46b3b2b7a",
  "head_sha": "59c4ecce89a556c205e38d75c4c201b229dc12f3",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava/src/com/google/common/reflect/TypeResolver.java",
      "status": "modified",
      "additions": 7,
      "deletions": 4,
      "changes": 11,
      "patch": "@@ -368,10 +368,13 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n          * by us. And that equality is guaranteed to hold because it doesn't involve the JDK\n          * TypeVariable implementation at all.\n          *\n-         * TODO: b/147144588 - But what about when the TypeVariable has annotations? Our\n-         * implementation currently doesn't support annotations _at all_. It could at least be made\n-         * to respond to queries about annotations by returning null/empty, but are there situations\n-         * in which it should return something else?\n+         * NOTE: b/147144588 - Custom TypeVariables created by Guava do not preserve\n+         * annotations. This is intentional. The semantics of annotation handling during\n+         * type resolution are unclear and have changed across Java versions. Until there's\n+         * a clear specification for what annotations should mean on resolved TypeVariables\n+         * with modified bounds, annotation methods will throw\n+         * UnsupportedOperationException. Frameworks requiring annotation preservation\n+         * should use the original TypeVariable when bounds haven't changed.\n          */\n         if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY\n             && Arrays.equals(bounds, resolvedBounds)) {"
    },
    {
      "filename": "android/guava/src/com/google/common/reflect/Types.java",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "patch": "@@ -382,6 +382,18 @@ private static final class TypeVariableInvocationHandler implements InvocationHa\n       String methodName = method.getName();\n       Method typeVariableMethod = typeVariableMethods.get(methodName);\n       if (typeVariableMethod == null) {\n+        if (methodName.equals(\"getAnnotatedBounds\")\n+            || methodName.equals(\"isAnnotationPresent\")\n+            // Each of these prefixes is shared by a family of methods:\n+            || methodName.startsWith(\"getAnnotation\")\n+            || methodName.startsWith(\"getDeclaredAnnotation\")) {\n+          throw new UnsupportedOperationException(\n+              \"Annotation methods are not supported on synthetic TypeVariables created during type\"\n+                  + \" resolution. The semantics of annotations on resolved types with modified\"\n+                  + \" bounds are undefined. Use the original TypeVariable for annotation access.\"\n+                  + \" See b/147144588.\");\n+        }\n+        // If any other method appears or if we forgot one, include it in the exception message:\n         throw new UnsupportedOperationException(methodName);\n       } else {\n         try {"
    },
    {
      "filename": "guava/src/com/google/common/reflect/TypeResolver.java",
      "status": "modified",
      "additions": 7,
      "deletions": 4,
      "changes": 11,
      "patch": "@@ -368,10 +368,13 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n          * by us. And that equality is guaranteed to hold because it doesn't involve the JDK\n          * TypeVariable implementation at all.\n          *\n-         * TODO: b/147144588 - But what about when the TypeVariable has annotations? Our\n-         * implementation currently doesn't support annotations _at all_. It could at least be made\n-         * to respond to queries about annotations by returning null/empty, but are there situations\n-         * in which it should return something else?\n+         * NOTE: b/147144588 - Custom TypeVariables created by Guava do not preserve\n+         * annotations. This is intentional. The semantics of annotation handling during\n+         * type resolution are unclear and have changed across Java versions. Until there's\n+         * a clear specification for what annotations should mean on resolved TypeVariables\n+         * with modified bounds, annotation methods will throw\n+         * UnsupportedOperationException. Frameworks requiring annotation preservation\n+         * should use the original TypeVariable when bounds haven't changed.\n          */\n         if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY\n             && Arrays.equals(bounds, resolvedBounds)) {"
    },
    {
      "filename": "guava/src/com/google/common/reflect/Types.java",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "patch": "@@ -382,6 +382,18 @@ private static final class TypeVariableInvocationHandler implements InvocationHa\n       String methodName = method.getName();\n       Method typeVariableMethod = typeVariableMethods.get(methodName);\n       if (typeVariableMethod == null) {\n+        if (methodName.equals(\"getAnnotatedBounds\")\n+            || methodName.equals(\"isAnnotationPresent\")\n+            // Each of these prefixes is shared by a family of methods:\n+            || methodName.startsWith(\"getAnnotation\")\n+            || methodName.startsWith(\"getDeclaredAnnotation\")) {\n+          throw new UnsupportedOperationException(\n+              \"Annotation methods are not supported on synthetic TypeVariables created during type\"\n+                  + \" resolution. The semantics of annotations on resolved types with modified\"\n+                  + \" bounds are undefined. Use the original TypeVariable for annotation access.\"\n+                  + \" See b/147144588.\");\n+        }\n+        // If any other method appears or if we forgot one, include it in the exception message:\n         throw new UnsupportedOperationException(methodName);\n       } else {\n         try {"
    }
  ],
  "diff": "diff --git a/android/guava/src/com/google/common/reflect/TypeResolver.java b/android/guava/src/com/google/common/reflect/TypeResolver.java\nindex b28ffbb7228c..9e184a47855d 100644\n--- a/android/guava/src/com/google/common/reflect/TypeResolver.java\n+++ b/android/guava/src/com/google/common/reflect/TypeResolver.java\n@@ -368,10 +368,13 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n          * by us. And that equality is guaranteed to hold because it doesn't involve the JDK\n          * TypeVariable implementation at all.\n          *\n-         * TODO: b/147144588 - But what about when the TypeVariable has annotations? Our\n-         * implementation currently doesn't support annotations _at all_. It could at least be made\n-         * to respond to queries about annotations by returning null/empty, but are there situations\n-         * in which it should return something else?\n+         * NOTE: b/147144588 - Custom TypeVariables created by Guava do not preserve\n+         * annotations. This is intentional. The semantics of annotation handling during\n+         * type resolution are unclear and have changed across Java versions. Until there's\n+         * a clear specification for what annotations should mean on resolved TypeVariables\n+         * with modified bounds, annotation methods will throw\n+         * UnsupportedOperationException. Frameworks requiring annotation preservation\n+         * should use the original TypeVariable when bounds haven't changed.\n          */\n         if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY\n             && Arrays.equals(bounds, resolvedBounds)) {\ndiff --git a/android/guava/src/com/google/common/reflect/Types.java b/android/guava/src/com/google/common/reflect/Types.java\nindex 0122104712f8..3f863910df57 100644\n--- a/android/guava/src/com/google/common/reflect/Types.java\n+++ b/android/guava/src/com/google/common/reflect/Types.java\n@@ -382,6 +382,18 @@ private static final class TypeVariableInvocationHandler implements InvocationHa\n       String methodName = method.getName();\n       Method typeVariableMethod = typeVariableMethods.get(methodName);\n       if (typeVariableMethod == null) {\n+        if (methodName.equals(\"getAnnotatedBounds\")\n+            || methodName.equals(\"isAnnotationPresent\")\n+            // Each of these prefixes is shared by a family of methods:\n+            || methodName.startsWith(\"getAnnotation\")\n+            || methodName.startsWith(\"getDeclaredAnnotation\")) {\n+          throw new UnsupportedOperationException(\n+              \"Annotation methods are not supported on synthetic TypeVariables created during type\"\n+                  + \" resolution. The semantics of annotations on resolved types with modified\"\n+                  + \" bounds are undefined. Use the original TypeVariable for annotation access.\"\n+                  + \" See b/147144588.\");\n+        }\n+        // If any other method appears or if we forgot one, include it in the exception message:\n         throw new UnsupportedOperationException(methodName);\n       } else {\n         try {\ndiff --git a/guava/src/com/google/common/reflect/TypeResolver.java b/guava/src/com/google/common/reflect/TypeResolver.java\nindex b28ffbb7228c..9e184a47855d 100644\n--- a/guava/src/com/google/common/reflect/TypeResolver.java\n+++ b/guava/src/com/google/common/reflect/TypeResolver.java\n@@ -368,10 +368,13 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n          * by us. And that equality is guaranteed to hold because it doesn't involve the JDK\n          * TypeVariable implementation at all.\n          *\n-         * TODO: b/147144588 - But what about when the TypeVariable has annotations? Our\n-         * implementation currently doesn't support annotations _at all_. It could at least be made\n-         * to respond to queries about annotations by returning null/empty, but are there situations\n-         * in which it should return something else?\n+         * NOTE: b/147144588 - Custom TypeVariables created by Guava do not preserve\n+         * annotations. This is intentional. The semantics of annotation handling during\n+         * type resolution are unclear and have changed across Java versions. Until there's\n+         * a clear specification for what annotations should mean on resolved TypeVariables\n+         * with modified bounds, annotation methods will throw\n+         * UnsupportedOperationException. Frameworks requiring annotation preservation\n+         * should use the original TypeVariable when bounds haven't changed.\n          */\n         if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY\n             && Arrays.equals(bounds, resolvedBounds)) {\ndiff --git a/guava/src/com/google/common/reflect/Types.java b/guava/src/com/google/common/reflect/Types.java\nindex 209369d017a4..74718cb813cd 100644\n--- a/guava/src/com/google/common/reflect/Types.java\n+++ b/guava/src/com/google/common/reflect/Types.java\n@@ -382,6 +382,18 @@ private static final class TypeVariableInvocationHandler implements InvocationHa\n       String methodName = method.getName();\n       Method typeVariableMethod = typeVariableMethods.get(methodName);\n       if (typeVariableMethod == null) {\n+        if (methodName.equals(\"getAnnotatedBounds\")\n+            || methodName.equals(\"isAnnotationPresent\")\n+            // Each of these prefixes is shared by a family of methods:\n+            || methodName.startsWith(\"getAnnotation\")\n+            || methodName.startsWith(\"getDeclaredAnnotation\")) {\n+          throw new UnsupportedOperationException(\n+              \"Annotation methods are not supported on synthetic TypeVariables created during type\"\n+                  + \" resolution. The semantics of annotations on resolved types with modified\"\n+                  + \" bounds are undefined. Use the original TypeVariable for annotation access.\"\n+                  + \" See b/147144588.\");\n+        }\n+        // If any other method appears or if we forgot one, include it in the exception message:\n         throw new UnsupportedOperationException(methodName);\n       } else {\n         try {\n",
  "additions": 38,
  "deletions": 8,
  "changed_files": 4,
  "url": "https://github.com/google/guava/pull/8019",
  "mined_at": "2025-10-25T12:55:39.533555"
}