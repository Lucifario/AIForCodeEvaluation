{
  "id": 8036,
  "repository": "google/guava",
  "title": "Delete `ClusterException` in favor of suppressed exceptions.",
  "body": "Delete `ClusterException` in favor of suppressed exceptions.\n\nSuppressed exceptions would have saved me from a short side quest during https://github.com/google/guava/commit/ae5e4d6f12ba92f90ace3f3d8ade76e0a52d8c24.\n\nRELNOTES=n/a\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-10-01T13:14:57+00:00",
  "created_at": "2025-10-01T12:50:21+00:00",
  "updated_at": "2025-10-01T13:14:57+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "ca18af83382f54edfe66264ec5bb5c6ada72b058",
  "head_sha": "7730d1317dc179a1eabb34ad6db251e9c9a5f844",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava-testlib/src/com/google/common/testing/ClusterException.java",
      "status": "removed",
      "additions": 0,
      "deletions": 115,
      "changes": 115,
      "patch": "@@ -1,115 +0,0 @@\n-/*\n- * Copyright (C) 2009 The Guava Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.google.common.testing;\n-\n-import com.google.common.annotations.GwtCompatible;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import org.jspecify.annotations.NullMarked;\n-\n-/**\n- * An {@link ClusterException} is a data structure that allows for some code to \"throw multiple\n- * exceptions\", or something close to it. The prototypical code that calls for this class is\n- * presented below:\n- *\n- * <pre>\n- * void runManyThings({@literal List<ThingToRun>} thingsToRun) {\n- *   for (ThingToRun thingToRun : thingsToRun) {\n- *     thingToRun.run(); // say this may throw an exception, but you want to\n- *                       // always run all thingsToRun\n- *   }\n- * }\n- * </pre>\n- *\n- * <p>This is what the code would become:\n- *\n- * <pre>\n- * void runManyThings({@literal List<ThingToRun>} thingsToRun) {\n- *   {@literal List<Exception>} exceptions = Lists.newArrayList();\n- *   for (ThingToRun thingToRun : thingsToRun) {\n- *     try {\n- *       thingToRun.run();\n- *     } catch (Exception e) {\n- *       exceptions.add(e);\n- *     }\n- *   }\n- *   if (exceptions.size() &gt; 0) {\n- *     throw ClusterException.create(exceptions);\n- *   }\n- * }\n- * </pre>\n- *\n- * <p>See semantic details at {@link #create(Collection)}.\n- *\n- * @author Luiz-Otavio Zorzella\n- */\n-@GwtCompatible\n-@NullMarked\n-final class ClusterException extends RuntimeException {\n-\n-  final Collection<? extends Throwable> exceptions;\n-\n-  private ClusterException(Collection<? extends Throwable> exceptions) {\n-    super(\n-        exceptions.size() + \" exceptions were thrown. The first exception is listed as a cause.\",\n-        exceptions.iterator().next());\n-    ArrayList<? extends Throwable> temp = new ArrayList<>(exceptions);\n-    this.exceptions = Collections.unmodifiableCollection(temp);\n-  }\n-\n-  /** See {@link #create(Collection)}. */\n-  static RuntimeException create(Throwable... exceptions) {\n-    ArrayList<Throwable> temp = new ArrayList<>(Arrays.asList(exceptions));\n-    return create(temp);\n-  }\n-\n-  /**\n-   * Given a collection of exceptions, returns a {@link RuntimeException}, with the following rules:\n-   *\n-   * <ul>\n-   *   <li>If {@code exceptions} has a single exception and that exception is a {@link\n-   *       RuntimeException}, return it\n-   *   <li>If {@code exceptions} has a single exceptions and that exceptions is <em>not</em> a\n-   *       {@link RuntimeException}, return a simple {@code RuntimeException} that wraps it\n-   *   <li>Otherwise, return an instance of {@link ClusterException} that wraps the first exception\n-   *       in the {@code exceptions} collection.\n-   * </ul>\n-   *\n-   * <p>Though this method takes any {@link Collection}, it often makes most sense to pass a {@link\n-   * java.util.List} or some other collection that preserves the order in which the exceptions got\n-   * added.\n-   *\n-   * @throws NullPointerException if {@code exceptions} is null\n-   * @throws IllegalArgumentException if {@code exceptions} is empty\n-   */\n-  static RuntimeException create(Collection<? extends Throwable> exceptions) {\n-    if (exceptions.size() == 0) {\n-      throw new IllegalArgumentException(\"Can't create an ExceptionCollection with no exceptions\");\n-    }\n-    if (exceptions.size() == 1) {\n-      Throwable temp = exceptions.iterator().next();\n-      if (temp instanceof RuntimeException) {\n-        return (RuntimeException) temp;\n-      } else {\n-        return new RuntimeException(temp);\n-      }\n-    }\n-    return new ClusterException(exceptions);\n-  }\n-}"
    },
    {
      "filename": "android/guava-testlib/src/com/google/common/testing/TearDownStack.java",
      "status": "modified",
      "additions": 10,
      "deletions": 4,
      "changes": 14,
      "patch": "@@ -17,6 +17,7 @@\n package com.google.common.testing;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Throwables.throwIfUnchecked;\n \n import com.google.common.annotations.GwtCompatible;\n import com.google.common.annotations.VisibleForTesting;\n@@ -66,7 +67,7 @@ public final void addTearDown(TearDown tearDown) {\n \n   /** Causes teardown to execute. */\n   public final void runTearDown() {\n-    List<Throwable> exceptions = new ArrayList<>();\n+    Throwable exception = null;\n     List<TearDown> stackCopy;\n     synchronized (lock) {\n       stackCopy = new ArrayList<>(stack);\n@@ -79,12 +80,17 @@ public final void runTearDown() {\n         if (suppressThrows) {\n           logger.log(Level.INFO, \"exception thrown during tearDown\", t);\n         } else {\n-          exceptions.add(t);\n+          if (exception == null) {\n+            exception = t;\n+          } else {\n+            exception.addSuppressed(t);\n+          }\n         }\n       }\n     }\n-    if (!suppressThrows && (exceptions.size() > 0)) {\n-      throw ClusterException.create(exceptions);\n+    if (exception != null) {\n+      throwIfUnchecked(exception);\n+      throw new RuntimeException(\"failure during tearDown\", exception);\n     }\n   }\n }"
    },
    {
      "filename": "android/guava-testlib/test/com/google/common/testing/TearDownStackTest.java",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "patch": "@@ -16,7 +16,9 @@\n \n package com.google.common.testing;\n \n+import static com.google.common.collect.Iterables.getOnlyElement;\n import static com.google.common.truth.Truth.assertThat;\n+import static java.util.Arrays.asList;\n \n import com.google.common.annotations.GwtCompatible;\n import junit.framework.TestCase;\n@@ -87,11 +89,11 @@ public void testThrowingTearDown() throws Exception {\n     try {\n       stack.runTearDown();\n       fail(\"runTearDown should have thrown an exception\");\n-    } catch (ClusterException expected) {\n-      assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(\"two\");\n-    } catch (RuntimeException e) {\n-      throw new RuntimeException(\n-          \"A ClusterException should have been thrown, rather than a \" + e.getClass().getName(), e);\n+    } catch (RuntimeException expected) {\n+      assertThat(expected).hasMessageThat().isEqualTo(\"two\");\n+      assertThat(getOnlyElement(asList(expected.getSuppressed())))\n+          .hasMessageThat()\n+          .isEqualTo(\"one\");\n     }\n \n     assertEquals(true, tearDownOne.ran);"
    },
    {
      "filename": "guava-testlib/src/com/google/common/testing/ClusterException.java",
      "status": "removed",
      "additions": 0,
      "deletions": 115,
      "changes": 115,
      "patch": "@@ -1,115 +0,0 @@\n-/*\n- * Copyright (C) 2009 The Guava Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.google.common.testing;\n-\n-import com.google.common.annotations.GwtCompatible;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import org.jspecify.annotations.NullMarked;\n-\n-/**\n- * An {@link ClusterException} is a data structure that allows for some code to \"throw multiple\n- * exceptions\", or something close to it. The prototypical code that calls for this class is\n- * presented below:\n- *\n- * <pre>\n- * void runManyThings({@literal List<ThingToRun>} thingsToRun) {\n- *   for (ThingToRun thingToRun : thingsToRun) {\n- *     thingToRun.run(); // say this may throw an exception, but you want to\n- *                       // always run all thingsToRun\n- *   }\n- * }\n- * </pre>\n- *\n- * <p>This is what the code would become:\n- *\n- * <pre>\n- * void runManyThings({@literal List<ThingToRun>} thingsToRun) {\n- *   {@literal List<Exception>} exceptions = Lists.newArrayList();\n- *   for (ThingToRun thingToRun : thingsToRun) {\n- *     try {\n- *       thingToRun.run();\n- *     } catch (Exception e) {\n- *       exceptions.add(e);\n- *     }\n- *   }\n- *   if (exceptions.size() &gt; 0) {\n- *     throw ClusterException.create(exceptions);\n- *   }\n- * }\n- * </pre>\n- *\n- * <p>See semantic details at {@link #create(Collection)}.\n- *\n- * @author Luiz-Otavio Zorzella\n- */\n-@GwtCompatible\n-@NullMarked\n-final class ClusterException extends RuntimeException {\n-\n-  final Collection<? extends Throwable> exceptions;\n-\n-  private ClusterException(Collection<? extends Throwable> exceptions) {\n-    super(\n-        exceptions.size() + \" exceptions were thrown. The first exception is listed as a cause.\",\n-        exceptions.iterator().next());\n-    ArrayList<? extends Throwable> temp = new ArrayList<>(exceptions);\n-    this.exceptions = Collections.unmodifiableCollection(temp);\n-  }\n-\n-  /** See {@link #create(Collection)}. */\n-  static RuntimeException create(Throwable... exceptions) {\n-    ArrayList<Throwable> temp = new ArrayList<>(Arrays.asList(exceptions));\n-    return create(temp);\n-  }\n-\n-  /**\n-   * Given a collection of exceptions, returns a {@link RuntimeException}, with the following rules:\n-   *\n-   * <ul>\n-   *   <li>If {@code exceptions} has a single exception and that exception is a {@link\n-   *       RuntimeException}, return it\n-   *   <li>If {@code exceptions} has a single exceptions and that exceptions is <em>not</em> a\n-   *       {@link RuntimeException}, return a simple {@code RuntimeException} that wraps it\n-   *   <li>Otherwise, return an instance of {@link ClusterException} that wraps the first exception\n-   *       in the {@code exceptions} collection.\n-   * </ul>\n-   *\n-   * <p>Though this method takes any {@link Collection}, it often makes most sense to pass a {@link\n-   * java.util.List} or some other collection that preserves the order in which the exceptions got\n-   * added.\n-   *\n-   * @throws NullPointerException if {@code exceptions} is null\n-   * @throws IllegalArgumentException if {@code exceptions} is empty\n-   */\n-  static RuntimeException create(Collection<? extends Throwable> exceptions) {\n-    if (exceptions.size() == 0) {\n-      throw new IllegalArgumentException(\"Can't create an ExceptionCollection with no exceptions\");\n-    }\n-    if (exceptions.size() == 1) {\n-      Throwable temp = exceptions.iterator().next();\n-      if (temp instanceof RuntimeException) {\n-        return (RuntimeException) temp;\n-      } else {\n-        return new RuntimeException(temp);\n-      }\n-    }\n-    return new ClusterException(exceptions);\n-  }\n-}"
    },
    {
      "filename": "guava-testlib/src/com/google/common/testing/TearDownStack.java",
      "status": "modified",
      "additions": 10,
      "deletions": 4,
      "changes": 14,
      "patch": "@@ -17,6 +17,7 @@\n package com.google.common.testing;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Throwables.throwIfUnchecked;\n \n import com.google.common.annotations.GwtCompatible;\n import com.google.common.annotations.VisibleForTesting;\n@@ -66,7 +67,7 @@ public final void addTearDown(TearDown tearDown) {\n \n   /** Causes teardown to execute. */\n   public final void runTearDown() {\n-    List<Throwable> exceptions = new ArrayList<>();\n+    Throwable exception = null;\n     List<TearDown> stackCopy;\n     synchronized (lock) {\n       stackCopy = new ArrayList<>(stack);\n@@ -79,12 +80,17 @@ public final void runTearDown() {\n         if (suppressThrows) {\n           logger.log(Level.INFO, \"exception thrown during tearDown\", t);\n         } else {\n-          exceptions.add(t);\n+          if (exception == null) {\n+            exception = t;\n+          } else {\n+            exception.addSuppressed(t);\n+          }\n         }\n       }\n     }\n-    if (!suppressThrows && (exceptions.size() > 0)) {\n-      throw ClusterException.create(exceptions);\n+    if (exception != null) {\n+      throwIfUnchecked(exception);\n+      throw new RuntimeException(\"failure during tearDown\", exception);\n     }\n   }\n }"
    },
    {
      "filename": "guava-testlib/test/com/google/common/testing/TearDownStackTest.java",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "patch": "@@ -16,7 +16,9 @@\n \n package com.google.common.testing;\n \n+import static com.google.common.collect.Iterables.getOnlyElement;\n import static com.google.common.truth.Truth.assertThat;\n+import static java.util.Arrays.asList;\n \n import com.google.common.annotations.GwtCompatible;\n import junit.framework.TestCase;\n@@ -87,11 +89,11 @@ public void testThrowingTearDown() throws Exception {\n     try {\n       stack.runTearDown();\n       fail(\"runTearDown should have thrown an exception\");\n-    } catch (ClusterException expected) {\n-      assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(\"two\");\n-    } catch (RuntimeException e) {\n-      throw new RuntimeException(\n-          \"A ClusterException should have been thrown, rather than a \" + e.getClass().getName(), e);\n+    } catch (RuntimeException expected) {\n+      assertThat(expected).hasMessageThat().isEqualTo(\"two\");\n+      assertThat(getOnlyElement(asList(expected.getSuppressed())))\n+          .hasMessageThat()\n+          .isEqualTo(\"one\");\n     }\n \n     assertEquals(true, tearDownOne.ran);"
    }
  ],
  "diff": "diff --git a/android/guava-testlib/src/com/google/common/testing/ClusterException.java b/android/guava-testlib/src/com/google/common/testing/ClusterException.java\ndeleted file mode 100644\nindex 47232e8dd63b..000000000000\n--- a/android/guava-testlib/src/com/google/common/testing/ClusterException.java\n+++ /dev/null\n@@ -1,115 +0,0 @@\n-/*\n- * Copyright (C) 2009 The Guava Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.google.common.testing;\n-\n-import com.google.common.annotations.GwtCompatible;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import org.jspecify.annotations.NullMarked;\n-\n-/**\n- * An {@link ClusterException} is a data structure that allows for some code to \"throw multiple\n- * exceptions\", or something close to it. The prototypical code that calls for this class is\n- * presented below:\n- *\n- * <pre>\n- * void runManyThings({@literal List<ThingToRun>} thingsToRun) {\n- *   for (ThingToRun thingToRun : thingsToRun) {\n- *     thingToRun.run(); // say this may throw an exception, but you want to\n- *                       // always run all thingsToRun\n- *   }\n- * }\n- * </pre>\n- *\n- * <p>This is what the code would become:\n- *\n- * <pre>\n- * void runManyThings({@literal List<ThingToRun>} thingsToRun) {\n- *   {@literal List<Exception>} exceptions = Lists.newArrayList();\n- *   for (ThingToRun thingToRun : thingsToRun) {\n- *     try {\n- *       thingToRun.run();\n- *     } catch (Exception e) {\n- *       exceptions.add(e);\n- *     }\n- *   }\n- *   if (exceptions.size() &gt; 0) {\n- *     throw ClusterException.create(exceptions);\n- *   }\n- * }\n- * </pre>\n- *\n- * <p>See semantic details at {@link #create(Collection)}.\n- *\n- * @author Luiz-Otavio Zorzella\n- */\n-@GwtCompatible\n-@NullMarked\n-final class ClusterException extends RuntimeException {\n-\n-  final Collection<? extends Throwable> exceptions;\n-\n-  private ClusterException(Collection<? extends Throwable> exceptions) {\n-    super(\n-        exceptions.size() + \" exceptions were thrown. The first exception is listed as a cause.\",\n-        exceptions.iterator().next());\n-    ArrayList<? extends Throwable> temp = new ArrayList<>(exceptions);\n-    this.exceptions = Collections.unmodifiableCollection(temp);\n-  }\n-\n-  /** See {@link #create(Collection)}. */\n-  static RuntimeException create(Throwable... exceptions) {\n-    ArrayList<Throwable> temp = new ArrayList<>(Arrays.asList(exceptions));\n-    return create(temp);\n-  }\n-\n-  /**\n-   * Given a collection of exceptions, returns a {@link RuntimeException}, with the following rules:\n-   *\n-   * <ul>\n-   *   <li>If {@code exceptions} has a single exception and that exception is a {@link\n-   *       RuntimeException}, return it\n-   *   <li>If {@code exceptions} has a single exceptions and that exceptions is <em>not</em> a\n-   *       {@link RuntimeException}, return a simple {@code RuntimeException} that wraps it\n-   *   <li>Otherwise, return an instance of {@link ClusterException} that wraps the first exception\n-   *       in the {@code exceptions} collection.\n-   * </ul>\n-   *\n-   * <p>Though this method takes any {@link Collection}, it often makes most sense to pass a {@link\n-   * java.util.List} or some other collection that preserves the order in which the exceptions got\n-   * added.\n-   *\n-   * @throws NullPointerException if {@code exceptions} is null\n-   * @throws IllegalArgumentException if {@code exceptions} is empty\n-   */\n-  static RuntimeException create(Collection<? extends Throwable> exceptions) {\n-    if (exceptions.size() == 0) {\n-      throw new IllegalArgumentException(\"Can't create an ExceptionCollection with no exceptions\");\n-    }\n-    if (exceptions.size() == 1) {\n-      Throwable temp = exceptions.iterator().next();\n-      if (temp instanceof RuntimeException) {\n-        return (RuntimeException) temp;\n-      } else {\n-        return new RuntimeException(temp);\n-      }\n-    }\n-    return new ClusterException(exceptions);\n-  }\n-}\ndiff --git a/android/guava-testlib/src/com/google/common/testing/TearDownStack.java b/android/guava-testlib/src/com/google/common/testing/TearDownStack.java\nindex e0101e13eb73..5dff3b86df38 100644\n--- a/android/guava-testlib/src/com/google/common/testing/TearDownStack.java\n+++ b/android/guava-testlib/src/com/google/common/testing/TearDownStack.java\n@@ -17,6 +17,7 @@\n package com.google.common.testing;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Throwables.throwIfUnchecked;\n \n import com.google.common.annotations.GwtCompatible;\n import com.google.common.annotations.VisibleForTesting;\n@@ -66,7 +67,7 @@ public final void addTearDown(TearDown tearDown) {\n \n   /** Causes teardown to execute. */\n   public final void runTearDown() {\n-    List<Throwable> exceptions = new ArrayList<>();\n+    Throwable exception = null;\n     List<TearDown> stackCopy;\n     synchronized (lock) {\n       stackCopy = new ArrayList<>(stack);\n@@ -79,12 +80,17 @@ public final void runTearDown() {\n         if (suppressThrows) {\n           logger.log(Level.INFO, \"exception thrown during tearDown\", t);\n         } else {\n-          exceptions.add(t);\n+          if (exception == null) {\n+            exception = t;\n+          } else {\n+            exception.addSuppressed(t);\n+          }\n         }\n       }\n     }\n-    if (!suppressThrows && (exceptions.size() > 0)) {\n-      throw ClusterException.create(exceptions);\n+    if (exception != null) {\n+      throwIfUnchecked(exception);\n+      throw new RuntimeException(\"failure during tearDown\", exception);\n     }\n   }\n }\ndiff --git a/android/guava-testlib/test/com/google/common/testing/TearDownStackTest.java b/android/guava-testlib/test/com/google/common/testing/TearDownStackTest.java\nindex fe9fb8675582..7345fbd6fe23 100644\n--- a/android/guava-testlib/test/com/google/common/testing/TearDownStackTest.java\n+++ b/android/guava-testlib/test/com/google/common/testing/TearDownStackTest.java\n@@ -16,7 +16,9 @@\n \n package com.google.common.testing;\n \n+import static com.google.common.collect.Iterables.getOnlyElement;\n import static com.google.common.truth.Truth.assertThat;\n+import static java.util.Arrays.asList;\n \n import com.google.common.annotations.GwtCompatible;\n import junit.framework.TestCase;\n@@ -87,11 +89,11 @@ public void testThrowingTearDown() throws Exception {\n     try {\n       stack.runTearDown();\n       fail(\"runTearDown should have thrown an exception\");\n-    } catch (ClusterException expected) {\n-      assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(\"two\");\n-    } catch (RuntimeException e) {\n-      throw new RuntimeException(\n-          \"A ClusterException should have been thrown, rather than a \" + e.getClass().getName(), e);\n+    } catch (RuntimeException expected) {\n+      assertThat(expected).hasMessageThat().isEqualTo(\"two\");\n+      assertThat(getOnlyElement(asList(expected.getSuppressed())))\n+          .hasMessageThat()\n+          .isEqualTo(\"one\");\n     }\n \n     assertEquals(true, tearDownOne.ran);\ndiff --git a/guava-testlib/src/com/google/common/testing/ClusterException.java b/guava-testlib/src/com/google/common/testing/ClusterException.java\ndeleted file mode 100644\nindex 47232e8dd63b..000000000000\n--- a/guava-testlib/src/com/google/common/testing/ClusterException.java\n+++ /dev/null\n@@ -1,115 +0,0 @@\n-/*\n- * Copyright (C) 2009 The Guava Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.google.common.testing;\n-\n-import com.google.common.annotations.GwtCompatible;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import org.jspecify.annotations.NullMarked;\n-\n-/**\n- * An {@link ClusterException} is a data structure that allows for some code to \"throw multiple\n- * exceptions\", or something close to it. The prototypical code that calls for this class is\n- * presented below:\n- *\n- * <pre>\n- * void runManyThings({@literal List<ThingToRun>} thingsToRun) {\n- *   for (ThingToRun thingToRun : thingsToRun) {\n- *     thingToRun.run(); // say this may throw an exception, but you want to\n- *                       // always run all thingsToRun\n- *   }\n- * }\n- * </pre>\n- *\n- * <p>This is what the code would become:\n- *\n- * <pre>\n- * void runManyThings({@literal List<ThingToRun>} thingsToRun) {\n- *   {@literal List<Exception>} exceptions = Lists.newArrayList();\n- *   for (ThingToRun thingToRun : thingsToRun) {\n- *     try {\n- *       thingToRun.run();\n- *     } catch (Exception e) {\n- *       exceptions.add(e);\n- *     }\n- *   }\n- *   if (exceptions.size() &gt; 0) {\n- *     throw ClusterException.create(exceptions);\n- *   }\n- * }\n- * </pre>\n- *\n- * <p>See semantic details at {@link #create(Collection)}.\n- *\n- * @author Luiz-Otavio Zorzella\n- */\n-@GwtCompatible\n-@NullMarked\n-final class ClusterException extends RuntimeException {\n-\n-  final Collection<? extends Throwable> exceptions;\n-\n-  private ClusterException(Collection<? extends Throwable> exceptions) {\n-    super(\n-        exceptions.size() + \" exceptions were thrown. The first exception is listed as a cause.\",\n-        exceptions.iterator().next());\n-    ArrayList<? extends Throwable> temp = new ArrayList<>(exceptions);\n-    this.exceptions = Collections.unmodifiableCollection(temp);\n-  }\n-\n-  /** See {@link #create(Collection)}. */\n-  static RuntimeException create(Throwable... exceptions) {\n-    ArrayList<Throwable> temp = new ArrayList<>(Arrays.asList(exceptions));\n-    return create(temp);\n-  }\n-\n-  /**\n-   * Given a collection of exceptions, returns a {@link RuntimeException}, with the following rules:\n-   *\n-   * <ul>\n-   *   <li>If {@code exceptions} has a single exception and that exception is a {@link\n-   *       RuntimeException}, return it\n-   *   <li>If {@code exceptions} has a single exceptions and that exceptions is <em>not</em> a\n-   *       {@link RuntimeException}, return a simple {@code RuntimeException} that wraps it\n-   *   <li>Otherwise, return an instance of {@link ClusterException} that wraps the first exception\n-   *       in the {@code exceptions} collection.\n-   * </ul>\n-   *\n-   * <p>Though this method takes any {@link Collection}, it often makes most sense to pass a {@link\n-   * java.util.List} or some other collection that preserves the order in which the exceptions got\n-   * added.\n-   *\n-   * @throws NullPointerException if {@code exceptions} is null\n-   * @throws IllegalArgumentException if {@code exceptions} is empty\n-   */\n-  static RuntimeException create(Collection<? extends Throwable> exceptions) {\n-    if (exceptions.size() == 0) {\n-      throw new IllegalArgumentException(\"Can't create an ExceptionCollection with no exceptions\");\n-    }\n-    if (exceptions.size() == 1) {\n-      Throwable temp = exceptions.iterator().next();\n-      if (temp instanceof RuntimeException) {\n-        return (RuntimeException) temp;\n-      } else {\n-        return new RuntimeException(temp);\n-      }\n-    }\n-    return new ClusterException(exceptions);\n-  }\n-}\ndiff --git a/guava-testlib/src/com/google/common/testing/TearDownStack.java b/guava-testlib/src/com/google/common/testing/TearDownStack.java\nindex e0101e13eb73..5dff3b86df38 100644\n--- a/guava-testlib/src/com/google/common/testing/TearDownStack.java\n+++ b/guava-testlib/src/com/google/common/testing/TearDownStack.java\n@@ -17,6 +17,7 @@\n package com.google.common.testing;\n \n import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Throwables.throwIfUnchecked;\n \n import com.google.common.annotations.GwtCompatible;\n import com.google.common.annotations.VisibleForTesting;\n@@ -66,7 +67,7 @@ public final void addTearDown(TearDown tearDown) {\n \n   /** Causes teardown to execute. */\n   public final void runTearDown() {\n-    List<Throwable> exceptions = new ArrayList<>();\n+    Throwable exception = null;\n     List<TearDown> stackCopy;\n     synchronized (lock) {\n       stackCopy = new ArrayList<>(stack);\n@@ -79,12 +80,17 @@ public final void runTearDown() {\n         if (suppressThrows) {\n           logger.log(Level.INFO, \"exception thrown during tearDown\", t);\n         } else {\n-          exceptions.add(t);\n+          if (exception == null) {\n+            exception = t;\n+          } else {\n+            exception.addSuppressed(t);\n+          }\n         }\n       }\n     }\n-    if (!suppressThrows && (exceptions.size() > 0)) {\n-      throw ClusterException.create(exceptions);\n+    if (exception != null) {\n+      throwIfUnchecked(exception);\n+      throw new RuntimeException(\"failure during tearDown\", exception);\n     }\n   }\n }\ndiff --git a/guava-testlib/test/com/google/common/testing/TearDownStackTest.java b/guava-testlib/test/com/google/common/testing/TearDownStackTest.java\nindex fe9fb8675582..7345fbd6fe23 100644\n--- a/guava-testlib/test/com/google/common/testing/TearDownStackTest.java\n+++ b/guava-testlib/test/com/google/common/testing/TearDownStackTest.java\n@@ -16,7 +16,9 @@\n \n package com.google.common.testing;\n \n+import static com.google.common.collect.Iterables.getOnlyElement;\n import static com.google.common.truth.Truth.assertThat;\n+import static java.util.Arrays.asList;\n \n import com.google.common.annotations.GwtCompatible;\n import junit.framework.TestCase;\n@@ -87,11 +89,11 @@ public void testThrowingTearDown() throws Exception {\n     try {\n       stack.runTearDown();\n       fail(\"runTearDown should have thrown an exception\");\n-    } catch (ClusterException expected) {\n-      assertThat(expected).hasCauseThat().hasMessageThat().isEqualTo(\"two\");\n-    } catch (RuntimeException e) {\n-      throw new RuntimeException(\n-          \"A ClusterException should have been thrown, rather than a \" + e.getClass().getName(), e);\n+    } catch (RuntimeException expected) {\n+      assertThat(expected).hasMessageThat().isEqualTo(\"two\");\n+      assertThat(getOnlyElement(asList(expected.getSuppressed())))\n+          .hasMessageThat()\n+          .isEqualTo(\"one\");\n     }\n \n     assertEquals(true, tearDownOne.ran);\n",
  "additions": 34,
  "deletions": 248,
  "changed_files": 6,
  "url": "https://github.com/google/guava/pull/8036",
  "mined_at": "2025-10-25T12:51:50.418991"
}