diff --git a/android/guava/src/com/google/common/collect/ImmutableSet.java b/android/guava/src/com/google/common/collect/ImmutableSet.java
index 98722999c64b..e355478c4f77 100644
--- a/android/guava/src/com/google/common/collect/ImmutableSet.java
+++ b/android/guava/src/com/google/common/collect/ImmutableSet.java
@@ -262,11 +262,6 @@ static int chooseTableSize(int setSize) {
    * @throws NullPointerException if any of {@code elements} is null
    * @since 7.0 (source-compatible since 2.0)
    */
-  // This the best we could do to get copyOfEnumSet to compile in the mainline.
-  // The suppression also covers the cast to E[], discussed below.
-  // In the backport, we don't have those cases and thus don't need this suppression.
-  // We keep it to minimize diffs.
-  @SuppressWarnings("unchecked")
   public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {
     /*
      * TODO(lowasser): consider checking for ImmutableAsList here
diff --git a/guava/src/com/google/common/collect/ImmutableSet.java b/guava/src/com/google/common/collect/ImmutableSet.java
index 7a6ba99d14d5..5cc6b4469041 100644
--- a/guava/src/com/google/common/collect/ImmutableSet.java
+++ b/guava/src/com/google/common/collect/ImmutableSet.java
@@ -169,11 +169,6 @@ public static <E> ImmutableSet<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E... ot
    * @throws NullPointerException if any of {@code elements} is null
    * @since 7.0 (source-compatible since 2.0)
    */
-  // This the best we could do to get copyOfEnumSet to compile in the mainline.
-  // The suppression also covers the cast to E[], discussed below.
-  // In the backport, we don't have those cases and thus don't need this suppression.
-  // We keep it to minimize diffs.
-  @SuppressWarnings("unchecked")
   public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {
     /*
      * TODO(lowasser): consider checking for ImmutableAsList here
@@ -187,7 +182,15 @@ public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {
         return set;
       }
     } else if (elements instanceof EnumSet) {
-      return copyOfEnumSet((EnumSet<?>) elements);
+      EnumSet<?> clone = ((EnumSet<?>) elements).clone();
+      ImmutableSet<?> untypedResult = ImmutableEnumSet.asImmutable(clone);
+      /*
+       * The result has the same type argument we started with. We just couldn't express EnumSet<E>
+       * or ImmutableEnumSet<E> along the way because our own <E> isn't <E extends Enum<E>>.
+       */
+      @SuppressWarnings("unchecked")
+      ImmutableSet<E> result = (ImmutableSet<E>) untypedResult;
+      return result;
     }
 
     if (elements.isEmpty()) {
@@ -196,6 +199,7 @@ public static <E> ImmutableSet<E> copyOf(Collection<? extends E> elements) {
     }
     // Collection<E>.toArray() is required to contain only E instances, and all we do is read them.
     // TODO(cpovirk): Consider using Object[] anyway.
+    @SuppressWarnings("unchecked")
     E[] array = (E[]) elements.toArray();
     /*
      * For a Set, we guess that it contains no duplicates. That's just a guess for purpose of
@@ -270,11 +274,6 @@ private static <E> ImmutableSet<E> fromArrayWithExpectedSize(E[] elements, int e
     }
   }
 
-  @SuppressWarnings("rawtypes") // necessary to compile against Java 8
-  private static ImmutableSet copyOfEnumSet(EnumSet<?> enumSet) {
-    return ImmutableEnumSet.asImmutable(EnumSet.copyOf(enumSet));
-  }
-
   ImmutableSet() {}
 
   /** Returns {@code true} if the {@code hashCode()} method runs quickly. */
