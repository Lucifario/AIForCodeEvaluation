{
  "id": 7972,
  "repository": "google/guava",
  "title": "Revise `TypeResolver` comment further, including adding a TODO about annotations.",
  "body": "Revise `TypeResolver` comment further, including adding a TODO about annotations.\n\nRELNOTES=n/a\n",
  "state": "closed",
  "merged": true,
  "merged_at": "2025-09-05T21:20:32+00:00",
  "created_at": "2025-09-05T20:57:06+00:00",
  "updated_at": "2025-09-05T21:20:32+00:00",
  "author": "copybara-service[bot]",
  "reviewers": [],
  "base_sha": "1586eb271d9701b1c27f55d542c2ddaae0ff119d",
  "head_sha": "6dede7c7cd37e7ede3772de1a10a7806bb349cbe",
  "review_comments": [],
  "pr_comments": [],
  "files_changed": [
    {
      "filename": "android/guava/src/com/google/common/reflect/TypeResolver.java",
      "status": "modified",
      "additions": 22,
      "deletions": 7,
      "changes": 29,
      "patch": "@@ -331,15 +331,25 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n         Type[] resolvedBounds = new TypeResolver(forDependants).resolveTypes(bounds);\n         /*\n          * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's\n-         * just one problem: Under all the JDK versions that we support (though *not* under\n-         * Android), the built-in TypeVariable's equals() method doesn't recognize instances of our\n-         * TypeVariable implementation. This is a problem because users compare TypeVariables from\n-         * the JDK against TypeVariables returned by TypeResolver. To work with all JDK versions,\n-         * TypeResolver must return the appropriate TypeVariable implementation in each of the three\n-         * possible cases:\n+         * just one problem: We want to interoperate properly with the platform's built-in\n+         * implementation of TypeVariable, but the behavior of the built-in implementation differs\n+         * across platforms:\n+         *\n+         * - Under the JDK, the built-in TypeVariable's equals() method doesn't recognize instances\n+         *   of our TypeVariable implementation.\n+         *\n+         * - Under Android, it does.\n+         *\n+         * We want users to see the same behavior when they compare a built-in TypeVariable against\n+         * ours as they do when they perform the same comparison in reverse. To provide that\n+         * behavior on all platforms, TypeResolver must return the appropriate TypeVariable\n+         * implementation in each of the three possible cases:\n          *\n          * 1. Under Android, the built-in TypeVariable implementation interoperates with ours.\n-         * Therefore, we can always create our own TypeVariable.\n+         * Therefore, we can always create our own TypeVariable. (One downside of our TypeVariable\n+         * in some situations is that it does not support the AnnotatedType API. However, those\n+         * situations don't arise under Android because Android does not provide the AnnotatedType\n+         * API at all.)\n          *\n          * 2. Under the JDK, the built-in TypeVariable implementation does not interoperate with\n          * ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n@@ -357,6 +367,11 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n          * new TypeVariable _will_ be equal to is an equivalent TypeVariable that was also created\n          * by us. And that equality is guaranteed to hold because it doesn't involve the JDK\n          * TypeVariable implementation at all.\n+         *\n+         * TODO: b/147144588 - But what about when the TypeVariable has annotations? Our\n+         * implementation currently doesn't support annotations _at all_. It could at least be made\n+         * to respond to queries about annotations by returning null/empty, but are there situations\n+         * in which it should return something else?\n          */\n         if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY\n             && Arrays.equals(bounds, resolvedBounds)) {"
    },
    {
      "filename": "guava/src/com/google/common/reflect/TypeResolver.java",
      "status": "modified",
      "additions": 22,
      "deletions": 7,
      "changes": 29,
      "patch": "@@ -331,15 +331,25 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n         Type[] resolvedBounds = new TypeResolver(forDependants).resolveTypes(bounds);\n         /*\n          * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's\n-         * just one problem: Under all the JDK versions that we support (though *not* under\n-         * Android), the built-in TypeVariable's equals() method doesn't recognize instances of our\n-         * TypeVariable implementation. This is a problem because users compare TypeVariables from\n-         * the JDK against TypeVariables returned by TypeResolver. To work with all JDK versions,\n-         * TypeResolver must return the appropriate TypeVariable implementation in each of the three\n-         * possible cases:\n+         * just one problem: We want to interoperate properly with the platform's built-in\n+         * implementation of TypeVariable, but the behavior of the built-in implementation differs\n+         * across platforms:\n+         *\n+         * - Under the JDK, the built-in TypeVariable's equals() method doesn't recognize instances\n+         *   of our TypeVariable implementation.\n+         *\n+         * - Under Android, it does.\n+         *\n+         * We want users to see the same behavior when they compare a built-in TypeVariable against\n+         * ours as they do when they perform the same comparison in reverse. To provide that\n+         * behavior on all platforms, TypeResolver must return the appropriate TypeVariable\n+         * implementation in each of the three possible cases:\n          *\n          * 1. Under Android, the built-in TypeVariable implementation interoperates with ours.\n-         * Therefore, we can always create our own TypeVariable.\n+         * Therefore, we can always create our own TypeVariable. (One downside of our TypeVariable\n+         * in some situations is that it does not support the AnnotatedType API. However, those\n+         * situations don't arise under Android because Android does not provide the AnnotatedType\n+         * API at all.)\n          *\n          * 2. Under the JDK, the built-in TypeVariable implementation does not interoperate with\n          * ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n@@ -357,6 +367,11 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n          * new TypeVariable _will_ be equal to is an equivalent TypeVariable that was also created\n          * by us. And that equality is guaranteed to hold because it doesn't involve the JDK\n          * TypeVariable implementation at all.\n+         *\n+         * TODO: b/147144588 - But what about when the TypeVariable has annotations? Our\n+         * implementation currently doesn't support annotations _at all_. It could at least be made\n+         * to respond to queries about annotations by returning null/empty, but are there situations\n+         * in which it should return something else?\n          */\n         if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY\n             && Arrays.equals(bounds, resolvedBounds)) {"
    }
  ],
  "diff": "diff --git a/android/guava/src/com/google/common/reflect/TypeResolver.java b/android/guava/src/com/google/common/reflect/TypeResolver.java\nindex 2055c4340d12..b28ffbb7228c 100644\n--- a/android/guava/src/com/google/common/reflect/TypeResolver.java\n+++ b/android/guava/src/com/google/common/reflect/TypeResolver.java\n@@ -331,15 +331,25 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n         Type[] resolvedBounds = new TypeResolver(forDependants).resolveTypes(bounds);\n         /*\n          * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's\n-         * just one problem: Under all the JDK versions that we support (though *not* under\n-         * Android), the built-in TypeVariable's equals() method doesn't recognize instances of our\n-         * TypeVariable implementation. This is a problem because users compare TypeVariables from\n-         * the JDK against TypeVariables returned by TypeResolver. To work with all JDK versions,\n-         * TypeResolver must return the appropriate TypeVariable implementation in each of the three\n-         * possible cases:\n+         * just one problem: We want to interoperate properly with the platform's built-in\n+         * implementation of TypeVariable, but the behavior of the built-in implementation differs\n+         * across platforms:\n+         *\n+         * - Under the JDK, the built-in TypeVariable's equals() method doesn't recognize instances\n+         *   of our TypeVariable implementation.\n+         *\n+         * - Under Android, it does.\n+         *\n+         * We want users to see the same behavior when they compare a built-in TypeVariable against\n+         * ours as they do when they perform the same comparison in reverse. To provide that\n+         * behavior on all platforms, TypeResolver must return the appropriate TypeVariable\n+         * implementation in each of the three possible cases:\n          *\n          * 1. Under Android, the built-in TypeVariable implementation interoperates with ours.\n-         * Therefore, we can always create our own TypeVariable.\n+         * Therefore, we can always create our own TypeVariable. (One downside of our TypeVariable\n+         * in some situations is that it does not support the AnnotatedType API. However, those\n+         * situations don't arise under Android because Android does not provide the AnnotatedType\n+         * API at all.)\n          *\n          * 2. Under the JDK, the built-in TypeVariable implementation does not interoperate with\n          * ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n@@ -357,6 +367,11 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n          * new TypeVariable _will_ be equal to is an equivalent TypeVariable that was also created\n          * by us. And that equality is guaranteed to hold because it doesn't involve the JDK\n          * TypeVariable implementation at all.\n+         *\n+         * TODO: b/147144588 - But what about when the TypeVariable has annotations? Our\n+         * implementation currently doesn't support annotations _at all_. It could at least be made\n+         * to respond to queries about annotations by returning null/empty, but are there situations\n+         * in which it should return something else?\n          */\n         if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY\n             && Arrays.equals(bounds, resolvedBounds)) {\ndiff --git a/guava/src/com/google/common/reflect/TypeResolver.java b/guava/src/com/google/common/reflect/TypeResolver.java\nindex 2055c4340d12..b28ffbb7228c 100644\n--- a/guava/src/com/google/common/reflect/TypeResolver.java\n+++ b/guava/src/com/google/common/reflect/TypeResolver.java\n@@ -331,15 +331,25 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n         Type[] resolvedBounds = new TypeResolver(forDependants).resolveTypes(bounds);\n         /*\n          * We'd like to simply create our own TypeVariable with the newly resolved bounds. There's\n-         * just one problem: Under all the JDK versions that we support (though *not* under\n-         * Android), the built-in TypeVariable's equals() method doesn't recognize instances of our\n-         * TypeVariable implementation. This is a problem because users compare TypeVariables from\n-         * the JDK against TypeVariables returned by TypeResolver. To work with all JDK versions,\n-         * TypeResolver must return the appropriate TypeVariable implementation in each of the three\n-         * possible cases:\n+         * just one problem: We want to interoperate properly with the platform's built-in\n+         * implementation of TypeVariable, but the behavior of the built-in implementation differs\n+         * across platforms:\n+         *\n+         * - Under the JDK, the built-in TypeVariable's equals() method doesn't recognize instances\n+         *   of our TypeVariable implementation.\n+         *\n+         * - Under Android, it does.\n+         *\n+         * We want users to see the same behavior when they compare a built-in TypeVariable against\n+         * ours as they do when they perform the same comparison in reverse. To provide that\n+         * behavior on all platforms, TypeResolver must return the appropriate TypeVariable\n+         * implementation in each of the three possible cases:\n          *\n          * 1. Under Android, the built-in TypeVariable implementation interoperates with ours.\n-         * Therefore, we can always create our own TypeVariable.\n+         * Therefore, we can always create our own TypeVariable. (One downside of our TypeVariable\n+         * in some situations is that it does not support the AnnotatedType API. However, those\n+         * situations don't arise under Android because Android does not provide the AnnotatedType\n+         * API at all.)\n          *\n          * 2. Under the JDK, the built-in TypeVariable implementation does not interoperate with\n          * ours. Therefore, we have to be careful about whether we create our own TypeVariable:\n@@ -357,6 +367,11 @@ Type resolveInternal(TypeVariable<?> var, TypeTable forDependants) {\n          * new TypeVariable _will_ be equal to is an equivalent TypeVariable that was also created\n          * by us. And that equality is guaranteed to hold because it doesn't involve the JDK\n          * TypeVariable implementation at all.\n+         *\n+         * TODO: b/147144588 - But what about when the TypeVariable has annotations? Our\n+         * implementation currently doesn't support annotations _at all_. It could at least be made\n+         * to respond to queries about annotations by returning null/empty, but are there situations\n+         * in which it should return something else?\n          */\n         if (Types.NativeTypeVariableEquals.NATIVE_TYPE_VARIABLE_ONLY\n             && Arrays.equals(bounds, resolvedBounds)) {\n",
  "additions": 44,
  "deletions": 14,
  "changed_files": 2,
  "url": "https://github.com/google/guava/pull/7972",
  "mined_at": "2025-10-25T13:05:11.987158"
}