{
  "source_item_id": 1454,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:25:59.996115",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.ToIntFunction;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.lang3.stream.Streams;\n\n/**\n * Provides methods for Java enums.\n *\n * <p>#ThreadSafe#</p>\n *\n * @since 3.0\n */\npublic class EnumUtils {\n\n    private static final String CANNOT_STORE_S_S_VALUES_IN_S_BITS = \"Cannot store %s %s values in %s bits\";\n    private static final String ENUM_CLASS_MUST_BE_DEFINED = \"EnumClass must be defined.\";\n    private static final String NULL_ELEMENTS_NOT_PERMITTED = \"null elements not permitted\";\n    private static final String S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE = \"%s does not seem to be an Enum type\";\n\n    /**\n     * Validate {@code enumClass}.\n     *\n     * @param <E> the type of the enumeration.\n     * @param enumClass to check.\n     * @return {@code enumClass}.\n     * @throws NullPointerException if {@code enumClass} is {@code null}.\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class.\n     * @since 3.2\n     */\n    private static <E extends Enum<E>> Class<E> asEnum(final Class<E> enumClass) {\n        Objects.requireNonNull(enumClass, ENUM_CLASS_MUST_BE_DEFINED);\n        Validate.isTrue(enumClass.isEnum(), S_DOES_NOT_SEEM_TO_BE_AN_ENUM_TYPE, enumClass);\n        return enumClass;\n    }\n\n    /**\n     * Validate that {@code enumClass} is compatible with representation in a {@code long}.\n     *\n     * @param <E> the type of the enumeration.\n     * @param enumClass to check.\n     * @return {@code enumClass}.\n     * @throws NullPointerException if {@code enumClass} is {@code null}.\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values.\n     * @since 3.0.1\n     */\n    private static <E extends Enum<E>> Class<E> checkBitVectorable(final Class<E> enumClass) {\n        final E[] constants = asEnum(enumClass).getEnumConstants();\n        Validate.isTrue(constants.length <= Long.SIZE, CANNOT_STORE_S_S_VALUES_IN_S_BITS, Integer.valueOf(constants.length), enumClass.getSimpleName(),\n                Integer.valueOf(Long.SIZE));\n        return enumClass;\n    }\n\n    /**\n     * Creates a long bit vector representation of the given array of Enum values.\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVector}.</p>\n     *\n     * <p>Do not use this method if you have more than 64 values in your Enum, as this\n     * would create a value greater than a long can hold.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}.\n     * @param values    the values we want to convert, not {@code null}.\n     * @param <E>       the type of the enumeration.\n     * @return a long whose value provides a binary representation of the given set of enum values.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}.\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values.\n     * @since 3.0.1\n     * @see #generateBitVectors(Class, Iterable)\n     */\n    @SafeVarargs\n    public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final E... values) {\n        Validate.noNullElements(values);\n        return generateBitVector(enumClass, Arrays.asList(values));\n    }\n\n    /**\n     * Creates a long bit vector representation of the given subset of an Enum.\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVector}.</p>\n     *\n     * <p>Do not use this method if you have more than 64 values in your Enum, as this\n     * would create a value greater than a long can hold.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}.\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}.\n     * @param <E>       the type of the enumeration.\n     * @return a long whose value provides a binary representation of the given set of enum values.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}.\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class or has more than 64 values,\n     *                                  or if any {@code values} {@code null}.\n     * @since 3.0.1\n     * @see #generateBitVectors(Class, Iterable)\n     */\n    public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<? extends E> values) {\n        checkBitVectorable(enumClass);\n        Objects.requireNonNull(values, \"values\");\n        long total = 0;\n        for (final E constant : values) {\n            Objects.requireNonNull(constant, NULL_ELEMENTS_NOT_PERMITTED);\n            total |= 1L << constant.ordinal();\n        }\n        return total;\n    }\n\n    /**\n     * Creates a bit vector representation of the given subset of an Enum using as many {@code long}s as needed.\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVectors}.</p>\n     *\n     * <p>Use this method if you have more than 64 values in your Enum.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}.\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}.\n     * @param <E>       the type of the enumeration.\n     * @return a long[] whose values provide a binary representation of the given set of enum values\n     *         with the least significant digits rightmost.\n     * @throws NullPointerException if {@code enumClass} or {@code values} is {@code null}.\n     * @throws IllegalArgumentException if {@code enumClass} is not an enum class, or if any {@code values} {@code null}.\n     * @since 3.2\n     */\n    @SafeVarargs\n    public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final E... values) {\n        asEnum(enumClass);\n        Validate.noNullElements(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        Collections.addAll(condensed, values);\n        final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n        for (final E value : condensed) {\n            result[value.ordinal() / Long.SIZE] |= 1L << value.ordinal() % Long.SIZE;\n        }\n        ArrayUtils.reverse(result);\n        return result;\n    }\n\n    /**\n     * Creates a bit vector representation of the given subset of an Enum using as many {@code long}s as needed.\n     *\n     * <p>This generates a value that is usable by {@link EnumUtils#processBitVectors}.</p>\n     *\n     * <p>Use this method if you have more than 64 values in your Enum.</p>\n     *\n     * @param enumClass the class of the enum we are working with, not {@code null}.\n     * @param values    the values we want to convert, not {@code null}, neither containing {@code null}.\n     * @param <E>       the type of the enumeration.\n     * @return a long[] ",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The method generateBitVector and generateBitVectors do not handle the case where enumClass is not an Enum class, but it is not null. This can lead to a ClassCastException.\",\n         \"suggested_fix\": \"Add a check to ensure enumClass is an Enum class before proceeding with the rest of the method.\"\n      },\n      {\n         \"explanation\": \"The method generateBitVector and generateBitVectors do not handle the case where values is null, but enumClass is not null. This can lead to a NullPointerException.\",\n         \"suggested_fix\": \"Add a check to ensure values is not null before proceeding with the rest of the method.\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs were found in the provided code snippet.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The method generateBitVector and generateBitVectors do not handle the case where enumClass is not an Enum class, but it is not null. This can lead to a ClassCastException.",
        "suggested_fix": "Add a check to ensure enumClass is an Enum class before proceeding with the rest of the method."
      },
      {
        "explanation": "The method generateBitVector and generateBitVectors do not handle the case where values is null, but enumClass is not null. This can lead to a NullPointerException.",
        "suggested_fix": "Add a check to ensure values is not null before proceeding with the rest of the method."
      }
    ],
    "no_bugs_reasoning": "No bugs were found in the provided code snippet."
  },
  "error": null
}