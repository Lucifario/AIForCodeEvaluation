{"sample_id": "Closure_34", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.debugging.sourcemap.FilePosition;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.List;\n\n/**\n * CodePrinter prints out js code in either pretty format or compact format.\n *\n * @see CodeGenerator\n */\nclass CodePrinter {\n  // The number of characters after which we insert a line break in the code\n  static final int DEFAULT_LINE_LENGTH_THRESHOLD = 500;\n\n\n  // There are two separate CodeConsumers, one for pretty-printing and\n  // another for compact printing.\n\n  // There are two implementations because the CompactCodePrinter\n  // potentially has a very different implementation to the pretty\n  // version.\n\n  private abstract static class MappedCodePrinter extends CodeConsumer {\n    final private Deque<Mapping> mappings;\n    final private List<Mapping> allMappings;\n    final private boolean createSrcMap;\n    final private SourceMap.DetailLevel sourceMapDetailLevel;\n    protected final StringBuilder code = new StringBuilder(1024);\n    protected final int lineLengthThreshold;\n    protected int lineLength = 0;\n    protected int lineIndex = 0;\n\n    MappedCodePrinter(\n        int lineLengthThreshold,\n        boolean createSrcMap,\n        SourceMap.DetailLevel sourceMapDetailLevel) {\n      Preconditions.checkState(sourceMapDetailLevel != null);\n      this.lineLengthThreshold = lineLengthThreshold <= 0 ? Integer.MAX_VALUE :\n        lineLengthThreshold;\n      this.createSrcMap = createSrcMap;\n      this.sourceMapDetailLevel = sourceMapDetailLevel;\n      this.mappings = createSrcMap ? new ArrayDeque<Mapping>() : null;\n      this.allMappings = createSrcMap ? new ArrayList<Mapping>() : null;\n    }\n\n    /**\n     * Maintains a mapping from a given node to the position\n     * in the source code at which its generated form was\n     * placed. This position is relative only to the current\n     * run of the CodeConsumer and will be normalized\n     * later on by the SourceMap.\n     *\n     * @see SourceMap\n     */\n    private static class Mapping {\n      Node node;\n      FilePosition start;\n      FilePosition end;\n    }\n\n    /**\n     * Starts the source mapping for the given\n     * node at the current position.\n     */\n    @Override\n    void startSourceMapping(Node node) {\n      Preconditions.checkState(sourceMapDetailLevel != null);\n      Preconditions.checkState(node != null);\n      if (createSrcMap\n          && node.getSourceFileName() != null\n          && node.getLineno() > 0\n          && sourceMapDetailLevel.apply(node)) {\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n        Preconditions.checkState(line >= 0);\n        Mapping mapping = new Mapping();\n        mapping.node = node;\n        mapping.start = new FilePosition(line, index);\n        mappings.push(mapping);\n        allMappings.add(mapping);\n      }\n    }\n\n    /**\n     * Finishes the source mapping for the given\n     * node at the current position.\n     */\n    @Override\n    void endSourceMapping(Node node) {\n      if (createSrcMap && !mappings.isEmpty() && mappings.peek().node == node) {\n        Mapping mapping = mappings.pop();\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n        Preconditions.checkState(line >= 0);\n        mapping.end = new FilePosition(line, index);\n      }\n    }\n\n    /**\n     * Generates the source map from the given code consumer,\n     * appending the information it saved to the SourceMap\n     * object given.\n     */\n    void generateSourceMap(SourceMap map){\n      if (createSrcMap) {\n        for (Mapping mapping : allMappings) {\n          map.addMapping(mapping.node, mapping.start, mapping.end);\n        }\n      }\n    }\n\n    /**\n     * Reports to the code consumer that the given line has been cut at the\n     * given position, i.e. a \\n has been inserted there. Or that a cut has\n     * been undone, i.e. a previously inserted \\n has been removed.\n     * All mappings in the source maps after that position will be renormalized\n     * as needed.\n     */\n    void reportLineCut(int lineIndex, int charIndex, boolean insertion) {\n      if (createSrcMap) {\n        for (Mapping mapping : allMappings) {\n          mapping.start = convertPosition(mapping.start, lineIndex, charIndex,\n              insertion);\n\n          if (mapping.end != null) {\n            mapping.end = convertPosition(mapping.end, lineIndex, charIndex,\n                insertion);\n          }\n        }\n      }\n    }\n\n    /**\n     * Converts the given position by normalizing it against the insertion\n     * or removal of a newline at the given line and character position.\n     *\n     * @param position The existing position before the newline was inserted.\n     * @param lineIndex The index of the line at which the newline was inserted.\n     * @param characterPosition The position on the line at which the newline\n     *     was inserted.\n     * @param insertion True if a newline was inserted, false if a newline was\n     *     removed.\n     *\n     * @return The normalized position.\n     * @throws IllegalStateException if an attempt to reverse a line cut is\n     *     made on a previous line rather than the current line.\n     */\n    private FilePosition convertPosition(FilePosition position, int lineIndex,\n                                     int characterPosition, boolean insertion) {\n      int originalLine = position.getLine();\n      int originalChar = position.getColumn();\n      if (insertion) {\n        if (originalLine == lineIndex && originalChar >= characterPosition) {\n          // If the position falls on the line itself, then normalize it\n          // if it falls at or after the place the newline was inserted.\n          return new FilePosition(\n              originalLine + 1, originalChar - characterPosition);\n        } else {\n          return position;\n        }\n      } else {\n        if (originalLine == lineIndex) {\n          return new FilePosition(\n              originalLine - 1, originalChar + characterPosition);\n        } else if (originalLine > lineIndex) {\n            // Not supported, can only undo a cut on the most recent line. To\n            // do this on a previous lines would require reevaluating the cut\n            // positions on all subsequent lines.\n            throw new IllegalStateException(\n                \"Cannot undo line cut on a previous line.\");\n        } else {\n          return position;\n        }\n      }\n    }\n\n    public String getCode() {\n      return code.toString();\n    }\n\n    @Override\n    char getLastChar() {\n      return (code.length() > 0) ? code.charAt(code.length() - 1) : '\\0';\n    }\n\n    protected final int getCurrentCharIndex() {\n      return lineLength;\n    }\n\n    protected final int getCurrentLineIndex() {\n      return lineIndex;\n    }\n  }\n\n  static class PrettyCodePrinter\n      extends MappedCodePrinter {\n    // The number of characters after which we insert a line break in the code\n    static final String INDENT = \"  \";\n\n    private int indent = 0;\n\n    /**\n     * @param lineLengthThreshold The length of a line after which we force\n     *                            a newline when possible.\n     * @param createSourceMap Whether to generate source map data.\n     * @param sourceMapDetailLevel A filter to control which nodes get mapped\n     *     into the source map.\n     */\n    private PrettyCodePrinter(\n        int lineLengthThreshold,\n        boolean createSourceMap,\n        SourceMap.DetailLevel sourceMapDetailLevel) {\n      super(lineLengthThreshold, createSourceMap, sourceMapDetailLevel);\n    }\n\n    /**\n     * Appends a string to the code, keeping track of the current line length.\n     */\n    @Override\n    void append(String str) {\n      // For pretty printing: indent at the beginning of the line\n      if (lineLength == 0) {\n        for (int i = 0; i < indent; i++) {\n          code.append(INDENT);\n          lineLength += INDENT.length();\n        }\n      }\n      code.append(str);\n      lineLength += str.length();\n    }\n\n    /**\n     * Adds a newline to the code, resetting the line length and handling\n     * indenting for pretty printing.\n     */\n    @Override\n    void startNewLine() {\n      if (lineLength > 0) {\n        code.append('\\n');\n        lineIndex++;\n        lineLength = 0;\n      }\n    }\n\n    @Override\n    void maybeLineBreak() {\n      maybeCutLine();\n    }\n\n    /**\n     * This may start a new line if the current line is longer than the line\n     * length threshold.\n     */\n    @Override\n    void maybeCutLine() {\n      if (lineLength > lineLengthThreshold) {\n        startNewLine();\n      }\n    }\n\n    @Override\n    void endLine() {\n      startNewLine();\n    }\n\n    @Override\n    void appendBlockStart() {\n      append(\" {\");\n      indent++;\n    }\n\n    @Override\n    void appendBlockEnd() {\n      endLine();\n      indent--;\n      append(\"}\");\n    }\n\n    @Override\n    void listSeparator() {\n      add(\", \");\n      maybeLineBreak();\n    }\n\n    @Override\n    void endFunction(boolean statementContext) {\n      super.endFunction(statementContext);\n      if (statementContext) {\n        startNewLine();\n      }\n    }\n\n    @Override\n    void beginCaseBody() {\n      super.beginCaseBody();\n      indent++;\n      endLine();\n    }\n\n    @Override\n    void endCaseBody() {\n      super.endCaseBody();\n      indent--;\n      endStatement();\n    }\n\n    @Override\n    void appendOp(String op, boolean binOp) {\n      if (binOp) {\n        if (getLastChar() != ' ') {\n          append(\" \");\n        }\n        append(op);\n        append(\" \");\n      } else {\n        append(op);\n      }\n    }\n\n    /**\n     * If the body of a for loop or the then clause of an if statement has\n     * a single statement, should it be wrapped in a block?\n     * {@inheritDoc}\n     */\n    @Override\n    boolean shouldPreserveExtraBlocks() {\n      // When pretty-printing, always place the statement in its own block\n      // so it is printed on a separate line.  This allows breakpoints to be\n      // placed on the statement.\n      return true;\n    }\n\n    /**\n     * @return The TRY node for the specified CATCH node.\n     */\n    private Node getTryForCatch(Node n) {\n      return n.getParent().getParent();\n    }\n\n    /**\n     * @return Whether the a line break should be added after the specified\n     * BLOCK.\n     */\n    @Override\n    boolean breakAfterBlockFor(Node n,  boolean isStatementContext) {\n      Preconditions.checkState(n.isBlock());\n      Node parent = n.getParent();\n      if (parent != null) {\n        int type = parent.getType();\n        switch (type) {\n          case Token.DO:\n            // Don't break before 'while' in DO-WHILE statements.\n            return false;\n          case Token.FUNCTION:\n            // FUNCTIONs are handled separately, don't break here.\n            return false;\n          case Token.TRY:\n            // Don't break before catch\n            return n != parent.getFirstChild();\n          case Token.CATCH:\n            // Don't break before finally\n            return !NodeUtil.hasFinally(getTryForCatch(parent));\n          case Token.IF:\n            // Don't break before else\n            return n == parent.getLastChild();\n        }\n      }\n      return true;\n    }\n\n    @Override\n    void endFile() {\n      maybeEndStatement();\n    }\n  }\n\n\n  static class CompactCodePrinter\n      extends MappedCodePrinter {\n\n    // The CompactCodePrinter tries to emit just enough newlines to stop there\n    // being lines longer than the threshold.  Since the output is going to be\n    // gzipped, it makes sense to try to make the newlines appear in similar\n    // contexts so that GZIP can encode them for 'free'.\n    //\n    // This version tries to break the lines at 'preferred' places, which are\n    // between the top-level forms.  This works because top level forms tend to\n    // be more uniform than arbitary legal contexts.  Better compression would\n    // probably require explicit modelling of the gzip algorithm.\n\n    private final boolean lineBreak;\n    private final boolean preferLineBreakAtEndOfFile;\n    private int lineStartPosition = 0;\n    private int preferredBreakPosition = 0;\n    private int prevCutPosition = 0;\n    private int prevLineStartPosition = 0;\n\n  /**\n   * @param lineBreak break the lines a bit more aggressively\n   * @param lineLengthThreshold The length of a line after which we force\n   *                            a newline when possible.\n   * @param createSrcMap Whether to gather source position\n   *                            mapping information when printing.\n   * @param sourceMapDetailLevel A filter to control which nodes get mapped into\n   *     the source map.\n   */\n    private CompactCodePrinter(boolean lineBreak,\n        boolean preferLineBreakAtEndOfFile, int lineLengthThreshold,\n        boolean createSrcMap, SourceMap.DetailLevel sourceMapDetailLevel) {\n      super(lineLengthThreshold, createSrcMap, sourceMapDetailLevel);\n      this.lineBreak = lineBreak;\n      this.preferLineBreakAtEndOfFile = preferLineBreakAtEndOfFile;\n    }\n\n    /**\n     * Appends a string to the code, keeping track of the current line length.\n     */\n    @Override\n    void append(String str) {\n      code.append(str);\n      lineLength += str.length();\n    }\n\n    /**\n     * Adds a newline to the code, resetting the line length.\n     */\n    @Override\n    void startNewLine() {\n      if (lineLength > 0) {\n        prevCutPosition = code.length();\n        prevLineStartPosition = lineStartPosition;\n        code.append('\\n');\n        lineLength = 0;\n        lineIndex++;\n        lineStartPosition = code.length();\n      }\n    }\n\n    @Override\n    void maybeLineBreak() {\n      if (lineBreak) {\n        if (sawFunction) {\n          startNewLine();\n          sawFunction = false;\n        }\n      }\n\n      // Since we are at a legal line break, can we upgrade the\n      // preferred break position?  We prefer to break after a\n      // semicolon rather than before it.\n      int len = code.length();\n      if (preferredBreakPosition == len - 1) {\n        char ch = code.charAt(len - 1);\n        if (ch == ';') {\n          preferredBreakPosition = len;\n        }\n      }\n      maybeCutLine();\n    }\n\n    /**\n     * This may start a new line if the current line is longer than the line\n     * length threshold.\n     */\n    @Override\n    void maybeCutLine() {\n      if (lineLength > lineLengthThreshold) {\n        // Use the preferred position provided it will break the line.\n        if (preferredBreakPosition > lineStartPosition &&\n            preferredBreakPosition < lineStartPosition + lineLength) {\n          int position = preferredBreakPosition;\n          code.insert(position, '\\n');\n          prevCutPosition = position;\n          reportLineCut(lineIndex, position - lineStartPosition, true);\n          lineIndex++;\n          lineLength -= (position - lineStartPosition);\n          lineStartPosition = position + 1;\n        } else {\n          startNewLine();\n        }\n      }\n    }\n\n    @Override\n    void notePreferredLineBreak() {\n      preferredBreakPosition = code.length();\n    }\n\n    @Override\n    void endFile() {\n      super.endFile();\n      if (!preferLineBreakAtEndOfFile) {\n        return;\n      }\n      if (lineLength > lineLengthThreshold / 2) {\n        // Add an extra break at end of file.\n        append(\";\");\n        startNewLine();\n      } else if (prevCutPosition > 0) {\n        // Shift the previous break to end of file by replacing it with a\n        // <space> and adding a new break at end of file. Adding the space\n        // handles cases like instanceof\\nfoo. (it would be nice to avoid this)\n        code.setCharAt(prevCutPosition, ' ');\n        lineStartPosition = prevLineStartPosition;\n        lineLength = code.length() - lineStartPosition;\n        reportLineCut(lineIndex, prevCutPosition + 1, false);\n        lineIndex--;\n        prevCutPosition = 0;\n        prevLineStartPosition = 0;\n        append(\";\");\n        startNewLine();\n      } else {\n        // A small file with no line breaks. We do nothing in this case to\n        // avoid excessive line breaks. It's not ideal if a lot of these pile\n        // up, but that is reasonably unlikely.\n      }\n    }\n\n  }\n\n  static class Builder {\n    private final Node root;\n    private boolean prettyPrint = false;\n    private boolean lineBreak = false;\n    private boolean preferLineBreakAtEndOfFile = false;\n    private boolean outputTypes = false;\n    private int lineLengthThreshold = DEFAULT_LINE_LENGTH_THRESHOLD;\n    private SourceMap sourceMap = null;\n    private SourceMap.DetailLevel sourceMapDetailLevel =\n        SourceMap.DetailLevel.ALL;\n    // Specify a charset to use when outputting source code.  If null,\n    // then just output ASCII.\n    private Charset outputCharset = null;\n    private boolean tagAsStrict;\n\n    /**\n     * Sets the root node from which to generate the source code.\n     * @param node The root node.\n     */\n    Builder(Node node) {\n      root = node;\n    }\n\n    /**\n     * Sets whether pretty printing should be used.\n     * @param prettyPrint If true, pretty printing will be used.\n     */\n    Builder setPrettyPrint(boolean prettyPrint) {\n      this.prettyPrint = prettyPrint;\n      return this;\n    }\n\n    /**\n     * Sets whether line breaking should be done automatically.\n     * @param lineBreak If true, line breaking is done automatically.\n     */\n    Builder setLineBreak(boolean lineBreak) {\n      this.lineBreak = lineBreak;\n      return this;\n    }\n\n    /**\n     * Sets whether line breaking is preferred at end of file. This is useful\n     * if JS serving code needs a place to insert code, such as script tags,\n     * without interfering with source maps.\n     * @param lineBreakAtEnd If true, prefer line breaking at end of file.\n     */\n    Builder setPreferLineBreakAtEndOfFile(boolean lineBreakAtEnd) {\n      this.preferLineBreakAtEndOfFile = lineBreakAtEnd;\n      return this;\n    }\n\n    /**\n     * Sets whether to output closure-style type annotations.\n     * @param outputTypes If true, outputs closure-style type annotations.\n     */\n    Builder setOutputTypes(boolean outputTypes) {\n      this.outputTypes = outputTypes;\n      return this;\n    }\n\n    /**\n     * Sets the line length threshold that will be used to determine\n     * when to break lines, if line breaking is on.\n     *\n     * @param threshold The line length threshold.\n     */\n    Builder setLineLengthThreshold(int threshold) {\n      this.lineLengthThreshold = threshold;\n      return this;\n    }\n\n    /**\n     * Sets the source map to which to write the metadata about\n     * the generated source code.\n     *\n     * @param sourceMap The source map.\n     */\n    Builder setSourceMap(SourceMap sourceMap) {\n      this.sourceMap = sourceMap;\n      return this;\n    }\n\n    /**\n     * @param level The detail level to use.\n     */\n    Builder setSourceMapDetailLevel(SourceMap.DetailLevel level) {\n      Preconditions.checkState(level != null);\n      this.sourceMapDetailLevel = level;\n      return this;\n    }\n\n    /**\n     * Set the charset to use when determining what characters need to be\n     * escaped in the output.\n     */\n    Builder setOutputCharset(Charset outCharset) {\n      this.outputCharset = outCharset;\n      return this;\n    }\n\n    /**\n     * Set whether the output should be tags as ECMASCRIPT 5 Strict.\n     */\n    Builder setTagAsStrict(boolean tagAsStrict) {\n      this.tagAsStrict = tagAsStrict;\n      return this;\n    }\n\n    /**\n     * Generates the source code and returns it.\n     */\n    String build() {\n      if (root == null) {\n        throw new IllegalStateException(\n            \"Cannot build without root node being specified\");\n      }\n\n      Format outputFormat = outputTypes\n          ? Format.TYPED\n          : prettyPrint\n              ? Format.PRETTY\n              : Format.COMPACT;\n\n      return toSource(root, outputFormat, lineBreak, preferLineBreakAtEndOfFile,\n          lineLengthThreshold, sourceMap, sourceMapDetailLevel, outputCharset,\n          tagAsStrict);\n    }\n  }\n\n  enum Format {\n    COMPACT,\n    PRETTY,\n    TYPED\n  }\n\n  /**\n   * Converts a tree to js code\n   */\n  private static String toSource(Node root, Format outputFormat,\n                                 boolean lineBreak,  boolean preferEndOfFileBreak,\n                                 int lineLengthThreshold,\n                                 SourceMap sourceMap,\n                                 SourceMap.DetailLevel sourceMapDetailLevel,\n                                 Charset outputCharset,\n                                 boolean tagAsStrict) {\n    Preconditions.checkState(sourceMapDetailLevel != null);\n\n    boolean createSourceMap = (sourceMap != null);\n    MappedCodePrinter mcp =\n        outputFormat == Format.COMPACT\n        ? new CompactCodePrinter(\n            lineBreak, preferEndOfFileBreak, lineLengthThreshold,\n            createSourceMap, sourceMapDetailLevel)\n        : new PrettyCodePrinter(\n            lineLengthThreshold, createSourceMap, sourceMapDetailLevel);\n    CodeGenerator cg =\n        outputFormat == Format.TYPED\n        ? new TypedCodeGenerator(mcp, outputCharset)\n        : new CodeGenerator(mcp, outputCharset);\n\n    if (tagAsStrict) {\n      cg.tagAsStrict();\n    }\n\n    cg.add(root);\n    mcp.endFile();\n\n    String code = mcp.getCode();\n\n    if (createSourceMap) {\n      mcp.generateSourceMap(sourceMap);\n    }\n\n    return code;\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"description\": \"Infinite loop in `printNewline()` method\",\n      \"code\": \"    while (lineLength >= lineLengthThreshold) {\",\n      \"line\": 427,\n      \"column\": 5\n    },\n    {\n      \"description\": \"Null pointer exception in `generateSourceMap()` method\",\n      \"code\": \"map.addMapping(mapping.node, mapping.start, mapping.end);\",\n      \"line\": 557,\n      \"column\": 9\n    },\n    {\n      \"description\": \"Incorrect normalization of line breaks in `reportLineCut()` method\",\n      \"code\": \"mapping.start = convertPosition(mapping.start, lineIndex, charIndex, insertion);\",\n      \"line\": 513,\n      \"column\": 5\n    },\n    {\n      \"description\": \"Unused variable `createSrcMap`\",\n      \"code\": \"boolean createSrcMap,\",\n      \"line\": 143,\n      \"column\": 27\n    },\n    {\n      \"description\": \"Unused variable `sourceMapDetailLevel`\",\n      \"code\": \"SourceMap.DetailLevel sourceMapDetailLevel\",\n      \"line\": 144,\n      \"column\": 27\n    },\n    {\n      \"description\": \"Unused import\",\n      \"code\": \"import com.google.debugging.sourcemap.FilePosition;\",\n      \"line\": 10,\n      \"column\": 0\n    }\n  ]\n}"}}