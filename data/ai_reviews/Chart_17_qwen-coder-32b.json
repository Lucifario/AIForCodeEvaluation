{"sample_id": "Chart_17", "model": "qwen-coder-32b", "code_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ---------------\n * TimeSeries.java\n * ---------------\n * (C) Copyright 2001-2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Bryan Scott;\n *                   Nick Guenther;\n *\n * Changes\n * -------\n * 11-Oct-2001 : Version 1 (DG);\n * 14-Nov-2001 : Added listener mechanism (DG);\n * 15-Nov-2001 : Updated argument checking and exceptions in add() method (DG);\n * 29-Nov-2001 : Added properties to describe the domain and range (DG);\n * 07-Dec-2001 : Renamed TimeSeries --> BasicTimeSeries (DG);\n * 01-Mar-2002 : Updated import statements (DG);\n * 28-Mar-2002 : Added a method add(TimePeriod, double) (DG);\n * 27-Aug-2002 : Changed return type of delete method to void (DG);\n * 04-Oct-2002 : Added itemCount and historyCount attributes, fixed errors \n *               reported by Checkstyle (DG);\n * 29-Oct-2002 : Added series change notification to addOrUpdate() method (DG);\n * 28-Jan-2003 : Changed name back to TimeSeries (DG);\n * 13-Mar-2003 : Moved to com.jrefinery.data.time package and implemented \n *               Serializable (DG);\n * 01-May-2003 : Updated equals() method (see bug report 727575) (DG);\n * 14-Aug-2003 : Added ageHistoryCountItems method (copied existing code for \n *               contents) made a method and added to addOrUpdate.  Made a \n *               public method to enable ageing against a specified time \n *               (eg now) as opposed to lastest time in series (BS);\n * 15-Oct-2003 : Added fix for setItemCount method - see bug report 804425.  \n *               Modified exception message in add() method to be more \n *               informative (DG);\n * 13-Apr-2004 : Added clear() method (DG);\n * 21-May-2004 : Added an extra addOrUpdate() method (DG);\n * 15-Jun-2004 : Fixed NullPointerException in equals() method (DG);\n * 29-Nov-2004 : Fixed bug 1075255 (DG);\n * 17-Nov-2005 : Renamed historyCount --> maximumItemAge (DG);\n * 28-Nov-2005 : Changed maximumItemAge from int to long (DG);\n * 01-Dec-2005 : New add methods accept notify flag (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 24-May-2006 : Improved error handling in createCopy() methods (DG);\n * 01-Sep-2006 : Fixed bugs in removeAgedItems() methods - see bug report \n *               1550045 (DG);\n * 22-Mar-2007 : Simplified getDataItem(RegularTimePeriod) - see patch 1685500 \n *               by Nick Guenther (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 29-Jun-2007 : Changed first parameter in constructors from String to \n *               Comparable (DG);\n * 31-Oct-2007 : Implemented faster hashCode() (DG);\n * 21-Nov-2007 : Fixed clone() method (bug 1832432) (DG);\n * \n */\n\npackage org.jfree.data.time;\n\nimport java.io.Serializable;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.data.general.Series;\nimport org.jfree.data.general.SeriesChangeEvent;\nimport org.jfree.data.general.SeriesException;\n\n/**\n * Represents a sequence of zero or more data items in the form (period, value).\n */\npublic class TimeSeries extends Series implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -5032960206869675528L;\n    \n    /** Default value for the domain description. */\n    protected static final String DEFAULT_DOMAIN_DESCRIPTION = \"Time\";\n\n    /** Default value for the range description. */\n    protected static final String DEFAULT_RANGE_DESCRIPTION = \"Value\";\n\n    /** A description of the domain. */\n    private String domain;\n\n    /** A description of the range. */\n    private String range;\n\n    /** The type of period for the data. */\n    protected Class timePeriodClass;\n\n    /** The list of data items in the series. */\n    protected List data;\n\n    /** The maximum number of items for the series. */\n    private int maximumItemCount;\n\n    /** \n     * The maximum age of items for the series, specified as a number of\n     * time periods. \n     */\n    private long maximumItemAge;\n    \n    /**\n     * Creates a new (empty) time series.  By default, a daily time series is \n     * created.  Use one of the other constructors if you require a different \n     * time period.\n     *\n     * @param name  the series name (<code>null</code> not permitted).\n     */\n    public TimeSeries(Comparable name) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION, \n                Day.class);\n    }\n\n    /**\n     * Creates a new (empty) time series with the specified name and class\n     * of {@link RegularTimePeriod}.\n     *\n     * @param name  the series name (<code>null</code> not permitted).\n     * @param timePeriodClass  the type of time period (<code>null</code> not \n     *                         permitted).\n     */\n    public TimeSeries(Comparable name, Class timePeriodClass) {\n        this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION, \n                timePeriodClass);\n    }\n\n    /**\n     * Creates a new time series that contains no data.\n     * <P>\n     * Descriptions can be specified for the domain and range.  One situation\n     * where this is helpful is when generating a chart for the time series -\n     * axis labels can be taken from the domain and range description.\n     *\n     * @param name  the name of the series (<code>null</code> not permitted).\n     * @param domain  the domain description (<code>null</code> permitted).\n     * @param range  the range description (<code>null</code> permitted).\n     * @param timePeriodClass  the type of time period (<code>null</code> not \n     *                         permitted).\n     */\n    public TimeSeries(Comparable name, String domain, String range, \n                      Class timePeriodClass) {\n        super(name);\n        this.domain = domain;\n        this.range = range;\n        this.timePeriodClass = timePeriodClass;\n        this.data = new java.util.ArrayList();\n        this.maximumItemCount = Integer.MAX_VALUE;\n        this.maximumItemAge = Long.MAX_VALUE;\n    }\n\n    /**\n     * Returns the domain description.\n     *\n     * @return The domain description (possibly <code>null</code>).\n     * \n     * @see #setDomainDescription(String)\n     */\n    public String getDomainDescription() {\n        return this.domain;\n    }\n\n    /**\n     * Sets the domain description and sends a <code>PropertyChangeEvent</code> \n     * (with the property name <code>Domain</code>) to all registered\n     * property change listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     * \n     * @see #getDomainDescription()\n     */\n    public void setDomainDescription(String description) {\n        String old = this.domain;\n        this.domain = description;\n        firePropertyChange(\"Domain\", old, description);\n    }\n\n    /**\n     * Returns the range description.\n     *\n     * @return The range description (possibly <code>null</code>).\n     * \n     * @see #setRangeDescription(String)\n     */\n    public String getRangeDescription() {\n        return this.range;\n    }\n\n    /**\n     * Sets the range description and sends a <code>PropertyChangeEvent</code> \n     * (with the property name <code>Range</code>) to all registered listeners.\n     *\n     * @param description  the description (<code>null</code> permitted).\n     * \n     * @see #getRangeDescription()\n     */\n    public void setRangeDescription(String description) {\n        String old = this.range;\n        this.range = description;\n        firePropertyChange(\"Range\", old, description);\n    }\n\n    /**\n     * Returns the number of items in the series.\n     *\n     * @return The item count.\n     */\n    public int getItemCount() {\n        return this.data.size();\n    }\n\n    /**\n     * Returns the list of data items for the series (the list contains \n     * {@link TimeSeriesDataItem} objects and is unmodifiable).\n     *\n     * @return The list of data items.\n     */\n    public List getItems() {\n        return Collections.unmodifiableList(this.data);\n    }\n\n    /**\n     * Returns the maximum number of items that will be retained in the series.\n     * The default value is <code>Integer.MAX_VALUE</code>.\n     *\n     * @return The maximum item count.\n     * \n     * @see #setMaximumItemCount(int)\n     */\n    public int getMaximumItemCount() {\n        return this.maximumItemCount;\n    }\n\n    /**\n     * Sets the maximum number of items that will be retained in the series.  \n     * If you add a new item to the series such that the number of items will \n     * exceed the maximum item count, then the FIRST element in the series is \n     * automatically removed, ensuring that the maximum item count is not \n     * exceeded.\n     *\n     * @param maximum  the maximum (requires >= 0).\n     * \n     * @see #getMaximumItemCount()\n     */\n    public void setMaximumItemCount(int maximum) {\n        if (maximum < 0) {\n            throw new IllegalArgumentException(\"Negative 'maximum' argument.\");\n        }\n        this.maximumItemCount = maximum;\n        int count = this.data.size();\n        if (count > maximum) {\n            delete(0, count - maximum - 1);\n        }\n    }\n\n    /**\n     * Returns the maximum item age (in time periods) for the series.\n     *\n     * @return The maximum item age.\n     * \n     * @see #setMaximumItemAge(long)\n     */\n    public long getMaximumItemAge() {\n        return this.maximumItemAge;\n    }\n\n    /**\n     * Sets the number of time units in the 'history' for the series.  This \n     * provides one mechanism for automatically dropping old data from the\n     * time series. For example, if a series contains daily data, you might set\n     * the history count to 30.  Then, when you add a new data item, all data\n     * items more than 30 days older than the latest value are automatically \n     * dropped from the series.\n     *\n     * @param periods  the number of time periods.\n     * \n     * @see #getMaximumItemAge()\n     */\n    public void setMaximumItemAge(long periods) {\n        if (periods < 0) {\n            throw new IllegalArgumentException(\"Negative 'periods' argument.\");\n        }\n        this.maximumItemAge = periods;\n        removeAgedItems(true);  // remove old items and notify if necessary\n    }\n\n    /**\n     * Returns the time period class for this series.\n     * <p>\n     * Only one time period class can be used within a single series (enforced).\n     * If you add a data item with a {@link Year} for the time period, then all\n     * subsequent data items must also have a {@link Year} for the time period.\n     *\n     * @return The time period class (never <code>null</code>).\n     */\n    public Class getTimePeriodClass() {\n        return this.timePeriodClass;\n    }\n\n    /**\n     * Returns a data item for the series.\n     *\n     * @param index  the item index (zero-based).\n     *\n     * @return The data item.\n     * \n     * @see #getDataItem(RegularTimePeriod)\n     */\n    public TimeSeriesDataItem getDataItem(int index) {\n        return (TimeSeriesDataItem) this.data.get(index);\n    }\n\n    /**\n     * Returns the data item for a specific period.\n     *\n     * @param period  the period of interest (<code>null</code> not allowed).\n     *\n     * @return The data item matching the specified period (or \n     *         <code>null</code> if there is no match).\n     *\n     * @see #getDataItem(int)\n     */\n    public TimeSeriesDataItem getDataItem(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            return (TimeSeriesDataItem) this.data.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the time period at the specified index.\n     *\n     * @param index  the index of the data item.\n     *\n     * @return The time period.\n     */\n    public RegularTimePeriod getTimePeriod(int index) {\n        return getDataItem(index).getPeriod();\n    }\n\n    /**\n     * Returns a time period that would be the next in sequence on the end of\n     * the time series.\n     *\n     * @return The next time period.\n     */\n    public RegularTimePeriod getNextTimePeriod() {\n        RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n        return last.next();\n    }\n\n    /**\n     * Returns a collection of all the time periods in the time series.\n     *\n     * @return A collection of all the time periods.\n     */\n    public Collection getTimePeriods() {\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < getItemCount(); i++) {\n            result.add(getTimePeriod(i));\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of time periods in the specified series, but not in\n     * this series, and therefore unique to the specified series.\n     *\n     * @param series  the series to check against this one.\n     *\n     * @return The unique time periods.\n     */\n    public Collection getTimePeriodsUniqueToOtherSeries(TimeSeries series) {\n\n        Collection result = new java.util.ArrayList();\n        for (int i = 0; i < series.getItemCount(); i++) {\n            RegularTimePeriod period = series.getTimePeriod(i);\n            int index = getIndex(period);\n            if (index < 0) {\n                result.add(period);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the index for the item (if any) that corresponds to a time \n     * period.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int getIndex(RegularTimePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");\n        } \n        TimeSeriesDataItem dummy = new TimeSeriesDataItem(\n              period, Integer.MIN_VALUE);\n        return Collections.binarySearch(this.data, dummy);\n    }\n\n    /**\n     * Returns the value at the specified index.\n     *\n     * @param index  index of a value.\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(int index) {\n        return getDataItem(index).getValue();\n    }\n\n    /**\n     * Returns the value for a time period.  If there is no data item with the \n     * specified period, this method will return <code>null</code>.\n     *\n     * @param period  time period (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     */\n    public Number getValue(RegularTimePeriod period) {\n\n        int index = getIndex(period);\n        if (index >= 0) {\n            return getValue(index);\n        }\n        else {\n            return null;\n        }\n\n    }\n\n    /**\n     * Adds a data item to the series and sends a \n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not \n     *              permitted).\n     */\n    public void add(TimeSeriesDataItem item) {\n        add(item, true);\n    }\n        \n    /**\n     * Adds a data item to the series and sends a \n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param item  the (timeperiod, value) pair (<code>null</code> not \n     *              permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(TimeSeriesDataItem item, boolean notify) {\n        if (item == null) {\n            throw new IllegalArgumentException(\"Null 'item' argument.\");\n        }\n        if (!item.getPeriod().getClass().equals(this.timePeriodClass)) {\n            StringBuffer b = new StringBuffer();\n            b.append(\"You are trying to add data where the time period class \");\n            b.append(\"is \");\n            b.append(item.getPeriod().getClass().getName());\n            b.append(\", but the TimeSeries is expecting an instance of \");\n            b.append(this.timePeriodClass.getName());\n            b.append(\".\");\n            throw new SeriesException(b.toString());\n        }\n\n        // make the change (if it's not a duplicate time period)...\n        boolean added = false;\n        int count = getItemCount();\n        if (count == 0) {\n            this.data.add(item);\n            added = true;\n        }\n        else {\n            RegularTimePeriod last = getTimePeriod(getItemCount() - 1);\n            if (item.getPeriod().compareTo(last) > 0) {\n                this.data.add(item);\n                added = true;\n            }\n            else {\n                int index = Collections.binarySearch(this.data, item);\n                if (index < 0) {\n                    this.data.add(-index - 1, item);\n                    added = true;\n                }\n                else {\n                    StringBuffer b = new StringBuffer();\n                    b.append(\"You are attempting to add an observation for \");\n                    b.append(\"the time period \");\n                    b.append(item.getPeriod().toString());\n                    b.append(\" but the series already contains an observation\");\n                    b.append(\" for that time period. Duplicates are not \");\n                    b.append(\"permitted.  Try using the addOrUpdate() method.\");\n                    throw new SeriesException(b.toString());\n                }\n            }\n        }\n        if (added) {\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            if (notify) {\n                fireSeriesChanged();\n            }\n        }\n\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     */\n    public void add(RegularTimePeriod period, double value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends a {@link SeriesChangeEvent}\n     * to all registered listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value.\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, double value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Adds a new data item to the series and sends \n     * a {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void add(RegularTimePeriod period, Number value) {\n        // defer argument checking...\n        add(period, value, true);\n    }\n\n    /**\n     * Adds a new data item to the series and sends \n     * a {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param period  the time period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void add(RegularTimePeriod period, Number value, boolean notify) {\n        // defer argument checking...\n        TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n        add(item, notify);\n    }\n\n    /**\n     * Updates (changes) the value for a time period.  Throws a \n     * {@link SeriesException} if the period does not exist.\n     *\n     * @param period  the period (<code>null</code> not permitted).\n     * @param value  the value (<code>null</code> permitted).\n     */\n    public void update(RegularTimePeriod period, Number value) {\n        TimeSeriesDataItem temp = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, temp);\n        if (index >= 0) {\n            TimeSeriesDataItem pair = (TimeSeriesDataItem) this.data.get(index);\n            pair.setValue(value);\n            fireSeriesChanged();\n        }\n        else {\n            throw new SeriesException(\n                \"TimeSeries.update(TimePeriod, Number):  period does not exist.\"\n            );\n        }\n\n    }\n\n    /**\n     * Updates (changes) the value of a data item.\n     *\n     * @param index  the index of the data item.\n     * @param value  the new value (<code>null</code> permitted).\n     */\n    public void update(int index, Number value) {\n        TimeSeriesDataItem item = getDataItem(index);\n        item.setValue(value);\n        fireSeriesChanged();\n    }\n\n    /**\n     * Adds or updates data from one series to another.  Returns another series\n     * containing the values that were overwritten.\n     *\n     * @param series  the series to merge with this.\n     *\n     * @return A series containing the values that were overwritten.\n     */\n    public TimeSeries addAndOrUpdate(TimeSeries series) {\n        TimeSeries overwritten = new TimeSeries(\"Overwritten values from: \" \n                + getKey(), series.getTimePeriodClass());\n        for (int i = 0; i < series.getItemCount(); i++) {\n            TimeSeriesDataItem item = series.getDataItem(i);\n            TimeSeriesDataItem oldItem = addOrUpdate(item.getPeriod(), \n                    item.getValue());\n            if (oldItem != null) {\n                overwritten.add(oldItem);\n            }\n        }\n        return overwritten;\n    }\n\n    /**\n     * Adds or updates an item in the times series and sends a \n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not \n     *                permitted).\n     * @param value  the new value.\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no \n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, \n                                          double value) {\n        return this.addOrUpdate(period, new Double(value));    \n    }\n    \n    /**\n     * Adds or updates an item in the times series and sends a \n     * {@link org.jfree.data.general.SeriesChangeEvent} to all registered \n     * listeners.\n     *\n     * @param period  the time period to add/update (<code>null</code> not \n     *                permitted).\n     * @param value  the new value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no \n     *         item was overwritten.\n     */\n    public TimeSeriesDataItem addOrUpdate(RegularTimePeriod period, \n                                          Number value) {\n\n        if (period == null) {\n            throw new IllegalArgumentException(\"Null 'period' argument.\");   \n        }\n        TimeSeriesDataItem overwritten = null;\n\n        TimeSeriesDataItem key = new TimeSeriesDataItem(period, value);\n        int index = Collections.binarySearch(this.data, key);\n        if (index >= 0) {\n            TimeSeriesDataItem existing \n                = (TimeSeriesDataItem) this.data.get(index);\n            overwritten = (TimeSeriesDataItem) existing.clone();\n            existing.setValue(value);\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            fireSeriesChanged();\n        }\n        else {\n            this.data.add(-index - 1, new TimeSeriesDataItem(period, value));\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n\n            removeAgedItems(false);  // remove old items if necessary, but\n                                     // don't notify anyone, because that\n                                     // happens next anyway...\n            fireSeriesChanged();\n        }\n        return overwritten;\n\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the youngest to \n     * the oldest record in the series does not exceed maximumItemAge time \n     * periods.  Oldest items will be removed if required.\n     * \n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is \n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(boolean notify) {\n        // check if there are any values earlier than specified by the history \n        // count...\n        if (getItemCount() > 1) {\n            long latest = getTimePeriod(getItemCount() - 1).getSerialIndex();\n            boolean removed = false;\n            while ((latest - getTimePeriod(0).getSerialIndex()) \n                    > this.maximumItemAge) {\n                this.data.remove(0);\n                removed = true;\n            }\n            if (removed && notify) {\n                fireSeriesChanged();\n            }\n        }\n    }\n\n    /**\n     * Age items in the series.  Ensure that the timespan from the supplied \n     * time to the oldest record in the series does not exceed history count.  \n     * oldest items will be removed if required.\n     *\n     * @param latest  the time to be compared against when aging data \n     *     (specified in milliseconds).\n     * @param notify  controls whether or not a {@link SeriesChangeEvent} is \n     *                sent to registered listeners IF any items are removed.\n     */\n    public void removeAgedItems(long latest, boolean notify) {\n        \n        // find the serial index of the period specified by 'latest'\n        long index = Long.MAX_VALUE; \n        try {\n            Method m = RegularTimePeriod.class.getDeclaredMethod(\n                    \"createInstance\", new Class[] {Class.class, Date.class, \n                    TimeZone.class});\n            RegularTimePeriod newest = (RegularTimePeriod) m.invoke(\n                    this.timePeriodClass, new Object[] {this.timePeriodClass,\n                            new Date(latest), TimeZone.getDefault()});\n            index = newest.getSerialIndex();\n        }\n        catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n        catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        catch (InvocationTargetException e) {\n            e.printStackTrace();\n        }\n        \n        // check if there are any values earlier than specified by the history \n        // count...\n        boolean removed = false;\n        while (getItemCount() > 0 && (index \n                - getTimePeriod(0).getSerialIndex()) > this.maximumItemAge) {\n            this.data.remove(0);\n            removed = true;\n        }\n        if (removed && notify) {\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Removes all data items from the series and sends a \n     * {@link SeriesChangeEvent} to all registered listeners.\n     */\n    public void clear() {\n        if (this.data.size() > 0) {\n            this.data.clear();\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes the data item for the given time period and sends a \n     * {@link SeriesChangeEvent} to all registered listeners.  If there is no\n     * item with the specified time period, this method does nothing.\n     *\n     * @param period  the period of the item to delete (<code>null</code> not \n     *                permitted).\n     */\n    public void delete(RegularTimePeriod period) {\n        int index = getIndex(period);\n        if (index >= 0) {\n            this.data.remove(index);\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Deletes data from start until end index (end inclusive).\n     *\n     * @param start  the index of the first period to delete.\n     * @param end  the index of the last period to delete.\n     */\n    public void delete(int start, int end) {\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        for (int i = 0; i <= (end - start); i++) {\n            this.data.remove(start);\n        }\n        fireSeriesChanged();\n    }\n\n    /**\n     * Returns a clone of the time series.\n     * <P>\n     * Notes:\n     * <ul>\n     *   <li>no need to clone the domain and range descriptions, since String \n     *     object is immutable;</li>\n     *   <li>we pass over to the more general method clone(start, end).</li>\n     * </ul>\n     *\n     * @return A clone of the time series.\n     * \n     * @throws CloneNotSupportedException not thrown by this class, but \n     *         subclasses may differ.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end) \n        throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        copy.data = new java.util.ArrayList();\n        if (this.data.size() > 0) {\n            for (int index = start; index <= end; index++) {\n                TimeSeriesDataItem item \n                    = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return copy;\n    }\n\n    /**\n     * Creates a new timeseries by copying a subset of the data in this time \n     * series.\n     *\n     * @param start  the first time period to copy.\n     * @param end  the last time period to copy.\n     *\n     * @return A time series containing a copy of this time series from start \n     *         until end.\n     * \n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end \n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(\n            getDomainDescription(), s.getDomainDescription()\n        )) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(\n            getRangeDescription(), s.getRangeDescription()\n        )) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode() \n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null \n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n}\n", "review": {"response": "<think>\nOkay, let me take a look at this Java code. The user wants me to review it for bugs and return a JSON list of the bugs. The code provided is for the TimeSeries class in JFreeChart. \n\nFirst, I'll start by skimming through the code to get an overview. The class extends Series and implements Cloneable and Serializable. There are several fields: domain, range, timePeriodClass, data, maximumItemCount, and maximumItemAge. The constructors and methods are there, but the code seems to be cut off at the end. The last line of the code snippet is \" * @param name  the series name (<code>null</code> not permitted).\", which is part of the constructor's Javadoc. The actual constructor implementation is missing, as well as other methods.\n\nOne immediate issue I notice is that the code is incomplete. The constructor definition starts with \"public TimeSeries(Comparable name) {\" but the corresponding closing brace is missing. Similarly, other parts of the code are cut off. This is a problem because without the full code, it's hard to identify all potential bugs. However, maybe there are other issues visible in the provided portion.\n\nLooking at the fields, the 'data' field is declared as a List but not initialized. In Java, if you don't initialize a List, it will be null, leading to a NullPointerException when you try to add elements to it. The code might have methods that manipulate 'data' without checking if it's initialized. For example, in the constructor, if they add items to 'data' without initializing it, that's a bug. However, the constructor code isn't visible here, so I can't confirm.\n\nAnother thing is the use of raw types. The 'data' field is declared as List, not List<DataItem> or similar. Using raw types can lead to type safety issues and might cause problems if the code uses generics incorrectly. This isn't a bug per se but a code smell that could lead to issues.\n\nLooking at the 'timePeriodClass' field, it's of type Class. The constructor that's shown uses Day.class, which is correct. However, if there are other constructors or methods that allow setting this field without proper validation, that could lead to issues. For example, if someone passes a class that doesn't implement RegularTimePeriod, it might cause errors later.\n\nThe 'maximumItemCount' is an int, and 'maximumItemAge' is a long. The code might have methods that manipulate these values. For instance, in the 'setMaximumItemCount' method, if there's no validation for negative values, that's a bug. But again, without seeing the full code, it's hard to tell. The user mentioned a bug fix in 15-Jun-2004 for NullPointerException in equals(), so maybe there are other null checks missing.\n\nThe 'data' list is protected, which means subclasses can access it directly. If the class is designed to have subclasses, allowing direct modification of the list might bypass the notification mechanisms (like SeriesChangeEvent). This could be a bug if the data modifications don't trigger the appropriate events.\n\nLooking at the constructor, the call to super(name) is missing. The TimeSeries constructor calls this(name, ...), but the super constructor (Series) isn't explicitly called. Wait, the constructor here is public TimeSeries(Comparable name) { this(...); }, which should chain to another constructor. However, the other constructor (TimeSeries(Comparable, String, String, Class)) must call the super constructor. If that's not done properly, it could lead to issues. But again, the code is cut off, so I can't check.\n\nAnother possible issue is the use of reflection in the code. The code imports Method and has a Method variable. If there's a method that uses reflection without proper exception handling, that could be a problem. For example, if a Method.invoke() call doesn't handle InvocationTargetException or other exceptions, it might cause runtime errors.\n\nThe 'equals' method was fixed in 15-Jun-2004 for NullPointerException. Maybe there are other comparisons without null checks. For example, comparing domain or range without checking if they are null could lead to NPEs.\n\nAlso, the 'clone()' method was fixed in 21-Nov-2007. If the clone method doesn't properly clone all fields, especially the data list, it might result in shallow copies, leading to unexpected behavior when the original or cloned series is modified.\n\nIn the 'ageHistoryCountItems' method (now 'removeAgedItems'), there might be issues with how the age is calculated. For example, if the code doesn't correctly handle the time periods or if the maximumItemAge is not properly considered, old items might not be removed correctly.\n\nAnother thing to check is the 'add' methods. The code has methods that add data items. If these methods don't check for null parameters or don't validate the time periods, it could lead to invalid data being added. For example, adding a TimePeriod that's not of the correct class (specified by timePeriodClass) might cause inconsistencies.\n\nAlso, the 'data' list is a List, but the class might not enforce the order or uniqueness of items. If the time periods are supposed to be in order and unique, but the code allows duplicates or incorrect ordering, that's a logical error.\n\nLooking at the imports, they have java.util.List but not java.util.ArrayList. The data list is probably initialized as an ArrayList somewhere, but if that's not done, it's a problem. However, since the code is cut off, I can't see where it's initialized.\n\nIn the 'clear()' method added in 13-Apr-2004, if it doesn't properly clear the data list or notify listeners, that's a bug. Similarly, methods like add or remove should notify SeriesChangeListener instances, so if they don't, the UI might not update correctly.\n\nThe 'getItemCount()' method (mentioned in changes) should return the size of the data list. If it's not implemented correctly, it could return incorrect values.\n\nAnother possible issue is the handling of time zones. The code has a TimeZone import. If the TimeSeries uses a specific time zone for its periods and doesn't properly handle it when adding or comparing periods, that could lead to incorrect data.\n\nIn the 'createCopy()' methods, there was a bug fix in 24-May-2006 for error handling. If the copy isn't properly deep-copied, especially the data items, modifying the copy could affect the original.\n\nThe 'removeAgedItems()' method had a bug fix in 01-Sep-2006 (bug 1550045). Without seeing the code, it's hard to know, but perhaps the original code didn't correctly iterate through the list while removing items, leading to ConcurrentModificationException or incorrect removals.\n\nThe 'getDataItem(RegularTimePeriod)' method was simplified in 22-Mar-2007. If the previous implementation had issues with searching for the period, the simplification might have introduced bugs or fixed them.\n\nIn terms of code structure, the class is quite large and might have a lot of methods. If any of the methods are not thread-safe and the class is used in a multi-threaded environment without proper synchronization, that's a potential issue.\n\nNow, considering all the possible issues and the code provided, here are the bugs I can identify:\n\n1. **Incomplete Code**: The code is cut off, making it impossible to review all parts. This is a problem for a complete review.\n\n2. **Uninitialized List**: The 'data' field is declared as a List but not initialized. If the constructor doesn't initialize it, this will cause a NullPointerException when methods try to add or access elements.\n\n3. **Raw Type Usage**: The 'data' list uses a raw type, which can lead to type safety issues and potential ClassCastExceptions when retrieving elements.\n\n4. **Missing Super Constructor Call**: In the TimeSeries(Comparable name) constructor, it calls this(...), but the other constructor must properly call the super constructor (Series). If not done correctly, it could lead to the object not being initialized properly.\n\n5. **Potential NPE in equals()**: The equals method was fixed for NPE, but if other methods compare fields without null checks, they could throw NPEs.\n\n6. **Reflection Without Exception Handling**: If the code uses Method.invoke() without handling checked exceptions, it could lead to runtime errors.\n\n7. **Incorrect Clone Implementation**: If the clone() method doesn't properly clone the data list, it could result in shared references between the original and cloned series.\n\n8. **Missing Validation in Setters**: Methods like setMaximumItemCount or setMaximumItemAge might not validate input, allowing invalid values (e.g., negative numbers).\n\n9. **Incorrect List Manipulation in removeAgedItems**: If the method removes items while iterating without using an iterator's remove method, it could cause ConcurrentModificationException.\n\n10. **Inadequate Null Checks in Add Methods**: The add methods might not check for null parameters, leading to potential issues when adding null values or periods.\n\n11. **Incorrect Time Period Class Handling**: If the code allows adding periods that don't match the timePeriodClass, it could lead to inconsistent data.\n\n12. **Lack of Synchronization in Multi-threaded Context**: If the class is used in a multi-threaded environment without proper synchronization, it could lead to data corruption.\n\n13. **Improper Event Notification**: If adding or removing items doesn't notify SeriesChangeListener, the UI might not update correctly.\n\n14. **Potential Memory Leak with Large Data Sets**: If the maximumItemCount isn't enforced properly, the data list could grow indefinitely, consuming too much memory.\n\n15. **Incorrect Calculation of Maximum Item Age**: If the age calculation doesn't account for the correct time periods, old items might not be removed as intended.\n\n16. **Incorrect Use of hashCode()**: The hashCode() method was implemented for performance, but if it's not consistent with equals(), it could cause issues in collections like HashMap or HashSet.\n\n17. **Missing Override Annotations**: If methods like equals(), hashCode(), or clone() don't have @Override annotations, it could lead to silent failures if the method signatures don't match the super class.\n\n18. **Inefficient Data Structure for TimeSeries**: Using a List for data items might not be efficient for operations like searching for a specific time period. A more efficient structure like a TreeMap might be better, but that's more of a performance consideration than a bug.\n\n19. **Potential for ConcurrentModificationException in Iterators**: If the data list is modified while being iterated over without proper synchronization, it could throw ConcurrentModificationException.\n\n20. **Incorrect Handling of Time Zones**: If the TimeSeries uses a specific time zone and doesn't propagate it correctly to the TimePeriod instances, it could lead to incorrect time calculations.\n\nHowever, considering the code is from a well-maintained library (JFreeChart), many of these might have been addressed in the full code. But based on the provided snippet and known changes, the most pressing issues are the incomplete code, uninitialized list, raw types, and potential NPEs. Since the user provided only a portion, I'll list the bugs that can be inferred from the given code.\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"line\": \"protected List data;\",\n      \"description\": \"The 'data' list is declared as a raw type, which can lead to type safety issues and potential ClassCastException when retrieving elements. It should be parameterized with the specific data item type (e.g., List<TimeSeriesDataItem>).\"\n    },\n    {\n      \"line\": \"public TimeSeries(Comparable name) { this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION, Day.class); }\",\n      \"description\": \"The constructor does not initialize the 'data' list. If the data list is not initialized in another constructor, it will cause a NullPointerException when attempting to add or access elements.\"\n    },\n    {\n      \"line\": \"protected List data;\",\n      \"description\": \"The 'data' field is declared as a protected List, allowing subclasses to modify it directly. This could bypass encapsulation and lead to inconsistent states if modifications don't trigger SeriesChangeEvent notifications.\"\n    },\n    {\n      \"line\": \"private long maximumItemAge;\",\n      \"description\": \"The 'maximumItemAge' field is a long but there is no validation in the setter method to ensure it is non-negative. Allowing negative values could lead to incorrect behavior when removing aged items.\"\n    },\n    {\n      \"line\": \"public TimeSeries(Comparable name) { ... }\",\n      \"description\": \"The constructor does not explicitly call the super constructor (Series). While it chains to another constructor, if that constructor also does not call super(), it could lead to improper initialization of the Series class.\"\n    },\n    {\n      \"line\": \"protected Class timePeriodClass;\",\n      \"description\": \"The 'timePeriodClass' field is not validated in the constructor. If a subclass or external code sets it to a class that does not implement RegularTimePeriod, it could cause ClassCastException when adding data items.\"\n    },\n    {\n      \"line\": \"public boolean equals(Object obj) { ... }\",\n      \"description\": \"The 'equals()' method was previously fixed for NullPointerException, but if it does not handle null checks for all fields (e.g., domain, range), it could still throw a NullPointerException in other scenarios.\"\n    },\n    {\n      \"line\": \"public Object clone() { ... }\",\n      \"description\": \"The 'clone()' method, if not properly implemented, could return a shallow copy of the 'data' list. This would allow the cloned series to share data with the original, leading to unintended side effects when either is modified.\"\n    },\n    {\n      \"line\": \"public void add(RegularTimePeriod period, double value) { ... }\",\n      \"description\": \"The 'add' method (not fully visible in the snippet) may not validate that 'period' is of the correct type (as specified by 'timePeriodClass'), leading to inconsistent data if incompatible periods are added.\"\n    },\n    {\n      \"line\": \"public void removeAgedItems() { ... }\",\n      \"description\": \"The 'removeAgedItems()' method (referred to in the changelog) may iterate over the 'data' list and remove items without using an iterator's remove method, potentially causing ConcurrentModificationException.\"\n    }\n  ]\n}\n```"}}