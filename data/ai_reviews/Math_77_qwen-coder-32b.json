{"sample_id": "Math_77", "model": "qwen-coder-32b", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math.linear;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\n\n/**\n * This class implements the {@link RealVector} interface with a {@link OpenIntToDoubleHashMap} backing store.\n * @version $Revision$ $Date$\n * @since 2.0\n*/\npublic class OpenMapRealVector extends AbstractRealVector implements SparseRealVector, Serializable {\n\n    /** Default Tolerance for having a value considered zero. */\n    public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\n\n    /** Serializable version identifier. */\n    private static final long serialVersionUID = 8772222695580707260L;\n\n    /** Entries of the vector. */\n    private final OpenIntToDoubleHashMap entries;\n\n    /** Dimension of the vector. */\n    private final int virtualSize;\n\n    /** Tolerance for having a value considered zero. */\n    private double epsilon;\n\n    /**\n     * Build a 0-length vector.\n     * <p>Zero-length vectors may be used to initialized construction of vectors\n     * by data gathering. We start with zero-length and use either the {@link\n     * #OpenMapRealVector(OpenMapRealVector, int)} constructor\n     * or one of the <code>append</code> method ({@link #append(double)}, {@link\n     * #append(double[])}, {@link #append(RealVector)}) to gather data\n     * into this vector.</p>\n     */\n    public OpenMapRealVector() {\n        this(0, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Construct a (dimension)-length vector of zeros.\n     * @param dimension size of the vector\n     */\n    public OpenMapRealVector(int dimension) {\n        this(dimension, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Construct a (dimension)-length vector of zeros, specifying zero tolerance.\n     * @param dimension Size of the vector\n     * @param epsilon The tolerance for having a value considered zero\n     */\n    public OpenMapRealVector(int dimension, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * Build a resized vector, for use with append.\n     * @param v The original vector\n     * @param resize The amount to resize it\n     */\n    protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n        virtualSize = v.getDimension() + resize;\n        entries = new OpenIntToDoubleHashMap(v.entries);\n        epsilon = v.epsilon;\n    }\n\n    /**\n     * Build a vector with known the sparseness (for advanced use only).\n     * @param dimension The size of the vector\n     * @param expectedSize The expected number of non-zero entries\n     */\n    public OpenMapRealVector(int dimension, int expectedSize) {\n        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Build a vector with known the sparseness and zero tolerance setting (for advanced use only).\n     * @param dimension The size of the vector\n     * @param expectedSize The expected number of non-zero entries\n     * @param epsilon The tolerance for having a value considered zero\n     */\n    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * Create from a double array.\n     * Only non-zero entries will be stored\n     * @param values The set of values to create from\n     */\n    public OpenMapRealVector(double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Create from a double array, specifying zero tolerance.\n     * Only non-zero entries will be stored\n     * @param values The set of values to create from\n     * @param epsilon The tolerance for having a value considered zero\n     */\n    public OpenMapRealVector(double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key];\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Create from a Double array.\n     * Only non-zero entries will be stored\n     * @param values The set of values to create from\n     */\n    public OpenMapRealVector(Double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Create from a Double array.\n     * Only non-zero entries will be stored\n     * @param values The set of values to create from\n     * @param epsilon The tolerance for having a value considered zero\n     */\n    public OpenMapRealVector(Double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key].doubleValue();\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Copy constructor.\n     * @param v The instance to copy from\n     */\n    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }\n\n    /**\n     * Generic copy constructor.\n     * @param v The instance to copy from\n     */\n    public OpenMapRealVector(RealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(0.0);\n        epsilon = DEFAULT_ZERO_TOLERANCE;\n        for (int key = 0; key < virtualSize; key++) {\n            double value = v.getEntry(key);\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Get the entries of this instance.\n     * @return entries of this instance\n     */\n    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }\n\n    /**\n     * Determine if this value is within epsilon of zero.\n     * @param value The value to test\n     * @return <code>true</code> if this value is within epsilon to zero, <code>false</code> otherwise\n     */\n    protected boolean isDefaultValue(double value) {\n        return Math.abs(value) < epsilon;\n    }\n\n    /** {@inheritDoc} */\n    public RealVector add(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return add((OpenMapRealVector) v);\n        } else {\n            return super.add(v);\n        }\n    }\n\n    /**\n     * Optimized method to add two OpenMapRealVectors.  Copies the larger vector, iterates over the smaller.\n     * @param v Vector to add with\n     * @return The sum of <code>this</code> with <code>v</code>\n     * @throws IllegalArgumentException If the dimensions don't match\n     */\n    public OpenMapRealVector add(OpenMapRealVector v) throws IllegalArgumentException{\n        checkVectorDimensions(v.getDimension());\n        boolean copyThis = entries.size() > v.entries.size();\n        OpenMapRealVector res = copyThis ? this.copy() : v.copy();\n        Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();\n        OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (randomAccess.containsKey(key)) {\n                res.setEntry(key, randomAccess.get(key) + iter.value());\n            } else {\n                res.setEntry(key, iter.value());\n            }\n        }\n        return res;\n    }\n\n    /**\n     * Optimized method to append a OpenMapRealVector.\n     * @param v vector to append\n     * @return The result of appending <code>v</code> to self\n     */\n    public OpenMapRealVector append(OpenMapRealVector v) {\n        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n        Iterator iter = v.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key() + virtualSize, iter.value());\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector append(RealVector v) {\n        if (v instanceof OpenMapRealVector) {\n            return append((OpenMapRealVector) v);\n        }\n        return append(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector append(double d) {\n        OpenMapRealVector res = new OpenMapRealVector(this, 1);\n        res.setEntry(virtualSize, d);\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector append(double[] a) {\n        OpenMapRealVector res = new OpenMapRealVector(this, a.length);\n        for (int i = 0; i < a.length; i++) {\n            res.setEntry(i + virtualSize, a[i]);\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector copy() {\n        return new OpenMapRealVector(this);\n    }\n\n    /**\n     * Optimized method to compute the dot product with an OpenMapRealVector.\n     * Iterates over the smaller of the two.\n     * @param v The vector to compute the dot product with\n     * @return The dot product of <code>this</code> and <code>v</code>\n     * @throws IllegalArgumentException If the dimensions don't match\n     */\n    public double dotProduct(OpenMapRealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        boolean thisIsSmaller  = entries.size() < v.entries.size();\n        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;\n        double d = 0;\n        while(iter.hasNext()) {\n            iter.advance();\n            d += iter.value() * larger.get(iter.key());\n        }\n        return d;\n    }\n\n    /** {@inheritDoc} */\n    public double dotProduct(RealVector v) throws IllegalArgumentException {\n        if(v instanceof OpenMapRealVector) {\n            return dotProduct((OpenMapRealVector)v);\n        } else {\n            return super.dotProduct(v);\n        }\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector ebeDivide(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector getSubVector(int index, int n) throws MatrixIndexException {\n        checkIndex(index);\n        checkIndex(index + n - 1);\n        OpenMapRealVector res = new OpenMapRealVector(n);\n        int end = index + n;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (key >= index && key < end) {\n                res.setEntry(key - index, iter.value());\n            }\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public double[] getData() {\n        double[] res = new double[virtualSize];\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res[iter.key()] = iter.value();\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public int getDimension() {\n        return virtualSize;\n    }\n\n    /**\n     * Optimized method to compute distance.\n     * @param v The vector to compute distance to\n     * @return The distance from <code>this</code> and <code>v</code>\n     * @throws IllegalArgumentException If the dimensions don't match\n     */\n    public double getDistance(OpenMapRealVector v) throws IllegalArgumentException {\n        Iterator iter = entries.iterator();\n        double res = 0;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            double delta;\n            delta = iter.value() - v.getEntry(key);\n            res += delta * delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                final double value = iter.value();\n                res += value * value;\n            }\n        }\n        return Math.sqrt(res);\n    }\n\n    /** {@inheritDoc} */\n    public double getDistance(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getDistance((OpenMapRealVector) v);\n        }\n        return getDistance(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public double getDistance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double res = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = entries.get(i) - v[i];\n            res += delta * delta;\n        }\n        return Math.sqrt(res);\n    }\n\n    /** {@inheritDoc} */\n    public double getEntry(int index) throws MatrixIndexException {\n        checkIndex(index);\n        return entries.get(index);\n    }\n\n    /**\n     * Distance between two vectors.\n     * <p>This method computes the distance consistent with\n     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n     * elements differences.</p>\n     * @param v vector to which distance is requested\n     * @return distance between two vectors.\n     */\n    public double getL1Distance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n            max += delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                double delta = Math.abs(iter.value());\n                max +=  Math.abs(delta);\n            }\n        }\n        return max;\n    }\n\n    /** {@inheritDoc} */\n    public double getL1Distance(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getL1Distance((OpenMapRealVector) v);\n        }\n        return getL1Distance(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public double getL1Distance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = Math.abs(getEntry(i) - v[i]);\n            max += delta;\n        }\n        return max;\n    }\n\n    public double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }\n    /**\n     * Optimized method to compute LInfDistance.\n     * @param v The vector to compute from\n     * @return the LInfDistance\n     */\n    private double getLInfDistance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                if (iter.value() > max) {\n                    max = iter.value();\n                }\n            }\n        }\n        return max;\n    }\n\n    /** {@inheritDoc} */\n    public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getLInfDistance((OpenMapRealVector) v);\n        }\n        return getLInfDistance(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public double getLInfDistance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = Math.abs(getEntry(i) - v[i]);\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        return max;\n    }\n\n    /** {@inheritDoc} */\n    public boolean isInfinite() {\n        boolean infiniteFound = false;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            final double value = iter.value();\n            if (Double.isNaN(value)) {\n                return false;\n            }\n            if (Double.isInfinite(value)) {\n                infiniteFound = true;\n            }\n        }\n        return infiniteFound;\n    }\n\n    /** {@inheritDoc} */\n    public boolean isNaN() {\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            if (Double.isNaN(iter.value())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector mapAdd(double d) {\n        return copy().mapAddToSelf(d);\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector mapAddToSelf(double d) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, getEntry(i) + d);\n        }\n        return this;\n    }\n\n     /** {@inheritDoc} */\n    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        RealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int row = iter.key();\n            double value = iter.value();\n            for (int col = 0; col < virtualSize; col++) {\n                res.setEntry(row, col, value * v[col]);\n            }\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public RealVector projection(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector projection(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        return (OpenMapRealVector) projection(new OpenMapRealVector(v));\n    }\n\n    /** {@inheritDoc} */\n    public void setEntry(int index, double value) throws MatrixIndexException {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n\n    /** {@inheritDoc} */\n    public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n        checkIndex(index);\n        checkIndex(index + v.getDimension() - 1);\n        setSubVector(index, v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public void setSubVector(int index, double[] v) throws MatrixIndexException {\n        checkIndex(index);\n        checkIndex(index + v.length - 1);\n        for (int i = 0; i < v.length; i++) {\n            setEntry(i + index, v[i]);\n        }\n    }\n\n    /** {@inheritDoc} */\n    public void set(double value) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, value);\n        }\n    }\n\n    /**\n     * Optimized method to subtract OpenMapRealVectors.\n     * @param v The vector to subtract from <code>this</code>\n     * @return The difference of <code>this</code> and <code>v</code>\n     * @throws IllegalArgumentException If the dimensions don't match\n     */\n    public OpenMapRealVector subtract(OpenMapRealVector v) throws IllegalArgumentException{\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = copy();\n        Iterator iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (entries.containsKey(key)) {\n                res.setEntry(key, entries.get(key) - iter.value());\n            } else {\n                res.setEntry(key, -iter.value());\n            }\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return subtract((OpenMapRealVector) v);\n        }\n        return subtract(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        for (int i = 0; i < v.length; i++) {\n            if (entries.containsKey(i)) {\n                res.setEntry(i, entries.get(i) - v[i]);\n            } else {\n                res.setEntry(i, -v[i]);\n            }\n        }\n        return res;\n    }\n\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector unitVector() {\n        OpenMapRealVector res = copy();\n        res.unitize();\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public void unitize() {\n        double norm = getNorm();\n        if (isDefaultValue(norm)) {\n            throw  MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            entries.put(iter.key(), iter.value() / norm);\n        }\n\n    }\n\n\n    /** {@inheritDoc} */\n    public double[] toArray() {\n        return getData();\n    }\n\n    /** {@inheritDoc}\n     * <p> Implementation Note: This works on exact values, and as a result\n     * it is possible for {@code a.subtract(b)} to be the zero vector, while\n     * {@code a.hashCode() != b.hashCode()}.</p>\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(epsilon);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + virtualSize;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            temp = Double.doubleToLongBits(iter.value());\n            result = prime * result + (int) (temp ^ (temp >>32));\n        }\n        return result;\n    }\n\n    /**\n     * <p> Implementation Note: This performs an exact comparison, and as a result\n     * it is possible for {@code a.subtract(b}} to be the zero vector, while\n     * {@code  a.equals(b) == false}.</p>\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof OpenMapRealVector)) {\n            return false;\n        }\n        OpenMapRealVector other = (OpenMapRealVector) obj;\n        if (virtualSize != other.virtualSize) {\n            return false;\n        }\n        if (Double.doubleToLongBits(epsilon) !=\n            Double.doubleToLongBits(other.epsilon)) {\n            return false;\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = other.getEntry(iter.key());\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {\n                return false;\n            }\n        }\n        iter = other.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = iter.value();\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     *\n     * @return the percentage of none zero elements as a decimal percent.\n     */\n    public double getSparcity() {\n        return (double)entries.size()/(double)getDimension();\n    }\n\n    /** {@inheritDoc} */\n    public java.util.Iterator<Entry> sparseIterator() {\n        return new OpenMapSparseIterator();\n    }\n\n    /**\n     *  Implementation of <code>Entry</code> optimized for OpenMap.\n     * <p>This implementation does not allow arbitrary calls to <code>setIndex</code>\n     * since the order that entries are returned is undefined.\n     */\n    protected class OpenMapEntry extends Entry {\n\n        /** Iterator pointing to the entry. */\n        private final Iterator iter;\n\n        /** Build an entry from an iterator point to an element.\n         * @param iter iterator pointing to the entry\n         */\n        protected OpenMapEntry(Iterator iter) {\n            this.iter = iter;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public double getValue() {\n            return iter.value();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void setValue(double value) {\n            entries.put(iter.key(), value);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int getIndex() {\n            return iter.key();\n        }\n\n    }\n\n    /**\n     *  Iterator class to do iteration over just the non-zero elements.\n     *  <p>This implementation is fail-fast, so cannot be used to modify any zero element.\n     *\n     */\n    protected class OpenMapSparseIterator implements java.util.Iterator<Entry> {\n\n        /** Underlying iterator. */\n        private final Iterator iter;\n\n        /** Current entry. */\n        private final Entry current;\n\n        /** Simple constructor. */\n        protected OpenMapSparseIterator() {\n            iter = entries.iterator();\n            current = new OpenMapEntry(iter);\n        }\n\n        /** {@inheritDoc} */\n        public boolean hasNext() {\n            return iter.hasNext();\n        }\n\n        /** {@inheritDoc} */\n        public Entry next() {\n            iter.advance();\n            return current;\n        }\n\n        /** {@inheritDoc} */\n        public void remove() {\n            throw new UnsupportedOperationException(\"Not supported\");\n       }\n\n    }\n}\n", "review": {"response": "<think>\nOkay, let me take a look at this Java code. The user wants me to review it for bugs and return a JSON with a list of bugs. Alright, first, I'll read through the code carefully.\n\nStarting with the class definition: OpenMapRealVector extends AbstractRealVector and implements SparseRealVector and Serializable. The code uses an OpenIntToDoubleHashMap for storage. \n\nLooking at the constructors. The first constructor is public OpenMapRealVector(), which calls this(0, DEFAULT_ZERO_TOLERANCE). That seems okay. Then there's a constructor that takes an int dimension, which also calls this(dimension, DEFAULT...). The next one is protected OpenMapRealVector(OpenMapRealVector v, int resize). Here, they set virtualSize to v.getDimension() + resize. But wait, what if resize is negative? That could lead to a negative dimension, which might be a problem. But maybe the method is intended to be used only with positive resize, like in append operations. But the code doesn't check for that. So that's a possible bug if someone passes a negative resize. Should there be a check here?\n\nThen there's the constructor with expectedSize parameters. The OpenIntToDoubleHashMap is initialized with expectedSize, which is okay. \n\nLooking at the method where they create from a double array. In the constructor public OpenMapRealVector(double[] values), they set virtualSize to values.length. Then loop through each element. The check isDefaultValue(value) is used to decide whether to put it in the map. But what's the default value? The entries are initialized with 0.0 as the default. So isDefaultValue is comparing the value against epsilon? Let me check the isDefaultValue method. Wait, the code here doesn't show that method. But in the code provided, the user hasn't included all the methods. However, based on the code given, I can infer that isDefaultValue probably checks if the absolute value is less than or equal to epsilon. So if a value is very close to zero (within epsilon), it's considered default and not stored. That makes sense for a sparse vector.\n\nNow, looking at the Double[] constructor. Here, they do values[key].doubleValue(). But what if values[key] is null? That would cause a NullPointerException. Oh right! Because the array is of type Double (boxed), so individual elements could be null. So in the loop, if any element in the Double array is null, calling doubleValue() would throw an NPE. That's a definite bug. The code should check for null and treat it as zero, perhaps. For example, if (values[key] == null) { value = 0.0; } else { value = ... }.\n\nAnother thing: the OpenIntToDoubleHashMap is initialized with a default value of 0.0. So when getting a value for an index not present, it returns 0.0. But when putting values, they only add entries that are not considered default (i.e., non-zero within epsilon). That's correct for a sparse vector.\n\nLooking at the protected constructor that takes resize. The problem here is that if resize is negative, virtualSize could be set to a value less than v.getDimension(). But if this constructor is used for appending, perhaps resize is supposed to be positive. However, the code doesn't validate the resize parameter. So if someone passes a negative resize, it might create a vector with a smaller dimension than the original. That could lead to inconsistencies if the new vector has a smaller size but still has entries beyond that size. For example, if the original vector had entries at indices beyond the new virtualSize. That could be a problem. So the code should probably check that the resize doesn't lead to a negative size and maybe also check that existing entries don't exceed the new virtualSize. But I'm not sure if that's the case. It depends on how the constructor is intended to be used. Since it's a protected constructor, maybe it's part of the internal API and the append method ensures that resize is positive. However, without validation, there's a potential bug if used incorrectly.\n\nAnother possible issue: in the constructor that takes a double array, if the array is empty (length 0), virtualSize is set to 0. But the code for the zero-length vector is handled by the first constructor. But what if someone passes a zero-length array here? It should be okay. But maybe not a problem.\n\nWhat about the case where the virtualSize is set, but entries can have indices beyond that? For example, if someone creates a vector with dimension 3, but then somehow adds an entry at index 5. That would be a problem because the virtualSize is 3. How is that handled? The code may not check for that. For example, if a user uses the put method (assuming it's present in the class) to add an entry beyond virtualSize. But since the code provided doesn't show all methods, perhaps the setEntry or other methods check the index against virtualSize. If not, that's a bug. But since the code is part of a larger library (Apache Commons Math), perhaps other methods handle that. However, in the current code, the constructors that take arrays don't check if the array length is correct. For example, if someone uses the constructor with a double array of length 5, but then the virtualSize is set to 5. That's correct. But if someone later resizes the vector, but the entries may have indices beyond the virtualSize. But again, that's up to other methods to handle.\n\nAnother possible bug: in the constructor that takes a Double array, the code sets virtualSize to values.length. Suppose the array has length N, but some elements are null. When creating the entries, those nulls are treated as zero. However, if the virtualSize is N, but the actual entries in the vector may have zeros (due to nulls) which are not stored. So for example, if the array is [null, 1.0], then the entries will have index 1 with value 1.0, and the virtualSize is 2. So when someone accesses index 0, it returns 0.0 (from the default in the map). But the actual array length was 2, so that's correct. So no bug here, but the code should handle nulls properly by treating them as zero.\n\nSo the main bugs I can spot are:\n\n1. In the constructor that takes a Double array, there's a potential NullPointerException if any element is null. The code should handle nulls by treating them as 0.0.\n\n2. The protected constructor that resizes the vector doesn't validate the resize parameter. If resize is negative, it can lead to a virtualSize smaller than the original, which might cause inconsistencies if existing entries are beyond the new virtualSize.\n\nAre there any other issues?\n\nLooking at the method isDefaultValue. Wait, in the code provided, the method isn't shown. But based on the code, it's probably a helper method that checks if a value is close to zero based on epsilon. For example, Math.abs(value) <= epsilon. If that's the case, then in the constructors that add entries, they check if the value is not default (i.e., non-zero enough) and add it to the map. That's correct.\n\nAnother thing: in the constructor that takes a double array, if the array is null, it would throw a NullPointerException. But the code doesn't check for that. Similarly for the Double array constructor. But the problem is that the code as written doesn't check for null inputs. So if someone passes a null array to the constructor, it would throw a NPE when trying to get the length. So perhaps the code should check for null arrays and throw an IllegalArgumentException.\n\nBut in the code provided, the constructors don't have such checks. For example, in public OpenMapRealVector(double[] values), the code uses values.length. If values is null, that would throw an NPE. So that's another potential bug. Similarly for the Double[] constructor.\n\nSo adding those as bugs:\n\n3. The constructors that take double[] or Double[] arrays don't check if the input array is null, leading to a NullPointerException.\n\nSo the three bugs I found are:\n\n1. NullPointerException in Double array constructor when elements are null.\n\n2. No validation on resize parameter in the protected constructor, allowing negative sizes.\n\n3. No null check on the input arrays in the constructors that take arrays.\n\nAre there any others?\n\nLooking at the code again. The OpenIntToDoubleHashMap's initial capacity is set in some constructors. For example, in the constructor with expectedSize, they create a new OpenIntToDoubleHashMap(expectedSize, 0.0). But the OpenIntToDoubleHashMap's constructor may have different parameters. Wait, the OpenIntToDoubleHashMap has a constructor that takes initial capacity and default value. So that's correct.\n\nAnother thing: the virtualSize is final, so once set in the constructor, it can't be changed. But in the protected constructor that resizes, it's allowed. So that's okay.\n\nAnother possible issue: in the case where the virtualSize is zero. For example, the first constructor creates a zero-length vector. But when using that, any access to entries beyond zero would be invalid. But the code should handle that, perhaps through other methods.\n\nSo, to summarize the bugs:\n\n1. In the constructor that takes a Double array, if any element is null, it will throw a NullPointerException when calling doubleValue(). The code should handle null elements by treating them as zero.\n\n2. The protected constructor that resizes the vector does not validate the resize parameter. If the resize leads to a negative virtualSize, it could cause inconsistencies. The code should check that the resize doesn't make virtualSize negative.\n\n3. The constructors that take double[] or Double[] arrays don't check if the input array is null, leading to a NullPointerException when accessing values.length.\n\nAre there any other issues? Let me think again.\n\nIn the constructor that takes a double array and epsilon, the code loops through the array and adds entries for non-default values. But if the array is empty (length 0), virtualSize is set to 0, which is correct. No problem there.\n\nAnother thing: in the case of the Double array constructor, if the array has elements that are NaN or infinite, but the code doesn't check for that. However, that's probably an issue with the input data rather than a bug in the code. Unless the class is supposed to handle only finite values, but the code doesn't check. However, the problem statement is about bugs in the code, so unless there's a specific requirement to validate inputs, that's not a bug. So maybe not a problem here.\n\nSo the three bugs I identified are the main ones. Let me structure them as JSON.\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"line_number\": 115,\n      \"description\": \"Potential NullPointerException in Double array constructor when elements are null. The code does not handle null elements in the Double array, leading to a NullPointerException when calling doubleValue() on null elements.\"\n    },\n    {\n      \"line_number\": 95,\n      \"description\": \"Missing validation for resize parameter in protected constructor. The constructor does not check if the resize value is negative, which could result in a negative virtualSize and potential inconsistencies if existing entries exceed the new virtualSize.\"\n    },\n    {\n      \"line_number\": 78,\n      \"description\": \"Missing null check for input array in double[] constructor. The code does not validate that the input array is not null, leading to a NullPointerException when accessing values.length if the input is null.\"\n    },\n    {\n      \"line_number\": 109,\n      \"description\": \"Missing null check for input array in Double[] constructor. The code does not validate that the input array is not null, leading to a NullPointerException when accessing values.length if the input is null.\"\n    }\n  ]\n}\n```"}}