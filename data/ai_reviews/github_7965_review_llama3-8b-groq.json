{
  "source_item_id": 7965,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:46:55.169421",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2009 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.reflect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static java.util.Arrays.asList;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * An object of this class encapsulates type mappings from type variables. Mappings are established\n * with {@link #where} and types are resolved using {@link #resolveType}.\n *\n * <p>Note that usually type mappings are already implied by the static type hierarchy (for example,\n * the {@code E} type variable declared by class {@code List} naturally maps to {@code String} in\n * the context of {@code class MyStringList implements List<String>}). In such case, prefer to use\n * {@link TypeToken#resolveType} since it's simpler and more type safe. This class should only be\n * used when the type mapping isn't implied by the static type hierarchy, but provided through other\n * means such as an annotation or external configuration file.\n *\n * @author Ben Yu\n * @since 15.0\n */\npublic final class TypeResolver {\n\n  private final TypeTable typeTable;\n\n  public TypeResolver() {\n    this.typeTable = new TypeTable();\n  }\n\n  private TypeResolver(TypeTable typeTable) {\n    this.typeTable = typeTable;\n  }\n\n  /**\n   * Returns a resolver that resolves types \"covariantly\".\n   *\n   * <p>For example, when resolving {@code List<T>} in the context of {@code ArrayList<?>}, {@code\n   * <T>} is covariantly resolved to {@code <?>} such that return type of {@code List::get} is\n   * {@code <?>}.\n   */\n  static TypeResolver covariantly(Type contextType) {\n    return new TypeResolver().where(TypeMappingIntrospector.getTypeMappings(contextType));\n  }\n\n  /**\n   * Returns a resolver that resolves types \"invariantly\".\n   *\n   * <p>For example, when resolving {@code List<T>} in the context of {@code ArrayList<?>}, {@code\n   * <T>} cannot be invariantly resolved to {@code <?>} because otherwise the parameter type of\n   * {@code List::set} will be {@code <?>} and it'll falsely say any object can be passed into\n   * {@code ArrayList<?>::set}.\n   *\n   * <p>Instead, {@code <?>} will be resolved to a capture in the form of a type variable {@code\n   * <capture-of-? extends Object>}, effectively preventing {@code set} from accepting any type.\n   */\n  static TypeResolver invariantly(Type contextType) {\n    Type invariantContext = WildcardCapturer.INSTANCE.capture(contextType);\n    return new TypeResolver().where(TypeMappingIntrospector.getTypeMappings(invariantContext));\n  }\n\n  /**\n   * Returns a new {@code TypeResolver} with type variables in {@code formal} mapping to types in\n   * {@code actual}.\n   *\n   * <p>For example, if {@code formal} is a {@code TypeVariable T}, and {@code actual} is {@code\n   * String.class}, then {@code new TypeResolver().where(formal, actual)} will {@linkplain\n   * #resolveType resolve} {@code ParameterizedType List<T>} to {@code List<String>}, and resolve\n   * {@code Map<T, Something>} to {@code Map<String, Something>} etc. Similarly, {@code formal} and\n   * {@code actual} can be {@code Map<K, V>} and {@code Map<String, Integer>} respectively, or they\n   * can be {@code E[]} and {@code String[]} respectively, or even any arbitrary combination\n   * thereof.\n   *\n   * @param formal The type whose type variables or itself is mapped to other type(s). It's almost\n   *     always a bug if {@code formal} isn't a type variable and contains no type variable. Make\n   *     sure you are passing the two parameters in the right order.\n   * @param actual The type that the formal type variable(s) are mapped to. It can be or contain yet\n   *     other type variables, in which case these type variables will be further resolved if\n   *     corresponding mappings exist in the current {@code TypeResolver} instance.\n   */\n  public TypeResolver where(Type formal, Type actual) {\n    Map<TypeVariableKey, Type> mappings = new HashMap<>();\n    populateTypeMappings(mappings, checkNotNull(formal), checkNotNull(actual));\n    return where(mappings);\n  }\n\n  /** Returns a new {@code TypeResolver} with {@code variable} mapping to {@code type}. */\n  TypeResolver where(Map<TypeVariableKey, ? extends Type> mappings) {\n    return new TypeResolver(typeTable.where(mappings));\n  }\n\n  private static void populateTypeMappings(\n      Map<TypeVariableKey, Type> mappings, Type from, Type to) {\n    if (from.equals(to)) {\n      return;\n    }\n    new TypeVisitor() {\n      @Override\n      void visitTypeVariable(TypeVariable<?> typeVariable) {\n        mappings.put(new TypeVariableKey(typeVariable), to);\n      }\n\n      @Override\n      void visitWildcardType(WildcardType fromWildcardType) {\n        if (!(to instanceof WildcardType)) {\n          return; // okay to say <?> is anything\n        }\n        WildcardType toWildcardType = (WildcardType) to;\n        Type[] fromUpperBounds = fromWildcardType.getUpperBounds();\n        Type[] toUpperBounds = toWildcardType.getUpperBounds();\n        Type[] fromLowerBounds = fromWildcardType.getLowerBounds();\n        Type[] toLowerBounds = toWildcardType.getLowerBounds();\n        checkArgument(\n            fromUpperBounds.length == toUpperBounds.length\n                && fromLowerBounds.length == toLowerBounds.length,\n            \"Incompatible type: %s vs. %s\",\n            fromWildcardType,\n            to);\n        for (int i = 0; i < fromUpperBounds.length; i++) {\n          populateTypeMappings(mappings, fromUpperBounds[i], toUpperBounds[i]);\n        }\n        for (int i = 0; i < fromLowerBounds.length; i++) {\n          populateTypeMappings(mappings, fromLowerBounds[i], toLowerBounds[i]);\n        }\n      }\n\n      @Override\n      void visitParameterizedType(ParameterizedType fromParameterizedType) {\n        if (to instanceof WildcardType) {\n          return; // Okay to say Foo<A> is <?>\n        }\n        ParameterizedType toParameterizedType = expectArgument(ParameterizedType.class, to);\n        if (fromParameterizedType.getOwnerType() != null\n            && toParameterizedType.getOwnerType() != null) {\n          populateTypeMappings(\n              mappings, fromParameterizedType.getOwnerType(), toParameterizedType.getOwnerType());\n        }\n        checkArgument(\n            fromParameterizedType.getRawType().equals(toParameterizedType.getRawType()),\n            \"Inconsistent raw type: %s vs. %s\",\n            fromParameterizedType,\n            to);\n        Type[] fromArgs = fromParameterizedType.getActualTypeArguments();\n        Type[] toArgs = toParameterizedType.getActualTypeArguments();\n        checkArgument(\n            fromArgs.length == toArgs.length,\n            \"%s not compatible with %s\",\n            fromParameterizedType,\n            toParameterizedType);\n        for (int i = 0; i < fromArgs.length; i++) {\n       ",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The where() method does not handle the case where the 'actual' parameter is a ParameterizedType and the 'formal' parameter is a TypeVariable. This can lead to incorrect type mappings.\",\n         \"suggested_fix\": \"In the where() method, add a check to see if 'actual' is a ParameterizedType and if so, recursively call the where() method with the actual type arguments of 'actual' and the corresponding type arguments of 'formal'.\"\n      },\n      {\n         \"explanation\": \"The TypeVisitor class does not handle the case where the 'to' parameter is a GenericArrayType. This can lead to incorrect type mappings.\",\n         \"suggested_fix\": \"In the TypeVisitor class, add a check to see if 'to' is a GenericArrayType and if so, recursively call the populateTypeMappings() method with the component type of 'to' and the corresponding type of 'from'.\"\n      },\n      {\n         \"explanation\": \"The where() method does not handle the case where the 'formal' parameter is a WildcardType and the 'actual' parameter is not a WildcardType. This can lead to incorrect type mappings.\",\n         \"suggested_fix\": \"In the where() method, add a check to see if 'formal' is a WildcardType and if so, recursively call the where() method with the upper and lower bounds of 'formal' and the corresponding upper and lower bounds of 'actual'.\"\n      },\n      {\n         \"explanation\": \"The TypeVisitor class does not handle the case where the 'from' parameter is a TypeVariable and the 'to' parameter is a WildcardType. This can lead to incorrect type mappings.\",\n         \"suggested_fix\": \"In the TypeVisitor class, add a check to see if 'from' is a TypeVariable and if so, recursively call the populateTypeMappings() method with the bounds of 'from' and the corresponding bounds of 'to'.\"\n      },\n      {\n         \"explanation\": \"The TypeResolver class does not handle the case where the 'contextType' parameter is a GenericArrayType. This can lead to incorrect type mappings.\",\n         \"suggested_fix\": \"In the TypeResolver class, add a check to see if 'contextType' is a GenericArrayType and if so, recursively call the covariantly() method with the component type of 'contextType'.\"\n      },\n      {\n         \"explanation\": \"The TypeResolver class does not handle the case where the 'contextType' parameter is a WildcardType. This can lead to incorrect type mappings.\",\n         \"suggested_fix\": \"In the TypeResolver class, add a check to see if 'contextType' is a WildcardType and if so, recursively call the invariantly() method with the upper and lower bounds of 'contextType'.\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"None\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The where() method does not handle the case where the 'actual' parameter is a ParameterizedType and the 'formal' parameter is a TypeVariable. This can lead to incorrect type mappings.",
        "suggested_fix": "In the where() method, add a check to see if 'actual' is a ParameterizedType and if so, recursively call the where() method with the actual type arguments of 'actual' and the corresponding type arguments of 'formal'."
      },
      {
        "explanation": "The TypeVisitor class does not handle the case where the 'to' parameter is a GenericArrayType. This can lead to incorrect type mappings.",
        "suggested_fix": "In the TypeVisitor class, add a check to see if 'to' is a GenericArrayType and if so, recursively call the populateTypeMappings() method with the component type of 'to' and the corresponding type of 'from'."
      },
      {
        "explanation": "The where() method does not handle the case where the 'formal' parameter is a WildcardType and the 'actual' parameter is not a WildcardType. This can lead to incorrect type mappings.",
        "suggested_fix": "In the where() method, add a check to see if 'formal' is a WildcardType and if so, recursively call the where() method with the upper and lower bounds of 'formal' and the corresponding upper and lower bounds of 'actual'."
      },
      {
        "explanation": "The TypeVisitor class does not handle the case where the 'from' parameter is a TypeVariable and the 'to' parameter is a WildcardType. This can lead to incorrect type mappings.",
        "suggested_fix": "In the TypeVisitor class, add a check to see if 'from' is a TypeVariable and if so, recursively call the populateTypeMappings() method with the bounds of 'from' and the corresponding bounds of 'to'."
      },
      {
        "explanation": "The TypeResolver class does not handle the case where the 'contextType' parameter is a GenericArrayType. This can lead to incorrect type mappings.",
        "suggested_fix": "In the TypeResolver class, add a check to see if 'contextType' is a GenericArrayType and if so, recursively call the covariantly() method with the component type of 'contextType'."
      },
      {
        "explanation": "The TypeResolver class does not handle the case where the 'contextType' parameter is a WildcardType. This can lead to incorrect type mappings.",
        "suggested_fix": "In the TypeResolver class, add a check to see if 'contextType' is a WildcardType and if so, recursively call the invariantly() method with the upper and lower bounds of 'contextType'."
      }
    ],
    "no_bugs_reasoning": "None"
  },
  "error": null
}