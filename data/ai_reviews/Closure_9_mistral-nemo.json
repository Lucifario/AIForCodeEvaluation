{"sample_id": "Closure_9", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2011 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n/**\n * Rewrites a CommonJS module http://wiki.commonjs.org/wiki/Modules/1.1.1\n * into a form that can be safely concatenated.\n * Does not add a function around the module body but instead adds suffixes\n * to global variables to avoid conflicts.\n * Calls to require are changed to reference the required module directly.\n * goog.provide and goog.require are emitted for closure compiler automatic\n * ordering.\n */\npublic class ProcessCommonJSModules implements CompilerPass {\n  // According to the spec, the forward slash should be the delimite on\n  // all platforms.\n  private static final String MODULE_SLASH = \"/\";\n\n  public static final String DEFAULT_FILENAME_PREFIX = \".\" + MODULE_SLASH;\n\n  private static final String MODULE_NAME_SEPARATOR = \"\\\\$\";\n  private static final String MODULE_NAME_PREFIX = \"module$\";\n\n  private final AbstractCompiler compiler;\n  private final String filenamePrefix;\n  private final boolean reportDependencies;\n  private JSModule module;\n\n  ProcessCommonJSModules(AbstractCompiler compiler, String filenamePrefix) {\n    this(compiler, filenamePrefix, true);\n  }\n\n  ProcessCommonJSModules(AbstractCompiler compiler, String filenamePrefix,\n      boolean reportDependencies) {\n    this.compiler = compiler;\n    this.filenamePrefix = filenamePrefix.endsWith(MODULE_SLASH) ?\n        filenamePrefix : filenamePrefix + MODULE_SLASH;\n    this.reportDependencies = reportDependencies;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal\n        .traverse(compiler, root, new ProcessCommonJsModulesCallback());\n  }\n\n  String guessCJSModuleName(String filename) {\n    return toModuleName(normalizeSourceName(filename));\n  }\n\n  /**\n   * For every file that is being processed this returns the module that\n   * created for it.\n   */\n  JSModule getModule() {\n    return module;\n  }\n\n  /**\n   * Turns a filename into a JS identifier that is used for moduleNames in\n   * rewritten code. Removes leading ./, replaces / with $, removes trailing .js\n   * and replaces - with _. All moduleNames get a \"module$\" prefix.\n   */\n  public static String toModuleName(String filename) {\n    return MODULE_NAME_PREFIX +\n        filename.replaceAll(\"^\\\\.\" + Pattern.quote(MODULE_SLASH), \"\")\n            .replaceAll(Pattern.quote(MODULE_SLASH), MODULE_NAME_SEPARATOR)\n            .replaceAll(\"\\\\.js$\", \"\").replaceAll(\"-\", \"_\");\n  }\n\n  /**\n   * Turn a filename into a moduleName with support for relative addressing\n   * with ./ and ../ based on currentFilename;\n   */\n  public static String toModuleName(String requiredFilename,\n      String currentFilename) {\n    requiredFilename = requiredFilename.replaceAll(\"\\\\.js$\", \"\");\n    currentFilename = currentFilename.replaceAll(\"\\\\.js$\", \"\");\n\n    if (requiredFilename.startsWith(\".\" + MODULE_SLASH) ||\n        requiredFilename.startsWith(\"..\" + MODULE_SLASH)) {\n      try {\n        requiredFilename = (new URI(currentFilename)).resolve(new URI(requiredFilename))\n            .toString();\n      } catch (URISyntaxException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return toModuleName(requiredFilename);\n  }\n\n  private String normalizeSourceName(String filename) {\n    // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n    // wrestle it back.\n\n    if (filename.indexOf(filenamePrefix) == 0) {\n      filename = filename.substring(filenamePrefix.length());\n    }\n\n    return filename;\n  }\n\n  /**\n   * Visits require, every \"script\" and special module.exports assignments.\n   */\n  private class ProcessCommonJsModulesCallback extends\n      AbstractPostOrderCallback {\n\n    private int scriptNodeCount = 0;\n    private Set<String> modulesWithExports = Sets.newHashSet();\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isCall() && n.getChildCount() == 2 &&\n          \"require\".equals(n.getFirstChild().getQualifiedName()) &&\n          n.getChildAtIndex(1).isString()) {\n        visitRequireCall(t, n, parent);\n      }\n\n      if (n.isScript()) {\n        scriptNodeCount++;\n        visitScript(t, n);\n      }\n\n      if (n.isGetProp() &&\n          \"module.exports\".equals(n.getQualifiedName())) {\n        visitModuleExports(n);\n      }\n    }\n\n    /**\n     * Visit require calls. Emit corresponding goog.require and rewrite require\n     * to be a direct reference to name of require module.\n     */\n    private void visitRequireCall(NodeTraversal t, Node require, Node parent) {\n      String moduleName = toModuleName(require.getChildAtIndex(1).getString(),\n          normalizeSourceName(t.getSourceName()));\n      Node moduleRef = IR.name(moduleName).srcref(require);\n      parent.replaceChild(require, moduleRef);\n      Node script = getCurrentScriptNode(parent);\n      if (reportDependencies) {\n        t.getInput().addRequire(moduleName);\n      }\n      // Rewrite require(\"name\").\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"require\")),\n              IR.string(moduleName))).copyInformationFromForTree(require));\n      compiler.reportCodeChange();\n    }\n\n    /**\n     * Emit goog.provide and add suffix to all global vars to avoid conflicts\n     * with other modules.\n     */\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n\n    /**\n     * Emit <code>if (moduleName.module$exports) {\n     *    moduleName = moduleName.module$export;\n     * }</code> at end of file.\n     */\n    private void emitOptionalModuleExportsOverride(Node script,\n        String moduleName) {\n      if (!modulesWithExports.contains(moduleName)) {\n        return;\n      }\n\n      Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n          IR.string(\"module$exports\"));\n      script.addChildToBack(IR.ifNode(\n          moduleExportsProp,\n          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n              moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n          script));\n    }\n\n    /**\n     * Rewrite module.exports to moduleName.module$exports.\n     */\n    private void visitModuleExports(Node prop) {\n      String moduleName = guessCJSModuleName(prop.getSourceFileName());\n      Node module = prop.getChildAtIndex(0);\n      module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n      module.setString(moduleName);\n      Node exports = prop.getChildAtIndex(1);\n      exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n      exports.setString(\"module$exports\");\n      modulesWithExports.add(moduleName);\n    }\n\n    /**\n     * Returns next script node in parents.\n     */\n    private Node getCurrentScriptNode(Node n) {\n      while (true) {\n        if (n.isScript()) {\n          return n;\n        }\n        n = n.getParent();\n      }\n    }\n  }\n\n  /**\n   * Traverses a node tree and appends a suffix to all global variable names.\n   */\n  private class SuffixVarsCallback extends AbstractPostOrderCallback {\n\n    private static final String EXPORTS = \"exports\";\n\n    private final String suffix;\n\n    SuffixVarsCallback(String suffix) {\n      this.suffix = suffix;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isName()) {\n        String name = n.getString();\n        if (suffix.equals(name)) {\n          return;\n        }\n        if (EXPORTS.equals(name)) {\n          n.setString(suffix);\n          n.putProp(Node.ORIGINALNAME_PROP, EXPORTS);\n        } else {\n          Scope.Var var = t.getScope().getVar(name);\n          if (var != null && var.isGlobal()) {\n            n.setString(name + \"$$\" + suffix);\n            n.putProp(Node.ORIGINALNAME_PROP, name);\n          }\n        }\n      }\n    }\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"description\": \"Inconsistent use of filenamePrefix in constructor\",\n      \"code\": \"this.filenamePrefix = filenamePrefix.endsWith(MODULE_SLASH) ? filenamePrefix : filenamePrefix + MODULE_SLASH;\"\n    },\n    {\n      \"description\": \"Potential NullPointerException in guessCJSModuleName\",\n      \"code\": \"String filename = normalizeSourceName(t.getSourceName());\"\n    },\n    {\n      \"description\": \"Infinite loop in toModuleName when requiredFilename starts with ./ or ../\",\n      \"code\": \"while (requiredFilename.startsWith(\"\n             } \n  ]\n}"}}