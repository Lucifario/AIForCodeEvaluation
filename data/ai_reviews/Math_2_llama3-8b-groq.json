{"sample_id": "Math_2", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.distribution;\n\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math3.exception.NumberIsTooLargeException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.random.RandomGenerator;\nimport org.apache.commons.math3.random.Well19937c;\n\n/**\n * Implementation of the hypergeometric distribution.\n *\n * @see <a href=\"http://en.wikipedia.org/wiki/Hypergeometric_distribution\">Hypergeometric distribution (Wikipedia)</a>\n * @see <a href=\"http://mathworld.wolfram.com/HypergeometricDistribution.html\">Hypergeometric distribution (MathWorld)</a>\n * @version $Id$\n */\npublic class HypergeometricDistribution extends AbstractIntegerDistribution {\n    /** Serializable version identifier. */\n    private static final long serialVersionUID = -436928820673516179L;\n    /** The number of successes in the population. */\n    private final int numberOfSuccesses;\n    /** The population size. */\n    private final int populationSize;\n    /** The sample size. */\n    private final int sampleSize;\n    /** Cached numerical variance */\n    private double numericalVariance = Double.NaN;\n    /** Whether or not the numerical variance has been calculated */\n    private boolean numericalVarianceIsCalculated = false;\n\n    /**\n     * Construct a new hypergeometric distribution with the specified population\n     * size, number of successes in the population, and sample size.\n     *\n     * @param populationSize Population size.\n     * @param numberOfSuccesses Number of successes in the population.\n     * @param sampleSize Sample size.\n     * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n     * @throws NotStrictlyPositiveException if {@code populationSize <= 0}.\n     * @throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize},\n     * or {@code sampleSize > populationSize}.\n     */\n    public HypergeometricDistribution(int populationSize, int numberOfSuccesses, int sampleSize)\n    throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n        this(new Well19937c(), populationSize, numberOfSuccesses, sampleSize);\n    }\n\n    /**\n     * Creates a new hypergeometric distribution.\n     *\n     * @param rng Random number generator.\n     * @param populationSize Population size.\n     * @param numberOfSuccesses Number of successes in the population.\n     * @param sampleSize Sample size.\n     * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n     * @throws NotStrictlyPositiveException if {@code populationSize <= 0}.\n     * @throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize},\n     * or {@code sampleSize > populationSize}.\n     * @since 3.1\n     */\n    public HypergeometricDistribution(RandomGenerator rng,\n                                      int populationSize,\n                                      int numberOfSuccesses,\n                                      int sampleSize)\n    throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n        super(rng);\n\n        if (populationSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.POPULATION_SIZE,\n                                                   populationSize);\n        }\n        if (numberOfSuccesses < 0) {\n            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,\n                                           numberOfSuccesses);\n        }\n        if (sampleSize < 0) {\n            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                                           sampleSize);\n        }\n\n        if (numberOfSuccesses > populationSize) {\n            throw new NumberIsTooLargeException(LocalizedFormats.NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE,\n                                                numberOfSuccesses, populationSize, true);\n        }\n        if (sampleSize > populationSize) {\n            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE,\n                                                sampleSize, populationSize, true);\n        }\n\n        this.numberOfSuccesses = numberOfSuccesses;\n        this.populationSize = populationSize;\n        this.sampleSize = sampleSize;\n    }\n\n    /** {@inheritDoc} */\n    public double cumulativeProbability(int x) {\n        double ret;\n\n        int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n        if (x < domain[0]) {\n            ret = 0.0;\n        } else if (x >= domain[1]) {\n            ret = 1.0;\n        } else {\n            ret = innerCumulativeProbability(domain[0], x, 1);\n        }\n\n        return ret;\n    }\n\n    /**\n     * Return the domain for the given hypergeometric distribution parameters.\n     *\n     * @param n Population size.\n     * @param m Number of successes in the population.\n     * @param k Sample size.\n     * @return a two element array containing the lower and upper bounds of the\n     * hypergeometric distribution.\n     */\n    private int[] getDomain(int n, int m, int k) {\n        return new int[] { getLowerDomain(n, m, k), getUpperDomain(m, k) };\n    }\n\n    /**\n     * Return the lowest domain value for the given hypergeometric distribution\n     * parameters.\n     *\n     * @param n Population size.\n     * @param m Number of successes in the population.\n     * @param k Sample size.\n     * @return the lowest domain value of the hypergeometric distribution.\n     */\n    private int getLowerDomain(int n, int m, int k) {\n        return FastMath.max(0, m - (n - k));\n    }\n\n    /**\n     * Access the number of successes.\n     *\n     * @return the number of successes.\n     */\n    public int getNumberOfSuccesses() {\n        return numberOfSuccesses;\n    }\n\n    /**\n     * Access the population size.\n     *\n     * @return the population size.\n     */\n    public int getPopulationSize() {\n        return populationSize;\n    }\n\n    /**\n     * Access the sample size.\n     *\n     * @return the sample size.\n     */\n    public int getSampleSize() {\n        return sampleSize;\n    }\n\n    /**\n     * Return the highest domain value for the given hypergeometric distribution\n     * parameters.\n     *\n     * @param m Number of successes in the population.\n     * @param k Sample size.\n     * @return the highest domain value of the hypergeometric distribution.\n     */\n    private int getUpperDomain(int m, int k) {\n        return FastMath.min(k, m);\n    }\n\n    /** {@inheritDoc} */\n    public double probability(int x) {\n        double ret;\n\n        int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n        if (x < domain[0] || x > domain[1]) {\n            ret = 0.0;\n        } else {\n            double p = (double) sampleSize / (double) populationSize;\n            double q = (double) (populationSize - sampleSize) / (double) populationSize;\n            double p1 = SaddlePointExpansion.logBinomialProbability(x,\n                    numberOfSuccesses, p, q);\n            double p2 =\n                SaddlePointExpansion.logBinomialProbability(sampleSize - x,\n                    populationSize - numberOfSuccesses, p, q);\n            double p3 =\n                SaddlePointExpansion.logBinomialProbability(sampleSize, populationSize, p, q);\n            ret = FastMath.exp(p1 + p2 - p3);\n        }\n\n        return ret;\n    }\n\n    /**\n     * For this distribution, {@code X}, this method returns {@code P(X >= x)}.\n     *\n     * @param x Value at which the CDF is evaluated.\n     * @return the upper tail CDF for this distribution.\n     * @since 1.1\n     */\n    public double upperCumulativeProbability(int x) {\n        double ret;\n\n        final int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n        if (x <= domain[0]) {\n            ret = 1.0;\n        } else if (x > domain[1]) {\n            ret = 0.0;\n        } else {\n            ret = innerCumulativeProbability(domain[1], x, -1);\n        }\n\n        return ret;\n    }\n\n    /**\n     * For this distribution, {@code X}, this method returns\n     * {@code P(x0 <= X <= x1)}.\n     * This probability is computed by summing the point probabilities for the\n     * values {@code x0, x0 + 1, x0 + 2, ..., x1}, in the order directed by\n     * {@code dx}.\n     *\n     * @param x0 Inclusive lower bound.\n     * @param x1 Inclusive upper bound.\n     * @param dx Direction of summation (1 indicates summing from x0 to x1, and\n     * 0 indicates summing from x1 to x0).\n     * @return {@code P(x0 <= X <= x1)}.\n     */\n    private double innerCumulativeProbability(int x0, int x1, int dx) {\n        double ret = probability(x0);\n        while (x0 != x1) {\n            x0 += dx;\n            ret += probability(x0);\n        }\n        return ret;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the mean is {@code n * m / N}.\n     */\n    public double getNumericalMean() {\n        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the variance is\n     * {@code [n * m * (N - n) * (N - m)] / [N^2 * (N - 1)]}.\n     */\n    public double getNumericalVariance() {\n        if (!numericalVarianceIsCalculated) {\n            numericalVariance = calculateNumericalVariance();\n            numericalVarianceIsCalculated = true;\n        }\n        return numericalVariance;\n    }\n\n    /**\n     * Used by {@link #getNumericalVariance()}.\n     *\n     * @return the variance of this distribution\n     */\n    protected double calculateNumericalVariance() {\n        final double N = getPopulationSize();\n        final double m = getNumberOfSuccesses();\n        final double n = getSampleSize();\n        return (n * m * (N - n) * (N - m)) / (N * N * (N - 1));\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the lower bound of the support is\n     * {@code max(0, n + m - N)}.\n     *\n     * @return lower bound of the support\n     */\n    public int getSupportLowerBound() {\n        return FastMath.max(0,\n                            getSampleSize() + getNumberOfSuccesses() - getPopulationSize());\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For number of successes {@code m} and sample size {@code n}, the upper\n     * bound of the support is {@code min(m, n)}.\n     *\n     * @return upper bound of the support\n     */\n    public int getSupportUpperBound() {\n        return FastMath.min(getNumberOfSuccesses(), getSampleSize());\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The support of this distribution is connected.\n     *\n     * @return {@code true}\n     */\n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"code\": \"if (populationSize <= 0) {\",\n         \"description\": \"The population size should be strictly positive, not just positive.\"\n      },\n      {\n         \"code\": \"if (numberOfSuccesses < 0) {\",\n         \"description\": \"The number of successes should be non-negative, not just not positive.\"\n      },\n      {\n         \"code\": \"if (sampleSize < 0) {\",\n         \"description\": \"The sample size should be non-negative, not just not positive.\"\n      },\n      {\n         \"code\": \"if (numberOfSuccesses > populationSize) {\",\n         \"description\": \"The number of successes should not be greater than the population size.\"\n      },\n      {\n         \"code\": \"if (sampleSize > populationSize) {\",\n         \"description\": \"The sample size should not be greater than the population size.\"\n      },\n      {\n         \"code\": \"if (x < domain[0]) {\",\n         \"description\": \"The cumulative probability function should return 0 for values less than the lower bound of the domain.\"\n      },\n      {\n         \"code\": \"if (x >= domain[1]) {\",\n         \"description\": \"The cumulative probability function should return 1 for values greater than or equal to the upper bound of the domain.\"\n      },\n      {\n         \"code\": \"ret = innerCumulativeProbability(domain[0], x, 1);\",\n         \"description\": \"The inner cumulative probability function should be called with the correct parameters.\"\n      },\n      {\n         \"code\": \"this.numericalVariance = Double.NaN;\",\n         \"description\": \"The numerical variance should be initialized with a default value, not NaN.\"\n      },\n      {\n         \"code\": \"this.numericalVarianceIsCalculated = false;\",\n         \"description\": \"The flag indicating whether the numerical variance has been calculated should be initialized to false.\"\n      }\n   ]\n}"}}