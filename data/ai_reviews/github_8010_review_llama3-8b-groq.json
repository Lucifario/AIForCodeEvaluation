{
  "source_item_id": 8010,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:52:18.036124",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;\nimport static java.util.Objects.requireNonNull;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.J2ktIncompatible;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.concurrent.LazyInit;\nimport com.google.j2objc.annotations.RetainedWith;\nimport com.google.j2objc.annotations.WeakOuter;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * A general-purpose bimap implementation using any two backing {@code Map} instances.\n *\n * <p>Note that this class contains {@code equals()} calls that keep it from supporting {@code\n * IdentityHashMap} backing maps.\n *\n * @author Kevin Bourrillion\n * @author Mike Bostock\n */\n@GwtCompatible\nabstract class AbstractBiMap<K extends @Nullable Object, V extends @Nullable Object>\n    extends ForwardingMap<K, V> implements BiMap<K, V>, Serializable {\n\n  @SuppressWarnings(\"nullness:initialization.field.uninitialized\") // For J2KT (lateinit)\n  private transient Map<K, V> delegate;\n\n  @SuppressWarnings(\"nullness:initialization.field.uninitialized\") // For J2KT (lateinit)\n  @RetainedWith\n  transient AbstractBiMap<V, K> inverse;\n\n  /** Package-private constructor for creating a map-backed bimap. */\n  AbstractBiMap(Map<K, V> forward, Map<V, K> backward) {\n    setDelegates(forward, backward);\n  }\n\n  /** Private constructor for inverse bimap. */\n  private AbstractBiMap(Map<K, V> backward, AbstractBiMap<V, K> forward) {\n    delegate = backward;\n    inverse = forward;\n  }\n\n  @Override\n  protected Map<K, V> delegate() {\n    return delegate;\n  }\n\n  /** Returns its input, or throws an exception if this is not a valid key. */\n  @CanIgnoreReturnValue\n  @ParametricNullness\n  K checkKey(@ParametricNullness K key) {\n    return key;\n  }\n\n  /** Returns its input, or throws an exception if this is not a valid value. */\n  @CanIgnoreReturnValue\n  @ParametricNullness\n  V checkValue(@ParametricNullness V value) {\n    return value;\n  }\n\n  /**\n   * Specifies the delegate maps going in each direction. Called by the constructor and by\n   * subclasses during deserialization.\n   */\n  void setDelegates(Map<K, V> forward, Map<V, K> backward) {\n    checkState(delegate == null);\n    checkState(inverse == null);\n    checkArgument(forward.isEmpty());\n    checkArgument(backward.isEmpty());\n    checkArgument(forward != backward);\n    delegate = forward;\n    inverse = makeInverse(backward);\n  }\n\n  AbstractBiMap<V, K> makeInverse(Map<V, K> backward) {\n    return new Inverse<>(backward, this);\n  }\n\n  void setInverse(AbstractBiMap<V, K> inverse) {\n    this.inverse = inverse;\n  }\n\n  // Query Operations (optimizations)\n\n  @Override\n  public boolean containsValue(@Nullable Object value) {\n    return inverse.containsKey(value);\n  }\n\n  // Modification Operations\n\n  @CanIgnoreReturnValue\n  @Override\n  public @Nullable V put(@ParametricNullness K key, @ParametricNullness V value) {\n    return putInBothMaps(key, value, false);\n  }\n\n  @CanIgnoreReturnValue\n  @Override\n  public @Nullable V forcePut(@ParametricNullness K key, @ParametricNullness V value) {\n    return putInBothMaps(key, value, true);\n  }\n\n  private @Nullable V putInBothMaps(\n      @ParametricNullness K key, @ParametricNullness V value, boolean force) {\n    checkKey(key);\n    checkValue(value);\n    boolean containedKey = containsKey(key);\n    if (containedKey && Objects.equals(value, get(key))) {\n      return value;\n    }\n    if (force) {\n      inverse().remove(value);\n    } else {\n      checkArgument(!containsValue(value), \"value already present: %s\", value);\n    }\n    V oldValue = delegate.put(key, value);\n    updateInverseMap(key, containedKey, oldValue, value);\n    return oldValue;\n  }\n\n  private void updateInverseMap(\n      @ParametricNullness K key,\n      boolean containedKey,\n      @Nullable V oldValue,\n      @ParametricNullness V newValue) {\n    if (containedKey) {\n      // The cast is safe because of the containedKey check.\n      removeFromInverseMap(uncheckedCastNullableTToT(oldValue));\n    }\n    inverse.delegate.put(newValue, key);\n  }\n\n  @CanIgnoreReturnValue\n  @Override\n  public @Nullable V remove(@Nullable Object key) {\n    return containsKey(key) ? removeFromBothMaps(key) : null;\n  }\n\n  @CanIgnoreReturnValue\n  @ParametricNullness\n  private V removeFromBothMaps(@Nullable Object key) {\n    // The cast is safe because the callers of this method first check that the key is present.\n    V oldValue = uncheckedCastNullableTToT(delegate.remove(key));\n    removeFromInverseMap(oldValue);\n    return oldValue;\n  }\n\n  private void removeFromInverseMap(@ParametricNullness V oldValue) {\n    inverse.delegate.remove(oldValue);\n  }\n\n  // Bulk Operations\n\n  @Override\n  public void putAll(Map<? extends K, ? extends V> map) {\n    for (Entry<? extends K, ? extends V> entry : map.entrySet()) {\n      put(entry.getKey(), entry.getValue());\n    }\n  }\n\n  @Override\n  public void clear() {\n    delegate.clear();\n    inverse.delegate.clear();\n  }\n\n  // Views\n\n  @Override\n  public BiMap<V, K> inverse() {\n    return inverse;\n  }\n\n  @LazyInit private transient @Nullable Set<K> keySet;\n\n  @Override\n  public Set<K> keySet() {\n    Set<K> result = keySet;\n    return (result == null) ? keySet = new KeySet() : result;\n  }\n\n  @WeakOuter\n  private final class KeySet extends ForwardingSet<K> {\n    @Override\n    protected Set<K> delegate() {\n      return delegate.keySet();\n    }\n\n    @Override\n    public void clear() {\n      AbstractBiMap.this.clear();\n    }\n\n    @Override\n    public boolean remove(@Nullable Object key) {\n      if (!contains(key)) {\n        return false;\n      }\n      removeFromBothMaps(key);\n      return true;\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> keysToRemove) {\n      return standardRemoveAll(keysToRemove);\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> keysToRetain) {\n      return standardRetainAll(keysToRetain);\n    }\n\n    @Override\n    public Iterator<K> iterator() {\n      return Maps.keyIterator(entrySet().iterator());\n    }\n  }\n\n  @LazyInit private transient @Nullable Set<V> valueSet;\n\n  @Override\n  public Set<V> values() {\n    /*\n     * We can almost reuse the inverse's keySet, except we have to fix the\n     * iteration order so that it is consistent with the forward map.\n     */\n    Set<V> result = valueSet;\n    return (result == null) ? valueSet = new ValueSet() : result;\n  }\n\n  @WeakOuter\n  private final class ValueSet extends ForwardingSet<V> {\n    final Set<V> valuesDelegate = inverse.keySet();\n\n    @Override\n    protected Set<V> delegate() {\n      return valuesDelegate;\n    }\n\n    @Override\n    public Iterator<V> iterator() {\n      return Maps.valueIterator(entrySet().iterator());\n    }\n\n    @Override\n    public @Nullable Object[] toArray() {\n      return standardToArray();\n    }\n\n    @Override\n    @SuppressWarnings(\"nullness\") // bug in our check",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The class is not properly handling null values in the key and value parameters of the put and forcePut methods. This can lead to NullPointerExceptions.\",\n         \"suggested_fix\": \"Add null checks in the put and forcePut methods to handle null values.\"\n      },\n      {\n         \"explanation\": \"The class is not properly handling the case where the input map is not empty. This can lead to IllegalArgumentExceptions.\",\n         \"suggested_fix\": \"Add a check to ensure the input map is empty before setting the delegates.\"\n      },\n      {\n         \"explanation\": \"The updateInverseMap method is not properly handling the case where the old value is null. This can lead to NullPointerExceptions.\",\n         \"suggested_fix\": \"Add a null check for the old value in the updateInverseMap method.\"\n      },\n      {\n         \"explanation\": \"The removeFromInverseMap method is not properly handling the case where the old value is null. This can lead to NullPointerExceptions.\",\n         \"suggested_fix\": \"Add a null check for the old value in the removeFromInverseMap method.\"\n      },\n      {\n         \"explanation\": \"The KeySet class is not properly handling the case where the key is null. This can lead to NullPointerExceptions.\",\n         \"suggested_fix\": \"Add a null check for the key in the KeySet class.\"\n      },\n      {\n         \"explanation\": \"The ValueSet class is not properly handling the case where the value is null. This can lead to NullPointerExceptions.\",\n         \"suggested_fix\": \"Add a null check for the value in the ValueSet class.\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs found in the provided code snippet.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The class is not properly handling null values in the key and value parameters of the put and forcePut methods. This can lead to NullPointerExceptions.",
        "suggested_fix": "Add null checks in the put and forcePut methods to handle null values."
      },
      {
        "explanation": "The class is not properly handling the case where the input map is not empty. This can lead to IllegalArgumentExceptions.",
        "suggested_fix": "Add a check to ensure the input map is empty before setting the delegates."
      },
      {
        "explanation": "The updateInverseMap method is not properly handling the case where the old value is null. This can lead to NullPointerExceptions.",
        "suggested_fix": "Add a null check for the old value in the updateInverseMap method."
      },
      {
        "explanation": "The removeFromInverseMap method is not properly handling the case where the old value is null. This can lead to NullPointerExceptions.",
        "suggested_fix": "Add a null check for the old value in the removeFromInverseMap method."
      },
      {
        "explanation": "The KeySet class is not properly handling the case where the key is null. This can lead to NullPointerExceptions.",
        "suggested_fix": "Add a null check for the key in the KeySet class."
      },
      {
        "explanation": "The ValueSet class is not properly handling the case where the value is null. This can lead to NullPointerExceptions.",
        "suggested_fix": "Add a null check for the value in the ValueSet class."
      }
    ],
    "no_bugs_reasoning": "No bugs found in the provided code snippet."
  },
  "error": null
}