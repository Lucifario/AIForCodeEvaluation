{"sample_id": "Time_15", "model": "mistral-nemo", "code_context": "/*\n *  Copyright 2001-2005 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.field;\n\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.IllegalFieldValueException;\n\n/**\n * General utilities that don't fit elsewhere.\n * <p>\n * FieldUtils is thread-safe and immutable.\n *\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic class FieldUtils {\n\n    /**\n     * Restricted constructor.\n     */\n    private FieldUtils() {\n        super();\n    }\n    \n    //------------------------------------------------------------------------\n    /**\n     * Negates the input throwing an exception if it can't negate it.\n     * \n     * @param value  the value to negate\n     * @return the negated value\n     * @throws ArithmeticException if the value is Integer.MIN_VALUE\n     * @since 1.1\n     */\n    public static int safeNegate(int value) {\n        if (value == Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"Integer.MIN_VALUE cannot be negated\");\n        }\n        return -value;\n    }\n    \n    /**\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeAdd(int val1, int val2) {\n        int sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n    \n    /**\n     * Add two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeAdd(long val1, long val2) {\n        long sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }\n    \n    /**\n     * Subtracts two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value, to be taken away from\n     * @param val2  the second value, the amount to take away\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeSubtract(long val1, long val2) {\n        long diff = val1 - val2;\n        // If there is a sign change, but the two values have different signs...\n        if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n        }\n        return diff;\n    }\n    \n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static int safeMultiply(int val1, int val2) {\n        long total = (long) val1 * (long) val2;\n        if (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\n          throw new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n        }\n        return (int) total;\n    }\n\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static long safeMultiply(long val1, int val2) {\n        switch (val2) {\n            case -1:\n                return -val1;\n            case 0:\n                return 0L;\n            case 1:\n                return val1;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val1 == 1) {\n            return val2;\n        }\n        if (val1 == 0 || val2 == 0) {\n            return 0;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n    \n    /**\n     * Casts to an int throwing an exception if overflow occurs.\n     * \n     * @param value  the value\n     * @return the value as an int\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeToInt(long value) {\n        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n            return (int) value;\n        }\n        throw new ArithmeticException(\"Value cannot fit in an int: \" + value);\n    }\n    \n    /**\n     * Multiply two values to return an int throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static int safeMultiplyToInt(long val1, long val2) {\n        long val = FieldUtils.safeMultiply(val1, val2);\n        return FieldUtils.safeToInt(val);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Verify that input values are within specified bounds.\n     * \n     * @param value  the value to check\n     * @param lowerBound  the lower bound allowed for value\n     * @param upperBound  the upper bound allowed for value\n     * @throws IllegalFieldValueException if value is not in the specified bounds\n     */\n    public static void verifyValueBounds(DateTimeField field, \n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (field.getType(), Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }\n\n    /**\n     * Verify that input values are within specified bounds.\n     * \n     * @param value  the value to check\n     * @param lowerBound  the lower bound allowed for value\n     * @param upperBound  the upper bound allowed for value\n     * @throws IllegalFieldValueException if value is not in the specified bounds\n     * @since 1.1\n     */\n    public static void verifyValueBounds(DateTimeFieldType fieldType, \n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (fieldType, Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }\n\n    /**\n     * Verify that input values are within specified bounds.\n     * \n     * @param value  the value to check\n     * @param lowerBound  the lower bound allowed for value\n     * @param upperBound  the upper bound allowed for value\n     * @throws IllegalFieldValueException if value is not in the specified bounds\n     */\n    public static void verifyValueBounds(String fieldName,\n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (fieldName, Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }\n\n    /**\n     * Utility method used by addWrapField implementations to ensure the new\n     * value lies within the field's legal value range.\n     *\n     * @param currentValue the current value of the data, which may lie outside\n     * the wrapped value range\n     * @param wrapValue  the value to add to current value before\n     *  wrapping.  This may be negative.\n     * @param minValue the wrap range minimum value.\n     * @param maxValue the wrap range maximum value.  This must be\n     *  greater than minValue (checked by the method).\n     * @return the wrapped value\n     * @throws IllegalArgumentException if minValue is greater\n     *  than or equal to maxValue\n     */\n    public static int getWrappedValue(int currentValue, int wrapValue,\n                                      int minValue, int maxValue) {\n        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);\n    }\n\n    /**\n     * Utility method that ensures the given value lies within the field's\n     * legal value range.\n     * \n     * @param value  the value to fit into the wrapped value range\n     * @param minValue the wrap range minimum value.\n     * @param maxValue the wrap range maximum value.  This must be\n     *  greater than minValue (checked by the method).\n     * @return the wrapped value\n     * @throws IllegalArgumentException if minValue is greater\n     *  than or equal to maxValue\n     */\n    public static int getWrappedValue(int value, int minValue, int maxValue) {\n        if (minValue >= maxValue) {\n            throw new IllegalArgumentException(\"MIN > MAX\");\n        }\n\n        int wrapRange = maxValue - minValue + 1;\n        value -= minValue;\n\n        if (value >= 0) {\n            return (value % wrapRange) + minValue;\n        }\n\n        int remByRange = (-value) % wrapRange;\n\n        if (remByRange == 0) {\n            return 0 + minValue;\n        }\n        return (wrapRange - remByRange) + minValue;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares two objects as equals handling null.\n     * \n     * @param object1  the first object\n     * @param object2  the second object\n     * @return true if equal\n     * @since 1.4\n     */\n    public static boolean equals(Object object1, Object object2) {\n        if (object1 == object2) {\n            return true;\n        }\n        if (object1 == null || object2 == null) {\n            return false;\n        }\n        return object1.equals(object2);\n    }\n\n}\n", "review": {"response": "{ \"bugs\": [\n\n  {\n    \"id\": 1,\n    \"description\": \"In the `safeMultiply` method for `long` and `int`, there is no handling for the case when `val2` is a very large positive number. This could lead to an `ArithmeticException` when multiplying a large `val1` by a large `val2`.\"\n  },\n\n  {\n    \"id\": 2,\n    \"description\": \"In the `safeMultiply` method for `long` and `long`, there is no handling for the case when both `val1` and `val2` are `Long.MIN_VALUE`. This could lead to an `ArithmeticException` when multiplying `-1` by `-1`.\"\n  },\n\n  {\n    \"id\": 3,\n    \"description\": \"The `FieldUtils` class is declared as `final`, but it has a non-private constructor. This violates the principle of encapsulation and could potentially allow subclasses to be created.\"\n  },\n\n  {\n    \"id\": 4,\n    \"description\": \"The `safeNegate` method throws an `ArithmeticException` when trying to negate `Integer.MIN_VALUE`, but it should throw an `IllegalArgumentException` because the input value is not valid for the operation.\"\n  }\n\n] }"}}