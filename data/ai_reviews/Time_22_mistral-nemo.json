{"sample_id": "Time_22", "model": "mistral-nemo", "code_context": "/*\n *  Copyright 2001-2007 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.base;\n\nimport java.io.Serializable;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.Duration;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.MutablePeriod;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadWritablePeriod;\nimport org.joda.time.ReadableDuration;\nimport org.joda.time.ReadableInstant;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.ReadablePeriod;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.convert.ConverterManager;\nimport org.joda.time.convert.PeriodConverter;\nimport org.joda.time.field.FieldUtils;\n\n/**\n * BasePeriod is an abstract implementation of ReadablePeriod that stores\n * data in a <code>PeriodType</code> and an <code>int[]</code>.\n * <p>\n * This class should generally not be used directly by API users.\n * The {@link ReadablePeriod} interface should be used when different \n * kinds of period objects are to be referenced.\n * <p>\n * BasePeriod subclasses may be mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @since 1.0\n */\npublic abstract class BasePeriod\n        extends AbstractPeriod\n        implements ReadablePeriod, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2110953284060001145L;\n\n    /** The type of period */\n    private PeriodType iType;\n    /** The values */\n    private int[] iValues;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a period from a set of field values.\n     *\n     * @param years  amount of years in this period, which must be zero if unsupported\n     * @param months  amount of months in this period, which must be zero if unsupported\n     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n     * @param days  amount of days in this period, which must be zero if unsupported\n     * @param hours  amount of hours in this period, which must be zero if unsupported\n     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n     * @param type  which set of fields this period supports\n     * @throws IllegalArgumentException if period type is invalid\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected BasePeriod(int years, int months, int weeks, int days,\n                         int hours, int minutes, int seconds, int millis,\n                         PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        iType = type;\n        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); // internal method\n    }\n\n    /**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, in milliseconds\n     * @param endInstant  interval end, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chrono  the chronology to use, null means ISO default\n     * @throws IllegalArgumentException if period type is invalid\n     */\n    protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, startInstant, endInstant);\n    }\n\n    /**\n     * Creates a period from the given interval endpoints.\n     *\n     * @param startInstant  interval start, null means now\n     * @param endInstant  interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     * @throws IllegalArgumentException if period type is invalid\n     */\n    protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        if (startInstant == null && endInstant == null) {\n            iType = type;\n            iValues = new int[size()];\n        } else {\n            long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n            long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n            Chronology chrono = DateTimeUtils.getIntervalChronology(startInstant, endInstant);\n            iType = type;\n            iValues = chrono.get(this, startMillis, endMillis);\n        }\n    }\n\n    /**\n     * Creates a period from the given duration and end point.\n     * <p>\n     * The two partials must contain the same fields, thus you can\n     * specify two <code>LocalDate</code> objects, or two <code>LocalTime</code>\n     * objects, but not one of each.\n     * As these are Partial objects, time zones have no effect on the result.\n     * <p>\n     * The two partials must also both be contiguous - see\n     * {@link DateTimeUtils#isContiguous(ReadablePartial)} for a\n     * definition. Both <code>LocalDate</code> and <code>LocalTime</code> are contiguous.\n     *\n     * @param start  the start of the period, must not be null\n     * @param end  the end of the period, must not be null\n     * @param type  which set of fields this period supports, null means standard\n     * @throws IllegalArgumentException if the partials are null or invalid\n     * @since 1.1\n     */\n    protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) {\n        super();\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) {\n            // for performance\n            type = checkPeriodType(type);\n            long startMillis = ((BaseLocal) start).getLocalMillis();\n            long endMillis = ((BaseLocal) end).getLocalMillis();\n            Chronology chrono = start.getChronology();\n            chrono = DateTimeUtils.getChronology(chrono);\n            iType = type;\n            iValues = chrono.get(this, startMillis, endMillis);\n        } else {\n            if (start.size() != end.size()) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            for (int i = 0, isize = start.size(); i < isize; i++) {\n                if (start.getFieldType(i) != end.getFieldType(i)) {\n                    throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n                }\n            }\n            if (DateTimeUtils.isContiguous(start) == false) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n            }\n            iType = checkPeriodType(type);\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n            iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L));\n        }\n    }\n\n    /**\n     * Creates a period from the given start point and duration.\n     *\n     * @param startInstant  the interval start, null means now\n     * @param duration  the duration of the interval, null means zero-length\n     * @param type  which set of fields this period supports, null means standard\n     */\n    protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        long endMillis = FieldUtils.safeAdd(startMillis, durationMillis);\n        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n        iType = type;\n        iValues = chrono.get(this, startMillis, endMillis);\n    }\n\n    /**\n     * Creates a period from the given duration and end point.\n     *\n     * @param duration  the duration of the interval, null means zero-length\n     * @param endInstant  the interval end, null means now\n     * @param type  which set of fields this period supports, null means standard\n     */\n    protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        long durationMillis = DateTimeUtils.getDurationMillis(duration);\n        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n        long startMillis = FieldUtils.safeSubtract(endMillis, durationMillis);\n        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n        iType = type;\n        iValues = chrono.get(this, startMillis, endMillis);\n    }\n\n    /**\n     * Creates a period from the given millisecond duration with the standard period type\n     * and ISO rules, ensuring that the calculation is performed with the time-only period type.\n     * <p>\n     * The calculation uses the hour, minute, second and millisecond fields.\n     *\n     * @param duration  the duration, in milliseconds\n     */\n    protected BasePeriod(long duration) {\n        this(duration, null, null);\n        // bug [3264409]\n    }\n\n    /**\n     * Creates a period from the given millisecond duration, which is only really\n     * suitable for durations less than one day.\n     * <p>\n     * Only fields that are precise will be used.\n     * Thus the largest precise field may have a large value.\n     *\n     * @param duration  the duration, in milliseconds\n     * @param type  which set of fields this period supports, null means standard\n     * @param chrono  the chronology to use, null means ISO default\n     * @throws IllegalArgumentException if period type is invalid\n     */\n    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, duration);\n    }\n\n    /**\n     * Creates a new period based on another using the {@link ConverterManager}.\n     *\n     * @param period  the period to convert\n     * @param type  which set of fields this period supports, null means use type from object\n     * @param chrono  the chronology to use, null means ISO default\n     * @throws IllegalArgumentException if period is invalid\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected BasePeriod(Object period, PeriodType type, Chronology chrono) {\n        super();\n        PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n        type = (type == null ? converter.getPeriodType(period) : type);\n        type = checkPeriodType(type);\n        iType = type;\n        if (this instanceof ReadWritablePeriod) {\n            iValues = new int[size()];\n            chrono = DateTimeUtils.getChronology(chrono);\n            converter.setInto((ReadWritablePeriod) this, period, chrono);\n        } else {\n            iValues = new MutablePeriod(period, type, chrono).getValues();\n        }\n    }\n\n    /**\n     * Constructor used when we trust ourselves.\n     * Do not expose publically.\n     *\n     * @param values  the values to use, not null, not cloned\n     * @param type  which set of fields this period supports, not null\n     */\n    protected BasePeriod(int[] values, PeriodType type) {\n        super();\n        iType = type;\n        iValues = values;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Validates a period type, converting nulls to a default value and\n     * checking the type is suitable for this instance.\n     * \n     * @param type  the type to check, may be null\n     * @return the validated type to use, not null\n     * @throws IllegalArgumentException if the period type is invalid\n     */\n    protected PeriodType checkPeriodType(PeriodType type) {\n        return DateTimeUtils.getPeriodType(type);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the period type.\n     *\n     * @return the period type\n     */\n    public PeriodType getPeriodType() {\n        return iType;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the number of fields that this period supports.\n     *\n     * @return the number of fields supported\n     */\n    public int size() {\n        return iType.size();\n    }\n\n    /**\n     * Gets the field type at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public DurationFieldType getFieldType(int index) {\n        return iType.getFieldType(index);\n    }\n\n    /**\n     * Gets the value at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the value of the field at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public int getValue(int index) {\n        return iValues[index];\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the total millisecond duration of this period relative to a start instant.\n     * <p>\n     * This method adds the period to the specified instant in order to\n     * calculate the duration.\n     * <p>\n     * An instant must be supplied as the duration of a period varies.\n     * For example, a period of 1 month could vary between the equivalent of\n     * 28 and 31 days in milliseconds due to different length months.\n     * Similarly, a day can vary at Daylight Savings cutover, typically between\n     * 23 and 25 hours.\n     *\n     * @param startInstant  the instant to add the period to, thus obtaining the duration\n     * @return the total length of the period as a duration relative to the start instant\n     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n     */\n    public Duration toDurationFrom(ReadableInstant startInstant) {\n        long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n        long endMillis = chrono.add(this, startMillis, 1);\n        return new Duration(startMillis, endMillis);\n    }\n\n    /**\n     * Gets the total millisecond duration of this period relative to an\n     * end instant.\n     * <p>\n     * This method subtracts the period from the specified instant in order\n     * to calculate the duration.\n     * <p>\n     * An instant must be supplied as the duration of a period varies.\n     * For example, a period of 1 month could vary between the equivalent of\n     * 28 and 31 days in milliseconds due to different length months.\n     * Similarly, a day can vary at Daylight Savings cutover, typically between\n     * 23 and 25 hours.\n     *\n     * @param endInstant  the instant to subtract the period from, thus obtaining the duration\n     * @return the total length of the period as a duration relative to the end instant\n     * @throws ArithmeticException if the millis exceeds the capacity of the duration\n     */\n    public Duration toDurationTo(ReadableInstant endInstant) {\n        long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n        long startMillis = chrono.add(this, endMillis, -1);\n        return new Duration(startMillis, endMillis);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether a field type is supported, and if so adds the new value\n     * to the relevent index in the specified array.\n     * \n     * @param type  the field type\n     * @param values  the array to update\n     * @param newValue  the new value to store if successful\n     */\n    private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {\n        int index = indexOf(type);\n        if (index == -1) {\n            if (newValue != 0) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + type.getName() + \"'\");\n            }\n        } else {\n            values[index] = newValue;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets all the fields of this period from another.\n     * \n     * @param period  the period to copy from, not null\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected void setPeriod(ReadablePeriod period) {\n        if (period == null) {\n            setValues(new int[size()]);\n        } else {\n            setPeriodInternal(period);\n        }\n    }\n\n    /**\n     * Private method called from constructor.\n     */\n    private void setPeriodInternal(ReadablePeriod period) {\n        int[] newValues = new int[size()];\n        for (int i = 0, isize = period.size(); i < isize; i++) {\n            DurationFieldType type = period.getFieldType(i);\n            int value = period.getValue(i);\n            checkAndUpdate(type, newValues, value);\n        }\n        iValues = newValues;\n    }\n\n    /**\n     * Sets the eight standard the fields in one go.\n     * \n     * @param years  amount of years in this period, which must be zero if unsupported\n     * @param months  amount of months in this period, which must be zero if unsupported\n     * @param weeks  amount of weeks in this period, which must be zero if unsupported\n     * @param days  amount of days in this period, which must be zero if unsupported\n     * @param hours  amount of hours in this period, which must be zero if unsupported\n     * @param minutes  amount of minutes in this period, which must be zero if unsupported\n     * @param seconds  amount of seconds in this period, which must be zero if unsupported\n     * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected void setPeriod(int years, int months, int weeks, int days,\n                             int hours, int minutes, int seconds, int millis) {\n        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis);\n    }\n\n    /**\n     * Private method called from constructor.\n     */\n    private void setPeriodInternal(int years, int months, int weeks, int days,\n                                   int hours, int minutes, int seconds, int millis) {\n        int[] newValues = new int[size()];\n        checkAndUpdate(DurationFieldType.years(), newValues, years);\n        checkAndUpdate(DurationFieldType.months(), newValues, months);\n        checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);\n        checkAndUpdate(DurationFieldType.days(), newValues, days);\n        checkAndUpdate(DurationFieldType.hours(), newValues, hours);\n        checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n        checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n        checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n        iValues = newValues;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value of a field in this period.\n     * \n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is is null or not supported.\n     */\n    protected void setField(DurationFieldType field, int value) {\n        setFieldInto(iValues, field, value);\n    }\n\n    /**\n     * Sets the value of a field in this period.\n     * \n     * @param values  the array of values to update\n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is null or not supported.\n     */\n    protected void setFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + field + \"'\");\n            }\n        } else {\n            values[index] = value;\n        }\n    }\n\n    /**\n     * Adds the value of a field in this period.\n     * \n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is is null or not supported.\n     */\n    protected void addField(DurationFieldType field, int value) {\n        addFieldInto(iValues, field, value);\n    }\n\n    /**\n     * Adds the value of a field in this period.\n     * \n     * @param values  the array of values to update\n     * @param field  the field to set\n     * @param value  the value to set\n     * @throws IllegalArgumentException if field is is null or not supported.\n     */\n    protected void addFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + field + \"'\");\n            }\n        } else {\n            values[index] = FieldUtils.safeAdd(values[index], value);\n        }\n    }\n\n    /**\n     * Merges the fields from another period.\n     * \n     * @param period  the period to add from, not null\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected void mergePeriod(ReadablePeriod period) {\n        if (period != null) {\n            iValues = mergePeriodInto(getValues(), period);\n        }\n    }\n\n    /**\n     * Merges the fields from another period.\n     * \n     * @param values  the array of values to update\n     * @param period  the period to add from, not null\n     * @return the updated values\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected int[] mergePeriodInto(int[] values, ReadablePeriod period) {\n         for (int i = 0, isize = period.size(); i < isize; i++) {\n             DurationFieldType type = period.getFieldType(i);\n             int value = period.getValue(i);\n             checkAndUpdate(type, values, value);\n         }\n         return values;\n    }\n\n    /**\n     * Adds the fields from another period.\n     * \n     * @param period  the period to add from, not null\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected void addPeriod(ReadablePeriod period) {\n        if (period != null) {\n            iValues = addPeriodInto(getValues(), period);\n        }\n    }\n\n    /**\n     * Adds the fields from another period.\n     * \n     * @param values  the array of values to update\n     * @param period  the period to add from, not null\n     * @return the updated values\n     * @throws IllegalArgumentException if an unsupported field's value is non-zero\n     */\n    protected int[] addPeriodInto(int[] values, ReadablePeriod period) {\n         for (int i = 0, isize = period.size(); i < isize; i++) {\n             DurationFieldType type = period.getFieldType(i);\n             int value = period.getValue(i);\n             if (value != 0) {\n                 int index = indexOf(type);\n                 if (index == -1) {\n                     throw new IllegalArgumentException(\n                         \"Period does not support field '\" + type.getName() + \"'\");\n                 } else {\n                     values[index] = FieldUtils.safeAdd(getValue(index), value);\n                 }\n             }\n         }\n         return values;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the value of the field at the specifed index.\n     * \n     * @param index  the index\n     * @param value  the value to set\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected void setValue(int index, int value) {\n        iValues[index] = value;\n    }\n\n    /**\n     * Sets the values of all fields.\n     * \n     * @param values  the array of values\n     */\n    protected void setValues(int[] values) {\n        iValues = values;\n    }\n\n}\n", "review": {"response": "{\"bugs\": []}"}}