{
  "source_item_id": 8045,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:45:12.759167",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2017 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.graph;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.graph.GraphConstants.ENDPOINTS_MISMATCH;\nimport static com.google.common.graph.GraphConstants.NODE_PAIR_REMOVED_FROM_GRAPH;\nimport static com.google.common.graph.GraphConstants.NODE_REMOVED_FROM_GRAPH;\n\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterators;\nimport com.google.common.collect.Sets;\nimport com.google.common.collect.UnmodifiableIterator;\nimport com.google.common.math.IntMath;\nimport com.google.common.primitives.Ints;\nimport java.util.AbstractSet;\nimport java.util.Set;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * This class provides a skeletal implementation of {@link BaseGraph}.\n *\n * <p>The methods implemented in this class should not be overridden unless the subclass admits a\n * more efficient implementation.\n *\n * @author James Sexton\n * @param <N> Node parameter type\n */\nabstract class AbstractBaseGraph<N> implements BaseGraph<N> {\n\n  /**\n   * Returns the number of edges in this graph; used to calculate the size of {@link Graph#edges()}.\n   * This implementation requires O(|N|) time. Classes extending this one may manually keep track of\n   * the number of edges as the graph is updated, and override this method for better performance.\n   */\n  protected long edgeCount() {\n    long degreeSum = 0L;\n    for (N node : nodes()) {\n      degreeSum += degree(node);\n    }\n    // According to the degree sum formula, this is equal to twice the number of edges.\n    checkState((degreeSum & 1) == 0);\n    return degreeSum >>> 1;\n  }\n\n  /**\n   * An implementation of {@link BaseGraph#edges()} defined in terms of {@link Graph#nodes()} and\n   * {@link #successors(Object)}.\n   */\n  @Override\n  public Set<EndpointPair<N>> edges() {\n    return new AbstractSet<EndpointPair<N>>() {\n      @Override\n      public UnmodifiableIterator<EndpointPair<N>> iterator() {\n        return EndpointPairIterator.of(AbstractBaseGraph.this);\n      }\n\n      @Override\n      public int size() {\n        return Ints.saturatedCast(edgeCount());\n      }\n\n      @Override\n      public boolean remove(@Nullable Object o) {\n        throw new UnsupportedOperationException();\n      }\n\n      // Mostly safe: We check contains(u) before calling successors(u), so we perform unsafe\n      // operations only in weird cases like checking for an EndpointPair<ArrayList> in a\n      // Graph<LinkedList>.\n      @SuppressWarnings(\"unchecked\")\n      @Override\n      public boolean contains(@Nullable Object obj) {\n        if (!(obj instanceof EndpointPair)) {\n          return false;\n        }\n        EndpointPair<?> endpointPair = (EndpointPair<?>) obj;\n        return isOrderingCompatible(endpointPair)\n            && nodes().contains(endpointPair.nodeU())\n            && successors((N) endpointPair.nodeU()).contains(endpointPair.nodeV());\n      }\n    };\n  }\n\n  @Override\n  public ElementOrder<N> incidentEdgeOrder() {\n    return ElementOrder.unordered();\n  }\n\n  @Override\n  public Set<EndpointPair<N>> incidentEdges(N node) {\n    checkNotNull(node);\n    checkArgument(nodes().contains(node), \"Node %s is not an element of this graph.\", node);\n    IncidentEdgeSet<N> incident =\n        new IncidentEdgeSet<N>(this, node) {\n          @Override\n          public UnmodifiableIterator<EndpointPair<N>> iterator() {\n            if (graph.isDirected()) {\n              return Iterators.unmodifiableIterator(\n                  Iterators.concat(\n                      Iterators.transform(\n                          graph.predecessors(node).iterator(),\n                          (N predecessor) -> EndpointPair.ordered(predecessor, node)),\n                      Iterators.transform(\n                          // filter out 'node' from successors (already covered by predecessors,\n                          // above)\n                          Sets.difference(graph.successors(node), ImmutableSet.of(node)).iterator(),\n                          (N successor) -> EndpointPair.ordered(node, successor))));\n            } else {\n              return Iterators.unmodifiableIterator(\n                  Iterators.transform(\n                      graph.adjacentNodes(node).iterator(),\n                      (N adjacentNode) -> EndpointPair.unordered(node, adjacentNode)));\n            }\n          }\n        };\n    return nodeInvalidatableSet(incident, node);\n  }\n\n  @Override\n  public int degree(N node) {\n    if (isDirected()) {\n      return IntMath.saturatedAdd(predecessors(node).size(), successors(node).size());\n    } else {\n      Set<N> neighbors = adjacentNodes(node);\n      int selfLoopCount = (allowsSelfLoops() && neighbors.contains(node)) ? 1 : 0;\n      return IntMath.saturatedAdd(neighbors.size(), selfLoopCount);\n    }\n  }\n\n  @Override\n  public int inDegree(N node) {\n    return isDirected() ? predecessors(node).size() : degree(node);\n  }\n\n  @Override\n  public int outDegree(N node) {\n    return isDirected() ? successors(node).size() : degree(node);\n  }\n\n  @Override\n  public boolean hasEdgeConnecting(N nodeU, N nodeV) {\n    checkNotNull(nodeU);\n    checkNotNull(nodeV);\n    return nodes().contains(nodeU) && successors(nodeU).contains(nodeV);\n  }\n\n  @Override\n  public boolean hasEdgeConnecting(EndpointPair<N> endpoints) {\n    checkNotNull(endpoints);\n    if (!isOrderingCompatible(endpoints)) {\n      return false;\n    }\n    N nodeU = endpoints.nodeU();\n    N nodeV = endpoints.nodeV();\n    return nodes().contains(nodeU) && successors(nodeU).contains(nodeV);\n  }\n\n  /**\n   * Throws {@code IllegalArgumentException} if the ordering of {@code endpoints} is not compatible\n   * with the directionality of this graph.\n   */\n  protected final void validateEndpoints(EndpointPair<?> endpoints) {\n    checkNotNull(endpoints);\n    checkArgument(isOrderingCompatible(endpoints), ENDPOINTS_MISMATCH);\n  }\n\n  /**\n   * Returns {@code true} iff {@code endpoints}' ordering is compatible with the directionality of\n   * this graph.\n   */\n  protected final boolean isOrderingCompatible(EndpointPair<?> endpoints) {\n    return endpoints.isOrdered() == this.isDirected();\n  }\n\n  protected final <T> Set<T> nodeInvalidatableSet(Set<T> set, N node) {\n    return InvalidatableSet.of(\n        set, () -> nodes().contains(node), () -> String.format(NODE_REMOVED_FROM_GRAPH, node));\n  }\n\n  protected final <T> Set<T> nodePairInvalidatableSet(Set<T> set, N nodeU, N nodeV) {\n    return InvalidatableSet.of(\n        set,\n        () -> nodes().contains(nodeU) && nodes().contains(nodeV),\n        () -> String.format(NODE_PAIR_REMOVED_FROM_GRAPH, nodeU, nodeV));\n  }\n}\n",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The edgeCount() method does not handle the case when the graph has no nodes. This will result in an exception when trying to access the nodes() method.\",\n         \"suggested_fix\": \"Add a check at the beginning of the edgeCount() method to return 0 when the graph has no nodes.\"\n      },\n      {\n         \"explanation\": \"The incidentEdges() method does not handle the case when the node is not in the graph. This will result in an exception when trying to access the nodes() method.\",\n         \"suggested_fix\": \"Add a check at the beginning of the incidentEdges() method to return an empty set when the node is not in the graph.\"\n      },\n      {\n         \"explanation\": \"The degree() method does not handle the case when the graph has no nodes. This will result in an exception when trying to access the nodes() method.\",\n         \"suggested_fix\": \"Add a check at the beginning of the degree() method to return 0 when the graph has no nodes.\"\n      },\n      {\n         \"explanation\": \"The inDegree() and outDegree() methods do not handle the case when the node is not in the graph. This will result in an exception when trying to access the nodes() method.\",\n         \"suggested_fix\": \"Add a check at the beginning of the inDegree() and outDegree() methods to return 0 when the node is not in the graph.\"\n      },\n      {\n         \"explanation\": \"The hasEdgeConnecting() method does not handle the case when either of the nodes is not in the graph. This will result in an exception when trying to access the nodes() method.\",\n         \"suggested_fix\": \"Add a check at the beginning of the hasEdgeConnecting() method to return false when either of the nodes is not in the graph.\"\n      },\n      {\n         \"explanation\": \"The nodeInvalidatableSet() and nodePairInvalidatableSet() methods do not handle the case when the node is not in the graph. This will result in an exception when trying to access the nodes() method.\",\n         \"suggested_fix\": \"Add a check at the beginning of the nodeInvalidatableSet() and nodePairInvalidatableSet() methods to return an empty set when the node is not in the graph.\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs found, the code is well-structured and handles all edge cases.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The edgeCount() method does not handle the case when the graph has no nodes. This will result in an exception when trying to access the nodes() method.",
        "suggested_fix": "Add a check at the beginning of the edgeCount() method to return 0 when the graph has no nodes."
      },
      {
        "explanation": "The incidentEdges() method does not handle the case when the node is not in the graph. This will result in an exception when trying to access the nodes() method.",
        "suggested_fix": "Add a check at the beginning of the incidentEdges() method to return an empty set when the node is not in the graph."
      },
      {
        "explanation": "The degree() method does not handle the case when the graph has no nodes. This will result in an exception when trying to access the nodes() method.",
        "suggested_fix": "Add a check at the beginning of the degree() method to return 0 when the graph has no nodes."
      },
      {
        "explanation": "The inDegree() and outDegree() methods do not handle the case when the node is not in the graph. This will result in an exception when trying to access the nodes() method.",
        "suggested_fix": "Add a check at the beginning of the inDegree() and outDegree() methods to return 0 when the node is not in the graph."
      },
      {
        "explanation": "The hasEdgeConnecting() method does not handle the case when either of the nodes is not in the graph. This will result in an exception when trying to access the nodes() method.",
        "suggested_fix": "Add a check at the beginning of the hasEdgeConnecting() method to return false when either of the nodes is not in the graph."
      },
      {
        "explanation": "The nodeInvalidatableSet() and nodePairInvalidatableSet() methods do not handle the case when the node is not in the graph. This will result in an exception when trying to access the nodes() method.",
        "suggested_fix": "Add a check at the beginning of the nodeInvalidatableSet() and nodePairInvalidatableSet() methods to return an empty set when the node is not in the graph."
      }
    ],
    "no_bugs_reasoning": "No bugs found, the code is well-structured and handles all edge cases."
  },
  "error": null
}