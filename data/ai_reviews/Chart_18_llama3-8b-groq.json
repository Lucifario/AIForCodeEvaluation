{"sample_id": "Chart_18", "model": "llama3-8b-groq", "code_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -------------------------\n * DefaultKeyedValues2D.java\n * -------------------------\n * (C) Copyright 2002-2007, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Andreas Schroeder;\n *\n * Changes\n * -------\n * 28-Oct-2002 : Version 1 (DG);\n * 21-Jan-2003 : Updated Javadocs (DG);\n * 13-Mar-2003 : Implemented Serializable (DG);\n * 18-Aug-2003 : Implemented Cloneable (DG);\n * 31-Mar-2004 : Made the rows optionally sortable by a flag (AS);\n * 01-Apr-2004 : Implemented remove method (AS);\n * 05-Apr-2004 : Added clear() method (DG);\n * 15-Sep-2004 : Fixed clone() method (DG);\n * 12-Jan-2005 : Fixed bug in getValue() method (DG);\n * 23-Mar-2005 : Implemented PublicCloneable (DG);\n * 09-Jun-2005 : Modified getValue() method to throw exception for unknown\n *               keys (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 18-Jan-2007 : Fixed bug in getValue() method (DG);\n * 30-Mar-2007 : Fixed bug 1690654, problem with removeValue() (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 21-Nov-2007 : Fixed bug (1835955) in removeColumn(Comparable) method (DG);\n *\n */\n\npackage org.jfree.data;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PublicCloneable;\n\n/**\n * A data structure that stores zero, one or many values, where each value \n * is associated with two keys (a 'row' key and a 'column' key).  The keys \n * should be (a) instances of {@link Comparable} and (b) immutable.  \n */\npublic class DefaultKeyedValues2D implements KeyedValues2D, \n                                             PublicCloneable, Cloneable, \n                                             Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -5514169970951994748L;\n    \n    /** The row keys. */\n    private List rowKeys;\n\n    /** The column keys. */\n    private List columnKeys;\n\n    /** The row data. */\n    private List rows;\n    \n    /** If the row keys should be sorted by their comparable order. */\n    private boolean sortRowKeys;\n\n    /**\n     * Creates a new instance (initially empty).\n     */\n    public DefaultKeyedValues2D() {\n        this(false);\n    }\n\n    /**\n     * Creates a new instance (initially empty).\n     * \n     * @param sortRowKeys  if the row keys should be sorted.\n     */\n    public DefaultKeyedValues2D(boolean sortRowKeys) {\n        this.rowKeys = new java.util.ArrayList();\n        this.columnKeys = new java.util.ArrayList();\n        this.rows = new java.util.ArrayList();\n        this.sortRowKeys = sortRowKeys;\n    }\n\n    /**\n     * Returns the row count.\n     *\n     * @return The row count.\n     * \n     * @see #getColumnCount()\n     */\n    public int getRowCount() {\n        return this.rowKeys.size();\n    }\n\n    /**\n     * Returns the column count.\n     *\n     * @return The column count.\n     * \n     * @see #getRowCount()\n     */\n    public int getColumnCount() {\n        return this.columnKeys.size();\n    }\n\n    /**\n     * Returns the value for a given row and column.\n     *\n     * @param row  the row index.\n     * @param column  the column index.\n     *\n     * @return The value.\n     * \n     * @see #getValue(Comparable, Comparable)\n     */\n    public Number getValue(int row, int column) {\n        Number result = null;\n        DefaultKeyedValues rowData = (DefaultKeyedValues) this.rows.get(row);\n        if (rowData != null) {\n            Comparable columnKey = (Comparable) this.columnKeys.get(column);\n            // the row may not have an entry for this key, in which case the \n            // return value is null\n            int index = rowData.getIndex(columnKey);\n            if (index >= 0) {\n                result = rowData.getValue(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the key for a given row.\n     *\n     * @param row  the row index (in the range 0 to {@link #getRowCount()} - 1).\n     *\n     * @return The row key.\n     * \n     * @see #getRowIndex(Comparable)\n     * @see #getColumnKey(int)\n     */\n    public Comparable getRowKey(int row) {\n        return (Comparable) this.rowKeys.get(row);\n    }\n\n    /**\n     * Returns the row index for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The row index.\n     * \n     * @see #getRowKey(int)\n     * @see #getColumnIndex(Comparable)\n     */\n    public int getRowIndex(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (this.sortRowKeys) {\n            return Collections.binarySearch(this.rowKeys, key);\n        }\n        else {\n            return this.rowKeys.indexOf(key);\n        }\n    }\n\n    /**\n     * Returns the row keys in an unmodifiable list.\n     *\n     * @return The row keys.\n     * \n     * @see #getColumnKeys()\n     */\n    public List getRowKeys() {\n        return Collections.unmodifiableList(this.rowKeys);\n    }\n\n    /**\n     * Returns the key for a given column.\n     *\n     * @param column  the column (in the range 0 to {@link #getColumnCount()} \n     *     - 1).\n     *\n     * @return The key.\n     * \n     * @see #getColumnIndex(Comparable)\n     * @see #getRowKey(int)\n     */\n    public Comparable getColumnKey(int column) {\n        return (Comparable) this.columnKeys.get(column);\n    }\n\n    /**\n     * Returns the column index for a given key.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @return The column index.\n     * \n     * @see #getColumnKey(int)\n     * @see #getRowIndex(Comparable)\n     */\n    public int getColumnIndex(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        return this.columnKeys.indexOf(key);\n    }\n\n    /**\n     * Returns the column keys in an unmodifiable list.\n     *\n     * @return The column keys.\n     * \n     * @see #getRowKeys()\n     */\n    public List getColumnKeys() {\n        return Collections.unmodifiableList(this.columnKeys);\n    }\n\n    /**\n     * Returns the value for the given row and column keys.  This method will\n     * throw an {@link UnknownKeyException} if either key is not defined in the\n     * data structure.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     *\n     * @return The value (possibly <code>null</code>).\n     * \n     * @see #addValue(Number, Comparable, Comparable)\n     * @see #removeValue(Comparable, Comparable)\n     */\n    public Number getValue(Comparable rowKey, Comparable columnKey) {\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (columnKey == null) {\n            throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n        }\n        \n        // check that the column key is defined in the 2D structure\n        if (!(this.columnKeys.contains(columnKey))) {\n            throw new UnknownKeyException(\"Unrecognised columnKey: \" \n                    + columnKey);\n        }\n        \n        // now fetch the row data - need to bear in mind that the row\n        // structure may not have an entry for the column key, but that we\n        // have already checked that the key is valid for the 2D structure\n        int row = getRowIndex(rowKey);\n        if (row >= 0) {\n            DefaultKeyedValues rowData \n                = (DefaultKeyedValues) this.rows.get(row);\n            int col = rowData.getIndex(columnKey);\n            return (col >= 0 ? rowData.getValue(col) : null);\n        }\n        else {\n            throw new UnknownKeyException(\"Unrecognised rowKey: \" + rowKey);\n        }\n    }\n\n    /**\n     * Adds a value to the table.  Performs the same function as \n     * #setValue(Number, Comparable, Comparable).\n     *\n     * @param value  the value (<code>null</code> permitted).\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #setValue(Number, Comparable, Comparable)\n     * @see #removeValue(Comparable, Comparable)\n     */\n    public void addValue(Number value, Comparable rowKey, \n                         Comparable columnKey) {\n        // defer argument checking\n        setValue(value, rowKey, columnKey);\n    }\n\n    /**\n     * Adds or updates a value.\n     *\n     * @param value  the value (<code>null</code> permitted).\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #addValue(Number, Comparable, Comparable)\n     * @see #removeValue(Comparable, Comparable)\n     */\n    public void setValue(Number value, Comparable rowKey, \n                         Comparable columnKey) {\n\n        DefaultKeyedValues row;\n        int rowIndex = getRowIndex(rowKey);\n        \n        if (rowIndex >= 0) {\n            row = (DefaultKeyedValues) this.rows.get(rowIndex);\n        }\n        else {\n            row = new DefaultKeyedValues();\n            if (this.sortRowKeys) {\n                rowIndex = -rowIndex - 1;\n                this.rowKeys.add(rowIndex, rowKey);\n                this.rows.add(rowIndex, row);\n            }\n            else {\n                this.rowKeys.add(rowKey);\n                this.rows.add(row);\n            }\n        }\n        row.setValue(columnKey, value);\n        \n        int columnIndex = this.columnKeys.indexOf(columnKey);\n        if (columnIndex < 0) {\n            this.columnKeys.add(columnKey);\n        }\n    }\n\n    /**\n     * Removes a value from the table by setting it to <code>null</code>.  If\n     * all the values in the specified row and/or column are now \n     * <code>null</code>, the row and/or column is removed from the table.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @see #addValue(Number, Comparable, Comparable)\n     */\n    public void removeValue(Comparable rowKey, Comparable columnKey) {\n        setValue(null, rowKey, columnKey);\n        \n        // 1. check whether the row is now empty.\n        boolean allNull = true;\n        int rowIndex = getRowIndex(rowKey);\n        DefaultKeyedValues row = (DefaultKeyedValues) this.rows.get(rowIndex);\n\n        for (int item = 0, itemCount = row.getItemCount(); item < itemCount; \n             item++) {\n            if (row.getValue(item) != null) {\n                allNull = false;\n                break;\n            }\n        }\n        \n        if (allNull) {\n            this.rowKeys.remove(rowIndex);\n            this.rows.remove(rowIndex);\n        }\n        \n        // 2. check whether the column is now empty.\n        allNull = true;\n        //int columnIndex = getColumnIndex(columnKey);\n        \n        for (int item = 0, itemCount = this.rows.size(); item < itemCount; \n             item++) {\n            row = (DefaultKeyedValues) this.rows.get(item);\n            int columnIndex = row.getIndex(columnKey);\n            if (columnIndex >= 0 && row.getValue(columnIndex) != null) {\n                allNull = false;\n                break;\n            }\n        }\n        \n        if (allNull) {\n            for (int item = 0, itemCount = this.rows.size(); item < itemCount; \n                 item++) {\n                row = (DefaultKeyedValues) this.rows.get(item);\n                int columnIndex = row.getIndex(columnKey);\n                if (columnIndex >= 0) {\n                    row.removeValue(columnIndex);\n                }\n            }\n            this.columnKeys.remove(columnKey);\n        }\n    }\n\n    /**\n     * Removes a row.\n     *\n     * @param rowIndex  the row index.\n     * \n     * @see #removeRow(Comparable)\n     * @see #removeColumn(int)\n     */\n    public void removeRow(int rowIndex) {\n        this.rowKeys.remove(rowIndex);\n        this.rows.remove(rowIndex);\n    }\n\n    /**\n     * Removes a row.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * \n     * @see #removeRow(int)\n     * @see #removeColumn(Comparable)\n     */\n    public void removeRow(Comparable rowKey) {\n        removeRow(getRowIndex(rowKey));\n    }\n\n    /**\n     * Removes a column.\n     *\n     * @param columnIndex  the column index.\n     * \n     * @see #removeColumn(Comparable)\n     * @see #removeRow(int)\n     */\n    public void removeColumn(int columnIndex) {\n        Comparable columnKey = getColumnKey(columnIndex);\n        removeColumn(columnKey);\n    }\n\n    /**\n     * Removes a column from the table.\n     *\n     * @param columnKey  the column key (<code>null</code> not permitted).\n     * \n     * @throws UnknownKeyException if the table does not contain a column with\n     *     the specified key.\n     * @throws IllegalArgumentException if <code>columnKey</code> is \n     *     <code>null</code>.\n     * \n     * @see #removeColumn(int)\n     * @see #removeRow(Comparable)\n     */\n    public void removeColumn(Comparable columnKey) {\n        Iterator iterator = this.rows.iterator();\n        while (iterator.hasNext()) {\n            DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\n                rowData.removeValue(columnKey);\n        }\n        this.columnKeys.remove(columnKey);\n    }\n\n    /**\n     * Clears all the data and associated keys.\n     */\n    public void clear() {\n        this.rowKeys.clear();\n        this.columnKeys.clear();\n        this.rows.clear();\n    }\n    \n    /**\n     * Tests if this object is equal to another.\n     *\n     * @param o  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object o) {\n\n        if (o == null) {\n            return false;\n        }\n        if (o == this) {\n            return true;\n        }\n\n        if (!(o instanceof KeyedValues2D)) {\n            return false;\n        }\n        KeyedValues2D kv2D = (KeyedValues2D) o;\n        if (!getRowKeys().equals(kv2D.getRowKeys())) {\n            return false;\n        }\n        if (!getColumnKeys().equals(kv2D.getColumnKeys())) {\n            return false;\n        }\n        int rowCount = getRowCount();\n        if (rowCount != kv2D.getRowCount()) {\n            return false;\n        }\n\n        int colCount = getColumnCount();\n        if (colCount != kv2D.getColumnCount()) {\n            return false;\n        }\n\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < colCount; c++) {\n                Number v1 = getValue(r, c);\n                Number v2 = kv2D.getValue(r, c);\n                if (v1 == null) {\n                    if (v2 != null) {\n                        return false;\n                    }\n                }\n                else {\n                    if (!v1.equals(v2)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     * \n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = this.rowKeys.hashCode();\n        result = 29 * result + this.columnKeys.hashCode();\n        result = 29 * result + this.rows.hashCode();\n        return result;\n    }\n\n    /**\n     * Returns a clone.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  this class will not throw this \n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        DefaultKeyedValues2D clone = (DefaultKeyedValues2D) super.clone();\n        // for the keys, a shallow copy should be fine because keys\n        // should be immutable...\n        clone.columnKeys = new java.util.ArrayList(this.columnKeys);\n        clone.rowKeys = new java.util.ArrayList(this.rowKeys);\n        \n        // but the row data requires a deep copy\n        clone.rows = (List) ObjectUtilities.deepClone(this.rows);\n        return clone;\n    }\n\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"category\": \"Potential NullPointerException\",\n         \"description\": \"In the getValue() method, the rowData variable is cast to DefaultKeyedValues, but if rowData is null, this will throw a NullPointerException. However, the method does not check for null before casting.\",\n         \"line\": 83,\n         \"column\": 13\n      },\n      {\n         \"category\": \"Potential ClassCastException\",\n         \"description\": \"In the getValue() method, the columnKey variable is cast to Comparable, but if columnKey is not an instance of Comparable, this will throw a ClassCastException. However, the method does not check for this before casting.\",\n         \"line\": 86,\n         \"column\": 13\n      },\n      {\n         \"category\": \"Potential IndexOutOfBoundsException\",\n         \"description\": \"In the getValue() method, the index variable is used to access the rowData list. However, if the index is out of range, this will throw an IndexOutOfBoundsException. However, the method does not check for this before accessing the list.\",\n         \"line\": 91,\n         \"column\": 13\n      },\n      {\n         \"category\": \"Potential IllegalArgumentException\",\n         \"description\": \"In the getRowIndex() method, the key variable is checked for null, but if it is not null, the method does not check if the key is actually in the rowKeys list. If the key is not in the list, this will throw an IllegalArgumentException.\",\n         \"line\": 114,\n         \"column\": 13\n      },\n      {\n         \"category\": \"Potential IllegalArgumentException\",\n         \"description\": \"In the getRowIndex() method, the key variable is checked for null, but if it is not null, the method does not check if the key is actually in the rowKeys list. If the key is not in the list, this will throw an IllegalArgumentException.\",\n         \"line\": 121,\n         \"column\": 13\n      }\n   ]\n}"}}