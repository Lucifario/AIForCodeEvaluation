{"sample_id": "Mockito_26", "model": "qwen-coder-32b", "code_context": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@SuppressWarnings(\"unchecked\")\npublic class Primitives {\n    \n    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {\n        if(clazz.isPrimitive()) {\n            return clazz;\n        }\n        return (Class<T>) primitiveTypes.get(clazz);\n    }\n\n    public static boolean isPrimitiveWrapper(Class<?> type) {\n        return wrapperReturnValues.containsKey(type);\n    }\n\n    public static <T> T primitiveWrapperOf(Class<T> type) {\n        return (T) wrapperReturnValues.get(type);\n    }\n\n    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {\n        return (T) primitiveValues.get(primitiveType);\n    }\n    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();\n    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();\n\n    static {\n        primitiveTypes.put(Boolean.class, Boolean.TYPE);\n        primitiveTypes.put(Character.class, Character.TYPE);\n        primitiveTypes.put(Byte.class, Byte.TYPE);\n        primitiveTypes.put(Short.class, Short.TYPE);\n        primitiveTypes.put(Integer.class, Integer.TYPE);\n        primitiveTypes.put(Long.class, Long.TYPE);\n        primitiveTypes.put(Float.class, Float.TYPE);\n        primitiveTypes.put(Double.class, Double.TYPE);\n    }\n\n    static {\n        wrapperReturnValues.put(Boolean.class, false);\n        wrapperReturnValues.put(Character.class, '\\u0000');\n        wrapperReturnValues.put(Byte.class, (byte) 0);\n        wrapperReturnValues.put(Short.class, (short) 0);\n        wrapperReturnValues.put(Integer.class, 0);\n        wrapperReturnValues.put(Long.class, 0L);\n        wrapperReturnValues.put(Float.class, 0F);\n        wrapperReturnValues.put(Double.class, 0D);\n    }\n\n    static {\n        primitiveValues.put(boolean.class, false);\n        primitiveValues.put(char.class, '\\u0000');\n        primitiveValues.put(byte.class, (byte) 0);\n        primitiveValues.put(short.class, (short) 0);\n        primitiveValues.put(int.class, 0);\n        primitiveValues.put(long.class, 0L);\n        primitiveValues.put(float.class, 0F);\n        primitiveValues.put(double.class, 0);\n    }\n}", "review": {"response": "<think>\nOkay, I need to review this Java code for bugs. Let me start by reading through it carefully.\n\nFirst, the class is called Primitives, and it has several static methods dealing with primitive types and their wrappers. There are four static maps: wrapperTypes, primitiveTypes, wrapperReturnValues, and primitiveValues. The static initializers populate these maps. \n\nLooking at the first method, primitiveTypeOf. It takes a Class<T> and if it's a primitive, returns it. Otherwise, it looks up in the primitiveTypes map. Wait, the primitiveTypes map is supposed to map wrapper classes to their primitive types. So if someone passes a wrapper class like Integer.class, it returns int.class. But what if the class isn't a wrapper? Like, say, String.class? Then it would return null, but the method is supposed to return a Class<T>, which would be null. That's a possible NPE if the caller doesn't check. But maybe that's intended? The method's name suggests it's for primitives, but the code allows any class. Hmm, maybe that's a bug. But maybe the method is designed to return the primitive type if the input is a wrapper, otherwise return the class if it's already a primitive. Wait, the code checks if clazz is primitive. If yes, returns it. Otherwise, looks up in the map. But if the class is not a primitive and not a wrapper, it returns null. So for example, if you pass String.class, it would return null. So the method could return null. But the method's return type is Class<T>, which is a reference type, so returning null is possible. The caller should handle that. So maybe that's not a bug, just a possible NPE if not handled.\n\nNext, the isPrimitiveWrapper method checks if the type is a key in wrapperReturnValues. The wrapperReturnValues map has entries for the wrapper classes (like Boolean.class, etc.) and their default values. So isPrimitiveWrapper returns true for those. But wait, what about the primitive types themselves? For example, if someone passes int.class, this method would return false. But maybe that's correct, since the method is supposed to check if the type is a wrapper. So int.class is a primitive, not a wrapper. So the method is correct here.\n\nThe primitiveWrapperOf method returns the wrapper class for a given type. Wait, no, the method is called primitiveWrapperOf, but the code returns wrapperReturnValues.get(type). But wrapperReturnValues contains the default values (like false, 0, etc.), not the wrapper classes. That seems wrong. For example, if you call primitiveWrapperOf(Integer.class), you'd get 0 as an Object. But the method is supposed to return the wrapper class? Wait, no. Let me check the method's name and parameters. The method is called primitiveWrapperOf and takes a Class<T> type. The return type is T. But looking at the code, it's returning (T) wrapperReturnValues.get(type). So if the type is Integer.class, wrapperReturnValues.get(Integer.class) is 0, which is an Integer. So the method is returning the default value for the wrapper type. But the method's name is primitiveWrapperOf, which sounds like it should return the wrapper class. So there's a naming inconsistency here. That's a bug. The method's name doesn't match its purpose. It should probably be named defaultValueForWrapper or something similar, but as per the code, the method is returning the default value, not the wrapper class. So this is a bug. The method's name is misleading. Also, the parameter type is passed as a Class<T>, but the method is using it to get a default value. So for example, if someone passes Integer.class, it returns 0 (as Integer), which is correct. But the method's name is confusing.\n\nAnother thing: the primitiveTypes map is used in the primitiveTypeOf method. The static initializer for primitiveTypes adds entries like Boolean.class to Boolean.TYPE. So for example, if you pass Boolean.class (the wrapper), it returns boolean.class. That's correct. But if you pass a primitive type, the method returns it directly. So that seems okay.\n\nLooking at the static initializers. The first one initializes primitiveTypes with wrapper classes to primitives. The second one initializes wrapperReturnValues with wrapper classes to default values. The third initializes primitiveValues with primitive types to their default values. \n\nNow, the primitiveValueOrNullFor method takes a primitiveType (Class<T>) and returns the corresponding value from primitiveValues. For example, if you pass int.class, it returns 0. But if you pass a non-primitive, like String.class, it returns null. So that's okay, but again, the method could return null, which the caller needs to handle.\n\nPotential bugs:\n\n1. In the method primitiveWrapperOf, the name suggests it returns the wrapper class, but it's returning the default value. So the method's name is incorrect. That's a bug in naming.\n\n2. The wrapperReturnValues map is being used to store default values for wrapper classes. But the isPrimitiveWrapper method checks if the type is a key in wrapperReturnValues. For example, if someone passes Integer.class, isPrimitiveWrapper returns true. But if someone passes the primitive type int.class, it returns false. So the method is checking if the type is a wrapper class (like Integer.class), not if it's a wrapper type. So if you have a primitive, isPrimitiveWrapper returns false. That's correct. But perhaps the method's name is a bit ambiguous. But maybe that's intended.\n\n3. In the static initializer for primitiveValues, the entry for double.class is set to 0, but 0 is an int literal. Wait, in Java, 0 is an int. Assigning it to a double would require a cast or a widening conversion. But in the code, the value is stored as an Object. So when you put 0 into the map with key double.class, the value is an Integer 0. But when you retrieve it, you cast it to T. For example, if T is Double, then the value is Integer 0, which would be autounboxed to 0.0 when cast to Double. Wait, no. Because when you cast an Integer to Double, you can't. Wait, let's see:\n\nprimitiveValues.put(double.class, 0); \n\nHere, 0 is an int. The map is of type Map<Class<?>, Object>. So the value is stored as an Integer. When you retrieve it, you cast it to T. For example, if T is Double, then you have (Double) (Object) 0. But 0 is an Integer. So this would throw a ClassCastException at runtime. Because you can't cast an Integer to a Double. \n\nThat's a bug. The line in the static initializer for double.class is using 0, which is an int, but the key is double.class. So the value is stored as Integer, but when retrieved, it's cast to Double. That will cause a ClassCastException. Similarly, for float.class, the code uses 0F, which is a Float. That's okay. But for double.class, it's using 0, which is an int, not a Double. So that's incorrect. The correct value should be 0.0, which is a double. But in Java, 0.0 is a double literal, but when stored in a Map as an Object, it's boxed to a Double. However, in the code, the line is:\n\nprimitiveValues.put(double.class, 0);\n\nBut 0 is an int. So the code is putting an Integer into the map for the double primitive type. That's incorrect. The correct code should be 0.0, which is a double. But how to write it in Java? The code should be 0D, which is a double. Let me check the code again. \n\nLooking at the static initializer for primitiveValues:\n\nstatic {\n    primitiveValues.put(boolean.class, false);\n    primitiveValues.put(char.class, '\\u0000');\n    primitiveValues.put(byte.class, (byte) 0);\n    primitiveValues.put(short.class, (short) 0);\n    primitiveValues.put(int.class, 0);\n    primitiveValues.put(long.class, 0L);\n    primitiveValues.put(float.class, 0F);\n    primitiveValues.put(double.class, 0);\n}\n\nThe line for double.class is 0. But 0 is an int. So when this is stored in the map, it's stored as an Integer. When the code later tries to retrieve it as a Double (since the key is double.class and the method returns T which is Double for double.class), it will throw a ClassCastException when casting from Integer to Double.\n\nThis is a definite bug. The line for double.class should be 0D, which is a double literal. So the correct code is:\n\nprimitiveValues.put(double.class, 0D);\n\nSimilarly, the line for float.class uses 0F, which is correct. For double.class, using 0 is incorrect.\n\nAnother possible issue: in the method primitiveTypeOf, when the class is not a primitive, it returns (Class<T>) primitiveTypes.get(clazz). But primitiveTypes is a Map<Class<?>, Class<?>>. So if clazz is a wrapper class, like Integer.class, then primitiveTypes.get(clazz) is int.class, which is a Class<Integer.TYPE> (Class<int>). So casting to Class<T> is safe if T is the primitive type. But the method's return type is Class<T>, which is a generic. For example, if T is Integer, but the method returns a Class<T> which is int.class. But int.class is a Class<Integer.TYPE>, not a Class<Integer>. So this would cause a ClassCastException at runtime if someone tries to cast it. Wait, but the method is declared as public static <T> Class<T> primitiveTypeOf(Class<T> clazz). So for example, if you call primitiveTypeOf(Integer.class), the type parameter T is Class<Integer>, and the method returns a Class<T> which is int.class. But int.class is not a Class<Integer>, so this is an invalid cast. The cast (Class<T>) is unchecked and would result in a warning. However, the method is annotated with @SuppressWarnings(\"unchecked\"), which suppresses that warning. But this is actually a type safety issue. For example, if someone does:\n\nClass<Integer> clazz = Primitives.primitiveTypeOf(Integer.class); \n\nThis would compile, but clazz would actually be int.class, which is not a Class<Integer>. So this is a bug. The method's generic type is incorrect. The method's return type is Class<T>, but when T is a wrapper class, the method returns the corresponding primitive class. But the primitive class is not assignable to T. So this is a type mismatch. \n\nFor example, if T is Integer (Class<Integer>), the method returns int.class, which is a Class<Integer.TYPE>, not a Class<Integer>. So the cast is invalid. This is a type safety issue. The method's generic parameter is not correctly used. \n\nThis is a more subtle bug. The method is supposed to return the primitive type corresponding to the given class. But the generic type is not correctly handled. The method should probably return Class<?>, not Class<T>. But the current code uses a generic method. So this is a potential bug that could lead to incorrect usage and runtime errors.\n\nAnother possible issue: the wrapperTypes map is declared but never used. The code has:\n\nprivate static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<>();\n\nBut looking through the code, there's no reference to wrapperTypes. That's a code smell. The method primitiveTypeOf uses primitiveTypes, but wrapperTypes is not used anywhere. So that's an unused variable. That's a bug (dead code). The variable should be removed.\n\nSo to summarize the bugs:\n\n1. The method primitiveWrapperOf is named incorrectly. It returns the default value for the wrapper class, not the wrapper class itself. The method name is misleading.\n\n2. The line for double.class in the primitiveValues static initializer is using 0 (int) instead of 0D (double), leading to a ClassCastException when retrieved.\n\n3. The wrapperTypes map is declared but never used, which is dead code.\n\n4. The method primitiveTypeOf uses an unchecked cast from Class<?> to Class<T>, which is incorrect because the returned Class may not be compatible with T. For example, when T is a wrapper class and the method returns the corresponding primitive class, which is not a Class<T> but a different type. This can lead to ClassCastException at runtime if the method is used in a way that expects the returned class to be of type T.\n\nLet me check each of these points again.\n\nFor the first point: primitiveWrapperOf is called with a Class<T> type. Let's say T is Integer. So the method is called with Integer.class. The code retrieves the value from wrapperReturnValues for Integer.class, which is 0 (as Integer). So the method returns (T) 0. Since T is Integer, it's okay. But the method's name is primitiveWrapperOf, which sounds like it's returning the wrapper class, not the default value. So the method's name is incorrect. That's a naming bug.\n\nSecond, the double.class entry in primitiveValues is 0, which is an Integer. When retrieved, it's cast to T. For example, if T is Double, the code would cast the Integer 0 to Double, which is invalid. So this is a bug.\n\nThird, wrapperTypes is unused. That's a bug.\n\nFourth, the method primitiveTypeOf returns (Class<T>) primitiveTypes.get(clazz). For example, if clazz is Integer.class (T is Class<Integer>), then the method returns int.class. But int.class is a Class<Integer.TYPE>, not a Class<Integer>. So the cast is invalid. The method's generic is incorrect. This is a type safety issue.\n\nSo these are four bugs. Let me check if there are others.\n\nAnother possible issue: in the isPrimitiveWrapper method, the code checks if the type is present in wrapperReturnValues. But wrapperReturnValues contains entries for the wrapper classes (like Boolean.class, etc.), so isPrimitiveWrapper returns true for those. However, if someone passes a primitive type (e.g., int.class), isPrimitiveWrapper returns false. That's correct. But what about if someone passes a class that is not a primitive or a wrapper? Then it returns false. So that's okay. No bug here.\n\nAnother thing: in the static initializer for wrapperReturnValues, the value for Character.class is '\\u0000', which is correct. For the wrapper class Character, the default value is the zero character. That's okay.\n\nSo the main bugs are the four mentioned above.\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"line_number\": 15,\n      \"description\": \"The method 'primitiveWrapperOf' is incorrectly named and returns a default value instead of the wrapper class. This can lead to confusion as the method name suggests it should return the wrapper class type.\",\n      \"severity\": \"medium\"\n    },\n    {\n      \"line_number\": 34,\n      \"description\": \"The line for 'double.class' in the 'primitiveValues' static initializer uses '0' (an int) instead of '0D' (a double). This will cause a ClassCastException when retrieving the value as a Double.\",\n      \"severity\": \"high\"\n    },\n    {\n      \"line_number\": 20,\n      \"description\": \"The 'wrapperTypes' map is declared but never used in the code. This is dead code and should be removed.\",\n      \"severity\": \"low\"\n    },\n    {\n      \"line_number\": 12,\n      \"description\": \"The method 'primitiveTypeOf' performs an unchecked cast from 'Class<?> to Class<T>', which can result in a ClassCastException if the returned class is not compatible with the generic type T (e.g., when T is a wrapper class).\",\n      \"severity\": \"high\"\n    }\n  ]\n}\n```"}}