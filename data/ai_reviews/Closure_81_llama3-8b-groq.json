{"sample_id": "Closure_81", "model": "llama3-8b-groq", "code_context": "/*\n * Copyright 2009 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp.parsing;\n\nimport static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.ArrayLiteral;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.Assignment;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.AstNode;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.Block;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.BreakStatement;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.CatchClause;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.Comment;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.ConditionalExpression;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.ContinueStatement;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.DoLoop;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.ElementGet;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.EmptyExpression;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.ExpressionStatement;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.ForInLoop;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.ForLoop;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.FunctionCall;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.FunctionNode;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.IfStatement;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.InfixExpression;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.KeywordLiteral;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.Label;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.LabeledStatement;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.Name;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.NewExpression;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.NumberLiteral;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.ObjectLiteral;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.ObjectProperty;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.ParenthesizedExpression;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.PropertyGet;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.RegExpLiteral;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.ReturnStatement;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.Scope;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.StringLiteral;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.SwitchCase;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.SwitchStatement;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.ThrowStatement;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.TryStatement;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.UnaryExpression;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.VariableDeclaration;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.VariableInitializer;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.WhileLoop;\nimport com.google.javascript.jscomp.mozilla.rhino.ast.WithStatement;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Set;\n\n/**\n * IRFactory transforms the new AST to the old AST.\n *\n */\npublic class IRFactory {\n\n  private final String sourceString;\n  private final String sourceName;\n  private final Config config;\n  private final ErrorReporter errorReporter;\n  private final TransformDispatcher transformDispatcher;\n\n  // non-static for thread safety\n  private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n\n  // @license text gets appended onto the fileLevelJsDocBuilder as found,\n  // and stored in JSDocInfo for placeholder node.\n  Node rootNodeJsDocHolder = new Node(Token.SCRIPT);\n  Node.FileLevelJsDocBuilder fileLevelJsDocBuilder =\n      rootNodeJsDocHolder.getJsDocBuilderForNode();\n  JSDocInfo fileOverviewInfo = null;\n\n  // Use a template node for properties set on all nodes to minimize the\n  // memory footprint associated with these.\n  private Node templateNode;\n\n  // TODO(johnlenz): Consider creating a template pool for ORIGINALNAME_PROP.\n\n  private IRFactory(String sourceString,\n                    String sourceName,\n                    Config config,\n                    ErrorReporter errorReporter) {\n    this.sourceString = sourceString;\n    this.sourceName = sourceName;\n    this.config = config;\n    this.errorReporter = errorReporter;\n    this.transformDispatcher = new TransformDispatcher();\n    // The template node properties are applied to all nodes in this transform.\n    this.templateNode = createTemplateNode();\n  }\n\n  // Create a template node to use as a source of common attributes, this allows\n  // the prop structure to be shared among all the node from this source file.\n  // This reduces the cost of these properties to O(nodes) to O(files).\n  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = new Node(Token.SCRIPT);\n    templateNode.putProp(Node.SOURCENAME_PROP, sourceName);\n    return templateNode;\n  }\n\n  public static Node transformTree(AstRoot node,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(),\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == JSDOC && !comment.isParsed()) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }\n\n  private void setFileOverviewJsDoc(Node irNode) {\n    // Only after we've seen all @fileoverview entries, attach the\n    // last one to the root node, and copy the found license strings\n    // to that node.\n    irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo());\n    if (fileOverviewInfo != null) {\n      if ((irNode.getJSDocInfo() != null) &&\n          (irNode.getJSDocInfo().getLicense() != null)) {\n        fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n      }\n      irNode.setJSDocInfo(fileOverviewInfo);\n    }\n  }\n\n  private Node transformBlock(AstNode node) {\n    Node irNode = transform(node);\n    if (irNode.getType() != Token.BLOCK) {\n      if (irNode.getType() == Token.EMPTY) {\n        irNode.setType(Token.BLOCK);\n        irNode.setWasEmptyNode(true);\n      } else {\n        Node newBlock = newNode(Token.BLOCK, irNode);\n        newBlock.setLineno(irNode.getLineno());\n        newBlock.setCharno(irNode.getCharno());\n        irNode = newBlock;\n      }\n    }\n    return irNode;\n  }\n\n  /**\n   * @return true if the jsDocParser represents a fileoverview.\n   */\n  private boolean handlePossibleFileOverviewJsDoc(\n      JsDocInfoParser jsDocParser) {\n    if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n      fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n      return true;\n    }\n    return false;\n  }\n\n  private void handlePossibleFileOverviewJsDoc(Comment comment) {\n    JsDocInfoParser jsDocParser = createJsDocInfoParser(comment);\n    comment.setParsed(true);\n    handlePossibleFileOverviewJsDoc(jsDocParser);\n  }\n\n  private JSDocInfo handleJsDoc(AstNode node) {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment);\n      comment.setParsed(true);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        return jsDocParser.retrieveAndResetParsedJSDocInfo();\n      }\n    }\n    return null;\n  }\n\n  private Node transform(AstNode node) {\n    JSDocInfo jsDocInfo = handleJsDoc(node);\n    Node irNode = justTransform(node);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n\n    // If we have a named function, set the position to that of the name.\n    if (irNode.getType() == Token.FUNCTION &&\n        irNode.getFirstChild().getLineno() != -1) {\n      irNode.setLineno(irNode.getFirstChild().getLineno());\n      irNode.setCharno(irNode.getFirstChild().getCharno());\n    } else {\n      if (irNode.getLineno() == -1) {\n        // If we didn't already set the line, then set it now.  This avoids\n        // cases like ParenthesizedExpression where we just return a previous\n        // node, but don't want the new node to get its parent's line number.\n        int lineno = node.getLineno();\n        irNode.setLineno(lineno);\n        int charno = position2charno(node.getAbsolutePosition());\n        irNode.setCharno(charno);\n      }\n    }\n    return irNode;\n  }\n\n  /**\n   * Creates a JsDocInfoParser and parses the JsDoc string.\n   *\n   * Used both for handling individual JSDoc comments and for handling\n   * file-level JSDoc comments (@fileoverview and @license).\n   *\n   * @param node The JsDoc Comment node to parse.\n   * @return A JSDocInfoParser. Will contain either fileoverview jsdoc, or\n   *     normal jsdoc, or no jsdoc (if the method parses to the wrong level).\n   */\n  private JsDocInfoParser createJsDocInfoParser(Comment node) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          sourceName,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }\n\n  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf('\\n', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }\n\n  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }\n\n  private class TransformDispatcher extends TypeSafeDispatcher<Node> {\n    private Node processGeneric(\n        com.google.javascript.jscomp.mozilla.rhino.Node n) {\n      Node node = newNode(transformTokenType(n.getType()));\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      return node;\n    }\n\n    /**\n     * Transforms the given node and then sets its type to Token.STRING if it\n     * was Token.NAME. If its type was already Token.STRING, then quotes it.\n     * Used for properties, as the old AST uses String tokens, while the new one\n     * uses Name tokens for unquoted strings. For example, in\n     * var o = {'a' : 1, b: 2};\n     * the string 'a' is quoted, while the name b is turned into a string, but\n     * unquoted.\n     */\n    private Node transformAsString(AstNode n) {\n      Node ret = transform(n);\n      if (ret.getType() == Token.STRING) {\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      } else if (ret.getType() == Token.NAME) {\n        ret.setType(Token.STRING);\n      }\n      return ret;\n    }\n\n    @Override\n    Node processArrayLiteral(ArrayLiteral literalNode) {\n      if (literalNode.isDestructuring()) {\n        reportDestructuringAssign(literalNode);\n      }\n\n      Node node = newNode(Token.ARRAYLIT);\n      int skipCount = 0;\n      for (AstNode child : literalNode.getElements()) {\n        Node c = transform(child);\n        if (c.getType() == Token.EMPTY) {\n          skipCount++;\n        }\n        node.addChildToBack(c);\n\n      }\n      if (skipCount > 0) {\n        int[] skipIndexes = new int[skipCount];\n        int i = 0;\n        int j = 0;\n        for (Node child : node.children()) {\n          if (child.getType() == Token.EMPTY) {\n            node.removeChild(child);\n            skipIndexes[j] = i;\n            j++;\n          }\n          i++;\n        }\n        node.putProp(Node.SKIP_INDEXES_PROP, skipIndexes);\n      }\n      return node;\n    }\n\n    @Override\n    Node processAssignment(Assignment assignmentNode) {\n      Node assign = processInfixExpression(assignmentNode);\n      Node target = assign.getFirstChild();\n      if (!validAssignmentTarget(target)) {\n        errorReporter.error(\n          \"invalid assignment target\",\n          sourceName,\n          target.getLineno(), \"\", 0);\n      }\n      return assign;\n    }\n\n    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = newNode(Token.SCRIPT);\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      parseDirectives(node);\n      return node;\n    }\n\n    /**\n     * Parse the directives, encode them in the AST, and remove their nodes.\n     *\n     * For information on ES5 directives, see section 14.1 of\n     * Ecma-262, Edition 5.\n     *\n     * It would be nice if Rhino would eventually take care of this for\n     * us, but right now their directive-processing is a one-off.\n     */\n    private void parseDirectives(Node node) {\n      // Remove all the directives, and encode them in the AST.\n      Set<String> directives = null;\n      while (isDirective(node.getFirstChild())) {\n        String directive = node.removeFirstChild().getFirstChild().getString();\n        if (directives == null) {\n          directives = Sets.newHashSet(directive);\n        } else {\n          directives.add(directive);\n        }\n      }\n\n      if (directives != null) {\n        node.setDirectives(directives);\n      }\n    }\n\n    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n          n.getFirstChild().getType() == Token.STRING &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n\n    @Override\n    Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }\n\n    @Override\n    Node processBreakStatement(BreakStatement statementNode) {\n      Node node = newNode(Token.BREAK);\n      if (statementNode.getBreakLabel() != null) {\n        Node labelName = transform(statementNode.getBreakLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    @Override\n    Node processCatchClause(CatchClause clauseNode) {\n      AstNode catchVar = clauseNode.getVarName();\n      Node node = newNode(Token.CATCH, transform(catchVar));\n      if (clauseNode.getCatchCondition() != null) {\n        errorReporter.error(\n            \"Catch clauses are not supported\",\n            sourceName,\n            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n      }\n      node.addChildToBack(transformBlock(clauseNode.getBody()));\n      return node;\n    }\n\n    @Override\n    Node processConditionalExpression(ConditionalExpression exprNode) {\n      return newNode(\n          Token.HOOK,\n          transform(exprNode.getTestExpression()),\n          transform(exprNode.getTrueExpression()),\n          transform(exprNode.getFalseExpression()));\n    }\n\n    @Override\n    Node processContinueStatement(ContinueStatement statementNode) {\n      Node node = newNode(Token.CONTINUE);\n      if (statementNode.getLabel() != null) {\n        Node labelName = transform(statementNode.getLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    @Override\n    Node processDoLoop(DoLoop loopNode) {\n      return newNode(\n          Token.DO,\n          transformBlock(loopNode.getBody()),\n          transform(loopNode.getCondition()));\n    }\n\n    @Override\n    Node processElementGet(ElementGet getNode) {\n      return newNode(\n          Token.GETELEM,\n          transform(getNode.getTarget()),\n          transform(getNode.getElement()));\n    }\n\n    @Override\n    Node processEmptyExpression(EmptyExpression exprNode) {\n      Node node = newNode(Token.EMPTY);\n      return node;\n    }\n\n    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }\n\n    @Override\n    Node processForInLoop(ForInLoop loopNode) {\n      return newNode(\n          Token.FOR,\n          transform(loopNode.getIterator()),\n          transform(loopNode.getIteratedObject()),\n          transformBlock(loopNode.getBody()));\n    }\n\n    @Override\n    Node processForLoop(ForLoop loopNode) {\n      Node node = newNode(\n          Token.FOR,\n          transform(loopNode.getInitializer()),\n          transform(loopNode.getCondition()),\n          transform(loopNode.getIncrement()));\n      node.addChildToBack(transformBlock(loopNode.getBody()));\n      return node;\n    }\n\n    @Override\n    Node processFunctionCall(FunctionCall callNode) {\n      Node node = newNode(transformTokenType(callNode.getType()),\n                           transform(callNode.getTarget()));\n      for (AstNode child : callNode.getArguments()) {\n        node.addChildToBack(transform(child));\n      }\n\n      int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n      node.setLineno(callNode.getLineno());\n      node.setCharno(position2charno(leftParamPos));\n      return node;\n    }\n\n    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.LP);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }\n\n    @Override\n    Node processIfStatement(IfStatement statementNode) {\n      Node node = newNode(Token.IF);\n      node.addChildToBack(transform(statementNode.getCondition()));\n      node.addChildToBack(transformBlock(statementNode.getThenPart()));\n      if (statementNode.getElsePart() != null) {\n        node.addChildToBack(transformBlock(statementNode.getElsePart()));\n      }\n      return node;\n    }\n\n    @Override\n    Node processInfixExpression(InfixExpression exprNode) {\n      Node n =  newNode(\n          transformTokenType(exprNode.getType()),\n          transform(exprNode.getLeft()),\n          transform(exprNode.getRight()));\n      // Set the line number here so we can fine-tune it in ways transform\n      // doesn't do.\n      n.setLineno(exprNode.getLineno());\n      // Position in new ASTNode is to start of expression, but old-fashioned\n      // line numbers from Node reference the operator token.  Add the offset\n      // to the operator to get the correct character number.\n      n.setCharno(position2charno(exprNode.getAbsolutePosition() +\n          exprNode.getOperatorPosition()));\n      return n;\n    }\n\n    @Override\n    Node processKeywordLiteral(KeywordLiteral literalNode) {\n      return newNode(transformTokenType(literalNode.getType()));\n    }\n\n    @Override\n    Node processLabel(Label labelNode) {\n      return newStringNode(Token.LABEL_NAME, labelNode.getName());\n    }\n\n    @Override\n    Node processLabeledStatement(LabeledStatement statementNode) {\n      Node node = newNode(Token.LABEL);\n      Node prev = null;\n      Node cur = node;\n      for (Label label : statementNode.getLabels()) {\n        if (prev != null) {\n          prev.addChildToBack(cur);\n        }\n        cur.addChildToBack(transform(label));\n\n        cur.setLineno(label.getLineno());\n        int clauseAbsolutePosition =\n            position2charno(label.getAbsolutePosition());\n        cur.setCharno(clauseAbsolutePosition);\n\n        prev = cur;\n        cur = newNode(Token.LABEL);\n      }\n      prev.addChildToBack(transform(statementNode.getStatement()));\n      return node;\n    }\n\n    @Override\n    Node processName(Name nameNode) {\n      return newStringNode(Token.NAME, nameNode.getIdentifier());\n    }\n\n    @Override\n    Node processNewExpression(NewExpression exprNode) {\n      return processFunctionCall(exprNode);\n    }\n\n    @Override\n    Node processNumberLiteral(NumberLiteral literalNode) {\n      return newNumberNode(literalNode.getNumber());\n    }\n\n    @Override\n    Node processObjectLiteral(ObjectLiteral literalNode) {\n      if (literalNode.isDestructuring()) {\n        reportDestructuringAssign(literalNode);\n      }\n\n      Node node = newNode(Token.OBJECTLIT);\n      for (ObjectProperty el : literalNode.getElements()) {\n        if (!config.acceptES5) {\n          if (el.isGetter()) {\n            reportGetter(el);\n            continue;\n          } else if (el.isSetter()) {\n            reportSetter(el);\n            continue;\n          }\n        }\n\n        Node key = transformAsString(el.getLeft());\n        Node value = transform(el.getRight());\n        if (el.isGetter()) {\n          key.setType(Token.GET);\n          Preconditions.checkState(value.getType() == Token.FUNCTION);\n          if (getFnParamNode(value).hasChildren()) {\n            reportGetterParam(el.getLeft());\n          }\n        } else if (el.isSetter()) {\n          key.setType(Token.SET);\n          Preconditions.checkState(value.getType() == Token.FUNCTION);\n          if (!getFnParamNode(value).hasOneChild()) {\n            reportSetterParam(el.getLeft());\n          }\n        }\n        key.addChildToFront(value);\n        node.addChildToBack(key);\n      }\n      return node;\n    }\n\n    /**\n     * @param fnNode The function.\n     * @return The Node containing the Function parameters.\n     */\n   Node getFnParamNode(Node fnNode) {\n     // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]\n     Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);\n     return fnNode.getFirstChild().getNext();\n   }\n\n    @Override\n    Node processObjectProperty(ObjectProperty propertyNode) {\n      return processInfixExpression(propertyNode);\n    }\n\n    @Override\n    Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n      Node node = transform(exprNode.getExpression());\n      node.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE);\n      return node;\n    }\n\n    @Override\n    Node processPropertyGet(PropertyGet getNode) {\n      return newNode(\n          Token.GETPROP,\n          transform(getNode.getTarget()),\n          transformAsString(getNode.getProperty()));\n    }\n\n    @Override\n    Node processRegExpLiteral(RegExpLiteral literalNode) {\n      Node literalStringNode = newStringNode(literalNode.getValue());\n      // assume it's on the same line.\n      literalStringNode.setLineno(literalNode.getLineno());\n      Node node = newNode(Token.REGEXP, literalStringNode);\n      String flags = literalNode.getFlags();\n      if (flags != null && !flags.isEmpty()) {\n        Node flagsNode = newStringNode(flags);\n        // Assume the flags are on the same line as the literal node.\n        flagsNode.setLineno(literalNode.getLineno());\n        node.addChildToBack(flagsNode);\n      }\n      return node;\n    }\n\n    @Override\n    Node processReturnStatement(ReturnStatement statementNode) {\n      Node node = newNode(Token.RETURN);\n      if (statementNode.getReturnValue() != null) {\n        node.addChildToBack(transform(statementNode.getReturnValue()));\n      }\n      return node;\n    }\n\n    @Override\n    Node processScope(Scope scopeNode) {\n      return processGeneric(scopeNode);\n    }\n\n    @Override\n    Node processStringLiteral(StringLiteral literalNode) {\n      Node n = newStringNode(literalNode.getValue());\n      return n;\n    }\n\n    @Override\n    Node processSwitchCase(SwitchCase caseNode) {\n      Node node;\n      if (caseNode.isDefault()) {\n        node = newNode(Token.DEFAULT);\n      } else {\n        AstNode expr = caseNode.getExpression();\n        node = newNode(Token.CASE, transform(expr));\n      }\n      Node block = newNode(Token.BLOCK);\n      block.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n      block.setLineno(caseNode.getLineno());\n      block.setCharno(position2charno(caseNode.getAbsolutePosition()));\n      if (caseNode.getStatements() != null) {\n        for (AstNode child : caseNode.getStatements()) {\n          block.addChildToBack(transform(child));\n        }\n      }\n      node.addChildToBack(block);\n      return node;\n    }\n\n    @Override\n    Node processSwitchStatement(SwitchStatement statementNode) {\n      Node node = newNode(Token.SWITCH,\n          transform(statementNode.getExpression()));\n      for (AstNode child : statementNode.getCases()) {\n        node.addChildToBack(transform(child));\n      }\n      return node;\n    }\n\n    @Override\n    Node processThrowStatement(ThrowStatement statementNode) {\n      return newNode(Token.THROW,\n          transform(statementNode.getExpression()));\n    }\n\n    @Override\n    Node processTryStatement(TryStatement statementNode) {\n      Node node = newNode(Token.TRY,\n          transformBlock(statementNode.getTryBlock()));\n      Node block = newNode(Token.BLOCK);\n      boolean lineSet = false;\n\n      for (CatchClause cc : statementNode.getCatchClauses()) {\n        // Mark the enclosing block at the same line as the first catch\n        // clause.\n        if (lineSet == false) {\n            block.setLineno(cc.getLineno());\n            lineSet = true;\n        }\n        block.addChildToBack(transform(cc));\n      }\n      node.addChildToBack(block);\n\n      AstNode finallyBlock = statementNode.getFinallyBlock();\n      if (finallyBlock != null) {\n        node.addChildToBack(transformBlock(finallyBlock));\n      }\n\n      // If we didn't set the line on the catch clause, then\n      // we've got an empty catch clause.  Set its line to be the same\n      // as the finally block (to match Old Rhino's behavior.)\n      if ((lineSet == false) && (finallyBlock != null)) {\n        block.setLineno(finallyBlock.getLineno());\n      }\n\n      return node;\n    }\n\n    @Override\n    Node processUnaryExpression(UnaryExpression exprNode) {\n      int type = transformTokenType(exprNode.getType());\n      Node operand = transform(exprNode.getOperand());\n      if (type == Token.NEG && operand.getType() == Token.NUMBER) {\n        operand.setDouble(-operand.getDouble());\n        return operand;\n      } else {\n        if (type == Token.INC || type == Token.DEC) {\n          if (!validAssignmentTarget(operand)) {\n            String msg = (type == Token.INC)\n                ? \"invalid increment target\"\n                : \"invalid decrement target\";\n            errorReporter.error(\n              msg,\n              sourceName,\n              operand.getLineno(), \"\", 0);\n          }\n        }\n\n        Node node = newNode(type, operand);\n        if (exprNode.isPostfix()) {\n          node.putBooleanProp(Node.INCRDECR_PROP, true);\n        }\n        return node;\n      }\n    }\n\n    private boolean validAssignmentTarget(Node target) {\n      switch (target.getType()) {\n        case Token.NAME:\n        case Token.GETPROP:\n        case Token.GETELEM:\n          return true;\n      }\n      return false;\n    }\n\n    @Override\n    Node processVariableDeclaration(VariableDeclaration declarationNode) {\n      if (!config.acceptConstKeyword && declarationNode.getType() ==\n          com.google.javascript.jscomp.mozilla.rhino.Token.CONST) {\n        processIllegalToken(declarationNode);\n      }\n\n      Node node = newNode(Token.VAR);\n      for (VariableInitializer child : declarationNode.getVariables()) {\n        node.addChildToBack(transform(child));\n      }\n      return node;\n    }\n\n    @Override\n    Node processVariableInitializer(VariableInitializer initializerNode) {\n      Node node = transform(initializerNode.getTarget());\n      if (initializerNode.getInitializer() != null) {\n        node.addChildToBack(transform(initializerNode.getInitializer()));\n        node.setLineno(node.getLineno());\n      }\n      return node;\n    }\n\n    @Override\n    Node processWhileLoop(WhileLoop loopNode) {\n      return newNode(\n          Token.WHILE,\n          transform(loopNode.getCondition()),\n          transformBlock(loopNode.getBody()));\n    }\n\n    @Override\n    Node processWithStatement(WithStatement statementNode) {\n      return newNode(\n          Token.WITH,\n          transform(statementNode.getExpression()),\n          transformBlock(statementNode.getStatement()));\n    }\n\n    @Override\n    Node processIllegalToken(AstNode node) {\n      errorReporter.error(\n          \"Unsupported syntax: \" +\n          com.google.javascript.jscomp.mozilla.rhino.Token.typeToName(\n              node.getType()),\n          sourceName,\n          node.getLineno(), \"\", 0);\n      return newNode(Token.EMPTY);\n    }\n\n    void reportDestructuringAssign(AstNode node) {\n      errorReporter.error(\n          \"destructuring assignment forbidden\",\n          sourceName,\n          node.getLineno(), \"\", 0);\n    }\n\n    void reportGetter(AstNode node) {\n      errorReporter.error(\n          \"getters are not supported in Internet Explorer\",\n          sourceName,\n          node.getLineno(), \"\", 0);\n    }\n\n    void reportSetter(AstNode node) {\n      errorReporter.error(\n          \"setters are not supported in Internet Explorer\",\n          sourceName,\n          node.getLineno(), \"\", 0);\n    }\n\n    void reportGetterParam(AstNode node) {\n      errorReporter.error(\n          \"getters may not have parameters\",\n          sourceName,\n          node.getLineno(), \"\", 0);\n    }\n\n    void reportSetterParam(AstNode node) {\n      errorReporter.error(\n          \"setters must have exactly one parameter\",\n          sourceName,\n          node.getLineno(), \"\", 0);\n    }\n  }\n\n  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR:\n        return Token.ERROR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EOF:\n        return Token.EOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EOL:\n        return Token.EOL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH:\n        return Token.ENTERWITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH:\n        return Token.LEAVEWITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO:\n        return Token.GOTO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ:\n        return Token.IFEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE:\n        return Token.IFNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME:\n        return Token.SETNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NE:\n        return Token.NE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LT:\n        return Token.LT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LE:\n        return Token.LE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GT:\n        return Token.GT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GE:\n        return Token.GE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.POS:\n        return Token.POS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP:\n        return Token.SETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM:\n        return Token.SETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME:\n        return Token.BINDNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW:\n        return Token.RETHROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IN:\n        return Token.IN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD:\n        return Token.LOCAL_LOAD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR:\n        return Token.GETVAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR:\n        return Token.SETVAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE:\n        return Token.CATCH_SCOPE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS:\n        return Token.ENUM_INIT_KEYS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES:\n        return Token.ENUM_INIT_VALUES;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT:\n        return Token.ENUM_NEXT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID:\n        return Token.ENUM_ID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN:\n        return Token.THISFN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT:\n        return Token.RETURN_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF:\n        return Token.GET_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF:\n        return Token.SET_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF:\n        return Token.DEL_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL:\n        return Token.REF_CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL:\n        return Token.REF_SPECIAL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE:\n        return Token.DEFAULTNAMESPACE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT:\n        return Token.ESCXMLTEXT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR:\n        return Token.ESCXMLATTR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER:\n        return Token.REF_MEMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER:\n        return Token.REF_NS_MEMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME:\n        return Token.REF_NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME:\n        return Token.REF_NS_NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRY:\n        return Token.TRY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI:\n        return Token.SEMI;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LB:\n        return Token.LB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RB:\n        return Token.RB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LC:\n        return Token.LC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RC:\n        return Token.RC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LP:\n        return Token.LP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RP:\n        return Token.RP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLON:\n        return Token.COLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OR:\n        return Token.OR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.AND:\n        return Token.AND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INC:\n        return Token.INC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOT:\n        return Token.DOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT:\n        return Token.EXPORT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT:\n        return Token.IMPORT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IF:\n        return Token.IF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE:\n        return Token.ELSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT:\n        return Token.DEFAULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DO:\n        return Token.DO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY:\n        return Token.FINALLY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED:\n        return Token.RESERVED;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET:\n        return Token.TARGET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP:\n        return Token.LOOP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID:\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.JSR:\n        return Token.JSR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME:\n        return Token.TYPEOFNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK:\n        return Token.USE_STACK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP:\n        return Token.SETPROP_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP:\n        return Token.SETELEM_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK:\n        return Token.LOCAL_BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP:\n        return Token.SET_REF_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT:\n        return Token.DOTDOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON:\n        return Token.COLONCOLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XML:\n        return Token.XML;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY:\n        return Token.DOTQUERY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR:\n        return Token.XMLATTR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND:\n        return Token.XMLEND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT:\n        return Token.TO_OBJECT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE:\n        return Token.TO_DOUBLE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET:\n        return Token.GET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET:\n        return Token.SET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST:\n        return Token.SETCONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }\n\n  // Simple helper to create nodes and set the initial node properties.\n  private Node newNode(int type) {\n    return new Node(type).clonePropsFrom(templateNode);\n  }\n\n  private Node newNode(int type, Node child1) {\n    return new Node(type, child1).clonePropsFrom(templateNode);\n  }\n\n  private Node newNode(int type, Node child1, Node child2) {\n    return new Node(type, child1, child2).clonePropsFrom(templateNode);\n  }\n\n  private Node newNode(int type, Node child1, Node child2, Node child3) {\n    return new Node(type, child1, child2, child3).clonePropsFrom(templateNode);\n  }\n\n  private Node newStringNode(String value) {\n    return Node.newString(value).clonePropsFrom(templateNode);\n  }\n\n  private Node newStringNode(int type, String value) {\n    return Node.newString(type, value).clonePropsFrom(templateNode);\n  }\n\n  private Node newNumberNode(Double value) {\n    return Node.newNumber(value).clonePropsFrom(templateNode);\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"message\": \"The IRFactory class has a private constructor, but it's not clear why it's not public. This might make it difficult to instantiate the class from other parts of the codebase.\",\n         \"type\": \"design flaw\",\n         \"severity\": \"low\"\n      },\n      {\n         \"message\": \"The ALLOWED_DIRECTIVES set is not thread-safe. It should be synchronized or made final to prevent concurrent modifications.\",\n         \"type\": \"thread safety\",\n         \"severity\": \"medium\"\n      },\n      {\n         \"message\": \"The createTemplateNode method is not thread-safe. It should be synchronized or made final to prevent concurrent modifications.\",\n         \"type\": \"thread safety\",\n         \"severity\": \"medium\"\n      },\n      {\n         \"message\": \"The IRFactory class has a lot of instance variables. This might make it difficult to reason about the class's behavior and might lead to bugs.\",\n         \"type\": \"complexity\",\n         \"severity\": \"high\"\n      },\n      {\n         \"message\": \"The IRFactory class uses a lot of internal APIs. This might make it difficult to understand the class's behavior and might lead to bugs.\",\n         \"type\": \"complexity\",\n         \"severity\": \"high\"\n      }\n   ]\n}"}}