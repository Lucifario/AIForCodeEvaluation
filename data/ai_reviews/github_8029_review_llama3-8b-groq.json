{
  "source_item_id": 8029,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:47:25.783274",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkPositionIndexes;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.J2ktIncompatible;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.CharBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Provides utility methods for working with character streams.\n *\n * @author Chris Nokleberg\n * @author Bin Zhu\n * @author Colin Decker\n * @since 1.0\n */\n@J2ktIncompatible\n@GwtIncompatible\npublic final class CharStreams {\n\n  // 2K chars (4K bytes)\n  private static final int DEFAULT_BUF_SIZE = 0x800;\n\n  /** Creates a new {@code CharBuffer} for buffering reads or writes. */\n  static CharBuffer createBuffer() {\n    return CharBuffer.allocate(DEFAULT_BUF_SIZE);\n  }\n\n  private CharStreams() {}\n\n  /**\n   * Copies all characters between the {@link Readable} and {@link Appendable} objects. Does not\n   * close or flush either object.\n   *\n   * @param from the object to read from\n   * @param to the object to write to\n   * @return the number of characters copied\n   * @throws IOException if an I/O error occurs\n   */\n  @CanIgnoreReturnValue\n  public static long copy(Readable from, Appendable to) throws IOException {\n    // The most common case is that from is a Reader (like InputStreamReader or StringReader) so\n    // take advantage of that.\n    if (from instanceof Reader) {\n      // optimize for common output types which are optimized to deal with char[]\n      if (to instanceof StringBuilder) {\n        return copyReaderToBuilder((Reader) from, (StringBuilder) to);\n      } else {\n        return copyReaderToWriter((Reader) from, asWriter(to));\n      }\n    }\n\n    checkNotNull(from);\n    checkNotNull(to);\n    long total = 0;\n    CharBuffer buf = createBuffer();\n    while (from.read(buf) != -1) {\n      Java8Compatibility.flip(buf);\n      to.append(buf);\n      total += buf.remaining();\n      Java8Compatibility.clear(buf);\n    }\n    return total;\n  }\n\n  // TODO(lukes): consider allowing callers to pass in a buffer to use, some callers would be able\n  // to reuse buffers, others would be able to size them more appropriately than the constant\n  // defaults\n\n  /**\n   * Copies all characters between the {@link Reader} and {@link StringBuilder} objects. Does not\n   * close or flush the reader.\n   *\n   * <p>This is identical to {@link #copy(Readable, Appendable)} but optimized for these specific\n   * types. CharBuffer has poor performance when being written into or read out of so round tripping\n   * all the bytes through the buffer takes a long time. With these specialized types we can just\n   * use a char array.\n   *\n   * @param from the object to read from\n   * @param to the object to write to\n   * @return the number of characters copied\n   * @throws IOException if an I/O error occurs\n   */\n  @CanIgnoreReturnValue\n  static long copyReaderToBuilder(Reader from, StringBuilder to) throws IOException {\n    checkNotNull(from);\n    checkNotNull(to);\n    char[] buf = new char[DEFAULT_BUF_SIZE];\n    int nRead;\n    long total = 0;\n    while ((nRead = from.read(buf)) != -1) {\n      to.append(buf, 0, nRead);\n      total += nRead;\n    }\n    return total;\n  }\n\n  /**\n   * Copies all characters between the {@link Reader} and {@link Writer} objects. Does not close or\n   * flush the reader or writer.\n   *\n   * <p>This is identical to {@link #copy(Readable, Appendable)} but optimized for these specific\n   * types. CharBuffer has poor performance when being written into or read out of so round tripping\n   * all the bytes through the buffer takes a long time. With these specialized types we can just\n   * use a char array.\n   *\n   * @param from the object to read from\n   * @param to the object to write to\n   * @return the number of characters copied\n   * @throws IOException if an I/O error occurs\n   */\n  @CanIgnoreReturnValue\n  static long copyReaderToWriter(Reader from, Writer to) throws IOException {\n    checkNotNull(from);\n    checkNotNull(to);\n    char[] buf = new char[DEFAULT_BUF_SIZE];\n    int nRead;\n    long total = 0;\n    while ((nRead = from.read(buf)) != -1) {\n      to.write(buf, 0, nRead);\n      total += nRead;\n    }\n    return total;\n  }\n\n  /**\n   * Reads all characters from a {@link Readable} object into a {@link String}. Does not close the\n   * {@code Readable}.\n   *\n   * @param r the object to read from\n   * @return a string containing all the characters\n   * @throws IOException if an I/O error occurs\n   */\n  public static String toString(Readable r) throws IOException {\n    return toStringBuilder(r).toString();\n  }\n\n  /**\n   * Reads all characters from a {@link Readable} object into a new {@link StringBuilder} instance.\n   * Does not close the {@code Readable}.\n   *\n   * @param r the object to read from\n   * @return a {@link StringBuilder} containing all the characters\n   * @throws IOException if an I/O error occurs\n   */\n  private static StringBuilder toStringBuilder(Readable r) throws IOException {\n    StringBuilder sb = new StringBuilder();\n    if (r instanceof Reader) {\n      copyReaderToBuilder((Reader) r, sb);\n    } else {\n      copy(r, sb);\n    }\n    return sb;\n  }\n\n  /**\n   * Reads all of the lines from a {@link Readable} object. The lines do not include\n   * line-termination characters, but do include other leading and trailing whitespace.\n   *\n   * <p>Does not close the {@code Readable}. If reading files or resources you should use the {@link\n   * Files#readLines} and {@link Resources#readLines} methods.\n   *\n   * @param r the object to read from\n   * @return a mutable {@link List} containing all the lines\n   * @throws IOException if an I/O error occurs\n   */\n  public static List<String> readLines(Readable r) throws IOException {\n    List<String> result = new ArrayList<>();\n    LineReader lineReader = new LineReader(r);\n    String line;\n    while ((line = lineReader.readLine()) != null) {\n      result.add(line);\n    }\n    return result;\n  }\n\n  /**\n   * Streams lines from a {@link Readable} object, stopping when the processor returns {@code false}\n   * or all lines have been read and returning the result produced by the processor. Does not close\n   * {@code readable}. Note that this method may not fully consume the contents of {@code readable}\n   * if the processor stops processing early.\n   *\n   * @throws IOException if an I/O error occurs\n   * @since 14.0\n   */\n  @CanIgnoreReturnValue // some processors won't return a useful result\n  @ParametricNullness\n  public static <T extends @Nullable Object> T readLines(\n      Readable readable, LineProcessor<T> processor) throws IOException {\n    checkNotNull(readable);\n    checkNotNull(processor);\n\n    LineReader lineReader = new LineReader(readable);\n    String line;\n    while ((line = lineReader.readLine()) != null) {\n      if (!processor.processLine(line)) {\n        break;\n      }\n    }\n    return processor.getResult();\n  }\n\n  /**\n   * Reads and discards data from the given {@code Readable} until the end of the stream is reached.\n   * Returns the total number of chars read. Does not close the stream.\n   *\n   * @since 20.0\n   */\n  @CanIgnoreReturnValu",
  "raw_llm_output": null,
  "parsed_llm_output": null,
  "error": "No response from LLM llama3-8b-groq"
}