{"sample_id": "Math_101", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.complex;\n\nimport java.io.Serializable;\nimport java.text.FieldPosition;\nimport java.text.Format;\nimport java.text.NumberFormat;\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.Locale;\n\n/**\n * Formats a Complex number in cartesian format \"Re(c) + Im(c)i\".  'i' can\n * be replaced with 'j', and the number format for both real and imaginary parts\n * can be configured.\n *\n * @author Apache Software Foundation\n * @version $Revision$ $Date$\n */\npublic class ComplexFormat extends Format implements Serializable {\n    \n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6337346779577272306L;\n    \n    /** The default imaginary character. */\n    private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\";\n    \n    /** The notation used to signify the imaginary part of the complex number. */\n    private String imaginaryCharacter;\n    \n    /** The format used for the imaginary part. */\n    private NumberFormat imaginaryFormat;\n\n    /** The format used for the real part. */\n    private NumberFormat realFormat;\n    \n    /**\n     * Create an instance with the default imaginary character, 'i', and the\n     * default number format for both real and imaginary parts.\n     */\n    public ComplexFormat() {\n        this(DEFAULT_IMAGINARY_CHARACTER, getDefaultNumberFormat());\n    }\n\n    /**\n     * Create an instance with a custom number format for both real and\n     * imaginary parts.\n     * @param format the custom format for both real and imaginary parts.\n     */\n    public ComplexFormat(NumberFormat format) {\n        this(DEFAULT_IMAGINARY_CHARACTER, format);\n    }\n    \n    /**\n     * Create an instance with a custom number format for the real part and a\n     * custom number format for the imaginary part.\n     * @param realFormat the custom format for the real part.\n     * @param imaginaryFormat the custom format for the imaginary part.\n     */\n    public ComplexFormat(NumberFormat realFormat,\n            NumberFormat imaginaryFormat) {\n        this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);\n    }\n    \n    /**\n     * Create an instance with a custom imaginary character, and the default\n     * number format for both real and imaginary parts.\n     * @param imaginaryCharacter The custom imaginary character.\n     */\n    public ComplexFormat(String imaginaryCharacter) {\n        this(imaginaryCharacter, getDefaultNumberFormat());\n    }\n    \n    /**\n     * Create an instance with a custom imaginary character, and a custom number\n     * format for both real and imaginary parts.\n     * @param imaginaryCharacter The custom imaginary character.\n     * @param format the custom format for both real and imaginary parts.\n     */\n    public ComplexFormat(String imaginaryCharacter, NumberFormat format) {\n        this(imaginaryCharacter, format, (NumberFormat)format.clone());\n    }\n    \n    /**\n     * Create an instance with a custom imaginary character, a custom number\n     * format for the real part, and a custom number format for the imaginary\n     * part.\n     * @param imaginaryCharacter The custom imaginary character.\n     * @param realFormat the custom format for the real part.\n     * @param imaginaryFormat the custom format for the imaginary part.\n     */\n    public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat,\n            NumberFormat imaginaryFormat) {\n        super();\n        setImaginaryCharacter(imaginaryCharacter);\n        setImaginaryFormat(imaginaryFormat);\n        setRealFormat(realFormat);\n    }\n\n    /**\n     * This static method calls formatComplex() on a default instance of\n     * ComplexFormat.\n     *\n     * @param c Complex object to format\n     * @return A formatted number in the form \"Re(c) + Im(c)i\"\n     */\n    public static String formatComplex( Complex c ) {\n        return getInstance().format( c );\n    }\n    \n    /**\n     * Formats a {@link Complex} object to produce a string.\n     *\n     * @param complex the object to format.\n     * @param toAppendTo where the text is to be appended\n     * @param pos On input: an alignment field, if desired. On output: the\n     *            offsets of the alignment field\n     * @return the value passed in as toAppendTo.\n     */\n    public StringBuffer format(Complex complex, StringBuffer toAppendTo,\n            FieldPosition pos) {\n        \n        pos.setBeginIndex(0);\n        pos.setEndIndex(0);\n\n        // format real\n        double re = complex.getReal();\n        formatDouble(re, getRealFormat(), toAppendTo, pos);\n        \n        // format sign and imaginary\n        double im = complex.getImaginary();\n        if (im < 0.0) {\n            toAppendTo.append(\" - \");\n            formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);\n            toAppendTo.append(getImaginaryCharacter());\n        } else if (im > 0.0 || Double.isNaN(im)) {\n            toAppendTo.append(\" + \");\n            formatDouble(im, getImaginaryFormat(), toAppendTo, pos);\n            toAppendTo.append(getImaginaryCharacter());\n        }\n        \n        return toAppendTo;\n    }\n    \n    /**\n     * Formats a object to produce a string.  <code>obj</code> must be either a \n     * {@link Complex} object or a {@link Number} object.  Any other type of\n     * object will result in an {@link IllegalArgumentException} being thrown.\n     *\n     * @param obj the object to format.\n     * @param toAppendTo where the text is to be appended\n     * @param pos On input: an alignment field, if desired. On output: the\n     *            offsets of the alignment field\n     * @return the value passed in as toAppendTo.\n     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n     */\n    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n            FieldPosition pos) {\n        \n        StringBuffer ret = null;\n        \n        if (obj instanceof Complex) {\n            ret = format( (Complex)obj, toAppendTo, pos);\n        } else if (obj instanceof Number) {\n            ret = format( new Complex(((Number)obj).doubleValue(), 0.0),\n                toAppendTo, pos);\n        } else { \n            throw new IllegalArgumentException(\n                \"Cannot format given Object as a Date\");\n        }\n        \n        return ret;\n    }\n\n    /**\n     * Formats a double value to produce a string.  In general, the value is\n     * formatted using the formatting rules of <code>format</code>.  There are\n     * three exceptions to this:\n     * <ol>\n     * <li>NaN is formatted as '(NaN)'</li>\n     * <li>Positive infinity is formatted as '(Infinity)'</li>\n     * <li>Negative infinity is formatted as '(-Infinity)'</li>\n     * </ol>\n     *\n     * @param value the double to format.\n     * @param format the format used.\n     * @param toAppendTo where the text is to be appended\n     * @param pos On input: an alignment field, if desired. On output: the\n     *            offsets of the alignment field\n     * @return the value passed in as toAppendTo.\n     */\n    private StringBuffer formatDouble(double value, NumberFormat format,\n            StringBuffer toAppendTo, FieldPosition pos) {\n        if( Double.isNaN(value) || Double.isInfinite(value) ) {\n            toAppendTo.append('(');\n            toAppendTo.append(value);\n            toAppendTo.append(')');\n        } else {\n            format.format(value, toAppendTo, pos);\n        }\n        return toAppendTo;\n    }\n    \n    /**\n     * Get the set of locales for which complex formats are available.  This\n     * is the same set as the {@link NumberFormat} set. \n     * @return available complex format locales.\n     */\n    public static Locale[] getAvailableLocales() {\n        return NumberFormat.getAvailableLocales();\n    }\n    \n    /**\n     * Create a default number format.  The default number format is based on\n     * {@link NumberFormat#getInstance()} with the only customizing is the\n     * maximum number of fraction digits, which is set to 2.  \n     * @return the default number format.\n     */\n    private static NumberFormat getDefaultNumberFormat() {\n        return getDefaultNumberFormat(Locale.getDefault());\n    }\n    \n    /**\n     * Create a default number format.  The default number format is based on\n     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n     * customizing is the maximum number of fraction digits, which is set to 2.  \n     * @param locale the specific locale used by the format.\n     * @return the default number format specific to the given locale.\n     */\n    private static NumberFormat getDefaultNumberFormat(Locale locale) {\n        NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(2);\n        return nf;\n    }\n    \n    /**\n     * Access the imaginaryCharacter.\n     * @return the imaginaryCharacter.\n     */\n    public String getImaginaryCharacter() {\n        return imaginaryCharacter;\n    }\n    \n    /**\n     * Access the imaginaryFormat.\n     * @return the imaginaryFormat.\n     */\n    public NumberFormat getImaginaryFormat() {\n        return imaginaryFormat;\n    }\n    \n    /**\n     * Returns the default complex format for the current locale.\n     * @return the default complex format.\n     */\n    public static ComplexFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }\n    \n    /**\n     * Returns the default complex format for the given locale.\n     * @param locale the specific locale used by the format.\n     * @return the complex format specific to the given locale.\n     */\n    public static ComplexFormat getInstance(Locale locale) {\n        NumberFormat f = getDefaultNumberFormat(locale);\n        return new ComplexFormat(f);\n    }\n    \n    /**\n     * Access the realFormat.\n     * @return the realFormat.\n     */\n    public NumberFormat getRealFormat() {\n        return realFormat;\n    }\n\n    /**\n     * Parses a string to produce a {@link Complex} object.\n     *\n     * @param source the string to parse\n     * @return the parsed {@link Complex} object.\n     * @exception ParseException if the beginning of the specified string\n     *            cannot be parsed.\n     */\n    public Complex parse(String source) throws ParseException {\n        ParsePosition parsePosition = new ParsePosition(0);\n        Complex result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new ParseException(\"Unparseable complex number: \\\"\" + source +\n                \"\\\"\", parsePosition.getErrorIndex());\n        }\n        return result;\n    }\n    \n    /**\n     * Parses a string to produce a {@link Complex} object.\n     *\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed {@link Complex} object.\n     */\n    public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse real\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            // invalid real number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse sign\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse imaginary\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            // invalid imaginary number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse imaginary character\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            // set index back to initial, error index should be the start index\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n     \n    /**\n     * Parses <code>source</code> until a non-whitespace character is found.\n     *\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n     *        holds the index of the next non-whitespace character.\n     */\n    private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {\n        parseNextCharacter(source, pos);\n        pos.setIndex(pos.getIndex() - 1);\n    }\n\n    /**\n     * Parses <code>source</code> until a non-whitespace character is found.\n     *\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the first non-whitespace character.\n     */\n    private char parseNextCharacter(String source, ParsePosition pos) {\n         int index = pos.getIndex();\n         int n = source.length();\n         char ret = 0;\n\n         if (index < n) {\n             char c;\n             do {\n                 c = source.charAt(index++);\n             } while (Character.isWhitespace(c) && index < n);\n             pos.setIndex(index);\n         \n             if (index < n) {\n                 ret = c;\n             }\n         }\n         \n         return ret;\n    }\n    \n    /**\n     * Parses <code>source</code> for a special double values.  These values\n     * include Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n     *\n     * @param source the string to parse\n     * @param value the special value to parse.\n     * @param pos input/ouput parsing parameter.\n     * @return the special number.\n     */\n    private Number parseNumber(String source, double value, ParsePosition pos) {\n        Number ret = null;\n        \n        StringBuffer sb = new StringBuffer();\n        sb.append('(');\n        sb.append(value);\n        sb.append(')');\n        \n        int n = sb.length();\n        int startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (endIndex < source.length()) {\n            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n                ret = new Double(value);\n                pos.setIndex(endIndex);\n            }\n        }\n        \n        return ret;\n    }\n    \n    /**\n     * Parses <code>source</code> for a number.  This method can parse normal,\n     * numeric values as well as special values.  These special values include\n     * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n     *\n     * @param source the string to parse\n     * @param format the number format used to parse normal, numeric values.\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed number.\n     */\n    private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {\n        int startIndex = pos.getIndex();\n        Number number = format.parse(source, pos);\n        int endIndex = pos.getIndex();\n        \n        // check for error parsing number\n        if (startIndex == endIndex) {\n            // try parsing special numbers\n            double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};\n            for (int i = 0; i < special.length; ++i) {\n                number = parseNumber(source, special[i], pos);\n                if (number != null) {\n                    break;\n                }\n            }\n        }\n        \n        return number;\n    }\n\n    /**\n     * Parses a string to produce a object.\n     *\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed object.\n     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n     */\n    public Object parseObject(String source, ParsePosition pos) {\n        return parse(source, pos);\n    }\n    /**\n     * Modify the imaginaryCharacter.\n     * @param imaginaryCharacter The new imaginaryCharacter value.\n     * @throws IllegalArgumentException if <code>imaginaryCharacter</code> is\n     *         <code>null</code> or an empty string.\n     */\n    public void setImaginaryCharacter(String imaginaryCharacter) {\n        if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {\n            throw new IllegalArgumentException(\n                \"imaginaryCharacter must be a non-empty string.\");\n        }\n        this.imaginaryCharacter = imaginaryCharacter;\n    }\n    \n    /**\n     * Modify the imaginaryFormat.\n     * @param imaginaryFormat The new imaginaryFormat value.\n     * @throws IllegalArgumentException if <code>imaginaryFormat</code> is\n     *         <code>null</code>.\n     */\n    public void setImaginaryFormat(NumberFormat imaginaryFormat) {\n        if (imaginaryFormat == null) {\n            throw new IllegalArgumentException(\n                \"imaginaryFormat can not be null.\");\n        }\n        this.imaginaryFormat = imaginaryFormat;\n    }\n    \n    /**\n     * Modify the realFormat.\n     * @param realFormat The new realFormat value.\n     * @throws IllegalArgumentException if <code>realFormat</code> is\n     *         <code>null</code>.\n     */\n    public void setRealFormat(NumberFormat realFormat) {\n        if (realFormat == null) {\n            throw new IllegalArgumentException(\n                \"realFormat can not be null.\");\n        }\n        this.realFormat = realFormat;\n    }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"description\": \"In the formatComplex method, the getInstance() method is called without checking if the instance has been initialized. If the instance has not been initialized, a NullPointerException will be thrown.\",\n         \"location\": \"ComplexFormat.formatComplex(Complex c)\"\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"description\": \"In the format method, the getRealFormat() and getImaginaryFormat() methods are called without checking if the formats have been initialized. If the formats have not been initialized, a NullPointerException will be thrown.\",\n         \"location\": \"ComplexFormat.format(Complex complex, StringBuffer toAppendTo, FieldPosition pos)\"\n      },\n      {\n         \"type\": \"Potential ArithmeticException\",\n         \"description\": \"In the format method, the formatDouble method is called with a negative number. If the number format does not support negative numbers, an ArithmeticException will be thrown.\",\n         \"location\": \"ComplexFormat.format(Complex complex, StringBuffer toAppendTo, FieldPosition pos)\"\n      },\n      {\n         \"type\": \"Potential ClassCastException\",\n         \"description\": \"In the ComplexFormat constructor, the format parameter is cast to NumberFormat without checking if it is actually a NumberFormat instance. If it is not a NumberFormat instance, a ClassCastException will be thrown.\",\n         \"location\": \"ComplexFormat(NumberFormat format)\"\n      },\n      {\n         \"type\": \"Potential ClassCastException\",\n         \"description\": \"In the ComplexFormat constructor, the imaginaryFormat parameter is cast to NumberFormat without checking if it is actually a NumberFormat instance. If it is not a NumberFormat instance, a ClassCastException will be thrown.\",\n         \"location\": \"ComplexFormat(String imaginaryCharacter, NumberFormat realFormat, NumberFormat imaginaryFormat)\"\n      },\n      {\n         \"type\": \"Potential ClassCastException\",\n         \"description\": \"In the ComplexFormat constructor, the format parameter is cast to NumberFormat without checking if it is actually a NumberFormat instance. If it is not a NumberFormat instance, a ClassCastException will be thrown.\",\n         \"location\": \"ComplexFormat(String imaginaryCharacter, NumberFormat format)\"\n      }\n   ]\n}"}}