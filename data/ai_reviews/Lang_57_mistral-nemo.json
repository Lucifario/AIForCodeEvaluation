{"sample_id": "Lang_57", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * <p>Operations to assist when working with a {@link Locale}.</p>\n *\n * <p>This class tries to handle <code>null</code> input gracefully.\n * An exception will not be thrown for a <code>null</code> input.\n * Each method documents its behaviour in more detail.</p>\n *\n * @author Stephen Colebourne\n * @since 2.2\n * @version $Id$\n */\npublic class LocaleUtils {\n\n    /** Unmodifiable list of available locales. */\n    private static final List cAvailableLocaleList;\n    /** Unmodifiable set of available locales. */\n    private static Set cAvailableLocaleSet;\n    /** Unmodifiable map of language locales by country. */\n    private static final Map cLanguagesByCountry = Collections.synchronizedMap(new HashMap());\n    /** Unmodifiable map of country locales by language. */\n    private static final Map cCountriesByLanguage = Collections.synchronizedMap(new HashMap());\n    static {\n        List list = Arrays.asList(Locale.getAvailableLocales());\n        cAvailableLocaleList = Collections.unmodifiableList(list);\n    }\n\n    /**\n     * <p><code>LocaleUtils</code> instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as <code>LocaleUtils.toLocale(\"en_GB\");</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public LocaleUtils() {\n      super();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Converts a String to a Locale.</p>\n     *\n     * <p>This method takes the string format of a locale and creates the\n     * locale object from it.</p>\n     *\n     * <pre>\n     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n     * </pre>\n     *\n     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n     *\n     * <p>This method validates the input strictly.\n     * The language code must be lowercase.\n     * The country code must be uppercase.\n     * The separator must be an underscore.\n     * The length must be correct.\n     * </p>\n     *\n     * @param str  the locale String to convert, null returns null\n     * @return a Locale, null if null input\n     * @throws IllegalArgumentException if the string is an invalid format\n     */\n    public static Locale toLocale(String str) {\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len != 2 && len != 5 && len < 7) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch0 = str.charAt(0);\n        char ch1 = str.charAt(1);\n        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 2) {\n            return new Locale(str, \"\");\n        } else {\n            if (str.charAt(2) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 5) {\n                return new Locale(str.substring(0, 2), str.substring(3, 5));\n            } else {\n                if (str.charAt(5) != '_') {\n                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n                }\n                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\",\"CA\",\"xxx\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\")]\n     * </pre>\n     *\n     * @param locale  the locale to start from\n     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n     */\n    public static List localeLookupList(Locale locale) {\n        return localeLookupList(locale, locale);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\"]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n     */\n    public static List localeLookupList(Locale locale, Locale defaultLocale) {\n        List list = new ArrayList(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (list.contains(defaultLocale) == false) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains an unmodifiable list of installed locales.</p>\n     * \n     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n     * It is more efficient, as the JDK method must create a new array each\n     * time it is called.</p>\n     *\n     * @return the unmodifiable list of available locales\n     */\n    public static List availableLocaleList() {\n        return cAvailableLocaleList;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains an unmodifiable set of installed locales.</p>\n     * \n     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n     * It is more efficient, as the JDK method must create a new array each\n     * time it is called.</p>\n     *\n     * @return the unmodifiable set of available locales\n     */\n    public static Set availableLocaleSet() {\n        Set set = cAvailableLocaleSet;\n        if (set == null) {\n            set = new HashSet(availableLocaleList());\n            set = Collections.unmodifiableSet(set);\n            cAvailableLocaleSet = set;\n        }\n        return set;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */\n    public static boolean isAvailableLocale(Locale locale) {\n        return cAvailableLocaleSet.contains(locale);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains the list of languages supported for a given country.</p>\n     *\n     * <p>This method takes a country code and searches to find the\n     * languages available for that country. Variant locales are removed.</p>\n     *\n     * @param countryCode  the 2 letter country code, null returns empty\n     * @return an unmodifiable List of Locale objects, never null\n     */\n    public static List languagesByCountry(String countryCode) {\n        List langs = (List) cLanguagesByCountry.get(countryCode);  //syncd\n        if (langs == null) {\n            if (countryCode != null) {\n                langs = new ArrayList();\n                List locales = availableLocaleList();\n                for (int i = 0; i < locales.size(); i++) {\n                    Locale locale = (Locale) locales.get(i);\n                    if (countryCode.equals(locale.getCountry()) &&\n                            locale.getVariant().length() == 0) {\n                        langs.add(locale);\n                    }\n                }\n                langs = Collections.unmodifiableList(langs);\n            } else {\n                langs = Collections.EMPTY_LIST;\n            }\n            cLanguagesByCountry.put(countryCode, langs);  //syncd\n        }\n        return langs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains the list of countries supported for a given language.</p>\n     * \n     * <p>This method takes a language code and searches to find the\n     * countries available for that language. Variant locales are removed.</p>\n     *\n     * @param languageCode  the 2 letter language code, null returns empty\n     * @return an unmodifiable List of Locale objects, never null\n     */\n    public static List countriesByLanguage(String languageCode) {\n        List countries = (List) cCountriesByLanguage.get(languageCode);  //syncd\n        if (countries == null) {\n            if (languageCode != null) {\n                countries = new ArrayList();\n                List locales = availableLocaleList();\n                for (int i = 0; i < locales.size(); i++) {\n                    Locale locale = (Locale) locales.get(i);\n                    if (languageCode.equals(locale.getLanguage()) &&\n                            locale.getCountry().length() != 0 &&\n                            locale.getVariant().length() == 0) {\n                        countries.add(locale);\n                    }\n                }\n                countries = Collections.unmodifiableList(countries);\n            } else {\n                countries = Collections.EMPTY_LIST;\n            }\n            cCountriesByLanguage.put(languageCode, countries);  //syncd\n        }\n        return countries;\n    }\n\n}\n", "review": {"response": "[{\"code\": \"Invalid locale format: fr_CA_xxx\", \"message\": \"Invalid locale format: fr_CA_xxx\"}, {\"code\": \"Invalid locale format: en_GB_xxx\", \"message\": \"Invalid locale format: en_GB_xxx\"}, {\"code\": \"Invalid locale format: fr_CA\", \"message\": \"Invalid locale format: fr_CA\"}, {\"code\": \"Invalid locale format: en\", \"message\": \"Invalid locale format: en\"}, {\"code\": \"Invalid locale format: en_GB\", \"message\": \"Invalid locale format: en_GB\"}, {\"code\": \"Invalid locale format: fr\", \"message\": \"Invalid locale format: fr\"}]"}}