{"sample_id": "Closure_37", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.rhino.InputId;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n\n/**\n * Nodetraversal allows an iteration through the nodes in the parse tree,\n * and facilitates the optimizations on the parse tree.\n *\n */\npublic class NodeTraversal {\n  // Package protected for tests\n  private final AbstractCompiler compiler;\n  private final Callback callback;\n\n  /** Contains the current node*/\n  private Node curNode;\n\n  public static final DiagnosticType NODE_TRAVERSAL_ERROR =\n      DiagnosticType.error(\"JSC_NODE_TRAVERSAL_ERROR\", \"{0}\");\n\n  /**\n   * Stack containing the Scopes that have been created. The Scope objects\n   * are lazily created; so the {@code scopeRoots} stack contains the\n   * Nodes for all Scopes that have not been created yet.\n   */\n  private final Deque<Scope> scopes = new ArrayDeque<Scope>();\n\n  /**\n   * A stack of scope roots. All scopes that have not been created\n   * are represented in this Deque.\n   */\n  private final Deque<Node> scopeRoots = new ArrayDeque<Node>();\n\n\n  /**\n   * Stack of control flow graphs (CFG). There is one CFG per scope. CFGs\n   * are lazily populated: elements are {@code null} until requested by\n   * {@link #getControlFlowGraph()}. Note that {@link ArrayDeque} does not allow\n   * {@code null} elements, so {@link LinkedList} is used instead.\n   */\n  Deque<ControlFlowGraph<Node>> cfgs = new LinkedList<ControlFlowGraph<Node>>();\n\n  /** The current source file name */\n  private String sourceName;\n\n  /** The current input */\n  private InputId inputId;\n\n  /** The scope creator */\n  private ScopeCreator scopeCreator;\n\n  /** Possible callback for scope entry and exist **/\n  private ScopedCallback scopeCallback;\n\n  /**\n   * Callback\n   */\n  public interface Callback {\n    /**\n     * <p>Visits a node in pre order (before visiting its children) and decides\n     * whether this node's children should be traversed. If children are\n     * traversed, they will be visited by\n     * {@link #visit(NodeTraversal, Node, Node)} in post order.</p>\n     * <p>Implementations can have side effects (e.g. modifying the parse\n     * tree).</p>\n     * @return whether the children of this node should be visited\n     */\n    boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent);\n\n    /**\n     * <p>Visits a node in post order (after its children have been visited).\n     * A node is visited only if all its parents should be traversed\n     * ({@link #shouldTraverse(NodeTraversal, Node, Node)}).</p>\n     * <p>Implementations can have side effects (e.g. modifying the parse\n     * tree).</p>\n     */\n    void visit(NodeTraversal t, Node n, Node parent);\n  }\n\n  /**\n   * Callback that also knows about scope changes\n   */\n  public interface ScopedCallback extends Callback {\n\n    /**\n     * Called immediately after entering a new scope. The new scope can\n     * be accessed through t.getScope()\n     */\n    void enterScope(NodeTraversal t);\n\n    /**\n     * Called immediately before exiting a scope. The ending scope can\n     * be accessed through t.getScope()\n     */\n    void exitScope(NodeTraversal t);\n  }\n\n  /**\n   * Abstract callback to visit all nodes in post order.\n   */\n  public abstract static class AbstractPostOrderCallback implements Callback {\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }\n  }\n\n  /**\n   * Abstract scoped callback to visit all nodes in post order.\n   */\n  public abstract static class AbstractScopedCallback\n      implements ScopedCallback {\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }\n\n    @Override\n    public void enterScope(NodeTraversal t) {}\n\n    @Override\n    public void exitScope(NodeTraversal t) {}\n  }\n\n  /**\n   * Abstract callback to visit all nodes but not traverse into function\n   * bodies.\n   */\n  public abstract static class AbstractShallowCallback implements Callback {\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      // We do want to traverse the name of a named function, but we don't\n      // want to traverse the arguments or body.\n      return parent == null || !parent.isFunction() ||\n          n == parent.getFirstChild();\n    }\n  }\n\n  /**\n   * Abstract callback to visit all structure and statement nodes but doesn't\n   * traverse into functions or expressions.\n   */\n  public abstract static class AbstractShallowStatementCallback\n      implements Callback {\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return parent == null || NodeUtil.isControlStructure(parent)\n         || NodeUtil.isStatementBlock(parent);\n    }\n  }\n\n  /**\n   * Abstract callback to visit a pruned set of nodes.\n   */\n  public abstract static class AbstractNodeTypePruningCallback\n        implements Callback {\n    private final Set<Integer> nodeTypes;\n    private final boolean include;\n\n    /**\n     * Creates an abstract pruned callback.\n     * @param nodeTypes the nodes to include in the traversal\n     */\n    public AbstractNodeTypePruningCallback(Set<Integer> nodeTypes) {\n      this(nodeTypes, true);\n    }\n\n    /**\n     * Creates an abstract pruned callback.\n     * @param nodeTypes the nodes to include/exclude in the traversal\n     * @param include whether to include or exclude the nodes in the traversal\n     */\n    public AbstractNodeTypePruningCallback(Set<Integer> nodeTypes,\n          boolean include) {\n      this.nodeTypes = nodeTypes;\n      this.include = include;\n    }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return include == nodeTypes.contains(n.getType());\n    }\n  }\n\n  /**\n   * Creates a node traversal using the specified callback interface.\n   */\n  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }\n\n  /**\n   * Creates a node traversal using the specified callback interface\n   * and the scope creator.\n   */\n  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.inputId = null;\n    this.sourceName = \"\";\n    this.scopeCreator = scopeCreator;\n  }\n\n  private void throwUnexpectedException(Exception unexpectedException) {\n    // If there's an unexpected exception, try to get the\n    // line number of the code that caused it.\n    String message = unexpectedException.getMessage();\n\n    // TODO(user): It is possible to get more information if curNode or\n    // its parent is missing. We still have the scope stack in which it is still\n    // very useful to find out at least which function caused the exception.\n    if (inputId != null) {\n      message =\n          unexpectedException.getMessage() + \"\\n\" +\n          formatNodeContext(\"Node\", curNode) +\n          (curNode == null ?\n              \"\" :\n              formatNodeContext(\"Parent\", curNode.getParent()));\n    }\n    compiler.throwInternalError(message, unexpectedException);\n  }\n\n  private String formatNodeContext(String label, Node n) {\n    if (n == null) {\n      return \"  \" + label + \": NULL\";\n    }\n    return \"  \" + label + \"(\" + n.toString(false, false, false) + \"): \"\n        + formatNodePosition(n);\n  }\n\n  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }\n\n  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }\n\n  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }\n\n  private static final String MISSING_SOURCE = \"[source unknown]\";\n\n  private String formatNodePosition(Node n) {\n    if (n == null) {\n      return MISSING_SOURCE + \"\\n\";\n    }\n\n    int lineNumber = n.getLineno();\n    int columnNumber = n.getCharno();\n    String src = compiler.getSourceLine(sourceName, lineNumber);\n    if (src == null) {\n      src = MISSING_SOURCE;\n    }\n    return sourceName + \":\" + lineNumber + \":\" + columnNumber + \"\\n\"\n        + src + \"\\n\";\n  }\n\n  /**\n   * Traverses a parse tree recursively with a scope, starting with the given\n   * root. This should only be used in the global scope. Otherwise, use\n   * {@link #traverseAtScope}.\n   */\n  void traverseWithScope(Node root, Scope s) {\n    Preconditions.checkState(s.isGlobal());\n\n    inputId = null;\n    sourceName = \"\";\n    curNode = root;\n    pushScope(s);\n    traverseBranch(root, null);\n    popScope();\n  }\n\n  /**\n   * Traverses a parse tree recursively with a scope, starting at that scope's\n   * root.\n   */\n  void traverseAtScope(Scope s) {\n    Node n = s.getRootNode();\n    if (n.isFunction()) {\n      // We need to do some extra magic to make sure that the scope doesn't\n      // get re-created when we dive into the function.\n      if (inputId == null) {\n        inputId = NodeUtil.getInputId(n);\n      }\n      sourceName = getSourceName(n);\n      curNode = n;\n      pushScope(s);\n\n      Node args = n.getFirstChild().getNext();\n      Node body = args.getNext();\n      traverseBranch(args, n);\n      traverseBranch(body, n);\n\n      popScope();\n    } else {\n      traverseWithScope(n, s);\n    }\n  }\n\n  /**\n   * Traverses an inner node recursively with a refined scope. An inner node may\n   * be any node with a non {@code null} parent (i.e. all nodes except the\n   * root).\n   *\n   * @param node the node to traverse\n   * @param parent the node's parent, it may be not be {@code null}\n   * @param refinedScope the refined scope of the scope currently at the top of\n   *     the scope stack or in trivial cases that very scope or {@code null}\n   */\n  protected void traverseInnerNode(Node node, Node parent, Scope refinedScope) {\n    Preconditions.checkNotNull(parent);\n    if (refinedScope != null && getScope() != refinedScope) {\n      curNode = node;\n      pushScope(refinedScope);\n      traverseBranch(node, parent);\n      popScope();\n    } else {\n      traverseBranch(node, parent);\n    }\n  }\n\n  /**\n   * Gets the compiler.\n   */\n  public Compiler getCompiler() {\n    // TODO(nicksantos): Remove this type cast. This is just temporary\n    // while refactoring.\n    return (Compiler) compiler;\n  }\n\n  /**\n   * Gets the current line number, or zero if it cannot be determined. The line\n   * number is retrieved lazily as a running time optimization.\n   */\n  public int getLineNumber() {\n    Node cur = curNode;\n    while (cur != null) {\n      int line = cur.getLineno();\n      if (line >=0) {\n        return line;\n      }\n      cur = cur.getParent();\n    }\n    return 0;\n  }\n\n  /**\n   * Gets the current input source name.\n   *\n   * @return A string that may be empty, but not null\n   */\n  public String getSourceName() {\n    return sourceName;\n  }\n\n  /**\n   * Gets the current input source.\n   */\n  public CompilerInput getInput() {\n    return compiler.getInput(inputId);\n  }\n\n  /**\n   * Gets the current input module.\n   */\n  public JSModule getModule() {\n    CompilerInput input = getInput();\n    return input == null ? null : input.getModule();\n  }\n\n  /** Returns the node currently being traversed. */\n  public Node getCurrentNode() {\n    return curNode;\n  }\n\n  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }\n\n  /**\n   * Traverses a list of node trees.\n   */\n  public static void traverseRoots(\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverseRoots(roots);\n  }\n\n  public static void traverseRoots(\n      AbstractCompiler compiler, Callback cb, Node ... roots) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverseRoots(roots);\n  }\n\n  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }\n\n  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());\n    traverseBranch(body, n);\n\n    popScope();\n  }\n\n  /** Examines the functions stack for the last instance of a function node. */\n  @SuppressWarnings(\"unchecked\")\n  public Node getEnclosingFunction() {\n    if (scopes.size() + scopeRoots.size() < 2) {\n      return null;\n    } else {\n      if (scopeRoots.isEmpty()) {\n        return scopes.peek().getRootNode();\n      } else {\n        return scopeRoots.peek();\n      }\n    }\n  }\n\n  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }\n\n  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Scope s) {\n    Preconditions.checkState(curNode != null);\n    scopes.push(s);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }\n\n  /** Pops back to the previous scope (e.g. when leaving a function). */\n  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }\n\n  /** Gets the current scope. */\n  public Scope getScope() {\n    Scope scope = scopes.isEmpty() ? null : scopes.peek();\n    if (scopeRoots.isEmpty()) {\n      return scope;\n    }\n\n    Iterator<Node> it = scopeRoots.descendingIterator();\n    while (it.hasNext()) {\n      scope = scopeCreator.createScope(it.next(), scope);\n      scopes.push(scope);\n    }\n    scopeRoots.clear();\n\n    return scope;\n  }\n\n  /** Gets the control flow graph for the current JS scope. */\n  public ControlFlowGraph<Node> getControlFlowGraph() {\n    if (cfgs.peek() == null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n      cfa.process(null, getScopeRoot());\n      cfgs.pop();\n      cfgs.push(cfa.getCfg());\n    }\n    return cfgs.peek();\n  }\n\n  /** Returns the current scope's root. */\n  public Node getScopeRoot() {\n    if (scopeRoots.isEmpty()) {\n      return scopes.peek().getRootNode();\n    } else {\n      return scopeRoots.peek();\n    }\n  }\n\n  /**\n   * Determines whether the traversal is currently in the global scope.\n   */\n  boolean inGlobalScope() {\n    return getScopeDepth() <= 1;\n  }\n\n  int getScopeDepth() {\n    return scopes.size() + scopeRoots.size();\n  }\n\n  public boolean hasScope() {\n    return !(scopes.isEmpty() && scopeRoots.isEmpty());\n  }\n\n  /** Reports a diagnostic (error or warning) */\n  public void report(Node n, DiagnosticType diagnosticType,\n      String... arguments) {\n    JSError error = JSError.make(getSourceName(), n, diagnosticType, arguments);\n    compiler.report(error);\n  }\n\n  private static String getSourceName(Node n) {\n    String name = n.getSourceFileName();\n    return name == null ? \"\" : name;\n  }\n\n  InputId getInputId() {\n    return inputId;\n  }\n\n  /**\n   * Creates a JSError during NodeTraversal.\n   *\n   * @param n Determines the line and char position within the source file name\n   * @param type The DiagnosticType\n   * @param arguments Arguments to be incorporated into the message\n   */\n  public JSError makeError(Node n, CheckLevel level, DiagnosticType type,\n      String... arguments) {\n    return JSError.make(getSourceName(), n, level, type, arguments);\n  }\n\n  /**\n   * Creates a JSError during NodeTraversal.\n   *\n   * @param n Determines the line and char position within the source file name\n   * @param type The DiagnosticType\n   * @param arguments Arguments to be incorporated into the message\n   */\n  public JSError makeError(Node n, DiagnosticType type, String... arguments) {\n    return JSError.make(getSourceName(), n, type, arguments);\n  }\n}\n", "review": {"response": "[{\"name\":\"NODE_TRAVERSAL_ERROR\",\"message\":\"{0}\",\"severity\":\"error\",\"category\":\"JSC\"}]"}}