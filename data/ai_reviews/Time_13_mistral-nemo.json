{"sample_id": "Time_13", "model": "mistral-nemo", "code_context": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TreeSet;\n\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadWritablePeriod;\nimport org.joda.time.ReadablePeriod;\n\n/**\n * Factory that creates complex instances of PeriodFormatter via method calls.\n * <p>\n * Period formatting is performed by the {@link PeriodFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link PeriodFormat} and {@link ISOPeriodFormat}.\n * <p>\n * PeriodFormatterBuilder is used for constructing formatters which are then\n * used to print or parse. The formatters are built by appending specific fields\n * or other formatters to an instance of this builder.\n * <p>\n * For example, a formatter that prints years and months, like \"15 years and 8 months\",\n * can be constructed as follows:\n * <p>\n * <pre>\n * PeriodFormatter yearsAndMonths = new PeriodFormatterBuilder()\n *     .printZeroAlways()\n *     .appendYears()\n *     .appendSuffix(\" year\", \" years\")\n *     .appendSeparator(\" and \")\n *     .printZeroRarelyLast()\n *     .appendMonths()\n *     .appendSuffix(\" month\", \" months\")\n *     .toFormatter();\n * </pre>\n * <p>\n * PeriodFormatterBuilder itself is mutable and not thread-safe, but the\n * formatters that it builds are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see PeriodFormat\n */\npublic class PeriodFormatterBuilder {\n    private static final int PRINT_ZERO_RARELY_FIRST = 1;\n    private static final int PRINT_ZERO_RARELY_LAST = 2;\n    private static final int PRINT_ZERO_IF_SUPPORTED = 3;\n    private static final int PRINT_ZERO_ALWAYS = 4;\n    private static final int PRINT_ZERO_NEVER = 5;\n    \n    private static final int YEARS = 0;\n    private static final int MONTHS = 1;\n    private static final int WEEKS = 2;\n    private static final int DAYS = 3;\n    private static final int HOURS = 4;\n    private static final int MINUTES = 5;\n    private static final int SECONDS = 6;\n    private static final int MILLIS = 7;\n    private static final int SECONDS_MILLIS = 8;\n    private static final int SECONDS_OPTIONAL_MILLIS = 9;\n    private static final int MAX_FIELD = SECONDS_OPTIONAL_MILLIS;\n\n    private int iMinPrintedDigits;\n    private int iPrintZeroSetting;\n    private int iMaxParsedDigits;\n    private boolean iRejectSignedValues;\n\n    private PeriodFieldAffix iPrefix;\n\n    // List of Printers and Parsers used to build a final formatter.\n    private List<Object> iElementPairs;\n    /** Set to true if the formatter is not a printer. */\n    private boolean iNotPrinter;\n    /** Set to true if the formatter is not a parser. */\n    private boolean iNotParser;\n\n    // Last PeriodFormatter appended of each field type.\n    private FieldFormatter[] iFieldFormatters;\n\n    public PeriodFormatterBuilder() {\n        clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a PeriodFormatter using all the appended elements.\n     * <p>\n     * This is the main method used by applications at the end of the build\n     * process to create a usable formatter.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned formatter.\n     * <p>\n     * The returned formatter may not support both printing and parsing.\n     * The methods {@link PeriodFormatter#isPrinter()} and\n     * {@link PeriodFormatter#isParser()} will help you determine the state\n     * of the formatter.\n     * \n     * @return the newly created formatter\n     * @throws IllegalStateException if the builder can produce neither a printer nor a parser\n     */\n    public PeriodFormatter toFormatter() {\n        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\n        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n        return formatter;\n    }\n\n    /**\n     * Internal method to create a PeriodPrinter instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned printer.\n     * \n     * @return the newly created printer, null if builder cannot create a printer\n     */\n    public PeriodPrinter toPrinter() {\n        if (iNotPrinter) {\n            return null;\n        }\n        return toFormatter().getPrinter();\n    }\n\n    /**\n     * Internal method to create a PeriodParser instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned parser.\n     * \n     * @return the newly created parser, null if builder cannot create a parser\n     */\n    public PeriodParser toParser() {\n        if (iNotParser) {\n            return null;\n        }\n        return toFormatter().getParser();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clears out all the appended elements, allowing this builder to be reused.\n     */\n    public void clear() {\n        iMinPrintedDigits = 1;\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        iMaxParsedDigits = 10;\n        iRejectSignedValues = false;\n        iPrefix = null;\n        if (iElementPairs == null) {\n            iElementPairs = new ArrayList<Object>();\n        } else {\n            iElementPairs.clear();\n        }\n        iNotPrinter = false;\n        iNotParser = false;\n        iFieldFormatters = new FieldFormatter[10];\n    }\n\n    /**\n     * Appends another formatter.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder append(PeriodFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        clearPrefix();\n        append0(formatter.getPrinter(), formatter.getParser());\n        return this;\n    }\n\n    /**\n     * Appends a printer parser pair.\n     * <p>\n     * Either the printer or the parser may be null, in which case the builder will\n     * be unable to produce a parser or printer repectively.\n     *\n     * @param printer  appends a printer to the builder, null if printing is not supported\n     * @param parser  appends a parser to the builder, null if parsing is not supported\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if both the printer and parser are null\n     */\n    public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {\n        if (printer == null && parser == null) {\n            throw new IllegalArgumentException(\"No printer or parser supplied\");\n        }\n        clearPrefix();\n        append0(printer, parser);\n        return this;\n    }\n\n    /**\n     * Instructs the printer to emit specific text, and the parser to expect it.\n     * The parser is case-insensitive.\n     *\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if text is null\n     */\n    public PeriodFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        clearPrefix();\n        Literal literal = new Literal(text);\n        append0(literal, literal);\n        return this;\n    }\n\n    /**\n     * Set the minimum digits printed for the next and following appended\n     * fields. By default, the minimum digits printed is one. If the field value\n     * is zero, it is not printed unless a printZero rule is applied.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {\n        iMinPrintedDigits = minDigits;\n        return this;\n    }\n\n    /**\n     * Set the maximum digits parsed for the next and following appended\n     * fields. By default, the maximum digits parsed is ten.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {\n        iMaxParsedDigits = maxDigits;\n        return this;\n    }\n\n    /**\n     * Reject signed values when parsing the next and following appended fields.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder rejectSignedValues(boolean v) {\n        iRejectSignedValues = v;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroRarelyLast() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the first \"printZeroRarely\" field to print a zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroRarelyFirst() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;\n        return this;\n    }\n\n    /**\n     * Print zero values for the next and following appened fields only if the\n     * period supports it.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroIfSupported() {\n        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n        return this;\n    }\n\n    /**\n     * Always print zero values for the next and following appended fields,\n     * even if the period doesn't support it. The parser requires values for\n     * fields that always print zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroAlways() {\n        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroNever() {\n        iPrintZeroSetting = PRINT_ZERO_NEVER;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param text text to print before field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    public PeriodFormatterBuilder appendPrefix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new SimpleAffix(text));\n    }\n\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether\n     * or not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    public PeriodFormatterBuilder appendPrefix(String singularText,\n                                                 String pluralText) {\n        if (singularText == null || pluralText == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new PluralAffix(singularText, pluralText));\n    }\n\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param prefix custom prefix\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException();\n        }\n        if (iPrefix != null) {\n            prefix = new CompositeAffix(iPrefix, prefix);\n        }\n        iPrefix = prefix;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Instruct the printer to emit an integer years field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendYears() {\n        appendField(YEARS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer months field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMonths() {\n        appendField(MONTHS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer weeks field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendWeeks() {\n        appendField(WEEKS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer days field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendDays() {\n        appendField(DAYS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer hours field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendHours() {\n        appendField(HOURS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer minutes field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMinutes() {\n        appendField(MINUTES);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer seconds field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSeconds() {\n        appendField(SECONDS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are always output.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSecondsWithMillis() {\n        appendField(SECONDS_MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are only output if non-zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\n        appendField(SECONDS_OPTIONAL_MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMillis() {\n        appendField(MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMillis3Digit() {\n        appendField(7, 3);\n        return this;\n    }\n\n    private void appendField(int type) {\n        appendField(type, iMinPrintedDigits);\n    }\n\n    private void appendField(int type, int minPrinted) {\n        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);\n        append0(field, field);\n        iFieldFormatters[type] = field;\n        iPrefix = null;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param text text to print after field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    public PeriodFormatterBuilder appendSuffix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new SimpleAffix(text));\n    }\n\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether or\n     * not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    public PeriodFormatterBuilder appendSuffix(String singularText,\n                                               String pluralText) {\n        if (singularText == null || pluralText == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new PluralAffix(singularText, pluralText));\n    }\n\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param suffix custom suffix\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\n        final Object originalPrinter;\n        final Object originalParser;\n        if (iElementPairs.size() > 0) {\n            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\n            originalParser = iElementPairs.get(iElementPairs.size() - 1);\n        } else {\n            originalPrinter = null;\n            originalParser = null;\n        }\n\n        if (originalPrinter == null || originalParser == null ||\n                originalPrinter != originalParser ||\n                !(originalPrinter instanceof FieldFormatter)) {\n            throw new IllegalStateException(\"No field to apply suffix to\");\n        }\n\n        clearPrefix();\n        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\n        iElementPairs.set(iElementPairs.size() - 2, newField);\n        iElementPairs.set(iElementPairs.size() - 1, newField);\n        iFieldFormatters[newField.getFieldType()] = newField;\n        \n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n     * will only output the comma if both the days and hours fields are output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text) {\n        return appendSeparator(text, text, null, true, true);\n    }\n\n    /**\n     * Append a separator, which is output only if fields are printed after the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(\",\").appendHours()</code>\n     * will only output the comma if the hours fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n        return appendSeparator(text, text, null, false, true);\n    }\n\n    /**\n     * Append a separator, which is output only if fields are printed before the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(\",\").appendHours()</code>\n     * will only output the comma if the days fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n        return appendSeparator(text, text, null, true, false);\n    }\n\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {\n        return appendSeparator(text, finalText, null, true, true);\n    }\n\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @param variants  set of text values which are also acceptable when parsed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                  String[] variants) {\n        return appendSeparator(text, finalText, variants, true, true);\n    }\n\n    private PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                   String[] variants,\n                                                   boolean useBefore, boolean useAfter) {\n        if (text == null || finalText == null) {\n            throw new IllegalArgumentException();\n        }\n\n        clearPrefix();\n        \n        // optimise zero formatter case\n        List<Object> pairs = iElementPairs;\n        if (pairs.size() == 0) {\n            if (useAfter && useBefore == false) {\n                Separator separator = new Separator(\n                        text, finalText, variants,\n                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);\n                append0(separator, separator);\n            }\n            return this;\n        }\n        \n        // find the last separator added\n        int i;\n        Separator lastSeparator = null;\n        for (i=pairs.size(); --i>=0; ) {\n            if (pairs.get(i) instanceof Separator) {\n                lastSeparator = (Separator) pairs.get(i);\n                pairs = pairs.subList(i + 1, pairs.size());\n                break;\n            }\n            i--;  // element pairs\n        }\n        \n        // merge formatters\n        if (lastSeparator != null && pairs.size() == 0) {\n            throw new IllegalStateException(\"Cannot have two adjacent separators\");\n        } else {\n            Object[] comp = createComposite(pairs);\n            pairs.clear();\n            Separator separator = new Separator(\n                    text, finalText, variants,\n                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],\n                    useBefore, useAfter);\n            pairs.add(separator);\n            pairs.add(separator);\n        }\n        \n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private void clearPrefix() throws IllegalStateException {\n        if (iPrefix != null) {\n            throw new IllegalStateException(\"Prefix not followed by field\");\n        }\n        iPrefix = null;\n    }\n\n    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        iNotPrinter |= (printer == null);\n        iNotParser |= (parser == null);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        int size = elementPairs.size();\n        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n            Separator sep = (Separator) elementPairs.get(0);\n            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                sep = sep.finish(f.getPrinter(), f.getParser());\n                return new PeriodFormatter(sep, sep);\n            }\n        }\n        Object[] comp = createComposite(elementPairs);\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }\n\n    private static Object[] createComposite(List<Object> elementPairs) {\n        switch (elementPairs.size()) {\n            case 0:\n                return new Object[] {Literal.EMPTY, Literal.EMPTY};\n            case 1:\n                return new Object[] {elementPairs.get(0), elementPairs.get(1)};\n            default:\n                Composite comp = new Composite(elementPairs);\n                return new Object[] {comp, comp};\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Defines a formatted field's prefix or suffix text.\n     * This can be used for fields such as 'n hours' or 'nH' or 'Hour:n'.\n     */\n    static interface PeriodFieldAffix {\n        int calculatePrintedLength(int value);\n        \n        void printTo(StringBuffer buf, int value);\n        \n        void printTo(Writer out, int value) throws IOException;\n        \n        /**\n         * @return new position after parsing affix, or ~position of failure\n         */\n        int parse(String periodStr, int position);\n\n        /**\n         * @return position where affix starts, or original ~position if not found\n         */\n        int scan(String periodStr, int position);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an affix where the text does not vary by the amount.\n     */\n    static class SimpleAffix implements PeriodFieldAffix {\n        private final String iText;\n\n        SimpleAffix(String text) {\n            iText = text;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return iText.length();\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(iText);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            out.write(iText);\n        }\n\n        public int parse(String periodStr, int position) {\n            String text = iText;\n            int textLength = text.length();\n            if (periodStr.regionMatches(true, position, text, 0, textLength)) {\n                return position + textLength;\n            }\n            return ~position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            String text = iText;\n            int textLength = text.length();\n            int sourceLength = periodStr.length();\n            search:\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {\n                    return pos;\n                }\n                // Only allow number characters to be skipped in search of suffix.\n                switch (periodStr.charAt(pos)) {\n                case '0': case '1': case '2': case '3': case '4':\n                case '5': case '6': case '7': case '8': case '9':\n                case '.': case ',': case '+': case '-':\n                    break;\n                default:\n                    break search;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an affix where the text varies by the amount of the field.\n     * Only singular (1) and plural (not 1) are supported.\n     */\n    static class PluralAffix implements PeriodFieldAffix {\n        private final String iSingularText;\n        private final String iPluralText;\n\n        PluralAffix(String singularText, String pluralText) {\n            iSingularText = singularText;\n            iPluralText = pluralText;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return (value == 1 ? iSingularText : iPluralText).length();\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(value == 1 ? iSingularText : iPluralText);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            out.write(value == 1 ? iSingularText : iPluralText);\n        }\n\n        public int parse(String periodStr, int position) {\n            String text1 = iPluralText;\n            String text2 = iSingularText; \n\n            if (text1.length() < text2.length()) {\n                // Swap in order to match longer one first.\n                String temp = text1;\n                text1 = text2;\n                text2 = temp;\n            }\n\n            if (periodStr.regionMatches\n                (true, position, text1, 0, text1.length())) {\n                return position + text1.length();\n            }\n            if (periodStr.regionMatches\n                (true, position, text2, 0, text2.length())) {\n                return position + text2.length();\n            }\n\n            return ~position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            String text1 = iPluralText;\n            String text2 = iSingularText; \n\n            if (text1.length() < text2.length()) {\n                // Swap in order to match longer one first.\n                String temp = text1;\n                text1 = text2;\n                text2 = temp;\n            }\n\n            int textLength1 = text1.length();\n            int textLength2 = text2.length();\n\n            int sourceLength = periodStr.length();\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) {\n                    return pos;\n                }\n                if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) {\n                    return pos;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Builds a composite affix by merging two other affix implementations.\n     */\n    static class CompositeAffix implements PeriodFieldAffix {\n        private final PeriodFieldAffix iLeft;\n        private final PeriodFieldAffix iRight;\n\n        CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) {\n            iLeft = left;\n            iRight = right;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return iLeft.calculatePrintedLength(value)\n                + iRight.calculatePrintedLength(value);\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            iLeft.printTo(buf, value);\n            iRight.printTo(buf, value);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            iLeft.printTo(out, value);\n            iRight.printTo(out, value);\n        }\n\n        public int parse(String periodStr, int position) {\n            position = iLeft.parse(periodStr, position);\n            if (position >= 0) {\n                position = iRight.parse(periodStr, position);\n            }\n            return position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            int pos = iLeft.scan(periodStr, position);\n            if (pos >= 0) {\n                return iRight.scan(periodStr, pos);\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats the numeric value of a field, potentially with prefix/suffix.\n     */\n    static class FieldFormatter\n            implements PeriodPrinter, PeriodParser {\n        private final int iMinPrintedDigits;\n        private final int iPrintZeroSetting;\n        private final int iMaxParsedDigits;\n        private final boolean iRejectSignedValues;\n        \n        /** The index of the field type, 0=year, etc. */\n        private final int iFieldType;\n        /**\n         * The array of the latest formatter added for each type.\n         * This is shared between all the field formatters in a formatter.\n         */\n        private final FieldFormatter[] iFieldFormatters;\n        \n        private final PeriodFieldAffix iPrefix;\n        private final PeriodFieldAffix iSuffix;\n\n        FieldFormatter(int minPrintedDigits, int printZeroSetting,\n                       int maxParsedDigits, boolean rejectSignedValues,\n                       int fieldType, FieldFormatter[] fieldFormatters,\n                       PeriodFieldAffix prefix, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = minPrintedDigits;\n            iPrintZeroSetting = printZeroSetting;\n            iMaxParsedDigits = maxParsedDigits;\n            iRejectSignedValues = rejectSignedValues;\n            iFieldType = fieldType;\n            iFieldFormatters = fieldFormatters;\n            iPrefix = prefix;\n            iSuffix = suffix;\n        }\n\n        FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = field.iMinPrintedDigits;\n            iPrintZeroSetting = field.iPrintZeroSetting;\n            iMaxParsedDigits = field.iMaxParsedDigits;\n            iRejectSignedValues = field.iRejectSignedValues;\n            iFieldType = field.iFieldType;\n            iFieldFormatters = field.iFieldFormatters;\n            iPrefix = field.iPrefix;\n            if (field.iSuffix != null) {\n                suffix = new CompositeAffix(field.iSuffix, suffix);\n            }\n            iSuffix = suffix;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            if (stopAt <= 0) {\n                return 0;\n            }\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {\n                return 1;\n            }\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return 0;\n            }\n\n            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\n            if (iFieldType >= SECONDS_MILLIS) {\n                // valueLong contains the seconds and millis fields\n                // the minimum output is 0.000, which is 4 or 5 digits with a negative\n                sum = Math.max(sum, 4);\n                // plus one for the decimal point\n                sum++;\n                if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\n                    sum -= 4; // remove three digits and decimal point\n                }\n                // reset valueLong to refer to the seconds part for the prefic/suffix calculation\n                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;\n            }\n            int value = (int) valueLong;\n\n            if (iPrefix != null) {\n                sum += iPrefix.calculatePrintedLength(value);\n            }\n            if (iSuffix != null) {\n                sum += iSuffix.calculatePrintedLength(value);\n            }\n\n            return sum;\n        }\n        \n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(buf, value);\n            }\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.appendUnpaddedInteger(buf, value);\n            } else {\n                FormatUtils.appendPaddedInteger(buf, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    buf.append('.');\n                    FormatUtils.appendPaddedInteger(buf, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(buf, value);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(out, value);\n            }\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.writeUnpaddedInteger(out, value);\n            } else {\n                FormatUtils.writePaddedInteger(out, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    out.write('.');\n                    FormatUtils.writePaddedInteger(out, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(out, value);\n            }\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\n                    if (wholeValue < 0) {\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }\n\n        /**\n         * @param text text to parse\n         * @param position position in text\n         * @param length exact count of characters to parse\n         * @return parsed int value\n         */\n        private int parseInt(String text, int position, int length) {\n            if (length >= 10) {\n                // Since value may exceed max, use stock parser which checks for this.\n                return Integer.parseInt(text.substring(position, position + length));\n            }\n            if (length <= 0) {\n                return 0;\n            }\n            int value = text.charAt(position++);\n            length--;\n            boolean negative;\n            if (value == '-') {\n                if (--length < 0) {\n                    return 0;\n                }\n                negative = true;\n                value = text.charAt(position++);\n            } else {\n                negative = false;\n            }\n            value -= '0';\n            while (length-- > 0) {\n                value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n            }\n            return negative ? -value : value;\n        }\n\n        /**\n         * @return Long.MAX_VALUE if nothing to print, otherwise value\n         */\n        long getFieldValue(ReadablePeriod period) {\n            PeriodType type;\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                type = null; // Don't need to check if supported.\n            } else {\n                type = period.getPeriodType();\n            }\n            if (type != null && isSupported(type, iFieldType) == false) {\n                return Long.MAX_VALUE;\n            }\n\n            long value;\n\n            switch (iFieldType) {\n            default:\n                return Long.MAX_VALUE;\n            case YEARS:\n                value = period.get(DurationFieldType.years());\n                break;\n            case MONTHS:\n                value = period.get(DurationFieldType.months());\n                break;\n            case WEEKS:\n                value = period.get(DurationFieldType.weeks());\n                break;\n            case DAYS:\n                value = period.get(DurationFieldType.days());\n                break;\n            case HOURS:\n                value = period.get(DurationFieldType.hours());\n                break;\n            case MINUTES:\n                value = period.get(DurationFieldType.minutes());\n                break;\n            case SECONDS:\n                value = period.get(DurationFieldType.seconds());\n                break;\n            case MILLIS:\n                value = period.get(DurationFieldType.millis());\n                break;\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                int seconds = period.get(DurationFieldType.seconds());\n                int millis = period.get(DurationFieldType.millis());\n                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n                break;\n            }\n\n            // determine if period is zero and this is the last field\n            if (value == 0) {\n                switch (iPrintZeroSetting) {\n                case PRINT_ZERO_NEVER:\n                    return Long.MAX_VALUE;\n                case PRINT_ZERO_RARELY_LAST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                case PRINT_ZERO_RARELY_FIRST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK\n                        i--;                              // see bug 1660490\n                        for (; i >= 0 && i <= MAX_FIELD; i--) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                }\n            }\n\n            return value;\n        }\n\n        boolean isZero(ReadablePeriod period) {\n            for (int i = 0, isize = period.size(); i < isize; i++) {\n                if (period.getValue(i) != 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        boolean isSupported(PeriodType type, int field) {\n            switch (field) {\n            default:\n                return false;\n            case YEARS:\n                return type.isSupported(DurationFieldType.years());\n            case MONTHS:\n                return type.isSupported(DurationFieldType.months());\n            case WEEKS:\n                return type.isSupported(DurationFieldType.weeks());\n            case DAYS:\n                return type.isSupported(DurationFieldType.days());\n            case HOURS:\n                return type.isSupported(DurationFieldType.hours());\n            case MINUTES:\n                return type.isSupported(DurationFieldType.minutes());\n            case SECONDS:\n                return type.isSupported(DurationFieldType.seconds());\n            case MILLIS:\n                return type.isSupported(DurationFieldType.millis());\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                return type.isSupported(DurationFieldType.seconds()) ||\n                       type.isSupported(DurationFieldType.millis());\n            }\n        }\n\n        void setFieldValue(ReadWritablePeriod period, int field, int value) {\n            switch (field) {\n            default:\n                break;\n            case YEARS:\n                period.setYears(value);\n                break;\n            case MONTHS:\n                period.setMonths(value);\n                break;\n            case WEEKS:\n                period.setWeeks(value);\n                break;\n            case DAYS:\n                period.setDays(value);\n                break;\n            case HOURS:\n                period.setHours(value);\n                break;\n            case MINUTES:\n                period.setMinutes(value);\n                break;\n            case SECONDS:\n                period.setSeconds(value);\n                break;\n            case MILLIS:\n                period.setMillis(value);\n                break;\n            }\n        }\n\n        int getFieldType() {\n            return iFieldType;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Handles a simple literal piece of text.\n     */\n    static class Literal\n            implements PeriodPrinter, PeriodParser {\n        static final Literal EMPTY = new Literal(\"\");\n        private final String iText;\n\n        Literal(String text) {\n            iText = text;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            return iText.length();\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            buf.append(iText);\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            out.write(iText);\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n                return position + iText.length();\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Handles a separator, that splits the fields into multiple parts.\n     * For example, the 'T' in the ISO8601 standard.\n     */\n    static class Separator\n            implements PeriodPrinter, PeriodParser {\n        private final String iText;\n        private final String iFinalText;\n        private final String[] iParsedForms;\n\n        private final boolean iUseBefore;\n        private final boolean iUseAfter;\n\n        private final PeriodPrinter iBeforePrinter;\n        private volatile PeriodPrinter iAfterPrinter;\n        private final PeriodParser iBeforeParser;\n        private volatile PeriodParser iAfterParser;\n\n        Separator(String text, String finalText, String[] variants,\n                PeriodPrinter beforePrinter, PeriodParser beforeParser,\n                boolean useBefore, boolean useAfter) {\n            iText = text;\n            iFinalText = finalText;\n\n            if ((finalText == null || text.equals(finalText)) &&\n                (variants == null || variants.length == 0)) {\n\n                iParsedForms = new String[] {text};\n            } else {\n                // Filter and reverse sort the parsed forms.\n                TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n                parsedSet.add(text);\n                parsedSet.add(finalText);\n                if (variants != null) {\n                    for (int i=variants.length; --i>=0; ) {\n                        parsedSet.add(variants[i]);\n                    }\n                }\n                ArrayList<String> parsedList = new ArrayList<String>(parsedSet);\n                Collections.reverse(parsedList);\n                iParsedForms = parsedList.toArray(new String[parsedList.size()]);\n            }\n\n            iBeforePrinter = beforePrinter;\n            iBeforeParser = beforeParser;\n            iUseBefore = useBefore;\n            iUseAfter = useAfter;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale);\n            if (sum < stopAt) {\n                sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale);\n            }\n            return sum;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            int sum = before.calculatePrintedLength(period, locale)\n                    + after.calculatePrintedLength(period, locale);\n            \n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            sum += (afterCount > 1 ? iText : iFinalText).length();\n                        }\n                    } else {\n                        sum += iText.length();\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                sum += iText.length();\n            }\n            \n            return sum;\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(buf, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            buf.append(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        buf.append(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                buf.append(iText);\n            }\n            after.printTo(buf, period, locale);\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(out, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            out.write(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        out.write(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                out.write(iText);\n            }\n            after.printTo(out, period, locale);\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            int oldPos = position;\n            position = iBeforeParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            boolean found = false;\n            if (position > oldPos) {\n                // Consume this separator.\n                String[] parsedForms = iParsedForms;\n                int length = parsedForms.length;\n                for (int i=0; i < length; i++) {\n                    String parsedForm = parsedForms[i];\n                    if ((parsedForm == null || parsedForm.length() == 0) ||\n                        periodStr.regionMatches\n                        (true, position, parsedForm, 0, parsedForm.length())) {\n                        \n                        position += (parsedForm == null ? 0 : parsedForm.length());\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            oldPos = position;\n            position = iAfterParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            if (found && position == oldPos) {\n                // Separator should not have been supplied.\n                return ~oldPos;\n            }\n\n            if (position > oldPos && !found && !iUseBefore) {\n                // Separator was required.\n                return ~oldPos;\n            }\n\n            return position;\n        }\n\n        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\n            iAfterPrinter = afterPrinter;\n            iAfterParser = afterParser;\n            return this;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Composite implementation that merges other fields to create a full pattern.\n     */\n    static class Composite\n            implements PeriodPrinter, PeriodParser {\n        \n        private final PeriodPrinter[] iPrinters;\n        private final PeriodParser[] iParsers;\n\n        Composite(List<Object> elementPairs) {\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n            } else {\n                iPrinters = printerList.toArray(\n                        new PeriodPrinter[printerList.size()]);\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n            } else {\n                iParsers = parserList.toArray(\n                        new PeriodParser[parserList.size()]);\n            }\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; sum < stopAt && --i>=0; ) {\n                sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);\n            }\n            return sum;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; --i>=0; ) {\n                sum += printers[i].calculatePrintedLength(period, locale);\n            }\n            return sum;\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(buf, period, locale);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(out, period, locale);\n            }\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            PeriodParser[] parsers = iParsers;\n            if (parsers == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = parsers.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = parsers[i].parseInto(period, periodStr, position, locale);\n            }\n            return position;\n        }\n\n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof PeriodPrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite) element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof PeriodParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite) element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }\n\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }\n    }\n\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"description\": \"The `toFormatter` method does not check if the builder can produce neither a printer nor a parser. It should throw an `IllegalStateException` in such cases.\",\n      \"location\": \"PeriodFormatterBuilder#toFormatter\"\n    },\n    {\n      \"description\": \"The `toPrinter` and `toParser` methods do not clear the internal state of the builder after creating a printer or parser. This could lead to unexpected behavior if the builder is reused.\",\n      \"location\": \"PeriodFormatterBuilder#toPrinter, PeriodFormatterBuilder#toParser\"\n    },\n    {\n      \"description\": \"The `iMinPrintedDigits`, `iPrintZeroSetting`, `iMaxParsedDigits`, and `iRejectSignedValues` fields are not initialized in the constructor. They should be initialized to default values or reset in the `clear` method.\",\n      \"location\": \"PeriodFormatterBuilder#PeriodFormatterBuilder\"\n    },\n    {\n      \"description\": \"The `iElementPairs` list is not cleared in the constructor. It should be cleared or reset in the `clear` method.\",\n      \"location\": \"PeriodFormatterBuilder#PeriodFormatterBuilder\"\n    },\n    {\n      \"description\": \"The `iNotPrinter` and `iNotParser` boolean flags are not reset in the constructor. They should be set to `false` or reset in the `clear` method.\",\n      \"location\": \"PeriodFormatterBuilder#PeriodFormatterBuilder\"\n    },\n    {\n      \"description\": \"The `iFieldFormatters` array is not cleared in the constructor. It should be cleared or reset in the `clear` method.\",\n      \"location\": \"PeriodFormatterBuilder#PeriodFormatterBuilder\"\n    }\n  ]\n}"}}