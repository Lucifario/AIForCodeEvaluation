{"sample_id": "Math_95", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math.distribution;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.special.Beta;\n\n/**\n * Default implementation of\n * {@link org.apache.commons.math.distribution.FDistribution}.\n *\n * @version $Revision$ $Date$\n */\npublic class FDistributionImpl\n    extends AbstractContinuousDistribution\n    implements FDistribution, Serializable  {\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = -8516354193418641566L;\n\n    /** The numerator degrees of freedom*/\n    private double numeratorDegreesOfFreedom;\n\n    /** The numerator degrees of freedom*/\n    private double denominatorDegreesOfFreedom;\n    \n    /**\n     * Create a F distribution using the given degrees of freedom.\n     * @param numeratorDegreesOfFreedom the numerator degrees of freedom.\n     * @param denominatorDegreesOfFreedom the denominator degrees of freedom.\n     */\n    public FDistributionImpl(double numeratorDegreesOfFreedom,\n            double denominatorDegreesOfFreedom) {\n        super();\n        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n        setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n    }\n    \n    /**\n     * For this distribution, X, this method returns P(X &lt; x).\n     * \n     * The implementation of this method is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n     * F-Distribution</a>, equation (4).</li>\n     * </ul>\n     * \n     * @param x the value at which the CDF is evaluated.\n     * @return CDF for this distribution. \n     * @throws MathException if the cumulative probability can not be\n     *            computed due to convergence or other numerical errors.\n     */\n    public double cumulativeProbability(double x) throws MathException {\n        double ret;\n        if (x <= 0.0) {\n            ret = 0.0;\n        } else {\n            double n = getNumeratorDegreesOfFreedom();\n            double m = getDenominatorDegreesOfFreedom();\n            \n            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n                0.5 * n,\n                0.5 * m);\n        }\n        return ret;\n    }\n    \n    /**\n     * For this distribution, X, this method returns the critical point x, such\n     * that P(X &lt; x) = <code>p</code>.\n     * <p>\n     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n     *\n     * @param p the desired probability\n     * @return x, such that P(X &lt; x) = <code>p</code>\n     * @throws MathException if the inverse cumulative probability can not be\n     *         computed due to convergence or other numerical errors.\n     * @throws IllegalArgumentException if <code>p</code> is not a valid\n     *         probability.\n     */\n    public double inverseCumulativeProbability(final double p) \n        throws MathException {\n        if (p == 0) {\n            return 0d;\n        }\n        if (p == 1) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return super.inverseCumulativeProbability(p);\n    }\n        \n    /**\n     * Access the domain value lower bound, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return domain value lower bound, i.e.\n     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n     */\n    protected double getDomainLowerBound(double p) {\n        return 0.0;\n    }\n\n    /**\n     * Access the domain value upper bound, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return domain value upper bound, i.e.\n     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n     */\n    protected double getDomainUpperBound(double p) {\n        return Double.MAX_VALUE;\n    }\n\n    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n        return ret;\n    }\n    \n    /**\n     * Modify the numerator degrees of freedom.\n     * @param degreesOfFreedom the new numerator degrees of freedom.\n     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n     *         positive.\n     */\n    public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n        if (degreesOfFreedom <= 0.0) {\n            throw new IllegalArgumentException(\n                \"degrees of freedom must be positive.\");\n        }\n        this.numeratorDegreesOfFreedom = degreesOfFreedom;\n    }\n    \n    /**\n     * Access the numerator degrees of freedom.\n     * @return the numerator degrees of freedom.\n     */\n    public double getNumeratorDegreesOfFreedom() {\n        return numeratorDegreesOfFreedom;\n    }\n    \n    /**\n     * Modify the denominator degrees of freedom.\n     * @param degreesOfFreedom the new denominator degrees of freedom.\n     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n     *         positive.\n     */\n    public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n        if (degreesOfFreedom <= 0.0) {\n            throw new IllegalArgumentException(\n                \"degrees of freedom must be positive.\");\n        }\n        this.denominatorDegreesOfFreedom = degreesOfFreedom;\n    }\n    \n    /**\n     * Access the denominator degrees of freedom.\n     * @return the denominator degrees of freedom.\n     */\n    public double getDenominatorDegreesOfFreedom() {\n        return denominatorDegreesOfFreedom;\n    }\n}\n", "review": {"response": "{ \"bugs\": [] }"}}