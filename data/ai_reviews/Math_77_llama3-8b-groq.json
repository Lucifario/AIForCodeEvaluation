{"sample_id": "Math_77", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math.linear;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\n\n/**\n * This class implements the {@link RealVector} interface with a {@link OpenIntToDoubleHashMap} backing store.\n * @version $Revision$ $Date$\n * @since 2.0\n*/\npublic class OpenMapRealVector extends AbstractRealVector implements SparseRealVector, Serializable {\n\n    /** Default Tolerance for having a value considered zero. */\n    public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\n\n    /** Serializable version identifier. */\n    private static final long serialVersionUID = 8772222695580707260L;\n\n    /** Entries of the vector. */\n    private final OpenIntToDoubleHashMap entries;\n\n    /** Dimension of the vector. */\n    private final int virtualSize;\n\n    /** Tolerance for having a value considered zero. */\n    private double epsilon;\n\n    /**\n     * Build a 0-length vector.\n     * <p>Zero-length vectors may be used to initialized construction of vectors\n     * by data gathering. We start with zero-length and use either the {@link\n     * #OpenMapRealVector(OpenMapRealVector, int)} constructor\n     * or one of the <code>append</code> method ({@link #append(double)}, {@link\n     * #append(double[])}, {@link #append(RealVector)}) to gather data\n     * into this vector.</p>\n     */\n    public OpenMapRealVector() {\n        this(0, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Construct a (dimension)-length vector of zeros.\n     * @param dimension size of the vector\n     */\n    public OpenMapRealVector(int dimension) {\n        this(dimension, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Construct a (dimension)-length vector of zeros, specifying zero tolerance.\n     * @param dimension Size of the vector\n     * @param epsilon The tolerance for having a value considered zero\n     */\n    public OpenMapRealVector(int dimension, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * Build a resized vector, for use with append.\n     * @param v The original vector\n     * @param resize The amount to resize it\n     */\n    protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n        virtualSize = v.getDimension() + resize;\n        entries = new OpenIntToDoubleHashMap(v.entries);\n        epsilon = v.epsilon;\n    }\n\n    /**\n     * Build a vector with known the sparseness (for advanced use only).\n     * @param dimension The size of the vector\n     * @param expectedSize The expected number of non-zero entries\n     */\n    public OpenMapRealVector(int dimension, int expectedSize) {\n        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Build a vector with known the sparseness and zero tolerance setting (for advanced use only).\n     * @param dimension The size of the vector\n     * @param expectedSize The expected number of non-zero entries\n     * @param epsilon The tolerance for having a value considered zero\n     */\n    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * Create from a double array.\n     * Only non-zero entries will be stored\n     * @param values The set of values to create from\n     */\n    public OpenMapRealVector(double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Create from a double array, specifying zero tolerance.\n     * Only non-zero entries will be stored\n     * @param values The set of values to create from\n     * @param epsilon The tolerance for having a value considered zero\n     */\n    public OpenMapRealVector(double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key];\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Create from a Double array.\n     * Only non-zero entries will be stored\n     * @param values The set of values to create from\n     */\n    public OpenMapRealVector(Double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Create from a Double array.\n     * Only non-zero entries will be stored\n     * @param values The set of values to create from\n     * @param epsilon The tolerance for having a value considered zero\n     */\n    public OpenMapRealVector(Double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key].doubleValue();\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Copy constructor.\n     * @param v The instance to copy from\n     */\n    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }\n\n    /**\n     * Generic copy constructor.\n     * @param v The instance to copy from\n     */\n    public OpenMapRealVector(RealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(0.0);\n        epsilon = DEFAULT_ZERO_TOLERANCE;\n        for (int key = 0; key < virtualSize; key++) {\n            double value = v.getEntry(key);\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Get the entries of this instance.\n     * @return entries of this instance\n     */\n    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }\n\n    /**\n     * Determine if this value is within epsilon of zero.\n     * @param value The value to test\n     * @return <code>true</code> if this value is within epsilon to zero, <code>false</code> otherwise\n     */\n    protected boolean isDefaultValue(double value) {\n        return Math.abs(value) < epsilon;\n    }\n\n    /** {@inheritDoc} */\n    public RealVector add(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return add((OpenMapRealVector) v);\n        } else {\n            return super.add(v);\n        }\n    }\n\n    /**\n     * Optimized method to add two OpenMapRealVectors.  Copies the larger vector, iterates over the smaller.\n     * @param v Vector to add with\n     * @return The sum of <code>this</code> with <code>v</code>\n     * @throws IllegalArgumentException If the dimensions don't match\n     */\n    public OpenMapRealVector add(OpenMapRealVector v) throws IllegalArgumentException{\n        checkVectorDimensions(v.getDimension());\n        boolean copyThis = entries.size() > v.entries.size();\n        OpenMapRealVector res = copyThis ? this.copy() : v.copy();\n        Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();\n        OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (randomAccess.containsKey(key)) {\n                res.setEntry(key, randomAccess.get(key) + iter.value());\n            } else {\n                res.setEntry(key, iter.value());\n            }\n        }\n        return res;\n    }\n\n    /**\n     * Optimized method to append a OpenMapRealVector.\n     * @param v vector to append\n     * @return The result of appending <code>v</code> to self\n     */\n    public OpenMapRealVector append(OpenMapRealVector v) {\n        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n        Iterator iter = v.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key() + virtualSize, iter.value());\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector append(RealVector v) {\n        if (v instanceof OpenMapRealVector) {\n            return append((OpenMapRealVector) v);\n        }\n        return append(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector append(double d) {\n        OpenMapRealVector res = new OpenMapRealVector(this, 1);\n        res.setEntry(virtualSize, d);\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector append(double[] a) {\n        OpenMapRealVector res = new OpenMapRealVector(this, a.length);\n        for (int i = 0; i < a.length; i++) {\n            res.setEntry(i + virtualSize, a[i]);\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector copy() {\n        return new OpenMapRealVector(this);\n    }\n\n    /**\n     * Optimized method to compute the dot product with an OpenMapRealVector.\n     * Iterates over the smaller of the two.\n     * @param v The vector to compute the dot product with\n     * @return The dot product of <code>this</code> and <code>v</code>\n     * @throws IllegalArgumentException If the dimensions don't match\n     */\n    public double dotProduct(OpenMapRealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        boolean thisIsSmaller  = entries.size() < v.entries.size();\n        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;\n        double d = 0;\n        while(iter.hasNext()) {\n            iter.advance();\n            d += iter.value() * larger.get(iter.key());\n        }\n        return d;\n    }\n\n    /** {@inheritDoc} */\n    public double dotProduct(RealVector v) throws IllegalArgumentException {\n        if(v instanceof OpenMapRealVector) {\n            return dotProduct((OpenMapRealVector)v);\n        } else {\n            return super.dotProduct(v);\n        }\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector ebeDivide(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector getSubVector(int index, int n) throws MatrixIndexException {\n        checkIndex(index);\n        checkIndex(index + n - 1);\n        OpenMapRealVector res = new OpenMapRealVector(n);\n        int end = index + n;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (key >= index && key < end) {\n                res.setEntry(key - index, iter.value());\n            }\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public double[] getData() {\n        double[] res = new double[virtualSize];\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res[iter.key()] = iter.value();\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public int getDimension() {\n        return virtualSize;\n    }\n\n    /**\n     * Optimized method to compute distance.\n     * @param v The vector to compute distance to\n     * @return The distance from <code>this</code> and <code>v</code>\n     * @throws IllegalArgumentException If the dimensions don't match\n     */\n    public double getDistance(OpenMapRealVector v) throws IllegalArgumentException {\n        Iterator iter = entries.iterator();\n        double res = 0;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            double delta;\n            delta = iter.value() - v.getEntry(key);\n            res += delta * delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                final double value = iter.value();\n                res += value * value;\n            }\n        }\n        return Math.sqrt(res);\n    }\n\n    /** {@inheritDoc} */\n    public double getDistance(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getDistance((OpenMapRealVector) v);\n        }\n        return getDistance(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public double getDistance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double res = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = entries.get(i) - v[i];\n            res += delta * delta;\n        }\n        return Math.sqrt(res);\n    }\n\n    /** {@inheritDoc} */\n    public double getEntry(int index) throws MatrixIndexException {\n        checkIndex(index);\n        return entries.get(index);\n    }\n\n    /**\n     * Distance between two vectors.\n     * <p>This method computes the distance consistent with\n     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n     * elements differences.</p>\n     * @param v vector to which distance is requested\n     * @return distance between two vectors.\n     */\n    public double getL1Distance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n            max += delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                double delta = Math.abs(iter.value());\n                max +=  Math.abs(delta);\n            }\n        }\n        return max;\n    }\n\n    /** {@inheritDoc} */\n    public double getL1Distance(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getL1Distance((OpenMapRealVector) v);\n        }\n        return getL1Distance(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public double getL1Distance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = Math.abs(getEntry(i) - v[i]);\n            max += delta;\n        }\n        return max;\n    }\n\n    public double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }\n    /**\n     * Optimized method to compute LInfDistance.\n     * @param v The vector to compute from\n     * @return the LInfDistance\n     */\n    private double getLInfDistance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                if (iter.value() > max) {\n                    max = iter.value();\n                }\n            }\n        }\n        return max;\n    }\n\n    /** {@inheritDoc} */\n    public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getLInfDistance((OpenMapRealVector) v);\n        }\n        return getLInfDistance(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public double getLInfDistance(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = Math.abs(getEntry(i) - v[i]);\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        return max;\n    }\n\n    /** {@inheritDoc} */\n    public boolean isInfinite() {\n        boolean infiniteFound = false;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            final double value = iter.value();\n            if (Double.isNaN(value)) {\n                return false;\n            }\n            if (Double.isInfinite(value)) {\n                infiniteFound = true;\n            }\n        }\n        return infiniteFound;\n    }\n\n    /** {@inheritDoc} */\n    public boolean isNaN() {\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            if (Double.isNaN(iter.value())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector mapAdd(double d) {\n        return copy().mapAddToSelf(d);\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector mapAddToSelf(double d) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, getEntry(i) + d);\n        }\n        return this;\n    }\n\n     /** {@inheritDoc} */\n    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        RealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int row = iter.key();\n            double value = iter.value();\n            for (int col = 0; col < virtualSize; col++) {\n                res.setEntry(row, col, value * v[col]);\n            }\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public RealVector projection(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector projection(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        return (OpenMapRealVector) projection(new OpenMapRealVector(v));\n    }\n\n    /** {@inheritDoc} */\n    public void setEntry(int index, double value) throws MatrixIndexException {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n\n    /** {@inheritDoc} */\n    public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n        checkIndex(index);\n        checkIndex(index + v.getDimension() - 1);\n        setSubVector(index, v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public void setSubVector(int index, double[] v) throws MatrixIndexException {\n        checkIndex(index);\n        checkIndex(index + v.length - 1);\n        for (int i = 0; i < v.length; i++) {\n            setEntry(i + index, v[i]);\n        }\n    }\n\n    /** {@inheritDoc} */\n    public void set(double value) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, value);\n        }\n    }\n\n    /**\n     * Optimized method to subtract OpenMapRealVectors.\n     * @param v The vector to subtract from <code>this</code>\n     * @return The difference of <code>this</code> and <code>v</code>\n     * @throws IllegalArgumentException If the dimensions don't match\n     */\n    public OpenMapRealVector subtract(OpenMapRealVector v) throws IllegalArgumentException{\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = copy();\n        Iterator iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (entries.containsKey(key)) {\n                res.setEntry(key, entries.get(key) - iter.value());\n            } else {\n                res.setEntry(key, -iter.value());\n            }\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return subtract((OpenMapRealVector) v);\n        }\n        return subtract(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        for (int i = 0; i < v.length; i++) {\n            if (entries.containsKey(i)) {\n                res.setEntry(i, entries.get(i) - v[i]);\n            } else {\n                res.setEntry(i, -v[i]);\n            }\n        }\n        return res;\n    }\n\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector unitVector() {\n        OpenMapRealVector res = copy();\n        res.unitize();\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public void unitize() {\n        double norm = getNorm();\n        if (isDefaultValue(norm)) {\n            throw  MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            entries.put(iter.key(), iter.value() / norm);\n        }\n\n    }\n\n\n    /** {@inheritDoc} */\n    public double[] toArray() {\n        return getData();\n    }\n\n    /** {@inheritDoc}\n     * <p> Implementation Note: This works on exact values, and as a result\n     * it is possible for {@code a.subtract(b)} to be the zero vector, while\n     * {@code a.hashCode() != b.hashCode()}.</p>\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(epsilon);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + virtualSize;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            temp = Double.doubleToLongBits(iter.value());\n            result = prime * result + (int) (temp ^ (temp >>32));\n        }\n        return result;\n    }\n\n    /**\n     * <p> Implementation Note: This performs an exact comparison, and as a result\n     * it is possible for {@code a.subtract(b}} to be the zero vector, while\n     * {@code  a.equals(b) == false}.</p>\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!(obj instanceof OpenMapRealVector)) {\n            return false;\n        }\n        OpenMapRealVector other = (OpenMapRealVector) obj;\n        if (virtualSize != other.virtualSize) {\n            return false;\n        }\n        if (Double.doubleToLongBits(epsilon) !=\n            Double.doubleToLongBits(other.epsilon)) {\n            return false;\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = other.getEntry(iter.key());\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {\n                return false;\n            }\n        }\n        iter = other.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = iter.value();\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     *\n     * @return the percentage of none zero elements as a decimal percent.\n     */\n    public double getSparcity() {\n        return (double)entries.size()/(double)getDimension();\n    }\n\n    /** {@inheritDoc} */\n    public java.util.Iterator<Entry> sparseIterator() {\n        return new OpenMapSparseIterator();\n    }\n\n    /**\n     *  Implementation of <code>Entry</code> optimized for OpenMap.\n     * <p>This implementation does not allow arbitrary calls to <code>setIndex</code>\n     * since the order that entries are returned is undefined.\n     */\n    protected class OpenMapEntry extends Entry {\n\n        /** Iterator pointing to the entry. */\n        private final Iterator iter;\n\n        /** Build an entry from an iterator point to an element.\n         * @param iter iterator pointing to the entry\n         */\n        protected OpenMapEntry(Iterator iter) {\n            this.iter = iter;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public double getValue() {\n            return iter.value();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void setValue(double value) {\n            entries.put(iter.key(), value);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int getIndex() {\n            return iter.key();\n        }\n\n    }\n\n    /**\n     *  Iterator class to do iteration over just the non-zero elements.\n     *  <p>This implementation is fail-fast, so cannot be used to modify any zero element.\n     *\n     */\n    protected class OpenMapSparseIterator implements java.util.Iterator<Entry> {\n\n        /** Underlying iterator. */\n        private final Iterator iter;\n\n        /** Current entry. */\n        private final Entry current;\n\n        /** Simple constructor. */\n        protected OpenMapSparseIterator() {\n            iter = entries.iterator();\n            current = new OpenMapEntry(iter);\n        }\n\n        /** {@inheritDoc} */\n        public boolean hasNext() {\n            return iter.hasNext();\n        }\n\n        /** {@inheritDoc} */\n        public Entry next() {\n            iter.advance();\n            return current;\n        }\n\n        /** {@inheritDoc} */\n        public void remove() {\n            throw new UnsupportedOperationException(\"Not supported\");\n       }\n\n    }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"type\": \"Potential Null Pointer Exception\",\n         \"description\": \"In the constructor OpenMapRealVector(OpenMapRealVector v, int resize), the epsilon field is not initialized. If v.epsilon is null, this could lead to a NullPointerException.\",\n         \"location\": \"OpenMapRealVector(OpenMapRealVector v, int resize)\"\n      },\n      {\n         \"type\": \"Potential ArrayIndexOutOfBoundsException\",\n         \"description\": \"In the constructor OpenMapRealVector(double[] values), the loop that iterates over the values array does not check if the index is within the bounds of the array. If values is null, this could lead to an ArrayIndexOutOfBoundsException.\",\n         \"location\": \"OpenMapRealVector(double[] values)\"\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"description\": \"In the constructor OpenMapRealVector(Double[] values), the loop that iterates over the values array does not check if values is null. If values is null, this could lead to a NullPointerException.\",\n         \"location\": \"OpenMapRealVector(Double[] values)\"\n      },\n      {\n         \"type\": \"Potential ClassCastException\",\n         \"description\": \"In the constructor OpenMapRealVector(Double[] values), the call to values[key].doubleValue() does not check if values[key] is null. If values[key] is null, this could lead to a ClassCastException.\",\n         \"location\": \"OpenMapRealVector(Double[] values)\"\n      }\n   ]\n}"}}