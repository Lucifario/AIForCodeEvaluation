{"sample_id": "Math_53", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.complex;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math.FieldElement;\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.exception.NullArgumentException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.util.MathUtils;\nimport org.apache.commons.math.util.FastMath;\n\n/**\n * Representation of a Complex number - a number which has both a\n * real and imaginary part.\n * <p>\n * Implementations of arithmetic operations handle <code>NaN</code> and\n * infinite values according to the rules for {@link java.lang.Double}\n * arithmetic, applying definitional formulas and returning <code>NaN</code> or\n * infinite values in real or imaginary parts as these arise in computation.\n * See individual method javadocs for details.</p>\n * <p>\n * {@link #equals} identifies all values with <code>NaN</code> in either real\n * or imaginary part - e.g., <pre>\n * <code>1 + NaNi  == NaN + i == NaN + NaNi.</code></pre></p>\n *\n * implements Serializable since 2.0\n *\n * @version $Id$\n */\npublic class Complex implements FieldElement<Complex>, Serializable  {\n\n    /** The square root of -1. A number representing \"0.0 + 1.0i\" */\n    public static final Complex I = new Complex(0.0, 1.0);\n\n    // CHECKSTYLE: stop ConstantName\n    /** A complex number representing \"NaN + NaNi\" */\n    public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n    // CHECKSTYLE: resume ConstantName\n\n    /** A complex number representing \"+INF + INFi\" */\n    public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n\n    /** A complex number representing \"1.0 + 0.0i\" */\n    public static final Complex ONE = new Complex(1.0, 0.0);\n\n    /** A complex number representing \"0.0 + 0.0i\" */\n    public static final Complex ZERO = new Complex(0.0, 0.0);\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6195664516687396620L;\n\n    /** The imaginary part. */\n    private final double imaginary;\n\n    /** The real part. */\n    private final double real;\n\n    /** Record whether this complex number is equal to NaN. */\n    private final transient boolean isNaN;\n\n    /** Record whether this complex number is infinite. */\n    private final transient boolean isInfinite;\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param real the real part\n     * @param imaginary the imaginary part\n     */\n    public Complex(double real, double imaginary) {\n        super();\n        this.real = real;\n        this.imaginary = imaginary;\n\n        isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n        isInfinite = !isNaN &&\n        (Double.isInfinite(real) || Double.isInfinite(imaginary));\n    }\n\n    /**\n     * Return the absolute value of this complex number.\n     * <p>\n     * Returns <code>NaN</code> if either real or imaginary part is\n     * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if\n     * neither part is <code>NaN</code>, but at least one part takes an infinite\n     * value.</p>\n     *\n     * @return the absolute value\n     */\n    public double abs() {\n        if (isNaN) {\n            return Double.NaN;\n        }\n\n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return FastMath.abs(real);\n            }\n            double q = real / imaginary;\n            return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n        } else {\n            if (real == 0.0) {\n                return FastMath.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n        }\n    }\n\n    /**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise Infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.</p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number sum\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n\n    /**\n     * Return the conjugate of this complex number. The conjugate of\n     * \"A + Bi\" is \"A - Bi\".\n     * <p>\n     * {@link #NaN} is returned if either the real or imaginary\n     * part of this Complex number equals <code>Double.NaN</code>.</p>\n     * <p>\n     * If the imaginary part is infinite, and the real part is not NaN,\n     * the returned value has infinite imaginary part of the opposite\n     * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>\n     * is <code>1 - NEGATIVE_INFINITY i</code></p>\n     *\n     * @return the conjugate of this Complex object\n     */\n    public Complex conjugate() {\n        if (isNaN) {\n            return NaN;\n        }\n        return createComplex(real, -imaginary);\n    }\n\n    /**\n     * Return the quotient of this complex number and the given complex number.\n     * <p>\n     * Implements the definitional formula\n     * <pre><code>\n     *    a + bi          ac + bd + (bc - ad)i\n     *    ----------- = -------------------------\n     *    c + di         c<sup>2</sup> + d<sup>2</sup>\n     * </code></pre>\n     * but uses\n     * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n     * prescaling of operands</a> to limit the effects of overflows and\n     * underflows in the computation.</p>\n     * <p>\n     * Infinite and NaN values are handled / returned according to the\n     * following rules, applied in the order presented:\n     * <ul>\n     * <li>If either this or <code>rhs</code> has a NaN value in either part,\n     *  {@link #NaN} is returned.</li>\n     * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.\n     * </li>\n     * <li>If this and <code>rhs</code> are both infinite,\n     * {@link #NaN} is returned.</li>\n     * <li>If this is finite (i.e., has no infinite or NaN parts) and\n     *  <code>rhs</code> is infinite (one or both parts infinite),\n     * {@link #ZERO} is returned.</li>\n     * <li>If this is infinite and <code>rhs</code> is finite, NaN values are\n     * returned in the parts of the result if the {@link java.lang.Double}\n     * rules applied to the definitional formula force NaN results.</li>\n     * </ul></p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number quotient\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex divide(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n\n        double c = rhs.getReal();\n        double d = rhs.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n\n        if (rhs.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(c) < FastMath.abs(d)) {\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }\n\n    /**\n     * Test for the equality of two Complex objects.\n     * <p>\n     * If both the real and imaginary parts of two Complex numbers\n     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n     * Complex objects are considered to be equal.</p>\n     * <p>\n     * All <code>NaN</code> values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to <code>Double.NaN</code>, the complex number is equal to\n     * <code>Complex.NaN</code>.</p>\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if\n     *         object is null, not an instance of Complex, or\n     *         not equal to this Complex instance\n     *\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN) {\n                return isNaN;\n            } else {\n                return (real == rhs.real) && (imaginary == rhs.imaginary);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get a hashCode for the complex number.\n     * <p>\n     * All NaN values have the same hash code.</p>\n     *\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        if (isNaN) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) +\n            MathUtils.hash(real));\n    }\n\n    /**\n     * Access the imaginary part.\n     *\n     * @return the imaginary part\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Access the real part.\n     *\n     * @return the real part\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Returns true if either or both parts of this complex number is NaN;\n     * false otherwise\n     *\n     * @return  true if either or both parts of this complex number is NaN;\n     * false otherwise\n     */\n    public boolean isNaN() {\n        return isNaN;\n    }\n\n    /**\n     * Returns true if either the real or imaginary part of this complex number\n     * takes an infinite value (either <code>Double.POSITIVE_INFINITY</code> or\n     * <code>Double.NEGATIVE_INFINITY</code>) and neither part\n     * is <code>NaN</code>.\n     *\n     * @return true if one or both parts of this complex number are infinite\n     * and neither part is <code>NaN</code>\n     */\n    public boolean isInfinite() {\n        return isInfinite;\n    }\n\n    /**\n     * Return the product of this complex number and the given complex number.\n     * <p>\n     * Implements preliminary checks for NaN and infinity followed by\n     * the definitional formula:\n     * <pre><code>\n     * (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     * </code></pre>\n     * </p>\n     * <p>\n     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n     * NaN parts.\n     * </p>\n     * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more\n     * NaN parts and if either this or <code>rhs</code> has one or more\n     * infinite parts (same result is returned regardless of the sign of the\n     * components).\n     * </p>\n     * <p>\n     * Returns finite values in components of the result per the\n     * definitional formula in all remaining cases.\n     *  </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number product\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex multiply(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {\n            // we don't use Complex.isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n                real * rhs.imaginary + imaginary * rhs.real);\n    }\n\n    /**\n     * Return the product of this complex number and the given scalar number.\n     * <p>\n     * Implements preliminary checks for NaN and infinity followed by\n     * the definitional formula:\n     * <pre><code>\n     * c(a + bi) = (ca) + (cb)i\n     * </code></pre>\n     * </p>\n     * <p>\n     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n     * NaN parts.\n     * </p>\n     * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more\n     * NaN parts and if either this or <code>rhs</code> has one or more\n     * infinite parts (same result is returned regardless of the sign of the\n     * components).\n     * </p>\n     * <p>\n     * Returns finite values in components of the result per the\n     * definitional formula in all remaining cases.\n     *  </p>\n     *\n     * @param rhs the scalar number\n     * @return the complex number product\n     */\n    public Complex multiply(double rhs) {\n        if (isNaN || Double.isNaN(rhs)) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs)) {\n            // we don't use Complex.isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * rhs, imaginary * rhs);\n    }\n\n    /**\n     * Return the additive inverse of this complex number.\n     * <p>\n     * Returns <code>Complex.NaN</code> if either real or imaginary\n     * part of this Complex number equals <code>Double.NaN</code>.</p>\n     *\n     * @return the negation of this complex number\n     */\n    public Complex negate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(-real, -imaginary);\n    }\n\n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n      * <p>\n     * Uses the definitional formula\n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise infinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     *\n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullArgumentException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        if (isNaN || rhs.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n     * inverse cosine</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code> or infinite.</p>\n     *\n     * @return the inverse cosine of this complex number\n     * @since 1.2\n     */\n    public Complex acos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n     * inverse sine</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code> or infinite.</p>\n     *\n     * @return the inverse sine of this complex number.\n     * @since 1.2\n     */\n    public Complex asin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return sqrt1z().add(this.multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n     * inverse tangent</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code> or infinite.</p>\n     *\n     * @return the inverse tangent of this complex number\n     * @since 1.2\n     */\n    public Complex atan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n     * cosine</a>\n     * of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i\n     * cos(&plusmn;INFINITY + i) = NaN + NaN i\n     * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     *\n     * @return the cosine of this complex number\n     * @since 1.2\n     */\n    public Complex cos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cos(real) * MathUtils.cosh(imaginary),\n            -FastMath.sin(real) * MathUtils.sinh(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n     * hyperbolic cosine</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n     * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n     * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     *\n     * @return the hyperbolic cosine of this complex number.\n     * @since 1.2\n     */\n    public Complex cosh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(MathUtils.cosh(real) * FastMath.cos(imaginary),\n            MathUtils.sinh(real) * FastMath.sin(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n     * exponential function</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and\n     * {@link java.lang.Math#sin}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * exp(1 &plusmn; INFINITY i) = NaN + NaN i\n     * exp(INFINITY + i) = INFINITY + INFINITY i\n     * exp(-INFINITY + i) = 0 + 0i\n     * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     *\n     * @return <i>e</i><sup><code>this</code></sup>\n     * @since 1.2\n     */\n    public Complex exp() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double expReal = FastMath.exp(real);\n        return createComplex(expReal *  FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n     * natural logarithm</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> log(a + bi) = ln(|a + bi|) + arg(a + bi)i</code></pre>\n     * where ln on the right hand side is {@link java.lang.Math#log},\n     * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and\n     * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite (or critical) values in real or imaginary parts of the input may\n     * result in infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n     * log(INFINITY + i) = INFINITY + 0i\n     * log(-INFINITY + i) = INFINITY + &pi;i\n     * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n     * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n     * log(0 + 0i) = -INFINITY + 0i\n     * </code></pre></p>\n     *\n     * @return ln of this complex number.\n     * @since 1.2\n     */\n    public Complex log() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.log(abs()),\n            FastMath.atan2(imaginary, real));\n    }\n\n    /**\n     * Returns of value of this complex number raised to the power of <code>x</code>.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre>\n     * where <code>exp</code> and <code>log</code> are {@link #exp} and\n     * {@link #log}, respectively.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code> or infinite, or if <code>y</code>\n     * equals {@link Complex#ZERO}.</p>\n     *\n     * @param x the exponent.\n     * @return <code>this</code><sup><code>x</code></sup>\n     * @throws NullArgumentException if x is null\n     * @since 1.2\n     */\n    public Complex pow(Complex x)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(x);\n        return this.log().multiply(x).exp();\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n     * sine</a>\n     * of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n     * sin(&plusmn;INFINITY + i) = NaN + NaN i\n     * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     *\n     * @return the sine of this complex number.\n     * @since 1.2\n     */\n    public Complex sin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sin(real) * MathUtils.cosh(imaginary),\n            FastMath.cos(real) * MathUtils.sinh(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n     * hyperbolic sine</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n     * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n     * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     *\n     * @return the hyperbolic sine of this complex number\n     * @since 1.2\n     */\n    public Complex sinh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(MathUtils.sinh(real) * FastMath.cos(imaginary),\n            MathUtils.cosh(real) * FastMath.sin(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n     * square root</a> of this complex number.\n     * <p>\n     * Implements the following algorithm to compute <code>sqrt(a + bi)</code>:\n     * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>\n     * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>\n     *  else return <code>|b|/2t + sign(b)t i </code></pre></li>\n     * </ol>\n     * where <ul>\n     * <li><code>|a| = {@link Math#abs}(a)</code></li>\n     * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>\n     * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>\n     * </ul></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n     * sqrt(INFINITY + i) = INFINITY + 0i\n     * sqrt(-INFINITY + i) = 0 + INFINITY i\n     * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n     * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n     * </code></pre></p>\n     *\n     * @return the square root of this complex number\n     * @since 1.2\n     */\n    public Complex sqrt() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n\n        double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n                MathUtils.indicator(imaginary) * t);\n        }\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n     * square root</a> of 1 - <code>this</code><sup>2</sup> for this complex\n     * number.\n     * <p>\n     * Computes the result directly as\n     * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.</p>\n     *\n     * @return the square root of 1 - <code>this</code><sup>2</sup>\n     * @since 1.2\n     */\n    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n     * tangent</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite (or critical) values in real or imaginary parts of the input may\n     * result in infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * tan(1 &plusmn; INFINITY i) = 0 + NaN i\n     * tan(&plusmn;INFINITY + i) = NaN + NaN i\n     * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>\n     *\n     * @return the tangent of this complex number\n     * @since 1.2\n     */\n    public Complex tan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cos(real2) + MathUtils.cosh(imaginary2);\n\n        return createComplex(FastMath.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n     * hyperbolic tangent</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples:\n     * <code>\n     * tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n     * tanh(&plusmn;INFINITY + i) = NaN + 0 i\n     * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre></p>\n     *\n     * @return the hyperbolic tangent of this complex number\n     * @since 1.2\n     */\n    public Complex tanh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);\n\n        return createComplex(MathUtils.sinh(real2) / d, FastMath.sin(imaginary2) / d);\n    }\n\n\n\n    /**\n     * <p>Compute the argument of this complex number.\n     * </p>\n     * <p>The argument is the angle phi between the positive real axis and the point\n     * representing this number in the complex plane. The value returned is between -PI (not inclusive)\n     * and PI (inclusive), with negative values returned for numbers with negative imaginary parts.\n     * </p>\n     * <p>If either real or imaginary part (or both) is NaN, NaN is returned.  Infinite parts are handled\n     * as java.Math.atan2 handles them, essentially treating finite parts as zero in the presence of\n     * an infinite coordinate and returning a multiple of pi/4 depending on the signs of the infinite\n     * parts.  See the javadoc for java.Math.atan2 for full details.</p>\n     *\n     * @return the argument of this complex number\n     */\n    public double getArgument() {\n        return FastMath.atan2(getImaginary(), getReal());\n    }\n\n    /**\n     * <p>Computes the n-th roots of this complex number.\n     * </p>\n     * <p>The nth roots are defined by the formula: <pre>\n     * <code> z<sub>k</sub> = abs<sup> 1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))</code></pre>\n     * for <i><code>k=0, 1, ..., n-1</code></i>, where <code>abs</code> and <code>phi</code> are\n     * respectively the {@link #abs() modulus} and {@link #getArgument() argument} of this complex number.\n     * </p>\n     * <p>If one or both parts of this complex number is NaN, a list with just one element,\n     *  {@link #NaN} is returned.</p>\n     * <p>if neither part is NaN, but at least one part is infinite, the result is a one-element\n     * list containing {@link #INF}.</p>\n     *\n     * @param n degree of root\n     * @return List<Complex> all nth roots of this complex number\n     * @throws IllegalArgumentException if parameter n is less than or equal to 0\n     * @since 2.0\n     */\n    public List<Complex> nthRoot(int n) throws IllegalArgumentException {\n\n        if (n <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                    n);\n        }\n\n        List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN) {\n            result.add(NaN);\n            return result;\n        }\n\n        if (isInfinite()) {\n            result.add(INF);\n            return result;\n        }\n\n        // nth root of abs -- faster / more accurate to use a solver here?\n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        // Compute nth roots of complex number with k = 0, 1, ... n-1\n        final double nthPhi = getArgument()/n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n ; k++) {\n            // inner part\n            final double realPart      = nthRootOfAbs *  FastMath.cos(innerPart);\n            final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n            result.add(createComplex(realPart, imaginaryPart));\n            innerPart += slice;\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param realPart the real part\n     * @param imaginaryPart the imaginary part\n     * @return a new complex number instance\n     * @since 1.2\n     */\n    protected Complex createComplex(double realPart, double imaginaryPart) {\n        return new Complex(realPart, imaginaryPart);\n    }\n\n    /**\n     * <p>Resolve the transient fields in a deserialized Complex Object.</p>\n     * <p>Subclasses will need to override {@link #createComplex} to deserialize properly</p>\n     * @return A Complex instance with all fields resolved.\n     * @since 2.0\n     */\n    protected final Object readResolve() {\n        return createComplex(real, imaginary);\n    }\n\n    /** {@inheritDoc} */\n    public ComplexField getField() {\n        return ComplexField.getInstance();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String toString() {\n        return \"(\" + real + \", \" + imaginary + \")\";\n    }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"type\": \"Potential NPE\",\n         \"description\": \"In the add method, the method MathUtils.checkNotNull(rhs) is called, but rhs is not checked for null before calling getReal() and getImaginary() methods.\",\n         \"location\": \"Complex.java:142\"\n      },\n      {\n         \"type\": \"Potential Division by Zero\",\n         \"description\": \"In the abs method, a division by imaginary is performed when calculating the absolute value of a complex number with zero imaginary part.\",\n         \"location\": \"Complex.java:67\"\n      },\n      {\n         \"type\": \"Potential Overflow\",\n         \"description\": \"In the abs method, a potential overflow can occur when calculating the absolute value of a complex number with very large real and imaginary parts.\",\n         \"location\": \"Complex.java:67\"\n      },\n      {\n         \"type\": \"Potential NaN Propagation\",\n         \"description\": \"In the add method, NaN values in the real or imaginary parts of the complex numbers are not handled correctly, leading to potential NaN propagation.\",\n         \"location\": \"Complex.java:142\"\n      }\n   ]\n}"}}