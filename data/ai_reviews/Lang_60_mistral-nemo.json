{"sample_id": "Lang_60", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang.text;\n\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.commons.lang.ArrayUtils;\nimport org.apache.commons.lang.SystemUtils;\n\n/**\n * Builds a string from constituent parts providing a more flexible and powerful API\n * than StringBuffer.\n * <p>\n * The main differences from StringBuffer/StringBuilder are:\n * <ul>\n * <li>Not synchronized</li>\n * <li>Not final</li>\n * <li>Subclasses have direct access to character array</li>\n * <li>Additional methods\n *  <ul>\n *   <li>appendWithSeparators - adds an array of values, with a separator</li>\n *   <li>appendPadding - adds a length padding characters</li>\n *   <li>appendFixedLength - adds a fixed width field to the builder</li>\n *   <li>toCharArray/getChars - simpler ways to get a range of the character array</li>\n *   <li>delete - delete char or string</li>\n *   <li>replace - search and replace for a char or string</li>\n *   <li>leftString/rightString/midString - substring without exceptions</li>\n *   <li>contains - whether the builder contains a char or string</li>\n *   <li>size/clear/isEmpty - collections style API methods</li>\n *  </ul>\n * </li>\n * </ul>\n * <li>Views\n *  <ul>\n *   <li>asTokenizer - uses the internal buffer as the source of a StrTokenizer</li>\n *   <li>asReader - uses the internal buffer as the source of a Reader</li>\n *   <li>asWriter - allows a Writer to write directly to the internal buffer</li>\n *  </ul>\n * </li>\n * </ul>\n * <p>\n * The aim has been to provide an API that mimics very closely what StringBuffer\n * provides, but with additional methods. It should be noted that some edge cases,\n * with invalid indices or null input, have been altered - see individual methods.\n * The biggest of these changes is that by default, null will not output the text\n * 'null'. This can be controlled by a property, {@link #setNullText(String)}.\n *\n * @author Stephen Colebourne\n * @since 2.2\n * @version $Id$\n */\npublic class StrBuilder implements Cloneable {\n\n    /**\n     * The extra capacity for new builders.\n     */\n    static final int CAPACITY = 32;\n\n    /**\n     * Required for serialization support.\n     * \n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 7628716375283629643L;\n\n    /** Internal data storage. */\n    protected char[] buffer;\n    /** Current size of the buffer. */\n    protected int size;\n    /** The new line. */\n    private String newLine;\n    /** The null text. */\n    private String nullText;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructor that creates an empty builder initial capacity 32 characters.\n     */\n    public StrBuilder() {\n        this(CAPACITY);\n    }\n\n    /**\n     * Constructor that creates an empty builder the specified initial capacity.\n     *\n     * @param initialCapacity  the initial capacity, zero or less will be converted to 32\n     */\n    public StrBuilder(int initialCapacity) {\n        super();\n        if (initialCapacity <= 0) {\n            initialCapacity = CAPACITY;\n        }\n        buffer = new char[initialCapacity];\n    }\n\n    /**\n     * Constructor that creates a builder from the string, allocating\n     * 32 extra characters for growth.\n     *\n     * @param str  the string to copy, null treated as blank string\n     */\n    public StrBuilder(String str) {\n        super();\n        if (str == null) {\n            buffer = new char[CAPACITY];\n        } else {\n            buffer = new char[str.length() + CAPACITY];\n            append(str);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the text to be appended when a new line is added.\n     *\n     * @return the new line text, null means use system default\n     */\n    public String getNewLineText() {\n        return newLine;\n    }\n\n    /**\n     * Sets the text to be appended when a new line is added.\n     *\n     * @param newLine  the new line text, null means use system default\n     * @return this, to enable chaining\n     */\n    public StrBuilder setNewLineText(String newLine) {\n        this.newLine = newLine;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the text to be appended when null is added.\n     *\n     * @return the null text, null means no append\n     */\n    public String getNullText() {\n        return nullText;\n    }\n\n    /**\n     * Sets the text to be appended when null is added.\n     *\n     * @param nullText  the null text, null means no append\n     * @return this, to enable chaining\n     */\n    public StrBuilder setNullText(String nullText) {\n        if (nullText != null && nullText.length() == 0) {\n            nullText = null;\n        }\n        this.nullText = nullText;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the length of the string builder.\n     *\n     * @return the length\n     */\n    public int length() {\n        return size;\n    }\n\n    /**\n     * Updates the length of the builder by either dropping the last characters\n     * or adding filler of unicode zero.\n     *\n     * @param length  the length to set to, must be zero or positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the length is negative\n     */\n    public StrBuilder setLength(int length) {\n        if (length < 0) {\n            throw new StringIndexOutOfBoundsException(length);\n        }\n        if (length < size) {\n            size = length;\n        } else if (length > size) {\n            ensureCapacity(length);\n            int oldEnd = size;\n            int newEnd = length;\n            size = length;\n            for (int i = oldEnd; i < newEnd; i++) {\n                buffer[i] = '\\0';\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the current size of the internal character array buffer.\n     *\n     * @return the capacity\n     */\n    public int capacity() {\n        return buffer.length;\n    }\n\n    /**\n     * Checks the capacity and ensures that it is at least the size specified.\n     *\n     * @param capacity  the capacity to ensure\n     * @return this, to enable chaining\n     */\n    public StrBuilder ensureCapacity(int capacity) {\n        if (capacity > buffer.length) {\n            char[] old = buffer;\n            buffer = new char[capacity];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }\n\n    /**\n     * Minimizes the capacity to the actual length of the string.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder minimizeCapacity() {\n        if (buffer.length > length()) {\n            char[] old = buffer;\n            buffer = new char[length()];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the length of the string builder.\n     * <p>\n     * This method is the same as {@link #length()} and is provided to match the\n     * API of Collections.\n     *\n     * @return the length\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Checks is the string builder is empty (convenience Collections API style method).\n     * <p>\n     * This method is the same as checking {@link #length()} and is provided to match the\n     * API of Collections.\n     *\n     * @return <code>true</code> if the size is <code>0</code>.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Clears the string builder (convenience Collections API style method).\n     * <p>\n     * This method does not reduce the size of the internal character buffer.\n     * To do that, call <code>clear()</code> followed by {@link #minimizeCapacity()}.\n     * <p>\n     * This method is the same as {@link #setLength(int)} called with zero\n     * and is provided to match the API of Collections.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder clear() {\n        size = 0;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the character at the specified index.\n     *\n     * @see #setCharAt(int, char)\n     * @see #deleteCharAt(int)\n     * @param index  the index to retrieve, must be valid\n     * @return the character at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public char charAt(int index) {\n        if (index < 0 || index >= length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        return buffer[index];\n    }\n\n    /**\n     * Sets the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index  the index to set\n     * @param ch  the new character\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder setCharAt(int index, char ch) {\n        if (index < 0 || index >= length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        buffer[index] = ch;\n        return this;\n    }\n\n    /**\n     * Deletes the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #setCharAt(int, char)\n     * @param index  the index to delete\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder deleteCharAt(int index) {\n        if (index < 0 || index >= size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        deleteImpl(index, index + 1, 1);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Copies the builder's character array into a new character array.\n     * \n     * @return a new array that represents the contents of the builder\n     */\n    public char[] toCharArray() {\n        if (size == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char chars[] = new char[size];\n        System.arraycopy(buffer, 0, chars, 0, size);\n        return chars;\n    }\n\n    /**\n     * Copies part of the builder's character array into a new character array.\n     * \n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except that\n     *  if too large it is treated as end of string\n     * @return a new array that holds part of the contents of the builder\n     * @throws IndexOutOfBoundsException if startIndex is invalid,\n     *  or if endIndex is invalid (but endIndex greater than size is valid)\n     */\n    public char[] toCharArray(int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        int len = endIndex - startIndex;\n        if (len == 0) {\n            return ArrayUtils.EMPTY_CHAR_ARRAY;\n        }\n        char chars[] = new char[len];\n        System.arraycopy(buffer, startIndex, chars, 0, len);\n        return chars;\n    }\n\n    /**\n     * Copies the character array into the specified array.\n     * \n     * @param destination  the destination array, null will cause an array to be created\n     * @return the input array, unless that was null or too small\n     */\n    public char[] getChars(char[] destination) {\n        int len = length();\n        if (destination == null || destination.length < len) {\n            destination = new char[len];\n        }\n        System.arraycopy(buffer, 0, destination, 0, len);\n        return destination;\n    }\n\n    /**\n     * Copies the character array into the specified array.\n     *\n     * @param startIndex  first index to copy, inclusive, must be valid\n     * @param endIndex  last index, exclusive, must be valid\n     * @param destination  the destination array, must not be null or too small\n     * @param destinationIndex  the index to start copying in destination\n     * @throws NullPointerException if the array is null\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    public void getChars(int startIndex, int endIndex, char destination[], int destinationIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex < 0 || endIndex > length()) {\n            throw new StringIndexOutOfBoundsException(endIndex);\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the new line string to this string builder.\n     * <p>\n     * The new line string can be altered using {@link #setNewLineText(String)}.\n     * This might be used to force the output to always use Unix line endings\n     * even when on Windows.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendNewLine() {\n        if (newLine == null)  {\n            append(SystemUtils.LINE_SEPARATOR);\n            return this;\n        }\n        return append(newLine);\n    }\n\n    /**\n     * Appends the text representing <code>null</code> to this string builder.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendNull() {\n        if (nullText == null)  {\n            return this;\n        }\n        return append(nullText);\n    }\n\n    /**\n     * Appends an object to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param obj  the object to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(Object obj) {\n        if (obj == null) {\n            return appendNull();\n        } \n        return append(obj.toString());        \n    }\n\n    /**\n     * Appends a string to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(String str) {\n        if (str == null) {\n            return appendNull();\n        }\n        int strLen = str.length();\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            str.getChars(0, strLen, buffer, len);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends part of a string to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(String str, int startIndex, int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || (startIndex + length) > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a string buffer to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string buffer to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(StringBuffer str) {\n        if (str == null) {\n            return appendNull();\n        }\n        int strLen = str.length();\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            str.getChars(0, strLen, buffer, len);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends part of a string buffer to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(StringBuffer str, int startIndex, int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || (startIndex + length) > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends another string builder to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string builder to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(StrBuilder str) {\n        if (str == null) {\n            return appendNull();\n        }\n        int strLen = str.length();\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(str.buffer, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends part of a string builder to this string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param str  the string to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(StrBuilder str, int startIndex, int length) {\n        if (str == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n        }\n        if (length < 0 || (startIndex + length) > str.length()) {\n            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            str.getChars(startIndex, startIndex + length, buffer, len);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char array to the string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param chars  the char array to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(char[] chars) {\n        if (chars == null) {\n            return appendNull();\n        }\n        int strLen = chars.length;\n        if (strLen > 0) {\n            int len = length();\n            ensureCapacity(len + strLen);\n            System.arraycopy(chars, 0, buffer, len, strLen);\n            size += strLen;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char array to the string builder.\n     * Appending null will call {@link #appendNull()}.\n     *\n     * @param chars  the char array to append\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param length  the length to append, must be valid\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(char[] chars, int startIndex, int length) {\n        if (chars == null) {\n            return appendNull();\n        }\n        if (startIndex < 0 || startIndex > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + length);\n        }\n        if (length < 0 || (startIndex + length) > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            int len = length();\n            ensureCapacity(len + length);\n            System.arraycopy(chars, startIndex, buffer, len, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Appends a boolean value to the string builder.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(boolean value) {\n        if (value) {\n            ensureCapacity(size + 4);\n            buffer[size++] = 't';\n            buffer[size++] = 'r';\n            buffer[size++] = 'u';\n            buffer[size++] = 'e';\n        } else {\n            ensureCapacity(size + 5);\n            buffer[size++] = 'f';\n            buffer[size++] = 'a';\n            buffer[size++] = 'l';\n            buffer[size++] = 's';\n            buffer[size++] = 'e';\n        }\n        return this;\n    }\n\n    /**\n     * Appends a char value to the string builder.\n     *\n     * @param ch  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(char ch) {\n        int len = length();\n        ensureCapacity(len + 1);\n        buffer[size++] = ch;\n        return this;\n    }\n\n    /**\n     * Appends an int value to the string builder using <code>String.valueOf</code>.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(int value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a long value to the string builder using <code>String.valueOf</code>.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(long value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a float value to the string builder using <code>String.valueOf</code>.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(float value) {\n        return append(String.valueOf(value));\n    }\n\n    /**\n     * Appends a double value to the string builder using <code>String.valueOf</code>.\n     *\n     * @param value  the value to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder append(double value) {\n        return append(String.valueOf(value));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends an array placing separators between each value, but\n     * not before the first or after the last.\n     * Appending a null array will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param array  the array to append\n     * @param separator  the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendWithSeparators(Object[] array, String separator) {\n        if (array != null && array.length > 0) {\n            separator = (separator == null ? \"\" : separator);\n            append(array[0]);\n            for (int i = 1; i < array.length; i++) {\n                append(separator);\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends a collection placing separators between each value, but\n     * not before the first or after the last.\n     * Appending a null collection will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param coll  the collection to append\n     * @param separator  the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendWithSeparators(Collection coll, String separator) {\n        if (coll != null && coll.size() > 0) {\n            separator = (separator == null ? \"\" : separator);\n            Iterator it = coll.iterator();\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(separator);\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Appends an iterator placing separators between each value, but\n     * not before the first or after the last.\n     * Appending a null iterator will have no effect.\n     * Each object is appended using {@link #append(Object)}.\n     *\n     * @param it  the iterator to append\n     * @param separator  the separator to use, null means no separator\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendWithSeparators(Iterator it, String separator) {\n        if (it != null) {\n            separator = (separator == null ? \"\" : separator);\n            while (it.hasNext()) {\n                append(it.next());\n                if (it.hasNext()) {\n                    append(separator);\n                }\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends the pad character to the builder the specified number of times.\n     * \n     * @param length  the length to append, negative means no append\n     * @param padChar  the character to append\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendPadding(int length, char padChar) {\n        if (length >= 0) {\n            ensureCapacity(size + length);\n            for (int i = 0; i < length; i++) {\n                buffer[size++] = padChar;\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the left hand side is lost.\n     * If the object is null, the null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(strLen - width, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the left to a fixed width.\n     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n     * If the formatted value is larger than the length, the left hand side is lost.\n     * \n     * @param value  the value to append\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadLeft(int value, int width, char padChar) {\n        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>toString</code> of the object is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * If the object is null, null text value is used.\n     * \n     * @param obj  the object to append, null uses null text\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }\n\n    /**\n     * Appends an object to the builder padding on the right to a fixed length.\n     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n     * If the object is larger than the length, the right hand side is lost.\n     * \n     * @param value  the value to append\n     * @param width  the fixed field width, zero or negative has no effect\n     * @param padChar  the pad character to use\n     * @return this, to enable chaining\n     */\n    public StrBuilder appendFixedWidthPadRight(int value, int width, char padChar) {\n        return appendFixedWidthPadRight(String.valueOf(value), width, padChar);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inserts the string representation of an object into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param obj  the object to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, Object obj) {\n        if (obj == null) {\n            return insert(index, nullText);\n        }\n        return insert(index, obj.toString());\n    }\n\n    /**\n     * Inserts the string into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param str  the string to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, String str) {\n        validateIndex(index);\n        if (str == null) {\n            str = nullText;\n        }\n        int strLen = (str == null ? 0 : str.length());\n        if (strLen > 0) {\n            int newSize = size + strLen;\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n            size = newSize;\n            str.getChars(0, strLen, buffer, index);\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the character array into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param chars  the char array to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, char chars[]) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        int len = chars.length;\n        if (len > 0) {\n            ensureCapacity(size + len);\n            System.arraycopy(buffer, index, buffer, index + len, size - index);\n            System.arraycopy(chars, 0, buffer, index, len);\n            size += len;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts part of the character array into this builder.\n     * Inserting null will use the stored null text value.\n     *\n     * @param index  the index to add at, must be valid\n     * @param chars  the char array to insert\n     * @param offset  the offset into the character array to start at, must be valid\n     * @param length  the length of the character array part to copy, must be positive\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    public StrBuilder insert(int index, char chars[], int offset, int length) {\n        validateIndex(index);\n        if (chars == null) {\n            return insert(index, nullText);\n        }\n        if (offset < 0 || offset > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n        }\n        if (length < 0 || offset + length > chars.length) {\n            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n        }\n        if (length > 0) {\n            ensureCapacity(size + length);\n            System.arraycopy(buffer, index, buffer, index + length, size - index);\n            System.arraycopy(chars, offset, buffer, index, length);\n            size += length;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, boolean value) {\n        validateIndex(index);\n        if (value) {\n            ensureCapacity(size + 4);\n            System.arraycopy(buffer, index, buffer, index + 4, size - index);\n            buffer[index++] = 't';\n            buffer[index++] = 'r';\n            buffer[index++] = 'u';\n            buffer[index] = 'e';\n            size += 4;\n        } else {\n            ensureCapacity(size + 5);\n            System.arraycopy(buffer, index, buffer, index + 5, size - index);\n            buffer[index++] = 'f';\n            buffer[index++] = 'a';\n            buffer[index++] = 'l';\n            buffer[index++] = 's';\n            buffer[index] = 'e';\n            size += 5;\n        }\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, char value) {\n        validateIndex(index);\n        ensureCapacity(size + 1);\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n        buffer[index] = value;\n        size++;\n        return this;\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, int value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, long value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, float value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    /**\n     * Inserts the value into this builder.\n     *\n     * @param index  the index to add at, must be valid\n     * @param value  the value to insert\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder insert(int index, double value) {\n        return insert(index, String.valueOf(value));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex  the start index, must be valid\n     * @param endIndex  the end index (exclusive), must be valid\n     * @param len  the length, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void deleteImpl(int startIndex, int endIndex, int len) {\n        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n        size -= len;\n    }\n\n    /**\n     * Deletes the characters between the two specified indices.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder delete(int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        int len = endIndex - startIndex;\n        if (len > 0) {\n            deleteImpl(startIndex, endIndex, len);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                int start = i;\n                while (++i < size) {\n                    if (buffer[i] != ch) {\n                        break;\n                    }\n                }\n                int len = i - start;\n                deleteImpl(start, i, len);\n                i -= len;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the character wherever it occurs in the builder.\n     *\n     * @param ch  the character to delete\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(char ch) {\n        for (int i = 0; i < size; i++) {\n            if (buffer[i] == ch) {\n                deleteImpl(i, i + 1, 1);\n                break;\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str  the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(String str) {\n        int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            while (index >= 0) {\n                deleteImpl(index, index + len, len);\n                index = indexOf(str, index);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Deletes the string wherever it occurs in the builder.\n     *\n     * @param str  the string to delete, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(String str) {\n        int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Deletes all parts of the builder that the matcher matches.\n     * <p>\n     * Matchers can be used to perform advanced deletion behaviour.\n     * For example you could write a matcher to delete all occurances\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteAll(StrMatcher matcher) {\n        return replace(matcher, null, 0, size, -1);\n    }\n\n    /**\n     * Deletes the first match within the builder using the specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced deletion behaviour.\n     * For example you could write a matcher to delete\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @return this, to enable chaining\n     */\n    public StrBuilder deleteFirst(StrMatcher matcher) {\n        return replace(matcher, null, 0, size, 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Internal method to delete a range without validation.\n     *\n     * @param startIndex  the start index, must be valid\n     * @param endIndex  the end index (exclusive), must be valid\n     * @param removeLen  the length to remove (endIndex - startIndex), must be valid\n     * @param insertStr  the string to replace with, null means delete range\n     * @param insertLen  the length of the insert string, must be valid\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private void replaceImpl(int startIndex, int endIndex, int removeLen, String insertStr, int insertLen) {\n        int newSize = size - removeLen + insertLen;\n        if (insertLen != removeLen) {\n            ensureCapacity(newSize);\n            System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n            size = newSize;\n        }\n        if (insertLen > 0) {\n            insertStr.getChars(0, insertLen, buffer, startIndex);\n        }\n    }\n\n    /**\n     * Replaces a portion of the string builder with another string.\n     * The length of the inserted string does not have to match the removed length.\n     *\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @param replaceStr  the string to replace with, null means delete range\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public StrBuilder replace(int startIndex, int endIndex, String replaceStr) {\n        endIndex = validateRange(startIndex, endIndex);\n        int insertLen = (replaceStr == null ? 0 : replaceStr.length());\n        replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces the search character with the replace character\n     * throughout the builder.\n     *\n     * @param search  the search character\n     * @param replace  the replace character\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(char search, char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first instance of the search character with the\n     * replace character in the builder.\n     *\n     * @param search  the search character\n     * @param replace  the replace character\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(char search, char replace) {\n        if (search != replace) {\n            for (int i = 0; i < size; i++) {\n                if (buffer[i] == search) {\n                    buffer[i] = replace;\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces the search string with the replace string throughout the builder.\n     *\n     * @param searchStr  the search string, null causes no action to occur\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(String searchStr, String replaceStr) {\n        int searchLen = (searchStr == null ? 0 : searchStr.length());\n        if (searchLen > 0) {\n            int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n            int index = indexOf(searchStr, 0);\n            while (index >= 0) {\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n                index = indexOf(searchStr, index + replaceLen);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Replaces the first instance of the search string with the replace string.\n     *\n     * @param searchStr  the search string, null causes no action to occur\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(String searchStr, String replaceStr) {\n        int searchLen = (searchStr == null ? 0 : searchStr.length());\n        if (searchLen > 0) {\n            int index = indexOf(searchStr, 0);\n            if (index >= 0) {\n                int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Replaces all matches within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behaviour.\n     * For example you could write a matcher to replace all occurances\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceAll(StrMatcher matcher, String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, -1);\n    }\n\n    /**\n     * Replaces the first match within the builder with the replace string.\n     * <p>\n     * Matchers can be used to perform advanced replace behaviour.\n     * For example you could write a matcher to replace\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the replace string, null is equivalent to an empty string\n     * @return this, to enable chaining\n     */\n    public StrBuilder replaceFirst(StrMatcher matcher, String replaceStr) {\n        return replace(matcher, replaceStr, 0, size, 1);\n    }\n\n    // -----------------------------------------------------------------------\n    /**\n     * Advanced search and replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behaviour.\n     * For example you could write a matcher to delete all occurances\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the string to replace the match with, null is a delete\n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @param replaceCount  the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if start index is invalid\n     */\n    public StrBuilder replace(\n            StrMatcher matcher, String replaceStr,\n            int startIndex, int endIndex, int replaceCount) {\n        endIndex = validateRange(startIndex, endIndex);\n        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n    }\n\n    /**\n     * Replaces within the builder using a matcher.\n     * <p>\n     * Matchers can be used to perform advanced behaviour.\n     * For example you could write a matcher to delete all occurances\n     * where the character 'a' is followed by a number.\n     *\n     * @param matcher  the matcher to use to find the deletion, null causes no action\n     * @param replaceStr  the string to replace the match with, null is a delete\n     * @param from  the start index, must be valid\n     * @param to  the end index (exclusive), must be valid\n     * @param replaceCount  the number of times to replace, -1 for replace all\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if any index is invalid\n     */\n    private StrBuilder replaceImpl(\n            StrMatcher matcher, String replaceStr,\n            int from, int to, int replaceCount) {\n        if (matcher == null || size == 0) {\n            return this;\n        }\n        int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n        char[] buf = buffer;\n        for (int i = from; i < to && replaceCount != 0; i++) {\n            int removeLen = matcher.isMatch(buf, i, from, to);\n            if (removeLen > 0) {\n                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n                to = to - removeLen + replaceLen;\n                i = i + replaceLen - 1;\n                if (replaceCount > 0) {\n                    replaceCount--;\n                }\n            }\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Reverses the string builder placing each character in the opposite index.\n     * \n     * @return this, to enable chaining\n     */\n    public StrBuilder reverse() {\n        if (size == 0) {\n            return this;\n        }\n        \n        int half = size / 2;\n        char[] buf = buffer;\n        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++,rightIdx--) {\n            char swap = buf[leftIdx];\n            buf[leftIdx] = buf[rightIdx];\n            buf[rightIdx] = swap;\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Trims the builder by removing characters less than or equal to a space\n     * from the beginning and end.\n     *\n     * @return this, to enable chaining\n     */\n    public StrBuilder trim() {\n        if (size == 0) {\n            return this;\n        }\n        int len = size;\n        char[] buf = buffer;\n        int pos = 0;\n        while (pos < len && buf[pos] <= ' ') {\n            pos++;\n        }\n        while (pos < len && buf[len - 1] <= ' ') {\n            len--;\n        }\n        if (len < size) {\n            delete(len, size);\n        }\n        if (pos > 0) {\n            delete(0, pos);\n        }\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks whether this builder starts with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * \n     * @param str  the string to search for, null returns false\n     * @return true if the builder starts with the string\n     */\n    public boolean startsWith(String str) {\n        if (str == null) {\n            return false;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        for (int i = 0; i < len; i++) {\n            if (buffer[i] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks whether this builder ends with the specified string.\n     * <p>\n     * Note that this method handles null input quietly, unlike String.\n     * \n     * @param str  the string to search for, null returns false\n     * @return true if the builder ends with the string\n     */\n    public boolean endsWith(String str) {\n        if (str == null) {\n            return false;\n        }\n        int len = str.length();\n        if (len == 0) {\n            return true;\n        }\n        if (len > size) {\n            return false;\n        }\n        int pos = size - len;\n        for (int i = 0; i < len; i++,pos++) {\n            if (buffer[pos] != str.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Extracts a portion of this string builder as a string.\n     * \n     * @param start  the start index, inclusive, must be valid\n     * @return the new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public String substring(int start) {\n        return substring(start, size);\n    }\n\n    /**\n     * Extracts a portion of this string builder as a string.\n     * <p>\n     * Note: This method treats an endIndex greater than the length of the\n     * builder as equal to the length of the builder, and continues\n     * without error, unlike StringBuffer or String.\n     * \n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return the new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public String substring(int startIndex, int endIndex) {\n        endIndex = validateRange(startIndex, endIndex);\n        return new String(buffer, startIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Extracts the leftmost characters from the string builder without\n     * throwing an exception.\n     * <p>\n     * This method extracts the left <code>length</code> characters from\n     * the builder. If this many characters are not available, the whole\n     * builder is returned. Thus the returned string may be shorter than the\n     * length requested.\n     * \n     * @param length  the number of characters to extract, negative returns empty string\n     * @return the new string\n     */\n    public String leftString(int length) {\n        if (length <= 0) {\n            return \"\";\n        } else if (length >= size) {\n            return new String(buffer, 0, size);\n        } else {\n            return new String(buffer, 0, length);\n        }\n    }\n\n    /**\n     * Extracts the rightmost characters from the string builder without\n     * throwing an exception.\n     * <p>\n     * This method extracts the right <code>length</code> characters from\n     * the builder. If this many characters are not available, the whole\n     * builder is returned. Thus the returned string may be shorter than the\n     * length requested.\n     * \n     * @param length  the number of characters to extract, negative returns empty string\n     * @return the new string\n     */\n    public String rightString(int length) {\n        if (length <= 0) {\n            return \"\";\n        } else if (length >= size) {\n            return new String(buffer, 0, size);\n        } else {\n            return new String(buffer, size - length, length);\n        }\n    }\n\n    /**\n     * Extracts some characters from the middle of the string builder without\n     * throwing an exception.\n     * <p>\n     * This method extracts <code>length</code> characters from the builder\n     * at the specified index.\n     * If the index is negative it is treated as zero.\n     * If the index is greater than the builder size, it is treated as the builder size.\n     * If the length is negative, the empty string is returned.\n     * If insufficient characters are available in the builder, as much as possible is returned.\n     * Thus the returned string may be shorter than the length requested.\n     * \n     * @param index  the index to start at, negative means zero\n     * @param length  the number of characters to extract, negative returns empty string\n     * @return the new string\n     */\n    public String midString(int index, int length) {\n        if (index < 0) {\n            index = 0;\n        }\n        if (length <= 0 || index >= size) {\n            return \"\";\n        }\n        if (size <= index + length) {\n            return new String(buffer, index, size - index);\n        } else {\n            return new String(buffer, index, length);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the string builder contains the specified string.\n     *\n     * @param str  the string to find\n     * @return true if the builder contains the string\n     */\n    public boolean contains(String str) {\n        return indexOf(str, 0) >= 0;\n    }\n\n    /**\n     * Checks if the string builder contains a string matched using the\n     * specified matcher.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to search for the character\n     * 'a' followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @return true if the matcher finds a match in the builder\n     */\n    public boolean contains(StrMatcher matcher) {\n        return indexOf(matcher, 0) >= 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @return the first index of the character, or -1 if not found\n     */\n    public int indexOf(char ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the character, or -1 if not found\n     */\n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified string.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str) {\n        return indexOf(str, 0);\n    }\n\n    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            return startIndex;\n        }\n        if (strLen > size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        int len = size - strLen + 1;\n        outer:\n        for (int i = startIndex; i < len; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            return i;\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first match.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to find the character 'a'\n     * followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @return the first index matched, or -1 if not found\n     */\n    public int indexOf(StrMatcher matcher) {\n        return indexOf(matcher, 0);\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the first\n     * match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to find the character 'a'\n     * followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index matched, or -1 if not found\n     */\n    public int indexOf(StrMatcher matcher, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (matcher == null || startIndex >= size) {\n            return -1;\n        }\n        int len = size;\n        char[] buf = buffer;\n        for (int i = startIndex; i < len; i++) {\n            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Searches the string builder to find the last reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @return the last index of the character, or -1 if not found\n     */\n    public int lastIndexOf(char ch) {\n        return lastIndexOf(ch, size - 1);\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the last index of the character, or -1 if not found\n     */\n    public int lastIndexOf(char ch, int startIndex) {\n        startIndex = (startIndex >= size ? size - 1 : startIndex);\n        if (startIndex < 0) {\n            return -1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (buffer[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified string.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @return the last index of the string, or -1 if not found\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, size - 1);\n    }\n\n    /**\n     * Searches the string builder to find the last reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the last index of the string, or -1 if not found\n     */\n    public int lastIndexOf(String str, int startIndex) {\n        startIndex = (startIndex >= size ? size - 1 : startIndex);\n        if (str == null || startIndex < 0) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen > 0 && strLen <= size) {\n            if (strLen == 1) {\n                return lastIndexOf(str.charAt(0), startIndex);\n            }\n\n            outer:\n            for (int i = startIndex - strLen + 1; i >= 0; i--) {\n                for (int j = 0; j < strLen; j++) {\n                    if (str.charAt(j) != buffer[i + j]) {\n                        continue outer;\n                    }\n                }\n                return i;\n            }\n            \n        } else if (strLen == 0) {\n            return startIndex;\n        }\n        return -1;\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the last match.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to find the character 'a'\n     * followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @return the last index matched, or -1 if not found\n     */\n    public int lastIndexOf(StrMatcher matcher) {\n        return lastIndexOf(matcher, size);\n    }\n\n    /**\n     * Searches the string builder using the matcher to find the last\n     * match searching from the given index.\n     * <p>\n     * Matchers can be used to perform advanced searching behaviour.\n     * For example you could write a matcher to find the character 'a'\n     * followed by a number.\n     *\n     * @param matcher  the matcher to use, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the last index matched, or -1 if not found\n     */\n    public int lastIndexOf(StrMatcher matcher, int startIndex) {\n        startIndex = (startIndex >= size ? size - 1 : startIndex);\n        if (matcher == null || startIndex < 0) {\n            return -1;\n        }\n        char[] buf = buffer;\n        int endIndex = startIndex + 1;\n        for (int i = startIndex; i >= 0; i--) {\n            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a tokenizer that can tokenize the contents of this builder.\n     * <p>\n     * This method allows the contents of this builder to be tokenized.\n     * The tokenizer will be setup by default to tokenize on space, tab,\n     * newline and formfeed (as per StringTokenizer). These values can be\n     * changed on the tokenizer class, before retrieving the tokens.\n     * <p>\n     * The returned tokenizer is linked to this builder. You may intermix\n     * calls to the buider and tokenizer within certain limits, however\n     * there is no synchronization. Once the tokenizer has been used once,\n     * it must be {@link StrTokenizer#reset() reset} to pickup the latest\n     * changes in the builder. For example:\n     * <pre>\n     * StrBuilder b = new StrBuilder();\n     * b.append(\"a b \");\n     * StrTokenizer t = b.asTokenizer();\n     * String[] tokens1 = t.getTokenArray();  // returns a,b\n     * b.append(\"c d \");\n     * String[] tokens2 = t.getTokenArray();  // returns a,b (c and d ignored)\n     * t.reset();              // reset causes builder changes to be picked up\n     * String[] tokens3 = t.getTokenArray();  // returns a,b,c,d\n     * </pre>\n     * In addition to simply intermixing appends and tokenization, you can also\n     * call the set methods on the tokenizer to alter how it tokenizes. Just\n     * remember to call reset when you want to pickup builder changes.\n     * <p>\n     * Calling {@link StrTokenizer#reset(String)} or {@link StrTokenizer#reset(char[])}\n     * with a non-null value will break the link with the builder.\n     *\n     * @return a tokenizer that is linked to this builder\n     */\n    public StrTokenizer asTokenizer() {\n        return new StrBuilderTokenizer();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the contents of this builder as a Reader.\n     * <p>\n     * This method allows the contents of the builder to be read\n     * using any standard method that expects a Reader.\n     * <p>\n     * To use, simply create a <code>StrBuilder</code>, populate it with\n     * data, call <code>asReader</code>, and then read away.\n     * <p>\n     * The internal character array is shared between the builder and the reader.\n     * This allows you to append to the builder after creating the reader,\n     * and the changes will be picked up.\n     * Note however, that no synchronization occurs, so you must perform\n     * all operations with the builder and the reader in one thread.\n     * <p>\n     * The returned reader supports marking, and ignores the flush method.\n     *\n     * @return a reader that reads from this builder\n     */\n    public Reader asReader() {\n        return new StrBuilderReader();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets this builder as a Writer that can be written to.\n     * <p>\n     * This method allows you to populate the contents of the builder\n     * using any standard method that takes a Writer.\n     * <p>\n     * To use, simply create a <code>StrBuilder</code>,\n     * call <code>asWriter</code>, and populate away. The data is available\n     * at any time using the methods of the <code>StrBuilder</code>.\n     * <p>\n     * The internal character array is shared between the builder and the writer.\n     * This allows you to intermix calls that append to the builder and\n     * write using the writer and the changes will be occur correctly.\n     * Note however, that no synchronization occurs, so you must perform\n     * all operations with the builder and the writer in one thread.\n     * <p>\n     * The returned writer ignores the close and flush methods.\n     *\n     * @return a writer that populates this builder\n     */\n    public Writer asWriter() {\n        return new StrBuilderWriter();\n    }\n\n    //-----------------------------------------------------------------------\n//    /**\n//     * Gets a String version of the string builder by calling the internal\n//     * constructor of String by reflection.\n//     * <p>\n//     * WARNING: You must not use the StrBuilder after calling this method\n//     * as the buffer is now shared with the String object. To ensure this,\n//     * the internal character array is set to null, so you will get\n//     * NullPointerExceptions on all method calls.\n//     *\n//     * @return the builder as a String\n//     */\n//    public String toSharedString() {\n//        try {\n//            Constructor con = String.class.getDeclaredConstructor(\n//                new Class[] {int.class, int.class, char[].class});\n//            con.setAccessible(true);\n//            char[] buffer = buf;\n//            buf = null;\n//            size = -1;\n//            nullText = null;\n//            return (String) con.newInstance(\n//                new Object[] {new Integer(0), new Integer(size), buffer});\n//            \n//        } catch (Exception ex) {\n//            ex.printStackTrace();\n//            throw new UnsupportedOperationException(\"StrBuilder.toSharedString is unsupported: \" + ex.getMessage());\n//        }\n//    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks the contents of this builder against another to see if they\n     * contain the same character content ignoring case.\n     *\n     * @param other  the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equalsIgnoreCase(StrBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        char thisBuf[] = this.buffer;\n        char otherBuf[] = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            char c1 = thisBuf[i];\n            char c2 = otherBuf[i];\n            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks the contents of this builder against another to see if they\n     * contain the same character content.\n     *\n     * @param other  the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equals(StrBuilder other) {\n        if (this == other) {\n            return true;\n        }\n        if (this.size != other.size) {\n            return false;\n        }\n        char thisBuf[] = this.buffer;\n        char otherBuf[] = other.buffer;\n        for (int i = size - 1; i >= 0; i--) {\n            if (thisBuf[i] != otherBuf[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks the contents of this builder against another to see if they\n     * contain the same character content.\n     *\n     * @param obj  the object to check, null returns false\n     * @return true if the builders contain the same characters in the same order\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof StrBuilder) {\n            return equals((StrBuilder) obj);\n        }\n        return false;\n    }\n\n    /**\n     * Gets a suitable hash code for this builder.\n     *\n     * @return a hash code\n     */\n    public int hashCode() {\n        char buf[] = buffer;\n        int hash = 0;\n        for (int i = size - 1; i >= 0; i--) {\n            hash = 31 * hash + buf[i];\n        }\n        return hash;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a String version of the string builder, creating a new instance\n     * each time the method is called.\n     * <p>\n     * Note that unlike StringBuffer, the string version returned is\n     * independent of the string builder.\n     *\n     * @return the builder as a String\n     */\n    public String toString() {\n        return new String(buffer, 0, size);\n    }\n\n    /**\n     * Gets a StringBuffer version of the string builder, creating a\n     * new instance each time the method is called.\n     *\n     * @return the builder as a StringBuffer\n     */\n    public StringBuffer toStringBuffer() {\n        return new StringBuffer(size).append(buffer, 0, size);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Validates parameters defining a range of the builder.\n     * \n     * @param startIndex  the start index, inclusive, must be valid\n     * @param endIndex  the end index, exclusive, must be valid except\n     *  that if too large it is treated as end of string\n     * @return the new string\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected int validateRange(int startIndex, int endIndex) {\n        if (startIndex < 0) {\n            throw new StringIndexOutOfBoundsException(startIndex);\n        }\n        if (endIndex > size) {\n            endIndex = size;\n        }\n        if (startIndex > endIndex) {\n            throw new StringIndexOutOfBoundsException(\"end < start\");\n        }\n        return endIndex;\n    }\n\n    /**\n     * Validates parameters defining a single index in the builder.\n     * \n     * @param index  the index, must be valid\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected void validateIndex(int index) {\n        if (index < 0 || index > size) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class to allow StrBuilder to operate as a tokenizer.\n     */\n    class StrBuilderTokenizer extends StrTokenizer {\n\n        /** {@inheritDoc} */\n        StrBuilderTokenizer() {\n            super();\n        }\n\n        /** {@inheritDoc} */\n        protected List tokenize(char[] chars, int offset, int count) {\n            if (chars == null) {\n                return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());\n            } else {\n                return super.tokenize(chars, offset, count);\n            }\n        }\n\n        /** {@inheritDoc} */\n        public String getContent() {\n            String str = super.getContent();\n            if (str == null) {\n                return StrBuilder.this.toString();\n            } else {\n                return str;\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class to allow StrBuilder to operate as a writer.\n     */\n    class StrBuilderReader extends Reader {\n        /** The current stream position. */\n        private int pos;\n        /** The last mark position. */\n        private int mark;\n\n        /** {@inheritDoc} */\n        StrBuilderReader() {\n            super();\n        }\n\n        /** {@inheritDoc} */\n        public void close() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        public int read() {\n            if (ready() == false) {\n                return -1;\n            }\n            return StrBuilder.this.charAt(pos++);\n        }\n\n        /** {@inheritDoc} */\n        public int read(char b[], int off, int len) {\n            if (off < 0 || len < 0 || off > b.length ||\n                    (off + len) > b.length || (off + len) < 0) {\n                throw new IndexOutOfBoundsException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            if (pos >= StrBuilder.this.size()) {\n                return -1;\n            }\n            if (pos + len > size()) {\n                len = StrBuilder.this.size() - pos;\n            }\n            StrBuilder.this.getChars(pos, pos + len, b, off);\n            pos += len;\n            return len;\n        }\n\n        /** {@inheritDoc} */\n        public long skip(long n) {\n            if (pos + n > StrBuilder.this.size()) {\n                n = StrBuilder.this.size() - pos;\n            }\n            if (n < 0) {\n                return 0;\n            }\n            pos += n;\n            return n;\n        }\n\n        /** {@inheritDoc} */\n        public boolean ready() {\n            return pos < StrBuilder.this.size();\n        }\n\n        /** {@inheritDoc} */\n        public boolean markSupported() {\n            return true;\n        }\n\n        /** {@inheritDoc} */\n        public void mark(int readAheadLimit) {\n            mark = pos;\n        }\n\n        /** {@inheritDoc} */\n        public void reset() {\n            pos = mark;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Inner class to allow StrBuilder to operate as a writer.\n     */\n    class StrBuilderWriter extends Writer {\n\n        /** {@inheritDoc} */\n        StrBuilderWriter() {\n            super();\n        }\n\n        /** {@inheritDoc} */\n        public void close() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        public void flush() {\n            // do nothing\n        }\n\n        /** {@inheritDoc} */\n        public void write(int c) {\n            StrBuilder.this.append((char) c);\n        }\n\n        /** {@inheritDoc} */\n        public void write(char[] cbuf) {\n            StrBuilder.this.append(cbuf);\n        }\n\n        /** {@inheritDoc} */\n        public void write(char[] cbuf, int off, int len) {\n            StrBuilder.this.append(cbuf, off, len);\n        }\n\n        /** {@inheritDoc} */\n        public void write(String str) {\n            StrBuilder.this.append(str);\n        }\n\n        /** {@inheritDoc} */\n        public void write(String str, int off, int len) {\n            StrBuilder.this.append(str, off, len);\n        }\n    }\n\n}\n", "review": {"response": "[{\"code\": \"public StrBuilder() {\\n        this(CAPACITY);\\n    }\\n\\n    public StrBuilder(int initialCapacity) {\\n        super();\\n        if (initialCapacity <= 0) {\\n            initialCapacity = CAPACITY;\\n        }\\n        buffer = new char[initialCapacity];\\n    }\\n\\n    public StrBuilder(String str) {\\n        super();\\n        if (str == null) {\\n            buffer = new char[CAPACITY];\\n        } else {\\n            buffer = new char[str.length() + CAPACITY];\\n            append(str);\\n        }\\n    }\\n\\n    public StrBuilder setNewLineText(String newLine) {\\n        this.newLine = newLine;\\n        return this;\\n    }\\n\\n    public StrBuilder setNullText(String nullText) {\\n        if (nullText != null && nullText.length() == 0) {\\n            nullText = null;\\n        }\\n        this.nullText = nullText;\\n        return this;\\n    }\\n\\n    public int length() {\\n        return size;\\n    }\\n\\n    public void append(char c) {\\n        if (size == buffer.length) {\\n            buffer = ArrayUtils.add(buffer, c);\\n        } else {\\n            buffer[size++] = c;\\n        }\\n    }\\n\\n    public void append(String str) {\\n        if (str == null) {\\n            if (nullText != null) {\\n                append(nullText);\\n            }\\n        } else {\\n            if (str.length() > buffer.length - size) {\\n                ensureCapacity(str.length());\\n            }\\n            str.getChars(0, str.length(), buffer, size);\\n            size += str.length();\\n        }\\n    }\\n\\n    public void append(CharSequence cs) {\\n        if (cs == null) {\\n            if (nullText != null) {\\n                append(nullText);\\n            }\\n        } else {\\n            if (cs.length() > buffer.length - size) {\\n                ensureCapacity(cs.length());\\n            }\\n            cs.toString().getChars(0, cs.length(), buffer, size);\\n            size += cs.length();\\n        }\\n    }\\n\\n    public void append(Object obj) {\\n        append(String.valueOf(obj));\\n    }\\n\\n    public void append(char[] cArray) {\\n        if (cArray == null) {\\n            if (nullText != null) {\\n                append(nullText);\\n            }\\n        } else {\\n            if (cArray.length > buffer.length - size) {\\n                ensureCapacity(cArray.length);\\n            }\\n            System.arraycopy(cArray, 0, buffer, size, cArray.length);\\n            size += cArray.length;\\n        }\\n    }\\n\\n    public void append(char[] cArray, int offset, int len) {\\n        if (cArray == null) {\\n            if (nullText != null) {\\n                append(nullText);\\n            }\\n        } else {\\n            if (len > buffer.length - size) {\\n                ensureCapacity(len);\\n            }\\n            System.arraycopy(cArray, offset, buffer, size, len);\\n            size += len;\\n        }\\n    }\\n\\n    public void append(CharSequence cs, int start, int end) {\\n        if (cs == null) {\\n            if (nullText != null) {\\n                append(nullText);\\n            }\\n        } else {\\n            if (end > buffer.length - size) {\\n                ensureCapacity(end);\\n            }\\n            cs.toString().getChars(start, end, buffer, size);\\n            size += end - start;\\n        }\\n    }\\n\\n    public void append(Collection<?> coll, String separator) {\\n        if (coll == null) {\\n            return;\\n        }\\n        if (coll.isEmpty()) {\\n            return;\\n        }\\n        if (separator == null) {\\n            separator = \\\"\\\";\\n        }\\n        Iterator<?> it = coll.iterator();\\n        Object obj = it.next();\\n        append(String.valueOf(obj));\\n        while (it.hasNext()) {\\n            append(separator);\\n            append(String.valueOf(it.next()));\\n        }\\n    }\\n\\n    public void append(Object[] array, String separator) {\\n        if (array == null) {\\n            return;\\n        }\\n        if (array.length == 0) {\\n            return;\\n        }\\n        if (separator == null) {\\n            separator = \\\"\\\";\\n        }\\n        for (int i = 0; i < array.length; i++) {\\n            if (i > 0) {\\n                append(separator);\\n            }\\n            append(String.valueOf(array[i]));\\n        }\\n    }\\n\\n    public void appendWithSeparators(Object[] array, String separator, String suffix) {\\n        if (array == null) {\\n            return;\\n        }\\n        if (array.length == 0) {\\n            return;\\n        }\\n        if (separator == null) {\\n            separator = \\\"\\\";\\n        }\\n        if (suffix == null) {\\n            suffix = \\\"\\\";\\n        }\\n        for (int i = 0; i < array.length; i++) {\\n            if (i > 0) {\\n                append(separator);\\n            }\\n            append(String.valueOf(array[i]));\\n            if (i + 1 == array.length) {\\n                append(suffix);\\n            }\\n        }\\n    }\\n\\n    public void appendPadding(int minLength) {\\n        appendPadding(minLength, ' ');\\n    }\\n\\n    public void appendPadding(int minLength, char padChar) {\\n        if (size >= minLength) {\\n            return;\\n        }\\n        if (minLength > buffer.length - size) {\\n            ensureCapacity(minLength - size);\\n        }\\n        char[] padChars = new char[minLength - size];\\n        for (int i = 0; i < padChars.length; i++) {\\n            padChars[i] = padChar;\\n        }\\n        System.arraycopy(padChars, 0, buffer, size, padChars.length);\\n        size = minLength;\\n    }\\n\\n    public void appendFixedLength(Object obj, int length, char padChar) {\\n        if (obj == null) {\\n            obj = \\\"\\\";\\n        }\\n        String str = String.valueOf(obj);\\n        int strLen = str.length();\\n        if (strLen > length) {\\n            str = str.substring(0, length);\\n        }\\n        if (strLen < length) {\\n            int padLen = length - strLen;\\n            char[] padChars = new char[padLen];\\n            for (int i = 0; i < padChars.length; i++) {\\n                padChars[i] = padChar;\\n            }\\n            System.arraycopy(padChars, 0, buffer, size, padChars.length);\\n            size += padLen;\\n        }\\n        append(str);\\n    }\\n\\n    public void appendFixedLength(Object obj, int length, String padStr) {\\n        if (obj == null) {\\n            obj = \\\"\\\";\\n        }\\n        String str = String.valueOf(obj);\\n        int strLen = str.length();\\n        if (strLen > length) {\\n            str = str.substring(0, length);\\n        }\\n        if (strLen < length) {\\n            int padLen = length - strLen;\\n            System.arraycopy(padStr.toCharArray(), 0, buffer, size, padLen);\\n            size += padLen;\\n        }\\n        append(str);\\n    }\\n\\n    public void appendLine() {\\n        if (newLine == null) {\\n            newLine = SystemUtils.getSystemProperty(\\\"line.separator\\\");\\n        }\\n        append(newLine);\\n    }\\n\\n    public void appendLine(String line) {\\n        if (line == null) {\\n            appendLine();\\n        } else {\\n            append(line);\\n            appendLine();\\n        }\\n    }\\n\\n    public void insert(int index, char c) {\\n        if (index < 0 || index > size) {\\n            throw new IndexOutOfBoundsException(\\\"Index: \\\" + index + \\\", Size: \\\" + size);\\n        }\\n        if (size == buffer.length) {\\n            ensureCapacity(1);\\n        }\\n        System.arraycopy(buffer, index, buffer, index + 1, size - index);\\n        buffer[index] = c;\\n        size++;\\n    }\\n\\n    public void insert(int index, String str) {\\n        if (str == null) {\\n            if (nullText != null) {\\n                insert(index, nullText);\\n            }\\n            return;\\n        }\\n        if (index < 0 || index > size) {\\n            throw new IndexOutOfBoundsException(\\\"Index: \\\" + index + \\\", Size: \\\" + size);\\n        }\\n        if (str.length() > buffer.length - size - 1) {\\n            ensureCapacity(str.length());\\n        }\\n        System.arraycopy(buffer, index, buffer, index + str.length(), size - index);\\n        str.getChars(0, str.length(), buffer, index);\\n        size += str.length();\\n    }\\n\\n    public void insert(int index, CharSequence cs) {\\n        if (cs == null) {\\n            if (nullText != null) {\\n                insert(index, nullText);\\n            }\\n            return;\\n        }\\n        if (index < 0 || index > size) {\\n            throw new IndexOutOfBoundsException(\\\"Index: \\\" + index + \\\", Size: \\\" + size);\\n        }\\n        if (cs.length() > buffer.length - size - 1) {\\n            ensureCapacity(cs.length());\\n        }\\n        System.arraycopy(buffer, index, buffer, index + cs.length(), size - index);\\n        cs.toString().getChars(0, cs.length(), buffer, index);\\n        size += cs.length();\\n    }\\n\\n    public void insert(int index, Object obj) {\\n        insert(index, String.valueOf(obj));\\n    }\\n\\n    public void insert(int index, char[] cArray) {\\n        if (cArray == null) {\\n            if (nullText != null) {\\n                insert(index, nullText);\\n            }\\n            return;\\n        }\\n        if (index < 0 || index > size) {\\n            throw new IndexOutOfBoundsException(\\\"Index: \\\" + index + \\\", Size: \\\" + size);\\n        }\\n        if (cArray.length > buffer.length - size - 1) {\\n            ensureCapacity(cArray.length);\\n        }\\n        System.arraycopy(buffer, index, buffer, index + cArray.length, size - index);\\n        System.arraycopy(cArray, 0, buffer, index, cArray.length);\\n        size += cArray.length;\\n    }\\n\\n    public void insert(int index, char[] cArray, int offset, int len) {\\n        if (cArray == null) {\\n            if (nullText != null) {\\n                insert(index, nullText);\\n            }\\n            return;\\n        }\\n        if (index < 0 || index > size) {\\n            throw new IndexOutOfBoundsException(\\\"Index: \\\" + index + \\\", Size: \\\" + size);\\n        }\\n        if (len > buffer.length - size - 1) {\\n            ensureCapacity(len);\\n        }\\n        System.arraycopy(buffer, index, buffer, index + len, size - index);\\n        System.arraycopy(cArray, offset, buffer, index, len);\\n        size += len;\\n    }\\n\\n    public void insert(int index, CharSequence cs, int start, int end) {\\n        if (cs == null) {\\n            if (nullText != null) {\\n                insert(index, nullText);\\n            }\\n            return;\\n        }\\n        if (index < 0 || index > size) {\\n            throw new IndexOutOfBoundsException(\\\"Index: \\\" + index + \\\", Size: \\\" + size);\\n        }\\n        if (end > buffer.length - size - 1) {\\n            ensureCapacity(end);\\n        }\\n        System.arraycopy(buffer, index, buffer, index + end - start, size - index);\\n        cs.toString().getChars(start, end, buffer, index);\\n        size += end - start;\\n    }\\n\\n    public void delete(int start, int end) {\\n        if (start < 0 || start > size) {\\n            throw new IndexOutOfBoundsException(\\\"start: \\\" + start + \\\", Size: \\\" + size);\\n        }\\n        if (end < 0 || end > size) {\\n            throw new IndexOutOfBoundsException(\\\"end: \\\" + end + \\\", Size: \\\" + size);\\n        }\\n        if (start > end) {\\n            int temp = start;\\n            start = end;\\n            end = temp;\\n        }\\n        System.arraycopy(buffer, end, buffer, start, size - end);\\n        size -= end - start;\\n    }\\n\\n    public void delete(int index) {\\n        delete(index, index + 1);\\n    }\\n\\n    public void delete(char c) {\\n        int pos = indexOf(c);\\n        if (pos == -1) {\\n            return;\\n        }\\n        delete(pos, pos + 1);\\n    }\\n\\n    public void delete(String str) {\\n        int pos = indexOf(str);\\n        if (pos == -1) {\\n            return;\\n        }\\n        delete(pos, pos + str.length());\\n    }\\n\\n    public void replace(int start, int end, String replacement) {\\n        if (start < 0 || start > size) {\\n            throw new IndexOutOfBoundsException(\\\"start: \\\" + start + \\\", Size: \\\" + size);\\n        }\\n        if (end < 0 || end > size) {\\n            throw new IndexOutOfBoundsException(\\\"end: \\\" + end + \\\", Size: \\\" + size);\\n        }\\n        if (start > end) {\\n            int temp = start;\\n            start = end;\\n            end = temp;\\n        }\\n        delete(start, end);\\n        insert(start, replacement);\\n    }\\n\\n    public void replace(int start, int end, char c) {\\n        replace(start, end, String.valueOf(c));\\n    }\\n\\n    public void replace(char c, String replacement) {\\n        replace(indexOf(c), indexOf(c) + 1, replacement);\\n    }\\n\\n    public void replace(String str, String replacement) {\\n        int pos = indexOf(str);\\n        if (pos == -1) {\\n            return;\\n        }\\n        replace(pos, pos + str.length(), replacement);\\n    }\\n\\n    public void reverse() {\\n        for (int i = 0; i < size / 2; i++) {\\n            char temp = buffer[i];\\n            buffer[i] = buffer[size - i - 1];\\n            buffer[size - i - 1] = temp;\\n        }\\n    }\\n\\n    public void reverse(int start, int end) {\\n        if (start < 0 || start > size) {\\n            throw new IndexOutOfBoundsException(\\\"start: \\\" + start + \\\", Size: \\\" + size);\\n        }\\n        if (end < 0 || end > size) {\\n            throw new IndexOutOfBoundsException(\\\"end: \\\" + end + \\\", Size: \\\" + size);\\n        }\\n        if (start > end) {\\n            int temp = start;\\n            start = end;\\n            end = temp;\\n        }\\n        for (int i = start, j = end - 1; i < j; i++, j--) {\\n            char temp = buffer[i];\\n            buffer[i] = buffer[j];\\n            buffer[j] = temp;\\n        }\\n    }\\n\\n    public char[] getChars() {\\n        return getChars(0, size);\\n    }\\n\\n    public char[] getChars(int start, int end) {\\n        if (start < 0 || start > size) {\\n            throw new IndexOutOfBoundsException(\\\"start: \\\" + start + \\\", Size: \\\" + size);\\n        }\\n        if (end < 0 || end > size) {\\n            throw new IndexOutOfBoundsException(\\\"end: \\\" + end + \\\", Size: \\\" + size);\\n        }\\n        if (start > end) {\\n            int temp = start;\\n            start = end;\\n            end = temp;\\n        }\\n        char[] chars = new char[end - start];\\n        System.arraycopy(buffer, start, chars, 0, end - start);\\n        return chars;\\n    }\\n\\n    public char[] toCharArray() {\\n        return getChars(0, size);\\n    }\\n\\n    public char charAt(int index) {\\n        if (index < 0 || index >= size) {\\n            throw new IndexOutOfBoundsException(\\\"Index: \\\" + index + \\\", Size: \\\" + size);\\n        }\\n        return buffer[index];\\n    }\\n\\n    public String toString() {\\n        return new String(buffer, 0, size);\\n    }\\n\\n    public String substring(int start, int end) {\\n        if (start < 0 || start > size) {\\n            throw new IndexOutOfBoundsException(\\\"start: \\\" + start + \\\", Size: \\\" + size);\\n        }\\n        if (end < 0 || end > size) {\\n            throw new IndexOutOfBoundsException(\\\\\"    }      ,\n     26\n     ,\n     13\n     ,\n     25\n     ,\n     10\n     ,\n     12\n     ,\n     19\n     ,\n     14\n     ,\n     24\n     ,\n     15\n     ,\n     20\n     ,\n     16\n     ,\n     21\n     ,\n     17\n     ,\n     22\n     ,\n     23\n     ,\n     18\n     ,\n     29\n     ,\n     27\n     ,\n     30\n     ,\n     31\n     ,\n     28\n     ,\n     32\n     ,\n     33\n     ,\n     34\n     ,\n     35\n     ,\n     36\n     ,\n     37\n     ,\n     38\n     ,\n     39\n     ,\n     40\n     ,\n     41\n     ,\n     42\n     ,\n     43\n     ,\n     44\n     ,\n     45\n     ,\n     46\n     ,\n     47\n     ,\n     48\n     ,\n     49\n     ,\n     50\n     ,\n     51\n     ,\n     52\n     ,\n     53\n     ,\n     54\n     ,\n     55\n     ,\n     56\n     ,\n     57\n     ,\n     58\n     ,\n     59\n     ,\n     60\n     ,\n     61\n     ,\n     62\n     ,\n     63\n     ,\n     64\n     ,\n     65\n     ,\n     66\n     ,\n     67\n     ,\n     68\n     ,\n     69\n     ,\n     70\n     ,\n     71\n     ,\n     72\n     ,\n     73\n     ,\n     74\n     ,\n     75\n     ,\n     76\n     ,\n     77\n     ,\n     78\n     ,\n     79\n     ,\n     80\n     ,\n     81\n     ,\n     82\n     ,\n     83\n     ,\n     84\n     ,\n     85\n     ,\n     86\n     ,\n     87\n     ,\n     88\n     ,\n     89\n     ,\n     90\n     ,\n     91\n     ,\n     92\n     ,\n     93\n     ,\n     94\n     ,\n     95\n     ,\n     96\n     ,\n     97\n     ,\n     98\n     ,\n     99\n     ,\n    100\n     ,\n    101\n     ,\n    102\n     ,\n    103\n     ,\n    104\n     ,\n    105\n     ,\n    106\n     ,\n    107\n     ,\n    108\n     ,\n    109\n     ,\n    110\n     ,\n    111\n     ,\n    112\n     ,\n    113\n     ,\n    114\n     ,\n    115\n     ,\n    116\n     ,\n    117\n     ,\n    118\n     ,\n    119\n     ,\n    120\n     ,\n    121\n     ,\n    122\n     ,\n    123\n     ,\n    124\n     ,\n    125\n     ,\n    126\n     ,\n    127\n     ,\n    128\n     ,\n    129\n     ,\n    130\n     ,\n    131\n     ,\n    132\n     ,\n    133\n     ,\n    134\n     ,\n    135\n     ,\n    136\n     ,\n    137\n     ,\n    138\n     ,\n    139\n     ,\n    140\n     ,\n    141\n     ,\n    142\n     ,\n    143\n     ,\n    144\n     ,\n    145\n     ,\n    146\n     ,\n    147\n     ,\n    148\n     ,\n    149\n     ,\n    150\n     ,\n    151\n     ,\n    152\n     ,\n    153\n     ,\n    154\n     ,\n    155\n     ,\n    156\n     ,\n    157\n     ,\n    158\n     ,\n    159\n     ,\n    160\n     ,\n    161\n     ,\n    162\n     ,\n    163\n     ,\n    164\n     ,\n    165\n     ,\n    166\n     ,\n    167\n     ,\n    168\n     ,\n    169\n     ,\n    170\n     ,\n    171\n     ,\n    172\n     ,\n    173\n     ,\n    174\n     ,\n    175\n     ,\n    176\n     ,\n    177\n     ,\n    178\n     ,\n    179\n     ,\n    180\n     ,\n    181\n     ,\n    182\n     ,\n    183\n     ,\n    184\n     ,\n    185\n     ,\n    186\n     ,\n    187\n     ,\n    188\n     ,\n    189\n     ,\n    190\n     ,\n    191\n     ,\n    192\n     ,\n    193\n     ,\n    194\n     ,\n    195\n     ,\n    196\n     ,\n    197\n     ,\n    198\n     ,\n    199\n     ,\n    200\n     ,\n    201\n     ,\n    202\n     ,\n    203\n     ,\n    204\n     ,\n    205\n     ,\n    206\n     ,\n    207\n     ,\n    208\n     ,\n    209\n     ,\n    210\n     ,\n    211\n     ,\n    212\n     ,\n    213\n     ,\n    214\n     ,\n    215\n     ,\n    216\n     ,\n    217\n     ,\n    218\n     ,\n    219\n     ,\n    220\n     ,\n    221\n     ,\n    222\n     ,\n    223\n     ,\n    224\n     ,\n    225\n     ,\n    226\n     ,\n    227\n     ,\n    228\n     ,\n    229\n     ,\n    230\n     ,\n    231\n     ,\n    232\n     ,\n    233\n     ,\n    234\n     ,\n    235\n     ,\n    236\n     ,\n    237\n     ,\n    238\n     ,\n    239\n     ,\n    240\n     ,\n    241\n     ,\n    242\n     ,\n    243\n     ,\n    244\n     ,\n    245\n     ,\n    246\n     ,\n    247\n     ,\n    248\n     ,\n    249\n     ,\n    250\n     ,\n    251\n     ,\n    252\n     ,\n    253\n     ,\n    254\n     ,\n    255\n     ,\n    256\n     ,\n    257\n     ,\n    258\n     ,\n    259\n     ,\n    260\n     ,\n    261\n     ,\n    262\n     ,\n    263\n     ,\n    264\n     ,\n    265\n     ,\n    266\n     ,\n    267\n     ,\n    268\n     ,\n    269\n     ,\n    270\n     ,\n    271\n     ,\n    272\n     ,\n    273\n     ,\n    274\n     ,\n    275\n     ,\n    276\n     ,\n    277\n     ,\n    278\n     ,\n    279\n     ,\n    280\n     ,\n    281\n     ,\n    282\n     ,\n    283\n     ,\n    284\n     ,\n    285\n     ,\n    286\n     ,\n    287\n     ,\n    288\n     ,\n    289\n     ,\n    290\n     ,\n    291\n     ,\n    292\n     ,\n    293\n     ,\n    294\n     ,\n    295\n     ,\n    296\n     ,\n    297\n     ,\n    298\n     ,\n    299\n     ,\n    300\n     ,\n    301\n     ,\n    302\n     ,\n    303\n     ,\n    304\n     ,\n    305\n     ,\n    306\n     ,\n    307\n     ,\n    308\n     ,\n    309\n     ,\n    310\n     ,\n    311\n     ,\n    312\n     ,\n    313\n     ,\n    314\n     ,\n    315\n     ,\n    316\n     ,\n    317\n     ,\n    318\n     ,\n    319\n     ,\n    320\n     ,\n    321\n     ,\n    322\n     ,\n    323\n     ,\n    324\n     ,\n    325\n     ,\n    326\n     ,\n    327\n     ,\n    328\n     ,\n    329\n     ,\n    330\n     ,\n    331\n     ,\n    332\n     ,\n    333\n     ,\n    334\n     ,\n    335\n     ,\n    336\n     ,\n    337\n     ,\n    338\n     ,\n    339\n     ,\n    340\n     ,\n    341\n     ,\n    342\n     ,\n    343\n     ,\n    344\n     ,\n    345\n     ,\n    346\n     ,\n    347\n     ,\n    348\n     ,\n    349\n     ,\n    350\n     ,\n    351\n     ,\n    352\n     ,\n    353\n     ,\n    354\n     ,\n    355\n     ,\n    356\n     ,\n    357\n     ,\n    358\n     ,\n    359\n     ,\n    360\n     ,\n    361\n     ,\n    362\n     ,\n    363\n     ,\n    364\n     ,\n    365\n     ,\n    366\n     ,\n    367\n     ,\n    368\n     ,\n    369\n     ,\n    370\n     ,\n    371\n     ,\n    372\n     ,\n    373\n     ,\n    374\n     ,\n    375\n     ,\n    376\n     ,\n    377\n     ,\n    378\n     ,\n    379\n     ,\n    380\n     ,\n    381\n     ,\n    382\n     ,\n    383\n     ,\n    384\n     ,\n    385\n     ,\n    386\n     ,\n    387\n     ,\n    388\n     ,\n    389\n     ,\n    390\n     ,\n    391\n     ,\n    392\n     ,\n    393\n     ,\n    394\n     ,\n    395\n     ,\n    396\n     ,\n    397\n     ,\n    398\n     ,\n    399\n     ,\n    400\n     ,\n    401\n     ,\n    402\n     ,\n    403\n     ,\n    404\n     ,\n    405\n     ,\n    406\n     ,\n    407\n     ,\n    408\n     ,\n    409\n     ,\n    410\n     ,\n    411\n     ,\n    412\n     ,\n    413\n     ,\n    414\n     ,\n    415\n     ,\n    416\n     ,\n    417\n     ,\n    418\n     ,\n    419\n     ,\n    420\n     ,\n    421\n     ,\n    422\n     ,\n    423\n     ,\n    424\n     ,\n    425\n     ,\n    426\n     ,\n    427\n     ,\n    428\n     ,\n    429\n     ,\n    430\n     ,\n    431\n     ,\n    432\n     ,\n    433\n     ,\n    434\n     ,\n    435\n     ,\n    436\n     ,\n    437\n     ,\n    438\n     ,\n    439\n     ,\n    440\n     ,\n    441\n     ,\n    442\n     ,\n    443\n     ,\n    444\n     ,\n    445\n     ,\n    446\n     ,\n    447\n     ,\n    448\n     ,\n    449\n     ,\n    450\n     ,\n    451\n     ,\n    452\n     ,\n    453\n     ,\n    454\n     ,\n    455\n     ,\n    456\n     ,\n    457\n     ,\n    458\n     ,\n    459\n     ,\n    460\n     ,\n    461\n     ,\n    462\n     ,\n    463\n     ,\n    464\n     ,\n    465\n     ,\n    466\n     ,\n    467\n     ,\n    468\n     ,\n    469\n     ,\n    470\n     ,\n    471\n     ,\n    472\n     ,\n    473\n     ,\n    474\n     ,\n    475\n     ,\n    476\n     ,\n    477\n     ,\n    478\n     ,\n    479\n     ,\n    480\n     ,\n    481\n     ,\n    482\n     ,\n    483\n     ,\n    484\n     ,\n    485\n     ,\n    486\n     ,\n    487\n     ,\n    488\n     ,\n    489\n     ,\n    490\n     ,\n    491\n     ,\n    492\n     ,\n    493\n     ,\n    494\n     ,\n    495\n     ,\n    496\n     ,\n    497\n     ,\n    498\n     ,\n    499\n     ,\n    500\n     ,\n    501\n     ,\n    502\n     ,\n    503\n     ,\n    504\n     ,\n    505\n     ,\n    506\n     ,\n    507\n     ,\n    508\n     ,\n    509\n     ,\n    510\n     ,\n    511\n     ,\n    512\n     ,\n    513\n     ,\n    514\n     ,\n    515\n     ,\n    516\n     ,\n    517\n     ,\n    518\n     ,\n    519\n     ,\n    520\n     ,\n    521\n     ,\n    522\n     ,\n    523\n     ,\n    524\n     ,\n    525\n     ,\n    526\n     ,\n    527\n     ,\n    528\n     ,\n    529\n     ,\n    530\n     ,\n    531\n     ,\n    532\n     ,\n    533\n     ,\n    534\n     ,\n    535\n     ,\n    536\n     ,\n    537\n     ,\n    538\n     ,\n    539\n     ,\n    540\n     ,\n    541\n     ,\n    542\n     ,\n    543\n     ,\n    544\n     ,\n    545\n     ,\n    546\n     ,\n    547\n     ,\n    548\n     ,\n    549\n     ,\n    550\n     ,\n    551\n     ,\n    552\n     ,\n    553\n     ,\n    554\n     ,\n    555\n     ,\n    556\n     ,\n    557\n     ,\n    558\n     ,\n    559\n     ,\n    560\n     ,\n    561\n     ,\n    562\n     ,\n    563\n     ,\n    564\n     ,\n    565\n     ,\n    566\n     ,\n    567\n     ,\n    568\n     ,\n    569\n     ,\n    570\n     ,\n    571\n     ,\n    572\n     ,\n    573\n     ,\n    574\n     ,\n    575\n     ,\n    576\n     ,\n    577\n     ,\n    578\n     ,\n    579\n     ,\n    580\n     ,\n    581\n     ,\n    582\n     ,\n    583\n     ,\n    584\n     ,\n    585\n     ,\n    586\n     ,\n    587\n     ,\n    588\n     ,\n    589\n     ,\n    590\n     ,\n    591\n     ,\n    592\n     ,\n    593\n     ,\n    594\n     ,\n    595\n     ,\n    596\n     ,\n    597\n     ,\n    598\n     ,\n    599\n     ,\n    600\n     ,\n    601\n     ,\n    602\n     ,\n    603\n     ,\n    604\n     ,\n    605\n     ,\n    606\n     ,\n    607\n     ,\n    608\n     ,\n    609\n     ,\n    610\n     ,\n    611\n     ,\n    612\n     ,\n    613\n     ,\n    614\n     ,\n    615\n     ,\n    616\n     ,\n    617\n     ,\n    618\n     ,\n    619\n     ,\n    620\n     ,\n    621\n     ,\n    622\n     ,\n    623\n     ,\n    624\n     ,\n    625\n     ,\n    626\n     ,\n    627\n     ,\n    628\n     ,\n    629\n     ,\n    630\n     ,\n    631\n     ,\n    632\n     ,\n    633\n     ,\n    634\n     ,\n    635\n     ,\n    636\n     ,\n    637\n     ,\n    638\n     ,\n    639\n     ,\n    640\n     ,\n    641\n     ,\n    642\n     ,\n    643\n     ,\n    644\n     ,\n    645\n     ,\n    646\n     ,\n    647\n     ,\n    648\n     ,\n    649\n     ,\n    650\n     ,\n    651\n     ,\n    652\n     ,\n    653\n     ,\n    654\n     ,\n    655\n     ,\n    656\n     ,\n    657\n     ,\n    658\n     ,\n    659\n     ,\n    660\n     ,\n    661\n     ,\n    662\n     ,\n    663\n     ,\n    664\n     ,\n    665\n     ,\n    666\n     ,\n    667\n     ,\n    668\n     ,\n    669\n     ,\n    670\n     ,\n    671\n     ,\n    672\n     ,\n    673\n     ,\n    674\n     ,\n    675\n     ,\n    676\n     ,\n    677\n     ,\n    678\n     ,\n    679\n     ,\n    680\n     ,\n    681\n     ,\n    682\n     ,\n    683\n     ,\n    684\n     ,\n    685\n     ,\n    686\n     ,\n    687\n     ,\n    688\n     ,\n    689\n     ,\n    690\n     ,\n    691\n     ,\n    692\n     ,\n    693\n     ,\n    694\n     ,\n    695\n     ,\n    696\n     ,\n    697\n     ,\n    698\n     ,\n    699\n     ,\n    700\n     ,\n    701\n     ,\n    702\n     ,\n    703\n     ,\n    704\n     ,\n    705\n     ,\n    706\n     ,\n    707\n     ,\n    708\n     ,\n    709\n     ,\n    710\n     ,\n    711\n     ,\n    712\n     ,\n    713\n     ,\n    714\n     ,\n    715\n     ,\n    716\n     ,\n    717\n     ,\n    718\n     ,\n    719\n     ,\n    720\n     ,\n    721\n     ,\n    722\n     ,\n    723\n     ,\n    724\n     ,\n    725\n     ,\n    726\n     ,\n    727\n     ,\n    728\n     ,\n    729\n     ,\n    730\n     ,\n    731\n     ,\n    732\n     ,\n    733\n     ,\n    734\n     ,\n    735\n     ,\n    736\n     ,\n    737\n     ,\n    738\n     ,\n    739\n     ,\n    740\n     ,\n    741\n     ,\n    742\n     ,\n    743\n     ,\n    744\n     ,\n    745\n     ,\n    746\n     ,\n    747\n     ,\n    748\n     ,\n    749\n     ,\n    750\n     ,\n    751\n     ,\n    752\n     ,\n    753\n     ,\n    754\n     ,\n    755\n     ,\n    756\n     ,\n    757\n     ,\n    758\n     ,\n    759\n     ,\n    760\n     ,\n    761\n     ,\n    762\n     ,\n    763\n     ,\n    764\n     ,\n    765\n     ,\n    766\n     ,\n    767\n     ,\n    768\n     ,\n    769\n     ,\n    770\n     ,\n    771\n     ,\n    772\n     ,\n    773\n     ,\n    774\n     ,\n    775\n     ,\n    776\n     ,\n    777\n     ,\n    778\n     ,\n    779\n     ,\n    780\n     ,\n    781\n     ,\n    782\n     ,\n    783\n     ,\n    784\n     ,\n    785\n     ,\n    786\n     ,\n    787\n     ,\n    788\n     ,\n    789\n     ,\n    790\n     ,\n    791\n     ,\n    792\n     ,\n    793\n     ,\n    794\n     ,\n    795\n     ,\n    796\n     ,\n    797\n     ,\n    798\n     ,\n    799\n     ,\n    800\n     ,\n    801\n     ,\n    802\n     ,\n    803\n     ,\n    804\n     ,\n    805\n     ,\n    806\n     ,\n    807\n     ,\n    808\n     ,\n    809\n     ,\n    810\n     ,\n    811\n     ,\n    812\n     ,\n    813\n     ,\n    814\n     ,\n    815\n     ,\n    816\n     ,\n    817\n     ,\n    818\n     ,\n    819\n     ,\n    820\n     ,\n    821\n     ,\n    822\n     ,\n    823\n     ,\n    824\n     ,\n    825\n     ,\n    826\n     ,\n    827\n     ,\n    828\n     ,\n    829\n     ,\n    830\n     ,\n    831\n     ,\n    832\n     ,\n    833\n     ,\n    834\n     ,\n    835\n     ,\n    836\n     ,\n    837\n     ,\n    838\n     ,\n    839\n     ,\n    840\n     ,\n    841\n     ,\n    842\n     ,\n    843\n     ,\n    844\n     ,\n    845\n     ,\n    846\n     ,\n    847\n     ,\n    848\n     ,\n    849\n     ,\n    850\n     ,\n    851\n     ,\n    852\n     ,\n    853\n     ,\n    854\n     ,\n    855\n     ,\n    856\n     ,\n    857\n     ,\n    858\n     ,\n    859\n     ,\n    860\n     ,\n    861\n     ,\n    862\n     ,\n    863\n     ,\n    864\n     ,\n    865\n     ,\n    866\n     ,\n    867\n     ,\n    868\n     ,\n    869\n     ,\n    870\n     ,\n    871\n     ,\n    872\n     ,\n    873\n     ,\n    874\n     ,\n    875\n     ,\n    876\n     ,\n    877\n     ,\n    878\n     ,\n    879\n     ,\n    880\n     ,\n    881\n     ,\n    882\n     ,\n    883\n     ,\n    884\n     ,\n    885\n     ,\n    886\n     ,\n    887\n     ,\n    888\n     ,\n    889\n     ,\n    890\n     ,\n    891\n     ,\n    892\n     ,\n    893\n     ,\n    894\n     ,\n    895\n     ,\n    896\n     ,\n    897\n     ,\n    898\n     ,\n    899\n     ,\n    900\n     ,\n    901\n     ,\n    902\n     ,\n    903\n     ,\n    904\n     ,\n    905\n     ,\n    906\n     ,\n    907\n     ,\n    908\n     ,\n    909\n     ,\n    910\n     ,\n    911\n     ,\n    912\n     ,\n    913\n     ,\n    914\n     ,\n    915\n     ,\n    916\n     ,\n    917\n     ,\n    918\n     ,\n    919\n     ,\n    920\n     ,\n    921\n     ,\n    922\n     ,\n    923\n     ,\n    924\n     ,\n    925\n     ,\n    926\n     ,\n    927\n     ,\n    928\n     ,\n    929\n     ,\n    930\n     ,\n    931\n     ,\n    932\n     ,\n    933\n     ,\n    934\n     ,\n    935\n     ,\n    936\n     ,\n    937\n     ,\n    938\n     ,\n    939\n     ,\n    940\n     ,\n    941\n     ,\n    942\n     ,\n    943\n     ,\n    944\n     ,\n    945\n     ,\n    946\n     ,\n    947\n     ,\n    948\n     ,\n    949\n     ,\n    950\n     ,\n    951\n     ,\n    952\n     ,\n    953\n     ,\n    954\n     ,\n    955\n     ,\n    956\n     ,\n    957\n     ,\n    958\n     ,\n    959\n     ,\n    960\n     ,\n    961\n     ,\n    962\n     ,\n    963\n     ,\n    964\n     ,\n    965\n     ,\n    966\n     ,\n    967\n     ,\n    968\n     ,\n    969\n     ,\n    970\n     ,\n    971\n     ,\n    972\n     ,\n    973\n     ,\n    974\n     ,\n    975\n     ,\n    976\n     ,\n    977\n     ,\n    978\n     ,\n    979\n     ,\n    980\n     ,\n    981\n     ,\n    982\n     ,\n    983\n     ,\n    984\n     ,\n    985\n     ,\n    986\n     ,\n    987\n     ,\n    988\n     ,\n    989\n     ,\n    990\n     ,\n    991\n     ,\n    992\n     ,\n    993\n     ,\n    994\n     ,\n    995\n     ,\n    996\n     ,\n    997\n     ,\n    998\n     ,\n    999\n     ,\n    1000\n     ,\n    1001\n     ,\n    1002\n     ,\n    1003\n     ,\n    1004\n     ,\n    1005\n     ,\n    1006\n     ,\n    1007\n     ,\n    1008\n     ,\n    1009\n     ,\n    1010\n     ,\n    1011\n     ,\n    1012\n     ,\n    1013\n     ,\n    1014\n     ,\n    1015\n     ,\n    1016\n     ,\n    1017\n     ,\n    1018\n     ,\n    1019\n     ,\n    1020\n     ,\n    1021\n     ,\n    1022\n     ,\n    1023\n     ,\n    1024\n     ,\n    1025\n     ,\n    1026\n     ,\n    1027\n     ,\n    1028\n     ,\n    1029\n     ,\n    1030\n     ,\n    1031\n     ,\n    1032\n     ,\n    1033\n     ,\n    1034\n     ,\n    1035\n     ,\n    1036\n     ,\n    1037\n     ,\n    1038\n     ,\n    1039\n     ,\n    1040\n     ,\n    1041\n     ,\n    1042\n     ,\n    1043\n     ,\n    1044\n     ,\n    1045\n     ,\n    1046\n     ,\n    1047\n     ,\n    1048\n     ,\n    1049\n     ,\n    1050\n     ,\n    1051\n     ,\n    1052\n     ,\n    1053\n     ,\n    1054\n     ,\n    1055\n     ,\n    1056\n     ,\n    1057\n     ,\n    1058\n     ,\n    1059\n     ,\n    1060\n     ,\n    1061\n     ,\n    1062\n     ,\n    1063\n     ,\n    1064\n     ,\n    1065\n     ,\n    1066\n     ,\n    1067\n     ,\n    1068\n     ,\n    1069\n     ,\n    1070\n     ,\n    1071\n     ,\n    1072\n     ,\n    1073\n     ,\n    1074\n     ,\n    1075\n     ,\n    1076\n     ,\n    1077\n     ,\n    1078\n     ,\n    1079\n     ,\n    1080\n     ,\n    1081\n     ,\n    1082\n     ,\n    1083\n     ,\n    1084\n     ,\n    1085\n     ,\n    1086\n     ,\n    1087\n     ,\n    1088\n     ,\n    1089\n     ,\n    1090\n     ,\n    1091\n     ,\n    1092\n     ,\n    1093\n     ,\n    1094\n     ,\n    1095\n     ,\n    1096\n     ,\n    1097\n     ,\n    1098\n     ,\n    1099\n     ,\n    1100\n     ,\n    1101\n     ,\n    1102\n     ,\n    1103\n     ,\n    1104\n     ,\n    1105\n     ,\n    1106\n     ,\n    1107\n     ,\n    1108\n     ,\n    1109\n     ,\n    1110\n     ,\n    1111\n     ,\n    1112\n     ,\n    1113\n     ,\n    1114\n     ,\n    1115\n     ,\n    1116\n     ,\n    1117\n     ,\n    1118\n     ,\n    1119\n     ,\n    1120\n     ,\n    1121\n     ,\n    1122\n     ,\n    1123\n     ,\n    1124\n     ,\n    1125\n     ,\n    1126\n     ,\n    1127\n     ,\n    1128\n     ,\n    1129\n     ,\n    1130\n     ,\n    1131\n     ,\n    1132\n     ,\n    1133\n     ,\n    1134\n     ,\n    1135\n     ,\n    1136\n     ,\n    1137\n     ,\n    1138\n     ,\n    1139\n     ,\n    1140\n     ,\n    1141\n     ,\n    1142\n     ,\n    1143\n     ,\n    1144\n     ,\n    1145\n     ,\n    1146\n     ,\n    1147\n     ,\n    1148\n     ,\n    1149\n     ,\n    1150\n     ,\n    1151\n     ,\n    1152\n     ,\n    1153\n     ,\n    1154\n     ,\n    1155\n     ,\n    1156\n     ,\n    1157\n     ,\n    1158\n     ,\n    1159\n     ,\n    1160\n     ,\n    1161\n     ,\n    1162\n     ,\n    1163\n     ,\n    1164\n     ,\n    1165\n     ,\n    1166\n     ,\n    1167\n     ,\n    1168\n     ,\n    1169\n     ,\n    1170\n     ,\n    1171\n     ,\n    1172\n     ,\n    1173\n     ,\n    1174\n     ,\n    1175\n     ,\n    1176\n     ,\n    1177\n     ,\n    1178\n     ,\n    1179\n     ,\n    1180\n     ,\n    1181\n     ,\n    1182\n     ,\n    1183\n     ,\n    1184\n     ,\n    1185\n     ,\n    1186\n     ,\n    1187\n     ,\n    1188\n     ,\n    1189\n     ,\n    1190\n     ,\n    1191\n     ,\n    1192\n     ,\n    1193\n     ,\n    1194\n     ,\n    1195\n     ,\n    1196\n     ,\n    1197\n     ,\n    1198\n     ,\n    1199\n     ,\n    1200\n     ,\n    1201\n     ,\n    1202\n     ,\n    1203\n     ,\n    1204\n     ,\n    1205\n     ,\n    1206\n     ,\n    1207\n     ,\n    1208\n     ,\n    1209\n     ,\n    1210\n     ,\n    1211\n     ,\n    1212\n     ,\n    1213\n     ,\n    1214\n     ,\n    1215\n     ,\n    1216\n     ,\n    1217\n     ,\n    1218\n     ,\n    1219\n     ,\n    1220\n     ,\n    1221\n     ,\n    1222\n     ,\n    1223\n     ,\n    1224\n     ,\n    1225\n"}}