{"sample_id": "Chart_12", "model": "llama3-8b-groq", "code_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * --------------------\n * MultiplePiePlot.java\n * --------------------\n * (C) Copyright 2004-2008, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Brian Cabana (patch 1943021);\n *\n * Changes\n * -------\n * 29-Jan-2004 : Version 1 (DG);\n * 31-Mar-2004 : Added setPieIndex() call during drawing (DG);\n * 20-Apr-2005 : Small change for update to LegendItem constructors (DG);\n * 05-May-2005 : Updated draw() method parameters (DG);\n * 16-Jun-2005 : Added get/setDataset() and equals() methods (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 06-Apr-2006 : Fixed bug 1190647 - legend and section colors not consistent\n *               when aggregation limit is specified (DG);\n * 27-Sep-2006 : Updated draw() method for deprecated code (DG);\n * 17-Jan-2007 : Updated prefetchSectionPaints() to check settings in\n *               underlying PiePlot (DG);\n * 17-May-2007 : Added argument check to setPieChart() (DG);\n * 18-May-2007 : Set dataset for LegendItem (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 18-Apr-2008 : In the constructor, register the plot as a dataset listener -\n *               see patch 1943021 from Brian Cabana (DG);\n *\n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Rectangle;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jfree.chart.ChartRenderingInfo;\nimport org.jfree.chart.JFreeChart;\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.title.TextTitle;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.TableOrder;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryToPieDataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.general.PieDataset;\n\n/**\n * A plot that displays multiple pie plots using data from a\n * {@link CategoryDataset}.\n */\npublic class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -355377800470807389L;\n\n    /** The chart object that draws the individual pie charts. */\n    private JFreeChart pieChart;\n\n    /** The dataset. */\n    private CategoryDataset dataset;\n\n    /** The data extract order (by row or by column). */\n    private TableOrder dataExtractOrder;\n\n    /** The pie section limit percentage. */\n    private double limit = 0.0;\n\n    /**\n     * The key for the aggregated items.\n     * @since 1.0.2\n     */\n    private Comparable aggregatedItemsKey;\n\n    /**\n     * The paint for the aggregated items.\n     * @since 1.0.2\n     */\n    private transient Paint aggregatedItemsPaint;\n\n    /**\n     * The colors to use for each section.\n     * @since 1.0.2\n     */\n    private transient Map sectionPaints;\n\n    /**\n     * Creates a new plot with no data.\n     */\n    public MultiplePiePlot() {\n        this(null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n        this.dataset = dataset;\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }\n\n    /**\n     * Returns the dataset used by the plot.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     */\n    public CategoryDataset getDataset() {\n        return this.dataset;\n    }\n\n    /**\n     * Sets the dataset used by the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public void setDataset(CategoryDataset dataset) {\n        // if there is an existing dataset, remove the plot from the list of\n        // change listeners...\n        if (this.dataset != null) {\n            this.dataset.removeChangeListener(this);\n        }\n\n        // set the new dataset, and register the chart as a change listener...\n        this.dataset = dataset;\n        if (dataset != null) {\n            setDatasetGroup(dataset.getGroup());\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self to trigger plot change event\n        datasetChanged(new DatasetChangeEvent(this, dataset));\n    }\n\n    /**\n     * Returns the pie chart that is used to draw the individual pie plots.\n     *\n     * @return The pie chart (never <code>null</code>).\n     *\n     * @see #setPieChart(JFreeChart)\n     */\n    public JFreeChart getPieChart() {\n        return this.pieChart;\n    }\n\n    /**\n     * Sets the chart that is used to draw the individual pie plots.  The\n     * chart's plot must be an instance of {@link PiePlot}.\n     *\n     * @param pieChart  the pie chart (<code>null</code> not permitted).\n     *\n     * @see #getPieChart()\n     */\n    public void setPieChart(JFreeChart pieChart) {\n        if (pieChart == null) {\n            throw new IllegalArgumentException(\"Null 'pieChart' argument.\");\n        }\n        if (!(pieChart.getPlot() instanceof PiePlot)) {\n            throw new IllegalArgumentException(\"The 'pieChart' argument must \"\n                    + \"be a chart based on a PiePlot.\");\n        }\n        this.pieChart = pieChart;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the data extract order (by row or by column).\n     *\n     * @return The data extract order (never <code>null</code>).\n     */\n    public TableOrder getDataExtractOrder() {\n        return this.dataExtractOrder;\n    }\n\n    /**\n     * Sets the data extract order (by row or by column) and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param order  the order (<code>null</code> not permitted).\n     */\n    public void setDataExtractOrder(TableOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument\");\n        }\n        this.dataExtractOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the limit (as a percentage) below which small pie sections are\n     * aggregated.\n     *\n     * @return The limit percentage.\n     */\n    public double getLimit() {\n        return this.limit;\n    }\n\n    /**\n     * Sets the limit below which pie sections are aggregated.\n     * Set this to 0.0 if you don't want any aggregation to occur.\n     *\n     * @param limit  the limit percent.\n     */\n    public void setLimit(double limit) {\n        this.limit = limit;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the key for aggregated items in the pie plots, if there are any.\n     * The default value is \"Other\".\n     *\n     * @return The aggregated items key.\n     *\n     * @since 1.0.2\n     */\n    public Comparable getAggregatedItemsKey() {\n        return this.aggregatedItemsKey;\n    }\n\n    /**\n     * Sets the key for aggregated items in the pie plots.  You must ensure\n     * that this doesn't clash with any keys in the dataset.\n     *\n     * @param key  the key (<code>null</code> not permitted).\n     *\n     * @since 1.0.2\n     */\n    public void setAggregatedItemsKey(Comparable key) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        this.aggregatedItemsKey = key;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the pie section representing the\n     * aggregated items.  The default value is <code>Color.lightGray</code>.\n     *\n     * @return The paint.\n     *\n     * @since 1.0.2\n     */\n    public Paint getAggregatedItemsPaint() {\n        return this.aggregatedItemsPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the pie section representing the aggregated\n     * items and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     *\n     * @since 1.0.2\n     */\n    public void setAggregatedItemsPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.aggregatedItemsPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a short string describing the type of plot.\n     *\n     * @return The plot type.\n     */\n    public String getPlotType() {\n        return \"Multiple Pie Plot\";\n         // TODO: need to fetch this from localised resources\n    }\n\n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a\n     * printer).\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param info  collects info about the drawing.\n     */\n    public void draw(Graphics2D g2,\n                     Rectangle2D area,\n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo info) {\n\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n        drawBackground(g2, area);\n        drawOutline(g2, area);\n\n        // check that there is some data to display...\n        if (DatasetUtilities.isEmptyOrNull(this.dataset)) {\n            drawNoDataMessage(g2, area);\n            return;\n        }\n\n        int pieCount = 0;\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n            pieCount = this.dataset.getRowCount();\n        }\n        else {\n            pieCount = this.dataset.getColumnCount();\n        }\n\n        // the columns variable is always >= rows\n        int displayCols = (int) Math.ceil(Math.sqrt(pieCount));\n        int displayRows\n            = (int) Math.ceil((double) pieCount / (double) displayCols);\n\n        // swap rows and columns to match plotArea shape\n        if (displayCols > displayRows && area.getWidth() < area.getHeight()) {\n            int temp = displayCols;\n            displayCols = displayRows;\n            displayRows = temp;\n        }\n\n        prefetchSectionPaints();\n\n        int x = (int) area.getX();\n        int y = (int) area.getY();\n        int width = ((int) area.getWidth()) / displayCols;\n        int height = ((int) area.getHeight()) / displayRows;\n        int row = 0;\n        int column = 0;\n        int diff = (displayRows * displayCols) - pieCount;\n        int xoffset = 0;\n        Rectangle rect = new Rectangle();\n\n        for (int pieIndex = 0; pieIndex < pieCount; pieIndex++) {\n            rect.setBounds(x + xoffset + (width * column), y + (height * row),\n                    width, height);\n\n            String title = null;\n            if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                title = this.dataset.getRowKey(pieIndex).toString();\n            }\n            else {\n                title = this.dataset.getColumnKey(pieIndex).toString();\n            }\n            this.pieChart.setTitle(title);\n\n            PieDataset piedataset = null;\n            PieDataset dd = new CategoryToPieDataset(this.dataset,\n                    this.dataExtractOrder, pieIndex);\n            if (this.limit > 0.0) {\n                piedataset = DatasetUtilities.createConsolidatedPieDataset(\n                        dd, this.aggregatedItemsKey, this.limit);\n            }\n            else {\n                piedataset = dd;\n            }\n            PiePlot piePlot = (PiePlot) this.pieChart.getPlot();\n            piePlot.setDataset(piedataset);\n            piePlot.setPieIndex(pieIndex);\n\n            // update the section colors to match the global colors...\n            for (int i = 0; i < piedataset.getItemCount(); i++) {\n                Comparable key = piedataset.getKey(i);\n                Paint p;\n                if (key.equals(this.aggregatedItemsKey)) {\n                    p = this.aggregatedItemsPaint;\n                }\n                else {\n                    p = (Paint) this.sectionPaints.get(key);\n                }\n                piePlot.setSectionPaint(key, p);\n            }\n\n            ChartRenderingInfo subinfo = null;\n            if (info != null) {\n                subinfo = new ChartRenderingInfo();\n            }\n            this.pieChart.draw(g2, rect, subinfo);\n            if (info != null) {\n                info.getOwner().getEntityCollection().addAll(\n                        subinfo.getEntityCollection());\n                info.addSubplotInfo(subinfo.getPlotInfo());\n            }\n\n            ++column;\n            if (column == displayCols) {\n                column = 0;\n                ++row;\n\n                if (row == displayRows - 1 && diff != 0) {\n                    xoffset = (diff * width) / 2;\n                }\n            }\n        }\n\n    }\n\n    /**\n     * For each key in the dataset, check the <code>sectionPaints</code>\n     * cache to see if a paint is associated with that key and, if not,\n     * fetch one from the drawing supplier.  These colors are cached so that\n     * the legend and all the subplots use consistent colors.\n     */\n    private void prefetchSectionPaints() {\n\n        // pre-fetch the colors for each key...this is because the subplots\n        // may not display every key, but we need the coloring to be\n        // consistent...\n\n        PiePlot piePlot = (PiePlot) getPieChart().getPlot();\n\n        if (this.dataExtractOrder == TableOrder.BY_ROW) {\n            // column keys provide potential keys for individual pies\n            for (int c = 0; c < this.dataset.getColumnCount(); c++) {\n                Comparable key = this.dataset.getColumnKey(c);\n                Paint p = piePlot.getSectionPaint(key);\n                if (p == null) {\n                    p = (Paint) this.sectionPaints.get(key);\n                    if (p == null) {\n                        p = getDrawingSupplier().getNextPaint();\n                    }\n                }\n                this.sectionPaints.put(key, p);\n            }\n        }\n        else {\n            // row keys provide potential keys for individual pies\n            for (int r = 0; r < this.dataset.getRowCount(); r++) {\n                Comparable key = this.dataset.getRowKey(r);\n                Paint p = piePlot.getSectionPaint(key);\n                if (p == null) {\n                    p = (Paint) this.sectionPaints.get(key);\n                    if (p == null) {\n                        p = getDrawingSupplier().getNextPaint();\n                    }\n                }\n                this.sectionPaints.put(key, p);\n            }\n        }\n\n    }\n\n    /**\n     * Returns a collection of legend items for the pie chart.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n\n        LegendItemCollection result = new LegendItemCollection();\n\n        if (this.dataset != null) {\n            List keys = null;\n\n            prefetchSectionPaints();\n            if (this.dataExtractOrder == TableOrder.BY_ROW) {\n                keys = this.dataset.getColumnKeys();\n            }\n            else if (this.dataExtractOrder == TableOrder.BY_COLUMN) {\n                keys = this.dataset.getRowKeys();\n            }\n\n            if (keys != null) {\n                int section = 0;\n                Iterator iterator = keys.iterator();\n                while (iterator.hasNext()) {\n                    Comparable key = (Comparable) iterator.next();\n                    String label = key.toString();\n                    String description = label;\n                    Paint paint = (Paint) this.sectionPaints.get(key);\n                    LegendItem item = new LegendItem(label, description,\n                            null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE,\n                            paint, Plot.DEFAULT_OUTLINE_STROKE, paint);\n                    item.setDataset(getDataset());\n                    result.add(item);\n                    section++;\n                }\n            }\n            if (this.limit > 0.0) {\n                result.add(new LegendItem(this.aggregatedItemsKey.toString(),\n                        this.aggregatedItemsKey.toString(), null, null,\n                        Plot.DEFAULT_LEGEND_ITEM_CIRCLE,\n                        this.aggregatedItemsPaint,\n                        Plot.DEFAULT_OUTLINE_STROKE,\n                        this.aggregatedItemsPaint));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Tests this plot for equality with an arbitrary object.  Note that the\n     * plot's dataset is not considered in the equality test.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> if this plot is equal to <code>obj</code>, and\n     *     <code>false</code> otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof MultiplePiePlot)) {\n            return false;\n        }\n        MultiplePiePlot that = (MultiplePiePlot) obj;\n        if (this.dataExtractOrder != that.dataExtractOrder) {\n            return false;\n        }\n        if (this.limit != that.limit) {\n            return false;\n        }\n        if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.aggregatedItemsPaint,\n                that.aggregatedItemsPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.aggregatedItemsPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.aggregatedItemsPaint = SerialUtilities.readPaint(stream);\n        this.sectionPaints = new HashMap();\n    }\n\n\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"message\": \"The class MultiplePiePlot is declared as Cloneable but does not override the clone() method.\",\n         \"line\": 36,\n         \"column\": 0\n      },\n      {\n         \"message\": \"The class MultiplePiePlot is declared as Serializable but does not implement the writeObject() and readObject() methods for serialization.\",\n         \"line\": 37,\n         \"column\": 0\n      },\n      {\n         \"message\": \"The constructor MultiplePiePlot() calls the constructor MultiplePiePlot(null) without checking for null.\",\n         \"line\": 44,\n         \"column\": 0\n      },\n      {\n         \"message\": \"The method getDataset() does not check for null before returning the dataset.\",\n         \"line\": 143,\n         \"column\": 0\n      },\n      {\n         \"message\": \"The method setDataset() does not check for null before setting the dataset.\",\n         \"line\": 150,\n         \"column\": 0\n      },\n      {\n         \"message\": \"The variable dataExtractOrder is not initialized in the constructor MultiplePiePlot()\",\n         \"line\": 52,\n         \"column\": 0\n      }\n   ]\n}"}}