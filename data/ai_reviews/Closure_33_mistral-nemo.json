{"sample_id": "Closure_33", "model": "mistral-nemo", "code_context": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Bob Jervis\n *   Google Inc.\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino.jstype;\n\nimport static com.google.common.base.Preconditions.checkState;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.rhino.ErrorReporter;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\n\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * The object type represents instances of JavaScript objects such as\n * {@code Object}, {@code Date}, {@code Function}.<p>\n *\n * Objects in JavaScript are unordered collections of properties.\n * Each property consists of a name, a value and a set of attributes.<p>\n *\n * Each instance has an implicit prototype property ({@code [[Prototype]]})\n * pointing to an object instance, which itself has an implicit property, thus\n * forming a chain.<p>\n *\n * A class begins life with no name.  Later, a name may be provided once it\n * can be inferred.  Note that the name in this case is strictly for\n * debugging purposes.  Looking up type name references goes through the\n * {@link JSTypeRegistry}.<p>\n */\nclass PrototypeObjectType extends ObjectType {\n  private static final long serialVersionUID = 1L;\n\n  private final String className;\n  private final Map<String, Property> properties;\n  private final boolean nativeType;\n\n  // NOTE(nicksantos): The implicit prototype can change over time.\n  // Modelling this is a bear. Always call getImplicitPrototype(), because\n  // some subclasses override this to do special resolution handling.\n  private ObjectType implicitPrototypeFallback;\n\n  // If this is a function prototype, then this is the owner.\n  // A PrototypeObjectType can only be the prototype of one function. If we try\n  // to do this for multiple functions, then we'll have to create a new one.\n  private FunctionType ownerFunction = null;\n\n  // Whether the toString representation of this should be pretty-printed,\n  // by printing all properties.\n  private boolean prettyPrint = false;\n\n  private static final int MAX_PRETTY_PRINTED_PROPERTIES = 4;\n\n  /**\n   * Creates an object type.\n   *\n   * @param className the name of the class.  May be {@code null} to\n   *        denote an anonymous class.\n   *\n   * @param implicitPrototype the implicit prototype\n   *        (a.k.a. {@code [[Prototype]]}) as defined by ECMA-262. If the\n   *        implicit prototype is {@code null} the implicit prototype will be\n   *        set to the {@link JSTypeNative#OBJECT_TYPE}.\n   */\n  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype) {\n    this(registry, className, implicitPrototype, false);\n  }\n\n  /**\n   * Creates an object type, allowing specification of the implicit prototype\n   * when creating native objects.\n   */\n  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType) {\n    super(registry);\n    this.properties = Maps.newTreeMap();\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType || implicitPrototype != null) {\n      setImplicitPrototype(implicitPrototype);\n    } else {\n      setImplicitPrototype(\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n    }\n  }\n\n  @Override\n  public Property getSlot(String name) {\n    if (properties.containsKey(name)) {\n      return properties.get(name);\n    }\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      Property prop = implicitPrototype.getSlot(name);\n      if (prop != null) {\n        return prop;\n      }\n    }\n    for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n      Property prop = interfaceType.getSlot(name);\n      if (prop != null) {\n        return prop;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Gets the number of properties of this object.\n   */\n  @Override\n  public int getPropertiesCount() {\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype == null) {\n      return this.properties.size();\n    }\n    int localCount = 0;\n    for (String property : properties.keySet()) {\n      if (!implicitPrototype.hasProperty(property)) {\n        localCount++;\n      }\n    }\n    return implicitPrototype.getPropertiesCount() + localCount;\n  }\n\n  @Override\n  public boolean hasProperty(String propertyName) {\n    // Unknown types have all properties.\n    return isUnknownType() || getSlot(propertyName) != null;\n  }\n\n  @Override\n  public boolean hasOwnProperty(String propertyName) {\n    return properties.get(propertyName) != null;\n  }\n\n  @Override\n  public Set<String> getOwnPropertyNames() {\n    return properties.keySet();\n  }\n\n  @Override\n  public boolean isPropertyTypeDeclared(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return false;\n    }\n    return !slot.isTypeInferred();\n  }\n\n  @Override\n  void collectPropertyNames(Set<String> props) {\n    for (String prop : properties.keySet()) {\n      props.add(prop);\n    }\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      implicitPrototype.collectPropertyNames(props);\n    }\n  }\n\n  @Override\n  public boolean isPropertyTypeInferred(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return false;\n    }\n    return slot.isTypeInferred();\n  }\n\n  @Override\n  public JSType getPropertyType(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    return slot.getType();\n  }\n\n  @Override\n  public boolean isPropertyInExterns(String propertyName) {\n    Property p = properties.get(propertyName);\n    if (p != null) {\n      return p.isFromExterns();\n    }\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      return implicitPrototype.isPropertyInExterns(propertyName);\n    }\n    return false;\n  }\n\n  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    if (hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    Property newProp = new Property(\n        name, type, inferred, propertyNode);\n    Property oldProp = properties.get(name);\n    if (oldProp != null) {\n      // This is to keep previously inferred jsdoc info, e.g., in a\n      // replaceScript scenario.\n      newProp.setJSDocInfo(oldProp.getJSDocInfo());\n    }\n    properties.put(name, newProp);\n    return true;\n  }\n\n  @Override\n  public boolean removeProperty(String name) {\n    return properties.remove(name) != null;\n  }\n\n  @Override\n  public Node getPropertyNode(String propertyName) {\n    Property p = properties.get(propertyName);\n    if (p != null) {\n      return p.getNode();\n    }\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      return implicitPrototype.getPropertyNode(propertyName);\n    }\n    return null;\n  }\n\n  @Override\n  public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n    Property p = properties.get(propertyName);\n    if (p != null) {\n      return p.getJSDocInfo();\n    }\n    return null;\n  }\n\n  @Override\n  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n    if (info != null) {\n      if (!properties.containsKey(propertyName)) {\n        // If docInfo was attached, but the type of the property\n        // was not defined anywhere, then we consider this an explicit\n        // declaration of the property.\n        defineInferredProperty(propertyName, getPropertyType(propertyName),\n            null);\n      }\n\n      // The prototype property is not represented as a normal Property.\n      // We probably don't want to attach any JSDoc to it anyway.\n      Property property = properties.get(propertyName);\n      if (property != null) {\n        property.setJSDocInfo(info);\n      }\n    }\n  }\n\n  @Override\n  public boolean matchesNumberContext() {\n    return isNumberObjectType() || isDateType() || isBooleanObjectType() ||\n        isStringObjectType() || hasOverridenNativeProperty(\"valueOf\");\n  }\n\n  @Override\n  public boolean matchesStringContext() {\n    return isTheObjectType() || isStringObjectType() || isDateType() ||\n        isRegexpType() || isArrayType() || isNumberObjectType() ||\n        isBooleanObjectType() || hasOverridenNativeProperty(\"toString\");\n  }\n\n  /**\n   * Given the name of a native object property, checks whether the property is\n   * present on the object and different from the native one.\n   */\n  private boolean hasOverridenNativeProperty(String propertyName) {\n    if (isNativeObjectType()) {\n      return false;\n    }\n\n    JSType propertyType = getPropertyType(propertyName);\n    ObjectType nativeType =\n        this.isFunctionType() ?\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE) :\n        registry.getNativeObjectType(JSTypeNative.OBJECT_PROTOTYPE);\n    JSType nativePropertyType = nativeType.getPropertyType(propertyName);\n    return propertyType != nativePropertyType;\n  }\n\n  @Override\n  public JSType unboxesTo() {\n    if (isStringObjectType()) {\n      return getNativeType(JSTypeNative.STRING_TYPE);\n    } else if (isBooleanObjectType()) {\n      return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n    } else if (isNumberObjectType()) {\n      return getNativeType(JSTypeNative.NUMBER_TYPE);\n    } else {\n      return super.unboxesTo();\n    }\n  }\n\n  @Override\n  public boolean matchesObjectContext() {\n    return true;\n  }\n\n  @Override\n  public boolean canBeCalled() {\n    return isRegexpType();\n  }\n\n  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Don't pretty print recursively.\n      prettyPrint = false;\n\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n\n        sb.append(property);\n        sb.append(\": \");\n        sb.append(getPropertyType(property).toStringHelper(forAnnotations));\n\n        ++i;\n        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {\n          sb.append(\", ...\");\n          break;\n        }\n      }\n\n      sb.append(\"}\");\n\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      return forAnnotations ? \"?\" : \"{...}\";\n    }\n  }\n\n  void setPrettyPrint(boolean prettyPrint) {\n    this.prettyPrint = prettyPrint;\n  }\n\n  boolean isPrettyPrint() {\n    return prettyPrint;\n  }\n\n  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }\n\n  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototypeFallback;\n  }\n\n  /**\n   * This should only be reset on the FunctionPrototypeType, only to fix an\n   * incorrectly established prototype chain due to the user having a mismatch\n   * in super class declaration, and only before properties on that type are\n   * processed.\n   */\n  final void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototypeFallback = implicitPrototype;\n  }\n\n  @Override\n  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else if (ownerFunction != null) {\n      return ownerFunction.getReferenceName() + \".prototype\";\n    } else {\n      return null;\n    }\n  }\n\n  @Override\n  public boolean hasReferenceName() {\n    return className != null || ownerFunction != null;\n  }\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that.isUnionType()) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that.isRecordType()) {\n      return RecordType.isSubtype(this, that.toMaybeRecordType());\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n    if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    if (getConstructor() != null && getConstructor().isInterface()) {\n      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n      // If unsure, say 'yes', to avoid spurious warnings.\n      // TODO(user): resolve the prototype chain completely in all cases,\n      // to avoid guessing.\n      return true;\n    }\n    return this.isImplicitPrototype(thatObj);\n  }\n\n  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }\n\n  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }\n\n  /** Whether this is a built-in object. */\n  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }\n\n  void setOwnerFunction(FunctionType type) {\n    Preconditions.checkState(ownerFunction == null || type == null);\n    ownerFunction = type;\n  }\n\n  @Override\n  public FunctionType getOwnerFunction() {\n    return ownerFunction;\n  }\n\n  @Override\n  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n    return isFunctionPrototypeType()\n        ? getOwnerFunction().getImplementedInterfaces()\n        : ImmutableList.<ObjectType>of();\n  }\n\n  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return isFunctionPrototypeType()\n        ? getOwnerFunction().getExtendedInterfaces()\n        : ImmutableList.<ObjectType>of();\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      implicitPrototypeFallback =\n          (ObjectType) implicitPrototype.resolve(t, scope);\n    }\n    for (Property prop : properties.values()) {\n      prop.setType(safeResolve(prop.getType(), t, scope));\n    }\n    return this;\n  }\n\n  @Override\n  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!hasProperty(prop)) {\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                .getLeastSupertype(propType);\n          }\n          defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"description\": \"The `implicitPrototypeFallback` field is not initialized in the constructor. This could lead to NullPointerException if it's accessed before being set.\",\n      \"codeSnippet\": \"private ObjectType implicitPrototypeFallback;\"\n    },\n    {\n      \"description\": \"The `ownerFunction` field is not initialized in the constructor. This could lead to NullPointerException if it's accessed before being set.\",\n      \"codeSnippet\": \"private FunctionType ownerFunction = null;\"\n    },\n    {\n      \"description\": \"The `prettyPrint` field is not initialized in the constructor. This could lead to unexpected behavior if it's accessed before being set.\",\n      \"codeSnippet\": \"private boolean prettyPrint = false;\"\n    },\n    {\n      \"description\": \"In the constructor, if `nativeType` is true and `implicitPrototype` is null, the implicit prototype is set to the native object type. However, if `implicitPrototype` is non-null, it should be checked if it's a native type and if so, use that as the implicit prototype instead of the global object type.\",\n      \"codeSnippet\": \"if (nativeType || implicitPrototype != null) { ... } else { ... }\"\n    }\n  ]\n}"}}