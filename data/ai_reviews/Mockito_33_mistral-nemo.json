{"sample_id": "Mockito_33", "model": "mistral-nemo", "code_context": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.invocation;\n\nimport java.io.Serializable;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.exceptions.PrintableInvocation;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.matchers.CapturesArguments;\nimport org.mockito.internal.reporting.PrintSettings;\nimport org.mockito.internal.reporting.PrintingFriendlyInvocation;\n\n@SuppressWarnings(\"unchecked\")\npublic class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation, Serializable {\n\n    private static final long serialVersionUID = -3047126096857467610L;\n    private final Invocation invocation;\n    private final List<Matcher> matchers;\n\n    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = invocation.argumentsToMatchers();\n        } else {\n            this.matchers = matchers;\n        }\n    }\n    \n    public InvocationMatcher(Invocation invocation) {\n        this(invocation, Collections.<Matcher>emptyList());\n    }\n\n    public Method getMethod() {\n        return invocation.getMethod();\n    }\n    \n    public Invocation getInvocation() {\n        return this.invocation;\n    }\n    \n    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }\n    \n    public String toString() {\n        return invocation.toString(matchers, new PrintSettings());\n    }\n\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n    private boolean safelyArgumentsMatch(Object[] actualArgs) {\n        try {\n            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n        } catch (Throwable t) {\n            return false;\n        }\n    }\n\n    /**\n     * similar means the same method name, same mock, unverified \n     * and: if arguments are the same cannot be overloaded\n     */\n    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }\n\n    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        \t/* Avoid unnecessary cloning */\n        return m1.equals(m2);\n    }\n    \n    public Location getLocation() {\n        return invocation.getLocation();\n    }\n\n    public String toString(PrintSettings printSettings) {\n        return invocation.toString(matchers, printSettings);\n    }\n\n    public void captureArgumentsFrom(Invocation i) {\n        int k = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n            }\n            k++;\n        }\n    }\n\n    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n\n        for (Invocation i : invocations) {\n            out.add(new InvocationMatcher(i));\n        }\n\n        return out;\n    }\n}", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"description\": \"Typo in interface name\",\n      \"line_number\": 16,\n      \"reason\": \"The interface name 'CapturesArgumensFromInvocation' has a typo. It should be 'CapturesArgumentsFromInvocation'.\"\n    },\n    {\n      \"description\": \"Potential NullPointerException in getMatchers()\",\n      \"line_number\": 22,\n      \"reason\": \"If the 'matchers' list is empty, it calls 'invocation.argumentsToMatchers()', which could return null. This could lead to a NullPointerException when trying to access 'matchers.toArray()' in 'toString()'.\"\n    },\n    {\n      \"description\": \"Potential NullPointerException in getMethod()\",\n      \"line_number\": 34,\n      \"reason\": \"If the 'invocation' object is null, calling 'invocation.getMethod()' will throw a NullPointerException.\"\n    },\n    {\n      \"description\": \"Potential NullPointerException in hasSimilarMethod()\",\n      \"line_number\": 60,\n      \"reason\": \"If 'candidate' is null, calling 'candidate.getMethod().getName()' will throw a NullPointerException.\"\n    },\n    {\n      \"description\": \"Potential NullPointerException in hasSameMethod()\",\n      \"line_number\": 73,\n      \"reason\": \"If 'invocation' or 'candidate' is null, calling 'invocation.getMethod()' or 'candidate.getMethod()' will throw a NullPointerException.\"\n    },\n    {\n      \"description\": \"Potential NullPointerException in getLocation()\",\n      \"line_number\": 97,\n      \"reason\": \"If 'invocation' is null, calling 'invocation.getLocation()' will throw a NullPointerException.\"\n    },\n    {\n      \"description\": \"Potential NullPointerException in toString(PrintSettings)\",\n      \"line_number\": 106,\n      \"reason\": \"If 'printSettings' is null, it calls 'invocation.toString(matchers, printSettings)', which could throw a NullPointerException.\"\n    },\n    {\n      \"description\": \"Potential NullPointerException in captureArgumentsFrom()\",\n      \"line_number\": 119,\n      \"reason\": \"If 'i' (the Invocation object) is null, calling 'i.getArguments()[k]' will throw a NullPointerException.\"\n    },\n    {\n      \"description\": \"Potential NullPointerException in createFrom()\",\n      \"line_number\": 133,\n      \"reason\": \"If 'invocations' is null, or any of the 'Invocation' objects in the list are null, it will throw a NullPointerException when creating a new 'InvocationMatcher'.\"\n    }\n  ]\n}"}}