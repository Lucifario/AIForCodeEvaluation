{"sample_id": "Math_49", "model": "qwen-coder-32b", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math.linear;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.exception.MathArithmeticException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap;\nimport org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\nimport org.apache.commons.math.util.FastMath;\n\n/**\n * This class implements the {@link RealVector} interface with a\n * {@link OpenIntToDoubleHashMap} backing store.\n * @version $Id$\n * @since 2.0\n*/\npublic class OpenMapRealVector extends AbstractRealVector\n    implements SparseRealVector, Serializable {\n    /** Default Tolerance for having a value considered zero. */\n    public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\n    /** Serializable version identifier. */\n    private static final long serialVersionUID = 8772222695580707260L;\n    /** Entries of the vector. */\n    private final OpenIntToDoubleHashMap entries;\n    /** Dimension of the vector. */\n    private final int virtualSize;\n    /** Tolerance for having a value considered zero. */\n    private final double epsilon;\n\n    /**\n     * Build a 0-length vector.\n     * Zero-length vectors may be used to initialized construction of vectors\n     * by data gathering. We start with zero-length and use either the {@link\n     * #OpenMapRealVector(OpenMapRealVector, int)} constructor\n     * or one of the {@code append} method ({@link #append(double)}, {@link\n     * #append(double[])}, {@link #append(RealVector)}) to gather data\n     * into this vector.\n     */\n    public OpenMapRealVector() {\n        this(0, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Construct a vector of zeroes.\n     *\n     * @param dimension Size of the vector.\n     */\n    public OpenMapRealVector(int dimension) {\n        this(dimension, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Construct a vector of zeroes, specifying zero tolerance.\n     *\n     * @param dimension Size of the vector.\n     * @param epsilon Tolerance below which a value considered zero.\n     */\n    public OpenMapRealVector(int dimension, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * Build a resized vector, for use with append.\n     *\n     * @param v Original vector.\n     * @param resize Amount to add.\n     */\n    protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n        virtualSize = v.getDimension() + resize;\n        entries = new OpenIntToDoubleHashMap(v.entries);\n        epsilon = v.epsilon;\n    }\n\n    /**\n     * Build a vector with known the sparseness (for advanced use only).\n     *\n     * @param dimension Size of the vector.\n     * @param expectedSize The expected number of non-zero entries.\n     */\n    public OpenMapRealVector(int dimension, int expectedSize) {\n        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Build a vector with known the sparseness and zero tolerance\n     * setting (for advanced use only).\n     *\n     * @param dimension Size of the vector.\n     * @param expectedSize Expected number of non-zero entries.\n     * @param epsilon Tolerance below which a value is considered zero.\n     */\n    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * Create from an array.\n     * Only non-zero entries will be stored.\n     *\n     * @param values Set of values to create from.\n     */\n    public OpenMapRealVector(double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Create from an array, specifying zero tolerance.\n     * Only non-zero entries will be stored.\n     *\n     * @param values Set of values to create from.\n     * @param epsilon Tolerance below which a value is considered zero.\n     */\n    public OpenMapRealVector(double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key];\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Create from an array.\n     * Only non-zero entries will be stored.\n     *\n     * @param values The set of values to create from\n     */\n    public OpenMapRealVector(Double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Create from an array.\n     * Only non-zero entries will be stored.\n     *\n     * @param values Set of values to create from.\n     * @param epsilon Tolerance below which a value is considered zero.\n     */\n    public OpenMapRealVector(Double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key].doubleValue();\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Copy constructor.\n     *\n     * @param v Instance to copy from.\n     */\n    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }\n\n    /**\n     * Generic copy constructor.\n     *\n     * @param v Instance to copy from.\n     */\n    public OpenMapRealVector(RealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(0.0);\n        epsilon = DEFAULT_ZERO_TOLERANCE;\n        for (int key = 0; key < virtualSize; key++) {\n            double value = v.getEntry(key);\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Get the entries of this instance.\n     *\n     * @return the entries of this instance.\n     */\n    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }\n\n    /**\n     * Determine if this value is within epsilon of zero.\n     *\n     * @param value Value to test\n     * @return {@code true} if this value is within epsilon to zero,\n     * {@code false} otherwise.\n     * @since 2.1\n     */\n    protected boolean isDefaultValue(double value) {\n        return FastMath.abs(value) < epsilon;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n        public RealVector add(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return add((OpenMapRealVector) v);\n        } else {\n            return super.add(v);\n        }\n    }\n\n    /**\n     * Optimized method to add two OpenMapRealVectors.\n     * It copies the larger vector, then iterates over the smaller.\n     *\n     * @param v Vector to add.\n     * @return the sum of {@code this} and {@code v}.\n     * @throws org.apache.commons.math.exception.DimensionMismatchException\n     * if the dimensions do not match.\n     */\n    public OpenMapRealVector add(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        boolean copyThis = entries.size() > v.entries.size();\n        OpenMapRealVector res = copyThis ? this.copy() : v.copy();\n        Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();\n        OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (randomAccess.containsKey(key)) {\n                res.setEntry(key, randomAccess.get(key) + iter.value());\n            } else {\n                res.setEntry(key, iter.value());\n            }\n        }\n        return res;\n    }\n\n    /**\n     * Optimized method to append a OpenMapRealVector.\n     * @param v vector to append\n     * @return The result of appending {@code v} to self\n     */\n    public OpenMapRealVector append(OpenMapRealVector v) {\n        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n        Iterator iter = v.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key() + virtualSize, iter.value());\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector append(RealVector v) {\n        if (v instanceof OpenMapRealVector) {\n            return append((OpenMapRealVector) v);\n        }\n        return append(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector append(double d) {\n        OpenMapRealVector res = new OpenMapRealVector(this, 1);\n        res.setEntry(virtualSize, d);\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector append(double[] a) {\n        OpenMapRealVector res = new OpenMapRealVector(this, a.length);\n        for (int i = 0; i < a.length; i++) {\n            res.setEntry(i + virtualSize, a[i]);\n        }\n        return res;\n    }\n\n    /**\n     * {@inheritDoc}\n     * @since 2.1\n     */\n    @Override\n    public OpenMapRealVector copy() {\n        return new OpenMapRealVector(this);\n    }\n\n    /**\n     * Optimized method to compute the dot product with an OpenMapRealVector.\n     * It iterates over the smallest of the two.\n     *\n     * @param v Cector to compute the dot product with.\n     * @return the dot product of {@code this} and {@code v}.\n     * @throws org.apache.commons.math.exception.DimensionMismatchException\n     * if the dimensions do not match.\n     */\n    public double dotProduct(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        boolean thisIsSmaller  = entries.size() < v.entries.size();\n        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;\n        double d = 0;\n        while(iter.hasNext()) {\n            iter.advance();\n            d += iter.value() * larger.get(iter.key());\n        }\n        return d;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double dotProduct(RealVector v) {\n        if(v instanceof OpenMapRealVector) {\n            return dotProduct((OpenMapRealVector)v);\n        } else {\n            return super.dotProduct(v);\n        }\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector ebeDivide(double[] v) {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector ebeMultiply(double[] v) {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public OpenMapRealVector getSubVector(int index, int n) {\n        checkIndex(index);\n        checkIndex(index + n - 1);\n        OpenMapRealVector res = new OpenMapRealVector(n);\n        int end = index + n;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (key >= index && key < end) {\n                res.setEntry(key - index, iter.value());\n            }\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double[] getData() {\n        double[] res = new double[virtualSize];\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res[iter.key()] = iter.value();\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public int getDimension() {\n        return virtualSize;\n    }\n\n    /**\n     * Optimized method to compute distance.\n     *\n     * @param v Vector to compute distance to.\n     * @return the distance from {@code this} and {@code v}.\n     * @throws org.apache.commons.math.exception.DimensionMismatchException\n     * if the dimensions do not match.\n     */\n    public double getDistance(OpenMapRealVector v) {\n        Iterator iter = entries.iterator();\n        double res = 0;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            double delta;\n            delta = iter.value() - v.getEntry(key);\n            res += delta * delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                final double value = iter.value();\n                res += value * value;\n            }\n        }\n        return FastMath.sqrt(res);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double getDistance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getDistance((OpenMapRealVector) v);\n        }\n        return getDistance(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double getDistance(double[] v) {\n        checkVectorDimensions(v.length);\n        double res = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = entries.get(i) - v[i];\n            res += delta * delta;\n        }\n        return FastMath.sqrt(res);\n    }\n\n    /** {@inheritDoc} */\n    public double getEntry(int index) {\n        checkIndex(index);\n        return entries.get(index);\n    }\n\n    /**\n     * Distance between two vectors.\n     * This method computes the distance consistent with\n     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n     * elements differences.\n     *\n     * @param v Vector to which distance is requested.\n     * @return distance between this vector and {@code v}.\n     */\n    public double getL1Distance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n            max += delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                double delta = FastMath.abs(iter.value());\n                max +=  FastMath.abs(delta);\n            }\n        }\n        return max;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double getL1Distance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getL1Distance((OpenMapRealVector) v);\n        }\n        return getL1Distance(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double getL1Distance(double[] v) {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = FastMath.abs(getEntry(i) - v[i]);\n            max += delta;\n        }\n        return max;\n    }\n\n    /**\n     * Optimized method to compute LInfDistance.\n     *\n     * @param v Vector to compute distance from.\n     * @return the LInfDistance.\n     */\n    private double getLInfDistance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                if (iter.value() > max) {\n                    max = iter.value();\n                }\n            }\n        }\n        return max;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double getLInfDistance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getLInfDistance((OpenMapRealVector) v);\n        }\n        return getLInfDistance(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double getLInfDistance(double[] v) {\n        checkVectorDimensions(v.length);\n        double max = 0;\n        for (int i = 0; i < v.length; i++) {\n            double delta = FastMath.abs(getEntry(i) - v[i]);\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        return max;\n    }\n\n    /** {@inheritDoc} */\n    public boolean isInfinite() {\n        boolean infiniteFound = false;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            final double value = iter.value();\n            if (Double.isNaN(value)) {\n                return false;\n            }\n            if (Double.isInfinite(value)) {\n                infiniteFound = true;\n            }\n        }\n        return infiniteFound;\n    }\n\n    /** {@inheritDoc} */\n    public boolean isNaN() {\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            if (Double.isNaN(iter.value())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector mapAdd(double d) {\n        return copy().mapAddToSelf(d);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector mapAddToSelf(double d) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, getEntry(i) + d);\n        }\n        return this;\n    }\n\n     /** {@inheritDoc} */\n    @Override\n    public RealMatrix outerProduct(double[] v) {\n        final int n = v.length;\n        RealMatrix res = new OpenMapRealMatrix(virtualSize, n);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int row = iter.key();\n            double value = iter.value();\n            for (int col = 0; col < n; col++) {\n                res.setEntry(row, col, value * v[col]);\n            }\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    public RealVector projection(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector projection(double[] v) {\n        checkVectorDimensions(v.length);\n        return (OpenMapRealVector) projection(new OpenMapRealVector(v));\n    }\n\n    /** {@inheritDoc} */\n    public void setEntry(int index, double value) {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setSubVector(int index, RealVector v) {\n        checkIndex(index);\n        checkIndex(index + v.getDimension() - 1);\n        setSubVector(index, v.getData());\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setSubVector(int index, double[] v) {\n        checkIndex(index);\n        checkIndex(index + v.length - 1);\n        for (int i = 0; i < v.length; i++) {\n            setEntry(i + index, v[i]);\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void set(double value) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, value);\n        }\n    }\n\n    /**\n     * Optimized method to subtract OpenMapRealVectors.\n     *\n     * @param v Vector to subtract from {@code this}.\n     * @return the difference of {@code this} and {@code v}.\n     * @throws org.apache.commons.math.exception.DimensionMismatchException\n     * if the dimensions do not match.\n     */\n    public OpenMapRealVector subtract(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = copy();\n        Iterator iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (entries.containsKey(key)) {\n                res.setEntry(key, entries.get(key) - iter.value());\n            } else {\n                res.setEntry(key, -iter.value());\n            }\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector subtract(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return subtract((OpenMapRealVector) v);\n        }\n        return subtract(v.getData());\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector subtract(double[] v) {\n        checkVectorDimensions(v.length);\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        for (int i = 0; i < v.length; i++) {\n            if (entries.containsKey(i)) {\n                res.setEntry(i, entries.get(i) - v[i]);\n            } else {\n                res.setEntry(i, -v[i]);\n            }\n        }\n        return res;\n    }\n\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector unitVector() {\n        OpenMapRealVector res = copy();\n        res.unitize();\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void unitize() {\n        double norm = getNorm();\n        if (isDefaultValue(norm)) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            entries.put(iter.key(), iter.value() / norm);\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double[] toArray() {\n        return getData();\n    }\n\n    /**\n     * {@inheritDoc}\n     * Implementation Note: This works on exact values, and as a result\n     * it is possible for {@code a.subtract(b)} to be the zero vector, while\n     * {@code a.hashCode() != b.hashCode()}.\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(epsilon);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + virtualSize;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            temp = Double.doubleToLongBits(iter.value());\n            result = prime * result + (int) (temp ^ (temp >>32));\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     * Implementation Note: This performs an exact comparison, and as a result\n     * it is possible for {@code a.subtract(b}} to be the zero vector, while\n     * {@code  a.equals(b) == false}.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof OpenMapRealVector)) {\n            return false;\n        }\n        OpenMapRealVector other = (OpenMapRealVector) obj;\n        if (virtualSize != other.virtualSize) {\n            return false;\n        }\n        if (Double.doubleToLongBits(epsilon) !=\n            Double.doubleToLongBits(other.epsilon)) {\n            return false;\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = other.getEntry(iter.key());\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {\n                return false;\n            }\n        }\n        iter = other.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = iter.value();\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     *\n     * @return the percentage of none zero elements as a decimal percent.\n     * @since 2.2\n     */\n    public double getSparsity() {\n        return (double)entries.size()/(double)getDimension();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public java.util.Iterator<Entry> sparseIterator() {\n        return new OpenMapSparseIterator();\n    }\n\n    /**\n     * Implementation of {@code Entry} optimized for OpenMap.\n     * This implementation does not allow arbitrary calls to {@code setIndex}\n     * since the order in which entries are returned is undefined.\n     */\n    protected class OpenMapEntry extends Entry {\n        /** Iterator pointing to the entry. */\n        private final Iterator iter;\n\n        /**\n         * Build an entry from an iterator point to an element.\n         *\n         * @param iter Iterator pointing to the entry.\n         */\n        protected OpenMapEntry(Iterator iter) {\n            this.iter = iter;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public double getValue() {\n            return iter.value();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void setValue(double value) {\n            entries.put(iter.key(), value);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int getIndex() {\n            return iter.key();\n        }\n\n    }\n\n    /**\n     * Iterator class to do iteration over just the non-zero elements.\n     * This implementation is fail-fast, so cannot be used to modify\n     * any zero element.\n     */\n    protected class OpenMapSparseIterator implements java.util.Iterator<Entry> {\n        /** Underlying iterator. */\n        private final Iterator iter;\n        /** Current entry. */\n        private final Entry current;\n\n        /** Simple constructor. */\n        protected OpenMapSparseIterator() {\n            iter = entries.iterator();\n            current = new OpenMapEntry(iter);\n        }\n\n        /** {@inheritDoc} */\n        public boolean hasNext() {\n            return iter.hasNext();\n        }\n\n        /** {@inheritDoc} */\n        public Entry next() {\n            iter.advance();\n            return current;\n        }\n\n        /** {@inheritDoc} */\n        public void remove() {\n            throw new UnsupportedOperationException(\"Not supported\");\n        }\n    }\n}\n", "review": {"response": "<think>\nOkay, let's look at this Java code for the OpenMapRealVector class. The user wants me to review it for bugs and return a JSON list of bugs. I need to carefully go through each part of the code to spot any issues.\n\nFirst, I'll start with the imports. The code imports org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator. Wait, that might be a problem because the OpenIntToDoubleHashMap's Iterator is a nested class. If the code uses the same name as the imported class, there could be a conflict. For example, if they try to use Iterator from the HashMap, but the import is shadowing it. But maybe that's intentional. I need to check where the Iterator is used. Looking at the code, I don't see any usage of Iterator in the provided code, so maybe that's just an unused import. But the user is asking for bugs, so maybe that's not a critical issue. I'll note that as a possible unused import but not a bug unless it causes a problem.\n\nNext, looking at the class declaration. It's public, extends AbstractRealVector, implements SparseRealVector and Serializable. The serialVersionUID is set, which is good. The fields are entries, virtualSize, epsilon. All seem correctly declared as private.\n\nLooking at the constructors. The first one is public OpenMapRealVector() which calls this(0, DEFAULT_ZERO_TOLERANCE). That seems okay. Then the constructor with int dimension, which calls this(dimension, DEFAULT...). Also okay.\n\nIn the constructor that takes dimension and epsilon, they set virtualSize, entries, and this.epsilon. The entries are initialized with new OpenIntToDoubleHashMap(0.0). The 0.0 is the default value, which is correct. So that's fine.\n\nThe protected constructor that takes another OpenMapRealVector and resize. It sets virtualSize to v's dimension plus resize. Then entries is a new OpenIntToDoubleHashMap(v.entries). But wait, if the OpenIntToDoubleHashMap's copy constructor is a shallow copy, then modifying the entries in the new object might affect the original. But maybe that's intentional or depends on the implementation. However, the code here is creating a new instance with the same entries. That seems okay unless the library's HashMap isn't copy-on-write. But that's more of a design choice rather than a bug. Not sure if that's a problem here. Maybe not a bug unless there's a need for a deep copy, but the code might not require it. I'll note that as a possible issue if the original vector's entries are modified later, but maybe the design is okay.\n\nLooking at the constructor with dimension, expectedSize, and epsilon. The entries are initialized with new OpenIntToDoubleHashMap(expectedSize, 0.0). That seems correct.\n\nThe next constructor is from a double array. The code loops through each element, checks if it's not a default value (using isDefaultValue), and adds it to the entries. The isDefaultValue method is probably checking against epsilon. But let's check the code for that method. Wait, in the code provided, I don't see the isDefaultValue method. Oh, it's part of the class, but the user hasn't provided the full code. So maybe that's a method that's defined elsewhere. Assuming that isDefaultValue is correctly implemented to compare the value against epsilon (the zero tolerance), then that's okay. But if that method is missing or has a bug, that could be an issue. However, since the user hasn't provided that method, I can't be sure. But in the code given, the method call is there, so assuming it's present, maybe that's okay.\n\nNow, looking at the constructor that takes a Double[] array. The code initializes virtualSize, entries, epsilon, then loops through each element. The line in question is:\n\ndouble value = values[key].doubleValue();\nif (!isDefaultValue(value)) {\n    entries.put(key, value)``` \n\nWait, the code ends with a ``` here. Oh, the user's code is cut off here. The line ends with entries.put(key, value) without a semicolon. That's a syntax error. So the last line in that constructor is missing a semicolon. That's definitely a bug. The code as written would not compile because of the missing semicolon.\n\nAnother thing: in the Double[] constructor, when converting from Double to double, there's a possibility of a NullPointerException if any element in the values array is null. Since the array is of type Double[], which is an array of objects, if any element is null, calling doubleValue() would throw NPE. The code doesn't handle that. So that's a potential bug if the input array contains nulls.\n\nLooking at other parts: in the create from double[] constructor, the code checks for non-zero entries. But what about NaN or infinite values? The isDefaultValue method might not handle those correctly, but again, that depends on how it's implemented. Since the code isn't provided, maybe that's an assumption.\n\nAnother thing: the virtualSize is set based on the input array's length in the constructors that take arrays. But what if the array is empty? For example, if the array has zero length, then virtualSize is zero, which is okay. But if the code expects the vector to have a certain dimension, maybe that's handled correctly.\n\nLooking at the protected constructor that resizes. It uses v.entries, which is a copy. If the entries are modified in the new object, does that affect the original? If the OpenIntToDoubleHashMap is a mutable structure and the copy is a shallow copy, then yes. But again, that depends on the implementation of the HashMap. If the library's HashMap is designed to be copied safely, then it's okay. Otherwise, it's a potential bug. However, without knowing the internal workings of OpenIntToDoubleHashMap, it's hard to say. Maybe that's a design choice rather than a bug.\n\nAnother thing: in the OpenMapRealVector(Double[] values, double epsilon) constructor, after putting the value into entries, there's a missing semicolon. Also, the code is cut off there. So the line should be entries.put(key, value);. So that's a syntax error.\n\nAdditionally, in that same constructor, if the Double array has elements that are null, then values[key].doubleValue() will throw a NullPointerException. So the code doesn't handle nulls in the input array. That's a bug if the input is allowed to have nulls.\n\nSo summarizing the bugs I found:\n\n1. Missing semicolon in the line entries.put(key, value) in the Double[] constructor. That's a syntax error.\n\n2. Potential NullPointerException in the same constructor when handling null elements in the Double array.\n\n3. The import of Iterator from OpenIntToDoubleHashMap might be shadowing another Iterator class, but unless it's used, it's just an unused import, not a bug.\n\n4. The copy constructor (protected one) may have a problem if the HashMap is not properly copied, but that's more of a logical issue depending on the HashMap's implementation.\n\nBut since the user is asking for bugs in the provided code, the first two are definite issues. The others may be considered depending on context.\n\nSo the JSON should list these bugs.\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"line\": 117,\n      \"description\": \"Missing semicolon at the end of the line 'entries.put(key, value)' in the constructor OpenMapRealVector(Double[], double). This will cause a compilation error.\"\n    },\n    {\n      \"line\": 117,\n      \"description\": \"Potential NullPointerException when converting elements of the Double[] array to double using 'values[key].doubleValue()' if any element in the array is null. The code does not handle null values in the input array.\"\n    }\n  ]\n}\n```"}}