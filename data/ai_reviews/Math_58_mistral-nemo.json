{"sample_id": "Math_58", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.optimization.fitting;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\nimport org.apache.commons.math.analysis.function.Gaussian;\nimport org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\nimport org.apache.commons.math.exception.NullArgumentException;\nimport org.apache.commons.math.exception.NumberIsTooSmallException;\nimport org.apache.commons.math.exception.OutOfRangeException;\nimport org.apache.commons.math.exception.ZeroException;\nimport org.apache.commons.math.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\nimport org.apache.commons.math.optimization.fitting.CurveFitter;\nimport org.apache.commons.math.optimization.fitting.WeightedObservedPoint;\n\n/**\n * Fits points to a {@link\n * org.apache.commons.math.analysis.function.Gaussian.Parametric Gaussian} function.\n * <p>\n * Usage example:\n * <pre>\n *   GaussianFitter fitter = new GaussianFitter(\n *     new LevenbergMarquardtOptimizer());\n *   fitter.addObservedPoint(4.0254623,  531026.0);\n *   fitter.addObservedPoint(4.03128248, 984167.0);\n *   fitter.addObservedPoint(4.03839603, 1887233.0);\n *   fitter.addObservedPoint(4.04421621, 2687152.0);\n *   fitter.addObservedPoint(4.05132976, 3461228.0);\n *   fitter.addObservedPoint(4.05326982, 3580526.0);\n *   fitter.addObservedPoint(4.05779662, 3439750.0);\n *   fitter.addObservedPoint(4.0636168,  2877648.0);\n *   fitter.addObservedPoint(4.06943698, 2175960.0);\n *   fitter.addObservedPoint(4.07525716, 1447024.0);\n *   fitter.addObservedPoint(4.08237071, 717104.0);\n *   fitter.addObservedPoint(4.08366408, 620014.0);\n *   double[] parameters = fitter.fit();\n * </pre>\n *\n * @since 2.2\n * @version $Revision$ $Date$\n */\npublic class GaussianFitter extends CurveFitter {\n    /**\n     * Constructs an instance using the specified optimizer.\n     *\n     * @param optimizer Optimizer to use for the fitting.\n     */\n    public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {\n        super(optimizer);\n    }\n\n    /**\n     * Fits a Gaussian function to the observed points.\n     *\n     * @param initialGuess First guess values in the following order:\n     * <ul>\n     *  <li>Norm</li>\n     *  <li>Mean</li>\n     *  <li>Sigma</li>\n     * </ul>\n     * @return the parameters of the Gaussian function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit(double[] initialGuess) {\n        final ParametricUnivariateRealFunction f = new ParametricUnivariateRealFunction() {\n                private final ParametricUnivariateRealFunction g = new Gaussian.Parametric();\n\n                public double value(double x, double[] p) {\n                    double v = Double.POSITIVE_INFINITY;\n                    try {\n                        v = g.value(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        // Do nothing.\n                    }\n                    return v;\n                }\n\n                public double[] gradient(double x, double[] p) {\n                    double[] v = { Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY,\n                                   Double.POSITIVE_INFINITY };\n                    try {\n                        v = g.gradient(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        // Do nothing.\n                    }\n                    return v;\n                }\n            };\n\n        return fit(f, initialGuess);\n    }\n\n    /**\n     * Fits a Gaussian function to the observed points.\n     *\n     * @return the parameters of the Gaussian function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(new Gaussian.Parametric(), guess);\n    }\n\n    /**\n     * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n     * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n     * based on the specified observed points.\n     */\n    public static class ParameterGuesser {\n        /** Observed points. */\n        private final WeightedObservedPoint[] observations;\n        /** Resulting guessed parameters. */\n        private double[] parameters;\n\n        /**\n         * Constructs instance with the specified observed points.\n         *\n         * @param observations observed points upon which should base guess\n         */\n        public ParameterGuesser(WeightedObservedPoint[] observations) {\n            if (observations == null) {\n                throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n            }\n            if (observations.length < 3) {\n                throw new NumberIsTooSmallException(observations.length, 3, true);\n            }\n            this.observations = observations.clone();\n        }\n\n        /**\n         * Guesses the parameters based on the observed points.\n         *\n         * @return the guessed parameters: norm, mean and sigma.\n         */\n        public double[] guess() {\n            if (parameters == null) {\n                parameters = basicGuess(observations);\n            }\n            return parameters.clone();\n        }\n\n        /**\n         * Guesses the parameters based on the specified observed points.\n         *\n         * @param points Observed points upon which should base guess.\n         * @return the guessed parameters: norm, mean and sigma.\n         */\n        private double[] basicGuess(WeightedObservedPoint[] points) {\n            Arrays.sort(points, createWeightedObservedPointComparator());\n            double[] params = new double[3];\n\n            int maxYIdx = findMaxY(points);\n            params[0] = points[maxYIdx].getY();\n            params[1] = points[maxYIdx].getX();\n\n            double fwhmApprox;\n            try {\n                double halfY = params[0] + ((params[1] - params[0]) / 2.0);\n                double fwhmX1 = interpolateXAtY(points, maxYIdx, -1, halfY);\n                double fwhmX2 = interpolateXAtY(points, maxYIdx, +1, halfY);\n                fwhmApprox = fwhmX2 - fwhmX1;\n            } catch (OutOfRangeException e) {\n                fwhmApprox = points[points.length - 1].getX() - points[0].getX();\n            }\n            params[2] = fwhmApprox / (2.0 * Math.sqrt(2.0 * Math.log(2.0)));\n\n            return params;\n        }\n\n        /**\n         * Finds index of point in specified points with the largest Y.\n         *\n         * @param points Points to search.\n         * @return the index in specified points array.\n         */\n        private int findMaxY(WeightedObservedPoint[] points) {\n            int maxYIdx = 0;\n            for (int i = 1; i < points.length; i++) {\n                if (points[i].getY() > points[maxYIdx].getY()) {\n                    maxYIdx = i;\n                }\n            }\n            return maxYIdx;\n        }\n\n        /**\n         * Interpolates using the specified points to determine X at the\n         * specified Y.\n         *\n         * @param points Points to use for interpolation.\n         * @param startIdx Index within points from which to start search for\n         *  interpolation bounds points.\n         * @param idxStep Index step for search for interpolation bounds points.\n         * @param y Y value for which X should be determined.\n         * @return the value of X at the specified Y.\n         * @throws ZeroException if {@code idxStep} is 0.\n         * @throws OutOfRangeException if specified {@code y} is not within the\n         * range of the specified {@code points}.\n         */\n        private double interpolateXAtY(WeightedObservedPoint[] points,\n                                       int startIdx, int idxStep, double y)\n            throws OutOfRangeException {\n            if (idxStep == 0) {\n                throw new ZeroException();\n            }\n            WeightedObservedPoint[] twoPoints = getInterpolationPointsForY(points, startIdx, idxStep, y);\n            WeightedObservedPoint pointA = twoPoints[0];\n            WeightedObservedPoint pointB = twoPoints[1];\n            if (pointA.getY() == y) {\n                return pointA.getX();\n            }\n            if (pointB.getY() == y) {\n                return pointB.getX();\n            }\n            return pointA.getX() +\n                   (((y - pointA.getY()) * (pointB.getX() - pointA.getX())) /\n                    (pointB.getY() - pointA.getY()));\n        }\n\n        /**\n         * Gets the two bounding interpolation points from the specified points\n         * suitable for determining X at the specified Y.\n         *\n         * @param points Points to use for interpolation.\n         * @param startIdx Index within points from which to start search for\n         * interpolation bounds points.\n         * @param idxStep Index step for search for interpolation bounds points.\n         * @param y Y value for which X should be determined.\n         * @return the array containing two points suitable for determining X at\n         * the specified Y.\n         * @throws ZeroException if {@code idxStep} is 0.\n         * @throws OutOfRangeException if specified {@code y} is not within the\n         * range of the specified {@code points}.\n         */\n        private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points,\n                                                                   int startIdx, int idxStep, double y)\n            throws OutOfRangeException {\n            if (idxStep == 0) {\n                throw new ZeroException();\n            }\n            for (int i = startIdx;\n                 (idxStep < 0) ? (i + idxStep >= 0) : (i + idxStep < points.length);\n                 i += idxStep) {\n                if (isBetween(y, points[i].getY(), points[i + idxStep].getY())) {\n                    return (idxStep < 0) ?\n                           new WeightedObservedPoint[] { points[i + idxStep], points[i] } :\n                           new WeightedObservedPoint[] { points[i], points[i + idxStep] };\n                }\n            }\n\n            double minY = Double.POSITIVE_INFINITY;\n            double maxY = Double.NEGATIVE_INFINITY;\n            for (final WeightedObservedPoint point : points) {\n                minY = Math.min(minY, point.getY());\n                maxY = Math.max(maxY, point.getY());\n            }\n            throw new OutOfRangeException(y, minY, maxY);\n        }\n\n        /**\n         * Determines whether a value is between two other values.\n         *\n         * @param value Value to determine whether is between {@code boundary1}\n         * and {@code boundary2}.\n         * @param boundary1 One end of the range.\n         * @param boundary2 Other end of the range.\n         * @return {@code true} if {@code value} is between {@code boundary1} and\n         * {@code boundary2} (inclusive), {@code false} otherwise.\n         */\n        private boolean isBetween(double value, double boundary1, double boundary2) {\n            return (value >= boundary1 && value <= boundary2) ||\n                   (value >= boundary2 && value <= boundary1);\n        }\n\n        /**\n         * Factory method creating {@code Comparator} for comparing\n         * {@code WeightedObservedPoint} instances.\n         *\n         * @return the new {@code Comparator} instance.\n         */\n        private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\n            return new Comparator<WeightedObservedPoint>() {\n                public int compare(WeightedObservedPoint p1, WeightedObservedPoint p2) {\n                    if (p1 == null && p2 == null) {\n                        return 0;\n                    }\n                    if (p1 == null) {\n                        return -1;\n                    }\n                    if (p2 == null) {\n                        return 1;\n                    }\n                    if (p1.getX() < p2.getX()) {\n                        return -1;\n                    }\n                    if (p1.getX() > p2.getX()) {\n                        return 1;\n                    }\n                    if (p1.getY() < p2.getY()) {\n                        return -1;\n                    }\n                    if (p1.getY() > p2.getY()) {\n                        return 1;\n                    }\n                    if (p1.getWeight() < p2.getWeight()) {\n                        return -1;\n                    }\n                    if (p1.getWeight() > p2.getWeight()) {\n                        return 1;\n                    }\n                    return 0;\n                }\n            };\n        }\n    }\n}\n", "review": {"response": "{\"bugs\": []}"}}