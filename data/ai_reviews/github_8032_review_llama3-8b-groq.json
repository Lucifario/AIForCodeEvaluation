{
  "source_item_id": 8032,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:44:53.851646",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.StandardSystemProperty.JAVA_IO_TMPDIR;\nimport static com.google.common.base.StandardSystemProperty.USER_NAME;\nimport static com.google.common.base.Throwables.throwIfUnchecked;\nimport static java.nio.file.attribute.AclEntryFlag.DIRECTORY_INHERIT;\nimport static java.nio.file.attribute.AclEntryFlag.FILE_INHERIT;\nimport static java.nio.file.attribute.AclEntryType.ALLOW;\nimport static java.nio.file.attribute.PosixFilePermissions.asFileAttribute;\nimport static java.util.Objects.requireNonNull;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.J2ktIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableList;\nimport com.google.j2objc.annotations.J2ObjCIncompatible;\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclEntryPermission;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.PosixFilePermissions;\nimport java.nio.file.attribute.UserPrincipal;\nimport java.util.EnumSet;\nimport java.util.Set;\n\n/**\n * Creates temporary files and directories whose permissions are restricted to the current user or,\n * in the case of Android, the current app. If that is not possible (as is the case under the very\n * old Android Ice Cream Sandwich release), then this class throws an exception instead of creating\n * a file or directory that would be more accessible.\n */\n@J2ktIncompatible\n@GwtIncompatible\n@J2ObjCIncompatible\nabstract class TempFileCreator {\n  static final TempFileCreator INSTANCE = pickSecureCreator();\n\n  /**\n   * @throws IllegalStateException if the directory could not be created (to implement the contract\n   *     of {@link Files#createTempDir()}, such as if the system does not support creating temporary\n   *     directories securely\n   */\n  abstract File createTempDir();\n\n  abstract File createTempFile(String prefix) throws IOException;\n\n  private static TempFileCreator pickSecureCreator() {\n    try {\n      Class.forName(\"java.nio.file.Path\");\n      return new JavaNioCreator();\n    } catch (ClassNotFoundException runningUnderAndroid) {\n      // Try another way.\n    }\n\n    try {\n      int version = (int) Class.forName(\"android.os.Build$VERSION\").getField(\"SDK_INT\").get(null);\n      int jellyBean =\n          (int) Class.forName(\"android.os.Build$VERSION_CODES\").getField(\"JELLY_BEAN\").get(null);\n      /*\n       * I assume that this check can't fail because JELLY_BEAN will be present only if we're\n       * running under Jelly Bean or higher. But it seems safest to check.\n       */\n      if (version < jellyBean) {\n        return new ThrowingCreator();\n      }\n\n      // Don't merge these catch() blocks, let alone use ReflectiveOperationException directly:\n      // b/65343391\n    } catch (NoSuchFieldException e) {\n      // The JELLY_BEAN field doesn't exist because we're running on a version before Jelly Bean :)\n      return new ThrowingCreator();\n    } catch (ClassNotFoundException e) {\n      // Should be impossible, but we want to return *something* so that class init succeeds.\n      return new ThrowingCreator();\n    } catch (IllegalAccessException e) {\n      // ditto\n      return new ThrowingCreator();\n    }\n\n    // Android isolates apps' temporary directories since Jelly Bean:\n    // https://github.com/google/guava/issues/4011#issuecomment-770020802\n    // So we can create files there with any permissions and still get security from the isolation.\n    return new JavaIoCreator();\n  }\n\n  /**\n   * Creates the permissions normally used for Windows filesystems, looking up the user afresh, even\n   * if previous calls have initialized the {@code PermissionSupplier} fields.\n   *\n   * <p>This lets us test the effects of different values of the {@code user.name} system property\n   * without needing a separate VM or classloader.\n   */\n  @IgnoreJRERequirement // used only when Path is available (and only from tests)\n  @VisibleForTesting\n  static void testMakingUserPermissionsFromScratch() throws IOException {\n    // All we're testing is whether it throws.\n    FileAttribute<?> unused = JavaNioCreator.userPermissions().get();\n  }\n\n  @IgnoreJRERequirement // used only when Path is available\n  private static final class JavaNioCreator extends TempFileCreator {\n    @Override\n    File createTempDir() {\n      try {\n        return java.nio.file.Files.createTempDirectory(\n                Paths.get(JAVA_IO_TMPDIR.value()), /* prefix= */ null, directoryPermissions.get())\n            .toFile();\n      } catch (IOException e) {\n        throw new IllegalStateException(\"Failed to create directory\", e);\n      }\n    }\n\n    @Override\n    File createTempFile(String prefix) throws IOException {\n      return java.nio.file.Files.createTempFile(\n              Paths.get(JAVA_IO_TMPDIR.value()),\n              /* prefix= */ prefix,\n              /* suffix= */ null,\n              filePermissions.get())\n          .toFile();\n    }\n\n    @IgnoreJRERequirement // see enclosing class (whose annotation Animal Sniffer ignores here...)\n    private interface PermissionSupplier {\n      FileAttribute<?> get() throws IOException;\n    }\n\n    private static final PermissionSupplier filePermissions;\n    private static final PermissionSupplier directoryPermissions;\n\n    static {\n      Set<String> views = FileSystems.getDefault().supportedFileAttributeViews();\n      if (views.contains(\"posix\")) {\n        filePermissions = () -> asFileAttribute(PosixFilePermissions.fromString(\"rw-------\"));\n        directoryPermissions = () -> asFileAttribute(PosixFilePermissions.fromString(\"rwx------\"));\n      } else if (views.contains(\"acl\")) {\n        filePermissions = directoryPermissions = userPermissions();\n      } else {\n        filePermissions =\n            directoryPermissions =\n                () -> {\n                  throw new IOException(\"unrecognized FileSystem type \" + FileSystems.getDefault());\n                };\n      }\n    }\n\n    private static PermissionSupplier userPermissions() {\n      try {\n        UserPrincipal user =\n            FileSystems.getDefault()\n                .getUserPrincipalLookupService()\n                .lookupPrincipalByName(getUsername());\n        ImmutableList<AclEntry> acl =\n            ImmutableList.of(\n                AclEntry.newBuilder()\n                    .setType(ALLOW)\n                    .setPrincipal(user)\n                    .setPermissions(EnumSet.allOf(AclEntryPermission.class))\n                    .setFlags(DIRECTORY_INHERIT, FILE_INHERIT)\n                    .build());\n        FileAttribute<ImmutableList<AclEntry>> attribute =\n            new FileAttribute<ImmutableList<AclEntry>>() {\n              @Override\n              public String name() {\n                return \"acl:acl\";\n              }\n\n              @Override\n              public ImmutableList<AclEntry> value() {\n                return acl;\n              }\n            };\n        return () -> attribute;\n      } catch (IOException e) {\n        // We throw a new exception each time so that the stack trace is right.\n        return () -> {\n          throw new IOException(\"Could not find user\", e);\n        };\n      }\n    }\n\n    private s",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The method `pickSecureCreator()` does not handle the case where `Class.forName(\\\"java.nio.file.Path\\\")` throws a `ClassNotFoundException` due to a missing dependency. This can lead to the creation of insecure temporary files.\",\n         \"suggested_fix\": \"Add a check for the missing dependency and throw a meaningful exception if it's not available.\"\n      },\n      {\n         \"explanation\": \"The `testMakingUserPermissionsFromScratch()` method is not thread-safe, as it uses a static variable to store the result of the `userPermissions()` method. This can lead to unexpected behavior if multiple threads call this method concurrently.\",\n         \"suggested_fix\": \"Make the `testMakingUserPermissionsFromScratch()` method thread-safe by using a synchronized block or a thread-safe data structure to store the result.\"\n      },\n      {\n         \"explanation\": \"The `userPermissions()` method throws an `IOException` if the user principal cannot be found, but it does not provide any additional information about the error. This can make it difficult to diagnose the issue.\",\n         \"suggested_fix\": \"Add a more informative error message to the `IOException` thrown by the `userPermissions()` method, including the user principal that could not be found.\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs found in the provided code snippet.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The method `pickSecureCreator()` does not handle the case where `Class.forName(\"java.nio.file.Path\")` throws a `ClassNotFoundException` due to a missing dependency. This can lead to the creation of insecure temporary files.",
        "suggested_fix": "Add a check for the missing dependency and throw a meaningful exception if it's not available."
      },
      {
        "explanation": "The `testMakingUserPermissionsFromScratch()` method is not thread-safe, as it uses a static variable to store the result of the `userPermissions()` method. This can lead to unexpected behavior if multiple threads call this method concurrently.",
        "suggested_fix": "Make the `testMakingUserPermissionsFromScratch()` method thread-safe by using a synchronized block or a thread-safe data structure to store the result."
      },
      {
        "explanation": "The `userPermissions()` method throws an `IOException` if the user principal cannot be found, but it does not provide any additional information about the error. This can make it difficult to diagnose the issue.",
        "suggested_fix": "Add a more informative error message to the `IOException` thrown by the `userPermissions()` method, including the user principal that could not be found."
      }
    ],
    "no_bugs_reasoning": "No bugs found in the provided code snippet."
  },
  "error": null
}