{
  "source_item_id": 8001,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:51:34.936774",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.math;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.math.MathPreconditions.checkNoOverflow;\nimport static com.google.common.math.MathPreconditions.checkNonNegative;\nimport static com.google.common.math.MathPreconditions.checkPositive;\nimport static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;\nimport static java.lang.Math.abs;\nimport static java.lang.Math.min;\nimport static java.math.RoundingMode.HALF_EVEN;\nimport static java.math.RoundingMode.HALF_UP;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.primitives.Ints;\nimport com.google.errorprone.annotations.InlineMe;\nimport java.math.BigInteger;\nimport java.math.RoundingMode;\n\n/**\n * A class for arithmetic on values of type {@code int}. Where possible, methods are defined and\n * named analogously to their {@code BigInteger} counterparts.\n *\n * <p>The implementations of many methods in this class are based on material from Henry S. Warren,\n * Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).\n *\n * <p>Similar functionality for {@code long} and for {@link BigInteger} can be found in {@link\n * LongMath} and {@link BigIntegerMath} respectively. For other common operations on {@code int}\n * values, see {@link com.google.common.primitives.Ints}.\n *\n * @author Louis Wasserman\n * @since 11.0\n */\n@GwtCompatible\npublic final class IntMath {\n  @VisibleForTesting static final int MAX_SIGNED_POWER_OF_TWO = 1 << (Integer.SIZE - 2);\n\n  /**\n   * Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to\n   * {@code checkedPow(2, log2(x, CEILING))}.\n   *\n   * @throws IllegalArgumentException if {@code x <= 0}\n   * @throws ArithmeticException of the next-higher power of two is not representable as an {@code\n   *     int}, i.e. when {@code x > 2^30}\n   * @since 20.0\n   */\n  public static int ceilingPowerOfTwo(int x) {\n    checkPositive(\"x\", x);\n    if (x > MAX_SIGNED_POWER_OF_TWO) {\n      throw new ArithmeticException(\"ceilingPowerOfTwo(\" + x + \") not representable as an int\");\n    }\n    return 1 << -Integer.numberOfLeadingZeros(x - 1);\n  }\n\n  /**\n   * Returns the largest power of two less than or equal to {@code x}. This is equivalent to {@code\n   * checkedPow(2, log2(x, FLOOR))}.\n   *\n   * @throws IllegalArgumentException if {@code x <= 0}\n   * @since 20.0\n   */\n  public static int floorPowerOfTwo(int x) {\n    checkPositive(\"x\", x);\n    return Integer.highestOneBit(x);\n  }\n\n  /**\n   * Returns {@code true} if {@code x} represents a power of two.\n   *\n   * <p>This differs from {@code Integer.bitCount(x) == 1}, because {@code\n   * Integer.bitCount(Integer.MIN_VALUE) == 1}, but {@link Integer#MIN_VALUE} is not a power of two.\n   */\n  // Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||\n  @SuppressWarnings(\"ShortCircuitBoolean\")\n  public static boolean isPowerOfTwo(int x) {\n    return x > 0 & (x & (x - 1)) == 0;\n  }\n\n  /**\n   * Returns 1 if {@code x < y} as unsigned integers, and 0 otherwise. Assumes that x - y fits into\n   * a signed int. The implementation is branch-free, and benchmarks suggest it is measurably (if\n   * narrowly) faster than the straightforward ternary expression.\n   */\n  @VisibleForTesting\n  static int lessThanBranchFree(int x, int y) {\n    // The double negation is optimized away by normal Java, but is necessary for GWT\n    // to make sure bit twiddling works as expected.\n    return ~~(x - y) >>> (Integer.SIZE - 1);\n  }\n\n  /**\n   * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.\n   *\n   * @throws IllegalArgumentException if {@code x <= 0}\n   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n   *     is not a power of two\n   */\n  @SuppressWarnings(\"fallthrough\")\n  // TODO(kevinb): remove after this warning is disabled globally\n  public static int log2(int x, RoundingMode mode) {\n    checkPositive(\"x\", x);\n    switch (mode) {\n      case UNNECESSARY:\n        checkRoundingUnnecessary(isPowerOfTwo(x));\n      // fall through\n      case DOWN:\n      case FLOOR:\n        return (Integer.SIZE - 1) - Integer.numberOfLeadingZeros(x);\n\n      case UP:\n      case CEILING:\n        return Integer.SIZE - Integer.numberOfLeadingZeros(x - 1);\n\n      case HALF_DOWN:\n      case HALF_UP:\n      case HALF_EVEN:\n        // Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5\n        int leadingZeros = Integer.numberOfLeadingZeros(x);\n        int cmp = MAX_POWER_OF_SQRT2_UNSIGNED >>> leadingZeros;\n        // floor(2^(logFloor + 0.5))\n        int logFloor = (Integer.SIZE - 1) - leadingZeros;\n        return logFloor + lessThanBranchFree(cmp, x);\n    }\n    throw new AssertionError();\n  }\n\n  /** The biggest half power of two that can fit in an unsigned int. */\n  @VisibleForTesting static final int MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333;\n\n  /**\n   * Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.\n   *\n   * @throws IllegalArgumentException if {@code x <= 0}\n   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n   *     is not a power of ten\n   */\n  @GwtIncompatible // need BigIntegerMath to adequately test\n  @SuppressWarnings(\"fallthrough\")\n  public static int log10(int x, RoundingMode mode) {\n    checkPositive(\"x\", x);\n    int logFloor = log10Floor(x);\n    int floorPow = powersOf10[logFloor];\n    switch (mode) {\n      case UNNECESSARY:\n        checkRoundingUnnecessary(x == floorPow);\n      // fall through\n      case FLOOR:\n      case DOWN:\n        return logFloor;\n      case CEILING:\n      case UP:\n        return logFloor + lessThanBranchFree(floorPow, x);\n      case HALF_DOWN:\n      case HALF_UP:\n      case HALF_EVEN:\n        // sqrt(10) is irrational, so log10(x) - logFloor is never exactly 0.5\n        return logFloor + lessThanBranchFree(halfPowersOf10[logFloor], x);\n    }\n    throw new AssertionError();\n  }\n\n  private static int log10Floor(int x) {\n    /*\n     * Based on Hacker's Delight Fig. 11-5, the two-table-lookup, branch-free implementation.\n     *\n     * The key idea is that based on the number of leading zeros (equivalently, floor(log2(x))), we\n     * can narrow the possible floor(log10(x)) values to two. For example, if floor(log2(x)) is 6,\n     * then 64 <= x < 128, so floor(log10(x)) is either 1 or 2.\n     */\n    int y = maxLog10ForLeadingZeros[Integer.numberOfLeadingZeros(x)];\n    /*\n     * y is the higher of the two possible values of floor(log10(x)). If x < 10^y, then we want the\n     * lower of the two possible values, or y - 1, otherwise, we want y.\n     */\n    return y - lessThanBranchFree(x, powersOf10[y]);\n  }\n\n  // maxLog10ForLeadingZeros[i] == floor(log10(2^(Long.SIZE - i)))\n  @VisibleForTesting\n  static final byte[] maxLog10ForLeadingZeros = {\n    9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1, 0, 0, 0,\n    0\n  };\n\n  @VisibleForTesting\n  static final int[] powersOf10 = {\n    1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000\n  };\n\n  // halfPowersOf10[i] = largest int less than 10^(i + 0.5)\n  ",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The method log2(int x, RoundingMode mode) does not handle the case when x is 0 or negative correctly. It throws an IllegalArgumentException when x <= 0, but it does not handle the case when x is negative correctly.\",\n         \"suggested_fix\": \"checkArgument(\\\"x\\\", x >= 0);\"\n      },\n      {\n         \"explanation\": \"The method log10(int x, RoundingMode mode) does not handle the case when x is 0 or negative correctly. It throws an IllegalArgumentException when x <= 0, but it does not handle the case when x is negative correctly.\",\n         \"suggested_fix\": \"checkArgument(\\\"x\\\", x >= 0);\"\n      },\n      {\n         \"explanation\": \"The method ceilingPowerOfTwo(int x) does not handle the case when x is greater than the maximum signed power of two correctly. It throws an ArithmeticException when x > MAX_SIGNED_POWER_OF_TWO, but it does not handle the case when x is greater than the maximum signed power of two correctly.\",\n         \"suggested_fix\": \"if (x > MAX_SIGNED_POWER_OF_TWO) { throw new ArithmeticException(\\\"ceilingPowerOfTwo(\\\" + x + \\\") not representable as an int\\\"); }\"\n      },\n      {\n         \"explanation\": \"The method lessThanBranchFree(int x, int y) does not handle the case when x and y are both negative correctly. It returns 1 if x < y as unsigned integers, but it does not handle the case when x and y are both negative correctly.\",\n         \"suggested_fix\": \"if (x < 0 && y < 0) { return x > y ? 1 : 0; }\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs found in the provided code snippet.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The method log2(int x, RoundingMode mode) does not handle the case when x is 0 or negative correctly. It throws an IllegalArgumentException when x <= 0, but it does not handle the case when x is negative correctly.",
        "suggested_fix": "checkArgument(\"x\", x >= 0);"
      },
      {
        "explanation": "The method log10(int x, RoundingMode mode) does not handle the case when x is 0 or negative correctly. It throws an IllegalArgumentException when x <= 0, but it does not handle the case when x is negative correctly.",
        "suggested_fix": "checkArgument(\"x\", x >= 0);"
      },
      {
        "explanation": "The method ceilingPowerOfTwo(int x) does not handle the case when x is greater than the maximum signed power of two correctly. It throws an ArithmeticException when x > MAX_SIGNED_POWER_OF_TWO, but it does not handle the case when x is greater than the maximum signed power of two correctly.",
        "suggested_fix": "if (x > MAX_SIGNED_POWER_OF_TWO) { throw new ArithmeticException(\"ceilingPowerOfTwo(\" + x + \") not representable as an int\"); }"
      },
      {
        "explanation": "The method lessThanBranchFree(int x, int y) does not handle the case when x and y are both negative correctly. It returns 1 if x < y as unsigned integers, but it does not handle the case when x and y are both negative correctly.",
        "suggested_fix": "if (x < 0 && y < 0) { return x > y ? 1 : 0; }"
      }
    ],
    "no_bugs_reasoning": "No bugs found in the provided code snippet."
  },
  "error": null
}