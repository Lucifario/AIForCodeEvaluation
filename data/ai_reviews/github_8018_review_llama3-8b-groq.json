{
  "source_item_id": 8018,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:47:48.192477",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.hash;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static java.lang.Byte.toUnsignedInt;\nimport static java.lang.Math.max;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Predicate;\nimport com.google.common.hash.BloomFilterStrategies.LockFreeBitArray;\nimport com.google.common.math.DoubleMath;\nimport com.google.common.primitives.SignedBytes;\nimport com.google.common.primitives.UnsignedBytes;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.InlineMe;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.math.RoundingMode;\nimport java.util.Objects;\nimport java.util.stream.Collector;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * A Bloom filter for instances of {@code T}. A Bloom filter offers an approximate containment test\n * with one-sided error: if it claims that an element is contained in it, this might be in error,\n * but if it claims that an element is <i>not</i> contained in it, then this is definitely true.\n *\n * <p>If you are unfamiliar with Bloom filters, this nice <a\n * href=\"http://llimllib.github.io/bloomfilter-tutorial/\">tutorial</a> may help you understand how\n * they work.\n *\n * <p>The false positive probability ({@code FPP}) of a Bloom filter is defined as the probability\n * that {@linkplain #mightContain(Object)} will erroneously return {@code true} for an object that\n * has not actually been put in the {@code BloomFilter}.\n *\n * <p>Bloom filters are serializable. They also support a more compact serial representation via the\n * {@link #writeTo} and {@link #readFrom} methods. Both serialized forms will continue to be\n * supported by future versions of this library. However, serial forms generated by newer versions\n * of the code may not be readable by older versions of the code (e.g., a serialized Bloom filter\n * generated today may <i>not</i> be readable by a binary that was compiled 6 months ago).\n *\n * <p>As of Guava 23.0, this class is thread-safe and lock-free. It internally uses atomics and\n * compare-and-swap to ensure correctness when multiple threads are used to access it.\n *\n * @param <T> the type of instances that the {@code BloomFilter} accepts\n * @author Dimitris Andreou\n * @author Kevin Bourrillion\n * @since 11.0 (thread-safe since 23.0)\n */\n@Beta\npublic final class BloomFilter<T extends @Nullable Object> implements Predicate<T>, Serializable {\n  /**\n   * A strategy to translate T instances, to {@code numHashFunctions} bit indexes.\n   *\n   * <p>Implementations should be collections of pure functions (i.e. stateless).\n   */\n  interface Strategy extends java.io.Serializable {\n\n    /**\n     * Sets {@code numHashFunctions} bits of the given bit array, by hashing a user element.\n     *\n     * <p>Returns whether any bits changed as a result of this operation.\n     */\n    <T extends @Nullable Object> boolean put(\n        @ParametricNullness T object,\n        Funnel<? super T> funnel,\n        int numHashFunctions,\n        LockFreeBitArray bits);\n\n    /**\n     * Queries {@code numHashFunctions} bits of the given bit array, by hashing a user element;\n     * returns {@code true} if and only if all selected bits are set.\n     */\n    <T extends @Nullable Object> boolean mightContain(\n        @ParametricNullness T object,\n        Funnel<? super T> funnel,\n        int numHashFunctions,\n        LockFreeBitArray bits);\n\n    /**\n     * Identifier used to encode this strategy, when marshalled as part of a BloomFilter. Only\n     * values in the [-128, 127] range are valid for the compact serial form. Non-negative values\n     * are reserved for enums defined in BloomFilterStrategies; negative values are reserved for any\n     * custom, stateful strategy we may define (e.g. any kind of strategy that would depend on user\n     * input).\n     */\n    int ordinal();\n  }\n\n  /** The bit set of the BloomFilter (not necessarily power of 2!) */\n  private final LockFreeBitArray bits;\n\n  /** Number of hashes per element */\n  private final int numHashFunctions;\n\n  /** The funnel to translate Ts to bytes */\n  private final Funnel<? super T> funnel;\n\n  /** The strategy we employ to map an element T to {@code numHashFunctions} bit indexes. */\n  private final Strategy strategy;\n\n  /** Natural logarithm of 2, used to optimize calculations in Bloom filter sizing. */\n  private static final double LOG_TWO = Math.log(2);\n\n  /** Square of the natural logarithm of 2, reused to optimize the bit size calculation. */\n  private static final double SQUARED_LOG_TWO = LOG_TWO * LOG_TWO;\n\n  /** Creates a BloomFilter. */\n  private BloomFilter(\n      LockFreeBitArray bits, int numHashFunctions, Funnel<? super T> funnel, Strategy strategy) {\n    checkArgument(numHashFunctions > 0, \"numHashFunctions (%s) must be > 0\", numHashFunctions);\n    checkArgument(\n        numHashFunctions <= 255, \"numHashFunctions (%s) must be <= 255\", numHashFunctions);\n    this.bits = checkNotNull(bits);\n    this.numHashFunctions = numHashFunctions;\n    this.funnel = checkNotNull(funnel);\n    this.strategy = checkNotNull(strategy);\n  }\n\n  /**\n   * Creates a new {@code BloomFilter} that's a copy of this instance. The new instance is equal to\n   * this instance but shares no mutable state.\n   *\n   * @since 12.0\n   */\n  public BloomFilter<T> copy() {\n    return new BloomFilter<>(bits.copy(), numHashFunctions, funnel, strategy);\n  }\n\n  /**\n   * Returns {@code true} if the element <i>might</i> have been put in this Bloom filter, {@code\n   * false} if this is <i>definitely</i> not the case.\n   */\n  public boolean mightContain(@ParametricNullness T object) {\n    return strategy.mightContain(object, funnel, numHashFunctions, bits);\n  }\n\n  /**\n   * @deprecated Provided only to satisfy the {@link Predicate} interface; use {@link #mightContain}\n   *     instead.\n   */\n  @InlineMe(replacement = \"this.mightContain(input)\")\n  @Deprecated\n  @Override\n  public boolean apply(@ParametricNullness T input) {\n    return mightContain(input);\n  }\n\n  /**\n   * Puts an element into this {@code BloomFilter}. Ensures that subsequent invocations of {@link\n   * #mightContain(Object)} with the same element will always return {@code true}.\n   *\n   * @return true if the Bloom filter's bits changed as a result of this operation. If the bits\n   *     changed, this is <i>definitely</i> the first time {@code object} has been added to the\n   *     filter. If the bits haven't changed, this <i>might</i> be the first time {@code object} has\n   *     been added to the filter. Note that {@code put(t)} always returns the <i>opposite</i>\n   *     result to what {@code mightContain(t)} would have returned at the time it is called.\n   * @since 12.0 (present in 11.0 with {@code void} return type})\n   */\n  @CanIgnoreReturnValue\n  public boolean put(@ParametricNullness T object) {\n    return strategy.put(object, funnel, numHashFunctions, bits);\n  }\n\n  /**\n   * Returns the probability that {@linkplain #mightContain(Object)} will erroneously return {@code\n   * true} for an object that has not actually been p",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The method mightContain() does not handle null inputs correctly. It calls the mightContain() method of the strategy object, which may also not handle null inputs correctly. This could lead to a NullPointerException.\",\n         \"suggested_fix\": \"Add a null check before calling the mightContain() method of the strategy object.\"\n      },\n      {\n         \"explanation\": \"The method put() does not handle null inputs correctly. It calls the put() method of the strategy object, which may also not handle null inputs correctly. This could lead to a NullPointerException.\",\n         \"suggested_fix\": \"Add a null check before calling the put() method of the strategy object.\"\n      },\n      {\n         \"explanation\": \"The BloomFilter class does not handle the case where the strategy object is null. This could lead to a NullPointerException when the put() or mightContain() method is called.\",\n         \"suggested_fix\": \"Add a null check for the strategy object in the constructor and throw an exception if it is null.\"\n      },\n      {\n         \"explanation\": \"The BloomFilter class does not handle the case where the funnel object is null. This could lead to a NullPointerException when the put() or mightContain() method is called.\",\n         \"suggested_fix\": \"Add a null check for the funnel object in the constructor and throw an exception if it is null.\"\n      },\n      {\n         \"explanation\": \"The BloomFilter class does not handle the case where the bits object is null. This could lead to a NullPointerException when the put() or mightContain() method is called.\",\n         \"suggested_fix\": \"Add a null check for the bits object in the constructor and throw an exception if it is null.\"\n      },\n      {\n         \"explanation\": \"The BloomFilter class does not handle the case where the numHashFunctions is less than or equal to 0. This could lead to an IllegalArgumentException when the constructor is called.\",\n         \"suggested_fix\": \"Add a check to ensure that numHashFunctions is greater than 0 in the constructor.\"\n      },\n      {\n         \"explanation\": \"The BloomFilter class does not handle the case where the numHashFunctions is greater than 255. This could lead to an IllegalArgumentException when the constructor is called.\",\n         \"suggested_fix\": \"Add a check to ensure that numHashFunctions is less than or equal to 255 in the constructor.\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The method mightContain() does not handle null inputs correctly. It calls the mightContain() method of the strategy object, which may also not handle null inputs correctly. This could lead to a NullPointerException.",
        "suggested_fix": "Add a null check before calling the mightContain() method of the strategy object."
      },
      {
        "explanation": "The method put() does not handle null inputs correctly. It calls the put() method of the strategy object, which may also not handle null inputs correctly. This could lead to a NullPointerException.",
        "suggested_fix": "Add a null check before calling the put() method of the strategy object."
      },
      {
        "explanation": "The BloomFilter class does not handle the case where the strategy object is null. This could lead to a NullPointerException when the put() or mightContain() method is called.",
        "suggested_fix": "Add a null check for the strategy object in the constructor and throw an exception if it is null."
      },
      {
        "explanation": "The BloomFilter class does not handle the case where the funnel object is null. This could lead to a NullPointerException when the put() or mightContain() method is called.",
        "suggested_fix": "Add a null check for the funnel object in the constructor and throw an exception if it is null."
      },
      {
        "explanation": "The BloomFilter class does not handle the case where the bits object is null. This could lead to a NullPointerException when the put() or mightContain() method is called.",
        "suggested_fix": "Add a null check for the bits object in the constructor and throw an exception if it is null."
      },
      {
        "explanation": "The BloomFilter class does not handle the case where the numHashFunctions is less than or equal to 0. This could lead to an IllegalArgumentException when the constructor is called.",
        "suggested_fix": "Add a check to ensure that numHashFunctions is greater than 0 in the constructor."
      },
      {
        "explanation": "The BloomFilter class does not handle the case where the numHashFunctions is greater than 255. This could lead to an IllegalArgumentException when the constructor is called.",
        "suggested_fix": "Add a check to ensure that numHashFunctions is less than or equal to 255 in the constructor."
      }
    ],
    "no_bugs_reasoning": ""
  },
  "error": null
}