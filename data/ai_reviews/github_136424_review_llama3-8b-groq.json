{
  "source_item_id": 136424,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:38:34.719964",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.cluster.routing.allocation.decider;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.elasticsearch.cluster.routing.RecoverySource;\nimport org.elasticsearch.cluster.routing.RoutingNode;\nimport org.elasticsearch.cluster.routing.ShardRouting;\nimport org.elasticsearch.cluster.routing.UnassignedInfo;\nimport org.elasticsearch.cluster.routing.allocation.RoutingAllocation;\nimport org.elasticsearch.common.settings.ClusterSettings;\nimport org.elasticsearch.common.settings.Setting;\nimport org.elasticsearch.common.settings.Setting.Property;\n\nimport static org.elasticsearch.cluster.routing.allocation.decider.Decision.THROTTLE;\nimport static org.elasticsearch.cluster.routing.allocation.decider.Decision.YES;\n\n/**\n * {@link ThrottlingAllocationDecider} controls the recovery process per node in\n * the cluster. It exposes two settings via the cluster update API that allow\n * changes in real-time:\n * <ul>\n * <li>{@code cluster.routing.allocation.node_initial_primaries_recoveries} -\n * restricts the number of initial primary shard recovery operations on a single\n * node. The default is {@code 4}</li>\n * <li>{@code cluster.routing.allocation.node_concurrent_recoveries} -\n * restricts the number of total concurrent shards initializing on a single node. The\n * default is {@code 2}</li>\n * </ul>\n * <p>\n * If one of the above thresholds is exceeded per node this allocation decider\n * will return {@link Decision#THROTTLE} as a hit to upstream logic to throttle\n * the allocation process to prevent overloading nodes due to too many concurrent recovery\n * processes.\n */\npublic class ThrottlingAllocationDecider extends AllocationDecider {\n\n    private static final Logger logger = LogManager.getLogger(ThrottlingAllocationDecider.class);\n\n    public static final int DEFAULT_CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES = 2;\n    public static final int DEFAULT_CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES = 4;\n    public static final String NAME = \"throttling\";\n    public static final Setting<Integer> CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING = new Setting<>(\n        \"cluster.routing.allocation.node_concurrent_recoveries\",\n        Integer.toString(DEFAULT_CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES),\n        (s) -> Setting.parseInt(s, 0, \"cluster.routing.allocation.node_concurrent_recoveries\"),\n        Property.Dynamic,\n        Property.NodeScope\n    );\n    public static final Setting<Integer> CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES_SETTING = Setting.intSetting(\n        \"cluster.routing.allocation.node_initial_primaries_recoveries\",\n        DEFAULT_CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES,\n        0,\n        Property.Dynamic,\n        Property.NodeScope\n    );\n    public static final Setting<Integer> CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_INCOMING_RECOVERIES_SETTING = new Setting<>(\n        \"cluster.routing.allocation.node_concurrent_incoming_recoveries\",\n        CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING,\n        (s) -> Setting.parseInt(s, 0, \"cluster.routing.allocation.node_concurrent_incoming_recoveries\"),\n        Property.Dynamic,\n        Property.NodeScope\n    );\n    public static final Setting<Integer> CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING = new Setting<>(\n        \"cluster.routing.allocation.node_concurrent_outgoing_recoveries\",\n        CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING,\n        (s) -> Setting.parseInt(s, 0, \"cluster.routing.allocation.node_concurrent_outgoing_recoveries\"),\n        Property.Dynamic,\n        Property.NodeScope\n    );\n\n    private volatile int primariesInitialRecoveries;\n    private volatile int concurrentIncomingRecoveries;\n    private volatile int concurrentOutgoingRecoveries;\n\n    public ThrottlingAllocationDecider(ClusterSettings clusterSettings) {\n        clusterSettings.initializeAndWatch(\n            CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES_SETTING,\n            this::setPrimariesInitialRecoveries\n        );\n        clusterSettings.initializeAndWatch(\n            CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_INCOMING_RECOVERIES_SETTING,\n            this::setConcurrentIncomingRecoverries\n        );\n        clusterSettings.initializeAndWatch(\n            CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING,\n            this::setConcurrentOutgoingRecoverries\n        );\n        logger.debug(\n            \"using node_concurrent_outgoing_recoveries [{}], node_concurrent_incoming_recoveries [{}], \"\n                + \"node_initial_primaries_recoveries [{}]\",\n            concurrentOutgoingRecoveries,\n            concurrentIncomingRecoveries,\n            primariesInitialRecoveries\n        );\n    }\n\n    private void setConcurrentIncomingRecoverries(int concurrentIncomingRecoveries) {\n        this.concurrentIncomingRecoveries = concurrentIncomingRecoveries;\n    }\n\n    private void setConcurrentOutgoingRecoverries(int concurrentOutgoingRecoveries) {\n        this.concurrentOutgoingRecoveries = concurrentOutgoingRecoveries;\n    }\n\n    private void setPrimariesInitialRecoveries(int primariesInitialRecoveries) {\n        this.primariesInitialRecoveries = primariesInitialRecoveries;\n    }\n\n    @Override\n    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {\n        if (shardRouting.primary() && shardRouting.unassigned()) {\n            assert initializingShard(shardRouting, node.nodeId()).recoverySource().getType() != RecoverySource.Type.PEER;\n            // primary is unassigned, means we are going to do recovery from store, snapshot or local shards\n            // count *just the primaries* currently doing recovery on the node and check against primariesInitialRecoveries\n\n            int primariesInRecovery = 0;\n            for (ShardRouting shard : node.initializing()) {\n                // when a primary shard is INITIALIZING, it can be because of *initial recovery* or *relocation from another node*\n                // we only count initial recoveries here, so we need to make sure that relocating node is null\n                if (shard.primary() && shard.relocatingNodeId() == null) {\n                    primariesInRecovery++;\n                }\n            }\n            if (allocation.isSimulating()) {\n                return allocation.decision(Decision.YES, NAME, \"primary allocation is not throttled when simulating\");\n            } else if (primariesInRecovery >= primariesInitialRecoveries) {\n                // TODO: Should index creation not be throttled for primary shards?\n                return allocation.decision(\n                    THROTTLE,\n                    NAME,\n                    \"reached the limit of ongoing initial primary recoveries [%d], cluster setting [%s=%d]\",\n                    primariesInRecovery,\n                    CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES_SETTING.getKey(),\n                    primariesInitialRecoveries\n                );\n            } else {\n                return allocation.decision(YES, NAME, \"below primary recovery limit of [%d]\", primariesInitialRecoveries);\n            }\n        } else {\n            // Peer recovery\n            assert initializingShard(shardRouting, node.nodeId()).recoverySource().getType() == RecoverySource.Type.PEER;\n\n            // Allocating a shard to this node will increase the incoming recover",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The method setConcurrentIncomingRecoverries and setConcurrentOutgoingRecoverries have a typo in their names. They should be setConcurrentIncomingRecoveries and setConcurrentOutgoingRecoveries respectively.\",\n         \"suggested_fix\": \"Change the method names to match the correct spelling.\"\n      },\n      {\n         \"explanation\": \"The method setPrimariesInitialRecoveries does not check if the new value is within the valid range (0, primariesInitialRecoveries). This could lead to a potential bug if the new value is set to a value outside this range.\",\n         \"suggested_fix\": \"Add a check to ensure the new value is within the valid range before setting it.\"\n      },\n      {\n         \"explanation\": \"The method canAllocate does not handle the case where the shard is relocating. This could lead to incorrect behavior if the shard is relocating.\",\n         \"suggested_fix\": \"Add a check to handle the case where the shard is relocating.\"\n      },\n      {\n         \"explanation\": \"The method canAllocate does not handle the case where the node is not initializing any shards. This could lead to a potential bug if the node is not initializing any shards.\",\n         \"suggested_fix\": \"Add a check to handle the case where the node is not initializing any shards.\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The method setConcurrentIncomingRecoverries and setConcurrentOutgoingRecoverries have a typo in their names. They should be setConcurrentIncomingRecoveries and setConcurrentOutgoingRecoveries respectively.",
        "suggested_fix": "Change the method names to match the correct spelling."
      },
      {
        "explanation": "The method setPrimariesInitialRecoveries does not check if the new value is within the valid range (0, primariesInitialRecoveries). This could lead to a potential bug if the new value is set to a value outside this range.",
        "suggested_fix": "Add a check to ensure the new value is within the valid range before setting it."
      },
      {
        "explanation": "The method canAllocate does not handle the case where the shard is relocating. This could lead to incorrect behavior if the shard is relocating.",
        "suggested_fix": "Add a check to handle the case where the shard is relocating."
      },
      {
        "explanation": "The method canAllocate does not handle the case where the node is not initializing any shards. This could lead to a potential bug if the node is not initializing any shards.",
        "suggested_fix": "Add a check to handle the case where the node is not initializing any shards."
      }
    ],
    "no_bugs_reasoning": ""
  },
  "error": null
}