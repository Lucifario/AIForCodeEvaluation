{"sample_id": "Time_27", "model": "qwen-coder-32b", "code_context": "/*\n *  Copyright 2001-2009 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.TreeSet;\n\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.PeriodType;\nimport org.joda.time.ReadWritablePeriod;\nimport org.joda.time.ReadablePeriod;\n\n/**\n * Factory that creates complex instances of PeriodFormatter via method calls.\n * <p>\n * Period formatting is performed by the {@link PeriodFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link PeriodFormat} and {@link ISOPeriodFormat}.\n * <p>\n * PeriodFormatterBuilder is used for constructing formatters which are then\n * used to print or parse. The formatters are built by appending specific fields\n * or other formatters to an instance of this builder.\n * <p>\n * For example, a formatter that prints years and months, like \"15 years and 8 months\",\n * can be constructed as follows:\n * <p>\n * <pre>\n * PeriodFormatter yearsAndMonths = new PeriodFormatterBuilder()\n *     .printZeroAlways()\n *     .appendYears()\n *     .appendSuffix(\" year\", \" years\")\n *     .appendSeparator(\" and \")\n *     .printZeroRarely()\n *     .appendMonths()\n *     .appendSuffix(\" month\", \" months\")\n *     .toFormatter();\n * </pre>\n * <p>\n * PeriodFormatterBuilder itself is mutable and not thread-safe, but the\n * formatters that it builds are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @since 1.0\n * @see PeriodFormat\n */\npublic class PeriodFormatterBuilder {\n    private static final int PRINT_ZERO_RARELY_FIRST = 1;\n    private static final int PRINT_ZERO_RARELY_LAST = 2;\n    private static final int PRINT_ZERO_IF_SUPPORTED = 3;\n    private static final int PRINT_ZERO_ALWAYS = 4;\n    private static final int PRINT_ZERO_NEVER = 5;\n    \n    private static final int YEARS = 0;\n    private static final int MONTHS = 1;\n    private static final int WEEKS = 2;\n    private static final int DAYS = 3;\n    private static final int HOURS = 4;\n    private static final int MINUTES = 5;\n    private static final int SECONDS = 6;\n    private static final int MILLIS = 7;\n    private static final int SECONDS_MILLIS = 8;\n    private static final int SECONDS_OPTIONAL_MILLIS = 9;\n    private static final int MAX_FIELD = SECONDS_OPTIONAL_MILLIS;\n\n    private int iMinPrintedDigits;\n    private int iPrintZeroSetting;\n    private int iMaxParsedDigits;\n    private boolean iRejectSignedValues;\n\n    private PeriodFieldAffix iPrefix;\n\n    // List of Printers and Parsers used to build a final formatter.\n    private List<Object> iElementPairs;\n    /** Set to true if the formatter is not a printer. */\n    private boolean iNotPrinter;\n    /** Set to true if the formatter is not a parser. */\n    private boolean iNotParser;\n\n    // Last PeriodFormatter appended of each field type.\n    private FieldFormatter[] iFieldFormatters;\n\n    public PeriodFormatterBuilder() {\n        clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a PeriodFormatter using all the appended elements.\n     * <p>\n     * This is the main method used by applications at the end of the build\n     * process to create a usable formatter.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned formatter.\n     * <p>\n     * The returned formatter may not support both printing and parsing.\n     * The methods {@link PeriodFormatter#isPrinter()} and\n     * {@link PeriodFormatter#isParser()} will help you determine the state\n     * of the formatter.\n     * \n     * @return the newly created formatter\n     * @throws IllegalStateException if the builder can produce neither a printer nor a parser\n     */\n    public PeriodFormatter toFormatter() {\n        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\n        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n        return formatter;\n    }\n\n    /**\n     * Internal method to create a PeriodPrinter instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned printer.\n     * \n     * @return the newly created printer, null if builder cannot create a printer\n     */\n    public PeriodPrinter toPrinter() {\n        if (iNotPrinter) {\n            return null;\n        }\n        return toFormatter().getPrinter();\n    }\n\n    /**\n     * Internal method to create a PeriodParser instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned parser.\n     * \n     * @return the newly created parser, null if builder cannot create a parser\n     */\n    public PeriodParser toParser() {\n        if (iNotParser) {\n            return null;\n        }\n        return toFormatter().getParser();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clears out all the appended elements, allowing this builder to be reused.\n     */\n    public void clear() {\n        iMinPrintedDigits = 1;\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        iMaxParsedDigits = 10;\n        iRejectSignedValues = false;\n        iPrefix = null;\n        if (iElementPairs == null) {\n            iElementPairs = new ArrayList<Object>();\n        } else {\n            iElementPairs.clear();\n        }\n        iNotPrinter = false;\n        iNotParser = false;\n        iFieldFormatters = new FieldFormatter[10];\n    }\n\n    /**\n     * Appends another formatter.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder append(PeriodFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        clearPrefix();\n        append0(formatter.getPrinter(), formatter.getParser());\n        return this;\n    }\n\n    /**\n     * Appends a printer parser pair.\n     * <p>\n     * Either the printer or the parser may be null, in which case the builder will\n     * be unable to produce a parser or printer repectively.\n     *\n     * @param printer  appends a printer to the builder, null if printing is not supported\n     * @param parser  appends a parser to the builder, null if parsing is not supported\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if both the printer and parser are null\n     */\n    public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {\n        if (printer == null && parser == null) {\n            throw new IllegalArgumentException(\"No printer or parser supplied\");\n        }\n        clearPrefix();\n        append0(printer, parser);\n        return this;\n    }\n\n    /**\n     * Instructs the printer to emit specific text, and the parser to expect it.\n     * The parser is case-insensitive.\n     *\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalArgumentException if text is null\n     */\n    public PeriodFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        clearPrefix();\n        Literal literal = new Literal(text);\n        append0(literal, literal);\n        return this;\n    }\n\n    /**\n     * Set the minimum digits printed for the next and following appended\n     * fields. By default, the minimum digits printed is one. If the field value\n     * is zero, it is not printed unless a printZero rule is applied.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {\n        iMinPrintedDigits = minDigits;\n        return this;\n    }\n\n    /**\n     * Set the maximum digits parsed for the next and following appended\n     * fields. By default, the maximum digits parsed is ten.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {\n        iMaxParsedDigits = maxDigits;\n        return this;\n    }\n\n    /**\n     * Reject signed values when parsing the next and following appended fields.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder rejectSignedValues(boolean v) {\n        iRejectSignedValues = v;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroRarelyLast() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the first \"printZeroRarely\" field to print a zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroRarelyFirst() {\n        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;\n        return this;\n    }\n\n    /**\n     * Print zero values for the next and following appened fields only if the\n     * period supports it.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroIfSupported() {\n        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;\n        return this;\n    }\n\n    /**\n     * Always print zero values for the next and following appended fields,\n     * even if the period doesn't support it. The parser requires values for\n     * fields that always print zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroAlways() {\n        iPrintZeroSetting = PRINT_ZERO_ALWAYS;\n        return this;\n    }\n\n    /**\n     * Never print zero values for the next and following appended fields,\n     * unless no fields would be printed. If no fields are printed, the printer\n     * forces the last \"printZeroRarely\" field to print a zero.\n     * <p>\n     * This field setting is the default.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder printZeroNever() {\n        iPrintZeroSetting = PRINT_ZERO_NEVER;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param text text to print before field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    public PeriodFormatterBuilder appendPrefix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new SimpleAffix(text));\n    }\n\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether\n     * or not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    public PeriodFormatterBuilder appendPrefix(String singularText,\n                                                 String pluralText) {\n        if (singularText == null || pluralText == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendPrefix(new PluralAffix(singularText, pluralText));\n    }\n\n    /**\n     * Append a field prefix which applies only to the next appended field. If\n     * the field is not printed, neither is the prefix.\n     *\n     * @param prefix custom prefix\n     * @return this PeriodFormatterBuilder\n     * @see #appendSuffix\n     */\n    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {\n        if (prefix == null) {\n            throw new IllegalArgumentException();\n        }\n        if (iPrefix != null) {\n            prefix = new CompositeAffix(iPrefix, prefix);\n        }\n        iPrefix = prefix;\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Instruct the printer to emit an integer years field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendYears() {\n        appendField(YEARS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer months field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMonths() {\n        appendField(MONTHS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer weeks field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendWeeks() {\n        appendField(WEEKS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer days field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendDays() {\n        appendField(DAYS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer hours field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendHours() {\n        appendField(HOURS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer minutes field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMinutes() {\n        appendField(MINUTES);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer seconds field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSeconds() {\n        appendField(SECONDS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are always output.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSecondsWithMillis() {\n        appendField(SECONDS_MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit a combined seconds and millis field, if supported.\n     * The millis will overflow into the seconds if necessary.\n     * The millis are only output if non-zero.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\n        appendField(SECONDS_OPTIONAL_MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of printed and parsed digits can be controlled using\n     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMillis() {\n        appendField(MILLIS);\n        return this;\n    }\n\n    /**\n     * Instruct the printer to emit an integer millis field, if supported.\n     * <p>\n     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.\n     *\n     * @return this PeriodFormatterBuilder\n     */\n    public PeriodFormatterBuilder appendMillis3Digit() {\n        appendField(7, 3);\n        return this;\n    }\n\n    private void appendField(int type) {\n        appendField(type, iMinPrintedDigits);\n    }\n\n    private void appendField(int type, int minPrinted) {\n        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);\n        append0(field, field);\n        iFieldFormatters[type] = field;\n        iPrefix = null;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param text text to print after field only if field is printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    public PeriodFormatterBuilder appendSuffix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new SimpleAffix(text));\n    }\n\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     * <p>\n     * During parsing, the singular and plural versions are accepted whether or\n     * not the actual value matches plurality.\n     *\n     * @param singularText text to print if field value is one\n     * @param pluralText text to print if field value is not one\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    public PeriodFormatterBuilder appendSuffix(String singularText,\n                                               String pluralText) {\n        if (singularText == null || pluralText == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new PluralAffix(singularText, pluralText));\n    }\n\n    /**\n     * Append a field suffix which applies only to the last appended field. If\n     * the field is not printed, neither is the suffix.\n     *\n     * @param suffix custom suffix\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if no field exists to append to\n     * @see #appendPrefix\n     */\n    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\n        final Object originalPrinter;\n        final Object originalParser;\n        if (iElementPairs.size() > 0) {\n            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\n            originalParser = iElementPairs.get(iElementPairs.size() - 1);\n        } else {\n            originalPrinter = null;\n            originalParser = null;\n        }\n\n        if (originalPrinter == null || originalParser == null ||\n                originalPrinter != originalParser ||\n                !(originalPrinter instanceof FieldFormatter)) {\n            throw new IllegalStateException(\"No field to apply suffix to\");\n        }\n\n        clearPrefix();\n        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\n        iElementPairs.set(iElementPairs.size() - 2, newField);\n        iElementPairs.set(iElementPairs.size() - 1, newField);\n        iFieldFormatters[newField.getFieldType()] = newField;\n        \n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\").appendHours()</code>\n     * will only output the comma if both the days and hours fields are output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text) {\n        return appendSeparator(text, text, null, true, true);\n    }\n\n    /**\n     * Append a separator, which is output only if fields are printed after the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsAfter(\",\").appendHours()</code>\n     * will only output the comma if the hours fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n        return appendSeparator(text, text, null, false, true);\n    }\n\n    /**\n     * Append a separator, which is output only if fields are printed before the separator.\n     * <p>\n     * For example,\n     * <code>builder.appendDays().appendSeparatorIfFieldsBefore(\",\").appendHours()</code>\n     * will only output the comma if the days fields is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {\n        return appendSeparator(text, text, null, true, false);\n    }\n\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {\n        return appendSeparator(text, finalText, null, true, true);\n    }\n\n    /**\n     * Append a separator, which is output if fields are printed both before\n     * and after the separator.\n     * <p>\n     * This method changes the separator depending on whether it is the last separator\n     * to be output.\n     * <p>\n     * For example, <code>builder.appendDays().appendSeparator(\",\", \"&\").appendHours().appendSeparator(\",\", \"&\").appendMinutes()</code>\n     * will output '1,2&3' if all three fields are output, '1&2' if two fields are output\n     * and '1' if just one field is output.\n     * <p>\n     * The text will be parsed case-insensitively.\n     * <p>\n     * Note: appending a separator discontinues any further work on the latest\n     * appended field.\n     *\n     * @param text  the text to use as a separator\n     * @param finalText  the text used used if this is the final separator to be printed\n     * @param variants  set of text values which are also acceptable when parsed\n     * @return this PeriodFormatterBuilder\n     * @throws IllegalStateException if this separator follows a previous one\n     */\n    public PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                  String[] variants) {\n        return appendSeparator(text, finalText, variants, true, true);\n    }\n\n    private PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                   String[] variants,\n                                                   boolean useBefore, boolean useAfter) {\n        if (text == null || finalText == null) {\n            throw new IllegalArgumentException();\n        }\n\n        clearPrefix();\n        \n        // optimise zero formatter case\n        List<Object> pairs = iElementPairs;\n        if (pairs.size() == 0) {\n            if (useAfter && useBefore == false) {\n                Separator separator = new Separator(\n                        text, finalText, variants,\n                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);\n                append0(separator, separator);\n            }\n            return this;\n        }\n        \n        // find the last separator added\n        int i;\n        Separator lastSeparator = null;\n        for (i=pairs.size(); --i>=0; ) {\n            if (pairs.get(i) instanceof Separator) {\n                lastSeparator = (Separator) pairs.get(i);\n                pairs = pairs.subList(i + 1, pairs.size());\n                break;\n            }\n            i--;  // element pairs\n        }\n        \n        // merge formatters\n        if (lastSeparator != null && pairs.size() == 0) {\n            throw new IllegalStateException(\"Cannot have two adjacent separators\");\n        } else {\n            Object[] comp = createComposite(pairs);\n            pairs.clear();\n            Separator separator = new Separator(\n                    text, finalText, variants,\n                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],\n                    useBefore, useAfter);\n            pairs.add(separator);\n            pairs.add(separator);\n        }\n        \n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private void clearPrefix() throws IllegalStateException {\n        if (iPrefix != null) {\n            throw new IllegalStateException(\"Prefix not followed by field\");\n        }\n        iPrefix = null;\n    }\n\n    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        iNotPrinter |= (printer == null);\n        iNotParser |= (parser == null);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        int size = elementPairs.size();\n        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n            Separator sep = (Separator) elementPairs.get(0);\n                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                sep = sep.finish(f.getPrinter(), f.getParser());\n                return new PeriodFormatter(sep, sep);\n        }\n        Object[] comp = createComposite(elementPairs);\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }\n\n    private static Object[] createComposite(List<Object> elementPairs) {\n        switch (elementPairs.size()) {\n            case 0:\n                return new Object[] {Literal.EMPTY, Literal.EMPTY};\n            case 1:\n                return new Object[] {elementPairs.get(0), elementPairs.get(1)};\n            default:\n                Composite comp = new Composite(elementPairs);\n                return new Object[] {comp, comp};\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Defines a formatted field's prefix or suffix text.\n     * This can be used for fields such as 'n hours' or 'nH' or 'Hour:n'.\n     */\n    static interface PeriodFieldAffix {\n        int calculatePrintedLength(int value);\n        \n        void printTo(StringBuffer buf, int value);\n        \n        void printTo(Writer out, int value) throws IOException;\n        \n        /**\n         * @return new position after parsing affix, or ~position of failure\n         */\n        int parse(String periodStr, int position);\n\n        /**\n         * @return position where affix starts, or original ~position if not found\n         */\n        int scan(String periodStr, int position);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an affix where the text does not vary by the amount.\n     */\n    static class SimpleAffix implements PeriodFieldAffix {\n        private final String iText;\n\n        SimpleAffix(String text) {\n            iText = text;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return iText.length();\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(iText);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            out.write(iText);\n        }\n\n        public int parse(String periodStr, int position) {\n            String text = iText;\n            int textLength = text.length();\n            if (periodStr.regionMatches(true, position, text, 0, textLength)) {\n                return position + textLength;\n            }\n            return ~position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            String text = iText;\n            int textLength = text.length();\n            int sourceLength = periodStr.length();\n            search:\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {\n                    return pos;\n                }\n                // Only allow number characters to be skipped in search of suffix.\n                switch (periodStr.charAt(pos)) {\n                case '0': case '1': case '2': case '3': case '4':\n                case '5': case '6': case '7': case '8': case '9':\n                case '.': case ',': case '+': case '-':\n                    break;\n                default:\n                    break search;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Implements an affix where the text varies by the amount of the field.\n     * Only singular (1) and plural (not 1) are supported.\n     */\n    static class PluralAffix implements PeriodFieldAffix {\n        private final String iSingularText;\n        private final String iPluralText;\n\n        PluralAffix(String singularText, String pluralText) {\n            iSingularText = singularText;\n            iPluralText = pluralText;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return (value == 1 ? iSingularText : iPluralText).length();\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            buf.append(value == 1 ? iSingularText : iPluralText);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            out.write(value == 1 ? iSingularText : iPluralText);\n        }\n\n        public int parse(String periodStr, int position) {\n            String text1 = iPluralText;\n            String text2 = iSingularText; \n\n            if (text1.length() < text2.length()) {\n                // Swap in order to match longer one first.\n                String temp = text1;\n                text1 = text2;\n                text2 = temp;\n            }\n\n            if (periodStr.regionMatches\n                (true, position, text1, 0, text1.length())) {\n                return position + text1.length();\n            }\n            if (periodStr.regionMatches\n                (true, position, text2, 0, text2.length())) {\n                return position + text2.length();\n            }\n\n            return ~position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            String text1 = iPluralText;\n            String text2 = iSingularText; \n\n            if (text1.length() < text2.length()) {\n                // Swap in order to match longer one first.\n                String temp = text1;\n                text1 = text2;\n                text2 = temp;\n            }\n\n            int textLength1 = text1.length();\n            int textLength2 = text2.length();\n\n            int sourceLength = periodStr.length();\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) {\n                    return pos;\n                }\n                if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) {\n                    return pos;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Builds a composite affix by merging two other affix implementations.\n     */\n    static class CompositeAffix implements PeriodFieldAffix {\n        private final PeriodFieldAffix iLeft;\n        private final PeriodFieldAffix iRight;\n\n        CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) {\n            iLeft = left;\n            iRight = right;\n        }\n\n        public int calculatePrintedLength(int value) {\n            return iLeft.calculatePrintedLength(value)\n                + iRight.calculatePrintedLength(value);\n        }\n\n        public void printTo(StringBuffer buf, int value) {\n            iLeft.printTo(buf, value);\n            iRight.printTo(buf, value);\n        }\n\n        public void printTo(Writer out, int value) throws IOException {\n            iLeft.printTo(out, value);\n            iRight.printTo(out, value);\n        }\n\n        public int parse(String periodStr, int position) {\n            position = iLeft.parse(periodStr, position);\n            if (position >= 0) {\n                position = iRight.parse(periodStr, position);\n            }\n            return position;\n        }\n\n        public int scan(String periodStr, final int position) {\n            int pos = iLeft.scan(periodStr, position);\n            if (pos >= 0) {\n                return iRight.scan(periodStr, pos);\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Formats the numeric value of a field, potentially with prefix/suffix.\n     */\n    static class FieldFormatter\n            implements PeriodPrinter, PeriodParser {\n        private final int iMinPrintedDigits;\n        private final int iPrintZeroSetting;\n        private final int iMaxParsedDigits;\n        private final boolean iRejectSignedValues;\n        \n        /** The index of the field type, 0=year, etc. */\n        private final int iFieldType;\n        /**\n         * The array of the latest formatter added for each type.\n         * This is shared between all the field formatters in a formatter.\n         */\n        private final FieldFormatter[] iFieldFormatters;\n        \n        private final PeriodFieldAffix iPrefix;\n        private final PeriodFieldAffix iSuffix;\n\n        FieldFormatter(int minPrintedDigits, int printZeroSetting,\n                       int maxParsedDigits, boolean rejectSignedValues,\n                       int fieldType, FieldFormatter[] fieldFormatters,\n                       PeriodFieldAffix prefix, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = minPrintedDigits;\n            iPrintZeroSetting = printZeroSetting;\n            iMaxParsedDigits = maxParsedDigits;\n            iRejectSignedValues = rejectSignedValues;\n            iFieldType = fieldType;\n            iFieldFormatters = fieldFormatters;\n            iPrefix = prefix;\n            iSuffix = suffix;\n        }\n\n        FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {\n            iMinPrintedDigits = field.iMinPrintedDigits;\n            iPrintZeroSetting = field.iPrintZeroSetting;\n            iMaxParsedDigits = field.iMaxParsedDigits;\n            iRejectSignedValues = field.iRejectSignedValues;\n            iFieldType = field.iFieldType;\n            iFieldFormatters = field.iFieldFormatters;\n            iPrefix = field.iPrefix;\n            if (field.iSuffix != null) {\n                suffix = new CompositeAffix(field.iSuffix, suffix);\n            }\n            iSuffix = suffix;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            if (stopAt <= 0) {\n                return 0;\n            }\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {\n                return 1;\n            }\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return 0;\n            }\n\n            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\n            if (iFieldType >= SECONDS_MILLIS) {\n                // valueLong contains the seconds and millis fields\n                // the minimum output is 0.000, which is 4 digits\n                sum = Math.max(sum, 4);\n                // plus one for the decimal point\n                sum++;\n                if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\n                    sum -= 4; // remove three digits and decimal point\n                }\n                // reset valueLong to refer to the seconds part for the prefic/suffix calculation\n                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;\n            }\n            int value = (int) valueLong;\n\n            if (iPrefix != null) {\n                sum += iPrefix.calculatePrintedLength(value);\n            }\n            if (iSuffix != null) {\n                sum += iSuffix.calculatePrintedLength(value);\n            }\n\n            return sum;\n        }\n        \n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(buf, value);\n            }\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.appendUnpaddedInteger(buf, value);\n            } else {\n                FormatUtils.appendPaddedInteger(buf, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    buf.append('.');\n                    FormatUtils.appendPaddedInteger(buf, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(buf, value);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(out, value);\n            }\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.writeUnpaddedInteger(out, value);\n            } else {\n                FormatUtils.writePaddedInteger(out, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    out.write('.');\n                    FormatUtils.writePaddedInteger(out, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(out, value);\n            }\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\n                    if (wholeValue < 0) {\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }\n\n        /**\n         * @param text text to parse\n         * @param position position in text\n         * @param length exact count of characters to parse\n         * @return parsed int value\n         */\n        private int parseInt(String text, int position, int length) {\n            if (length >= 10) {\n                // Since value may exceed max, use stock parser which checks for this.\n                return Integer.parseInt(text.substring(position, position + length));\n            }\n            if (length <= 0) {\n                return 0;\n            }\n            int value = text.charAt(position++);\n            length--;\n            boolean negative;\n            if (value == '-') {\n                if (--length < 0) {\n                    return 0;\n                }\n                negative = true;\n                value = text.charAt(position++);\n            } else {\n                negative = false;\n            }\n            value -= '0';\n            while (length-- > 0) {\n                value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n            }\n            return negative ? -value : value;\n        }\n\n        /**\n         * @return Long.MAX_VALUE if nothing to print, otherwise value\n         */\n        long getFieldValue(ReadablePeriod period) {\n            PeriodType type;\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                type = null; // Don't need to check if supported.\n            } else {\n                type = period.getPeriodType();\n            }\n            if (type != null && isSupported(type, iFieldType) == false) {\n                return Long.MAX_VALUE;\n            }\n\n            long value;\n\n            switch (iFieldType) {\n            default:\n                return Long.MAX_VALUE;\n            case YEARS:\n                value = period.get(DurationFieldType.years());\n                break;\n            case MONTHS:\n                value = period.get(DurationFieldType.months());\n                break;\n            case WEEKS:\n                value = period.get(DurationFieldType.weeks());\n                break;\n            case DAYS:\n                value = period.get(DurationFieldType.days());\n                break;\n            case HOURS:\n                value = period.get(DurationFieldType.hours());\n                break;\n            case MINUTES:\n                value = period.get(DurationFieldType.minutes());\n                break;\n            case SECONDS:\n                value = period.get(DurationFieldType.seconds());\n                break;\n            case MILLIS:\n                value = period.get(DurationFieldType.millis());\n                break;\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                int seconds = period.get(DurationFieldType.seconds());\n                int millis = period.get(DurationFieldType.millis());\n                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n                break;\n            }\n\n            // determine if period is zero and this is the last field\n            if (value == 0) {\n                switch (iPrintZeroSetting) {\n                case PRINT_ZERO_NEVER:\n                    return Long.MAX_VALUE;\n                case PRINT_ZERO_RARELY_LAST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                case PRINT_ZERO_RARELY_FIRST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK\n                        i--;                              // see bug 1660490\n                        for (; i >= 0 && i <= MAX_FIELD; i--) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                }\n            }\n\n            return value;\n        }\n\n        boolean isZero(ReadablePeriod period) {\n            for (int i = 0, isize = period.size(); i < isize; i++) {\n                if (period.getValue(i) != 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        boolean isSupported(PeriodType type, int field) {\n            switch (field) {\n            default:\n                return false;\n            case YEARS:\n                return type.isSupported(DurationFieldType.years());\n            case MONTHS:\n                return type.isSupported(DurationFieldType.months());\n            case WEEKS:\n                return type.isSupported(DurationFieldType.weeks());\n            case DAYS:\n                return type.isSupported(DurationFieldType.days());\n            case HOURS:\n                return type.isSupported(DurationFieldType.hours());\n            case MINUTES:\n                return type.isSupported(DurationFieldType.minutes());\n            case SECONDS:\n                return type.isSupported(DurationFieldType.seconds());\n            case MILLIS:\n                return type.isSupported(DurationFieldType.millis());\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                return type.isSupported(DurationFieldType.seconds()) ||\n                       type.isSupported(DurationFieldType.millis());\n            }\n        }\n\n        void setFieldValue(ReadWritablePeriod period, int field, int value) {\n            switch (field) {\n            default:\n                break;\n            case YEARS:\n                period.setYears(value);\n                break;\n            case MONTHS:\n                period.setMonths(value);\n                break;\n            case WEEKS:\n                period.setWeeks(value);\n                break;\n            case DAYS:\n                period.setDays(value);\n                break;\n            case HOURS:\n                period.setHours(value);\n                break;\n            case MINUTES:\n                period.setMinutes(value);\n                break;\n            case SECONDS:\n                period.setSeconds(value);\n                break;\n            case MILLIS:\n                period.setMillis(value);\n                break;\n            }\n        }\n\n        int getFieldType() {\n            return iFieldType;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Handles a simple literal piece of text.\n     */\n    static class Literal\n            implements PeriodPrinter, PeriodParser {\n        static final Literal EMPTY = new Literal(\"\");\n        private final String iText;\n\n        Literal(String text) {\n            iText = text;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            return 0;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            return iText.length();\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            buf.append(iText);\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            out.write(iText);\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n                return position + iText.length();\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Handles a separator, that splits the fields into multiple parts.\n     * For example, the 'T' in the ISO8601 standard.\n     */\n    static class Separator\n            implements PeriodPrinter, PeriodParser {\n        private final String iText;\n        private final String iFinalText;\n        private final String[] iParsedForms;\n\n        private final boolean iUseBefore;\n        private final boolean iUseAfter;\n\n        private final PeriodPrinter iBeforePrinter;\n        private volatile PeriodPrinter iAfterPrinter;\n        private final PeriodParser iBeforeParser;\n        private volatile PeriodParser iAfterParser;\n\n        Separator(String text, String finalText, String[] variants,\n                PeriodPrinter beforePrinter, PeriodParser beforeParser,\n                boolean useBefore, boolean useAfter) {\n            iText = text;\n            iFinalText = finalText;\n\n            if ((finalText == null || text.equals(finalText)) &&\n                (variants == null || variants.length == 0)) {\n\n                iParsedForms = new String[] {text};\n            } else {\n                // Filter and reverse sort the parsed forms.\n                TreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n                parsedSet.add(text);\n                parsedSet.add(finalText);\n                if (variants != null) {\n                    for (int i=variants.length; --i>=0; ) {\n                        parsedSet.add(variants[i]);\n                    }\n                }\n                ArrayList<String> parsedList = new ArrayList<String>(parsedSet);\n                Collections.reverse(parsedList);\n                iParsedForms = parsedList.toArray(new String[parsedList.size()]);\n            }\n\n            iBeforePrinter = beforePrinter;\n            iBeforeParser = beforeParser;\n            iUseBefore = useBefore;\n            iUseAfter = useAfter;\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale);\n            if (sum < stopAt) {\n                sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale);\n            }\n            return sum;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            int sum = before.calculatePrintedLength(period, locale)\n                    + after.calculatePrintedLength(period, locale);\n            \n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            sum += (afterCount > 1 ? iText : iFinalText).length();\n                        }\n                    } else {\n                        sum += iText.length();\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                sum += iText.length();\n            }\n            \n            return sum;\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(buf, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            buf.append(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        buf.append(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                buf.append(iText);\n            }\n            after.printTo(buf, period, locale);\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(out, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            out.write(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        out.write(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                out.write(iText);\n            }\n            after.printTo(out, period, locale);\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            int oldPos = position;\n            position = iBeforeParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            boolean found = false;\n            if (position > oldPos) {\n                // Consume this separator.\n                String[] parsedForms = iParsedForms;\n                int length = parsedForms.length;\n                for (int i=0; i < length; i++) {\n                    String parsedForm = parsedForms[i];\n                    if ((parsedForm == null || parsedForm.length() == 0) ||\n                        periodStr.regionMatches\n                        (true, position, parsedForm, 0, parsedForm.length())) {\n                        \n                        position += parsedForm.length();\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            oldPos = position;\n            position = iAfterParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            if (found && position == oldPos) {\n                // Separator should not have been supplied.\n                return ~oldPos;\n            }\n\n            if (position > oldPos && !found && !iUseBefore) {\n                // Separator was required.\n                return ~oldPos;\n            }\n\n            return position;\n        }\n\n        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\n            iAfterPrinter = afterPrinter;\n            iAfterParser = afterParser;\n            return this;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Composite implementation that merges other fields to create a full pattern.\n     */\n    static class Composite\n            implements PeriodPrinter, PeriodParser {\n        \n        private final PeriodPrinter[] iPrinters;\n        private final PeriodParser[] iParsers;\n\n        Composite(List<Object> elementPairs) {\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n            } else {\n                iPrinters = printerList.toArray(\n                        new PeriodPrinter[printerList.size()]);\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n            } else {\n                iParsers = parserList.toArray(\n                        new PeriodParser[parserList.size()]);\n            }\n        }\n\n        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; sum < stopAt && --i>=0; ) {\n                sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);\n            }\n            return sum;\n        }\n\n        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; --i>=0; ) {\n                sum += printers[i].calculatePrintedLength(period, locale);\n            }\n            return sum;\n        }\n\n        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(buf, period, locale);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(out, period, locale);\n            }\n        }\n\n        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            PeriodParser[] parsers = iParsers;\n            if (parsers == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = parsers.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = parsers[i].parseInto(period, periodStr, position, locale);\n            }\n            return position;\n        }\n\n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof PeriodPrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite) element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof PeriodParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite) element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }\n\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }\n    }\n\n}\n", "review": {"response": "<think>\nOkay, let me try to figure out what bugs might be in this Java code. The user provided a snippet of the PeriodFormatterBuilder class from Joda-Time. The task is to review the code for bugs and return a JSON list of bugs.\n\nFirst, I'll look through the code for any obvious issues. The code is part of the Joda-Time library, which is well-known, so maybe there are some subtle bugs here. Let me start by checking the methods and their implementations.\n\nThe toFormatter() method is supposed to create a PeriodFormatter. Looking at the code:\n\npublic PeriodFormatter toFormatter() {\n    PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\n    iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n    return formatter;\n}\n\nWait, the line where it clones iFieldFormatters. The original array is of type FieldFormatter[], and they're casting the clone to the same type. But in Java, the clone() method for arrays returns an Object, so they need to cast it. But the code does (FieldFormatter[]) iFieldFormatters.clone(). That's correct because the clone of an array is of the same type. But wait, what if iFieldFormatters is null? No, because in the constructor, clear() is called, which initializes iFieldFormatters. Let me check the constructor:\n\npublic PeriodFormatterBuilder() {\n    clear();\n}\n\nAnd the clear() method would initialize iFieldFormatters. Looking at the code, the clear() method (not shown here) probably sets iFieldFormatters to a new array. So assuming that's correct, this line is okay. But maybe there's a problem with the clone. Wait, the code is storing the clone back into iFieldFormatters. But why? The comment says that the returned formatter may not be a printer or parser, but the toFormatter() method is called, which creates a formatter. Then, the code clones the iFieldFormatters array. But why would they do that? Maybe it's part of a state management. However, the problem is that if the toFormatter() method is called multiple times, each time it would modify the iFieldFormatters array. Wait, no, because the code is cloning the original iFieldFormatters and then storing it back. Wait, no: the line is:\n\niFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n\nWait, that's taking the current iFieldFormatters, cloning it, and then assigning it back. But why? Because the original code is supposed to create a formatter and then save a clone of the field formatters. But the toFormatter() method is supposed to create a formatter that is immutable once built. However, the code here seems to be modifying the internal state of the builder after creating the formatter. That could be a problem. Because if you call toFormatter() multiple times, each call would clone the iFieldFormatters array and store it back. But if the builder is still being modified (appending elements), then the next toFormatter() call would have the updated elements. Wait, but the code is supposed to create a formatter based on the current state, and then save a clone of the field formatters. But the comment says that subsequent changes to the builder don't affect the returned formatter. So maybe this line is trying to preserve the state of the field formatters after building the formatter. However, the code is not doing that correctly. Because the line is cloning iFieldFormatters and then reassigning it, which would not change the array unless there was a prior modification. Hmm, perhaps this is a bug. Let me think.\n\nWait, the iFieldFormatters array is supposed to track the last appended formatters of each field type. When you call toFormatter(), you create a formatter, and then you save a clone of the iFieldFormatters array. But why? Because the builder is mutable, and if you call toFormatter() again, it would use the same iFieldFormatters array. But the comment says that subsequent changes to the builder do not affect the returned formatter. So the act of calling toFormatter() should capture the current state. However, the code here is not capturing the state of the iElementPairs, iNotPrinter, etc. when the formatter is created. Wait, the toFormatter() method is calling toFormatter(iElementPairs, iNotPrinter, iNotParser), which probably uses those variables. But then the code is saving a clone of iFieldFormatters into itself. That seems odd. Because if the builder is modified after that, the iFieldFormatters array would be different. But the formatter is already created. So perhaps the line where it clones iFieldFormatters is unnecessary, or perhaps it's a bug where the clone is not needed and is causing the builder's state to be modified. Because if you call toFormatter(), the code clones the current iFieldFormatters and overwrites it. But why would you do that? Maybe it's a mistake. For example, perhaps the code is trying to save the state of the field formatters after building the formatter, but the clone is unnecessary. Or maybe it's a leftover from some previous code. This line could be a bug because it's modifying the builder's internal state after creating the formatter. If the builder is supposed to be mutable and allow multiple calls to toFormatter(), then cloning the iFieldFormatters and overwriting it might not be necessary. For example, if the builder is modified again after the first call to toFormatter(), the clone would have been done, but the iFieldFormatters array is now a clone of itself. Wait, no. The original iFieldFormatters is a FieldFormatter array. When you call clone(), you get a shallow copy. So if the array is cloned and then assigned back to iFieldFormatters, it's still the same elements. But why would you need to do that? Unless there's some logic elsewhere that expects the iFieldFormatters to be a clone after building. But without seeing more code, it's hard to tell. However, this line could be a bug if it's intended to preserve the state of the field formatters at the time of building the formatter. For example, if after building, the builder is modified again, but the iFieldFormatters array is cloned and stored, perhaps that's not needed. Alternatively, maybe the code is trying to make a copy of the field formatters for the formatter, but it's not doing it correctly. For instance, if the formatter uses the iFieldFormatters array, and the builder is modified again, then the formatter's state could be affected. But the comment says that subsequent changes to the builder do not affect the returned formatter. So the act of calling toFormatter() should capture all necessary state. The line where it clones iFieldFormatters and stores it back may be a no-op, or perhaps it's a mistake. For example, maybe the code is trying to save the state of the field formatters for the formatter, but it's not doing it correctly. If the formatter is using the iFieldFormatters array, then cloning it here would not prevent the formatter from being affected by future changes to the builder. Because the formatter is built from the current state of iElementPairs, iNotPrinter, etc. So this line may be a bug, perhaps a leftover code that's not needed. Therefore, this line could be a bug. The correct approach would be to not modify the iFieldFormatters array after creating the formatter. The line iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone(); is unnecessary and could be a bug if it's intended to preserve the state. Alternatively, if the code is supposed to save the state of the field formatters for the formatter, but the way it's done is incorrect, then this is a problem.\n\nAnother possible bug is in the toFormatter() method's return statement. The method returns the formatter, but if the builder is not a printer or parser, it throws an IllegalStateException. However, the code for toFormatter() is not shown here. The line in the code that could cause that exception is when creating the formatter. But in the given code, the toFormatter() method calls another toFormatter() method with the current state. If that method is not properly checking if it can create a printer or parser, then there could be a bug. However, without seeing the implementation of the other toFormatter() method, it's hard to tell. But the user's code snippet doesn't include that method.\n\nAnother thing to check is the use of the clone method on the array. In Java, the clone method for arrays returns an array of the same type. So the cast is safe. However, if the iFieldFormatters is not an array of FieldFormatter, then it could cause a ClassCastException. But since iFieldFormatters is declared as FieldFormatter[], this is unlikely. So that line is probably okay.\n\nAnother possible issue is the handling of the iNotPrinter and iNotParser flags. For example, in the toPrinter() method:\n\npublic PeriodPrinter toPrinter() {\n    if (iNotPrinter) {\n        return null;\n    }\n    return toFormatter().getPrinter();\n}\n\nIf iNotPrinter is true, it returns null. Otherwise, it calls toFormatter() and gets the printer. But toFormatter() may throw an IllegalStateException if the builder can't produce a printer or parser. So if the builder can't produce a formatter (e.g., no elements added), then toFormatter() would throw, but toPrinter() is called when iNotPrinter is false. That could be a problem. For example, if the builder is not set up to be a printer (iNotPrinter is false), but there are no elements added, then toFormatter() would throw an exception. But the toPrinter() method doesn't handle that. So the toPrinter() method could throw an IllegalStateException when iNotPrinter is false but the builder can't create a formatter. That's a possible bug. The toPrinter() method should check if it can create a printer before calling toFormatter(). Alternatively, the toFormatter() method should be called only if the builder can create a formatter. But the code doesn't do that. For example, if iNotPrinter is false, but there are no elements in iElementPairs, then toFormatter() would throw an exception. The toPrinter() method should probably check if the builder can create a printer (i.e., if it's not a printer, return null, but if it is a printer, then check if there are elements to build the formatter). However, the current code doesn't do that. So the toPrinter() method could throw an exception even though it's supposed to return null if the builder can't create a printer. That's a bug.\n\nSimilarly, the toParser() method has the same issue. Let me check:\n\npublic PeriodParser toParser() {\n    if (iNotParser) {\n        return null;\n    }\n    return toFormatter().getParser();\n}\n\nSame problem. If iNotParser is false, but the builder can't create a formatter (e.g., no elements), then toFormatter() would throw an exception. The toParser() method should check if the formatter can be created as a parser before calling toFormatter(). The current code assumes that if iNotParser is false, then the formatter can be created as a parser, which may not be the case. So this is a bug.\n\nAnother possible issue is in the constructor. The code calls clear(), which presumably initializes the iElementPairs list. If clear() is not properly initializing the list, then appending elements could cause issues. However, the user's code snippet doesn't show the clear() method, so we can't check that. But assuming that clear() initializes iElementPairs as a new list, then it's okay.\n\nLooking at the iElementPairs list: it's a List<Object> used to build the formatter. The code doesn't show how elements are added to it, but if there's a possibility of adding null elements or incorrect types, that could be a problem. However, without seeing the append methods, it's hard to tell.\n\nAnother thing to check is the handling of the iPrintZeroSetting and other variables. For example, if the code uses these variables in the formatter creation, but they are not properly initialized. But again, without seeing more code, it's hard to assess.\n\nSo, based on the code provided, the main bugs are:\n\n1. In the toFormatter() method, the line iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone(); may be unnecessary and could be a bug if it's intended to preserve the state. However, without more context, it's hard to say for sure. But this line could be a problem if it's modifying the builder's state after creating the formatter, which might not be necessary.\n\n2. The toPrinter() and toParser() methods can throw an IllegalStateException even when they should return null. For example, if iNotPrinter is false, but the builder can't create a formatter (e.g., no elements added), then toFormatter() would throw, but toPrinter() is supposed to return null if the builder can't create a printer. However, in this case, the code is not handling that scenario. The toPrinter() and toParser() methods should check if the formatter can be created before calling toFormatter().\n\nLet me elaborate on the second point. The toPrinter() method checks if iNotPrinter is true and returns null. Otherwise, it calls toFormatter().getPrinter(). But if the builder can't create a formatter (e.g., no elements added), then toFormatter() would throw an IllegalStateException. However, the toPrinter() method is supposed to return null if the builder can't create a printer. But in this case, it's throwing an exception instead. So the code should check whether the formatter can be created as a printer before calling toFormatter(). For example, maybe the code should check if iElementPairs is empty and iNotPrinter is false, then return null. But the current code doesn't do that. Therefore, this is a bug.\n\nSo the JSON response should list these bugs.\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"line\": 119,\n      \"description\": \"The line `iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();` modifies the internal state of the builder after creating the formatter. This could be unnecessary and may lead to unexpected behavior if the builder is reused, as it clones the array but does not use it in formatter creation. The comment indicates that subsequent changes to the builder should not affect the formatter, but this line may not align with that intention.\"\n    },\n    {\n      \"line\": 149,\n      \"description\": \"The `toPrinter()` method calls `toFormatter().getPrinter()` without verifying if the formatter can actually be created. If the builder cannot produce a printer (e.g., no elements added), `toFormatter()` will throw an `IllegalStateException`, but the method should return `null` instead. This violates the documented behavior and could lead to unhandled exceptions.\"\n    },\n    {\n      \"line\": 162,\n      \"description\": \"The `toParser()` method similarly calls `toFormatter().getParser()` without checking if the formatter can be created. If the builder cannot produce a parser, `toFormatter()` will throw an `IllegalStateException`, but the method should return `null`. This is inconsistent with the documented behavior and may result in unhandled exceptions.\"\n    }\n  ]\n}\n```"}}