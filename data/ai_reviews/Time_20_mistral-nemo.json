{"sample_id": "Time_20", "model": "mistral-nemo", "code_context": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.MutableDateTime;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.MutableDateTime.Property;\nimport org.joda.time.field.MillisDurationField;\nimport org.joda.time.field.PreciseDateTimeField;\n\n/**\n * Factory that creates complex instances of DateTimeFormatter via method calls.\n * <p>\n * Datetime formatting is performed by the {@link DateTimeFormatter} class.\n * Three classes provide factory methods to create formatters, and this is one.\n * The others are {@link DateTimeFormat} and {@link ISODateTimeFormat}.\n * <p>\n * DateTimeFormatterBuilder is used for constructing formatters which are then\n * used to print or parse. The formatters are built by appending specific fields\n * or other formatters to an instance of this builder.\n * <p>\n * For example, a formatter that prints month and year, like \"January 1970\",\n * can be constructed as follows:\n * <p>\n * <pre>\n * DateTimeFormatter monthAndYear = new DateTimeFormatterBuilder()\n *     .appendMonthOfYearText()\n *     .appendLiteral(' ')\n *     .appendYear(4, 4)\n *     .toFormatter();\n * </pre>\n * <p>\n * DateTimeFormatterBuilder itself is mutable and not thread-safe, but the\n * formatters that it builds are thread-safe and immutable.\n *\n * @author Brian S O'Neill\n * @author Stephen Colebourne\n * @author Fredrik Borgh\n * @since 1.0\n * @see DateTimeFormat\n * @see ISODateTimeFormat\n */\npublic class DateTimeFormatterBuilder {\n\n    /** Array of printers and parsers (alternating). */\n    private ArrayList<Object> iElementPairs;\n    /** Cache of the last returned formatter. */\n    private Object iFormatter;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a DateTimeFormatterBuilder.\n     */\n    public DateTimeFormatterBuilder() {\n        super();\n        iElementPairs = new ArrayList<Object>();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a DateTimeFormatter using all the appended elements.\n     * <p>\n     * This is the main method used by applications at the end of the build\n     * process to create a usable formatter.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned formatter.\n     * <p>\n     * The returned formatter may not support both printing and parsing.\n     * The methods {@link DateTimeFormatter#isPrinter()} and\n     * {@link DateTimeFormatter#isParser()} will help you determine the state\n     * of the formatter.\n     *\n     * @throws UnsupportedOperationException if neither printing nor parsing is supported\n     */\n    public DateTimeFormatter toFormatter() {\n        Object f = getFormatter();\n        DateTimePrinter printer = null;\n        if (isPrinter(f)) {\n            printer = (DateTimePrinter) f;\n        }\n        DateTimeParser parser = null;\n        if (isParser(f)) {\n            parser = (DateTimeParser) f;\n        }\n        if (printer != null || parser != null) {\n            return new DateTimeFormatter(printer, parser);\n        }\n        throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n    }\n\n    /**\n     * Internal method to create a DateTimePrinter instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a printer in an application, call {@link #toFormatter()}\n     * and just use the printing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned printer.\n     *\n     * @throws UnsupportedOperationException if printing is not supported\n     */\n    public DateTimePrinter toPrinter() {\n        Object f = getFormatter();\n        if (isPrinter(f)) {\n            return (DateTimePrinter) f;\n        }\n        throw new UnsupportedOperationException(\"Printing is not supported\");\n    }\n\n    /**\n     * Internal method to create a DateTimeParser instance using all the\n     * appended elements.\n     * <p>\n     * Most applications will not use this method.\n     * If you want a parser in an application, call {@link #toFormatter()}\n     * and just use the parsing API.\n     * <p>\n     * Subsequent changes to this builder do not affect the returned parser.\n     *\n     * @throws UnsupportedOperationException if parsing is not supported\n     */\n    public DateTimeParser toParser() {\n        Object f = getFormatter();\n        if (isParser(f)) {\n            return (DateTimeParser) f;\n        }\n        throw new UnsupportedOperationException(\"Parsing is not supported\");\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns true if toFormatter can be called without throwing an\n     * UnsupportedOperationException.\n     * \n     * @return true if a formatter can be built\n     */\n    public boolean canBuildFormatter() {\n        return isFormatter(getFormatter());\n    }\n\n    /**\n     * Returns true if toPrinter can be called without throwing an\n     * UnsupportedOperationException.\n     * \n     * @return true if a printer can be built\n     */\n    public boolean canBuildPrinter() {\n        return isPrinter(getFormatter());\n    }\n\n    /**\n     * Returns true if toParser can be called without throwing an\n     * UnsupportedOperationException.\n     * \n     * @return true if a parser can be built\n     */\n    public boolean canBuildParser() {\n        return isParser(getFormatter());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Clears out all the appended elements, allowing this builder to be\n     * reused.\n     */\n    public void clear() {\n        iFormatter = null;\n        iElementPairs.clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Appends another formatter.\n     *\n     * @param formatter  the formatter to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if formatter is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        return append0(formatter.getPrinter(), formatter.getParser());\n    }\n\n    /**\n     * Appends just a printer. With no matching parser, a parser cannot be\n     * built from this DateTimeFormatterBuilder.\n     *\n     * @param printer  the printer to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if printer is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder append(DateTimePrinter printer) {\n        checkPrinter(printer);\n        return append0(printer, null);\n    }\n\n    /**\n     * Appends just a parser. With no matching printer, a printer cannot be\n     * built from this builder.\n     *\n     * @param parser  the parser to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if parser is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder append(DateTimeParser parser) {\n        checkParser(parser);\n        return append0(null, parser);\n    }\n\n    /**\n     * Appends a printer/parser pair.\n     *\n     * @param printer  the printer to add\n     * @param parser  the parser to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if printer or parser is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {\n        checkPrinter(printer);\n        checkParser(parser);\n        return append0(printer, parser);\n    }\n\n    /**\n     * Appends a printer and a set of matching parsers. When parsing, the first\n     * parser in the list is selected for parsing. If it fails, the next is\n     * chosen, and so on. If none of these parsers succeeds, then the failed\n     * position of the parser that made the greatest progress is returned.\n     * <p>\n     * Only the printer is optional. In addition, it is illegal for any but the\n     * last of the parser array elements to be null. If the last element is\n     * null, this represents the empty parser. The presence of an empty parser\n     * indicates that the entire array of parse formats is optional.\n     *\n     * @param printer  the printer to add\n     * @param parsers  the parsers to add\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if any printer or parser is of an invalid type\n     * @throws IllegalArgumentException if any parser element but the last is null\n     */\n    public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) {\n        if (printer != null) {\n            checkPrinter(printer);\n        }\n        if (parsers == null) {\n            throw new IllegalArgumentException(\"No parsers supplied\");\n        }\n        int length = parsers.length;\n        if (length == 1) {\n            if (parsers[0] == null) {\n                throw new IllegalArgumentException(\"No parser supplied\");\n            }\n            return append0(printer, parsers[0]);\n        }\n\n        DateTimeParser[] copyOfParsers = new DateTimeParser[length];\n        int i;\n        for (i = 0; i < length - 1; i++) {\n            if ((copyOfParsers[i] = parsers[i]) == null) {\n                throw new IllegalArgumentException(\"Incomplete parser array\");\n            }\n        }\n        copyOfParsers[i] = parsers[i];\n\n        return append0(printer, new MatchingParser(copyOfParsers));\n    }\n\n    /**\n     * Appends just a parser element which is optional. With no matching\n     * printer, a printer cannot be built from this DateTimeFormatterBuilder.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if parser is null or of an invalid type\n     */\n    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {\n        checkParser(parser);\n        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};\n        return append0(null, new MatchingParser(parsers));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the parser is non null and a provider.\n     * \n     * @param parser  the parser to check\n     */\n    private void checkParser(DateTimeParser parser) {\n        if (parser == null) {\n            throw new IllegalArgumentException(\"No parser supplied\");\n        }\n    }\n\n    /**\n     * Checks if the printer is non null and a provider.\n     * \n     * @param printer  the printer to check\n     */\n    private void checkPrinter(DateTimePrinter printer) {\n        if (printer == null) {\n            throw new IllegalArgumentException(\"No printer supplied\");\n        }\n    }\n\n    private DateTimeFormatterBuilder append0(Object element) {\n        iFormatter = null;\n        // Add the element as both a printer and parser.\n        iElementPairs.add(element);\n        iElementPairs.add(element);\n        return this;\n    }\n\n    private DateTimeFormatterBuilder append0(\n            DateTimePrinter printer, DateTimeParser parser) {\n        iFormatter = null;\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Instructs the printer to emit a specific character, and the parser to\n     * expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendLiteral(char c) {\n        return append0(new CharacterLiteral(c));\n    }\n\n    /**\n     * Instructs the printer to emit specific text, and the parser to expect\n     * it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if text is null\n     */\n    public DateTimeFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        switch (text.length()) {\n            case 0:\n                return this;\n            case 1:\n                return append0(new CharacterLiteral(text.charAt(0)));\n            default:\n                return append0(new StringLiteral(text));\n        }\n    }\n\n    /**\n     * Instructs the printer to emit a field value as a decimal number, and the\n     * parser to expect an unsigned decimal number.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n        }\n    }\n\n    /**\n     * Instructs the printer to emit a field value as a fixed-width decimal\n     * number (smaller numbers will be left-padded with zeros), and the parser\n     * to expect an unsigned decimal number with the same fixed width.\n     * \n     * @param fieldType  type of field to append\n     * @param numDigits  the exact number of digits to parse or print, except if\n     * printed value requires more digits\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n     * @since 1.5\n     */\n    public DateTimeFormatterBuilder appendFixedDecimal(\n            DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, false));\n    }\n\n    /**\n     * Instructs the printer to emit a field value as a decimal number, and the\n     * parser to expect a signed decimal number.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendSignedDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n        }\n    }\n\n    /**\n     * Instructs the printer to emit a field value as a fixed-width decimal\n     * number (smaller numbers will be left-padded with zeros), and the parser\n     * to expect an signed decimal number with the same fixed width.\n     * \n     * @param fieldType  type of field to append\n     * @param numDigits  the exact number of digits to parse or print, except if\n     * printed value requires more digits\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n     * @since 1.5\n     */\n    public DateTimeFormatterBuilder appendFixedSignedDecimal(\n            DateTimeFieldType fieldType, int numDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (numDigits <= 0) {\n            throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n        }\n        return append0(new FixedNumber(fieldType, numDigits, true));\n    }\n\n    /**\n     * Instructs the printer to emit a field value as text, and the\n     * parser to expect text.\n     *\n     * @param fieldType  type of field to append\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, false));\n    }\n\n    /**\n     * Instructs the printer to emit a field value as short text, and the\n     * parser to expect text.\n     *\n     * @param fieldType  type of field to append\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        return append0(new TextField(fieldType, true));\n    }\n\n    /**\n     * Instructs the printer to emit a remainder of time as a decimal fraction,\n     * without decimal point. For example, if the field is specified as\n     * minuteOfHour and the time is 12:30:45, the value printed is 75. A\n     * decimal point is implied, so the fraction is 0.75, or three-quarters of\n     * a minute.\n     *\n     * @param fieldType  type of field to append\n     * @param minDigits  minimum number of digits to print.\n     * @param maxDigits  maximum number of digits to print or parse.\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @throws IllegalArgumentException if field type is null\n     */\n    public DateTimeFormatterBuilder appendFraction(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        return append0(new Fraction(fieldType, minDigits, maxDigits));\n    }\n\n    /**\n     * Appends the print/parse of a fractional second.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 230 milliseconds.\n     * Contrast this behaviour to {@link #appendMillisOfSecond}.\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n    }\n\n    /**\n     * Appends the print/parse of a fractional minute.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 minutes (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits);\n    }\n\n    /**\n     * Appends the print/parse of a fractional hour.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 hours (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits);\n    }\n\n    /**\n     * Appends the print/parse of a fractional day.\n     * <p>\n     * This reliably handles the case where fractional digits are being handled\n     * beyond a visible decimal point. The digits parsed will always be treated\n     * as the most significant (numerically largest) digits.\n     * Thus '23' will be parsed as 0.23 days (converted to milliseconds).\n     * This method does not print or parse the decimal point itself.\n     * \n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to print or parse\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {\n        return appendFraction(DateTimeFieldType.dayOfYear(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric millisOfSecond field.\n     * <p>\n     * This method will append a field that prints a three digit value.\n     * During parsing the value that is parsed is assumed to be three digits.\n     * If less than three digits are present then they will be counted as the\n     * smallest parts of the millisecond. This is probably not what you want\n     * if you are using the field as a fraction. Instead, a fractional\n     * millisecond should be produced using {@link #appendFractionOfSecond}.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric millisOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.millisOfDay(), minDigits, 8);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric secondOfMinute field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric secondOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.secondOfDay(), minDigits, 5);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric minuteOfHour field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric minuteOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfDay(), minDigits, 4);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric hourOfDay field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric clockhourOfDay field.\n     *\n     * @param minDigits minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfDay(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric hourOfHalfday field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfHalfday(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric clockhourOfHalfday field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {\n        return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric dayOfWeek field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfWeek(), minDigits, 1);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric dayOfMonth field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric dayOfYear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric weekOfWeekyear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric weekyear field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric monthOfYear field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric year field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric year field which always prints\n     * and parses two digits. A pivot year is used during parsing to determine\n     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivot  pivot year to use when parsing\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot) {\n        return appendTwoDigitYear(pivot, false);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric year field which always prints\n     * two digits. A pivot year is used during parsing to determine the range\n     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n     * parse is instructed to be lenient and the digit count is not two, it is\n     * treated as an absolute year. With lenient parsing, specifying a positive\n     * or negative sign before the year also makes it absolute.\n     *\n     * @param pivot  pivot year to use when parsing\n     * @param lenientParse  when true, if digit count is not two, it is treated\n     * as an absolute year\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 1.1\n     */\n    public DateTimeFormatterBuilder appendTwoDigitYear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.year(), pivot, lenientParse));\n    }\n\n    /**\n     * Instructs the printer to emit a numeric weekyear field which always prints\n     * and parses two digits. A pivot year is used during parsing to determine\n     * the range of supported years as <code>(pivot - 50) .. (pivot + 49)</code>.\n     *\n     * <pre>\n     * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n     * ---------------------------------------------------------------\n     * 1950      1900..1999      1900    1920    1940    1960    1980\n     * 1975      1925..2024      2000    2020    1940    1960    1980\n     * 2000      1950..2049      2000    2020    2040    1960    1980\n     * 2025      1975..2074      2000    2020    2040    2060    1980\n     * 2050      2000..2099      2000    2020    2040    2060    2080\n     * </pre>\n     *\n     * @param pivot  pivot weekyear to use when parsing\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot) {\n        return appendTwoDigitWeekyear(pivot, false);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric weekyear field which always prints\n     * two digits. A pivot year is used during parsing to determine the range\n     * of supported years as <code>(pivot - 50) .. (pivot + 49)</code>. If\n     * parse is instructed to be lenient and the digit count is not two, it is\n     * treated as an absolute weekyear. With lenient parsing, specifying a positive\n     * or negative sign before the weekyear also makes it absolute.\n     *\n     * @param pivot  pivot weekyear to use when parsing\n     * @param lenientParse  when true, if digit count is not two, it is treated\n     * as an absolute weekyear\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 1.1\n     */\n    public DateTimeFormatterBuilder appendTwoDigitWeekyear(int pivot, boolean lenientParse) {\n        return append0(new TwoDigitYear(DateTimeFieldType.weekyear(), pivot, lenientParse));\n    }\n\n    /**\n     * Instructs the printer to emit a numeric yearOfEra field.\n     *\n     * @param minDigits  minimum number of digits to <i>print</i>\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric year of century field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {\n        return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a numeric century of era field.\n     *\n     * @param minDigits  minimum number of digits to print\n     * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n     * maximum number of digits to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.centuryOfEra(), minDigits, maxDigits);\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific AM/PM text, and the\n     * parser to expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendHalfdayOfDayText() {\n        return appendText(DateTimeFieldType.halfdayOfDay());\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific dayOfWeek text. The\n     * parser will accept a long or short dayOfWeek text, case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfWeekText() {\n        return appendText(DateTimeFieldType.dayOfWeek());\n    }\n\n    /**\n     * Instructs the printer to emit a short locale-specific dayOfWeek\n     * text. The parser will accept a long or short dayOfWeek text,\n     * case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendDayOfWeekShortText() {\n        return appendShortText(DateTimeFieldType.dayOfWeek());\n    }\n\n    /**\n     * Instructs the printer to emit a short locale-specific monthOfYear\n     * text. The parser will accept a long or short monthOfYear text,\n     * case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMonthOfYearText() { \n        return appendText(DateTimeFieldType.monthOfYear());\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific monthOfYear text. The\n     * parser will accept a long or short monthOfYear text, case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendMonthOfYearShortText() {\n        return appendShortText(DateTimeFieldType.monthOfYear());\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific era text (BC/AD), and\n     * the parser to expect it. The parser is case-insensitive.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendEraText() {\n        return appendText(DateTimeFieldType.era());\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific time zone name.\n     * Using this method prevents parsing, because time zone names are not unique.\n     * See {@link #appendTimeZoneName(Map)}.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneName() {\n        return append0(new TimeZoneName(TimeZoneName.LONG_NAME, null), null);\n    }\n\n    /**\n     * Instructs the printer to emit a locale-specific time zone name, providing a lookup for parsing.\n     * Time zone names are not unique, thus the API forces you to supply the lookup.\n     * The names are searched in the order of the map, thus it is strongly recommended\n     * to use a {@code LinkedHashMap} or similar.\n     *\n     * @param parseLookup  the table of names, not null\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.LONG_NAME, parseLookup);\n        return append0(pp, pp);\n    }\n\n    /**\n     * Instructs the printer to emit a short locale-specific time zone name.\n     * Using this method prevents parsing, because time zone names are not unique.\n     * See {@link #appendTimeZoneShortName(Map)}.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneShortName() {\n        return append0(new TimeZoneName(TimeZoneName.SHORT_NAME, null), null);\n    }\n\n    /**\n     * Instructs the printer to emit a short locale-specific time zone\n     * name, providing a lookup for parsing.\n     * Time zone names are not unique, thus the API forces you to supply the lookup.\n     * The names are searched in the order of the map, thus it is strongly recommended\n     * to use a {@code LinkedHashMap} or similar.\n     *\n     * @param parseLookup  the table of names, not null\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneShortName(Map<String, DateTimeZone> parseLookup) {\n        TimeZoneName pp = new TimeZoneName(TimeZoneName.SHORT_NAME, parseLookup);\n        return append0(pp, pp);\n    }\n\n    /**\n     * Instructs the printer to emit the identifier of the time zone.\n     * From version 2.0, this field can be parsed.\n     *\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneId() {\n        return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n    }\n\n    /**\n     * Instructs the printer to emit text and numbers to display time zone\n     * offset from UTC. A parser will use the parsed time zone offset to adjust\n     * the datetime.\n     * <p>\n     * If zero offset text is supplied, then it will be printed when the zone is zero.\n     * During parsing, either the zero offset text, or the offset will be parsed.\n     *\n     * @param zeroOffsetText  the text to use if time zone offset is zero. If\n     * null, offset is always shown.\n     * @param showSeparators  if true, prints ':' separator before minute and\n     * second field and prints '.' separator before fraction field.\n     * @param minFields  minimum number of fields to print, stopping when no\n     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n     * @param maxFields  maximum number of fields to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     */\n    public DateTimeFormatterBuilder appendTimeZoneOffset(\n            String zeroOffsetText, boolean showSeparators,\n            int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields));\n    }\n\n    /**\n     * Instructs the printer to emit text and numbers to display time zone\n     * offset from UTC. A parser will use the parsed time zone offset to adjust\n     * the datetime.\n     * <p>\n     * If zero offset print text is supplied, then it will be printed when the zone is zero.\n     * If zero offset parse text is supplied, then either it or the offset will be parsed.\n     *\n     * @param zeroOffsetPrintText  the text to print if time zone offset is zero. If\n     * null, offset is always shown.\n     * @param zeroOffsetParseText  the text to optionally parse to indicate that the time\n     * zone offset is zero. If null, then always use the offset.\n     * @param showSeparators  if true, prints ':' separator before minute and\n     * second field and prints '.' separator before fraction field.\n     * @param minFields  minimum number of fields to print, stopping when no\n     * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n     * @param maxFields  maximum number of fields to print\n     * @return this DateTimeFormatterBuilder, for chaining\n     * @since 2.0\n     */\n    public DateTimeFormatterBuilder appendTimeZoneOffset(\n            String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators,\n            int minFields, int maxFields) {\n        return append0(new TimeZoneOffset\n                       (zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calls upon {@link DateTimeFormat} to parse the pattern and append the\n     * results into this builder.\n     *\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     * @see DateTimeFormat\n     */\n    public DateTimeFormatterBuilder appendPattern(String pattern) {\n        DateTimeFormat.appendPatternTo(this, pattern);\n        return this;\n    }\n\n    //-----------------------------------------------------------------------\n    private Object getFormatter() {\n        Object f = iFormatter;\n\n        if (f == null) {\n            if (iElementPairs.size() == 2) {\n                Object printer = iElementPairs.get(0);\n                Object parser = iElementPairs.get(1);\n\n                if (printer != null) {\n                    if (printer == parser || parser == null) {\n                        f = printer;\n                    }\n                } else {\n                    f = parser;\n                }\n            }\n\n            if (f == null) {\n                f = new Composite(iElementPairs);\n            }\n\n            iFormatter = f;\n        }\n\n        return f;\n    }\n\n    private boolean isPrinter(Object f) {\n        if (f instanceof DateTimePrinter) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isPrinter();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isParser(Object f) {\n        if (f instanceof DateTimeParser) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isParser();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isFormatter(Object f) {\n        return (isPrinter(f) || isParser(f));\n    }\n\n    static void appendUnknownString(StringBuffer buf, int len) {\n        for (int i = len; --i >= 0;) {\n            buf.append('\\ufffd');\n        }\n    }\n\n    static void printUnknownString(Writer out, int len) throws IOException {\n        for (int i = len; --i >= 0;) {\n            out.write('\\ufffd');\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class CharacterLiteral\n            implements DateTimePrinter, DateTimeParser {\n\n        private final char iValue;\n\n        CharacterLiteral(char value) {\n            super();\n            iValue = value;\n        }\n\n        public int estimatePrintedLength() {\n            return 1;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public int estimateParsedLength() {\n            return 1;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (position >= text.length()) {\n                return ~position;\n            }\n\n            char a = text.charAt(position);\n            char b = iValue;\n\n            if (a != b) {\n                a = Character.toUpperCase(a);\n                b = Character.toUpperCase(b);\n                if (a != b) {\n                    a = Character.toLowerCase(a);\n                    b = Character.toLowerCase(b);\n                    if (a != b) {\n                        return ~position;\n                    }\n                }\n            }\n\n            return position + 1;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class StringLiteral\n            implements DateTimePrinter, DateTimeParser {\n\n        private final String iValue;\n\n        StringLiteral(String value) {\n            super();\n            iValue = value;\n        }\n\n        public int estimatePrintedLength() {\n            return iValue.length();\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            buf.append(iValue);\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            out.write(iValue);\n        }\n\n        public int estimateParsedLength() {\n            return iValue.length();\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (text.regionMatches(true, position, iValue, 0, iValue.length())) {\n                return position + iValue.length();\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static abstract class NumberFormatter\n            implements DateTimePrinter, DateTimeParser {\n        protected final DateTimeFieldType iFieldType;\n        protected final int iMaxParsedDigits;\n        protected final boolean iSigned;\n\n        NumberFormatter(DateTimeFieldType fieldType,\n                int maxParsedDigits, boolean signed) {\n            super();\n            iFieldType = fieldType;\n            iMaxParsedDigits = maxParsedDigits;\n            iSigned = signed;\n        }\n\n        public int estimateParsedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = Math.min(iMaxParsedDigits, text.length() - position);\n\n            boolean negative = false;\n            int length = 0;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                if (length == 0 && (c == '-' || c == '+') && iSigned) {\n                    negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                length++;\n            }\n\n            if (length == 0) {\n                return ~position;\n            }\n\n            int value;\n            if (length >= 9) {\n                // Since value may exceed integer limits, use stock parser\n                // which checks for this.\n                value = Integer.parseInt(text.substring(position, position += length));\n            } else {\n                int i = position;\n                if (negative) {\n                    i++;\n                }\n                try {\n                    value = text.charAt(i++) - '0';\n                } catch (StringIndexOutOfBoundsException e) {\n                    return ~position;\n                }\n                position += length;\n                while (i < position) {\n                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                }\n                if (negative) {\n                    value = -value;\n                }\n            }\n\n            bucket.saveField(iFieldType, value);\n            return position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class UnpaddedNumber extends NumberFormatter {\n\n        protected UnpaddedNumber(DateTimeFieldType fieldType,\n                       int maxParsedDigits, boolean signed)\n        {\n            super(fieldType, maxParsedDigits, signed);\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.appendUnpaddedInteger(buf, field.get(instant));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.writeUnpaddedInteger(out, field.get(instant));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType));\n                } catch (RuntimeException e) {\n                    buf.append('\\ufffd');\n                }\n            } else {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));\n                } catch (RuntimeException e) {\n                    out.write('\\ufffd');\n                }\n            } else {\n                out.write('\\ufffd');\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class PaddedNumber extends NumberFormatter {\n\n        protected final int iMinPrintedDigits;\n\n        protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\n                     boolean signed, int minPrintedDigits)\n        {\n            super(fieldType, maxParsedDigits, signed);\n            iMinPrintedDigits = minPrintedDigits;\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);\n            } catch (RuntimeException e) {\n                appendUnknownString(buf, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits);\n            } catch (RuntimeException e) {\n                printUnknownString(out, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);\n                } catch (RuntimeException e) {\n                    appendUnknownString(buf, iMinPrintedDigits);\n                }\n            } else {\n                appendUnknownString(buf, iMinPrintedDigits);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            if (partial.isSupported(iFieldType)) {\n                try {\n                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);\n                } catch (RuntimeException e) {\n                    printUnknownString(out, iMinPrintedDigits);\n                }\n            } else {\n                printUnknownString(out, iMinPrintedDigits);\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class FixedNumber extends PaddedNumber {\n\n        protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed) {\n            super(fieldType, numDigits, signed, numDigits);\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int newPos = super.parseInto(bucket, text, position);\n            if (newPos < 0) {\n                return newPos;\n            }\n            int expectedPos = position + iMaxParsedDigits;\n            if (newPos != expectedPos) {\n                if (iSigned) {\n                    char c = text.charAt(position);\n                    if (c == '-' || c == '+') {\n                        expectedPos++;\n                    }\n                }\n                if (newPos > expectedPos) {\n                    // The failure is at the position of the first extra digit.\n                    return ~(expectedPos + 1);\n                } else if (newPos < expectedPos) {\n                    // The failure is at the position where the next digit should be.\n                    return ~newPos;\n                }\n            }\n            return newPos;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class TwoDigitYear\n            implements DateTimePrinter, DateTimeParser {\n\n        /** The field to print/parse. */\n        private final DateTimeFieldType iType;\n        /** The pivot year. */\n        private final int iPivot;\n        private final boolean iLenientParse;\n\n        TwoDigitYear(DateTimeFieldType type, int pivot, boolean lenientParse) {\n            super();\n            iType = type;\n            iPivot = pivot;\n            iLenientParse = lenientParse;\n        }\n\n        public int estimateParsedLength() {\n            return iLenientParse ? 4 : 2;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\n                    if (length == 0 && (c == '-' || c == '+')) {\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }\n        \n        public int estimatePrintedLength() {\n            return 2;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            int year = getTwoDigitYear(instant, chrono);\n            if (year < 0) {\n                buf.append('\\ufffd');\n                buf.append('\\ufffd');\n            } else {\n                FormatUtils.appendPaddedInteger(buf, year, 2);\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            int year = getTwoDigitYear(instant, chrono);\n            if (year < 0) {\n                out.write('\\ufffd');\n                out.write('\\ufffd');\n            } else {\n                FormatUtils.writePaddedInteger(out, year, 2);\n            }\n        }\n\n        private int getTwoDigitYear(long instant, Chronology chrono) {\n            try {\n                int year = iType.getField(chrono).get(instant);\n                if (year < 0) {\n                    year = -year;\n                }\n                return year % 100;\n            } catch (RuntimeException e) {\n                return -1;\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            int year = getTwoDigitYear(partial);\n            if (year < 0) {\n                buf.append('\\ufffd');\n                buf.append('\\ufffd');\n            } else {\n                FormatUtils.appendPaddedInteger(buf, year, 2);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            int year = getTwoDigitYear(partial);\n            if (year < 0) {\n                out.write('\\ufffd');\n                out.write('\\ufffd');\n            } else {\n                FormatUtils.writePaddedInteger(out, year, 2);\n            }\n        }\n\n        private int getTwoDigitYear(ReadablePartial partial) {\n            if (partial.isSupported(iType)) {\n                try {\n                    int year = partial.get(iType);\n                    if (year < 0) {\n                        year = -year;\n                    }\n                    return year % 100;\n                } catch (RuntimeException e) {}\n            } \n            return -1;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class TextField\n            implements DateTimePrinter, DateTimeParser {\n\n        private static Map<Locale, Map<DateTimeFieldType, Object[]>> cParseCache =\n                    new HashMap<Locale, Map<DateTimeFieldType, Object[]>>();\n        private final DateTimeFieldType iFieldType;\n        private final boolean iShort;\n\n        TextField(DateTimeFieldType fieldType, boolean isShort) {\n            super();\n            iFieldType = fieldType;\n            iShort = isShort;\n        }\n\n        public int estimatePrintedLength() {\n            return iShort ? 6 : 20;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                buf.append(print(instant, chrono, locale));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            try {\n                out.write(print(instant, chrono, locale));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            try {\n                buf.append(print(partial, locale));\n            } catch (RuntimeException e) {\n                buf.append('\\ufffd');\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            try {\n                out.write(print(partial, locale));\n            } catch (RuntimeException e) {\n                out.write('\\ufffd');\n            }\n        }\n\n        private String print(long instant, Chronology chrono, Locale locale) {\n            DateTimeField field = iFieldType.getField(chrono);\n            if (iShort) {\n                return field.getAsShortText(instant, locale);\n            } else {\n                return field.getAsText(instant, locale);\n            }\n        }\n\n        private String print(ReadablePartial partial, Locale locale) {\n            if (partial.isSupported(iFieldType)) {\n                DateTimeField field = iFieldType.getField(partial.getChronology());\n                if (iShort) {\n                    return field.getAsShortText(partial, locale);\n                } else {\n                    return field.getAsText(partial, locale);\n                }\n            } else {\n                return \"\\ufffd\";\n            }\n        }\n\n        public int estimateParsedLength() {\n            return estimatePrintedLength();\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            Locale locale = bucket.getLocale();\n            // handle languages which might have non ASCII A-Z or punctuation\n            // bug 1788282\n            Set<String> validValues = null;\n            int maxLength = 0;\n            synchronized (cParseCache) {\n                Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);\n                if (innerMap == null) {\n                    innerMap = new HashMap<DateTimeFieldType, Object[]>();\n                    cParseCache.put(locale, innerMap);\n                }\n                Object[] array = innerMap.get(iFieldType);\n                if (array == null) {\n                    validValues = new HashSet<String>(32);\n                    MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);\n                    Property property = dt.property(iFieldType);\n                    int min = property.getMinimumValueOverall();\n                    int max = property.getMaximumValueOverall();\n                    if (max - min > 32) {  // protect against invalid fields\n                        return ~position;\n                    }\n                    maxLength = property.getMaximumTextLength(locale);\n                    for (int i = min; i <= max; i++) {\n                        property.set(i);\n                        validValues.add(property.getAsShortText(locale));\n                        validValues.add(property.getAsShortText(locale).toLowerCase(locale));\n                        validValues.add(property.getAsShortText(locale).toUpperCase(locale));\n                        validValues.add(property.getAsText(locale));\n                        validValues.add(property.getAsText(locale).toLowerCase(locale));\n                        validValues.add(property.getAsText(locale).toUpperCase(locale));\n                    }\n                    if (\"en\".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {\n                        // hack to support for parsing \"BCE\" and \"CE\" if the language is English\n                        validValues.add(\"BCE\");\n                        validValues.add(\"bce\");\n                        validValues.add(\"CE\");\n                        validValues.add(\"ce\");\n                        maxLength = 3;\n                    }\n                    array = new Object[] {validValues, Integer.valueOf(maxLength)};\n                    innerMap.put(iFieldType, array);\n                } else {\n                    validValues = (Set<String>) array[0];\n                    maxLength = ((Integer) array[1]).intValue();\n                }\n            }\n            // match the longest string first using our knowledge of the max length\n            int limit = Math.min(text.length(), position + maxLength);\n            for (int i = limit; i > position; i--) {\n                String match = text.substring(position, i);\n                if (validValues.contains(match)) {\n                    bucket.saveField(iFieldType, match, locale);\n                    return i;\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class Fraction\n            implements DateTimePrinter, DateTimeParser {\n\n        private final DateTimeFieldType iFieldType;\n        protected int iMinDigits;\n        protected int iMaxDigits;\n\n        protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n            super();\n            iFieldType = fieldType;\n            // Limit the precision requirements.\n            if (maxDigits > 18) {\n                maxDigits = 18;\n            }\n            iMinDigits = minDigits;\n            iMaxDigits = maxDigits;\n        }\n\n        public int estimatePrintedLength() {\n            return iMaxDigits;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                printTo(buf, null, instant, chrono);\n            } catch (IOException e) {\n                // Not gonna happen.\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            printTo(null, out, instant, chrono);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            // removed check whether field is supported, as input field is typically\n            // secondOfDay which is unsupported by TimeOfDay\n            long millis = partial.getChronology().set(partial, 0L);\n            try {\n                printTo(buf, null, millis, partial.getChronology());\n            } catch (IOException e) {\n                // Not gonna happen.\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            // removed check whether field is supported, as input field is typically\n            // secondOfDay which is unsupported by TimeOfDay\n            long millis = partial.getChronology().set(partial, 0L);\n            printTo(null, out, millis, partial.getChronology());\n        }\n\n        protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono)\n            throws IOException\n        {\n            DateTimeField field = iFieldType.getField(chrono);\n            int minDigits = iMinDigits;\n\n            long fraction;\n            try {\n                fraction = field.remainder(instant);\n            } catch (RuntimeException e) {\n                if (buf != null) {\n                    appendUnknownString(buf, minDigits);\n                } else {\n                    printUnknownString(out, minDigits);\n                }\n                return;\n            }\n\n            if (fraction == 0) {\n                if (buf != null) {\n                    while (--minDigits >= 0) {\n                        buf.append('0');\n                    }\n                } else {\n                    while (--minDigits >= 0) {\n                        out.write('0');\n                    }\n                }\n                return;\n            }\n\n            String str;\n            long[] fractionData = getFractionData(fraction, field);\n            long scaled = fractionData[0];\n            int maxDigits = (int) fractionData[1];\n            \n            if ((scaled & 0x7fffffff) == scaled) {\n                str = Integer.toString((int) scaled);\n            } else {\n                str = Long.toString(scaled);\n            }\n\n            int length = str.length();\n            int digits = maxDigits;\n            while (length < digits) {\n                if (buf != null) {\n                    buf.append('0');\n                } else {\n                    out.write('0');\n                }\n                minDigits--;\n                digits--;\n            }\n\n            if (minDigits < digits) {\n                // Chop off as many trailing zero digits as necessary.\n                while (minDigits < digits) {\n                    if (length <= 1 || str.charAt(length - 1) != '0') {\n                        break;\n                    }\n                    digits--;\n                    length--;\n                }\n                if (length < str.length()) {\n                    if (buf != null) {\n                        for (int i=0; i<length; i++) {\n                            buf.append(str.charAt(i));\n                        }\n                    } else {\n                        for (int i=0; i<length; i++) {\n                            out.write(str.charAt(i));\n                        }\n                    }\n                    return;\n                }\n            }\n\n            if (buf != null) {\n                buf.append(str);\n            } else {\n                out.write(str);\n            }\n        }\n        \n        private long[] getFractionData(long fraction, DateTimeField field) {\n            long rangeMillis = field.getDurationField().getUnitMillis();\n            long scalar;\n            int maxDigits = iMaxDigits;\n            while (true) {\n                switch (maxDigits) {\n                default: scalar = 1L; break;\n                case 1:  scalar = 10L; break;\n                case 2:  scalar = 100L; break;\n                case 3:  scalar = 1000L; break;\n                case 4:  scalar = 10000L; break;\n                case 5:  scalar = 100000L; break;\n                case 6:  scalar = 1000000L; break;\n                case 7:  scalar = 10000000L; break;\n                case 8:  scalar = 100000000L; break;\n                case 9:  scalar = 1000000000L; break;\n                case 10: scalar = 10000000000L; break;\n                case 11: scalar = 100000000000L; break;\n                case 12: scalar = 1000000000000L; break;\n                case 13: scalar = 10000000000000L; break;\n                case 14: scalar = 100000000000000L; break;\n                case 15: scalar = 1000000000000000L; break;\n                case 16: scalar = 10000000000000000L; break;\n                case 17: scalar = 100000000000000000L; break;\n                case 18: scalar = 1000000000000000000L; break;\n                }\n                if (((rangeMillis * scalar) / scalar) == rangeMillis) {\n                    break;\n                }\n                // Overflowed: scale down.\n                maxDigits--;\n            }\n            \n            return new long[] {fraction * scalar / rangeMillis, maxDigits};\n        }\n\n        public int estimateParsedLength() {\n            return iMaxDigits;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeField field = iFieldType.getField(bucket.getChronology());\n            \n            int limit = Math.min(iMaxDigits, text.length() - position);\n\n            long value = 0;\n            long n = field.getDurationField().getUnitMillis() * 10;\n            int length = 0;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                length++;\n                long nn = n / 10;\n                value += (c - '0') * nn;\n                n = nn;\n            }\n\n            value /= 10;\n\n            if (length == 0) {\n                return ~position;\n            }\n\n            if (value > Integer.MAX_VALUE) {\n                return ~position;\n            }\n\n            DateTimeField parseField = new PreciseDateTimeField(\n                DateTimeFieldType.millisOfSecond(),\n                MillisDurationField.INSTANCE,\n                field.getDurationField());\n\n            bucket.saveField(parseField, (int) value);\n\n            return position + length;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class TimeZoneOffset\n            implements DateTimePrinter, DateTimeParser {\n\n        private final String iZeroOffsetPrintText;\n        private final String iZeroOffsetParseText;\n        private final boolean iShowSeparators;\n        private final int iMinFields;\n        private final int iMaxFields;\n\n        TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\n                                boolean showSeparators,\n                                int minFields, int maxFields)\n        {\n            super();\n            iZeroOffsetPrintText = zeroOffsetPrintText;\n            iZeroOffsetParseText = zeroOffsetParseText;\n            iShowSeparators = showSeparators;\n            if (minFields <= 0 || maxFields < minFields) {\n                throw new IllegalArgumentException();\n            }\n            if (minFields > 4) {\n                minFields = 4;\n                maxFields = 4;\n            }\n            iMinFields = minFields;\n            iMaxFields = maxFields;\n        }\n            \n        public int estimatePrintedLength() {\n            int est = 1 + iMinFields << 1;\n            if (iShowSeparators) {\n                est += iMinFields - 1;\n            }\n            if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) {\n                est = iZeroOffsetPrintText.length();\n            }\n            return est;\n        }\n        \n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            if (displayZone == null) {\n                return;  // no zone\n            }\n            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n                buf.append(iZeroOffsetPrintText);\n                return;\n            }\n            if (displayOffset >= 0) {\n                buf.append('+');\n            } else {\n                buf.append('-');\n                displayOffset = -displayOffset;\n            }\n\n            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n            FormatUtils.appendPaddedInteger(buf, hours, 2);\n            if (iMaxFields == 1) {\n                return;\n            }\n            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n            if (displayOffset == 0 && iMinFields <= 1) {\n                return;\n            }\n\n            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n            if (iShowSeparators) {\n                buf.append(':');\n            }\n            FormatUtils.appendPaddedInteger(buf, minutes, 2);\n            if (iMaxFields == 2) {\n                return;\n            }\n            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n            if (displayOffset == 0 && iMinFields <= 2) {\n                return;\n            }\n\n            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n            if (iShowSeparators) {\n                buf.append(':');\n            }\n            FormatUtils.appendPaddedInteger(buf, seconds, 2);\n            if (iMaxFields == 3) {\n                return;\n            }\n            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n            if (displayOffset == 0 && iMinFields <= 3) {\n                return;\n            }\n\n            if (iShowSeparators) {\n                buf.append('.');\n            }\n            FormatUtils.appendPaddedInteger(buf, displayOffset, 3);\n        }\n        \n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            if (displayZone == null) {\n                return;  // no zone\n            }\n            if (displayOffset == 0 && iZeroOffsetPrintText != null) {\n                out.write(iZeroOffsetPrintText);\n                return;\n            }\n            if (displayOffset >= 0) {\n                out.write('+');\n            } else {\n                out.write('-');\n                displayOffset = -displayOffset;\n            }\n\n            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\n            FormatUtils.writePaddedInteger(out, hours, 2);\n            if (iMaxFields == 1) {\n                return;\n            }\n            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\n            if (displayOffset == 0 && iMinFields == 1) {\n                return;\n            }\n\n            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\n            if (iShowSeparators) {\n                out.write(':');\n            }\n            FormatUtils.writePaddedInteger(out, minutes, 2);\n            if (iMaxFields == 2) {\n                return;\n            }\n            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n            if (displayOffset == 0 && iMinFields == 2) {\n                return;\n            }\n\n            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\n            if (iShowSeparators) {\n                out.write(':');\n            }\n            FormatUtils.writePaddedInteger(out, seconds, 2);\n            if (iMaxFields == 3) {\n                return;\n            }\n            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n            if (displayOffset == 0 && iMinFields == 3) {\n                return;\n            }\n\n            if (iShowSeparators) {\n                out.write('.');\n            }\n            FormatUtils.writePaddedInteger(out, displayOffset, 3);\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            // no zone info\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            // no zone info\n        }\n\n        public int estimateParsedLength() {\n            return estimatePrintedLength();\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            zeroOffset:\n            if (iZeroOffsetParseText != null) {\n                if (iZeroOffsetParseText.length() == 0) {\n                    // Peek ahead, looking for sign character.\n                    if (limit > 0) {\n                        char c = text.charAt(position);\n                        if (c == '-' || c == '+') {\n                            break zeroOffset;\n                        }\n                    }\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position;\n                }\n                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\n                    bucket.setOffset(Integer.valueOf(0));\n                    return position + iZeroOffsetParseText.length();\n                }\n            }\n\n            // Format to expect is sign character followed by at least one digit.\n\n            if (limit <= 1) {\n                return ~position;\n            }\n\n            boolean negative;\n            char c = text.charAt(position);\n            if (c == '-') {\n                negative = true;\n            } else if (c == '+') {\n                negative = false;\n            } else {\n                return ~position;\n            }\n\n            limit--;\n            position++;\n\n            // Format following sign is one of:\n            //\n            // hh\n            // hhmm\n            // hhmmss\n            // hhmmssSSS\n            // hh:mm\n            // hh:mm:ss\n            // hh:mm:ss.SSS\n\n            // First parse hours.\n\n            if (digitCount(text, position, 2) < 2) {\n                // Need two digits for hour.\n                return ~position;\n            }\n\n            int offset;\n\n            int hours = FormatUtils.parseTwoDigits(text, position);\n            if (hours > 23) {\n                return ~position;\n            }\n            offset = hours * DateTimeConstants.MILLIS_PER_HOUR;\n            limit -= 2;\n            position += 2;\n\n            parse: {\n                // Need to decide now if separators are expected or parsing\n                // stops at hour field.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                boolean expectSeparators;\n                c = text.charAt(position);\n                if (c == ':') {\n                    expectSeparators = true;\n                    limit--;\n                    position++;\n                } else if (c >= '0' && c <= '9') {\n                    expectSeparators = false;\n                } else {\n                    break parse;\n                }\n\n                // Proceed to parse minutes.\n\n                int count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for minute.\n                    return ~position;\n                }\n\n                int minutes = FormatUtils.parseTwoDigits(text, position);\n                if (minutes > 59) {\n                    return ~position;\n                }\n                offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse seconds.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != ':') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n\n                count = digitCount(text, position, 2);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 2) {\n                    // Need two digits for second.\n                    return ~position;\n                }\n\n                int seconds = FormatUtils.parseTwoDigits(text, position);\n                if (seconds > 59) {\n                    return ~position;\n                }\n                offset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\n                limit -= 2;\n                position += 2;\n\n                // Proceed to parse fraction of second.\n\n                if (limit <= 0) {\n                    break parse;\n                }\n\n                if (expectSeparators) {\n                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {\n                        break parse;\n                    }\n                    limit--;\n                    position++;\n                }\n                \n                count = digitCount(text, position, 3);\n                if (count == 0 && !expectSeparators) {\n                    break parse;\n                } else if (count < 1) {\n                    // Need at least one digit for fraction of second.\n                    return ~position;\n                }\n\n                offset += (text.charAt(position++) - '0') * 100;\n                if (count > 1) {\n                    offset += (text.charAt(position++) - '0') * 10;\n                    if (count > 2) {\n                        offset += text.charAt(position++) - '0';\n                    }\n                }\n            }\n\n            bucket.setOffset(Integer.valueOf(negative ? -offset : offset));\n            return position;\n        }\n\n        /**\n         * Returns actual amount of digits to parse, but no more than original\n         * 'amount' parameter.\n         */\n        private int digitCount(String text, int position, int amount) {\n            int limit = Math.min(text.length() - position, amount);\n            amount = 0;\n            for (; limit > 0; limit--) {\n                char c = text.charAt(position + amount);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                amount++;\n            }\n            return amount;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class TimeZoneName\n            implements DateTimePrinter, DateTimeParser {\n\n        static final int LONG_NAME = 0;\n        static final int SHORT_NAME = 1;\n\n        private final Map<String, DateTimeZone> iParseLookup;\n        private final int iType;\n\n        TimeZoneName(int type, Map<String, DateTimeZone> parseLookup) {\n            super();\n            iType = type;\n            iParseLookup = parseLookup;\n        }\n\n        public int estimatePrintedLength() {\n            return (iType == SHORT_NAME ? 4 : 20);\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(print(instant - displayOffset, displayZone, locale));\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(print(instant - displayOffset, displayZone, locale));\n        }\n\n        private String print(long instant, DateTimeZone displayZone, Locale locale) {\n            if (displayZone == null) {\n                return \"\";  // no zone\n            }\n            switch (iType) {\n                case LONG_NAME:\n                    return displayZone.getName(instant, locale);\n                case SHORT_NAME:\n                    return displayZone.getShortName(instant, locale);\n            }\n            return \"\";\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            // no zone info\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            // no zone info\n        }\n\n        public int estimateParsedLength() {\n            return (iType == SHORT_NAME ? 4 : 20);\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            for (String name : iParseLookup.keySet()) {\n                if (str.startsWith(name)) {\n                    bucket.setZone(iParseLookup.get(name));\n                    return position + name.length();\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static enum TimeZoneId\n            implements DateTimePrinter, DateTimeParser {\n\n        INSTANCE;\n        static final Set<String> ALL_IDS = DateTimeZone.getAvailableIDs();\n        static final int MAX_LENGTH;\n        static {\n            int max = 0;\n            for (String id : ALL_IDS) {\n                max = Math.max(max, id.length());\n            }\n            MAX_LENGTH = max;\n        }\n\n        public int estimatePrintedLength() {\n            return MAX_LENGTH;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(displayZone != null ? displayZone.getID() : \"\");\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            out.write(displayZone != null ? displayZone.getID() : \"\");\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            // no zone info\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            // no zone info\n        }\n\n        public int estimateParsedLength() {\n            return MAX_LENGTH;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            for (String id : ALL_IDS) {\n                if (str.startsWith(id)) {\n                    bucket.setZone(DateTimeZone.forID(id));\n                    return position + id.length();\n                }\n            }\n            return ~position;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class Composite\n            implements DateTimePrinter, DateTimeParser {\n\n        private final DateTimePrinter[] iPrinters;\n        private final DateTimeParser[] iParsers;\n\n        private final int iPrintedLengthEstimate;\n        private final int iParsedLengthEstimate;\n\n        Composite(List<Object> elementPairs) {\n            super();\n\n            List<Object> printerList = new ArrayList<Object>();\n            List<Object> parserList = new ArrayList<Object>();\n\n            decompose(elementPairs, printerList, parserList);\n\n            if (printerList.size() <= 0) {\n                iPrinters = null;\n                iPrintedLengthEstimate = 0;\n            } else {\n                int size = printerList.size();\n                iPrinters = new DateTimePrinter[size];\n                int printEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimePrinter printer = (DateTimePrinter) printerList.get(i);\n                    printEst += printer.estimatePrintedLength();\n                    iPrinters[i] = printer;\n                }\n                iPrintedLengthEstimate = printEst;\n            }\n\n            if (parserList.size() <= 0) {\n                iParsers = null;\n                iParsedLengthEstimate = 0;\n            } else {\n                int size = parserList.size();\n                iParsers = new DateTimeParser[size];\n                int parseEst = 0;\n                for (int i=0; i<size; i++) {\n                    DateTimeParser parser = (DateTimeParser) parserList.get(i);\n                    parseEst += parser.estimateParsedLength();\n                    iParsers[i] = parser;\n                }\n                iParsedLengthEstimate = parseEst;\n            }\n        }\n\n        public int estimatePrintedLength() {\n            return iPrintedLengthEstimate;\n        }\n\n        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i = 0; i < len; i++) {\n                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n            }\n        }\n\n        public void printTo(\n                Writer out, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i = 0; i < len; i++) {\n                elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale);\n            }\n        }\n\n        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len; i++) {\n                elements[i].printTo(buf, partial, locale);\n            }\n        }\n\n        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len; i++) {\n                elements[i].printTo(out, partial, locale);\n            }\n        }\n\n        public int estimateParsedLength() {\n            return iParsedLengthEstimate;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeParser[] elements = iParsers;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = elements[i].parseInto(bucket, text, position);\n            }\n            return position;\n        }\n\n        boolean isPrinter() {\n            return iPrinters != null;\n        }\n\n        boolean isParser() {\n            return iParsers != null;\n        }\n\n        /**\n         * Processes the element pairs, putting results into the given printer\n         * and parser lists.\n         */\n        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof DateTimePrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite)element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof DateTimeParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite)element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }\n\n        private void addArrayToList(List<Object> list, Object[] array) {\n            if (array != null) {\n                for (int i=0; i<array.length; i++) {\n                    list.add(array[i]);\n                }\n            }\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    static class MatchingParser\n            implements DateTimeParser {\n\n        private final DateTimeParser[] iParsers;\n        private final int iParsedLengthEstimate;\n\n        MatchingParser(DateTimeParser[] parsers) {\n            super();\n            iParsers = parsers;\n            int est = 0;\n            for (int i=parsers.length; --i>=0 ;) {\n                DateTimeParser parser = parsers[i];\n                if (parser != null) {\n                    int len = parser.estimateParsedLength();\n                    if (len > est) {\n                        est = len;\n                    }\n                }\n            }\n            iParsedLengthEstimate = est;\n        }\n\n        public int estimateParsedLength() {\n            return iParsedLengthEstimate;\n        }\n\n        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeParser[] parsers = iParsers;\n            int length = parsers.length;\n\n            final Object originalState = bucket.saveState();\n            boolean isOptional = false;\n\n            int bestValidPos = position;\n            Object bestValidState = null;\n\n            int bestInvalidPos = position;\n\n            for (int i=0; i<length; i++) {\n                DateTimeParser parser = parsers[i];\n                if (parser == null) {\n                    // The empty parser wins only if nothing is better.\n                    if (bestValidPos <= position) {\n                        return position;\n                    }\n                    isOptional = true;\n                    break;\n                }\n                int parsePos = parser.parseInto(bucket, text, position);\n                if (parsePos >= position) {\n                    if (parsePos > bestValidPos) {\n                        if (parsePos >= text.length() ||\n                            (i + 1) >= length || parsers[i + 1] == null) {\n\n                            // Completely parsed text or no more parsers to\n                            // check. Skip the rest.\n                            return parsePos;\n                        }\n                        bestValidPos = parsePos;\n                        bestValidState = bucket.saveState();\n                    }\n                } else {\n                    if (parsePos < 0) {\n                        parsePos = ~parsePos;\n                        if (parsePos > bestInvalidPos) {\n                            bestInvalidPos = parsePos;\n                        }\n                    }\n                }\n                bucket.restoreState(originalState);\n            }\n\n            if (bestValidPos > position || (bestValidPos == position && isOptional)) {\n                // Restore the state to the best valid parse.\n                if (bestValidState != null) {\n                    bucket.restoreState(bestValidState);\n                }\n                return bestValidPos;\n            }\n\n            return ~bestInvalidPos;\n        }\n    }\n\n}\n", "review": {"response": "{ \"bugs\": [\n\n  {\n    \"description\": \"The license header is missing the year 2011 in the copyright statement.\",\n    \"line\": 1\n  },\n\n  {\n    \"description\": \"The Javadoc comment for the class does not mention the author Brian S O'Neill, although he is listed in the class header.\",\n    \"line\": 38\n  },\n\n  {\n    \"description\": \"The method toFormatter() does not check if both printing and parsing are supported before creating the DateTimeFormatter. It should throw an UnsupportedOperationException if neither is supported.\",\n    \"line\": 56\n  },\n\n  {\n    \"description\": \"The methods toPrinter() and toParser() should check if the formatter supports printing or parsing respectively, before creating the DateTimePrinter or DateTimeParser. They currently do not check and may throw an UnsupportedOperationException unnecessarily.\",\n    \"line\": 74,  \"fmt\": \"toPrinter()\", \"line\": 88\n  },\n\n  {\n    \"description\": \"The method canBuildFormatter() only checks if a formatter can be built, but it does not check if both printing and parsing are supported. It should return false if neither is supported.\",\n    \"line\": 102\n  },\n\n  {\n    \"description\": \"The method isFormatter() is not documented in the Javadoc. It should be documented to explain what it does and how it is used.\",\n    \"line\": 115\n  },\n\n  {\n    \"description\": \"The method isPrinter() and isParser() are not documented in the Javadoc. They should be documented to explain what they do and how they are used.\",\n    \"line\": 120,  \"fmt\": \"isPrinter()\", \"line\": 125\n  },\n\n  {\n    \"description\": \"The method getFormatter() is not documented in the Javadoc. It should be documented to explain what it does and how it is used.\",\n    \"line\": 130\n  },\n\n  {\n    \"description\": \"The method isFormatter() is not a standard Java naming convention. It should be renamed to something more descriptive, such as isFormatterSupported() or hasFormatter()\",\n    \"line\": 115\n  },\n\n  {\n    \"description\": \"The method getFormatter() is not a standard Java naming convention. It should be renamed to something more descriptive, such as getFormatterInstance() or getFormatterObject()\",\n    \"line\": 130\n  },\n\n  {\n    \"description\": \"The method toFormatter() does not handle the case where both printing and parsing are supported, but the formatter is null. It should create a new formatter in this case.\",\n    \"line\": 56\n  },\n\n  {\n    \"description\": \"The method toPrinter() does not handle the case where printing is supported, but the formatter is null. It should create a new printer in this case.\",\n    \"line\": 74\n  },\n\n  {\n    \"description\": \"The method toParser() does not handle the case where parsing is supported, but the formatter is null. It should create a new parser in this case.\",\n    \"line\": 88\n  }\n\n]}"}}