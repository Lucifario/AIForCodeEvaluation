{
  "source_item_id": 8042,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:49:13.556807",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.io;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkPositionIndexes;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.math.IntMath.divide;\nimport static com.google.common.math.IntMath.log2;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.math.RoundingMode.CEILING;\nimport static java.math.RoundingMode.FLOOR;\nimport static java.math.RoundingMode.UNNECESSARY;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.J2ktIncompatible;\nimport com.google.common.base.Ascii;\nimport com.google.errorprone.annotations.concurrent.LazyInit;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.Arrays;\nimport java.util.Objects;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * A binary encoding scheme for reversibly translating between byte sequences and printable ASCII\n * strings. This class includes several constants for encoding schemes specified by <a\n * href=\"http://tools.ietf.org/html/rfc4648\">RFC 4648</a>. For example, the expression:\n *\n * {@snippet :\n * BaseEncoding.base32().encode(\"foo\".getBytes(US_ASCII))\n * }\n *\n * <p>returns the string {@code \"MZXW6===\"}, and\n *\n * {@snippet :\n * byte[] decoded = BaseEncoding.base32().decode(\"MZXW6===\");\n * }\n *\n * <p>...returns the ASCII bytes of the string {@code \"foo\"}.\n *\n * <p>By default, {@code BaseEncoding}'s behavior is relatively strict and in accordance with RFC\n * 4648. Decoding rejects characters in the wrong case, though padding is optional. To modify\n * encoding and decoding behavior, use configuration methods to obtain a new encoding with modified\n * behavior:\n *\n * {@snippet :\n * BaseEncoding.base16().lowerCase().decode(\"deadbeef\");\n * }\n *\n * <p>Warning: BaseEncoding instances are immutable. Invoking a configuration method has no effect\n * on the receiving instance; you must store and use the new encoding instance it returns, instead.\n *\n * {@snippet :\n * // Do NOT do this\n * BaseEncoding hex = BaseEncoding.base16();\n * hex.lowerCase(); // does nothing!\n * return hex.decode(\"deadbeef\"); // throws an IllegalArgumentException\n * }\n *\n * <p>It is guaranteed that {@code encoding.decode(encoding.encode(x))} is always equal to {@code\n * x}, but the reverse does not necessarily hold.\n *\n * <table>\n * <caption>Encodings</caption>\n * <tr>\n * <th>Encoding\n * <th>Alphabet\n * <th>{@code char:byte} ratio\n * <th>Default padding\n * <th>Comments\n * <tr>\n * <td>{@link #base16()}\n * <td>0-9 A-F\n * <td>2.00\n * <td>N/A\n * <td>Traditional hexadecimal. Defaults to upper case.\n * <tr>\n * <td>{@link #base32()}\n * <td>A-Z 2-7\n * <td>1.60\n * <td>=\n * <td>Human-readable; no possibility of mixing up 0/O or 1/I. Defaults to upper case.\n * <tr>\n * <td>{@link #base32Hex()}\n * <td>0-9 A-V\n * <td>1.60\n * <td>=\n * <td>\"Numerical\" base 32; extended from the traditional hex alphabet. Defaults to upper case.\n * <tr>\n * <td>{@link #base64()}\n * <td>A-Z a-z 0-9 + /\n * <td>1.33\n * <td>=\n * <td>\n * <tr>\n * <td>{@link #base64Url()}\n * <td>A-Z a-z 0-9 - _\n * <td>1.33\n * <td>=\n * <td>Safe to use as filenames, or to pass in URLs without escaping\n * </table>\n *\n * <p>All instances of this class are immutable, so they may be stored safely as static constants.\n *\n * @author Louis Wasserman\n * @since 14.0\n */\n@GwtCompatible\npublic abstract class BaseEncoding {\n  // TODO(lowasser): consider making encodeTo(Appendable, byte[], int, int) public.\n\n  BaseEncoding() {}\n\n  /**\n   * Exception indicating invalid base-encoded input encountered while decoding.\n   *\n   * @author Louis Wasserman\n   * @since 15.0\n   */\n  public static final class DecodingException extends IOException {\n    DecodingException(@Nullable String message) {\n      super(message);\n    }\n  }\n\n  /** Encodes the specified byte array, and returns the encoded {@code String}. */\n  public String encode(byte[] bytes) {\n    return encode(bytes, 0, bytes.length);\n  }\n\n  /**\n   * Encodes the specified range of the specified byte array, and returns the encoded {@code\n   * String}.\n   */\n  public final String encode(byte[] bytes, int off, int len) {\n    checkPositionIndexes(off, off + len, bytes.length);\n    StringBuilder result = new StringBuilder(maxEncodedSize(len));\n    try {\n      encodeTo(result, bytes, off, len);\n    } catch (IOException impossible) {\n      throw new AssertionError(impossible);\n    }\n    return result.toString();\n  }\n\n  /**\n   * Returns an {@code OutputStream} that encodes bytes using this encoding into the specified\n   * {@code Writer}. When the returned {@code OutputStream} is closed, so is the backing {@code\n   * Writer}.\n   */\n  @J2ktIncompatible\n  @GwtIncompatible // Writer,OutputStream\n  public abstract OutputStream encodingStream(Writer writer);\n\n  /**\n   * Returns a {@code ByteSink} that writes base-encoded bytes to the specified {@code CharSink}.\n   */\n  @J2ktIncompatible\n  @GwtIncompatible // ByteSink,CharSink\n  public final ByteSink encodingSink(CharSink encodedSink) {\n    checkNotNull(encodedSink);\n    return new ByteSink() {\n      @Override\n      public OutputStream openStream() throws IOException {\n        return encodingStream(encodedSink.openStream());\n      }\n    };\n  }\n\n  // TODO(lowasser): document the extent of leniency, probably after adding ignore(CharMatcher)\n\n  private static byte[] extract(byte[] result, int length) {\n    if (length == result.length) {\n      return result;\n    }\n    byte[] trunc = new byte[length];\n    System.arraycopy(result, 0, trunc, 0, length);\n    return trunc;\n  }\n\n  /**\n   * Determines whether the specified character sequence is a valid encoded string according to this\n   * encoding.\n   *\n   * @since 20.0\n   */\n  public abstract boolean canDecode(CharSequence chars);\n\n  /**\n   * Decodes the specified character sequence, and returns the resulting {@code byte[]}. This is the\n   * inverse operation to {@link #encode(byte[])}.\n   *\n   * @throws IllegalArgumentException if the input is not a valid encoded string according to this\n   *     encoding.\n   */\n  public final byte[] decode(CharSequence chars) {\n    try {\n      return decodeChecked(chars);\n    } catch (DecodingException badInput) {\n      throw new IllegalArgumentException(badInput);\n    }\n  }\n\n  /**\n   * Decodes the specified character sequence, and returns the resulting {@code byte[]}. This is the\n   * inverse operation to {@link #encode(byte[])}.\n   *\n   * @throws DecodingException if the input is not a valid encoded string according to this\n   *     encoding.\n   */\n  final byte[] decodeChecked(CharSequence chars)\n      throws DecodingException {\n    chars = trimTrailingPadding(chars);\n    byte[] tmp = new byte[maxDecodedSize(chars.length())];\n    int len = decodeTo(tmp, chars);\n    return extract(tmp, len);\n  }\n\n  /**\n   * Returns an {@code InputStream} that decodes base-encoded input from the specified {@code\n   * Reader}. The returned stream throws a {@link DecodingException} upon decoding-specific errors.\n   */\n  @J2ktIncompatible\n  @GwtIncompatible // Reader,InputStream\n  public abstract InputStream decodingStream(Reader reader);\n\n  /**\n   * Returns a {@code ",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The method maxEncodedSize(int) is not implemented in the BaseEncoding class, which may cause a NullPointerException when used.\",\n         \"suggested_fix\": \"public int maxEncodedSize(int len) { return (int) Math.ceil((double) len * getCharBytes()); }\"\n      },\n      {\n         \"explanation\": \"The method maxDecodedSize(int) is not implemented in the BaseEncoding class, which may cause a NullPointerException when used.\",\n         \"suggested_fix\": \"public int maxDecodedSize(int len) { return (int) Math.ceil((double) len / getCharBytes()); }\"\n      },\n      {\n         \"explanation\": \"The method getCharBytes() is not implemented in the BaseEncoding class, which may cause a NullPointerException when used.\",\n         \"suggested_fix\": \"public abstract int getCharBytes();\"\n      },\n      {\n         \"explanation\": \"The method trimTrailingPadding(CharSequence) is not implemented in the BaseEncoding class, which may cause a NullPointerException when used.\",\n         \"suggested_fix\": \"public abstract CharSequence trimTrailingPadding(CharSequence chars);\"\n      },\n      {\n         \"explanation\": \"The method decodeTo(byte[], CharSequence) is not implemented in the BaseEncoding class, which may cause a NullPointerException when used.\",\n         \"suggested_fix\": \"public abstract int decodeTo(byte[] tmp, CharSequence chars);\"\n      },\n      {\n         \"explanation\": \"The method encodingStream(Writer) and decodingStream(Reader) are not implemented in the BaseEncoding class, which may cause a NullPointerException when used.\",\n         \"suggested_fix\": \"public abstract OutputStream encodingStream(Writer writer); public abstract InputStream decodingStream(Reader reader);\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs found, but the code has some potential issues that should be addressed.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The method maxEncodedSize(int) is not implemented in the BaseEncoding class, which may cause a NullPointerException when used.",
        "suggested_fix": "public int maxEncodedSize(int len) { return (int) Math.ceil((double) len * getCharBytes()); }"
      },
      {
        "explanation": "The method maxDecodedSize(int) is not implemented in the BaseEncoding class, which may cause a NullPointerException when used.",
        "suggested_fix": "public int maxDecodedSize(int len) { return (int) Math.ceil((double) len / getCharBytes()); }"
      },
      {
        "explanation": "The method getCharBytes() is not implemented in the BaseEncoding class, which may cause a NullPointerException when used.",
        "suggested_fix": "public abstract int getCharBytes();"
      },
      {
        "explanation": "The method trimTrailingPadding(CharSequence) is not implemented in the BaseEncoding class, which may cause a NullPointerException when used.",
        "suggested_fix": "public abstract CharSequence trimTrailingPadding(CharSequence chars);"
      },
      {
        "explanation": "The method decodeTo(byte[], CharSequence) is not implemented in the BaseEncoding class, which may cause a NullPointerException when used.",
        "suggested_fix": "public abstract int decodeTo(byte[] tmp, CharSequence chars);"
      },
      {
        "explanation": "The method encodingStream(Writer) and decodingStream(Reader) are not implemented in the BaseEncoding class, which may cause a NullPointerException when used.",
        "suggested_fix": "public abstract OutputStream encodingStream(Writer writer); public abstract InputStream decodingStream(Reader reader);"
      }
    ],
    "no_bugs_reasoning": "No bugs found, but the code has some potential issues that should be addressed."
  },
  "error": null
}