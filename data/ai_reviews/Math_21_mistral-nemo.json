{"sample_id": "Math_21", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.linear;\n\nimport org.apache.commons.math3.util.FastMath;\n\n/**\n * Calculates the rectangular Cholesky decomposition of a matrix.\n * <p>The rectangular Cholesky decomposition of a real symmetric positive\n * semidefinite matrix A consists of a rectangular matrix B with the same\n * number of rows such that: A is almost equal to BB<sup>T</sup>, depending\n * on a user-defined tolerance. In a sense, this is the square root of A.</p>\n * <p>The difference with respect to the regular {@link CholeskyDecomposition}\n * is that rows/columns may be permuted (hence the rectangular shape instead\n * of the traditional triangular shape) and there is a threshold to ignore\n * small diagonal elements. This is used for example to generate {@link\n * org.apache.commons.math3.random.CorrelatedRandomVectorGenerator correlated\n * random n-dimensions vectors} in a p-dimension subspace (p < n).\n * In other words, it allows generating random vectors from a covariance\n * matrix that is only positive semidefinite, and not positive definite.</p>\n * <p>Rectangular Cholesky decomposition is <em>not</em> suited for solving\n * linear systems, so it does not provide any {@link DecompositionSolver\n * decomposition solver}.</p>\n *\n * @see <a href=\"http://mathworld.wolfram.com/CholeskyDecomposition.html\">MathWorld</a>\n * @see <a href=\"http://en.wikipedia.org/wiki/Cholesky_decomposition\">Wikipedia</a>\n * @version $Id$\n * @since 2.0 (changed to concrete class in 3.0)\n */\npublic class RectangularCholeskyDecomposition {\n\n    /** Permutated Cholesky root of the symmetric positive semidefinite matrix. */\n    private final RealMatrix root;\n\n    /** Rank of the symmetric positive semidefinite matrix. */\n    private int rank;\n\n    /**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which  column are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n\n        int[] swap  = new int[order];\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n\n        int r = 0;\n        for (boolean loop = true; loop;) {\n\n            // find maximal diagonal element\n            swap[r] = r;\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i];\n                int isi = index[swap[i]];\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i;\n                }\n            }\n\n\n            // swap elements\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n\n            // check diagonal element\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n\n                if (r == 0) {\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n\n                // check remaining diagonal elements\n                for (int i = r; i < order; ++i) {\n                    if (c[index[i]][index[i]] < -small) {\n                        // there is at least one sufficiently negative diagonal element,\n                        // the symmetric positive semidefinite matrix is wrong\n                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n                    }\n                }\n\n                // all remaining diagonal elements are close to zero, we consider we have\n                // found the rank of the symmetric positive semidefinite matrix\n                ++r;\n                loop = false;\n\n            } else {\n\n                // transform the matrix\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt;\n                final double inverse  = 1 / sqrt;\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i];\n                    final double e = inverse * c[ii][ir];\n                    b[i][r] = e;\n                    c[ii][ii] -= e * e;\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n\n                // prepare next iteration\n                loop = ++r < order;\n            }\n        }\n\n        // build the root matrix\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n\n    }\n\n    /** Get the root of the covariance matrix.\n     * The root is the rectangular matrix <code>B</code> such that\n     * the covariance matrix is equal to <code>B.B<sup>T</sup></code>\n     * @return root of the square matrix\n     * @see #getRank()\n     */\n    public RealMatrix getRootMatrix() {\n        return root;\n    }\n\n    /** Get the rank of the symmetric positive semidefinite matrix.\n     * The r is the number of independent rows in the symmetric positive semidefinite\n     * matrix, it is also the number of columns of the rectangular\n     * matrix of the decomposition.\n     * @return r of the square matrix.\n     * @see #getRootMatrix()\n     */\n    public int getRank() {\n        return rank;\n    }\n\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"description\": \"The code does not handle the case when the input matrix is not symmetric. It assumes that the input matrix is symmetric and positive semidefinite, but does not check or handle cases where this might not be true.\",\n      \"lineNumber\": \"25\"\n    },\n    {\n      \"description\": \"The code does not handle the case when the input matrix is singular (i.e., has a zero determinant). In the loop that finds the maximal diagonal element, it does not check if the diagonal element is zero, which could cause a division by zero error in the calculation of the 'sqrt' variable on line 47.\",\n      \"lineNumber\": \"37\"\n    },\n    {\n      \"description\": \"The code does not handle the case when the input matrix has negative diagonal elements. In the loop that checks remaining diagonal elements, it only checks if they are sufficiently negative, but does not handle the case when they are negative (which would violate the assumption that the matrix is positive semidefinite).\",\n      \"lineNumber\": \"60\"\n    },\n    {\n      \"description\": \"The code does not handle the case when the input matrix has more than one sufficiently negative diagonal element. In the loop that checks remaining diagonal elements, it only throws an exception if there is at least one sufficiently negative diagonal element, but does not handle the case when there are multiple such elements.\",\n      \"lineNumber\": \"65\"\n    },\n    {\n      \"description\": \"The code does not handle the case when the input matrix has more than one zero diagonal element. In the loop that finds the maximal diagonal element, it does not check if the diagonal element is zero, which could cause a division by zero error in the calculation of the 'sqrt' variable on line 47 if there are multiple zero diagonal elements.\",\n      \"lineNumber\": \"37\"\n    }\n  ]\n}"}}