{"sample_id": "Closure_14", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.ArrayDeque;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\n/**\n * This is a compiler pass that computes a control flow graph.\n *\n */\nfinal class ControlFlowAnalysis implements Callback, CompilerPass {\n\n  /**\n   * Based roughly on the first few pages of\n   *\n   * \"Declarative Intraprocedural Flow Analysis of Java Source Code by\n   * Nilsson-Nyman, Hedin, Magnusson & Ekman\",\n   *\n   * this pass computes the control flow graph from the AST. However, a full\n   * attribute grammar is not necessary. We will compute the flow edges with a\n   * single post order traversal. The \"follow()\" of a given node will be\n   * computed recursively in a demand driven fashion.\n   *\n   * As of this moment, we are not performing any inter-procedural analysis\n   * within our framework.\n   */\n\n  private final AbstractCompiler compiler;\n\n  private ControlFlowGraph<Node> cfg;\n\n  private Map<Node, Integer> astPosition;\n\n  // TODO(nicksantos): should these be node annotations?\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n\n  // We order CFG nodes by by looking at the AST positions.\n  // CFG nodes that come first lexically should be visited first, because\n  // they will often be executed first in the source program.\n  private final Comparator<DiGraphNode<Node, Branch>> priorityComparator =\n      new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  };\n\n  private int astPositionCounter;\n  private int priorityCounter;\n\n  private final boolean shouldTraverseFunctions;\n  private final boolean edgeAnnotations;\n\n  // We need to store where we started, in case we aren't doing a flow analysis\n  // for the whole scope. This happens, for example, when running type inference\n  // on only the externs.\n  private Node root;\n\n  /*\n   * This stack captures the structure of nested TRY blocks. The top of the\n   * stack is the inner most TRY block. A FUNCTION node in this stack implies\n   * that the handler is determined by the caller of the function at runtime.\n   */\n  private final Deque<Node> exceptionHandler = new ArrayDeque<Node>();\n\n  /*\n   * This map is used to handle the follow of FINALLY. For example:\n   *\n   * while(x) {\n   *  try {\n   *    try {\n   *      break;\n   *    } catch (a) {\n   *    } finally {\n   *      foo();\n   *    }\n   *    fooFollow();\n   *  } catch (b) {\n   *  } finally {\n   *    bar();\n   *  }\n   *  barFollow();\n   * }\n   * END();\n   *\n   * In this case finallyMap will contain a map from:\n   *    first FINALLY -> bar()\n   *    second FINALLY -> END()\n   *\n   * When we are connecting foo() and bar() to to their respective follow, we\n   * must also look up this map and connect:\n   *   foo() -> bar()\n   *   bar() -> END\n   */\n  private final Multimap<Node, Node> finallyMap = HashMultimap.create();\n\n  /**\n   * Constructor.\n   *\n   * @param compiler Compiler instance.\n   * @param shouldTraverseFunctions Whether functions should be traversed (true\n   *    by default).\n   * @param edgeAnnotations Whether to allow edge annotations. By default,\n   *    only node annotations are allowed.\n   */\n  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions, boolean edgeAnnotations) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n    this.edgeAnnotations = edgeAnnotations;\n  }\n\n  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n                                  edgeAnnotations);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.isFunction()) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }\n\n  /**\n   * Given an entry node, find all the nodes reachable from that node\n   * and prioritize them.\n   */\n  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }\n\n  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT_CASE:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }\n\n  private void handleIf(Node node) {\n    Node thenBlock = node.getFirstChild().getNext();\n    Node elseBlock = thenBlock.getNext();\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock));\n\n    if (elseBlock == null) {\n      createEdge(node, Branch.ON_FALSE,\n          computeFollowNode(node, this)); // not taken branch\n    } else {\n      createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n    }\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleWhile(Node node) {\n    // Control goes to the first statement if the condition evaluates to true.\n    createEdge(node, Branch.ON_TRUE,\n        computeFallThrough(node.getFirstChild().getNext()));\n\n    // Control goes to the follow() if the condition evaluates to false.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleDo(Node node) {\n    // The first edge can be the initial iteration as well as the iterations\n    // after.\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild()));\n    // The edge that leaves the do loop if the condition fails.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleFor(Node forNode) {\n    if (forNode.getChildCount() == 4) {\n      // We have for (init; cond; iter) { body }\n      Node init = forNode.getFirstChild();\n      Node cond = init.getNext();\n      Node iter = cond.getNext();\n      Node body = iter.getNext();\n      // After initialization, we transfer to the FOR which is in charge of\n      // checking the condition (for the first time).\n      createEdge(init, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      // The end of the body will have a unconditional branch to our iter\n      // (handled by calling computeFollowNode of the last instruction of the\n      // body. Our iter will jump to the forNode again to another condition\n      // check.\n      createEdge(iter, Branch.UNCOND, forNode);\n      connectToPossibleExceptionHandler(init, init);\n      connectToPossibleExceptionHandler(forNode, cond);\n      connectToPossibleExceptionHandler(iter, iter);\n    } else {\n      // We have for (item in collection) { body }\n      Node item = forNode.getFirstChild();\n      Node collection = item.getNext();\n      Node body = collection.getNext();\n      // The collection behaves like init.\n      createEdge(collection, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      connectToPossibleExceptionHandler(forNode, collection);\n    }\n  }\n\n  private void handleSwitch(Node node) {\n    // Transfer to the first non-DEFAULT CASE. if there are none, transfer\n    // to the DEFAULT or the EMPTY node.\n    Node next = getNextSiblingOfType(\n        node.getFirstChild().getNext(), Token.CASE, Token.EMPTY);\n    if (next != null) { // Has at least one CASE or EMPTY\n      createEdge(node, Branch.UNCOND, next);\n    } else { // Has no CASE but possibly a DEFAULT\n      if (node.getFirstChild().getNext() != null) {\n        createEdge(node, Branch.UNCOND, node.getFirstChild().getNext());\n      } else { // No CASE, no DEFAULT\n        createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleCase(Node node) {\n    // Case is a bit tricky....First it goes into the body if condition is true.\n    createEdge(node, Branch.ON_TRUE,\n        node.getFirstChild().getNext());\n    // Look for the next CASE, skipping over DEFAULT.\n    Node next = getNextSiblingOfType(node.getNext(), Token.CASE);\n    if (next != null) { // Found a CASE\n      Preconditions.checkState(next.isCase());\n      createEdge(node, Branch.ON_FALSE, next);\n    } else { // No more CASE found, go back and search for a DEFAULT.\n      Node parent = node.getParent();\n      Node deflt = getNextSiblingOfType(\n        parent.getFirstChild().getNext(), Token.DEFAULT_CASE);\n      if (deflt != null) { // Has a DEFAULT\n        createEdge(node, Branch.ON_FALSE, deflt);\n      } else { // No DEFAULT found, go to the follow of the SWITCH.\n        createEdge(node, Branch.ON_FALSE, computeFollowNode(node, this));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleDefault(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleWith(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.isBlock() && parent != null &&\n        parent.isTry() &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.isFunction()) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT_CASE:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.isBlock() && node.isSyntheticBlock()) {\n            createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));\n          }\n          break;\n      }\n    }\n  }\n\n  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }\n\n  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleThrow(Node node) {\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleTry(Node node) {\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleCatch(Node node) {\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n  }\n\n  private void handleBreak(Node node) {\n    String label = null;\n    // See if it is a break with label.\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node previous = null;\n    Node lastJump;\n    Node parent = node.getParent();\n    /*\n     * Continuously look up the ancestor tree for the BREAK target or the target\n     * with the corresponding label and connect to it. If along the path we\n     * discover a FINALLY, we will connect the BREAK to that FINALLY. From then\n     * on, we will just record the control flow changes in the finallyMap. This\n     * is due to the fact that we need to connect any node that leaves its own\n     * FINALLY block to the outer FINALLY or the BREAK's target but those nodes\n     * are not known yet due to the way we traverse the nodes.\n     */\n    for (cur = node, lastJump = node;\n        !isBreakTarget(cur, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.isTry() && NodeUtil.hasFinally(cur)\n          && cur.getLastChild() != previous) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, computeFallThrough(\n              cur.getLastChild()));\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      if (parent == null) {\n        if (compiler.isIdeMode()) {\n          // In IDE mode, we expect that the data flow graph may\n          // not be well-formed.\n          return;\n        } else {\n          throw new IllegalStateException(\"Cannot find break target.\");\n        }\n      }\n      previous = cur;\n    }\n    if (lastJump == node) {\n      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur, this));\n    } else {\n      finallyMap.put(lastJump, computeFollowNode(cur, this));\n    }\n  }\n\n  private void handleContinue(Node node) {\n    String label = null;\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node previous = null;\n    Node lastJump;\n\n    // Similar to handBreak's logic with a few minor variation.\n    Node parent = node.getParent();\n    for (cur = node, lastJump = node;\n        !isContinueTarget(cur, parent, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.isTry() && NodeUtil.hasFinally(cur)\n          && cur.getLastChild() != previous) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, cur.getLastChild());\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      Preconditions.checkState(parent != null, \"Cannot find continue target.\");\n      previous = cur;\n    }\n    Node iter = cur;\n    if (cur.getChildCount() == 4) {\n      iter = cur.getFirstChild().getNext().getNext();\n    }\n\n    if (lastJump == node) {\n      createEdge(node, Branch.UNCOND, iter);\n    } else {\n      finallyMap.put(lastJump, iter);\n    }\n  }\n\n  private void handleReturn(Node node) {\n    Node lastJump = null;\n    for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n      Node curHandler = iter.next();\n      if (curHandler.isFunction()) {\n        break;\n      }\n      if (NodeUtil.hasFinally(curHandler)) {\n        if (lastJump == null) {\n          createEdge(node, Branch.UNCOND, curHandler.getLastChild());\n        } else {\n          finallyMap.put(lastJump,\n              computeFallThrough(curHandler.getLastChild()));\n        }\n        lastJump = curHandler;\n      }\n    }\n\n    if (node.hasChildren()) {\n      connectToPossibleExceptionHandler(node, node.getFirstChild());\n    }\n\n    if (lastJump == null) {\n      createEdge(node, Branch.UNCOND, null);\n    } else {\n      finallyMap.put(lastJump, null);\n    }\n  }\n\n  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n    return computeFollowNode(node, node, cfa);\n  }\n\n  static Node computeFollowNode(Node node) {\n    return computeFollowNode(node, node, null);\n  }\n\n  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n\n  /**\n   * Computes the destination node of n when we want to fallthrough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   */\n  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }\n\n  /**\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   */\n  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }\n\n  /**\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   */\n  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (handler.isFunction()) {\n          return;\n        }\n        Preconditions.checkState(handler.isTry());\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }\n\n  /**\n   * Get the next sibling (including itself) of one of the given types.\n   */\n  private static Node getNextSiblingOfType(Node first, int ... types) {\n    for (Node c = first; c != null; c = c.getNext()) {\n      for (int type : types) {\n        if (c.getType() == type) {\n          return c;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if target is actually the break target of labeled continue. The\n   * label can be null if it is an unlabeled break.\n   */\n  public static boolean isBreakTarget(Node target, String label) {\n    return isBreakStructure(target, label != null) &&\n      matchLabel(target.getParent(), label);\n  }\n\n  /**\n   * Checks if target is actually the continue target of labeled continue. The\n   * label can be null if it is an unlabeled continue.\n   */\n  private static boolean isContinueTarget(\n      Node target, Node parent, String label) {\n    return isContinueStructure(target) && matchLabel(parent, label);\n  }\n  /**\n   * Check if label is actually referencing the target control structure. If\n   * label is null, it always returns true.\n   */\n  private static boolean matchLabel(Node target, String label) {\n    if (label == null) {\n      return true;\n    }\n    while (target.isLabel()) {\n      if (target.getFirstChild().getString().equals(label)) {\n        return true;\n      }\n      target = target.getParent();\n    }\n    return false;\n  }\n\n  /**\n   * Determines if the subtree might throw an exception.\n   */\n  public static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether the given node can be terminated with a BREAK node.\n   */\n  static boolean isBreakStructure(Node n, boolean labeled) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.SWITCH:\n        return true;\n      case Token.BLOCK:\n      case Token.IF:\n      case Token.TRY:\n        return labeled;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Determines whether the given node can be advanced with a CONTINUE node.\n   */\n  static boolean isContinueStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Get the TRY block with a CATCH that would be run if n throws an exception.\n   * @return The CATCH node or null if it there isn't a CATCH before the\n   *     the function terminates.\n   */\n  static Node getExceptionHandler(Node n) {\n    for (Node cur = n;\n        !cur.isScript() && !cur.isFunction();\n        cur = cur.getParent()) {\n      Node catchNode = getCatchHandlerForBlock(cur);\n      if (catchNode != null) {\n        return catchNode;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Locate the catch BLOCK given the first block in a TRY.\n   * @return The CATCH node or null there is no catch handler.\n   */\n  static Node getCatchHandlerForBlock(Node block) {\n    if (block.isBlock() &&\n        block.getParent().isTry() &&\n        block.getParent().getFirstChild() == block) {\n      for (Node s = block.getNext(); s != null; s = s.getNext()) {\n        if (NodeUtil.hasCatchHandler(s)) {\n          return s.getFirstChild();\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * A {@link ControlFlowGraph} which provides a node comparator based on the\n   * pre-order traversal of the AST.\n   */\n  private static class AstControlFlowGraph extends ControlFlowGraph<Node> {\n    private final Map<DiGraphNode<Node, Branch>, Integer> priorities;\n\n    /**\n     * Constructor.\n     * @param entry The entry node.\n     * @param priorities The map from nodes to position in the AST (to be\n     *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n     */\n    private AstControlFlowGraph(Node entry,\n        Map<DiGraphNode<Node, Branch>, Integer> priorities,\n        boolean edgeAnnotations) {\n      super(entry,\n          true /* node annotations */, edgeAnnotations);\n      this.priorities = priorities;\n    }\n\n    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }\n\n    /**\n     * Gets the pre-order traversal position of the given node.\n     * @return An arbitrary counter used for comparing positions.\n     */\n    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }\n  }\n}\n", "review": {"response": "{ \"bugs\": [] }"}}