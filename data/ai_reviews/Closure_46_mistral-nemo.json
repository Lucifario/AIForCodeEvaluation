{"sample_id": "Closure_46", "model": "mistral-nemo", "code_context": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Bob Jervis\n *   Google Inc.\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino.jstype;\n\nimport com.google.common.collect.Maps;\nimport com.google.javascript.rhino.ErrorReporter;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty;\n\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\n\n/**\n * A record (structural) type.\n *\n * Subtyping: The subtyping of a record type is defined via structural\n * comparison of a record type's properties. For example, a record\n * type of the form { a : TYPE_1 } is a supertype of a record type\n * of the form { b : TYPE_2, a : TYPE_1 } because B can be assigned to\n * A and matches all constraints. Similarly, a defined type can be assigned\n * to a record type so long as that defined type matches all property\n * constraints of the record type. A record type of the form { a : A, b : B }\n * can be assigned to a record of type { a : A }.\n *\n */\nclass RecordType extends PrototypeObjectType {\n  private static final long serialVersionUID = 1L;\n\n  private final SortedMap<String, JSType> properties = Maps.newTreeMap();\n  private boolean isFrozen = false;\n\n  /**\n   * Creates a record type.\n   *\n   * @param registry The type registry under which this type lives.\n   * @param properties A map of all the properties of this record type.\n   * @throws IllegalStateException if the {@code RecordProperty} associated\n   *         with a property is null.\n   */\n  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {\n    super(registry, null, null);\n    setPrettyPrint(true);\n\n    for (String property : properties.keySet()) {\n      RecordProperty prop = properties.get(property);\n      if (prop == null) {\n        throw new IllegalStateException(\n            \"RecordProperty associated with a property should not be null!\");\n      }\n      defineDeclaredProperty(property, prop.getType(), prop.getPropertyNode());\n    }\n\n    // Freeze the record type.\n    isFrozen = true;\n  }\n\n  @Override\n  public boolean isEquivalentTo(JSType other) {\n    if (!other.isRecordType()) {\n      return false;\n    }\n\n    // Compare properties.\n    RecordType otherRecord = other.toMaybeRecordType();\n    if (otherRecord == this) {\n      return true;\n    }\n\n    Set<String> keySet = properties.keySet();\n    Map<String, JSType> otherProps = otherRecord.properties;\n    if (!otherProps.keySet().equals(keySet)) {\n      return false;\n    }\n    for (String key : keySet) {\n      if (!otherProps.get(key).isEquivalentTo(properties.get(key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public ObjectType getImplicitPrototype() {\n    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n  }\n\n  @Override\n  boolean defineProperty(String propertyName, JSType type,\n      boolean inferred, Node propertyNode) {\n    if (isFrozen) {\n      return false;\n    }\n\n    if (!inferred) {\n      properties.put(propertyName, type);\n    }\n\n    return super.defineProperty(propertyName, type, inferred,\n        propertyNode);\n  }\n\n  @Override\n  public JSType getLeastSupertype(JSType that) {\n    if (!that.isRecordType()) {\n      return super.getLeastSupertype(that);\n    }\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n      if (that.toMaybeRecordType().hasProperty(property) &&\n          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n              getPropertyType(property))) {\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n    }\n    return builder.build();\n  }\n  JSType getGreatestSubtypeHelper(JSType that) {\n    if (that.isRecordType()) {\n      RecordType thatRecord = that.toMaybeRecordType();\n      RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n\n      // The greatest subtype consists of those *unique* properties of both\n      // record types. If any property conflicts, then the NO_TYPE type\n      // is returned.\n      for (String property : properties.keySet()) {\n        if (thatRecord.hasProperty(property) &&\n            !thatRecord.getPropertyType(property).isEquivalentTo(\n                getPropertyType(property))) {\n          return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n        }\n\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n\n      for (String property : thatRecord.properties.keySet()) {\n        if (!hasProperty(property)) {\n          builder.addProperty(property, thatRecord.getPropertyType(property),\n              thatRecord.getPropertyNode(property));\n        }\n      }\n\n      return builder.build();\n    }\n\n    JSType greatestSubtype = registry.getNativeType(\n        JSTypeNative.NO_OBJECT_TYPE);\n    JSType thatRestrictedToObj =\n        registry.getNativeType(JSTypeNative.OBJECT_TYPE)\n        .getGreatestSubtype(that);\n    if (!thatRestrictedToObj.isEmptyType()) {\n      // In this branch, the other type is some object type. We find\n      // the greatest subtype with the following algorithm:\n      // 1) For each property \"x\" of this record type, take the union\n      //    of all classes with a property \"x\" with a compatible property type.\n      //    and which are a subtype of {@code that}.\n      // 2) Take the intersection of all of these unions.\n      for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n        String propName = entry.getKey();\n        JSType propType = entry.getValue();\n        UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n        for (ObjectType alt :\n                 registry.getEachReferenceTypeWithProperty(propName)) {\n          JSType altPropType = alt.getPropertyType(propName);\n          if (altPropType != null && !alt.isEquivalentTo(this) &&\n              alt.isSubtype(that) &&\n              (propType.isUnknownType() || altPropType.isUnknownType() ||\n                  altPropType.isEquivalentTo(propType))) {\n            builder.addAlternate(alt);\n          }\n        }\n        greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());\n      }\n    }\n    return greatestSubtype;\n  }\n\n  @Override\n  RecordType toMaybeRecordType() {\n    return this;\n  }\n\n  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    // Top of the record types is the empty record, or OBJECT_TYPE.\n    if (registry.getNativeObjectType(\n            JSTypeNative.OBJECT_TYPE).isSubtype(that)) {\n      return true;\n    }\n\n    // A type is a subtype of a record type if it itself is a record\n    // type and it has at least the same members as the parent record type\n    // with the same types.\n    if (!that.isRecordType()) {\n      return false;\n    }\n\n    return RecordType.isSubtype(this, that.toMaybeRecordType());\n  }\n\n  /** Determines if typeA is a subtype of typeB */\n  static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n      if (!typeA.hasProperty(property)) {\n        return false;\n      }\n\n      JSType propA = typeA.getPropertyType(property);\n      JSType propB = typeB.getPropertyType(property);\n      if (!propA.isUnknownType() && !propB.isUnknownType()) {\n        if (typeA.isPropertyTypeDeclared(property)) {\n          if (!propA.isEquivalentTo(propB)) {\n            return false;\n          }\n        } else {\n          if (!propA.isSubtype(propB)) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n      JSType type = entry.getValue();\n      JSType resolvedType = type.resolve(t, scope);\n      if (type != resolvedType) {\n        properties.put(entry.getKey(), resolvedType);\n      }\n    }\n    return super.resolveInternal(t, scope);\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"description\": \"The `isEquivalentTo` method is not correctly handling the case where the other type is a record type that is equal to the current record type. It should return `true` in this case, but it currently returns `false`.\",\n      \"code\": \"if (otherRecord == this) { return true; }\"\n    },\n    {\n      \"description\": \"The `getGreatestSubtypeHelper` method is not properly handling the case where a property of the current record type conflicts with a property of the other record type. It should return `registry.getNativeObjectType(JSTypeNative.NO_TYPE)` in this case, but it currently continues to build the record type.\",\n      \"code\": \"if (thatRecord.getPropertyType(property).isEquivalentTo(getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); }\"\n    }\n  ]\n}"}}