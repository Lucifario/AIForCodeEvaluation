{
  "source_item_id": 136887,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:36:00.620924",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.action.fieldcaps;\n\nimport org.elasticsearch.action.ActionResponse;\nimport org.elasticsearch.common.Strings;\nimport org.elasticsearch.common.collect.Iterators;\nimport org.elasticsearch.common.io.stream.StreamInput;\nimport org.elasticsearch.common.io.stream.StreamOutput;\nimport org.elasticsearch.common.xcontent.ChunkedToXContentObject;\nimport org.elasticsearch.xcontent.ParseField;\nimport org.elasticsearch.xcontent.ToXContent;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * Response for {@link FieldCapabilitiesRequest} requests.\n */\npublic class FieldCapabilitiesResponse extends ActionResponse implements ChunkedToXContentObject {\n    public static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n    public static final ParseField FIELDS_FIELD = new ParseField(\"fields\");\n    private static final ParseField FAILED_INDICES_FIELD = new ParseField(\"failed_indices\");\n    public static final ParseField FAILURES_FIELD = new ParseField(\"failures\");\n\n    private final String[] indices;\n    private final Map<String, Map<String, FieldCapabilities>> fields;\n    private final List<FieldCapabilitiesFailure> failures;\n    private final List<FieldCapabilitiesIndexResponse> indexResponses;\n\n    public FieldCapabilitiesResponse(\n        String[] indices,\n        Map<String, Map<String, FieldCapabilities>> fields,\n        List<FieldCapabilitiesFailure> failures\n    ) {\n        this(indices, fields, Collections.emptyList(), failures);\n    }\n\n    public FieldCapabilitiesResponse(String[] indices, Map<String, Map<String, FieldCapabilities>> fields) {\n        this(indices, fields, Collections.emptyList(), Collections.emptyList());\n    }\n\n    public FieldCapabilitiesResponse(List<FieldCapabilitiesIndexResponse> indexResponses, List<FieldCapabilitiesFailure> failures) {\n        this(Strings.EMPTY_ARRAY, Collections.emptyMap(), indexResponses, failures);\n    }\n\n    private FieldCapabilitiesResponse(\n        String[] indices,\n        Map<String, Map<String, FieldCapabilities>> fields,\n        List<FieldCapabilitiesIndexResponse> indexResponses,\n        List<FieldCapabilitiesFailure> failures\n    ) {\n        this.fields = Objects.requireNonNull(fields);\n        this.indexResponses = Objects.requireNonNull(indexResponses);\n        this.indices = indices;\n        this.failures = failures;\n    }\n\n    public FieldCapabilitiesResponse(StreamInput in) throws IOException {\n        this.indices = in.readStringArray();\n        this.fields = in.readMap(FieldCapabilitiesResponse::readField);\n        this.indexResponses = FieldCapabilitiesIndexResponse.readList(in);\n        this.failures = in.readCollectionAsList(FieldCapabilitiesFailure::new);\n    }\n\n    /**\n     * Get the concrete list of indices that were requested and returned a response.\n     */\n    public String[] getIndices() {\n        return indices;\n    }\n\n    /**\n     * Get the concrete list of indices that failed\n     */\n    public int getFailedIndicesCount() {\n        int count = 0;\n        for (FieldCapabilitiesFailure fieldCapabilitiesFailure : this.failures) {\n            int length = fieldCapabilitiesFailure.getIndices().length;\n            count += length;\n        }\n        return count;\n    }\n\n    /**\n     * Get the field capabilities map.\n     */\n    public Map<String, Map<String, FieldCapabilities>> get() {\n        return fields;\n    }\n\n    /**\n     * Get possible request failures keyed by index name\n     */\n    public List<FieldCapabilitiesFailure> getFailures() {\n        return failures;\n    }\n\n    /**\n     * Returns the actual per-index field caps responses\n     */\n    public List<FieldCapabilitiesIndexResponse> getIndexResponses() {\n        return indexResponses;\n    }\n\n    /**\n     *\n     * Get the field capabilities per type for the provided {@code field}.\n     */\n    public Map<String, FieldCapabilities> getField(String field) {\n        return fields.get(field);\n    }\n\n    /**\n     * Returns <code>true</code> if the provided field is a metadata field.\n     */\n    public boolean isMetadataField(String field) {\n        Map<String, FieldCapabilities> caps = getField(field);\n        if (caps == null) {\n            return false;\n        }\n        return caps.values().stream().anyMatch(FieldCapabilities::isMetadataField);\n    }\n\n    private static Map<String, FieldCapabilities> readField(StreamInput in) throws IOException {\n        return in.readMap(FieldCapabilities::new);\n    }\n\n    @Override\n    public void writeTo(StreamOutput out) throws IOException {\n        out.writeStringArray(indices);\n        out.writeMap(fields, FieldCapabilitiesResponse::writeField);\n        FieldCapabilitiesIndexResponse.writeList(out, indexResponses);\n        out.writeCollection(failures);\n    }\n\n    private static void writeField(StreamOutput out, Map<String, FieldCapabilities> map) throws IOException {\n        out.writeMap(map, StreamOutput::writeWriteable);\n    }\n\n    @Override\n    public Iterator<? extends ToXContent> toXContentChunked(ToXContent.Params params) {\n        if (indexResponses.size() > 0) {\n            throw new IllegalStateException(\"cannot serialize non-merged response\");\n        }\n\n        return Iterators.concat(\n            Iterators.single(\n                (b, p) -> b.startObject().array(INDICES_FIELD.getPreferredName(), indices).startObject(FIELDS_FIELD.getPreferredName())\n            ),\n            Iterators.map(fields.entrySet().iterator(), r -> (b, p) -> b.xContentValuesMap(r.getKey(), r.getValue())),\n            this.failures.size() > 0\n                ? Iterators.concat(\n                    Iterators.single(\n                        (ToXContent) (b, p) -> b.endObject()\n                            .field(FAILED_INDICES_FIELD.getPreferredName(), getFailedIndicesCount())\n                            .field(FAILURES_FIELD.getPreferredName())\n                            .startArray()\n                    ),\n                    failures.iterator(),\n                    Iterators.single((b, p) -> b.endArray().endObject())\n                )\n                : Iterators.single((b, p) -> b.endObject().endObject())\n        );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        FieldCapabilitiesResponse that = (FieldCapabilitiesResponse) o;\n        return Arrays.equals(indices, that.indices)\n            && Objects.equals(fields, that.fields)\n            && Objects.equals(indexResponses, that.indexResponses)\n            && Objects.equals(failures, that.failures);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = Objects.hash(fields, indexResponses, failures);\n        result = 31 * result + Arrays.hashCode(indices);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        if (indexResponses.size() > 0) {\n            return \"FieldCapabilitiesResponse{unmerged}\";\n        }\n        return Strings.toString(this);\n    }\n}\n",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The constructor FieldCapabilitiesResponse(String[] indices, Map<String, Map<String, FieldCapabilities>> fields, List<FieldCapabilitiesIndexResponse> indexResponses, List<FieldCapabilitiesFailure> failures) has a redundant parameter. The parameter 'failures' is already included in the other constructor FieldCapabilitiesResponse(String[] indices, Map<String, Map<String, FieldCapabilities>> fields, List<FieldCapabilitiesIndexResponse> indexResponses, List<FieldCapabilitiesFailure> failures).\",\n         \"suggested_fix\": \"Remove the redundant constructor FieldCapabilitiesResponse(String[] indices, Map<String, Map<String, FieldCapabilities>> fields, List<FieldCapabilitiesIndexResponse> indexResponses, List<FieldCapabilitiesFailure> failures).\"\n      },\n      {\n         \"explanation\": \"The method getFailedIndicesCount() has a potential null pointer exception. The field 'failures' is not checked for null before iterating over it.\",\n         \"suggested_fix\": \"Add a null check for the field 'failures' before iterating over it in the method getFailedIndicesCount().\"\n      },\n      {\n         \"explanation\": \"The method toXContentChunked(ToXContent.Params params) has a potential exception. If the indexResponses size is greater than 0, it throws an IllegalStateException. However, it does not handle the case when the indexResponses size is 0.\",\n         \"suggested_fix\": \"Add a null check for the indexResponses before calling the size() method in the method toXContentChunked(ToXContent.Params params).\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs found in the code. The code appears to be well-structured and follows best practices.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The constructor FieldCapabilitiesResponse(String[] indices, Map<String, Map<String, FieldCapabilities>> fields, List<FieldCapabilitiesIndexResponse> indexResponses, List<FieldCapabilitiesFailure> failures) has a redundant parameter. The parameter 'failures' is already included in the other constructor FieldCapabilitiesResponse(String[] indices, Map<String, Map<String, FieldCapabilities>> fields, List<FieldCapabilitiesIndexResponse> indexResponses, List<FieldCapabilitiesFailure> failures).",
        "suggested_fix": "Remove the redundant constructor FieldCapabilitiesResponse(String[] indices, Map<String, Map<String, FieldCapabilities>> fields, List<FieldCapabilitiesIndexResponse> indexResponses, List<FieldCapabilitiesFailure> failures)."
      },
      {
        "explanation": "The method getFailedIndicesCount() has a potential null pointer exception. The field 'failures' is not checked for null before iterating over it.",
        "suggested_fix": "Add a null check for the field 'failures' before iterating over it in the method getFailedIndicesCount()."
      },
      {
        "explanation": "The method toXContentChunked(ToXContent.Params params) has a potential exception. If the indexResponses size is greater than 0, it throws an IllegalStateException. However, it does not handle the case when the indexResponses size is 0.",
        "suggested_fix": "Add a null check for the indexResponses before calling the size() method in the method toXContentChunked(ToXContent.Params params)."
      }
    ],
    "no_bugs_reasoning": "No bugs found in the code. The code appears to be well-structured and follows best practices."
  },
  "error": null
}