{"sample_id": "Lang_55", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang.time;\n\n/**\n * <p><code>StopWatch</code> provides a convenient API for timings.</p>\n * \n * <p>To start the watch, call {@link #start()}. At this point you can:</p>\n * <ul>\n *  <li>{@link #split()} the watch to get the time whilst the watch continues in the\n *   background. {@link #unsplit()} will remove the effect of the split. At this point,\n *   these three options are available again.</li>\n *  <li>{@link #suspend()} the watch to pause it. {@link #resume()} allows the watch\n *   to continue. Any time between the suspend and resume will not be counted in\n *   the total. At this point, these three options are available again.</li>\n *  <li>{@link #stop()} the watch to complete the timing session.</li>\n * </ul>\n *\n * <p>It is intended that the output methods {@link #toString()} and {@link #getTime()}\n * should only be called after stop, split or suspend, however a suitable result will\n * be returned at other points.</p>\n *\n * <p>NOTE: As from v2.1, the methods protect against inappropriate calls.\n * Thus you cannot now call stop before start, resume before suspend or\n * unsplit before split.</p>\n *\n * <p>1. split(), suspend(), or stop() cannot be invoked twice<br />\n * 2. unsplit() may only be called if the watch has been split()<br />\n * 3. resume() may only be called if the watch has been suspend()<br />\n * 4. start() cannot be called twice without calling reset()</p>\n *\n * @author Stephen Colebourne\n * @since 2.0\n * @version $Id$\n */\npublic class StopWatch {\n\n    // running states\n    private static final int STATE_UNSTARTED = 0;\n    private static final int STATE_RUNNING   = 1;\n    private static final int STATE_STOPPED   = 2;\n    private static final int STATE_SUSPENDED = 3;\n\n    // split state\n    private static final int STATE_UNSPLIT = 10;\n    private static final int STATE_SPLIT   = 11;\n\n    /**\n     *  The current running state of the StopWatch. \n     */\n    private int runningState = STATE_UNSTARTED;\n\n    /**\n     * Whether the stopwatch has a split time recorded. \n     */\n    private int splitState   = STATE_UNSPLIT;\n\n    /**\n     * The start time.\n     */\n    private long startTime = -1;\n    /**\n     * The stop time.\n     */\n    private long stopTime = -1;\n\n    /**\n     * <p>Constructor.</p>\n     */\n    public StopWatch() {\n        super();\n    }\n\n    /**\n     * <p>Start the stopwatch.</p>\n     * \n     * <p>This method starts a new timing session, clearing any previous values.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is already running.\n     */\n    public void start() {\n        if(this.runningState == STATE_STOPPED) {\n            throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n        }\n        if(this.runningState != STATE_UNSTARTED) {\n            throw new IllegalStateException(\"Stopwatch already started. \");\n        }\n        stopTime = -1;\n        startTime = System.currentTimeMillis();\n        this.runningState = STATE_RUNNING;\n    }\n\n    /**\n     * <p>Stop the stopwatch.</p>\n     * \n     * <p>This method ends a new timing session, allowing the time to be retrieved.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not running.\n     */\n    public void stop() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n            stopTime = System.currentTimeMillis();\n        this.runningState = STATE_STOPPED;\n    }\n\n    /**\n     * <p>Resets the stopwatch. Stops it if need be. </p>\n     * \n     * <p>This method clears the internal values to allow the object to be reused.</p>\n     */\n    public void reset() {\n        this.runningState = STATE_UNSTARTED;\n        this.splitState   = STATE_UNSPLIT;\n        startTime = -1;\n        stopTime = -1;\n    }\n\n    /**\n     * <p>Split the time.</p>\n     * \n     * <p>This method sets the stop time of the watch to allow a time to be extracted.\n     * The start time is unaffected, enabling {@link #unsplit()} to continue the \n     * timing from the original start point.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not running.\n     */\n    public void split() {\n        if(this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        stopTime = System.currentTimeMillis();\n        this.splitState = STATE_SPLIT;\n    }\n\n    /**\n     * <p>Remove a split.</p>\n     * \n     * <p>This method clears the stop time. The start time is unaffected, enabling \n     * timing from the original start point to continue.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been split.\n     */\n    public void unsplit() {\n        if(this.splitState != STATE_SPLIT) {\n            throw new IllegalStateException(\"Stopwatch has not been split. \");\n        }\n        stopTime = -1;\n        this.splitState = STATE_UNSPLIT;\n    }\n\n    /**\n     * <p>Suspend the stopwatch for later resumption.</p>\n     * \n     * <p>This method suspends the watch until it is resumed. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch is not currently running.\n     */\n    public void suspend() {\n        if(this.runningState != STATE_RUNNING) {\n            throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n        }\n        stopTime = System.currentTimeMillis();\n        this.runningState = STATE_SUSPENDED;\n    }\n\n    /**\n     * <p>Resume the stopwatch after a suspend.</p>\n     * \n     * <p>This method resumes the watch after it was suspended. The watch will not include\n     * time between the suspend and resume calls in the total time.</p>\n     *\n     * @throws IllegalStateException if the StopWatch has not been suspended. \n     */\n    public void resume() {\n        if(this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n        }\n        startTime += (System.currentTimeMillis() - stopTime);\n        stopTime = -1;\n        this.runningState = STATE_RUNNING;\n    }\n\n    /**\n     * <p>Get the time on the stopwatch.</p>\n     * \n     * <p>This is either the time between the start and the moment this method \n     * is called, or the amount of time between start and stop.</p>\n     * \n     * @return the time in milliseconds\n     */\n    public long getTime() {\n        if(this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {\n            return this.stopTime - this.startTime;\n        } else\n        if(this.runningState == STATE_UNSTARTED) {\n            return 0;\n        } else\n        if(this.runningState == STATE_RUNNING) {\n            return System.currentTimeMillis() - this.startTime;\n        }\n        throw new RuntimeException(\"Illegal running state has occured. \");\n    }\n\n    /**\n     * <p>Get the split time on the stopwatch.</p>\n     * \n     * <p>This is the time between start and latest split. </p>\n     * \n     * @return the split time in milliseconds\n     *\n     * @throws IllegalStateException if the StopWatch has not yet been split.\n     * @since 2.1\n     */\n    public long getSplitTime() {\n        if(this.splitState != STATE_SPLIT) {\n            throw new IllegalStateException(\"Stopwatch must be split to get the split time. \");\n        }\n        return this.stopTime - this.startTime;\n    }\n\n    /**\n     * <p>Gets a summary of the time that the stopwatch recorded as a string.</p>\n     * \n     * <p>The format used is ISO8601-like,\n     * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>\n     * \n     * @return the time as a String\n     */\n    public String toString() {\n        return DurationFormatUtils.formatDurationHMS(getTime());\n    }\n\n    /**\n     * <p>Gets a summary of the split time that the stopwatch recorded as a string.</p>\n     * \n     * <p>The format used is ISO8601-like,\n     * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>\n     * \n     * @return the split time as a String\n     * @since 2.1\n     */\n    public String toSplitString() {\n        return DurationFormatUtils.formatDurationHMS(getSplitTime());\n    }\n\n}\n", "review": {"response": "{\n  \"bugs\":[\n      {\n         \"id\":1,\n         \"description\":\"In the stop method, the stopTime is set to System.currentTimeMillis() but it should be set to the current time minus the start time to get the actual elapsed time.\",\n         \"severity\":\"MEDIUM\"\n      },\n      {\n         \"id\":2,\n         \"description\":\"In the split method, the stopTime is set to System.currentTimeMillis() but it should be set to the current time minus the start time to get the actual elapsed time.\",\n         \"severity\":\"MEDIUM\"\n      },\n      {\n         \"id\":3,\n         \"description\":\"In the unsplit method, the stopTime is set to -1 but it should be reset to the original start time.\",\n         \"severity\":\"MEDIUM\"\n      },\n      {\n         \"id\":4,\n         \"description\":\"The reset method does not reset the splitState to STATE_UNSPLIT when the stopwatch is reset.\",\n         \"severity\":\"LOW\"\n      }\n   ]\n}"}}