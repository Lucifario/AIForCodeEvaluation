{
  "source_item_id": 137082,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:34:20.406169",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0; you may not use this file except in compliance with the Elastic License\n * 2.0.\n */\n\npackage org.elasticsearch.xpack.esql.parser;\n\nimport org.antlr.v4.runtime.ParserRuleContext;\nimport org.antlr.v4.runtime.tree.ParseTree;\nimport org.apache.lucene.util.BytesRef;\nimport org.elasticsearch.Build;\nimport org.elasticsearch.cluster.metadata.IndexNameExpressionResolver;\nimport org.elasticsearch.common.Strings;\nimport org.elasticsearch.common.logging.HeaderWarning;\nimport org.elasticsearch.common.lucene.BytesRefs;\nimport org.elasticsearch.core.Tuple;\nimport org.elasticsearch.dissect.DissectException;\nimport org.elasticsearch.dissect.DissectParser;\nimport org.elasticsearch.index.IndexMode;\nimport org.elasticsearch.index.mapper.IdFieldMapper;\nimport org.elasticsearch.transport.RemoteClusterAware;\nimport org.elasticsearch.xpack.esql.VerificationException;\nimport org.elasticsearch.xpack.esql.action.EsqlCapabilities;\nimport org.elasticsearch.xpack.esql.capabilities.TelemetryAware;\nimport org.elasticsearch.xpack.esql.common.Failure;\nimport org.elasticsearch.xpack.esql.core.expression.Alias;\nimport org.elasticsearch.xpack.esql.core.expression.Attribute;\nimport org.elasticsearch.xpack.esql.core.expression.EmptyAttribute;\nimport org.elasticsearch.xpack.esql.core.expression.Expression;\nimport org.elasticsearch.xpack.esql.core.expression.Expressions;\nimport org.elasticsearch.xpack.esql.core.expression.FoldContext;\nimport org.elasticsearch.xpack.esql.core.expression.Literal;\nimport org.elasticsearch.xpack.esql.core.expression.MapExpression;\nimport org.elasticsearch.xpack.esql.core.expression.MetadataAttribute;\nimport org.elasticsearch.xpack.esql.core.expression.NameId;\nimport org.elasticsearch.xpack.esql.core.expression.NamedExpression;\nimport org.elasticsearch.xpack.esql.core.expression.ReferenceAttribute;\nimport org.elasticsearch.xpack.esql.core.expression.UnresolvedAttribute;\nimport org.elasticsearch.xpack.esql.core.expression.UnresolvedStar;\nimport org.elasticsearch.xpack.esql.core.tree.Source;\nimport org.elasticsearch.xpack.esql.core.type.DataType;\nimport org.elasticsearch.xpack.esql.core.util.Holder;\nimport org.elasticsearch.xpack.esql.expression.Order;\nimport org.elasticsearch.xpack.esql.expression.UnresolvedNamePattern;\nimport org.elasticsearch.xpack.esql.expression.function.UnresolvedFunction;\nimport org.elasticsearch.xpack.esql.expression.predicate.Predicates;\nimport org.elasticsearch.xpack.esql.expression.predicate.logical.BinaryLogic;\nimport org.elasticsearch.xpack.esql.expression.predicate.logical.Not;\nimport org.elasticsearch.xpack.esql.expression.predicate.operator.comparison.Equals;\nimport org.elasticsearch.xpack.esql.expression.predicate.operator.comparison.EsqlBinaryComparison;\nimport org.elasticsearch.xpack.esql.plan.EsqlStatement;\nimport org.elasticsearch.xpack.esql.plan.IndexPattern;\nimport org.elasticsearch.xpack.esql.plan.QuerySetting;\nimport org.elasticsearch.xpack.esql.plan.logical.Aggregate;\nimport org.elasticsearch.xpack.esql.plan.logical.ChangePoint;\nimport org.elasticsearch.xpack.esql.plan.logical.Dissect;\nimport org.elasticsearch.xpack.esql.plan.logical.Drop;\nimport org.elasticsearch.xpack.esql.plan.logical.Enrich;\nimport org.elasticsearch.xpack.esql.plan.logical.Eval;\nimport org.elasticsearch.xpack.esql.plan.logical.Explain;\nimport org.elasticsearch.xpack.esql.plan.logical.Filter;\nimport org.elasticsearch.xpack.esql.plan.logical.Fork;\nimport org.elasticsearch.xpack.esql.plan.logical.Grok;\nimport org.elasticsearch.xpack.esql.plan.logical.InlineStats;\nimport org.elasticsearch.xpack.esql.plan.logical.Insist;\nimport org.elasticsearch.xpack.esql.plan.logical.Keep;\nimport org.elasticsearch.xpack.esql.plan.logical.Limit;\nimport org.elasticsearch.xpack.esql.plan.logical.LogicalPlan;\nimport org.elasticsearch.xpack.esql.plan.logical.Lookup;\nimport org.elasticsearch.xpack.esql.plan.logical.MvExpand;\nimport org.elasticsearch.xpack.esql.plan.logical.OrderBy;\nimport org.elasticsearch.xpack.esql.plan.logical.Rename;\nimport org.elasticsearch.xpack.esql.plan.logical.Row;\nimport org.elasticsearch.xpack.esql.plan.logical.Sample;\nimport org.elasticsearch.xpack.esql.plan.logical.TimeSeriesAggregate;\nimport org.elasticsearch.xpack.esql.plan.logical.UnresolvedRelation;\nimport org.elasticsearch.xpack.esql.plan.logical.fuse.Fuse;\nimport org.elasticsearch.xpack.esql.plan.logical.inference.Completion;\nimport org.elasticsearch.xpack.esql.plan.logical.inference.InferencePlan;\nimport org.elasticsearch.xpack.esql.plan.logical.inference.Rerank;\nimport org.elasticsearch.xpack.esql.plan.logical.join.LookupJoin;\nimport org.elasticsearch.xpack.esql.plan.logical.show.ShowInfo;\nimport org.joni.exception.SyntaxException;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport static java.util.Collections.emptyList;\nimport static org.elasticsearch.xpack.esql.action.EsqlCapabilities.Cap.LOOKUP_JOIN_ON_BOOLEAN_EXPRESSION;\nimport static org.elasticsearch.xpack.esql.core.util.StringUtils.WILDCARD;\nimport static org.elasticsearch.xpack.esql.expression.NamedExpressions.mergeOutputExpressions;\nimport static org.elasticsearch.xpack.esql.parser.ParserUtils.source;\nimport static org.elasticsearch.xpack.esql.parser.ParserUtils.typedParsing;\nimport static org.elasticsearch.xpack.esql.parser.ParserUtils.visitList;\nimport static org.elasticsearch.xpack.esql.plan.logical.Enrich.Mode;\n\n/**\n * Translates what we get back from Antlr into the data structures the rest of the planner steps will act on.  Generally speaking, things\n * which change the grammar will need to make changes here as well.\n */\npublic class LogicalPlanBuilder extends ExpressionBuilder {\n\n    interface PlanFactory extends Function<LogicalPlan, LogicalPlan> {}\n\n    /**\n     * Maximum number of commands allowed per query\n     */\n    public static final int MAX_QUERY_DEPTH = 500;\n\n    public LogicalPlanBuilder(ParsingContext context) {\n        super(context);\n    }\n\n    private int queryDepth = 0;\n\n    protected EsqlStatement statement(ParseTree ctx) {\n        EsqlStatement p = typedParsing(this, ctx, EsqlStatement.class);\n        return p;\n    }\n\n    protected LogicalPlan plan(ParseTree ctx) {\n        LogicalPlan p = ParserUtils.typedParsing(this, ctx, LogicalPlan.class);\n        if (p instanceof Explain == false && p.anyMatch(logicalPlan -> logicalPlan instanceof Explain)) {\n            throw new ParsingException(source(ctx), \"EXPLAIN does not support downstream commands\");\n        }\n        if (p instanceof Explain explain && explain.query().anyMatch(logicalPlan -> logicalPlan instanceof Explain)) {\n            // TODO this one is never reached because the Parser fails to understand multiple round brackets\n            throw new ParsingException(source(ctx), \"EXPLAIN cannot be used inside another EXPLAIN command\");\n        }\n        var errors = this.context.params().parsingErrors();\n        if (errors.hasNext() == false) {\n            return p;\n        } else {\n            throw ParsingException.combineParsingExceptions(errors);\n        }\n    }\n\n    @Override\n    public EsqlStatement visitStatements(EsqlBaseParser.StatementsContext ctx) {\n        List<QuerySetting> settings = new ArrayList<>();\n        for (EsqlBaseParser.SetCommandContext setCommandContext : ctx.setCommand()) {\n            settings.add(visitSetCommand(setCommandContext));\n        }\n\n        LogicalPlan query = visitSingleStatement(ctx.singleStatement());\n        return new EsqlStatement(query, settings);\n    }\n\n    protected List<LogicalPlan> plans(List<? extends ParserRuleContext> ctxs) {\n        return ParserUtils.visitList(this, ctxs, Logica",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The code does not handle the case where the parser fails to understand multiple round brackets in an EXPLAIN command.\",\n         \"suggested_fix\": \"Add a check to handle this case, for example by throwing a ParsingException with a specific message.\"\n      },\n      {\n         \"explanation\": \"The code does not handle the case where the query depth exceeds the maximum allowed depth.\",\n         \"suggested_fix\": \"Add a check to prevent the query depth from exceeding the maximum allowed depth, for example by throwing a ParsingException with a specific message.\"\n      },\n      {\n         \"explanation\": \"The code does not handle the case where the parsing errors are not combined correctly.\",\n         \"suggested_fix\": \"Use a more robust way to combine parsing exceptions, for example by using a try-catch block to catch and combine exceptions.\"\n      },\n      {\n         \"explanation\": \"The code does not handle the case where the logical plan is not an instance of Explain.\",\n         \"suggested_fix\": \"Add a check to ensure that the logical plan is an instance of Explain before throwing a ParsingException.\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No critical bugs found in the code. However, some potential issues were identified that could be improved for better code quality and maintainability.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The code does not handle the case where the parser fails to understand multiple round brackets in an EXPLAIN command.",
        "suggested_fix": "Add a check to handle this case, for example by throwing a ParsingException with a specific message."
      },
      {
        "explanation": "The code does not handle the case where the query depth exceeds the maximum allowed depth.",
        "suggested_fix": "Add a check to prevent the query depth from exceeding the maximum allowed depth, for example by throwing a ParsingException with a specific message."
      },
      {
        "explanation": "The code does not handle the case where the parsing errors are not combined correctly.",
        "suggested_fix": "Use a more robust way to combine parsing exceptions, for example by using a try-catch block to catch and combine exceptions."
      },
      {
        "explanation": "The code does not handle the case where the logical plan is not an instance of Explain.",
        "suggested_fix": "Add a check to ensure that the logical plan is an instance of Explain before throwing a ParsingException."
      }
    ],
    "no_bugs_reasoning": "No critical bugs found in the code. However, some potential issues were identified that could be improved for better code quality and maintainability."
  },
  "error": null
}