{"sample_id": "Chart_13", "model": "llama3-8b-groq", "code_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ----------------------\n * BorderArrangement.java\n * ----------------------\n * (C) Copyright 2004-2008, by Object Refinery Limited.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes:\n * --------\n * 22-Oct-2004 : Version 1 (DG);\n * 08-Feb-2005 : Updated for changes in RectangleConstraint (DG);\n * 24-Feb-2005 : Improved arrangeRR() method (DG);\n * 03-May-2005 : Implemented Serializable and added equals() method (DG);\n * 13-May-2005 : Fixed bugs in the arrange() method (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 08-Apr-2008 : Fixed bug in arrangeFF() method where width is too small for\n *               left and right blocks (DG);\n *\n */\n\npackage org.jfree.chart.block;\n\nimport java.awt.Graphics2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.Serializable;\n\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.Size2D;\nimport org.jfree.data.Range;\n\n/**\n * An arrangement manager that lays out blocks in a similar way to\n * Swing's BorderLayout class.\n */\npublic class BorderArrangement implements Arrangement, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 506071142274883745L;\n\n    /** The block (if any) at the center of the layout. */\n    private Block centerBlock;\n\n    /** The block (if any) at the top of the layout. */\n    private Block topBlock;\n\n    /** The block (if any) at the bottom of the layout. */\n    private Block bottomBlock;\n\n    /** The block (if any) at the left of the layout. */\n    private Block leftBlock;\n\n    /** The block (if any) at the right of the layout. */\n    private Block rightBlock;\n\n    /**\n     * Creates a new instance.\n     */\n    public BorderArrangement() {\n    }\n\n    /**\n     * Adds a block to the arrangement manager at the specified edge.\n     *\n     * @param block  the block (<code>null</code> permitted).\n     * @param key  the edge (an instance of {@link RectangleEdge}) or\n     *             <code>null</code> for the center block.\n     */\n    public void add(Block block, Object key) {\n\n        if (key == null) {\n            this.centerBlock = block;\n        }\n        else {\n            RectangleEdge edge = (RectangleEdge) key;\n            if (edge == RectangleEdge.TOP) {\n                this.topBlock = block;\n            }\n            else if (edge == RectangleEdge.BOTTOM) {\n                this.bottomBlock = block;\n            }\n            else if (edge == RectangleEdge.LEFT) {\n                this.leftBlock = block;\n            }\n            else if (edge == RectangleEdge.RIGHT) {\n                this.rightBlock = block;\n            }\n        }\n    }\n\n    /**\n     * Arranges the items in the specified container, subject to the given\n     * constraint.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param constraint  the constraint.\n     *\n     * @return The block size.\n     */\n    public Size2D arrange(BlockContainer container,\n                          Graphics2D g2,\n                          RectangleConstraint constraint) {\n        RectangleConstraint contentConstraint\n                = container.toContentConstraint(constraint);\n        Size2D contentSize = null;\n        LengthConstraintType w = contentConstraint.getWidthConstraintType();\n        LengthConstraintType h = contentConstraint.getHeightConstraintType();\n        if (w == LengthConstraintType.NONE) {\n            if (h == LengthConstraintType.NONE) {\n                contentSize = arrangeNN(container, g2);\n            }\n            else if (h == LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h == LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n        }\n        else if (w == LengthConstraintType.FIXED) {\n            if (h == LengthConstraintType.NONE) {\n                contentSize = arrangeFN(container, g2, constraint.getWidth());\n            }\n            else if (h == LengthConstraintType.FIXED) {\n                contentSize = arrangeFF(container, g2, constraint);\n            }\n            else if (h == LengthConstraintType.RANGE) {\n                contentSize = arrangeFR(container, g2, constraint);\n            }\n        }\n        else if (w == LengthConstraintType.RANGE) {\n            if (h == LengthConstraintType.NONE) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h == LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h == LengthConstraintType.RANGE) {\n                contentSize = arrangeRR(container, constraint.getWidthRange(),\n                        constraint.getHeightRange(), g2);\n            }\n        }\n        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()),\n                container.calculateTotalHeight(contentSize.getHeight()));\n    }\n\n    /**\n     * Performs an arrangement without constraints.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        if (this.topBlock != null) {\n            Size2D size = this.topBlock.arrange(g2, RectangleConstraint.NONE);\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Size2D size = this.bottomBlock.arrange(g2,\n                    RectangleConstraint.NONE);\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        if (this.leftBlock != null) {\n            Size2D size = this.leftBlock.arrange(g2, RectangleConstraint.NONE);\n            w[2] = size.width;\n            h[2] = size.height;\n       }\n        if (this.rightBlock != null) {\n            Size2D size = this.rightBlock.arrange(g2, RectangleConstraint.NONE);\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n\n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n\n        if (this.centerBlock != null) {\n            Size2D size = this.centerBlock.arrange(g2,\n                    RectangleConstraint.NONE);\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n        double centerHeight = Math.max(h[2], Math.max(h[3], h[4]));\n        double height = h[0] + h[1] + centerHeight;\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,\n                    height - h[1], width, h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    centerHeight));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],\n                    h[0], w[3], centerHeight));\n        }\n\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],\n                    width - w[2] - w[3], centerHeight));\n        }\n        return new Size2D(width, height);\n    }\n\n    /**\n     * Performs an arrangement with a fixed width and a range for the height.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param constraint  the constraint.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        Size2D size1 = arrangeFN(container, g2, constraint.getWidth());\n        if (constraint.getHeightRange().contains(size1.getHeight())) {\n            return size1;\n        }\n        else {\n            double h = constraint.getHeightRange().constrain(size1.getHeight());\n            RectangleConstraint c2 = constraint.toFixedHeight(h);\n            return arrange(container, g2, c2);\n        }\n    }\n\n    /**\n     * Arranges the container width a fixed width and no constraint on the\n     * height.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param width  the fixed width.\n     *\n     * @return The container size after arranging the contents.\n     */\n    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2,\n                               double width) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        RectangleConstraint c1 = new RectangleConstraint(width, null,\n                LengthConstraintType.FIXED, 0.0, null,\n                LengthConstraintType.NONE);\n        if (this.topBlock != null) {\n            Size2D size = this.topBlock.arrange(g2, c1);\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Size2D size = this.bottomBlock.arrange(g2, c1);\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        RectangleConstraint c2 = new RectangleConstraint(0.0,\n                new Range(0.0, width), LengthConstraintType.RANGE,\n                0.0, null, LengthConstraintType.NONE);\n        if (this.leftBlock != null) {\n            Size2D size = this.leftBlock.arrange(g2, c2);\n            w[2] = size.width;\n            h[2] = size.height;\n        }\n        if (this.rightBlock != null) {\n            double maxW = Math.max(width - w[2], 0.0);\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(Math.min(w[2], maxW), maxW),\n                    LengthConstraintType.RANGE, 0.0, null,\n                    LengthConstraintType.NONE);\n            Size2D size = this.rightBlock.arrange(g2, c3);\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n\n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n\n        if (this.centerBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(width - w[2]\n                    - w[3], null, LengthConstraintType.FIXED, 0.0, null,\n                    LengthConstraintType.NONE);\n            Size2D size = this.centerBlock.arrange(g2, c4);\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n        return arrange(container, g2, new RectangleConstraint(width, height));\n    }\n\n    /**\n     * Performs an arrangement with range constraints on both the vertical\n     * and horizontal sides.\n     *\n     * @param container  the container.\n     * @param widthRange  the allowable range for the container width.\n     * @param heightRange  the allowable range for the container height.\n     * @param g2  the graphics device.\n     *\n     * @return The container size.\n     */\n    protected Size2D arrangeRR(BlockContainer container,\n                               Range widthRange, Range heightRange,\n                               Graphics2D g2) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(widthRange,\n                    heightRange);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Range heightRange2 = Range.shift(heightRange, -h[0], false);\n            RectangleConstraint c2 = new RectangleConstraint(widthRange,\n                    heightRange2);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        Range heightRange3 = Range.shift(heightRange, -(h[0] + h[1]));\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(widthRange,\n                    heightRange3);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n            h[2] = size.height;\n        }\n        Range widthRange2 = Range.shift(widthRange, -w[2], false);\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(widthRange2,\n                    heightRange3);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n\n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n        Range widthRange3 = Range.shift(widthRange, -(w[2] + w[3]), false);\n        if (this.centerBlock != null) {\n            RectangleConstraint c5 = new RectangleConstraint(widthRange3,\n                    heightRange3);\n            // TODO:  the width and height ranges should be reduced by the\n            // height required for the top and bottom, and the width required\n            // by the left and right\n            Size2D size = this.centerBlock.arrange(g2, c5);\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,\n                    height - h[1], width, h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],\n                    h[0], w[3], h[3]));\n        }\n\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],\n                    width - w[2] - w[3], height - h[0] - h[1]));\n        }\n        return new Size2D(width, height);\n    }\n\n    /**\n     * Arranges the items within a container.\n     *\n     * @param container  the container.\n     * @param constraint  the constraint.\n     * @param g2  the graphics device.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth() - w[2]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }\n\n    /**\n     * Clears the layout.\n     */\n    public void clear() {\n        this.centerBlock = null;\n        this.topBlock = null;\n        this.bottomBlock = null;\n        this.leftBlock = null;\n        this.rightBlock = null;\n    }\n\n    /**\n     * Tests this arrangement for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof BorderArrangement)) {\n            return false;\n        }\n        BorderArrangement that = (BorderArrangement) obj;\n        if (!ObjectUtilities.equal(this.topBlock, that.topBlock)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.bottomBlock, that.bottomBlock)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.leftBlock, that.leftBlock)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rightBlock, that.rightBlock)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.centerBlock, that.centerBlock)) {\n            return false;\n        }\n        return true;\n    }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"id\": 1,\n         \"description\": \"The 'add' method does not handle the case where a block is added to a non-existent edge.\",\n         \"severity\": \"MEDIUM\"\n      },\n      {\n         \"id\": 2,\n         \"description\": \"The 'arrange' method does not handle the case where a block is added to a container with a constraint that is not supported.\",\n         \"severity\": \"HIGH\"\n      },\n      {\n         \"id\": 3,\n         \"description\": \"The 'arrangeFF' method does not handle the case where the width is too small for the left and right blocks.\",\n         \"severity\": \"LOW\"\n      },\n      {\n         \"id\": 4,\n         \"description\": \"The 'arrangeFR' method is not implemented.\",\n         \"severity\": \"HIGH\"\n      },\n      {\n         \"id\": 5,\n         \"description\": \"The 'arrangeRR' method is not implemented.\",\n         \"severity\": \"HIGH\"\n      }\n   ]\n}"}}