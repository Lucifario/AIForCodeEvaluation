{"sample_id": "Math_13", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.optimization.general;\n\nimport org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction;\nimport org.apache.commons.math3.analysis.FunctionUtils;\nimport org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\nimport org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction;\nimport org.apache.commons.math3.exception.DimensionMismatchException;\nimport org.apache.commons.math3.exception.NumberIsTooSmallException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.linear.ArrayRealVector;\nimport org.apache.commons.math3.linear.RealMatrix;\nimport org.apache.commons.math3.linear.DiagonalMatrix;\nimport org.apache.commons.math3.linear.DecompositionSolver;\nimport org.apache.commons.math3.linear.MatrixUtils;\nimport org.apache.commons.math3.linear.QRDecomposition;\nimport org.apache.commons.math3.linear.EigenDecomposition;\nimport org.apache.commons.math3.optimization.OptimizationData;\nimport org.apache.commons.math3.optimization.InitialGuess;\nimport org.apache.commons.math3.optimization.Target;\nimport org.apache.commons.math3.optimization.Weight;\nimport org.apache.commons.math3.optimization.ConvergenceChecker;\nimport org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer;\nimport org.apache.commons.math3.optimization.PointVectorValuePair;\nimport org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateVectorOptimizer;\nimport org.apache.commons.math3.util.FastMath;\n\n/**\n * Base class for implementing least squares optimizers.\n * It handles the boilerplate methods associated to thresholds settings,\n * Jacobian and error estimation.\n * <br/>\n * This class constructs the Jacobian matrix of the function argument in method\n * {@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[])\n * optimize} and assumes that the rows of that matrix iterate on the model\n * functions while the columns iterate on the parameters; thus, the numbers\n * of rows is equal to the dimension of the\n * {@link org.apache.commons.math3.optimization.Target Target} while\n * the number of columns is equal to the dimension of the\n * {@link org.apache.commons.math3.optimization.InitialGuess InitialGuess}.\n *\n * @version $Id$\n * @deprecated As of 3.1 (to be removed in 4.0).\n * @since 1.2\n */\n@Deprecated\npublic abstract class AbstractLeastSquaresOptimizer\n    extends BaseAbstractMultivariateVectorOptimizer<DifferentiableMultivariateVectorFunction>\n    implements DifferentiableMultivariateVectorOptimizer {\n    /**\n     * Singularity threshold (cf. {@link #getCovariances(double)}).\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    private static final double DEFAULT_SINGULARITY_THRESHOLD = 1e-14;\n    /**\n     * Jacobian matrix of the weighted residuals.\n     * This matrix is in canonical form just after the calls to\n     * {@link #updateJacobian()}, but may be modified by the solver\n     * in the derived class (the {@link LevenbergMarquardtOptimizer\n     * Levenberg-Marquardt optimizer} does this).\n     * @deprecated As of 3.1. To be removed in 4.0. Please use\n     * {@link #computeWeightedJacobian(double[])} instead.\n     */\n    @Deprecated\n    protected double[][] weightedResidualJacobian;\n    /** Number of columns of the jacobian matrix.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected int cols;\n    /** Number of rows of the jacobian matrix.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected int rows;\n    /** Current point.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected double[] point;\n    /** Current objective function value.\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected double[] objective;\n    /** Weighted residuals\n     * @deprecated As of 3.1.\n     */\n    @Deprecated\n    protected double[] weightedResiduals;\n    /** Cost value (square root of the sum of the residuals).\n     * @deprecated As of 3.1. Field to become \"private\" in 4.0.\n     * Please use {@link #setCost(double)}.\n     */\n    @Deprecated\n    protected double cost;\n    /** Objective function derivatives. */\n    private MultivariateDifferentiableVectorFunction jF;\n    /** Number of evaluations of the Jacobian. */\n    private int jacobianEvaluations;\n    /** Square-root of the weight matrix. */\n    private RealMatrix weightMatrixSqrt;\n\n    /**\n     * Simple constructor with default settings.\n     * The convergence check is set to a {@link\n     * org.apache.commons.math3.optimization.SimpleVectorValueChecker}.\n     * @deprecated See {@link org.apache.commons.math3.optimization.SimpleValueChecker#SimpleValueChecker()}\n     */\n    @Deprecated\n    protected AbstractLeastSquaresOptimizer() {}\n\n    /**\n     * @param checker Convergence checker.\n     */\n    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }\n\n    /**\n     * @return the number of evaluations of the Jacobian function.\n     */\n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    /**\n     * Update the jacobian matrix.\n     *\n     * @throws DimensionMismatchException if the Jacobian dimension does not\n     * match problem dimension.\n     * @deprecated As of 3.1. Please use {@link #computeWeightedJacobian(double[])}\n     * instead.\n     */\n    @Deprecated\n    protected void updateJacobian() {\n        final RealMatrix weightedJacobian = computeWeightedJacobian(point);\n        weightedResidualJacobian = weightedJacobian.scalarMultiply(-1).getData();\n    }\n\n    /**\n     * Computes the Jacobian matrix.\n     *\n     * @param params Model parameters at which to compute the Jacobian.\n     * @return the weighted Jacobian: W<sup>1/2</sup> J.\n     * @throws DimensionMismatchException if the Jacobian dimension does not\n     * match problem dimension.\n     * @since 3.1\n     */\n    protected RealMatrix computeWeightedJacobian(double[] params) {\n        ++jacobianEvaluations;\n\n        final DerivativeStructure[] dsPoint = new DerivativeStructure[params.length];\n        final int nC = params.length;\n        for (int i = 0; i < nC; ++i) {\n            dsPoint[i] = new DerivativeStructure(nC, 1, i, params[i]);\n        }\n        final DerivativeStructure[] dsValue = jF.value(dsPoint);\n        final int nR = getTarget().length;\n        if (dsValue.length != nR) {\n            throw new DimensionMismatchException(dsValue.length, nR);\n        }\n        final double[][] jacobianData = new double[nR][nC];\n        for (int i = 0; i < nR; ++i) {\n            int[] orders = new int[nC];\n            for (int j = 0; j < nC; ++j) {\n                orders[j] = 1;\n                jacobianData[i][j] = dsValue[i].getPartialDerivative(orders);\n                orders[j] = 0;\n            }\n        }\n\n        return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(jacobianData));\n    }\n\n    /**\n     * Update the residuals array and cost function value.\n     * @throws DimensionMismatchException if the dimension does not match the\n     * problem dimension.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximal number of evaluations is exceeded.\n     * @deprecated As of 3.1. Please use {@link #computeResiduals(double[])},\n     * {@link #computeObjectiveValue(double[])}, {@link #computeCost(double[])}\n     * and {@link #setCost(double)} instead.\n     */\n    @Deprecated\n    protected void updateResidualsAndCost() {\n        objective = computeObjectiveValue(point);\n        final double[] res = computeResiduals(objective);\n\n        // Compute cost.\n        cost = computeCost(res);\n\n        // Compute weighted residuals.\n        final ArrayRealVector residuals = new ArrayRealVector(res);\n        weightedResiduals = weightMatrixSqrt.operate(residuals).toArray();\n    }\n\n    /**\n     * Computes the cost.\n     *\n     * @param residuals Residuals.\n     * @return the cost.\n     * @see #computeResiduals(double[])\n     * @since 3.1\n     */\n    protected double computeCost(double[] residuals) {\n        final ArrayRealVector r = new ArrayRealVector(residuals);\n        return FastMath.sqrt(r.dotProduct(getWeight().operate(r)));\n    }\n\n    /**\n     * Get the Root Mean Square value.\n     * Get the Root Mean Square value, i.e. the root of the arithmetic\n     * mean of the square of all weighted residuals. This is related to the\n     * criterion that is minimized by the optimizer as follows: if\n     * <em>c</em> if the criterion, and <em>n</em> is the number of\n     * measurements, then the RMS is <em>sqrt (c/n)</em>.\n     *\n     * @return RMS value\n     */\n    public double getRMS() {\n        return FastMath.sqrt(getChiSquare() / rows);\n    }\n\n    /**\n     * Get a Chi-Square-like value assuming the N residuals follow N\n     * distinct normal distributions centered on 0 and whose variances are\n     * the reciprocal of the weights.\n     * @return chi-square value\n     */\n    public double getChiSquare() {\n        return cost * cost;\n    }\n\n    /**\n     * Gets the square-root of the weight matrix.\n     *\n     * @return the square-root of the weight matrix.\n     * @since 3.1\n     */\n    public RealMatrix getWeightSquareRoot() {\n        return weightMatrixSqrt.copy();\n    }\n\n    /**\n     * Sets the cost.\n     *\n     * @param cost Cost value.\n     * @since 3.1\n     */\n    protected void setCost(double cost) {\n        this.cost = cost;\n    }\n\n    /**\n     * Get the covariance matrix of the optimized parameters.\n     *\n     * @return the covariance matrix.\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed (singular problem).\n     * @see #getCovariances(double)\n     * @deprecated As of 3.1. Please use {@link #computeCovariances(double[],double)}\n     * instead.\n     */\n    @Deprecated\n    public double[][] getCovariances() {\n        return getCovariances(DEFAULT_SINGULARITY_THRESHOLD);\n    }\n\n    /**\n     * Get the covariance matrix of the optimized parameters.\n     * <br/>\n     * Note that this operation involves the inversion of the\n     * <code>J<sup>T</sup>J</code> matrix, where {@code J} is the\n     * Jacobian matrix.\n     * The {@code threshold} parameter is a way for the caller to specify\n     * that the result of this computation should be considered meaningless,\n     * and thus trigger an exception.\n     *\n     * @param threshold Singularity threshold.\n     * @return the covariance matrix.\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed (singular problem).\n     * @deprecated As of 3.1. Please use {@link #computeCovariances(double[],double)}\n     * instead.\n     */\n    @Deprecated\n    public double[][] getCovariances(double threshold) {\n        return computeCovariances(point, threshold);\n    }\n\n    /**\n     * Get the covariance matrix of the optimized parameters.\n     * <br/>\n     * Note that this operation involves the inversion of the\n     * <code>J<sup>T</sup>J</code> matrix, where {@code J} is the\n     * Jacobian matrix.\n     * The {@code threshold} parameter is a way for the caller to specify\n     * that the result of this computation should be considered meaningless,\n     * and thus trigger an exception.\n     *\n     * @param params Model parameters.\n     * @param threshold Singularity threshold.\n     * @return the covariance matrix.\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed (singular problem).\n     * @since 3.1\n     */\n    public double[][] computeCovariances(double[] params,\n                                         double threshold) {\n        // Set up the Jacobian.\n        final RealMatrix j = computeWeightedJacobian(params);\n\n        // Compute transpose(J)J.\n        final RealMatrix jTj = j.transpose().multiply(j);\n\n        // Compute the covariances matrix.\n        final DecompositionSolver solver\n            = new QRDecomposition(jTj, threshold).getSolver();\n        return solver.getInverse().getData();\n    }\n\n    /**\n     * <p>\n     * Returns an estimate of the standard deviation of each parameter. The\n     * returned values are the so-called (asymptotic) standard errors on the\n     * parameters, defined as {@code sd(a[i]) = sqrt(S / (n - m) * C[i][i])},\n     * where {@code a[i]} is the optimized value of the {@code i}-th parameter,\n     * {@code S} is the minimized value of the sum of squares objective function\n     * (as returned by {@link #getChiSquare()}), {@code n} is the number of\n     * observations, {@code m} is the number of parameters and {@code C} is the\n     * covariance matrix.\n     * </p>\n     * <p>\n     * See also\n     * <a href=\"http://en.wikipedia.org/wiki/Least_squares\">Wikipedia</a>,\n     * or\n     * <a href=\"http://mathworld.wolfram.com/LeastSquaresFitting.html\">MathWorld</a>,\n     * equations (34) and (35) for a particular case.\n     * </p>\n     *\n     * @return an estimate of the standard deviation of the optimized parameters\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed.\n     * @throws NumberIsTooSmallException if the number of degrees of freedom is not\n     * positive, i.e. the number of measurements is less or equal to the number of\n     * parameters.\n     * @deprecated as of version 3.1, {@link #computeSigma(double[],double)} should be used\n     * instead. It should be emphasized that {@code guessParametersErrors} and\n     * {@code computeSigma} are <em>not</em> strictly equivalent.\n     */\n    @Deprecated\n    public double[] guessParametersErrors() {\n        if (rows <= cols) {\n            throw new NumberIsTooSmallException(LocalizedFormats.NO_DEGREES_OF_FREEDOM,\n                                                rows, cols, false);\n        }\n        double[] errors = new double[cols];\n        final double c = FastMath.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = computeCovariances(point, 1e-14);\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = FastMath.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n\n    /**\n     * Computes an estimate of the standard deviation of the parameters. The\n     * returned values are the square root of the diagonal coefficients of the\n     * covariance matrix, {@code sd(a[i]) ~= sqrt(C[i][i])}, where {@code a[i]}\n     * is the optimized value of the {@code i}-th parameter, and {@code C} is\n     * the covariance matrix.\n     *\n     * @param params Model parameters.\n     * @param covarianceSingularityThreshold Singularity threshold (see\n     * {@link #computeCovariances(double[],double) computeCovariances}).\n     * @return an estimate of the standard deviation of the optimized parameters\n     * @throws org.apache.commons.math3.linear.SingularMatrixException\n     * if the covariance matrix cannot be computed.\n     * @since 3.1\n     */\n    public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold) {\n        final int nC = params.length;\n        final double[] sig = new double[nC];\n        final double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < nC; ++i) {\n            sig[i] = FastMath.sqrt(cov[i][i]);\n        }\n        return sig;\n    }\n\n    /** {@inheritDoc}\n     * @deprecated As of 3.1. Please use\n     * {@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[])\n     * optimize(int,MultivariateDifferentiableVectorFunction,OptimizationData...)}\n     * instead.\n     */\n    @Override\n    @Deprecated\n    public PointVectorValuePair optimize(int maxEval,\n                                         final DifferentiableMultivariateVectorFunction f,\n                                         final double[] target, final double[] weights,\n                                         final double[] startPoint) {\n        return optimizeInternal(maxEval,\n                                FunctionUtils.toMultivariateDifferentiableVectorFunction(f),\n                                new Target(target),\n                                new Weight(weights),\n                                new InitialGuess(startPoint));\n    }\n\n    /**\n     * Optimize an objective function.\n     * Optimization is considered to be a weighted least-squares minimization.\n     * The cost function to be minimized is\n     * <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>\n     *\n     * @param f Objective function.\n     * @param target Target value for the objective functions at optimum.\n     * @param weights Weights for the least squares cost computation.\n     * @param startPoint Start point for optimization.\n     * @return the point/value pair giving the optimal value for objective\n     * function.\n     * @param maxEval Maximum number of function evaluations.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the start point dimension is wrong.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the maximal number of evaluations is exceeded.\n     * @throws org.apache.commons.math3.exception.NullArgumentException if\n     * any argument is {@code null}.\n     * @deprecated As of 3.1. Please use\n     * {@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[])\n     * optimize(int,MultivariateDifferentiableVectorFunction,OptimizationData...)}\n     * instead.\n     */\n    @Deprecated\n    public PointVectorValuePair optimize(final int maxEval,\n                                         final MultivariateDifferentiableVectorFunction f,\n                                         final double[] target, final double[] weights,\n                                         final double[] startPoint) {\n        return optimizeInternal(maxEval, f,\n                                new Target(target),\n                                new Weight(weights),\n                                new InitialGuess(startPoint));\n    }\n\n    /**\n     * Optimize an objective function.\n     * Optimization is considered to be a weighted least-squares minimization.\n     * The cost function to be minimized is\n     * <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>\n     *\n     * @param maxEval Allowed number of evaluations of the objective function.\n     * @param f Objective function.\n     * @param optData Optimization data. The following data will be looked for:\n     * <ul>\n     *  <li>{@link Target}</li>\n     *  <li>{@link Weight}</li>\n     *  <li>{@link InitialGuess}</li>\n     * </ul>\n     * @return the point/value pair giving the optimal value of the objective\n     * function.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if\n     * the maximal number of evaluations is exceeded.\n     * @throws DimensionMismatchException if the target, and weight arguments\n     * have inconsistent dimensions.\n     * @see BaseAbstractMultivariateVectorOptimizer#optimizeInternal(int,MultivariateVectorFunction,OptimizationData[])\n     * @since 3.1\n     * @deprecated As of 3.1. Override is necessary only until this class's generic\n     * argument is changed to {@code MultivariateDifferentiableVectorFunction}.\n     */\n    @Deprecated\n    protected PointVectorValuePair optimizeInternal(final int maxEval,\n                                                    final MultivariateDifferentiableVectorFunction f,\n                                                    OptimizationData... optData) {\n        // XXX Conversion will be removed when the generic argument of the\n        // base class becomes \"MultivariateDifferentiableVectorFunction\".\n        return super.optimizeInternal(maxEval, FunctionUtils.toDifferentiableMultivariateVectorFunction(f), optData);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected void setUp() {\n        super.setUp();\n\n        // Reset counter.\n        jacobianEvaluations = 0;\n\n        // Square-root of the weight matrix.\n        weightMatrixSqrt = squareRoot(getWeight());\n\n        // Store least squares problem characteristics.\n        // XXX The conversion won't be necessary when the generic argument of\n        // the base class becomes \"MultivariateDifferentiableVectorFunction\".\n        // XXX \"jF\" is not strictly necessary anymore but is currently more\n        // efficient than converting the value returned from \"getObjectiveFunction()\"\n        // every time it is used.\n        jF = FunctionUtils.toMultivariateDifferentiableVectorFunction((DifferentiableMultivariateVectorFunction) getObjectiveFunction());\n\n        // Arrays shared with \"private\" and \"protected\" methods.\n        point = getStartPoint();\n        rows = getTarget().length;\n        cols = point.length;\n    }\n\n    /**\n     * Computes the residuals.\n     * The residual is the difference between the observed (target)\n     * values and the model (objective function) value.\n     * There is one residual for each element of the vector-valued\n     * function.\n     *\n     * @param objectiveValue Value of the the objective function. This is\n     * the value returned from a call to\n     * {@link #computeObjectiveValue(double[]) computeObjectiveValue}\n     * (whose array argument contains the model parameters).\n     * @return the residuals.\n     * @throws DimensionMismatchException if {@code params} has a wrong\n     * length.\n     * @since 3.1\n     */\n    protected double[] computeResiduals(double[] objectiveValue) {\n        final double[] target = getTarget();\n        if (objectiveValue.length != target.length) {\n            throw new DimensionMismatchException(target.length,\n                                                 objectiveValue.length);\n        }\n\n        final double[] residuals = new double[target.length];\n        for (int i = 0; i < target.length; i++) {\n            residuals[i] = target[i] - objectiveValue[i];\n        }\n\n        return residuals;\n    }\n\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n    private RealMatrix squareRoot(RealMatrix m) {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n    }\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"line\": 78,\n      \"description\": \"The field 'weightedResidualJacobian' is deprecated and should not be used. Use 'computeWeightedJacobian(double[])' instead.\"\n    },\n    {\n      \"line\": 80,\n      \"description\": \"The field 'cols' is deprecated and should not be used.\"\n    },\n    {\n      \"line\": 82,\n      \"description\": \"The field 'rows' is deprecated and should not be used.\"\n    },\n    {\n      \"line\": 84,\n      \"description\": \"The field 'point' is deprecated and should not be used.\"\n    },\n    {\n      \"line\": 86,\n      \"description\": \"The field 'objective' is deprecated and should not be used.\"\n    },\n    {\n      \"line\": 88,\n      \"description\": \"The field 'weightedResiduals' is deprecated and should not be used.\"\n    },\n    {\n      \"line\": 90,\n      \"description\": \"The field 'cost' is deprecated and should not be used. Use 'setCost(double)' instead.\"\n    },\n    {\n      \"line\": 94,\n      \"description\": \"The constructor 'AbstractLeastSquaresOptimizer()' is deprecated. Use a constructor that takes a ConvergenceChecker instead.\"\n    }\n  ]\n}"}}