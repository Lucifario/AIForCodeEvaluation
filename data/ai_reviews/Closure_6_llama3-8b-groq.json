{"sample_id": "Closure_6", "model": "llama3-8b-groq", "code_context": "/*\n * Copyright 2009 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_STRING;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n\nimport com.google.common.base.Objects;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.rhino.jstype.JSTypeNative;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\nimport com.google.javascript.rhino.jstype.ObjectType;\nimport com.google.javascript.rhino.jstype.StaticSlot;\nimport com.google.javascript.rhino.jstype.UnknownType;\n\nimport java.text.MessageFormat;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * A central reporter for all type violations: places where the programmer\n * has annotated a variable (or property) with one type, but has assigned\n * another type to it.\n *\n * Also doubles as a central repository for all type violations, so that\n * type-based optimizations (like AmbiguateProperties) can be fault-tolerant.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nclass TypeValidator {\n\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry typeRegistry;\n  private final JSType allValueTypes;\n  private boolean shouldReport = true;\n  private final JSType nullOrUndefined;\n\n  // TODO(nicksantos): Provide accessors to better filter the list of type\n  // mismatches. For example, if we pass (Cake|null) where only Cake is\n  // allowed, that doesn't mean we should invalidate all Cakes.\n  private final List<TypeMismatch> mismatches = Lists.newArrayList();\n\n  // User warnings\n  private static final String FOUND_REQUIRED =\n      \"{0}\\n\" +\n      \"found   : {1}\\n\" +\n      \"required: {2}\";\n\n  static final DiagnosticType INVALID_CAST =\n      DiagnosticType.warning(\"JSC_INVALID_CAST\",\n          \"invalid cast - must be a subtype or supertype\\n\" +\n          \"from: {0}\\n\" +\n          \"to  : {1}\");\n\n  static final DiagnosticType TYPE_MISMATCH_WARNING =\n      DiagnosticType.warning(\n          \"JSC_TYPE_MISMATCH\",\n          \"{0}\");\n\n  static final DiagnosticType MISSING_EXTENDS_TAG_WARNING =\n      DiagnosticType.warning(\n          \"JSC_MISSING_EXTENDS_TAG\",\n          \"Missing @extends tag on type {0}\");\n\n  static final DiagnosticType DUP_VAR_DECLARATION =\n      DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\",\n          \"variable {0} redefined with type {1}, \" +\n          \"original definition at {2}:{3} with type {4}\");\n\n  static final DiagnosticType HIDDEN_PROPERTY_MISMATCH =\n      DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\",\n          \"mismatch of the {0} property type and the type \" +\n          \"of the property it overrides from superclass {1}\\n\" +\n          \"original: {2}\\n\" +\n          \"override: {3}\");\n\n  static final DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED =\n      DiagnosticType.warning(\n          \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\",\n          \"property {0} on interface {1} is not implemented by type {2}\");\n\n  static final DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH =\n      DiagnosticType.warning(\n        \"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\",\n        \"mismatch of the {0} property type and the type \" +\n        \"of the property it overrides from interface {1}\\n\" +\n        \"original: {2}\\n\" +\n        \"override: {3}\");\n\n  static final DiagnosticType UNKNOWN_TYPEOF_VALUE =\n      DiagnosticType.warning(\"JSC_UNKNOWN_TYPEOF_VALUE\", \"unknown type: {0}\");\n\n  static final DiagnosticType ILLEGAL_PROPERTY_ACCESS =\n      DiagnosticType.warning(\"JSC_ILLEGAL_PROPERTY_ACCESS\",\n                             \"Cannot do {0} access on a {1}\");\n\n  static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup(\n      INVALID_CAST,\n      TYPE_MISMATCH_WARNING,\n      MISSING_EXTENDS_TAG_WARNING,\n      DUP_VAR_DECLARATION,\n      HIDDEN_PROPERTY_MISMATCH,\n      INTERFACE_METHOD_NOT_IMPLEMENTED,\n      HIDDEN_INTERFACE_PROPERTY_MISMATCH,\n      UNKNOWN_TYPEOF_VALUE,\n      ILLEGAL_PROPERTY_ACCESS);\n\n  TypeValidator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.allValueTypes = typeRegistry.createUnionType(\n        STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);\n    this.nullOrUndefined = typeRegistry.createUnionType(\n        NULL_TYPE, VOID_TYPE);\n  }\n\n  /**\n   * Gets a list of type violations.\n   *\n   * For each violation, one element is the expected type and the other is\n   * the type that is actually found. Order is not significant.\n   */\n  Iterable<TypeMismatch> getMismatches() {\n    return mismatches;\n  }\n\n  void setShouldReport(boolean report) {\n    this.shouldReport = report;\n  }\n\n  // All non-private methods should have the form:\n  // expectCondition(NodeTraversal t, Node n, ...);\n  // If there is a mismatch, the {@code expect} method should issue\n  // a warning and attempt to correct the mismatch, when possible.\n\n  void expectValidTypeofName(NodeTraversal t, Node n, String found) {\n    report(JSError.make(t.getSourceName(), n, UNKNOWN_TYPEOF_VALUE, found));\n  }\n\n  /**\n   * Expect the type to be an object, or a type convertible to object. If the\n   * expectation is not met, issue a warning at the provided node's source code\n   * position.\n   * @return True if there was no warning, false if there was a mismatch.\n   */\n  boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesObjectContext()) {\n      mismatch(t, n, msg, type, OBJECT_TYPE);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Expect the type to be an object. Unlike expectObject, a type convertible\n   * to object is not acceptable.\n   */\n  void expectActualObject(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.isObject()) {\n      mismatch(t, n, msg, type, OBJECT_TYPE);\n    }\n  }\n\n  /**\n   * Expect the type to contain an object sometimes. If the expectation is\n   * not met, issue a warning at the provided node's source code position.\n   */\n  void expectAnyObject(NodeTraversal t, Node n, JSType type, String msg) {\n    JSType anyObjectType = getNativeType(NO_OBJECT_TYPE);\n    if (!anyObjectType.isSubtype(type) && !type.isEmptyType()) {\n      mismatch(t, n, msg, type, anyObjectType);\n    }\n  }\n\n  /**\n   * Expect the type to be a string, or a type convertible to string. If the\n   * expectation is not met, issue a warning at the provided node's source code\n   * position.\n   */\n  void expectString(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesStringContext()) {\n      mismatch(t, n, msg, type, STRING_TYPE);\n    }\n  }\n\n  /**\n   * Expect the type to be a number, or a type convertible to number. If the\n   * expectation is not met, issue a warning at the provided node's source code\n   * position.\n   */\n  void expectNumber(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesNumberContext()) {\n      mismatch(t, n, msg, type, NUMBER_TYPE);\n    }\n  }\n\n  /**\n   * Expect the type to be a valid operand to a bitwise operator. This includes\n   * numbers, any type convertible to a number, or any other primitive type\n   * (undefined|null|boolean|string).\n   */\n  void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) {\n      mismatch(t, n, msg, type, allValueTypes);\n    }\n  }\n\n  /**\n   * Expect the type to be a number or string, or a type convertible to a number\n   * or string. If the expectation is not met, issue a warning at the provided\n   * node's source code position.\n   */\n  void expectStringOrNumber(\n      NodeTraversal t, Node n, JSType type, String msg) {\n    if (!type.matchesNumberContext() && !type.matchesStringContext()) {\n      mismatch(t, n, msg, type, NUMBER_STRING);\n    }\n  }\n\n  /**\n   * Expect the type to be anything but the null or void type. If the\n   * expectation is not met, issue a warning at the provided node's\n   * source code position. Note that a union type that includes the\n   * void type and at least one other type meets the expectation.\n   * @return Whether the expectation was met.\n   */\n  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        type.isSubtype(nullOrUndefined) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      // There's one edge case right now that we don't handle well, and\n      // that we don't want to warn about.\n      // if (this.x == null) {\n      //   this.initializeX();\n      //   this.x.foo();\n      // }\n      // In this case, we incorrectly type x because of how we\n      // infer properties locally. See issue 109.\n      // http://code.google.com/p/closure-compiler/issues/detail?id=109\n      //\n      // We do not do this inference globally.\n      if (n.isGetProp() &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }\n\n  private boolean containsForwardDeclaredUnresolvedName(JSType type) {\n    if (type.isUnionType()) {\n      for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n        if (containsForwardDeclaredUnresolvedName(alt)) {\n          return true;\n        }\n      }\n    }\n    return type.isNoResolvedType();\n  }\n\n  /**\n   * Expect that the type of a switch condition matches the type of its\n   * case condition.\n   */\n  void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType,\n      JSType caseType) {\n    // ECMA-262, page 68, step 3 of evaluation of CaseBlock,\n    // but allowing extra autoboxing.\n    // TODO(user): remove extra conditions when type annotations\n    // in the code base have adapted to the change in the compiler.\n    if (!switchType.canTestForShallowEqualityWith(caseType) &&\n        (caseType.autoboxesTo() == null ||\n            !caseType.autoboxesTo().isSubtype(switchType))) {\n      mismatch(t, n.getFirstChild(),\n          \"case expression doesn't match switch\",\n          caseType, switchType);\n    }\n  }\n\n  /**\n   * Expect that the first type can be addressed with GETELEM syntax,\n   * and that the second type is the right type for an index into the\n   * first type.\n   *\n   * @param t The node traversal.\n   * @param n The GETELEM node to issue warnings on.\n   * @param objType The type of the left side of the GETELEM.\n   * @param indexType The type inside the brackets of the GETELEM.\n   */\n  void expectIndexMatch(NodeTraversal t, Node n, JSType objType,\n                        JSType indexType) {\n    Preconditions.checkState(n.isGetElem());\n    Node indexNode = n.getLastChild();\n    if (objType.isStruct()) {\n      report(JSError.make(t.getSourceName(), indexNode,\n                          ILLEGAL_PROPERTY_ACCESS, \"'[]'\", \"struct\"));\n    }\n    if (objType.isUnknownType()) {\n      expectStringOrNumber(t, indexNode, indexType, \"property access\");\n    } else {\n      ObjectType dereferenced = objType.dereference();\n      if (dereferenced != null && dereferenced.getIndexType() != null) {\n        expectCanAssignTo(t, indexNode, indexType, dereferenced.getIndexType(),\n            \"restricted index type\");\n      } else if (dereferenced != null && dereferenced.isArrayType()) {\n        expectNumber(t, indexNode, indexType, \"array access\");\n      } else if (objType.matchesObjectContext()) {\n        expectString(t, indexNode, indexType, \"property access\");\n      } else {\n        mismatch(t, n, \"only arrays or objects can be accessed\",\n            objType,\n            typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE));\n      }\n    }\n  }\n\n  /**\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param owner The owner of the property being assigned to.\n   * @param propName The name of the property being assigned to.\n   * @return True if the types matched, false otherwise.\n   */\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param msg An extra message for the mismatch warning, if necessary.\n   * @return True if the types matched, false otherwise.\n   */\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Expect that the type of an argument matches the type of the parameter\n   * that it's fulfilling.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param argType The type of the argument.\n   * @param paramType The type of the parameter.\n   * @param callNode The call node, to help with the warning message.\n   * @param ordinal The argument ordinal, to help with the warning message.\n   */\n  void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType,\n      JSType paramType, Node callNode, int ordinal) {\n    if (!argType.canAssignTo(paramType)) {\n      mismatch(t, n,\n          String.format(\"actual parameter %d of %s does not match \" +\n              \"formal parameter\", ordinal,\n              getReadableJSTypeName(callNode.getFirstChild(), false)),\n          argType, paramType);\n    }\n  }\n\n  /**\n   * Expect that the first type can override a property of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param overridingType The overriding type.\n   * @param hiddenType The type of the property being overridden.\n   * @param propertyName The name of the property, for use in the\n   *     warning message.\n   * @param ownerType The type of the owner of the property, for use\n   *     in the warning message.\n   */\n  void expectCanOverride(NodeTraversal t, Node n, JSType overridingType,\n      JSType hiddenType, String propertyName, JSType ownerType) {\n    if (!overridingType.canAssignTo(hiddenType)) {\n      registerMismatch(overridingType, hiddenType,\n          report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName,\n            ownerType.toString(), hiddenType.toString(),\n            overridingType.toString())));\n    }\n  }\n\n  /**\n   * Expect that the first type is the direct superclass of the second type.\n   *\n   * @param t The node traversal.\n   * @param n The node where warnings should point to.\n   * @param superObject The expected super instance type.\n   * @param subObject The sub instance type.\n   */\n  void expectSuperType(NodeTraversal t, Node n, ObjectType superObject,\n      ObjectType subObject) {\n    FunctionType subCtor = subObject.getConstructor();\n    ObjectType implicitProto = subObject.getImplicitPrototype();\n    ObjectType declaredSuper =\n        implicitProto == null ? null : implicitProto.getImplicitPrototype();\n    if (declaredSuper != null &&\n        !(superObject instanceof UnknownType) &&\n        !declaredSuper.isEquivalentTo(superObject)) {\n      if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) {\n        registerMismatch(superObject, declaredSuper, report(\n            t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())));\n      } else {\n        mismatch(t.getSourceName(), n,\n            \"mismatch in declaration of superclass type\",\n            superObject, declaredSuper);\n      }\n\n      // Correct the super type.\n      if (!subCtor.hasCachedValues()) {\n        subCtor.setPrototypeBasedOn(superObject);\n      }\n    }\n  }\n\n  /**\n   * Expect that the first type can be cast to the second type. The first type\n   * should be either a subtype or supertype of the second.\n   *\n   * @param t The node traversal.\n   * @param n The node where warnings should point.\n   * @param type The type being cast from.\n   * @param castType The type being cast to.\n   */\n  void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) {\n    castType = castType.restrictByNotNullOrUndefined();\n    type = type.restrictByNotNullOrUndefined();\n\n    if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) {\n      registerMismatch(type, castType, report(t.makeError(n, INVALID_CAST,\n          castType.toString(), type.toString())));\n    }\n  }\n\n  /**\n   * Expect that the given variable has not been declared with a type.\n   *\n   * @param sourceName The name of the source file we're in.\n   * @param n The node where warnings should point to.\n   * @param parent The parent of {@code n}.\n   * @param var The variable that we're checking.\n   * @param variableName The name of the variable.\n   * @param newType The type being applied to the variable. Mostly just here\n   *     for the benefit of the warning.\n   * @return The variable we end up with. Most of the time, this will just\n   *     be {@code var}, but in some rare cases we will need to declare\n   *     a new var with new source info.\n   */\n  Var expectUndeclaredVariable(String sourceName, CompilerInput input,\n      Node n, Node parent, Var var, String variableName, JSType newType) {\n    Var newVar = var;\n    boolean allowDupe = false;\n    if (n.isGetProp() ||\n        NodeUtil.isObjectLitKey(n, parent)) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info == null) {\n        info = parent.getJSDocInfo();\n      }\n      allowDupe =\n          info != null && info.getSuppressions().contains(\"duplicate\");\n    }\n\n    JSType varType = var.getType();\n\n    // Only report duplicate declarations that have types. Other duplicates\n    // will be reported by the syntactic scope creator later in the\n    // compilation process.\n    if (varType != null &&\n        varType != typeRegistry.getNativeType(UNKNOWN_TYPE) &&\n        newType != null &&\n        newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {\n      // If there are two typed declarations of the same variable, that\n      // is an error and the second declaration is ignored, except in the\n      // case of native types. A null input type means that the declaration\n      // was made in TypedScopeCreator#createInitialScope and is a\n      // native type. We should redeclare it at the new input site.\n      if (var.input == null) {\n        Scope s = var.getScope();\n        s.undeclare(var);\n        newVar = s.declare(variableName, n, varType, input, false);\n\n        n.setJSType(varType);\n        if (parent.isVar()) {\n          if (n.getFirstChild() != null) {\n            n.getFirstChild().setJSType(varType);\n          }\n        } else {\n          Preconditions.checkState(parent.isFunction());\n          parent.setJSType(varType);\n        }\n      } else {\n        // Always warn about duplicates if the overridden type does not\n        // match the original type.\n        //\n        // If the types match, suppress the warning iff there was a @suppress\n        // tag, or if the original declaration was a stub.\n        if (!(allowDupe ||\n              var.getParentNode().isExprResult()) ||\n            !newType.isEquivalentTo(varType)) {\n          report(JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n              variableName, newType.toString(), var.getInputName(),\n              String.valueOf(var.nameNode.getLineno()),\n              varType.toString()));\n        }\n      }\n    }\n\n    return newVar;\n  }\n\n  /**\n   * Expect that all properties on interfaces that this type implements are\n   * implemented and correctly typed.\n   */\n  void expectAllInterfaceProperties(NodeTraversal t, Node n,\n      FunctionType type) {\n    ObjectType instance = type.getInstanceType();\n    for (ObjectType implemented : type.getAllImplementedInterfaces()) {\n      if (implemented.getImplicitPrototype() != null) {\n        for (String prop :\n             implemented.getImplicitPrototype().getOwnPropertyNames()) {\n          expectInterfaceProperty(t, n, instance, implemented, prop);\n        }\n      }\n    }\n  }\n\n  /**\n   * Expect that the property in an interface that this type implements is\n   * implemented and correctly typed.\n   */\n  private void expectInterfaceProperty(NodeTraversal t, Node n,\n      ObjectType instance, ObjectType implementedInterface, String prop) {\n    StaticSlot<JSType> propSlot = instance.getSlot(prop);\n    if (propSlot == null) {\n      // Not implemented\n      String sourceName = n.getSourceFileName();\n      sourceName = sourceName == null ? \"\" : sourceName;\n      registerMismatch(instance, implementedInterface,\n          report(JSError.make(sourceName, n,\n          INTERFACE_METHOD_NOT_IMPLEMENTED,\n          prop, implementedInterface.toString(), instance.toString())));\n    } else {\n      Node propNode = propSlot.getDeclaration() == null ?\n          null : propSlot.getDeclaration().getNode();\n\n      // Fall back on the constructor node if we can't find a node for the\n      // property.\n      propNode = propNode == null ? n : propNode;\n\n      JSType found = propSlot.getType();\n      JSType required\n          = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n      found = found.restrictByNotNullOrUndefined();\n      required = required.restrictByNotNullOrUndefined();\n      if (!found.canAssignTo(required)) {\n        // Implemented, but not correctly typed\n        FunctionType constructor =\n            implementedInterface.toObjectType().getConstructor();\n        registerMismatch(found, required, report(t.makeError(propNode,\n            HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop,\n            constructor.getTopMostDefiningType(prop).toString(),\n            required.toString(), found.toString())));\n      }\n    }\n  }\n\n  /**\n   * Report a type mismatch\n   */\n  private void mismatch(NodeTraversal t, Node n,\n                        String msg, JSType found, JSType required) {\n    mismatch(t.getSourceName(), n, msg, found, required);\n  }\n\n  private void mismatch(NodeTraversal t, Node n,\n                        String msg, JSType found, JSTypeNative required) {\n    mismatch(t, n, msg, found, getNativeType(required));\n  }\n\n  private void mismatch(String sourceName, Node n,\n                        String msg, JSType found, JSType required) {\n    registerMismatch(found, required, report(\n        JSError.make(sourceName, n, TYPE_MISMATCH_WARNING,\n                     formatFoundRequired(msg, found, required))));\n  }\n\n  private void registerMismatch(JSType found, JSType required, JSError error) {\n    // Don't register a mismatch for differences in null or undefined or if the\n    // code didn't downcast.\n    found = found.restrictByNotNullOrUndefined();\n    required = required.restrictByNotNullOrUndefined();\n    if (found.canAssignTo(required) || required.canAssignTo(found)) {\n      return;\n    }\n\n    mismatches.add(new TypeMismatch(found, required, error));\n    if (found.isFunctionType() &&\n        required.isFunctionType()) {\n      FunctionType fnTypeA = found.toMaybeFunctionType();\n      FunctionType fnTypeB = required.toMaybeFunctionType();\n      Iterator<Node> paramItA = fnTypeA.getParameters().iterator();\n      Iterator<Node> paramItB = fnTypeB.getParameters().iterator();\n      while (paramItA.hasNext() && paramItB.hasNext()) {\n        registerIfMismatch(paramItA.next().getJSType(),\n            paramItB.next().getJSType(), error);\n      }\n\n      registerIfMismatch(\n          fnTypeA.getReturnType(), fnTypeB.getReturnType(), error);\n    }\n  }\n\n  private void registerIfMismatch(\n      JSType found, JSType required, JSError error) {\n    if (found != null && required != null &&\n        !found.canAssignTo(required)) {\n      registerMismatch(found, required, error);\n    }\n  }\n\n  /**\n   * Formats a found/required error message.\n   */\n  private String formatFoundRequired(String description, JSType found,\n      JSType required) {\n    return MessageFormat.format(FOUND_REQUIRED, description, found, required);\n  }\n\n  /**\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\".\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible.\n   */\n  String getReadableJSTypeName(Node n, boolean dereference) {\n    // If we're analyzing a GETPROP, the property may be inherited by the\n    // prototype chain. So climb the prototype chain and find out where\n    // the property was originally defined.\n    if (n.isGetProp()) {\n      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          objectType = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n        } else {\n          // classes\n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        // Don't show complex function names or anonymous types.\n        // Instead, try to get a human-readable type name.\n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n\n    String qualifiedName = n.getQualifiedName();\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      return type.toString();\n    } else if (qualifiedName != null) {\n      return qualifiedName;\n    } else if (type.isFunctionType()) {\n      // Don't show complex function names.\n      return \"function\";\n    } else {\n      return type.toString();\n    }\n  }\n\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(user): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }\n\n  private JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }\n\n  private JSError report(JSError error) {\n    if (shouldReport) {\n      compiler.report(error);\n    }\n    return error;\n  }\n\n  /**\n   * Signals that the first type and the second type have been\n   * used interchangeably.\n   *\n   * Type-based optimizations should take this into account\n   * so that they don't wreck code with type warnings.\n   */\n  static class TypeMismatch {\n    final JSType typeA;\n    final JSType typeB;\n    final JSError src;\n\n    /**\n     * It's the responsibility of the class that creates the\n     * {@code TypeMismatch} to ensure that {@code a} and {@code b} are\n     * non-matching types.\n     */\n    TypeMismatch(JSType a, JSType b, JSError src) {\n      this.typeA = a;\n      this.typeB = b;\n      this.src = src;\n    }\n\n    @Override public boolean equals(Object object) {\n      if (object instanceof TypeMismatch) {\n        TypeMismatch that = (TypeMismatch) object;\n        return (that.typeA.isEquivalentTo(this.typeA)\n                && that.typeB.isEquivalentTo(this.typeB))\n            || (that.typeB.isEquivalentTo(this.typeA)\n                && that.typeA.isEquivalentTo(this.typeB));\n      }\n      return false;\n    }\n\n    @Override public int hashCode() {\n      return Objects.hashCode(typeA, typeB);\n    }\n\n    @Override public String toString() {\n      return \"(\" + typeA + \", \" + typeB + \")\";\n    }\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"id\": \"NullPointerException\",\n         \"description\": \"The compiler will throw a NullPointerException when trying to access a null object reference.\"\n      },\n      {\n         \"id\": \"Missing @extends tag\",\n         \"description\": \"The compiler will throw a warning when a class is missing the @extends tag.\"\n      },\n      {\n         \"id\": \"Duplicated variable declaration\",\n         \"description\": \"The compiler will throw a warning when a variable is redeclared with a different type.\"\n      },\n      {\n         \"id\": \"Hidden property type mismatch\",\n         \"description\": \"The compiler will throw a warning when a property's type does not match the type of the property it overrides.\"\n      },\n      {\n         \"id\": \"Interface method not implemented\",\n         \"description\": \"The compiler will throw a warning when a class does not implement an interface method.\"\n      },\n      {\n         \"id\": \"Hidden interface property type mismatch\",\n         \"description\": \"The compiler will throw a warning when a property's type does not match the type of the property it overrides from an interface.\"\n      },\n      {\n         \"id\": \"Unknown typeof value\",\n         \"description\": \"The compiler will throw a warning when trying to access a property with an unknown type.\"\n      },\n      {\n         \"id\": \"Illegal property access\",\n         \"description\": \"The compiler will throw a warning when trying to access a property that does not exist or is not accessible.\"\n      }\n   ]\n}"}}