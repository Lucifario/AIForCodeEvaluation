{"sample_id": "Mockito_36", "model": "mistral-nemo", "code_context": "/*\n * Copyright (c) 2007 Mockito contributors\n * This program is made available under the terms of the MIT License.\n */\npackage org.mockito.internal.invocation;\n\nimport java.util.*;\n\nimport org.hamcrest.Matcher;\nimport org.mockito.exceptions.PrintableInvocation;\nimport org.mockito.internal.debugging.Location;\nimport org.mockito.internal.invocation.realmethod.RealMethod;\nimport org.mockito.internal.matchers.*;\nimport org.mockito.internal.reporting.PrintSettings;\nimport org.mockito.internal.reporting.PrintingFriendlyInvocation;\nimport org.mockito.internal.util.*;\nimport org.mockito.invocation.InvocationOnMock;\n\n/**\n * Method call on a mock object.\n * <p>\n * Contains sequence number which should be globally unique and is used for\n * verification in order.\n * <p>\n * Contains stack trace of invocation\n */\n@SuppressWarnings(\"unchecked\")\npublic class Invocation implements PrintableInvocation, InvocationOnMock, PrintingFriendlyInvocation {\n\n    private static final long serialVersionUID = 8240069639250980199L;\n    private static final int MAX_LINE_LENGTH = 45;\n    private final int sequenceNumber;\n    private final Object mock;\n    private final MockitoMethod method;\n    private final Object[] arguments;\n    private final Object[] rawArguments;\n\n    private final Location location;\n    private boolean verified;\n    private boolean verifiedInOrder;\n\n    final RealMethod realMethod;\n\n    public Invocation(Object mock, MockitoMethod mockitoMethod, Object[] args, int sequenceNumber, RealMethod realMethod) {\n        this.method = mockitoMethod;\n        this.mock = mock;\n        this.realMethod = realMethod;\n        this.arguments = expandVarArgs(mockitoMethod.isVarArgs(), args);\n        this.rawArguments = args;\n        this.sequenceNumber = sequenceNumber;\n        this.location = new Location();\n    }\n\n    // expands array varArgs that are given by runtime (1, [a, b]) into true\n    // varArgs (1, a, b);\n    private static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {\n        if (!isVarArgs || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {\n            return args == null ? new Object[0] : args;\n        }\n\n        final int nonVarArgsCount = args.length - 1;\n        Object[] varArgs;\n        if (args[nonVarArgsCount] == null) {\n            // in case someone deliberately passed null varArg array\n            varArgs = new Object[] { null };\n        } else {\n            varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);\n        }\n        final int varArgsCount = varArgs.length;\n        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];\n        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);\n        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);\n        return newArgs;\n    }\n\n    public Object getMock() {\n        return mock;\n    }\n\n    public MockitoMethod getMethod() {\n        return method;\n    }\n\n    public Object[] getArguments() {\n        return arguments;\n    }\n\n    public boolean isVerified() {\n        return verified;\n    }\n\n    public Integer getSequenceNumber() {\n        return sequenceNumber;\n    }\n\n    public boolean isVerifiedInOrder() {\n        return verifiedInOrder;\n    }\n\n    public boolean equals(Object o) {\n        if (o == null || !o.getClass().equals(this.getClass())) {\n            return false;\n        }\n\n        Invocation other = (Invocation) o;\n\n        return this.mock.equals(other.mock) && this.method.equals(other.method) && this.equalArguments(other.arguments);\n    }\n\n    private boolean equalArguments(Object[] arguments) {\n        return Arrays.equals(arguments, this.arguments);\n    }\n\n    public int hashCode() {\n        throw new RuntimeException(\"hashCode() is not implemented\");\n    }\n\n    public String toString() {\n        return toString(argumentsToMatchers(), new PrintSettings());\n    }\n\n    protected String toString(List<Matcher> matchers, PrintSettings printSettings) {\n        MatchersPrinter matchersPrinter = new MatchersPrinter();\n        String method = qualifiedMethodName();\n        String invocation = method + matchersPrinter.getArgumentsLine(matchers, printSettings);\n        if (printSettings.isMultiline() || (!matchers.isEmpty() && invocation.length() > MAX_LINE_LENGTH)) {\n            return method + matchersPrinter.getArgumentsBlock(matchers, printSettings);\n        } else {\n            return invocation;\n        }\n    }\n\n    private String qualifiedMethodName() {\n        return new MockUtil().getMockName(mock) + \".\" + method.getName();\n    }\n\n    protected List<Matcher> argumentsToMatchers() {\n        List<Matcher> matchers = new ArrayList<Matcher>(arguments.length);\n        for (Object arg : arguments) {\n            if (arg != null && arg.getClass().isArray()) {\n                matchers.add(new ArrayEquals(arg));\n            } else {\n                matchers.add(new Equals(arg));\n            }\n        }\n        return matchers;\n    }\n\n    public static boolean isToString(InvocationOnMock invocation) {\n        return new ObjectMethodsGuru().isToString(invocation.getMethod());\n    }\n\n    public boolean isValidException(Throwable throwable) {\n        Class<?>[] exceptions = this.getMethod().getExceptionTypes();\n        Class<?> throwableClass = throwable.getClass();\n        for (Class<?> exception : exceptions) {\n            if (exception.isAssignableFrom(throwableClass)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public boolean isValidReturnType(Class clazz) {\n        if (method.getReturnType().isPrimitive()) {\n            return Primitives.primitiveTypeOf(clazz) == method.getReturnType();\n        } else {\n            return method.getReturnType().isAssignableFrom(clazz);\n        }\n    }\n\n    public boolean isVoid() {\n        return this.method.getReturnType() == Void.TYPE;\n    }\n\n    public String printMethodReturnType() {\n        return method.getReturnType().getSimpleName();\n    }\n\n    public String getMethodName() {\n        return method.getName();\n    }\n\n    public boolean returnsPrimitive() {\n        return method.getReturnType().isPrimitive();\n    }\n\n    public Location getLocation() {\n        return location;\n    }\n\n    public int getArgumentsCount() {\n        return arguments.length;\n    }\n\n    public Object[] getRawArguments() {\n        return this.rawArguments;\n    }\n\n    public Object callRealMethod() throws Throwable {\n        return realMethod.invoke(mock, rawArguments);\n    }\n\n    public String toString(PrintSettings printSettings) {\n        return toString(argumentsToMatchers(), printSettings);\n    }\n\n    void markVerified() {\n        this.verified = true;\n    }\n\n    void markVerifiedInOrder() {\n        markVerified();\n        this.verifiedInOrder = true;\n    }\n}", "review": {"response": "{\"bugs\": []}"}}