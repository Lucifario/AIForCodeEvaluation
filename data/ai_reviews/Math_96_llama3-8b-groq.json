{"sample_id": "Math_96", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.complex;\n\nimport java.io.Serializable;\nimport org.apache.commons.math.util.MathUtils;\n\n/**\n * Representation of a Complex number - a number which has both a \n * real and imaginary part.\n * <p>\n * Implementations of arithmetic operations handle <code>NaN</code> and\n * infinite values according to the rules for {@link java.lang.Double}\n * arithmetic, applying definitional formulas and returning <code>NaN</code> or\n * infinite values in real or imaginary parts as these arise in computation. \n * See individual method javadocs for details.</p>\n * <p>\n * {@link #equals} identifies all values with <code>NaN</code> in either real \n * or imaginary part - e.g., <pre>\n * <code>1 + NaNi  == NaN + i == NaN + NaNi.</code></pre></p>\n *\n * @version $Revision$ $Date$\n */\npublic class Complex implements Serializable  {\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6530173849413811929L;\n    \n    /** The square root of -1. A number representing \"0.0 + 1.0i\" */    \n    public static final Complex I = new Complex(0.0, 1.0);\n    \n    /** A complex number representing \"NaN + NaNi\" */\n    public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n\n    /** A complex number representing \"+INF + INFi\" */\n    public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n\n    /** A complex number representing \"1.0 + 0.0i\" */    \n    public static final Complex ONE = new Complex(1.0, 0.0);\n    \n    /** A complex number representing \"0.0 + 0.0i\" */    \n    public static final Complex ZERO = new Complex(0.0, 0.0);\n    \n    /** \n     * The imaginary part \n     */\n    private final double imaginary;\n    \n    /** \n     * The real part \n     */\n    private final double real;\n    \n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param real the real part\n     * @param imaginary the imaginary part\n     */\n    public Complex(double real, double imaginary) {\n        super();\n        this.real = real;\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Return the absolute value of this complex number.\n     * <p>\n     * Returns <code>NaN</code> if either real or imaginary part is\n     * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if\n     * neither part is <code>NaN</code>, but at least one part takes an infinite\n     * value.</p>\n     *\n     * @return the absolute value\n     */\n    public double abs() {\n        if (isNaN()) {\n            return Double.NaN;\n        }\n        \n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n        \n        if (Math.abs(real) < Math.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return Math.abs(real);\n            }\n            double q = real / imaginary;\n            return (Math.abs(imaginary) * Math.sqrt(1 + q*q));\n        } else {\n            if (real == 0.0) {\n                return Math.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return (Math.abs(real) * Math.sqrt(1 + q*q));\n        }\n    }\n    \n    /**\n     * Return the sum of this complex number and the given complex number.\n     * <p>\n     * Uses the definitional formula \n     * <pre>\n     * (a + bi) + (c + di) = (a+c) + (b+d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise Inifinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.</p> \n     *\n     * @param rhs the other complex number\n     * @return the complex number sum\n     * @throws NullPointerException if <code>rhs</code> is null\n     */\n    public Complex add(Complex rhs) {   \n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }\n    \n    /**\n     * Return the conjugate of this complex number. The conjugate of\n     * \"A + Bi\" is \"A - Bi\". \n     * <p>\n     * {@link #NaN} is returned if either the real or imaginary\n     * part of this Complex number equals <code>Double.NaN</code>.</p>\n     * <p>\n     * If the imaginary part is infinite, and the real part is not NaN, \n     * the returned value has infinite imaginary part of the opposite\n     * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>\n     * is <code>1 - NEGATIVE_INFINITY i</code></p>\n     *\n     * @return the conjugate of this Complex object\n     */\n    public Complex conjugate() {\n        if (isNaN()) {\n            return NaN;\n        }   \n        return createComplex(real, -imaginary);\n    }\n    \n    /**\n     * Return the quotient of this complex number and the given complex number.\n     * <p>\n     * Implements the definitional formula\n     * <pre><code>\n     *    a + bi          ac + bd + (bc - ad)i\n     *    ----------- = -------------------------\n     *    c + di               c<sup>2</sup> + d<sup>2</sup>\n     * </code></pre>\n     * but uses \n     * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n     * prescaling of operands</a> to limit the effects of overflows and\n     * underflows in the computation.</p>\n     * <p>\n     * Infinite and NaN values are handled / returned according to the\n     * following rules, applied in the order presented:\n     * <ul>\n     * <li>If either this or <code>rhs</code> has a NaN value in either part,\n     *  {@link #NaN} is returned.</li>\n     * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.\n     * </li>\n     * <li>If this and <code>rhs</code> are both infinite,\n     * {@link #NaN} is returned.</li>\n     * <li>If this is finite (i.e., has no infinite or NaN parts) and\n     *  <code>rhs</code> is infinite (one or both parts infinite), \n     * {@link #ZERO} is returned.</li>\n     * <li>If this is infinite and <code>rhs</code> is finite, NaN values are\n     * returned in the parts of the result if the {@link java.lang.Double}\n     * rules applied to the definitional formula force NaN results.</li>\n     * </ul></p>\n     * \n     * @param rhs the other complex number\n     * @return the complex number quotient\n     * @throws NullPointerException if <code>rhs</code> is null\n     */\n    public Complex divide(Complex rhs) {\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n\n        double c = rhs.getReal();\n        double d = rhs.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n        \n        if (rhs.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (Math.abs(c) < Math.abs(d)) {\n            if (d == 0.0) {\n                return createComplex(real/c, imaginary/c);\n            }\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            if (c == 0.0) {\n                return createComplex(imaginary/d, -real/c);\n            }\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }\n    \n    /**\n     * Test for the equality of two Complex objects.\n     * <p>\n     * If both the real and imaginary parts of two Complex numbers\n     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n     * Complex objects are considered to be equal.</p>\n     * <p>\n     * All <code>NaN</code> values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to <code>Double.NaN</code>, the complex number is equal to \n     * <code>Complex.NaN</code>.</p>\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if\n     *         object is null, not an instance of Complex, or\n     *         not equal to this Complex instance\n     * \n     */\n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }\n    \n    /**\n     * Get a hashCode for the complex number.\n     * <p>\n     * All NaN values have the same hash code.</p>\n     * \n     * @return a hash code value for this object\n     */\n    public int hashCode() {\n        if (isNaN()) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) + \n            MathUtils.hash(real));\n    }\n\n    /**\n     * Access the imaginary part.\n     *\n     * @return the imaginary part\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Access the real part.\n     *\n     * @return the real part\n     */\n    public double getReal() {\n        return real;\n    }\n    \n    /**\n     * Returns true if either or both parts of this complex number is NaN;\n     * false otherwise\n     *\n     * @return  true if either or both parts of this complex number is NaN;\n     * false otherwise\n     */\n    public boolean isNaN() {\n        return Double.isNaN(real) || Double.isNaN(imaginary);        \n    }\n    \n    /**\n     * Returns true if either the real or imaginary part of this complex number\n     * takes an infinite value (either <code>Double.POSITIVE_INFINITY</code> or \n     * <code>Double.NEGATIVE_INFINITY</code>) and neither part\n     * is <code>NaN</code>.\n     * \n     * @return true if one or both parts of this complex number are infinite\n     * and neither part is <code>NaN</code>\n     */\n    public boolean isInfinite() {\n        return !isNaN() && \n        (Double.isInfinite(real) || Double.isInfinite(imaginary));        \n    }\n    \n    /**\n     * Return the product of this complex number and the given complex number.\n     * <p>\n     * Implements preliminary checks for NaN and infinity followed by\n     * the definitional formula:\n     * <pre><code>\n     * (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n     * </code></pre>\n     * </p>\n     * <p>\n     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n     * NaN parts.\n     * </p>\n     * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more\n     * NaN parts and if either this or <code>rhs</code> has one or more\n     * infinite parts (same result is returned regardless of the sign of the\n     * components).\n     * </p>\n     * <p>\n     * Returns finite values in components of the result per the\n     * definitional formula in all remaining cases.\n     *  </p>\n     * \n     * @param rhs the other complex number\n     * @return the complex number product\n     * @throws NullPointerException if <code>rhs</code> is null\n     */\n    public Complex multiply(Complex rhs) {\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {\n            // we don't use Complex.isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n                real * rhs.imaginary + imaginary * rhs.real);\n    }\n    \n    /**\n     * Return the additive inverse of this complex number.\n     * <p>\n     * Returns <code>Complex.NaN</code> if either real or imaginary\n     * part of this Complex number equals <code>Double.NaN</code>.</p>\n     *\n     * @return the negation of this complex number\n     */\n    public Complex negate() {\n        if (isNaN()) {\n            return NaN;\n        }\n        \n        return createComplex(-real, -imaginary);\n    }\n    \n    /**\n     * Return the difference between this complex number and the given complex\n     * number.\n      * <p>\n     * Uses the definitional formula \n     * <pre>\n     * (a + bi) - (c + di) = (a-c) + (b-d)i\n     * </pre></p>\n     * <p>\n     * If either this or <code>rhs</code> has a NaN value in either part,\n     * {@link #NaN} is returned; otherwise inifinite and NaN values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic. </p>\n     * \n     * @param rhs the other complex number\n     * @return the complex number difference\n     * @throws NullPointerException if <code>rhs</code> is null\n     */\n    public Complex subtract(Complex rhs) {\n        if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n        \n        return createComplex(real - rhs.getReal(),\n            imaginary - rhs.getImaginary());\n    }\n    \n    /**\n     * Compute the \n     * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n     * inverse cosine</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code> or infinite.</p>\n     * \n     * @return the inverse cosine of this complex number\n     * @since 1.2\n     */\n    public Complex acos() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }\n    \n    /**\n     * Compute the \n     * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n     * inverse sine</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code> or infinite.</p>\n     * \n     * @return the inverse sine of this complex number.\n     * @since 1.2\n     */\n    public Complex asin() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n\n        return sqrt1z().add(this.multiply(Complex.I)).log()\n              .multiply(Complex.I.negate());\n    }\n    \n    /**\n     * Compute the \n     * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n     * inverse tangent</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code> or infinite.</p>\n     * \n     * @return the inverse tangent of this complex number\n     * @since 1.2\n     */\n    public Complex atan() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n    }\n    \n    /**\n     * Compute the \n     * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n     * cosine</a>\n     * of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples: \n     * <code>\n     * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i\n     * cos(&plusmn;INFINITY + i) = NaN + NaN i\n     * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     * \n     * @return the cosine of this complex number\n     * @since 1.2\n     */\n    public Complex cos() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(Math.cos(real) * MathUtils.cosh(imaginary),\n            -Math.sin(real) * MathUtils.sinh(imaginary));\n    }\n    \n    /**\n     * Compute the \n     * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n     * hyperbolic cosine</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples: \n     * <code>\n     * cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n     * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n     * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     * \n     * @return the hyperbolic cosine of this complex number.\n     * @since 1.2\n     */\n    public Complex cosh() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(MathUtils.cosh(real) * Math.cos(imaginary),\n            MathUtils.sinh(real) * Math.sin(imaginary));\n    }\n    \n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n     * exponential function</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and\n     * {@link java.lang.Math#sin}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples: \n     * <code>\n     * exp(1 &plusmn; INFINITY i) = NaN + NaN i\n     * exp(INFINITY + i) = INFINITY + INFINITY i\n     * exp(-INFINITY + i) = 0 + 0i\n     * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     * \n     * @return <i>e</i><sup><code>this</code></sup>\n     * @since 1.2\n     */\n    public Complex exp() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        double expReal = Math.exp(real);\n        return createComplex(expReal *  Math.cos(imaginary), expReal * Math.sin(imaginary));\n    }\n    \n    /**\n     * Compute the \n     * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n     * natural logarithm</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> log(a + bi) = ln(|a + bi|) + arg(a + bi)i</code></pre>\n     * where ln on the right hand side is {@link java.lang.Math#log},\n     * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and\n     * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite (or critical) values in real or imaginary parts of the input may\n     * result in infinite or NaN values returned in parts of the result.<pre>\n     * Examples: \n     * <code>\n     * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n     * log(INFINITY + i) = INFINITY + 0i\n     * log(-INFINITY + i) = INFINITY + &pi;i\n     * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n     * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n     * log(0 + 0i) = -INFINITY + 0i\n     * </code></pre></p>\n     * \n     * @return ln of this complex number.\n     * @since 1.2\n     */\n    public Complex log() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n\n        return createComplex(Math.log(abs()),\n            Math.atan2(imaginary, real));        \n    }\n    \n    /**\n     * Returns of value of this complex number raised to the power of <code>x</code>.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre> \n     * where <code>exp</code> and <code>log</code> are {@link #exp} and\n     * {@link #log}, respectively.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code> or infinite, or if <code>y</code>\n     * equals {@link Complex#ZERO}.</p>\n     * \n     * @param x the exponent.\n     * @return <code>this</code><sup><code>x</code></sup>\n     * @throws NullPointerException if x is null\n     * @since 1.2\n     */\n    public Complex pow(Complex x) {\n        if (x == null) {\n            throw new NullPointerException();\n        }\n        return this.log().multiply(x).exp();\n    }\n    \n    /**\n     * Compute the \n     * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n     * sine</a>\n     * of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples: \n     * <code>\n     * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n     * sin(&plusmn;INFINITY + i) = NaN + NaN i\n     * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     * \n     * @return the sine of this complex number.\n     * @since 1.2\n     */\n    public Complex sin() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(Math.sin(real) * MathUtils.cosh(imaginary),\n            Math.cos(real) * MathUtils.sinh(imaginary));\n    }\n    \n    /**\n     * Compute the \n     * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n     * hyperbolic sine</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples: \n     * <code>\n     * sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n     * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n     * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n     * \n     * @return the hyperbolic sine of this complex number\n     * @since 1.2\n     */\n    public Complex sinh() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        return createComplex(MathUtils.sinh(real) * Math.cos(imaginary),\n            MathUtils.cosh(real) * Math.sin(imaginary));\n    }\n    \n    /**\n     * Compute the \n     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n     * square root</a> of this complex number.\n     * <p>\n     * Implements the following algorithm to compute <code>sqrt(a + bi)</code>: \n     * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>\n     * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>\n     *  else return <code>|b|/2t + sign(b)t i </code></pre></li>\n     * </ol>\n     * where <ul>\n     * <li><code>|a| = {@link Math#abs}(a)</code></li>\n     * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>\n     * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>\n     * </ul></p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples: \n     * <code>\n     * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n     * sqrt(INFINITY + i) = INFINITY + 0i\n     * sqrt(-INFINITY + i) = 0 + INFINITY i\n     * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n     * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n     * </code></pre></p>\n     * \n     * @return the square root of this complex number\n     * @since 1.2\n     */\n    public Complex sqrt() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n        \n        double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(Math.abs(imaginary) / (2.0 * t),\n                MathUtils.indicator(imaginary) * t);\n        }\n    }\n    \n    /**\n     * Compute the \n     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n     * square root</a> of 1 - <code>this</code><sup>2</sup> for this complex\n     * number.\n     * <p>\n     * Computes the result directly as \n     * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.</p>\n     * \n     * @return the square root of 1 - <code>this</code><sup>2</sup>\n     * @since 1.2\n     */\n    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }\n    \n    /**\n     * Compute the \n     * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n     * tangent</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite (or critical) values in real or imaginary parts of the input may\n     * result in infinite or NaN values returned in parts of the result.<pre>\n     * Examples: \n     * <code>\n     * tan(1 &plusmn; INFINITY i) = 0 + NaN i\n     * tan(&plusmn;INFINITY + i) = NaN + NaN i\n     * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>\n     * \n     * @return the tangent of this complex number\n     * @since 1.2\n     */\n    public Complex tan() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = Math.cos(real2) + MathUtils.cosh(imaginary2);\n        \n        return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n    }\n    \n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n     * hyperbolic tangent</a> of this complex number.\n     * <p>\n     * Implements the formula: <pre>\n     * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>\n     * where the (real) functions on the right-hand side are\n     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the \n     * input argument is <code>NaN</code>.</p>\n     * <p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.<pre>\n     * Examples: \n     * <code>\n     * tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n     * tanh(&plusmn;INFINITY + i) = NaN + 0 i\n     * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre></p>\n     *\n     * @return the hyperbolic tangent of this complex number\n     * @since 1.2\n     */\n    public Complex tanh() {\n        if (isNaN()) {\n            return Complex.NaN;\n        }\n        \n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = MathUtils.cosh(real2) + Math.cos(imaginary2);\n        \n        return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);\n    }\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param real the real part\n     * @param imaginary the imaginary part\n     * @return a new complex number instance\n     * @since 1.2\n     */\n    protected Complex createComplex(double real, double imaginary) {\n        return new Complex(real, imaginary);\n    }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"id\": 1,\n         \"description\": \"In the abs() method, the condition Math.abs(real) < Math.abs(imaginary) is not symmetric with the condition Math.abs(imaginary) < Math.abs(real) which can lead to inconsistent results when the real and imaginary parts are equal but of opposite signs.\",\n         \"category\": \"logic\",\n         \"severity\": \"medium\"\n      },\n      {\n         \"id\": 2,\n         \"description\": \"The add() method does not handle the case where the rhs is null, which can lead to a NullPointerException.\",\n         \"category\": \"null pointer\",\n         \"severity\": \"high\"\n      },\n      {\n         \"id\": 3,\n         \"description\": \"The conjugate() method returns NaN if either the real or imaginary part of this Complex number equals Double.NaN, but it does not handle the case where the imaginary part is infinite and the real part is not NaN.\",\n         \"category\": \"logic\",\n         \"severity\": \"low\"\n      }\n   ]\n}"}}