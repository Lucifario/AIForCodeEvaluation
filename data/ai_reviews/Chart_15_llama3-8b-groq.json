{"sample_id": "Chart_15", "model": "llama3-8b-groq", "code_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ------------\n * PiePlot.java\n * ------------\n * (C) Copyright 2000-2008, by Andrzej Porebski and Contributors.\n *\n * Original Author:  Andrzej Porebski;\n * Contributor(s):   David Gilbert (for Object Refinery Limited);\n *                   Martin Cordova (percentages in labels);\n *                   Richard Atkinson (URL support for image maps);\n *                   Christian W. Zuckschwerdt;\n *                   Arnaud Lelievre;\n *                   Andreas Schroeder (very minor);\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 18-Sep-2001 : Updated header (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 19-Oct-2001 : Moved series paint and stroke methods from JFreeChart.java to \n *               Plot.java (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 13-Nov-2001 : Modified plot subclasses so that null axes are possible for \n *               pie plot (DG);\n * 17-Nov-2001 : Added PieDataset interface and amended this class accordingly,\n *               and completed removal of BlankAxis class as it is no longer \n *               required (DG);\n * 19-Nov-2001 : Changed 'drawCircle' property to 'circular' property (DG);\n * 21-Nov-2001 : Added options for exploding pie sections and filled out range \n *               of properties (DG);\n *               Added option for percentages in chart labels, based on code\n *               by Martin Cordova (DG);\n * 30-Nov-2001 : Changed default font from \"Arial\" --> \"SansSerif\" (DG);\n * 12-Dec-2001 : Removed unnecessary 'throws' clause in constructor (DG);\n * 13-Dec-2001 : Added tooltips (DG);\n * 16-Jan-2002 : Renamed tooltips class (DG);\n * 22-Jan-2002 : Fixed bug correlating legend labels with pie data (DG);\n * 05-Feb-2002 : Added alpha-transparency to plot class, and updated \n *               constructors accordingly (DG);\n * 06-Feb-2002 : Added optional background image and alpha-transparency to Plot\n *               and subclasses.  Clipped drawing within plot area (DG);\n * 26-Mar-2002 : Added an empty zoom method (DG);\n * 18-Apr-2002 : PieDataset is no longer sorted (oldman);\n * 23-Apr-2002 : Moved dataset from JFreeChart to Plot.  Added \n *               getLegendItemLabels() method (DG);\n * 19-Jun-2002 : Added attributes to control starting angle and direction \n *               (default is now clockwise) (DG);\n * 25-Jun-2002 : Removed redundant imports (DG);\n * 02-Jul-2002 : Fixed sign of percentage bug introduced in 0.9.2 (DG);\n * 16-Jul-2002 : Added check for null dataset in getLegendItemLabels() (DG);\n * 30-Jul-2002 : Moved summation code to DatasetUtilities (DG);\n * 05-Aug-2002 : Added URL support for image maps - new member variable for\n *               urlGenerator, modified constructor and minor change to the \n *               draw method (RA);\n * 18-Sep-2002 : Modified the percent label creation and added setters for the\n *               formatters (AS);\n * 24-Sep-2002 : Added getLegendItems() method (DG);\n * 02-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 09-Oct-2002 : Added check for null entity collection (DG);\n * 30-Oct-2002 : Changed PieDataset interface (DG);\n * 18-Nov-2002 : Changed CategoryDataset to TableDataset (DG);\n * 02-Jan-2003 : Fixed \"no data\" message (DG);\n * 23-Jan-2003 : Modified to extract data from rows OR columns in \n *               CategoryDataset (DG);\n * 14-Feb-2003 : Fixed label drawing so that foreground alpha does not apply \n *               (bug id 685536) (DG);\n * 07-Mar-2003 : Modified to pass pieIndex on to PieSectionEntity and tooltip \n *               and URL generators (DG);\n * 21-Mar-2003 : Added a minimum angle for drawing arcs \n *               (see bug id 620031) (DG);\n * 24-Apr-2003 : Switched around PieDataset and KeyedValuesDataset (DG);\n * 02-Jun-2003 : Fixed bug 721733 (DG);\n * 30-Jul-2003 : Modified entity constructor (CZ);\n * 19-Aug-2003 : Implemented Cloneable (DG);\n * 29-Aug-2003 : Fixed bug 796936 (null pointer on setOutlinePaint()) (DG);\n * 08-Sep-2003 : Added internationalization via use of properties \n *               resourceBundle (RFE 690236) (AL);\n * 16-Sep-2003 : Changed ChartRenderingInfo --> PlotRenderingInfo (DG);\n * 29-Oct-2003 : Added workaround for font alignment in PDF output (DG);\n * 05-Nov-2003 : Fixed missing legend bug (DG);\n * 10-Nov-2003 : Re-added the DatasetChangeListener to constructors (CZ);\n * 29-Jan-2004 : Fixed clipping bug in draw() method (DG);\n * 11-Mar-2004 : Major overhaul to improve labelling (DG);\n * 31-Mar-2004 : Made an adjustment for the plot area when the label generator \n *               is null.  Fixed null pointer exception when the label \n *               generator returns null for a label (DG);\n * 06-Apr-2004 : Added getter, setter, serialization and draw support for \n *               labelBackgroundPaint (AS);\n * 08-Apr-2004 : Added flag to control whether null values are ignored or \n *               not (DG);\n * 15-Apr-2004 : Fixed some minor warnings from Eclipse (DG);\n * 26-Apr-2004 : Added attributes for label outline and shadow (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 04-Nov-2004 : Fixed null pointer exception with new LegendTitle class (DG);\n * 09-Nov-2004 : Added user definable legend item shape (DG);\n * 25-Nov-2004 : Added new legend label generator (DG);\n * 20-Apr-2005 : Added a tool tip generator for legend labels (DG);\n * 26-Apr-2005 : Removed LOGGER (DG);\n * 05-May-2005 : Updated draw() method parameters (DG);\n * 10-May-2005 : Added flag to control visibility of label linking lines, plus\n *               another flag to control the handling of zero values (DG);\n * 08-Jun-2005 : Fixed bug in getLegendItems() method (not respecting flags\n *               for ignoring null and zero values), and fixed equals() method \n *               to handle GradientPaint (DG);\n * 15-Jul-2005 : Added sectionOutlinesVisible attribute (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 09-Jan-2006 : Fixed bug 1400442, inconsistent treatment of null and zero\n *               values in dataset (DG);\n * 28-Feb-2006 : Fixed bug 1440415, bad distribution of pie section \n *               labels (DG);\n * 27-Sep-2006 : Initialised baseSectionPaint correctly, added lookup methods\n *               for section paint, outline paint and outline stroke (DG);\n * 27-Sep-2006 : Refactored paint and stroke methods to use keys rather than\n *               section indices (DG);\n * 03-Oct-2006 : Replaced call to JRE 1.5 method (DG);\n * 23-Nov-2006 : Added support for URLs for the legend items (DG);\n * 24-Nov-2006 : Cloning fixes (DG);\n * 17-Apr-2007 : Check for null label in legend items (DG);\n * 19-Apr-2007 : Deprecated override settings (DG);\n * 18-May-2007 : Set dataset for LegendItem (DG);\n * 14-Jun-2007 : Added label distributor attribute (DG);\n * 19-Jun-2007 : Removed deprecated code (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 18-Jul-2007 : Added simple label option (DG);\n * 21-Nov-2007 : Fixed labelling bugs, added debug code, restored default\n *               white background (DG); \n * 19-Mar-2008 : Fixed IllegalArgumentException when drawing with null \n *               dataset (DG);\n *    \n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.PaintMap;\nimport org.jfree.chart.StrokeMap;\nimport org.jfree.chart.entity.EntityCollection;\nimport org.jfree.chart.entity.PieSectionEntity;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.labels.PieSectionLabelGenerator;\nimport org.jfree.chart.labels.PieToolTipGenerator;\nimport org.jfree.chart.labels.StandardPieSectionLabelGenerator;\nimport org.jfree.chart.text.G2TextMeasurer;\nimport org.jfree.chart.text.TextAnchor;\nimport org.jfree.chart.text.TextBlock;\nimport org.jfree.chart.text.TextBox;\nimport org.jfree.chart.text.TextUtilities;\nimport org.jfree.chart.urls.PieURLGenerator;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleAnchor;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.Rotation;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.jfree.chart.util.UnitType;\nimport org.jfree.data.DefaultKeyedValues;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.general.PieDataset;\n\n/**\n * A plot that displays data in the form of a pie chart, using data from any \n * class that implements the {@link PieDataset} interface.\n * <P>\n * Special notes:\n * <ol>\n * <li>the default starting point is 12 o'clock and the pie sections proceed\n * in a clockwise direction, but these settings can be changed;</li>\n * <li>negative values in the dataset are ignored;</li>\n * <li>there are utility methods for creating a {@link PieDataset} from a\n * {@link org.jfree.data.category.CategoryDataset};</li>\n * </ol>\n *\n * @see Plot\n * @see PieDataset\n */\npublic class PiePlot extends Plot implements Cloneable, Serializable {\n    \n    /** For serialization. */\n    private static final long serialVersionUID = -795612466005590431L;\n    \n    /** The default interior gap. */\n    public static final double DEFAULT_INTERIOR_GAP = 0.08;\n\n    /** The maximum interior gap (currently 40%). */\n    public static final double MAX_INTERIOR_GAP = 0.40;\n\n    /** The default starting angle for the pie chart. */\n    public static final double DEFAULT_START_ANGLE = 90.0;\n\n    /** The default section label font. */\n    public static final Font DEFAULT_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10);\n\n    /** The default section label paint. */\n    public static final Paint DEFAULT_LABEL_PAINT = Color.black;\n    \n    /** The default section label background paint. */\n    public static final Paint DEFAULT_LABEL_BACKGROUND_PAINT = new Color(255, \n            255, 192);\n\n    /** The default section label outline paint. */\n    public static final Paint DEFAULT_LABEL_OUTLINE_PAINT = Color.black;\n    \n    /** The default section label outline stroke. */\n    public static final Stroke DEFAULT_LABEL_OUTLINE_STROKE = new BasicStroke(\n            0.5f);\n    \n    /** The default section label shadow paint. */\n    public static final Paint DEFAULT_LABEL_SHADOW_PAINT = new Color(151, 151, \n            151, 128);\n    \n    /** The default minimum arc angle to draw. */\n    public static final double DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW = 0.00001;\n\n    /** The dataset for the pie chart. */\n    private PieDataset dataset;\n\n    /** The pie index (used by the {@link MultiplePiePlot} class). */\n    private int pieIndex;\n\n    /** \n     * The amount of space left around the outside of the pie plot, expressed \n     * as a percentage of the plot area width and height. \n     */\n    private double interiorGap;\n\n    /** Flag determining whether to draw an ellipse or a perfect circle. */\n    private boolean circular;\n\n    /** The starting angle. */\n    private double startAngle;\n\n    /** The direction for the pie segments. */\n    private Rotation direction;\n\n    /** The section paint map. */\n    private PaintMap sectionPaintMap;\n\n    /** The base section paint (fallback). */\n    private transient Paint baseSectionPaint;\n\n    /** \n     * A flag that controls whether or not an outline is drawn for each\n     * section in the plot.\n     */\n    private boolean sectionOutlinesVisible;\n\n    /** The section outline paint map. */\n    private PaintMap sectionOutlinePaintMap;\n\n    /** The base section outline paint (fallback). */\n    private transient Paint baseSectionOutlinePaint;\n\n    /** The section outline stroke map. */\n    private StrokeMap sectionOutlineStrokeMap;\n\n    /** The base section outline stroke (fallback). */\n    private transient Stroke baseSectionOutlineStroke;\n\n    /** The shadow paint. */\n    private transient Paint shadowPaint = Color.gray;\n\n    /** The x-offset for the shadow effect. */\n    private double shadowXOffset = 4.0f;\n    \n    /** The y-offset for the shadow effect. */\n    private double shadowYOffset = 4.0f;\n    \n    /** The percentage amount to explode each pie section. */\n    private Map explodePercentages;\n    \n    /** The section label generator. */\n    private PieSectionLabelGenerator labelGenerator;\n\n    /** The font used to display the section labels. */\n    private Font labelFont;\n\n    /** The color used to draw the section labels. */\n    private transient Paint labelPaint;\n    \n    /** \n     * The color used to draw the background of the section labels.  If this\n     * is <code>null</code>, the background is not filled.\n     */\n    private transient Paint labelBackgroundPaint;\n\n    /** \n     * The paint used to draw the outline of the section labels \n     * (<code>null</code> permitted). \n     */\n    private transient Paint labelOutlinePaint;\n    \n    /** \n     * The stroke used to draw the outline of the section labels \n     * (<code>null</code> permitted). \n     */\n    private transient Stroke labelOutlineStroke;\n    \n    /** \n     * The paint used to draw the shadow for the section labels \n     * (<code>null</code> permitted). \n     */\n    private transient Paint labelShadowPaint;\n    \n    /**\n     * A flag that controls whether simple or extended labels are used.\n     * \n     * @since 1.0.7\n     */\n    private boolean simpleLabels = true;\n    \n    /**\n     * The padding between the labels and the label outlines.  This is not\n     * allowed to be <code>null</code>.\n     * \n     * @since 1.0.7\n     */\n    private RectangleInsets labelPadding;\n    \n    /**\n     * The simple label offset.\n     * \n     * @since 1.0.7\n     */\n    private RectangleInsets simpleLabelOffset;\n    \n    /** The maximum label width as a percentage of the plot width. */\n    private double maximumLabelWidth = 0.14;\n    \n    /** \n     * The gap between the labels and the link corner, as a percentage of the \n     * plot width. \n     */\n    private double labelGap = 0.025;\n\n    /** A flag that controls whether or not the label links are drawn. */\n    private boolean labelLinksVisible;\n    \n    /** The link margin. */\n    private double labelLinkMargin = 0.025;\n    \n    /** The paint used for the label linking lines. */\n    private transient Paint labelLinkPaint = Color.black;\n    \n    /** The stroke used for the label linking lines. */\n    private transient Stroke labelLinkStroke = new BasicStroke(0.5f);\n    \n    /** \n     * The pie section label distributor.\n     * \n     * @since 1.0.6\n     */\n    private AbstractPieLabelDistributor labelDistributor;\n    \n    /** The tooltip generator. */\n    private PieToolTipGenerator toolTipGenerator;\n\n    /** The URL generator. */\n    private PieURLGenerator urlGenerator;\n    \n    /** The legend label generator. */\n    private PieSectionLabelGenerator legendLabelGenerator;\n    \n    /** A tool tip generator for the legend. */\n    private PieSectionLabelGenerator legendLabelToolTipGenerator;\n    \n    /** \n     * A URL generator for the legend items (optional).  \n     *\n     * @since 1.0.4. \n     */\n    private PieURLGenerator legendLabelURLGenerator;\n    \n    /** \n     * A flag that controls whether <code>null</code> values are ignored.  \n     */\n    private boolean ignoreNullValues;\n    \n    /**\n     * A flag that controls whether zero values are ignored.\n     */\n    private boolean ignoreZeroValues;\n\n    /** The legend item shape. */\n    private transient Shape legendItemShape;\n    \n    /**\n     * The smallest arc angle that will get drawn (this is to avoid a bug in \n     * various Java implementations that causes the JVM to crash).  See this \n     * link for details:\n     *\n     * http://www.jfree.org/phpBB2/viewtopic.php?t=2707\n     *\n     * ...and this bug report in the Java Bug Parade:\n     *\n     * http://developer.java.sun.com/developer/bugParade/bugs/4836495.html\n     */\n    private double minimumArcAngleToDraw;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources =\n            ResourceBundle.getBundle(\"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** \n     * This debug flag controls whether or not an outline is drawn showing the \n     * interior of the plot region.  This is drawn as a lightGray rectangle \n     * showing the padding provided by the 'interiorGap' setting.\n     */\n    static final boolean DEBUG_DRAW_INTERIOR = false;\n    \n    /** \n     * This debug flag controls whether or not an outline is drawn showing the \n     * link area (in blue) and link ellipse (in yellow).  This controls where \n     * the label links have 'elbow' points.\n     */\n    static final boolean DEBUG_DRAW_LINK_AREA = false;\n    \n    /**\n     * This debug flag controls whether or not an outline is drawn showing\n     * the pie area (in green).\n     */\n    static final boolean DEBUG_DRAW_PIE_AREA = false;\n    \n    /**\n     * Creates a new plot.  The dataset is initially set to <code>null</code>.\n     */\n    public PiePlot() {\n        this(null);\n    }\n\n    /**\n     * Creates a plot that will draw a pie chart for the specified dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     */\n    public PiePlot(PieDataset dataset) {\n        super();\n        this.dataset = dataset;\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        this.pieIndex = 0;\n        \n        this.interiorGap = DEFAULT_INTERIOR_GAP;\n        this.circular = true;\n        this.startAngle = DEFAULT_START_ANGLE;\n        this.direction = Rotation.CLOCKWISE;\n        this.minimumArcAngleToDraw = DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW;\n\n        this.sectionPaintMap = new PaintMap();\n        this.baseSectionPaint = Color.gray;\n\n        this.sectionOutlinesVisible = true;\n        this.sectionOutlinePaintMap = new PaintMap();\n        this.baseSectionOutlinePaint = DEFAULT_OUTLINE_PAINT;\n\n        this.sectionOutlineStrokeMap = new StrokeMap();\n        this.baseSectionOutlineStroke = DEFAULT_OUTLINE_STROKE;\n        \n        this.explodePercentages = new TreeMap();\n\n        this.labelGenerator = new StandardPieSectionLabelGenerator();\n        this.labelFont = DEFAULT_LABEL_FONT;\n        this.labelPaint = DEFAULT_LABEL_PAINT;\n        this.labelBackgroundPaint = DEFAULT_LABEL_BACKGROUND_PAINT;\n        this.labelOutlinePaint = DEFAULT_LABEL_OUTLINE_PAINT;\n        this.labelOutlineStroke = DEFAULT_LABEL_OUTLINE_STROKE;\n        this.labelShadowPaint = DEFAULT_LABEL_SHADOW_PAINT;\n        this.labelLinksVisible = true;\n        this.labelDistributor = new PieLabelDistributor(0);\n        \n        this.simpleLabels = false;\n        this.simpleLabelOffset = new RectangleInsets(UnitType.RELATIVE, 0.18, \n                0.18, 0.18, 0.18);\n        this.labelPadding = new RectangleInsets(2, 2, 2, 2);\n        \n        this.toolTipGenerator = null;\n        this.urlGenerator = null;\n        this.legendLabelGenerator = new StandardPieSectionLabelGenerator();\n        this.legendLabelToolTipGenerator = null;\n        this.legendLabelURLGenerator = null;\n        this.legendItemShape = Plot.DEFAULT_LEGEND_ITEM_CIRCLE;\n        \n        this.ignoreNullValues = false;\n        this.ignoreZeroValues = false;\n    }\n\n    /**\n     * Returns the dataset.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(PieDataset)\n     */\n    public PieDataset getDataset() {\n        return this.dataset;\n    }\n\n    /**\n     * Sets the dataset and sends a {@link DatasetChangeEvent} to 'this'.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset()\n     */\n    public void setDataset(PieDataset dataset) {\n        // if there is an existing dataset, remove the plot from the list of \n        // change listeners...\n        PieDataset existing = this.dataset;\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n\n        // set the new dataset, and register the chart as a change listener...\n        this.dataset = dataset;\n        if (dataset != null) {\n            setDatasetGroup(dataset.getGroup());\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n    \n    /**\n     * Returns the pie index (this is used by the {@link MultiplePiePlot} class\n     * to track subplots).\n     * \n     * @return The pie index.\n     * \n     * @see #setPieIndex(int)\n     */\n    public int getPieIndex() {\n        return this.pieIndex;\n    }\n    \n    /**\n     * Sets the pie index (this is used by the {@link MultiplePiePlot} class to \n     * track subplots).\n     * \n     * @param index  the index.\n     * \n     * @see #getPieIndex()\n     */\n    public void setPieIndex(int index) {\n        this.pieIndex = index;\n    }\n    \n    /**\n     * Returns the start angle for the first pie section.  This is measured in \n     * degrees starting from 3 o'clock and measuring anti-clockwise.\n     *\n     * @return The start angle.\n     * \n     * @see #setStartAngle(double)\n     */\n    public double getStartAngle() {\n        return this.startAngle;\n    }\n\n    /**\n     * Sets the starting angle and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  The initial default value is 90 degrees, which \n     * corresponds to 12 o'clock.  A value of zero corresponds to 3 o'clock...\n     * this is the encoding used by Java's Arc2D class.\n     *\n     * @param angle  the angle (in degrees).\n     * \n     * @see #getStartAngle()\n     */\n    public void setStartAngle(double angle) {\n        this.startAngle = angle;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the direction in which the pie sections are drawn (clockwise or \n     * anti-clockwise).\n     *\n     * @return The direction (never <code>null</code>).\n     * \n     * @see #setDirection(Rotation)\n     */\n    public Rotation getDirection() {\n        return this.direction;\n    }\n\n    /**\n     * Sets the direction in which the pie sections are drawn and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param direction  the direction (<code>null</code> not permitted).\n     * \n     * @see #getDirection()\n     */\n    public void setDirection(Rotation direction) {\n        if (direction == null) {\n            throw new IllegalArgumentException(\"Null 'direction' argument.\");\n        }\n        this.direction = direction;\n        notifyListeners(new PlotChangeEvent(this));\n\n    }\n\n    /**\n     * Returns the interior gap, measured as a percentage of the available \n     * drawing space.\n     *\n     * @return The gap (as a percentage of the available drawing space).\n     * \n     * @see #setInteriorGap(double)\n     */\n    public double getInteriorGap() {\n        return this.interiorGap;\n    }\n\n    /**\n     * Sets the interior gap and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  This controls the space between the edges of the \n     * pie plot and the plot area itself (the region where the section labels \n     * appear).\n     *\n     * @param percent  the gap (as a percentage of the available drawing space).\n     * \n     * @see #getInteriorGap()\n     */\n    public void setInteriorGap(double percent) {\n\n        if ((percent < 0.0) || (percent > MAX_INTERIOR_GAP)) {\n            throw new IllegalArgumentException(\n                \"Invalid 'percent' (\" + percent + \") argument.\");\n        }\n\n        if (this.interiorGap != percent) {\n            this.interiorGap = percent;\n            notifyListeners(new PlotChangeEvent(this));\n        }\n\n    }\n\n    /**\n     * Returns a flag indicating whether the pie chart is circular, or\n     * stretched into an elliptical shape.\n     *\n     * @return A flag indicating whether the pie chart is circular.\n     * \n     * @see #setCircular(boolean)\n     */\n    public boolean isCircular() {\n        return this.circular;\n    }\n\n    /**\n     * A flag indicating whether the pie chart is circular, or stretched into\n     * an elliptical shape.\n     *\n     * @param flag  the new value.\n     * \n     * @see #isCircular()\n     */\n    public void setCircular(boolean flag) {\n        setCircular(flag, true);\n    }\n\n    /**\n     * Sets the circular attribute and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param circular  the new value of the flag.\n     * @param notify  notify listeners?\n     * \n     * @see #isCircular()\n     */\n    public void setCircular(boolean circular, boolean notify) {\n        this.circular = circular;\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));   \n        }\n    }\n\n    /**\n     * Returns the flag that controls whether <code>null</code> values in the \n     * dataset are ignored.  \n     * \n     * @return A boolean.\n     * \n     * @see #setIgnoreNullValues(boolean)\n     */\n    public boolean getIgnoreNullValues() {\n        return this.ignoreNullValues;   \n    }\n    \n    /**\n     * Sets a flag that controls whether <code>null</code> values are ignored, \n     * and sends a {@link PlotChangeEvent} to all registered listeners.  At \n     * present, this only affects whether or not the key is presented in the \n     * legend.\n     * \n     * @param flag  the flag.\n     * \n     * @see #getIgnoreNullValues()\n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public void setIgnoreNullValues(boolean flag) {\n        this.ignoreNullValues = flag;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the flag that controls whether zero values in the \n     * dataset are ignored.  \n     * \n     * @return A boolean.\n     * \n     * @see #setIgnoreZeroValues(boolean)\n     */\n    public boolean getIgnoreZeroValues() {\n        return this.ignoreZeroValues;   \n    }\n    \n    /**\n     * Sets a flag that controls whether zero values are ignored, \n     * and sends a {@link PlotChangeEvent} to all registered listeners.  This \n     * only affects whether or not a label appears for the non-visible\n     * pie section.\n     * \n     * @param flag  the flag.\n     * \n     * @see #getIgnoreZeroValues()\n     * @see #setIgnoreNullValues(boolean)\n     */\n    public void setIgnoreZeroValues(boolean flag) {\n        this.ignoreZeroValues = flag;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    //// SECTION PAINT ////////////////////////////////////////////////////////\n\n    /**\n     * Returns the paint for the specified section.  This is equivalent to\n     * <code>lookupSectionPaint(section, false)</code>.\n     * \n     * @param key  the section key.\n     * \n     * @return The paint for the specified section.\n     * \n     * @since 1.0.3\n     * \n     * @see #lookupSectionPaint(Comparable, boolean)\n     */\n    protected Paint lookupSectionPaint(Comparable key) {\n        return lookupSectionPaint(key, false);        \n    }\n    \n    /**\n     * Returns the paint for the specified section.  The lookup involves these\n     * steps:\n     * <ul>\n     * <li>if {@link #getSectionPaint(Comparable)} is non-<code>null</code> \n     *         return it;</li>\n     * <li>if {@link #getSectionPaint(Comparable)} is <code>null</code> but \n     *         <code>autoPopulate</code> is <code>true</code>, attempt to fetch\n     *         a new paint from the drawing supplier \n     *         ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionPaint()}.\n     * </ul> \n     * \n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier \n     *     is used to auto-populate the section paint settings.\n     *     \n     * @return The paint.\n     * \n     * @since 1.0.3\n     */\n    protected Paint lookupSectionPaint(Comparable key, boolean autoPopulate) {\n        Paint result = null;\n        \n        // is a paint defined for the specified key\n        result = this.sectionPaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n        \n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextPaint();\n                this.sectionPaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionPaint;\n            }\n        }\n        else {\n            result = this.baseSectionPaint;\n        }\n        return result;\n    }\n    \n    /**\n     * Returns a key for the specified section.  If there is no such section \n     * in the dataset, we generate a key.  This is to provide some backward\n     * compatibility for the (now deprecated) methods that get/set attributes \n     * based on section indices.  The preferred way of doing this now is to\n     * link the attributes directly to the section key (there are new methods\n     * for this, starting from version 1.0.3).  \n     * \n     * @param section  the section index.\n     * \n     * @return The key.\n     *\n     * @since 1.0.3\n     */\n    protected Comparable getSectionKey(int section) {\n        Comparable key = null;\n        if (this.dataset != null) {\n            if (section >= 0 && section < this.dataset.getItemCount()) {\n                key = this.dataset.getKey(section);\n            }\n        }\n        if (key == null) {\n            key = new Integer(section);\n        }\n        return key;\n    }\n    \n    /**\n     * Returns the paint associated with the specified key, or \n     * <code>null</code> if there is no paint associated with the key.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * \n     * @return The paint associated with the specified key, or \n     *     <code>null</code>.\n     *     \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     * \n     * @see #setSectionPaint(Comparable, Paint)\n     * \n     * @since 1.0.3\n     */\n    public Paint getSectionPaint(Comparable key) {\n        // null argument check delegated...\n        return this.sectionPaintMap.getPaint(key);\n    }\n    \n    /**\n     * Sets the paint associated with the specified key, and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * @param paint  the paint.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     *     \n     * @see #getSectionPaint(Comparable)\n     * \n     * @since 1.0.3\n     */\n    public void setSectionPaint(Comparable key, Paint paint) {\n        // null argument check delegated...\n        this.sectionPaintMap.put(key, paint);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the base section paint.  This is used when no other paint is \n     * defined, which is rare.  The default value is <code>Color.gray</code>.\n     * \n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setBaseSectionPaint(Paint)\n     */\n    public Paint getBaseSectionPaint() {\n        return this.baseSectionPaint;   \n    }\n    \n    /**\n     * Sets the base section paint and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     * \n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getBaseSectionPaint()\n     */\n    public void setBaseSectionPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.baseSectionPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    //// SECTION OUTLINE PAINT ////////////////////////////////////////////////\n\n    /**\n     * Returns the flag that controls whether or not the outline is drawn for\n     * each pie section.\n     * \n     * @return The flag that controls whether or not the outline is drawn for\n     *         each pie section.\n     *         \n     * @see #setSectionOutlinesVisible(boolean)\n     */\n    public boolean getSectionOutlinesVisible() {\n        return this.sectionOutlinesVisible;\n    }\n    \n    /**\n     * Sets the flag that controls whether or not the outline is drawn for \n     * each pie section, and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     * \n     * @param visible  the flag.\n     * \n     * @see #getSectionOutlinesVisible()\n     */\n    public void setSectionOutlinesVisible(boolean visible) {\n        this.sectionOutlinesVisible = visible;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the outline paint for the specified section.  This is equivalent \n     * to <code>lookupSectionPaint(section, false)</code>.\n     * \n     * @param key  the section key.\n     * \n     * @return The paint for the specified section.\n     * \n     * @since 1.0.3\n     * \n     * @see #lookupSectionOutlinePaint(Comparable, boolean)\n     */\n    protected Paint lookupSectionOutlinePaint(Comparable key) {\n        return lookupSectionOutlinePaint(key, false);        \n    }\n    \n    /**\n     * Returns the outline paint for the specified section.  The lookup \n     * involves these steps:\n     * <ul>\n     * <li>if {@link #getSectionOutlinePaint(Comparable)} is \n     *         non-<code>null</code> return it;</li>\n     * <li>if {@link #getSectionOutlinePaint(Comparable)} is \n     *         <code>null</code> but <code>autoPopulate</code> is \n     *         <code>true</code>, attempt to fetch a new outline paint from \n     *         the drawing supplier ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionOutlinePaint()}.\n     * </ul> \n     * \n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier \n     *     is used to auto-populate the section outline paint settings.\n     *     \n     * @return The paint.\n     * \n     * @since 1.0.3\n     */\n    protected Paint lookupSectionOutlinePaint(Comparable key, \n            boolean autoPopulate) {\n        \n        Paint result = null;\n        \n        // is a paint defined for the specified key\n        result = this.sectionOutlinePaintMap.getPaint(key);\n        if (result != null) {\n            return result;\n        }\n        \n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextOutlinePaint();\n                this.sectionOutlinePaintMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionOutlinePaint;\n            }\n        }\n        else {\n            result = this.baseSectionOutlinePaint;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the outline paint associated with the specified key, or \n     * <code>null</code> if there is no paint associated with the key.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * \n     * @return The paint associated with the specified key, or \n     *     <code>null</code>.\n     *     \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     * \n     * @see #setSectionOutlinePaint(Comparable, Paint)\n     * \n     * @since 1.0.3\n     */\n    public Paint getSectionOutlinePaint(Comparable key) {\n        // null argument check delegated...\n        return this.sectionOutlinePaintMap.getPaint(key);\n    }\n    \n    /**\n     * Sets the outline paint associated with the specified key, and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * @param paint  the paint.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     *     \n     * @see #getSectionOutlinePaint(Comparable)\n     * \n     * @since 1.0.3\n     */\n    public void setSectionOutlinePaint(Comparable key, Paint paint) {\n        // null argument check delegated...\n        this.sectionOutlinePaintMap.put(key, paint);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the base section paint.  This is used when no other paint is \n     * available.\n     * \n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setBaseSectionOutlinePaint(Paint)\n     */\n    public Paint getBaseSectionOutlinePaint() {\n        return this.baseSectionOutlinePaint;   \n    }\n    \n    /**\n     * Sets the base section paint.\n     * \n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getBaseSectionOutlinePaint()\n     */\n    public void setBaseSectionOutlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.baseSectionOutlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    //// SECTION OUTLINE STROKE ///////////////////////////////////////////////\n\n    /**\n     * Returns the outline stroke for the specified section.  This is equivalent \n     * to <code>lookupSectionOutlineStroke(section, false)</code>.\n     * \n     * @param key  the section key.\n     * \n     * @return The stroke for the specified section.\n     * \n     * @since 1.0.3\n     * \n     * @see #lookupSectionOutlineStroke(Comparable, boolean)\n     */\n    protected Stroke lookupSectionOutlineStroke(Comparable key) {\n        return lookupSectionOutlineStroke(key, false);        \n    }\n    \n    /**\n     * Returns the outline stroke for the specified section.  The lookup \n     * involves these steps:\n     * <ul>\n     * <li>if {@link #getSectionOutlineStroke(Comparable)} is \n     *         non-<code>null</code> return it;</li>\n     * <li>if {@link #getSectionOutlineStroke(Comparable)} is \n     *         <code>null</code> but <code>autoPopulate</code> is \n     *         <code>true</code>, attempt to fetch a new outline stroke from \n     *         the drawing supplier ({@link #getDrawingSupplier()});\n     * <li>if all else fails, return {@link #getBaseSectionOutlineStroke()}.\n     * </ul> \n     * \n     * @param key  the section key.\n     * @param autoPopulate  a flag that controls whether the drawing supplier \n     *     is used to auto-populate the section outline stroke settings.\n     *     \n     * @return The stroke.\n     * \n     * @since 1.0.3\n     */\n    protected Stroke lookupSectionOutlineStroke(Comparable key, \n            boolean autoPopulate) {\n        \n        Stroke result = null;\n        \n        // is a stroke defined for the specified key\n        result = this.sectionOutlineStrokeMap.getStroke(key);\n        if (result != null) {\n            return result;\n        }\n        \n        // nothing defined - do we autoPopulate?\n        if (autoPopulate) {\n            DrawingSupplier ds = getDrawingSupplier();\n            if (ds != null) {\n                result = ds.getNextOutlineStroke();\n                this.sectionOutlineStrokeMap.put(key, result);\n            }\n            else {\n                result = this.baseSectionOutlineStroke;\n            }\n        }\n        else {\n            result = this.baseSectionOutlineStroke;\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the outline stroke associated with the specified key, or \n     * <code>null</code> if there is no stroke associated with the key.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * \n     * @return The stroke associated with the specified key, or \n     *     <code>null</code>.\n     *     \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     * \n     * @see #setSectionOutlineStroke(Comparable, Stroke)\n     * \n     * @since 1.0.3\n     */\n    public Stroke getSectionOutlineStroke(Comparable key) {\n        // null argument check delegated...\n        return this.sectionOutlineStrokeMap.getStroke(key);\n    }\n    \n    /**\n     * Sets the outline stroke associated with the specified key, and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * @param stroke  the stroke.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     *     \n     * @see #getSectionOutlineStroke(Comparable)\n     * \n     * @since 1.0.3\n     */\n    public void setSectionOutlineStroke(Comparable key, Stroke stroke) {\n        // null argument check delegated...\n        this.sectionOutlineStrokeMap.put(key, stroke);\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the base section stroke.  This is used when no other stroke is \n     * available.\n     * \n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setBaseSectionOutlineStroke(Stroke)\n     */\n    public Stroke getBaseSectionOutlineStroke() {\n        return this.baseSectionOutlineStroke;   \n    }\n    \n    /**\n     * Sets the base section stroke.\n     * \n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getBaseSectionOutlineStroke()\n     */\n    public void setBaseSectionOutlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.baseSectionOutlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the shadow paint.\n     * \n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setShadowPaint(Paint)\n     */\n    public Paint getShadowPaint() {\n        return this.shadowPaint;   \n    }\n    \n    /**\n     * Sets the shadow paint and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getShadowPaint()\n     */\n    public void setShadowPaint(Paint paint) {\n        this.shadowPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the x-offset for the shadow effect.\n     * \n     * @return The offset (in Java2D units).\n     * \n     * @see #setShadowXOffset(double)\n     */\n    public double getShadowXOffset() {\n        return this.shadowXOffset;\n    }\n    \n    /**\n     * Sets the x-offset for the shadow effect and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param offset  the offset (in Java2D units).\n     * \n     * @see #getShadowXOffset()\n     */\n    public void setShadowXOffset(double offset) {\n        this.shadowXOffset = offset;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the y-offset for the shadow effect.\n     * \n     * @return The offset (in Java2D units).\n     * \n     * @see #setShadowYOffset(double)\n     */\n    public double getShadowYOffset() {\n        return this.shadowYOffset;\n    }\n    \n    /**\n     * Sets the y-offset for the shadow effect and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param offset  the offset (in Java2D units).\n     * \n     * @see #getShadowYOffset()\n     */\n    public void setShadowYOffset(double offset) {\n        this.shadowYOffset = offset;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the amount that the section with the specified key should be\n     * exploded.\n     * \n     * @param key  the key (<code>null</code> not permitted).\n     * \n     * @return The amount that the section with the specified key should be\n     *     exploded.\n     * \n     * @throws IllegalArgumentException if <code>key</code> is \n     *     <code>null</code>.\n     *\n     * @since 1.0.3\n     * \n     * @see #setExplodePercent(Comparable, double)\n     */\n    public double getExplodePercent(Comparable key) {\n        double result = 0.0;\n        if (this.explodePercentages != null) {\n            Number percent = (Number) this.explodePercentages.get(key);\n            if (percent != null) {\n                result = percent.doubleValue();\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Sets the amount that a pie section should be exploded and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param key  the section key (<code>null</code> not permitted).\n     * @param percent  the explode percentage (0.30 = 30 percent).\n     * \n     * @since 1.0.3\n     * \n     * @see #getExplodePercent(Comparable)\n     */\n    public void setExplodePercent(Comparable key, double percent) {\n        if (key == null) { \n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (this.explodePercentages == null) {\n            this.explodePercentages = new TreeMap();\n        }\n        this.explodePercentages.put(key, new Double(percent));\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the maximum explode percent.\n     * \n     * @return The percent.\n     */\n    public double getMaximumExplodePercent() {\n        double result = 0.0;\n        Iterator iterator = this.dataset.getKeys().iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Number explode = (Number) this.explodePercentages.get(key);\n            if (explode != null) {\n                result = Math.max(result, explode.doubleValue());   \n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the section label generator. \n     * \n     * @return The generator (possibly <code>null</code>).\n     * \n     * @see #setLabelGenerator(PieSectionLabelGenerator)\n     */\n    public PieSectionLabelGenerator getLabelGenerator() {\n        return this.labelGenerator;   \n    }\n    \n    /**\n     * Sets the section label generator and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     * \n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getLabelGenerator()\n     */\n    public void setLabelGenerator(PieSectionLabelGenerator generator) {\n        this.labelGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the gap between the edge of the pie and the labels, expressed as \n     * a percentage of the plot width.\n     * \n     * @return The gap (a percentage, where 0.05 = five percent).\n     * \n     * @see #setLabelGap(double)\n     */\n    public double getLabelGap() {\n        return this.labelGap;   \n    }\n    \n    /**\n     * Sets the gap between the edge of the pie and the labels (expressed as a \n     * percentage of the plot width) and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     * \n     * @param gap  the gap (a percentage, where 0.05 = five percent).\n     * \n     * @see #getLabelGap()\n     */\n    public void setLabelGap(double gap) {\n        this.labelGap = gap;   \n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the maximum label width as a percentage of the plot width.\n     * \n     * @return The width (a percentage, where 0.20 = 20 percent).\n     * \n     * @see #setMaximumLabelWidth(double)\n     */\n    public double getMaximumLabelWidth() {\n        return this.maximumLabelWidth;   \n    }\n    \n    /**\n     * Sets the maximum label width as a percentage of the plot width and sends\n     * a {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param width  the width (a percentage, where 0.20 = 20 percent).\n     * \n     * @see #getMaximumLabelWidth()\n     */\n    public void setMaximumLabelWidth(double width) {\n        this.maximumLabelWidth = width;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the flag that controls whether or not label linking lines are\n     * visible.\n     * \n     * @return A boolean.\n     * \n     * @see #setLabelLinksVisible(boolean)\n     */\n    public boolean getLabelLinksVisible() {\n        return this.labelLinksVisible;\n    }\n    \n    /**\n     * Sets the flag that controls whether or not label linking lines are \n     * visible and sends a {@link PlotChangeEvent} to all registered listeners.\n     * Please take care when hiding the linking lines - depending on the data \n     * values, the labels can be displayed some distance away from the\n     * corresponding pie section.\n     * \n     * @param visible  the flag.\n     * \n     * @see #getLabelLinksVisible()\n     */\n    public void setLabelLinksVisible(boolean visible) {\n        this.labelLinksVisible = visible;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the margin (expressed as a percentage of the width or height) \n     * between the edge of the pie and the link point.\n     * \n     * @return The link margin (as a percentage, where 0.05 is five percent).\n     * \n     * @see #setLabelLinkMargin(double)\n     */\n    public double getLabelLinkMargin() {\n        return this.labelLinkMargin;   \n    }\n    \n    /**\n     * Sets the link margin and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param margin  the margin.\n     * \n     * @see #getLabelLinkMargin()\n     */\n    public void setLabelLinkMargin(double margin) {\n        this.labelLinkMargin = margin;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the paint used for the lines that connect pie sections to their \n     * corresponding labels.\n     * \n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setLabelLinkPaint(Paint)\n     */\n    public Paint getLabelLinkPaint() {\n        return this.labelLinkPaint;   \n    }\n    \n    /**\n     * Sets the paint used for the lines that connect pie sections to their \n     * corresponding labels, and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getLabelLinkPaint()\n     */\n    public void setLabelLinkPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelLinkPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the stroke used for the label linking lines.\n     * \n     * @return The stroke.\n     * \n     * @see #setLabelLinkStroke(Stroke)\n     */\n    public Stroke getLabelLinkStroke() {\n        return this.labelLinkStroke;   \n    }\n    \n    /**\n     * Sets the link stroke and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param stroke  the stroke.\n     * \n     * @see #getLabelLinkStroke()\n     */\n    public void setLabelLinkStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.labelLinkStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the section label font.\n     *\n     * @return The font (never <code>null</code>).\n     * \n     * @see #setLabelFont(Font)\n     */\n    public Font getLabelFont() {\n        return this.labelFont;\n    }\n\n    /**\n     * Sets the section label font and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param font  the font (<code>null</code> not permitted).\n     * \n     * @see #getLabelFont()\n     */\n    public void setLabelFont(Font font) {\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n        this.labelFont = font;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label paint.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setLabelPaint(Paint)\n     */\n    public Paint getLabelPaint() {\n        return this.labelPaint;\n    }\n\n    /**\n     * Sets the section label paint and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getLabelPaint()\n     */\n    public void setLabelPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.labelPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label background paint.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setLabelBackgroundPaint(Paint)\n     */\n    public Paint getLabelBackgroundPaint() {\n        return this.labelBackgroundPaint;\n    }\n\n    /**\n     * Sets the section label background paint and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getLabelBackgroundPaint()\n     */\n    public void setLabelBackgroundPaint(Paint paint) {\n        this.labelBackgroundPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label outline paint.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setLabelOutlinePaint(Paint)\n     */\n    public Paint getLabelOutlinePaint() {\n        return this.labelOutlinePaint;\n    }\n\n    /**\n     * Sets the section label outline paint and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getLabelOutlinePaint()\n     */\n    public void setLabelOutlinePaint(Paint paint) {\n        this.labelOutlinePaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label outline stroke.\n     *\n     * @return The stroke (possibly <code>null</code>).\n     * \n     * @see #setLabelOutlineStroke(Stroke)\n     */\n    public Stroke getLabelOutlineStroke() {\n        return this.labelOutlineStroke;\n    }\n\n    /**\n     * Sets the section label outline stroke and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> permitted).\n     * \n     * @see #getLabelOutlineStroke()\n     */\n    public void setLabelOutlineStroke(Stroke stroke) {\n        this.labelOutlineStroke = stroke;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the section label shadow paint.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setLabelShadowPaint(Paint)\n     */\n    public Paint getLabelShadowPaint() {\n        return this.labelShadowPaint;\n    }\n\n    /**\n     * Sets the section label shadow paint and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getLabelShadowPaint()\n     */\n    public void setLabelShadowPaint(Paint paint) {\n        this.labelShadowPaint = paint;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the label padding.\n     * \n     * @return The label padding (never <code>null</code>).\n     * \n     * @since 1.0.7\n     * \n     * @see #setLabelPadding(RectangleInsets)\n     */\n    public RectangleInsets getLabelPadding() {\n        return this.labelPadding;\n    }\n    \n    /**\n     * Sets the padding between each label and its outline and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param padding  the padding (<code>null</code> not permitted).\n     * \n     * @since 1.0.7\n     * \n     * @see #getLabelPadding()\n     */\n    public void setLabelPadding(RectangleInsets padding) {\n        if (padding == null) {\n            throw new IllegalArgumentException(\"Null 'padding' argument.\");\n        }\n        this.labelPadding = padding;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the flag that controls whether simple or extended labels are\n     * displayed on the plot.\n     * \n     * @return A boolean.\n     * \n     * @since 1.0.7\n     */\n    public boolean getSimpleLabels() {\n        return this.simpleLabels;\n    }\n    \n    /**\n     * Sets the flag that controls whether simple or extended labels are \n     * displayed on the plot, and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param simple  the new flag value.\n     * \n     * @since 1.0.7\n     */\n    public void setSimpleLabels(boolean simple) {\n        this.simpleLabels = simple;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the offset used for the simple labels, if they are displayed.\n     * \n     * @return The offset (never <code>null</code>).\n     * \n     * @since 1.0.7\n     * \n     * @see #setSimpleLabelOffset(RectangleInsets)\n     */\n    public RectangleInsets getSimpleLabelOffset() {\n        return this.simpleLabelOffset;\n    }\n    \n    /**\n     * Sets the offset for the simple labels and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param offset  the offset (<code>null</code> not permitted).\n     * \n     * @since 1.0.7\n     * \n     * @see #getSimpleLabelOffset()\n     */\n    public void setSimpleLabelOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.simpleLabelOffset = offset;\n        notifyListeners(new PlotChangeEvent(this));        \n    }\n    \n    /**\n     * Returns the object responsible for the vertical layout of the pie \n     * section labels.\n     * \n     * @return The label distributor (never <code>null</code>).\n     * \n     * @since 1.0.6\n     */\n    public AbstractPieLabelDistributor getLabelDistributor() {\n        return this.labelDistributor;\n    }\n    \n    /**\n     * Sets the label distributor and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param distributor  the distributor (<code>null</code> not permitted).\n     *\n     * @since 1.0.6\n     */\n    public void setLabelDistributor(AbstractPieLabelDistributor distributor) {\n        if (distributor == null) {\n            throw new IllegalArgumentException(\"Null 'distributor' argument.\");\n        }\n        this.labelDistributor = distributor;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the tool tip generator, an object that is responsible for \n     * generating the text items used for tool tips by the plot.  If the \n     * generator is <code>null</code>, no tool tips will be created.\n     *\n     * @return The generator (possibly <code>null</code>).\n     * \n     * @see #setToolTipGenerator(PieToolTipGenerator)\n     */\n    public PieToolTipGenerator getToolTipGenerator() {\n        return this.toolTipGenerator;\n    }\n\n    /**\n     * Sets the tool tip generator and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  Set the generator to <code>null</code> if you \n     * don't want any tool tips.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getToolTipGenerator()\n     */\n    public void setToolTipGenerator(PieToolTipGenerator generator) {\n        this.toolTipGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the URL generator.\n     *\n     * @return The generator (possibly <code>null</code>).\n     * \n     * @see #setURLGenerator(PieURLGenerator)\n     */\n    public PieURLGenerator getURLGenerator() {\n        return this.urlGenerator;\n    }\n\n    /**\n     * Sets the URL generator and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getURLGenerator()\n     */\n    public void setURLGenerator(PieURLGenerator generator) {\n        this.urlGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n\n    /**\n     * Returns the minimum arc angle that will be drawn.  Pie sections for an \n     * angle smaller than this are not drawn, to avoid a JDK bug.\n     *\n     * @return The minimum angle.\n     * \n     * @see #setMinimumArcAngleToDraw(double)\n     */\n    public double getMinimumArcAngleToDraw() {\n        return this.minimumArcAngleToDraw;\n    }\n\n    /**\n     * Sets the minimum arc angle that will be drawn.  Pie sections for an \n     * angle smaller than this are not drawn, to avoid a JDK bug.  See this \n     * link for details:\n     * <br><br>\n     * <a href=\"http://www.jfree.org/phpBB2/viewtopic.php?t=2707\">\n     * http://www.jfree.org/phpBB2/viewtopic.php?t=2707</a>\n     * <br><br>\n     * ...and this bug report in the Java Bug Parade:\n     * <br><br>\n     * <a href=\n     * \"http://developer.java.sun.com/developer/bugParade/bugs/4836495.html\">\n     * http://developer.java.sun.com/developer/bugParade/bugs/4836495.html</a>\n     *\n     * @param angle  the minimum angle.\n     * \n     * @see #getMinimumArcAngleToDraw()\n     */\n    public void setMinimumArcAngleToDraw(double angle) {\n        this.minimumArcAngleToDraw = angle;\n    }\n    \n    /**\n     * Returns the shape used for legend items.\n     * \n     * @return The shape (never <code>null</code>).\n     * \n     * @see #setLegendItemShape(Shape)\n     */\n    public Shape getLegendItemShape() {\n        return this.legendItemShape;\n    }\n\n    /**\n     * Sets the shape used for legend items and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param shape  the shape (<code>null</code> not permitted).\n     * \n     * @see #getLegendItemShape()\n     */\n    public void setLegendItemShape(Shape shape) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        this.legendItemShape = shape;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the legend label generator.\n     * \n     * @return The legend label generator (never <code>null</code>).\n     * \n     * @see #setLegendLabelGenerator(PieSectionLabelGenerator)\n     */\n    public PieSectionLabelGenerator getLegendLabelGenerator() {\n        return this.legendLabelGenerator;\n    }\n    \n    /**\n     * Sets the legend label generator and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     * \n     * @param generator  the generator (<code>null</code> not permitted).\n     * \n     * @see #getLegendLabelGenerator()\n     */\n    public void setLegendLabelGenerator(PieSectionLabelGenerator generator) {\n        if (generator == null) {\n            throw new IllegalArgumentException(\"Null 'generator' argument.\");\n        }\n        this.legendLabelGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the legend label tool tip generator.\n     * \n     * @return The legend label tool tip generator (possibly <code>null</code>).\n     * \n     * @see #setLegendLabelToolTipGenerator(PieSectionLabelGenerator)\n     */\n    public PieSectionLabelGenerator getLegendLabelToolTipGenerator() {\n        return this.legendLabelToolTipGenerator;\n    }\n    \n    /**\n     * Sets the legend label tool tip generator and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getLegendLabelToolTipGenerator()\n     */\n    public void setLegendLabelToolTipGenerator(\n            PieSectionLabelGenerator generator) {\n        this.legendLabelToolTipGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Returns the legend label URL generator.\n     * \n     * @return The legend label URL generator (possibly <code>null</code>).\n     * \n     * @see #setLegendLabelURLGenerator(PieURLGenerator)\n     * \n     * @since 1.0.4\n     */\n    public PieURLGenerator getLegendLabelURLGenerator() {\n        return this.legendLabelURLGenerator;\n    }\n    \n    /**\n     * Sets the legend label URL generator and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param generator  the generator (<code>null</code> permitted).\n     * \n     * @see #getLegendLabelURLGenerator()\n     * \n     * @since 1.0.4\n     */\n    public void setLegendLabelURLGenerator(PieURLGenerator generator) {\n        this.legendLabelURLGenerator = generator;\n        notifyListeners(new PlotChangeEvent(this));\n    }\n    \n    /**\n     * Initialises the drawing procedure.  This method will be called before \n     * the first item is rendered, giving the plot an opportunity to initialise\n     * any state information it wants to maintain.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area (<code>null</code> not permitted).\n     * @param plot  the plot.\n     * @param index  the secondary index (<code>null</code> for primary \n     *               renderer).\n     * @param info  collects chart rendering information for return to caller.\n     * \n     * @return A state object (maintains state information relevant to one \n     *         chart drawing).\n     */\n    public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\n            PiePlot plot, Integer index, PlotRenderingInfo info) {\n     \n        PiePlotState state = new PiePlotState(info);\n        state.setPassesRequired(2);\n            state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n                    plot.getDataset()));\n        state.setLatestAngle(plot.getStartAngle());\n        return state;\n        \n    }\n    \n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \n     * printer).\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param info  collects info about the drawing \n     *              (<code>null</code> permitted).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                     PlotState parentState, PlotRenderingInfo info) {\n\n        // adjust for insets...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        if (info != null) {\n            info.setPlotArea(area);\n            info.setDataArea(area);\n        }\n\n        drawBackground(g2, area);\n        drawOutline(g2, area);\n\n        Shape savedClip = g2.getClip();\n        g2.clip(area);\n\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                getForegroundAlpha()));\n\n        if (!DatasetUtilities.isEmptyOrNull(this.dataset)) {\n            drawPie(g2, area, info);\n        }\n        else {\n            drawNoDataMessage(g2, area);\n        }\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, area);\n\n    }\n\n    /**\n     * Draws the pie.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param info  chart rendering info.\n     */\n    protected void drawPie(Graphics2D g2, Rectangle2D plotArea, \n                           PlotRenderingInfo info) {\n\n        PiePlotState state = initialise(g2, plotArea, this, null, info);\n\n        // adjust the plot area for interior spacing and labels...\n        double labelReserve = 0.0;\n        if (this.labelGenerator != null && !this.simpleLabels) {\n            labelReserve = this.labelGap + this.maximumLabelWidth;    \n        }\n        double gapHorizontal = plotArea.getWidth() * (this.interiorGap \n                + labelReserve) * 2.0;\n        double gapVertical = plotArea.getHeight() * this.interiorGap * 2.0;\n\n        \n        if (DEBUG_DRAW_INTERIOR) {\n            double hGap = plotArea.getWidth() * this.interiorGap;\n            double vGap = plotArea.getHeight() * this.interiorGap;\n        \n            double igx1 = plotArea.getX() + hGap;\n            double igx2 = plotArea.getMaxX() - hGap;\n            double igy1 = plotArea.getY() + vGap;\n            double igy2 = plotArea.getMaxY() - vGap;\n            g2.setPaint(Color.gray);\n            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \n                    igy2 - igy1));\n        }\n        \n        double linkX = plotArea.getX() + gapHorizontal / 2;\n        double linkY = plotArea.getY() + gapVertical / 2;\n        double linkW = plotArea.getWidth() - gapHorizontal;\n        double linkH = plotArea.getHeight() - gapVertical;\n        \n        // make the link area a square if the pie chart is to be circular...\n        if (this.circular) {\n            double min = Math.min(linkW, linkH) / 2;\n            linkX = (linkX + linkX + linkW) / 2 - min;\n            linkY = (linkY + linkY + linkH) / 2 - min;\n            linkW = 2 * min;\n            linkH = 2 * min;\n        }\n\n        // the link area defines the dog leg points for the linking lines to \n        // the labels\n        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \n                linkH);\n        state.setLinkArea(linkArea);\n\n        if (DEBUG_DRAW_LINK_AREA) {\n            g2.setPaint(Color.blue);\n            g2.draw(linkArea);\n            g2.setPaint(Color.yellow);\n            g2.draw(new Ellipse2D.Double(linkArea.getX(), linkArea.getY(), \n                    linkArea.getWidth(), linkArea.getHeight()));\n        }\n        \n        // the explode area defines the max circle/ellipse for the exploded \n        // pie sections.  it is defined by shrinking the linkArea by the \n        // linkMargin factor.\n        double lm = 0.0;\n        if (!this.simpleLabels) {\n            lm = this.labelLinkMargin;\n        }\n        double hh = linkArea.getWidth() * lm * 2.0;\n        double vv = linkArea.getHeight() * lm * 2.0;\n        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \n                linkY + vv / 2.0, linkW - hh, linkH - vv);\n       \n        state.setExplodedPieArea(explodeArea);\n        \n        // the pie area defines the circle/ellipse for regular pie sections.\n        // it is defined by shrinking the explodeArea by the explodeMargin \n        // factor. \n        double maximumExplodePercent = getMaximumExplodePercent();\n        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\n        \n        double h1 = explodeArea.getWidth() * percent;\n        double v1 = explodeArea.getHeight() * percent;\n        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \n                + h1 / 2.0, explodeArea.getY() + v1 / 2.0, \n                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\n\n        if (DEBUG_DRAW_PIE_AREA) {\n            g2.setPaint(Color.green);\n            g2.draw(pieArea);\n        }\n        state.setPieArea(pieArea);\n        state.setPieCenterX(pieArea.getCenterX());\n        state.setPieCenterY(pieArea.getCenterY());\n        state.setPieWRadius(pieArea.getWidth() / 2.0);\n        state.setPieHRadius(pieArea.getHeight() / 2.0);\n        \n        // plot the data (unless the dataset is null)...\n        if ((this.dataset != null) && (this.dataset.getKeys().size() > 0)) {\n\n            List keys = this.dataset.getKeys();\n            double totalValue = DatasetUtilities.calculatePieDatasetTotal(\n                    this.dataset);\n\n            int passesRequired = state.getPassesRequired();\n            for (int pass = 0; pass < passesRequired; pass++) {\n                double runningTotal = 0.0;\n                for (int section = 0; section < keys.size(); section++) {\n                    Number n = this.dataset.getValue(section);\n                    if (n != null) {\n                        double value = n.doubleValue();\n                        if (value > 0.0) {\n                            runningTotal += value;\n                            drawItem(g2, section, explodeArea, state, pass);\n                        }\n                    } \n                }\n            }\n            if (this.simpleLabels) {\n                drawSimpleLabels(g2, keys, totalValue, plotArea, linkArea, \n                        state);\n            }\n            else {\n                drawLabels(g2, keys, totalValue, plotArea, linkArea, state);\n            }\n\n        }\n        else {\n            drawNoDataMessage(g2, plotArea);\n        }\n    }\n    \n    /**\n     * Draws a single data item.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param section  the section index.\n     * @param dataArea  the data plot area.\n     * @param state  state information for one chart.\n     * @param currentPass  the current pass index.\n     */\n    protected void drawItem(Graphics2D g2, int section, Rectangle2D dataArea,\n                            PiePlotState state, int currentPass) {\n    \n        Number n = this.dataset.getValue(section);\n        if (n == null) {\n            return;   \n        }\n        double value = n.doubleValue();\n        double angle1 = 0.0;\n        double angle2 = 0.0;\n        \n        if (this.direction == Rotation.CLOCKWISE) {\n            angle1 = state.getLatestAngle();\n            angle2 = angle1 - value / state.getTotal() * 360.0;\n        }\n        else if (this.direction == Rotation.ANTICLOCKWISE) {\n            angle1 = state.getLatestAngle();\n            angle2 = angle1 + value / state.getTotal() * 360.0;         \n        }\n        else {\n            throw new IllegalStateException(\"Rotation type not recognised.\");   \n        }\n        \n        double angle = (angle2 - angle1);\n        if (Math.abs(angle) > getMinimumArcAngleToDraw()) {\n            double ep = 0.0;\n            double mep = getMaximumExplodePercent();\n            if (mep > 0.0) {\n                ep = getExplodePercent(getSectionKey(section)) / mep;                \n            }\n            Rectangle2D arcBounds = getArcBounds(state.getPieArea(), \n                    state.getExplodedPieArea(), angle1, angle, ep);\n            Arc2D.Double arc = new Arc2D.Double(arcBounds, angle1, angle, \n                    Arc2D.PIE);\n            \n            if (currentPass == 0) {\n                if (this.shadowPaint != null) {\n                    Shape shadowArc = ShapeUtilities.createTranslatedShape(\n                            arc, (float) this.shadowXOffset, \n                            (float) this.shadowYOffset);\n                    g2.setPaint(this.shadowPaint);\n                    g2.fill(shadowArc);\n                }\n            }\n            else if (currentPass == 1) {\n                Comparable key = getSectionKey(section);\n                Paint paint = lookupSectionPaint(key, true);\n                g2.setPaint(paint);\n                g2.fill(arc);\n\n                Paint outlinePaint = lookupSectionOutlinePaint(key);\n                Stroke outlineStroke = lookupSectionOutlineStroke(key);\n                if (this.sectionOutlinesVisible) {\n                    g2.setPaint(outlinePaint);\n                    g2.setStroke(outlineStroke);\n                    g2.draw(arc);\n                }\n                \n                // update the linking line target for later\n                // add an entity for the pie section\n                if (state.getInfo() != null) {\n                    EntityCollection entities = state.getEntityCollection();\n                    if (entities != null) {\n                        String tip = null;\n                        if (this.toolTipGenerator != null) {\n                            tip = this.toolTipGenerator.generateToolTip(\n                                    this.dataset, key);\n                        }\n                        String url = null;\n                        if (this.urlGenerator != null) {\n                            url = this.urlGenerator.generateURL(this.dataset, \n                                    key, this.pieIndex);\n                        }\n                        PieSectionEntity entity = new PieSectionEntity(\n                                arc, this.dataset, this.pieIndex, section, key,\n                                tip, url);\n                        entities.add(entity);\n                    }\n                }\n            }\n        }    \n        state.setLatestAngle(angle2);\n    }\n    \n    /**\n     * Draws the pie section labels in the simple form.\n     * \n     * @param g2  the graphics device.\n     * @param keys  the section keys.\n     * @param totalValue  the total value for all sections in the pie.\n     * @param plotArea  the plot area.\n     * @param pieArea  the area containing the pie.\n     * @param state  the plot state.\n     *\n     * @since 1.0.7\n     */\n    protected void drawSimpleLabels(Graphics2D g2, List keys, \n            double totalValue, Rectangle2D plotArea, Rectangle2D pieArea, \n            PiePlotState state) {\n        \n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                1.0f));\n\n        RectangleInsets labelInsets = new RectangleInsets(UnitType.RELATIVE, \n                0.18, 0.18, 0.18, 0.18);\n        Rectangle2D labelsArea = labelInsets.createInsetRectangle(pieArea);\n        double runningTotal = 0.0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            boolean include = true;\n            double v = 0.0;\n            Number n = getDataset().getValue(key);\n            if (n == null) {\n                include = !getIgnoreNullValues();\n            }\n            else {\n                v = n.doubleValue();\n                include = getIgnoreZeroValues() ? v > 0.0 : v >= 0.0;\n            }\n\n            if (include) {\n                runningTotal = runningTotal + v;\n                // work out the mid angle (0 - 90 and 270 - 360) = right, \n                // otherwise left\n                double mid = getStartAngle() + (getDirection().getFactor()\n                        * ((runningTotal - v / 2.0) * 360) / totalValue);\n                \n                Arc2D arc = new Arc2D.Double(labelsArea, getStartAngle(), \n                        mid - getStartAngle(), Arc2D.OPEN);\n                int x = (int) arc.getEndPoint().getX();\n                int y = (int) arc.getEndPoint().getY();\n                \n                PieSectionLabelGenerator labelGenerator = getLabelGenerator();\n                if (labelGenerator == null) {\n                    continue;\n                }\n                String label = labelGenerator.generateSectionLabel(\n                        this.dataset, key);\n                if (label == null) {\n                    continue;\n                }\n                g2.setFont(this.labelFont);\n                FontMetrics fm = g2.getFontMetrics();\n                Rectangle2D bounds = TextUtilities.getTextBounds(label, g2, fm);\n                Rectangle2D out = this.labelPadding.createOutsetRectangle(\n                        bounds);\n                Shape bg = ShapeUtilities.createTranslatedShape(out, \n                        x - bounds.getCenterX(), y - bounds.getCenterY());\n                if (this.labelShadowPaint != null) {\n                    Shape shadow = ShapeUtilities.createTranslatedShape(bg, \n                            this.shadowXOffset, this.shadowYOffset);\n                    g2.setPaint(this.labelShadowPaint);\n                    g2.fill(shadow);\n                }\n                if (this.labelBackgroundPaint != null) {\n                    g2.setPaint(this.labelBackgroundPaint);\n                    g2.fill(bg);\n                }\n                if (this.labelOutlinePaint != null \n                        && this.labelOutlineStroke != null) {\n                    g2.setPaint(this.labelOutlinePaint);\n                    g2.setStroke(this.labelOutlineStroke);\n                    g2.draw(bg);\n                }\n                \n                g2.setPaint(this.labelPaint);\n                g2.setFont(this.labelFont);\n                TextUtilities.drawAlignedString(getLabelGenerator()\n                        .generateSectionLabel(getDataset(), key), g2, x, y, \n                        TextAnchor.CENTER);\n                \n            }\n        }\n       \n        g2.setComposite(originalComposite);\n\n    }\n\n    /**\n     * Draws the labels for the pie sections.\n     * \n     * @param g2  the graphics device.\n     * @param keys  the keys.\n     * @param totalValue  the total value.\n     * @param plotArea  the plot area.\n     * @param linkArea  the link area.\n     * @param state  the state.\n     */\n    protected void drawLabels(Graphics2D g2, List keys, double totalValue, \n                              Rectangle2D plotArea, Rectangle2D linkArea, \n                              PiePlotState state) {   \n\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                1.0f));\n\n        // classify the keys according to which side the label will appear...\n        DefaultKeyedValues leftKeys = new DefaultKeyedValues();\n        DefaultKeyedValues rightKeys = new DefaultKeyedValues();\n       \n        double runningTotal = 0.0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            boolean include = true;\n            double v = 0.0;\n            Number n = this.dataset.getValue(key);\n            if (n == null) {\n                include = !this.ignoreNullValues;\n            }\n            else {\n                v = n.doubleValue();\n                include = this.ignoreZeroValues ? v > 0.0 : v >= 0.0;\n            }\n\n            if (include) {\n                runningTotal = runningTotal + v;\n                // work out the mid angle (0 - 90 and 270 - 360) = right, \n                // otherwise left\n                double mid = this.startAngle + (this.direction.getFactor()\n                        * ((runningTotal - v / 2.0) * 360) / totalValue);\n                if (Math.cos(Math.toRadians(mid)) < 0.0) {\n                    leftKeys.addValue(key, new Double(mid));\n                }\n                else {\n                    rightKeys.addValue(key, new Double(mid));\n                }\n            }\n        }\n       \n        g2.setFont(getLabelFont());\n        \n        // calculate the max label width from the plot dimensions, because\n        // a circular pie can leave a lot more room for labels...\n        double marginX = plotArea.getX() + this.interiorGap * plotArea.getWidth();\n        double gap = plotArea.getWidth() * this.labelGap;\n        double ww = linkArea.getX() - gap - marginX;\n        float labelWidth = (float) this.labelPadding.trimWidth(ww);\n        \n        // draw the labels...\n        if (this.labelGenerator != null) {\n            drawLeftLabels(leftKeys, g2, plotArea, linkArea, labelWidth, \n                    state);\n            drawRightLabels(rightKeys, g2, plotArea, linkArea, labelWidth, \n                    state);\n        }\n        g2.setComposite(originalComposite);\n\n    }\n\n    /**\n     * Draws the left labels.\n     * \n     * @param leftKeys  a collection of keys and angles (to the middle of the\n     *         section, in degrees) for the sections on the left side of the \n     *         plot.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param linkArea  the link area.\n     * @param maxLabelWidth  the maximum label width.\n     * @param state  the state.\n     */\n    protected void drawLeftLabels(KeyedValues leftKeys, Graphics2D g2, \n                                  Rectangle2D plotArea, Rectangle2D linkArea, \n                                  float maxLabelWidth, PiePlotState state) {\n        \n        this.labelDistributor.clear();\n        double lGap = plotArea.getWidth() * this.labelGap;\n        double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;\n        for (int i = 0; i < leftKeys.getItemCount(); i++) {   \n            String label = this.labelGenerator.generateSectionLabel(\n                    this.dataset, leftKeys.getKey(i));\n            if (label != null) {\n                TextBlock block = TextUtilities.createTextBlock(label, \n                        this.labelFont, this.labelPaint, maxLabelWidth, \n                        new G2TextMeasurer(g2));\n                TextBox labelBox = new TextBox(block);\n                labelBox.setBackgroundPaint(this.labelBackgroundPaint);\n                labelBox.setOutlinePaint(this.labelOutlinePaint);\n                labelBox.setOutlineStroke(this.labelOutlineStroke);\n                labelBox.setShadowPaint(this.labelShadowPaint);\n                labelBox.setInteriorGap(this.labelPadding);\n                double theta = Math.toRadians(\n                        leftKeys.getValue(i).doubleValue());\n                double baseY = state.getPieCenterY() - Math.sin(theta) \n                               * verticalLinkRadius;\n                double hh = labelBox.getHeight(g2);\n\n                this.labelDistributor.addPieLabelRecord(new PieLabelRecord(\n                        leftKeys.getKey(i), theta, baseY, labelBox, hh,\n                        lGap / 2.0 + lGap / 2.0 * -Math.cos(theta), 0.9 \n                        + getExplodePercent(leftKeys.getKey(i))));\n            }\n        }\n        this.labelDistributor.distributeLabels(plotArea.getMinY(), \n                plotArea.getHeight());\n        for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {\n            drawLeftLabel(g2, state, \n                    this.labelDistributor.getPieLabelRecord(i));\n        }\n    }\n    \n    /**\n     * Draws the right labels.\n     * \n     * @param keys  the keys.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param linkArea  the link area.\n     * @param maxLabelWidth  the maximum label width.\n     * @param state  the state.\n     */\n    protected void drawRightLabels(KeyedValues keys, Graphics2D g2, \n                                   Rectangle2D plotArea, Rectangle2D linkArea, \n                                   float maxLabelWidth, PiePlotState state) {\n\n        // draw the right labels...\n        this.labelDistributor.clear();\n        double lGap = plotArea.getWidth() * this.labelGap;\n        double verticalLinkRadius = state.getLinkArea().getHeight() / 2.0;\n\n        for (int i = 0; i < keys.getItemCount(); i++) {\n            String label = this.labelGenerator.generateSectionLabel(\n                    this.dataset, keys.getKey(i));\n\n            if (label != null) {\n                TextBlock block = TextUtilities.createTextBlock(label, \n                        this.labelFont, this.labelPaint, maxLabelWidth, \n                        new G2TextMeasurer(g2));\n                TextBox labelBox = new TextBox(block);\n                labelBox.setBackgroundPaint(this.labelBackgroundPaint);\n                labelBox.setOutlinePaint(this.labelOutlinePaint);\n                labelBox.setOutlineStroke(this.labelOutlineStroke);\n                labelBox.setShadowPaint(this.labelShadowPaint);\n                labelBox.setInteriorGap(this.labelPadding);\n                double theta = Math.toRadians(keys.getValue(i).doubleValue());\n                double baseY = state.getPieCenterY() \n                              - Math.sin(theta) * verticalLinkRadius;\n                double hh = labelBox.getHeight(g2);\n                this.labelDistributor.addPieLabelRecord(new PieLabelRecord(\n                        keys.getKey(i), theta, baseY, labelBox, hh,\n                        lGap / 2.0 + lGap / 2.0 * Math.cos(theta), \n                        0.9 + getExplodePercent(keys.getKey(i))));\n            }\n        }\n        this.labelDistributor.distributeLabels(plotArea.getMinY(), \n                plotArea.getHeight());\n        for (int i = 0; i < this.labelDistributor.getItemCount(); i++) {\n            drawRightLabel(g2, state, \n                    this.labelDistributor.getPieLabelRecord(i));\n        }\n\n    }\n    \n    /**\n     * Returns a collection of legend items for the pie chart.\n     *\n     * @return The legend items (never <code>null</code>).\n     */\n    public LegendItemCollection getLegendItems() {\n\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.dataset == null) {\n            return result;\n        }\n        List keys = this.dataset.getKeys();\n        int section = 0;\n        Shape shape = getLegendItemShape();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Number n = this.dataset.getValue(key);\n            boolean include = true;\n            if (n == null) {\n                include = !this.ignoreNullValues;   \n            }\n            else {\n                double v = n.doubleValue();\n                if (v == 0.0) {\n                    include = !this.ignoreZeroValues;   \n                }\n                else {\n                    include = v > 0.0;   \n                }\n            }\n            if (include) {\n                String label = this.legendLabelGenerator.generateSectionLabel(\n                        this.dataset, key);\n                if (label != null) {\n                    String description = label;\n                    String toolTipText = null;\n                    if (this.legendLabelToolTipGenerator != null) {\n                        toolTipText = this.legendLabelToolTipGenerator\n                                .generateSectionLabel(this.dataset, key);\n                    }\n                    String urlText = null;\n                    if (this.legendLabelURLGenerator != null) {\n                        urlText = this.legendLabelURLGenerator.generateURL(\n                                this.dataset, key, this.pieIndex);\n                    }\n                    Paint paint = lookupSectionPaint(key, true);\n                    Paint outlinePaint = lookupSectionOutlinePaint(key);\n                    Stroke outlineStroke = lookupSectionOutlineStroke(key);\n                    LegendItem item = new LegendItem(label, description, \n                            toolTipText, urlText, true, shape, true, paint, \n                            true, outlinePaint, outlineStroke, \n                            false,          // line not visible\n                            new Line2D.Float(), new BasicStroke(), Color.black);\n                    item.setDataset(getDataset());\n                    result.add(item);\n                }\n                section++;\n            }\n            else {\n                section++;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a short string describing the type of plot.\n     *\n     * @return The plot type.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"Pie_Plot\");\n    }\n\n    /**\n     * Returns a rectangle that can be used to create a pie section (taking\n     * into account the amount by which the pie section is 'exploded').\n     *\n     * @param unexploded  the area inside which the unexploded pie sections are\n     *                    drawn.\n     * @param exploded  the area inside which the exploded pie sections are \n     *                  drawn.\n     * @param angle  the start angle.\n     * @param extent  the extent of the arc.\n     * @param explodePercent  the amount by which the pie section is exploded.\n     *\n     * @return A rectangle that can be used to create a pie section.\n     */\n    protected Rectangle2D getArcBounds(Rectangle2D unexploded, \n                                       Rectangle2D exploded,\n                                       double angle, double extent, \n                                       double explodePercent) {\n\n        if (explodePercent == 0.0) {\n            return unexploded;\n        }\n        else {\n            Arc2D arc1 = new Arc2D.Double(unexploded, angle, extent / 2, \n                    Arc2D.OPEN);\n            Point2D point1 = arc1.getEndPoint();\n            Arc2D.Double arc2 = new Arc2D.Double(exploded, angle, extent / 2, \n                    Arc2D.OPEN);\n            Point2D point2 = arc2.getEndPoint();\n            double deltaX = (point1.getX() - point2.getX()) * explodePercent;\n            double deltaY = (point1.getY() - point2.getY()) * explodePercent;\n            return new Rectangle2D.Double(unexploded.getX() - deltaX, \n                    unexploded.getY() - deltaY, unexploded.getWidth(), \n                    unexploded.getHeight());\n        }\n    }\n    \n    /**\n     * Draws a section label on the left side of the pie chart.\n     * \n     * @param g2  the graphics device.\n     * @param state  the state.\n     * @param record  the label record.\n     */\n    protected void drawLeftLabel(Graphics2D g2, PiePlotState state, \n                                 PieLabelRecord record) {\n\n        double anchorX = state.getLinkArea().getMinX();\n        double targetX = anchorX - record.getGap();\n        double targetY = record.getAllocatedY();\n        \n        if (this.labelLinksVisible) {\n            double theta = record.getAngle();\n            double linkX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getPieWRadius() * record.getLinkPercent();\n            double linkY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getPieHRadius() * record.getLinkPercent();\n            double elbowX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getLinkArea().getWidth() / 2.0;\n            double elbowY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getLinkArea().getHeight() / 2.0;\n            double anchorY = elbowY;\n            g2.setPaint(this.labelLinkPaint);\n            g2.setStroke(this.labelLinkStroke);\n            g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));\n        }\n        TextBox tb = record.getLabel();\n        tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.RIGHT);\n        \n    }\n\n    /**\n     * Draws a section label on the right side of the pie chart.\n     * \n     * @param g2  the graphics device.\n     * @param state  the state.\n     * @param record  the label record.\n     */\n    protected void drawRightLabel(Graphics2D g2, PiePlotState state, \n                                  PieLabelRecord record) {\n        \n        double anchorX = state.getLinkArea().getMaxX();\n        double targetX = anchorX + record.getGap();\n        double targetY = record.getAllocatedY();\n        \n        if (this.labelLinksVisible) {\n            double theta = record.getAngle();\n            double linkX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getPieWRadius() * record.getLinkPercent();\n            double linkY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getPieHRadius() * record.getLinkPercent();\n            double elbowX = state.getPieCenterX() + Math.cos(theta) \n                    * state.getLinkArea().getWidth() / 2.0;\n            double elbowY = state.getPieCenterY() - Math.sin(theta) \n                    * state.getLinkArea().getHeight() / 2.0;\n            double anchorY = elbowY;\n            g2.setPaint(this.labelLinkPaint);\n            g2.setStroke(this.labelLinkStroke);\n            g2.draw(new Line2D.Double(linkX, linkY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, elbowX, elbowY));\n            g2.draw(new Line2D.Double(anchorX, anchorY, targetX, targetY));\n        }\n        \n        TextBox tb = record.getLabel();\n        tb.draw(g2, (float) targetX, (float) targetY, RectangleAnchor.LEFT);\n    \n    }\n\n    /**\n     * Tests this plot for equality with an arbitrary object.  Note that the \n     * plot's dataset is NOT included in the test for equality.\n     *\n     * @param obj  the object to test against (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof PiePlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        PiePlot that = (PiePlot) obj;\n        if (this.pieIndex != that.pieIndex) {\n            return false;\n        }\n        if (this.interiorGap != that.interiorGap) {\n            return false;\n        }\n        if (this.circular != that.circular) {\n            return false;\n        }\n        if (this.startAngle != that.startAngle) {\n            return false;\n        }\n        if (this.direction != that.direction) {\n            return false;\n        }\n        if (this.ignoreZeroValues != that.ignoreZeroValues) {\n            return false;\n        }\n        if (this.ignoreNullValues != that.ignoreNullValues) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionPaintMap, \n                that.sectionPaintMap)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.baseSectionPaint, \n                that.baseSectionPaint)) {\n            return false;\n        }\n        if (this.sectionOutlinesVisible != that.sectionOutlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionOutlinePaintMap, \n                that.sectionOutlinePaintMap)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(\n            this.baseSectionOutlinePaint, that.baseSectionOutlinePaint\n        )) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.sectionOutlineStrokeMap, \n                that.sectionOutlineStrokeMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(\n            this.baseSectionOutlineStroke, that.baseSectionOutlineStroke\n        )) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.shadowPaint, that.shadowPaint)) {\n            return false;\n        }\n        if (!(this.shadowXOffset == that.shadowXOffset)) {\n            return false;\n        }\n        if (!(this.shadowYOffset == that.shadowYOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.explodePercentages, \n                that.explodePercentages)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelGenerator, \n                that.labelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelBackgroundPaint, \n                that.labelBackgroundPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelOutlinePaint, \n                that.labelOutlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelOutlineStroke, \n                that.labelOutlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelShadowPaint, \n                that.labelShadowPaint)) {\n            return false;\n        }\n        if (this.simpleLabels != that.simpleLabels) {\n            return false;\n        }\n        if (!this.simpleLabelOffset.equals(that.simpleLabelOffset)) {\n            return false;\n        }\n        if (!this.labelPadding.equals(that.labelPadding)) {\n            return false;\n        }\n        if (!(this.maximumLabelWidth == that.maximumLabelWidth)) {\n            return false;\n        }\n        if (!(this.labelGap == that.labelGap)) {\n            return false;\n        }\n        if (!(this.labelLinkMargin == that.labelLinkMargin)) {\n            return false;\n        }\n        if (this.labelLinksVisible != that.labelLinksVisible) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.labelLinkPaint, that.labelLinkPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.labelLinkStroke, \n                that.labelLinkStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.toolTipGenerator, \n                that.toolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.urlGenerator, that.urlGenerator)) {\n            return false;\n        }\n        if (!(this.minimumArcAngleToDraw == that.minimumArcAngleToDraw)) {\n            return false;\n        }\n        if (!ShapeUtilities.equal(this.legendItemShape, that.legendItemShape)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelGenerator, \n                that.legendLabelGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelToolTipGenerator,\n                that.legendLabelToolTipGenerator)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.legendLabelURLGenerator,\n                that.legendLabelURLGenerator)) {\n            return false;\n        }\n        // can't find any difference...\n        return true;\n    }\n\n    /**\n     * Returns a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the plot does \n     *         not support cloning.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        PiePlot clone = (PiePlot) super.clone();\n        if (clone.dataset != null) {\n            clone.dataset.addChangeListener(clone);\n        }\n        if (this.urlGenerator instanceof PublicCloneable) {\n            clone.urlGenerator = (PieURLGenerator) ObjectUtilities.clone(\n                    this.urlGenerator);\n        }\n        clone.legendItemShape = ShapeUtilities.clone(this.legendItemShape);\n        if (this.legendLabelGenerator != null) {\n            clone.legendLabelGenerator = (PieSectionLabelGenerator) \n                    ObjectUtilities.clone(this.legendLabelGenerator);\n        }\n        if (this.legendLabelToolTipGenerator != null) {\n            clone.legendLabelToolTipGenerator = (PieSectionLabelGenerator) \n                    ObjectUtilities.clone(this.legendLabelToolTipGenerator);\n        }\n        if (this.legendLabelURLGenerator instanceof PublicCloneable) {\n            clone.legendLabelURLGenerator = (PieURLGenerator) \n                    ObjectUtilities.clone(this.legendLabelURLGenerator);\n        }\n        return clone;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writePaint(this.baseSectionPaint, stream);\n        SerialUtilities.writePaint(this.baseSectionOutlinePaint, stream);\n        SerialUtilities.writeStroke(this.baseSectionOutlineStroke, stream);\n        SerialUtilities.writePaint(this.shadowPaint, stream);\n        SerialUtilities.writePaint(this.labelPaint, stream);\n        SerialUtilities.writePaint(this.labelBackgroundPaint, stream);\n        SerialUtilities.writePaint(this.labelOutlinePaint, stream);\n        SerialUtilities.writeStroke(this.labelOutlineStroke, stream);\n        SerialUtilities.writePaint(this.labelShadowPaint, stream);\n        SerialUtilities.writePaint(this.labelLinkPaint, stream);\n        SerialUtilities.writeStroke(this.labelLinkStroke, stream);\n        SerialUtilities.writeShape(this.legendItemShape, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.baseSectionPaint = SerialUtilities.readPaint(stream);\n        this.baseSectionOutlinePaint = SerialUtilities.readPaint(stream);\n        this.baseSectionOutlineStroke = SerialUtilities.readStroke(stream);\n        this.shadowPaint = SerialUtilities.readPaint(stream);\n        this.labelPaint = SerialUtilities.readPaint(stream);\n        this.labelBackgroundPaint = SerialUtilities.readPaint(stream);\n        this.labelOutlinePaint = SerialUtilities.readPaint(stream);\n        this.labelOutlineStroke = SerialUtilities.readStroke(stream);\n        this.labelShadowPaint = SerialUtilities.readPaint(stream);\n        this.labelLinkPaint = SerialUtilities.readPaint(stream);\n        this.labelLinkStroke = SerialUtilities.readStroke(stream);\n        this.legendItemShape = SerialUtilities.readShape(stream);\n    }\n\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"id\": 1,\n         \"description\": \"Potential NullPointerException in getLegendItemLabels() method when dataset is null\",\n         \"severity\": \"Medium\",\n         \"location\": \"PiePlot.java\"\n      },\n      {\n         \"id\": 2,\n         \"description\": \"Possible incorrect label drawing due to foreground alpha not being applied\",\n         \"severity\": \"Low\",\n         \"location\": \"PiePlot.java\"\n      },\n      {\n         \"id\": 3,\n         \"description\": \"Potential bug in drawing arcs with minimum angle\",\n         \"severity\": \"Medium\",\n         \"location\": \"PiePlot.java\"\n      },\n      {\n         \"id\": 4,\n         \"description\": \"Missing legend bug due to incorrect data source\",\n         \"severity\": \"High\",\n         \"location\": \"PiePlot.java\"\n      },\n      {\n         \"id\": 5,\n         \"description\": \"Potential clipping bug in draw() method\",\n         \"severity\": \"Medium\",\n         \"location\": \"PiePlot.java\"\n      },\n      {\n         \"id\": 6,\n         \"description\": \"Possible incorrect font alignment in PDF output\",\n         \"severity\": \"Low\",\n         \"location\": \"PiePlot.java\"\n      }\n   ]\n}"}}