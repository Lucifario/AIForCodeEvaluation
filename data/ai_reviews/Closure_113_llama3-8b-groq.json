{"sample_id": "Closure_113", "model": "llama3-8b-groq", "code_context": "/*\n * Copyright 2006 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.JSDocInfoBuilder;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.annotation.Nullable;\n\n/**\n * Replaces goog.provide calls, removes goog.require calls, verifies that\n * goog.require has a corresponding goog.provide and some closure specific\n * simplifications.\n *\n */\nclass ProcessClosurePrimitives extends AbstractPostOrderCallback\n    implements HotSwapCompilerPass {\n\n  static final DiagnosticType NULL_ARGUMENT_ERROR = DiagnosticType.error(\n      \"JSC_NULL_ARGUMENT_ERROR\",\n      \"method \\\"{0}\\\" called without an argument\");\n\n  static final DiagnosticType EXPECTED_OBJECTLIT_ERROR = DiagnosticType.error(\n      \"JSC_EXPECTED_OBJECTLIT_ERROR\",\n      \"method \\\"{0}\\\" expected an object literal argument\");\n\n  static final DiagnosticType EXPECTED_STRING_ERROR = DiagnosticType.error(\n      \"JSC_EXPECTED_STRING_ERROR\",\n      \"method \\\"{0}\\\" expected an object string argument\");\n\n  static final DiagnosticType INVALID_ARGUMENT_ERROR = DiagnosticType.error(\n      \"JSC_INVALID_ARGUMENT_ERROR\",\n      \"method \\\"{0}\\\" called with invalid argument\");\n\n  static final DiagnosticType INVALID_STYLE_ERROR = DiagnosticType.error(\n      \"JSC_INVALID_CSS_NAME_MAP_STYLE_ERROR\",\n      \"Invalid CSS name map style {0}\");\n\n  static final DiagnosticType TOO_MANY_ARGUMENTS_ERROR = DiagnosticType.error(\n      \"JSC_TOO_MANY_ARGUMENTS_ERROR\",\n      \"method \\\"{0}\\\" called with more than one argument\");\n\n  static final DiagnosticType DUPLICATE_NAMESPACE_ERROR = DiagnosticType.error(\n      \"JSC_DUPLICATE_NAMESPACE_ERROR\",\n      \"namespace \\\"{0}\\\" cannot be provided twice\");\n\n  static final DiagnosticType FUNCTION_NAMESPACE_ERROR = DiagnosticType.error(\n      \"JSC_FUNCTION_NAMESPACE_ERROR\",\n      \"\\\"{0}\\\" cannot be both provided and declared as a function\");\n\n  static final DiagnosticType MISSING_PROVIDE_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_PROVIDE_ERROR\",\n      \"required \\\"{0}\\\" namespace never provided\");\n\n  static final DiagnosticType LATE_PROVIDE_ERROR = DiagnosticType.error(\n      \"JSC_LATE_PROVIDE_ERROR\",\n      \"required \\\"{0}\\\" namespace not provided yet\");\n\n  static final DiagnosticType INVALID_PROVIDE_ERROR = DiagnosticType.error(\n      \"JSC_INVALID_PROVIDE_ERROR\",\n      \"\\\"{0}\\\" is not a valid JS identifier name\");\n\n  static final DiagnosticType INVALID_DEFINE_NAME_ERROR = DiagnosticType.error(\n      \"JSC_INVALID_DEFINE_NAME_ERROR\",\n      \"\\\"{0}\\\" is not a valid JS identifier name\");\n\n  static final DiagnosticType MISSING_DEFINE_ANNOTATION = DiagnosticType.error(\n      \"JSC_INVALID_MISSING_DEFINE_ANNOTATION\",\n      \"Missing @define annotation\");\n\n  static final DiagnosticType XMODULE_REQUIRE_ERROR = DiagnosticType.warning(\n      \"JSC_XMODULE_REQUIRE_ERROR\",\n      \"namespace \\\"{0}\\\" provided in module {1} \" +\n      \"but required in module {2}\");\n\n  static final DiagnosticType NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR =\n      DiagnosticType.error(\n          \"JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR\",\n      \"goog.setCssNameMapping only takes an object literal with string values\");\n\n  static final DiagnosticType INVALID_CSS_RENAMING_MAP = DiagnosticType.warning(\n      \"INVALID_CSS_RENAMING_MAP\",\n      \"Invalid entries in css renaming map: {0}\");\n\n  static final DiagnosticType BASE_CLASS_ERROR = DiagnosticType.error(\n      \"JSC_BASE_CLASS_ERROR\",\n      \"incorrect use of goog.base: {0}\");\n\n  /** The root Closure namespace */\n  static final String GOOG = \"goog\";\n\n  private final AbstractCompiler compiler;\n  private final JSModuleGraph moduleGraph;\n\n  // The goog.provides must be processed in a deterministic order.\n  private final Map<String, ProvidedName> providedNames =\n      Maps.newLinkedHashMap();\n\n  private final List<UnrecognizedRequire> unrecognizedRequires =\n      Lists.newArrayList();\n  private final Set<String> exportedVariables = Sets.newHashSet();\n  private final CheckLevel requiresLevel;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final List<Node> defineCalls = Lists.newArrayList();\n\n  ProcessClosurePrimitives(AbstractCompiler compiler,\n      @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n      CheckLevel requiresLevel) {\n    this.compiler = compiler;\n    this.preprocessorSymbolTable = preprocessorSymbolTable;\n    this.moduleGraph = compiler.getModuleGraph();\n    this.requiresLevel = requiresLevel;\n\n    // goog is special-cased because it is provided in Closure's base library.\n    providedNames.put(GOOG,\n        new ProvidedName(GOOG, null, null, false /* implicit */));\n  }\n\n  Set<String> getExportedVariableNames() {\n    return exportedVariables;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    new NodeTraversal(compiler, this).traverse(root);\n\n    for (Node n : defineCalls) {\n      replaceGoogDefines(n);\n    }\n\n    for (ProvidedName pn : providedNames.values()) {\n      pn.replace();\n    }\n\n    if (requiresLevel.isOn()) {\n      for (UnrecognizedRequire r : unrecognizedRequires) {\n        DiagnosticType error;\n        ProvidedName expectedName = providedNames.get(r.namespace);\n        if (expectedName != null && expectedName.firstNode != null) {\n          // The namespace ended up getting provided after it was required.\n          error = LATE_PROVIDE_ERROR;\n        } else {\n          error = MISSING_PROVIDE_ERROR;\n        }\n\n        compiler.report(JSError.make(\n            r.inputName, r.requireNode, requiresLevel, error, r.namespace));\n      }\n    }\n  }\n\n  /**\n   * @param n\n   */\n  private void replaceGoogDefines(Node n) {\n    Node parent = n.getParent();\n    Preconditions.checkState(parent.isExprResult());\n    String name = n.getChildAtIndex(1).getString();\n    Node value = n.getChildAtIndex(2).detachFromParent();\n\n    Node replacement = NodeUtil.newQualifiedNameNodeDeclaration(\n        compiler.getCodingConvention(), name, value, n.getJSDocInfo());\n    replacement.useSourceInfoIfMissingFromForTree(n);\n    parent.getParent().replaceChild(parent, replacement);\n    compiler.reportCodeChange();\n  }\n\n  @Override\n  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n    // TODO(bashir): Implement a real hot-swap version instead and make it fully\n    // consistent with the full version.\n    this.compiler.process(this);\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.CALL:\n        boolean isExpr = parent.isExprResult();\n        Node left = n.getFirstChild();\n        if (left.isGetProp()) {\n          Node name = left.getFirstChild();\n          if (name.isName() &&\n              GOOG.equals(name.getString())) {\n            // For the sake of simplicity, we report code changes\n            // when we see a provides/requires, and don't worry about\n            // reporting the change when we actually do the replacement.\n            String methodName = name.getNext().getString();\n            if (\"base\".equals(methodName)) {\n              processBaseClassCall(t, n);\n            } else if (!isExpr) {\n              // All other methods must be called in an EXPR.\n              break;\n            } else if (\"define\".equals(methodName)) {\n              processDefineCall(t, n, parent);\n            } else if (\"require\".equals(methodName)) {\n              processRequireCall(t, n, parent);\n            } else if (\"provide\".equals(methodName)) {\n              processProvideCall(t, n, parent);\n            } else if (\"exportSymbol\".equals(methodName)) {\n              Node arg = left.getNext();\n              if (arg.isString()) {\n                int dot = arg.getString().indexOf('.');\n                if (dot == -1) {\n                  exportedVariables.add(arg.getString());\n                } else {\n                  exportedVariables.add(arg.getString().substring(0, dot));\n                }\n              }\n            } else if (\"addDependency\".equals(methodName)) {\n              CodingConvention convention = compiler.getCodingConvention();\n              List<String> typeDecls =\n                  convention.identifyTypeDeclarationCall(n);\n              if (typeDecls != null) {\n                for (String typeDecl : typeDecls) {\n                  compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                }\n              }\n\n              // We can't modify parent, so just create a node that will\n              // get compiled out.\n              parent.replaceChild(n, IR.number(0));\n              compiler.reportCodeChange();\n            } else if (\"setCssNameMapping\".equals(methodName)) {\n              processSetCssNameMapping(t, n, parent);\n            }\n          }\n        }\n        break;\n\n      case Token.ASSIGN:\n      case Token.NAME:\n        // If this is an assignment to a provided name, remove the provided\n        // object.\n        handleCandidateProvideDefinition(t, n, parent);\n        break;\n\n      case Token.EXPR_RESULT:\n        handleTypedefDefinition(t, n);\n        break;\n\n      case Token.FUNCTION:\n        // If this is a declaration of a provided named function, this is an\n        // error. Hoisted functions will explode if they're provided.\n        if (t.inGlobalScope() &&\n            !NodeUtil.isFunctionExpression(n)) {\n          String name = n.getFirstChild().getString();\n          ProvidedName pn = providedNames.get(name);\n          if (pn != null) {\n            compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n          }\n        }\n        break;\n\n      case Token.GETPROP:\n        if (n.getFirstChild().isName() &&\n            !parent.isCall() &&\n            !parent.isAssign() &&\n            \"goog.base\".equals(n.getQualifiedName())) {\n          reportBadBaseClassUse(t, n, \"May only be called directly.\");\n        }\n        break;\n    }\n  }\n\n  /**\n   * Handles a goog.require call.\n   */\n  private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyLastArgumentIsString(t, left, arg)) {\n      String ns = arg.getString();\n      ProvidedName provided = providedNames.get(ns);\n      if (provided == null || !provided.isExplicitlyProvided()) {\n        unrecognizedRequires.add(\n            new UnrecognizedRequire(n, ns, t.getSourceName()));\n      } else {\n        JSModule providedModule = provided.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(providedModule);\n\n        JSModule module = t.getModule();\n        if (moduleGraph != null &&\n            module != providedModule &&\n            !moduleGraph.dependsOn(module, providedModule)) {\n          compiler.report(\n              t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                  providedModule.getName(),\n                  module.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      // Requires should be removed before further processing.\n      // Some clients run closure pass multiple times, first with\n      // the checks for broken requires turned off. In these cases, we\n      // allow broken requires to be preserved by the first run to\n      // let them be caught in the subsequent run.\n      if (provided != null) {\n        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  /**\n   * Handles a goog.provide call.\n   */\n  private void processProvideCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyProvide(t, left, arg)) {\n      String ns = arg.getString();\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(arg);\n\n      if (providedNames.containsKey(ns)) {\n        ProvidedName previouslyProvided = providedNames.get(ns);\n        if (!previouslyProvided.isExplicitlyProvided()) {\n          previouslyProvided.addProvide(parent, t.getModule(), true);\n        } else {\n          compiler.report(\n              t.makeError(n, DUPLICATE_NAMESPACE_ERROR, ns));\n        }\n      } else {\n        registerAnyProvidedPrefixes(ns, parent, t.getModule());\n        providedNames.put(\n            ns, new ProvidedName(ns, parent, t.getModule(), true));\n      }\n    }\n  }\n\n    /**\n   * Handles a goog.define call.\n   */\n  private void processDefineCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node args = left.getNext();\n    if (verifyDefine(t, parent, left, args)) {\n      Node nameNode = args;\n      String name = args.getString();\n      Node value = args.getNext();\n\n      maybeAddToSymbolTable(left);\n      maybeAddStringNodeToSymbolTable(nameNode);\n\n      this.defineCalls.add(n);\n    }\n  }\n\n  /**\n   * Handles a typedef definition for a goog.provided name.\n   * @param n EXPR_RESULT node.\n   */\n  private void handleTypedefDefinition(\n      NodeTraversal t, Node n) {\n    JSDocInfo info = n.getFirstChild().getJSDocInfo();\n    if (t.inGlobalScope() && info != null && info.hasTypedefType()) {\n      String name = n.getFirstChild().getQualifiedName();\n      if (name != null) {\n        ProvidedName pn = providedNames.get(name);\n        if (pn != null) {\n          pn.addDefinition(n, t.getModule());\n        }\n      }\n    }\n  }\n\n  /**\n   * Handles a candidate definition for a goog.provided name.\n   */\n  private void handleCandidateProvideDefinition(\n      NodeTraversal t, Node n, Node parent) {\n    if (t.inGlobalScope()) {\n      String name = null;\n      if (n.isName() && parent.isVar()) {\n        name = n.getString();\n      } else if (n.isAssign() &&\n          parent.isExprResult()) {\n        name = n.getFirstChild().getQualifiedName();\n      }\n\n      if (name != null) {\n        if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n          processProvideFromPreviousPass(t, name, parent);\n        } else {\n          ProvidedName pn = providedNames.get(name);\n          if (pn != null) {\n            pn.addDefinition(parent, t.getModule());\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Processes the base class call.\n   */\n  private void processBaseClassCall(NodeTraversal t, Node n) {\n    // Two things must hold for every goog.base call:\n    // 1) We must be calling it on \"this\".\n    // 2) We must be calling it on a prototype method of the same name as\n    //    the one we're in, OR we must be calling it from a constructor.\n    // If both of those things are true, then we can rewrite:\n    // <pre>\n    // function Foo() {\n    //   goog.base(this);\n    // }\n    // goog.inherits(Foo, BaseFoo);\n    // Foo.prototype.bar = function() {\n    //   goog.base(this, 'bar', 1);\n    // };\n    // </pre>\n    // as the easy-to-optimize:\n    // <pre>\n    // function Foo() {\n    //   BaseFoo.call(this);\n    // }\n    // goog.inherits(Foo, BaseFoo);\n    // Foo.prototype.bar = function() {\n    //   Foo.superClass_.bar.call(this, 1);\n    // };\n    //\n    // Most of the logic here is just to make sure the AST's\n    // structure is what we expect it to be.\n\n    Node callee = n.getFirstChild();\n    Node thisArg = callee.getNext();\n    if (thisArg == null || !thisArg.isThis()) {\n      reportBadBaseClassUse(t, n, \"First argument must be 'this'.\");\n      return;\n    }\n\n    Node enclosingFnNameNode = getEnclosingDeclNameNode(t);\n    if (enclosingFnNameNode == null) {\n      reportBadBaseClassUse(t, n, \"Could not find enclosing method.\");\n      return;\n    }\n\n    String enclosingQname = enclosingFnNameNode.getQualifiedName();\n    if (enclosingQname.indexOf(\".prototype.\") == -1) {\n      // Handle constructors.\n      Node enclosingParent = enclosingFnNameNode.getParent();\n      Node maybeInheritsExpr = (enclosingParent.isAssign() ?\n          enclosingParent.getParent() : enclosingParent).getNext();\n      Node baseClassNode = null;\n      if (maybeInheritsExpr != null &&\n          maybeInheritsExpr.isExprResult() &&\n          maybeInheritsExpr.getFirstChild().isCall()) {\n        Node callNode = maybeInheritsExpr.getFirstChild();\n        if (\"goog.inherits\".equals(\n                callNode.getFirstChild().getQualifiedName()) &&\n            callNode.getLastChild().isQualifiedName()) {\n          baseClassNode = callNode.getLastChild();\n        }\n      }\n\n      if (baseClassNode == null) {\n        reportBadBaseClassUse(\n            t, n, \"Could not find goog.inherits for base class\");\n        return;\n      }\n\n      // We're good to go.\n      n.replaceChild(\n          callee,\n          NodeUtil.newQualifiedNameNode(\n            compiler.getCodingConvention(),\n            String.format(\"%s.call\", baseClassNode.getQualifiedName()),\n            callee, \"goog.base\"));\n      compiler.reportCodeChange();\n    } else {\n      // Handle methods.\n      Node methodNameNode = thisArg.getNext();\n      if (methodNameNode == null || !methodNameNode.isString()) {\n        reportBadBaseClassUse(t, n, \"Second argument must name a method.\");\n        return;\n      }\n\n      String methodName = methodNameNode.getString();\n      String ending = \".prototype.\" + methodName;\n      if (enclosingQname == null ||\n          !enclosingQname.endsWith(ending)) {\n        reportBadBaseClassUse(\n            t, n, \"Enclosing method does not match \" + methodName);\n        return;\n      }\n\n      // We're good to go.\n      Node className =\n          enclosingFnNameNode.getFirstChild().getFirstChild();\n      n.replaceChild(\n          callee,\n          NodeUtil.newQualifiedNameNode(\n            compiler.getCodingConvention(),\n            String.format(\"%s.superClass_.%s.call\",\n                className.getQualifiedName(), methodName),\n            callee, \"goog.base\"));\n      n.removeChild(methodNameNode);\n      compiler.reportCodeChange();\n    }\n  }\n\n  /**\n   * Returns the qualified name node of the function whose scope we're in,\n   * or null if it cannot be found.\n   */\n  private Node getEnclosingDeclNameNode(NodeTraversal t) {\n    Node scopeRoot = t.getScopeRoot();\n    if (NodeUtil.isFunctionDeclaration(scopeRoot)) {\n      // function x() {...}\n      return scopeRoot.getFirstChild();\n    } else {\n      Node parent = scopeRoot.getParent();\n      if (parent != null) {\n        if (parent.isAssign() ||\n            parent.getLastChild() == scopeRoot &&\n            parent.getFirstChild().isQualifiedName()) {\n          // x.y.z = function() {...};\n          return parent.getFirstChild();\n        } else if (parent.isName()) {\n          // var x = function() {...};\n          return parent;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /** Reports an incorrect use of super-method calling. */\n  private void reportBadBaseClassUse(\n      NodeTraversal t, Node n, String extraMessage) {\n    compiler.report(t.makeError(n, BASE_CLASS_ERROR, extraMessage));\n  }\n\n  /**\n   * Processes the output of processed-provide from a previous pass.  This will\n   * update our data structures in the same manner as if the provide had been\n   * processed in this pass.\n   */\n  private void processProvideFromPreviousPass(\n      NodeTraversal t, String name, Node parent) {\n    if (!providedNames.containsKey(name)) {\n      // Record this provide created on a previous pass, and create a dummy\n      // EXPR node as a placeholder to simulate an explicit provide.\n      Node expr = new Node(Token.EXPR_RESULT);\n      expr.copyInformationFromForTree(parent);\n      parent.getParent().addChildBefore(expr, parent);\n      compiler.reportCodeChange();\n\n      JSModule module = t.getModule();\n      registerAnyProvidedPrefixes(name, expr, module);\n\n      ProvidedName provided = new ProvidedName(name, expr, module, true);\n      providedNames.put(name, provided);\n      provided.addDefinition(parent, module);\n    } else {\n      // Remove this provide if it came from a previous pass since we have an\n      // replacement already.\n      if (isNamespacePlaceholder(parent)) {\n        parent.getParent().removeChild(parent);\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  /**\n   * Processes a call to goog.setCssNameMapping(). Either the argument to\n   * goog.setCssNameMapping() is valid, in which case it will be used to create\n   * a CssRenamingMap for the compiler of this CompilerPass, or it is invalid\n   * and a JSCompiler error will be reported.\n   * @see #visit(NodeTraversal, Node, Node)\n   */\n  private void processSetCssNameMapping(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifySetCssNameMapping(t, left, arg)) {\n      // Translate OBJECTLIT into SubstitutionMap. All keys and\n      // values must be strings, or an error will be thrown.\n      final Map<String, String> cssNames = Maps.newHashMap();\n\n      for (Node key = arg.getFirstChild(); key != null;\n          key = key.getNext()) {\n        Node value = key.getFirstChild();\n        if (!key.isStringKey()\n            || value == null\n            || !value.isString()) {\n          compiler.report(\n              t.makeError(n,\n                  NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR));\n          return;\n        }\n        cssNames.put(key.getString(), value.getString());\n      }\n\n      String styleStr = \"BY_PART\";\n      if (arg.getNext() != null) {\n        styleStr = arg.getNext().getString();\n      }\n\n      final CssRenamingMap.Style style;\n      try {\n        style = CssRenamingMap.Style.valueOf(styleStr);\n      } catch (IllegalArgumentException e) {\n        compiler.report(\n            t.makeError(n, INVALID_STYLE_ERROR, styleStr));\n        return;\n      }\n\n      if (style == CssRenamingMap.Style.BY_PART) {\n        // Make sure that no keys contain -'s\n        List<String> errors = Lists.newArrayList();\n        for (String key : cssNames.keySet()) {\n          if (key.contains(\"-\")) {\n            errors.add(key);\n          }\n        }\n        if (errors.size() != 0) {\n          compiler.report(\n            t.makeError(n, INVALID_CSS_RENAMING_MAP, errors.toString()));\n        }\n      } else if (style == CssRenamingMap.Style.BY_WHOLE) {\n        // Verifying things is a lot trickier here. We just do a quick\n        // n^2 check over the map which makes sure that if \"a-b\" in\n        // the map, then map(a-b) = map(a)-map(b).\n        // To speed things up, only consider cases where len(b) <= 10\n        List<String> errors = Lists.newArrayList();\n        for (Map.Entry<String, String> b : cssNames.entrySet()) {\n          if (b.getKey().length() > 10) {\n            continue;\n          }\n          for (Map.Entry<String, String> a : cssNames.entrySet()) {\n            String combined = cssNames.get(a.getKey() + \"-\" + b.getKey());\n            if (combined != null &&\n                !combined.equals(a.getValue() + \"-\" + b.getValue())) {\n              errors.add(\"map(\" + a.getKey() + \"-\" + b.getKey() + \") != map(\" +\n                         a.getKey() + \")-map(\" + b.getKey() + \")\");\n            }\n          }\n        }\n        if (errors.size() != 0) {\n          compiler.report(\n            t.makeError(n, INVALID_CSS_RENAMING_MAP, errors.toString()));\n        }\n      }\n\n      CssRenamingMap cssRenamingMap = new CssRenamingMap() {\n        @Override\n        public String get(String value) {\n          if (cssNames.containsKey(value)) {\n            return cssNames.get(value);\n          } else {\n            return value;\n          }\n        }\n\n        @Override\n        public CssRenamingMap.Style getStyle() {\n          return style;\n        }\n      };\n      compiler.setCssRenamingMap(cssRenamingMap);\n      parent.getParent().removeChild(parent);\n      compiler.reportCodeChange();\n    }\n  }\n\n  /**\n   * Verifies that a provide method call has exactly one argument,\n   * and that it's a string literal and that the contents of the string are\n   * valid JS tokens. Reports a compile error if it doesn't.\n   *\n   * @return Whether the argument checked out okay\n   */\n  private boolean verifyProvide(NodeTraversal t, Node methodName, Node arg) {\n    if (!verifyLastArgumentIsString(t, methodName, arg)) {\n      return false;\n    }\n\n    for (String part : arg.getString().split(\"\\\\.\")) {\n      if (!NodeUtil.isValidPropertyName(part)) {\n        compiler.report(t.makeError(arg, INVALID_PROVIDE_ERROR, part));\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Verifies that a provide method call has exactly one argument,\n   * and that it's a string literal and that the contents of the string are\n   * valid JS tokens. Reports a compile error if it doesn't.\n   *\n   * @return Whether the argument checked out okay\n   */\n  private boolean verifyDefine(NodeTraversal t,\n      Node expr,\n      Node methodName, Node args) {\n\n    // Verify first arg\n    Node arg = args;\n    if (!verifyNotNull(t, methodName, arg) ||\n        !verifyOfType(t, methodName, arg, Token.STRING)) {\n      return false;\n    }\n\n    // Verify second arg\n    arg = arg.getNext();\n    if (!verifyNotNull(t, methodName, arg) ||\n        !verifyIsLast(t, methodName, arg)) {\n      return false;\n    }\n\n    String name = args.getString();\n    for (String part : name.split(\"\\\\.\")) {\n      if (!NodeUtil.isValidQualifiedName(part)) {\n        compiler.report(t.makeError(args, INVALID_DEFINE_NAME_ERROR, name));\n        return false;\n      }\n    }\n\n    JSDocInfo info = expr.getFirstChild().getJSDocInfo();\n    if (info == null || !info.isDefine()) {\n      compiler.report(t.makeError(expr, MISSING_DEFINE_ANNOTATION));\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Verifies that a method call has exactly one argument, and that it's a\n   * string literal. Reports a compile error if it doesn't.\n   *\n   * @return Whether the argument checked out okay\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node methodName, Node arg) {\n    return verifyNotNull(t, methodName, arg) &&\n        verifyOfType(t, methodName, arg, Token.STRING) &&\n        verifyIsLast(t, methodName, arg);\n  }\n\n  /**\n   * @return Whether the argument checked out okay\n   */\n  private boolean verifyNotNull(NodeTraversal t, Node methodName, Node arg) {\n    if (arg == null) {\n      compiler.report(\n          t.makeError(methodName,\n              NULL_ARGUMENT_ERROR, methodName.getQualifiedName()));\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * @return Whether the argument checked out okay\n   */\n  private boolean verifyOfType(NodeTraversal t, Node methodName,\n      Node arg, int desiredType) {\n    if (arg.getType() != desiredType) {\n      compiler.report(\n          t.makeError(methodName,\n              INVALID_ARGUMENT_ERROR, methodName.getQualifiedName()));\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * @return Whether the argument checked out okay\n   */\n  private boolean verifyIsLast(NodeTraversal t, Node methodName, Node arg) {\n    if (arg.getNext() != null) {\n      compiler.report(\n          t.makeError(methodName,\n              TOO_MANY_ARGUMENTS_ERROR, methodName.getQualifiedName()));\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Verifies that setCssNameMapping is called with the correct methods.\n   *\n   * @return Whether the arguments checked out okay\n   */\n  private boolean verifySetCssNameMapping(NodeTraversal t, Node methodName,\n      Node firstArg) {\n    DiagnosticType diagnostic = null;\n    if (firstArg == null) {\n      diagnostic = NULL_ARGUMENT_ERROR;\n    } else if (!firstArg.isObjectLit()) {\n      diagnostic = EXPECTED_OBJECTLIT_ERROR;\n    } else if (firstArg.getNext() != null) {\n      Node secondArg = firstArg.getNext();\n      if (!secondArg.isString()) {\n        diagnostic = EXPECTED_STRING_ERROR;\n      } else if (secondArg.getNext() != null) {\n        diagnostic = TOO_MANY_ARGUMENTS_ERROR;\n      }\n    }\n    if (diagnostic != null) {\n      compiler.report(\n          t.makeError(methodName,\n              diagnostic, methodName.getQualifiedName()));\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Registers ProvidedNames for prefix namespaces if they haven't\n   * already been defined. The prefix namespaces must be registered in\n   * order from shortest to longest.\n   *\n   * @param ns The namespace whose prefixes may need to be provided.\n   * @param node The EXPR of the provide call.\n   * @param module The current module.\n   */\n  private void registerAnyProvidedPrefixes(\n      String ns, Node node, JSModule module) {\n    int pos = ns.indexOf('.');\n    while (pos != -1) {\n      String prefixNs = ns.substring(0, pos);\n      pos = ns.indexOf('.', pos + 1);\n      if (providedNames.containsKey(prefixNs)) {\n        providedNames.get(prefixNs).addProvide(\n            node, module, false /* implicit */);\n      } else {\n        providedNames.put(\n            prefixNs,\n            new ProvidedName(prefixNs, node, module, false /* implicit */));\n      }\n    }\n  }\n\n  // -------------------------------------------------------------------------\n\n  /**\n   * Information required to replace a goog.provide call later in the traversal.\n   */\n  private class ProvidedName {\n    private final String namespace;\n\n    // The node and module where the call was explicitly or implicitly\n    // goog.provided.\n    private final Node firstNode;\n    private final JSModule firstModule;\n\n    // The node where the call was explicitly goog.provided. May be null\n    // if the namespace is always provided implicitly.\n    private Node explicitNode = null;\n    private JSModule explicitModule = null;\n\n    // The candidate definition.\n    private Node candidateDefinition = null;\n\n    // The minimum module where the provide must appear.\n    private JSModule minimumModule = null;\n\n    // The replacement declaration.\n    private Node replacementNode = null;\n\n    ProvidedName(String namespace, Node node, JSModule module,\n        boolean explicit) {\n      Preconditions.checkArgument(\n          node == null /* The base case */ ||\n          node.isExprResult());\n      this.namespace = namespace;\n      this.firstNode = node;\n      this.firstModule = module;\n\n      addProvide(node, module, explicit);\n    }\n\n    /**\n     * Add an implicit or explicit provide.\n     */\n    void addProvide(Node node, JSModule module, boolean explicit) {\n      if (explicit) {\n        Preconditions.checkState(explicitNode == null);\n        Preconditions.checkArgument(node.isExprResult());\n        explicitNode = node;\n        explicitModule = module;\n      }\n      updateMinimumModule(module);\n    }\n\n    boolean isExplicitlyProvided() {\n      return explicitNode != null;\n    }\n\n    /**\n     * Record function declaration, variable declaration or assignment that\n     * refers to the same name as the provide statement.  Give preference to\n     * declarations; if no declaration exists, record a reference to an\n     * assignment so it repurposed later.\n     */\n    void addDefinition(Node node, JSModule module) {\n      Preconditions.checkArgument(node.isExprResult() || // assign\n                                  node.isFunction() ||\n                                  node.isVar());\n      Preconditions.checkArgument(explicitNode != node);\n      if ((candidateDefinition == null) || !node.isExprResult()) {\n        candidateDefinition = node;\n        updateMinimumModule(module);\n      }\n    }\n\n    private void updateMinimumModule(JSModule newModule) {\n      if (minimumModule == null) {\n        minimumModule = newModule;\n      } else if (moduleGraph != null) {\n        minimumModule = moduleGraph.getDeepestCommonDependencyInclusive(\n            minimumModule, newModule);\n      } else {\n        // If there is no module graph, then there must be exactly one\n        // module in the program.\n        Preconditions.checkState(newModule == minimumModule,\n                                 \"Missing module graph\");\n      }\n    }\n\n    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (candidateDefinition.isExprResult() &&\n            !candidateDefinition.getFirstChild().isQualifiedName()) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.isName()) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = IR.var(nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.lastIndexOf('.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }\n\n    /**\n     * Create the declaration node for this name, without inserting it\n     * into the AST.\n     */\n    private Node createDeclarationNode() {\n      if (namespace.indexOf('.') == -1) {\n        return makeVarDeclNode();\n      } else {\n        return makeAssignmentExprNode();\n      }\n    }\n\n    /**\n     * Creates a simple namespace variable declaration\n     * (e.g. <code>var foo = {};</code>).\n     */\n    private Node makeVarDeclNode() {\n      Node name = IR.name(namespace);\n      name.addChildToFront(createNamespaceLiteral());\n\n      Node decl = IR.var(name);\n      decl.putBooleanProp(Node.IS_NAMESPACE, true);\n\n      // TODO(nicksantos): ew ew ew. Create a mutator package.\n      if (compiler.getCodingConvention().isConstant(namespace)) {\n        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n      }\n      if (candidateDefinition == null) {\n        name.setJSDocInfo(createConstantJsDoc());\n      }\n\n      Preconditions.checkState(isNamespacePlaceholder(decl));\n      setSourceInfo(decl);\n      return decl;\n    }\n\n    /**\n     * There are some special cases where clients of the compiler\n     * do not run TypedScopeCreator after running this pass.\n     * So always give the namespace literal a type.\n     */\n    private Node createNamespaceLiteral() {\n      Node objlit = IR.objectlit();\n      objlit.setJSType(\n          compiler.getTypeRegistry().createAnonymousObjectType(null));\n      return objlit;\n    }\n\n    /**\n     * Creates a dotted namespace assignment expression\n     * (e.g. <code>foo.bar = {};</code>).\n     */\n    private Node makeAssignmentExprNode() {\n      Node decl = IR.exprResult(\n          IR.assign(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), namespace,\n                  firstNode /* real source info will be filled in below */,\n                  namespace),\n              createNamespaceLiteral()));\n      decl.putBooleanProp(Node.IS_NAMESPACE, true);\n      if (candidateDefinition == null) {\n        decl.getFirstChild().setJSDocInfo(createConstantJsDoc());\n      }\n      Preconditions.checkState(isNamespacePlaceholder(decl));\n      setSourceInfo(decl);\n      return decl;\n    }\n\n    private JSDocInfo createConstantJsDoc() {\n      JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n      builder.recordConstancy();\n      return builder.build(null);\n    }\n\n    /**\n     * Copy source info to the new node.\n     */\n    private void setSourceInfo(Node newNode) {\n      Node provideStringNode = getProvideStringNode();\n      int offset = getSourceInfoOffset(provideStringNode);\n      Node sourceInfoNode = provideStringNode == null\n          ? firstNode : provideStringNode;\n      newNode.copyInformationFromForTree(sourceInfoNode);\n      if (offset != 0) {\n        newNode.setSourceEncodedPositionForTree(\n            sourceInfoNode.getSourcePosition() + offset);\n      }\n    }\n\n    /**\n     * Get the offset into the provide node where the symbol appears.\n     */\n    private int getSourceInfoOffset(Node provideStringNode) {\n      if (provideStringNode == null) {\n        return 0;\n      }\n\n      int indexOfLastDot = namespace.lastIndexOf('.');\n\n      // +1 for the opening quote\n      // +1 for the dot\n      // if there's no dot, then the -1 index cancels it out\n      // so elegant!\n      return 2 + indexOfLastDot;\n    }\n\n    private Node getProvideStringNode() {\n      return (firstNode.getFirstChild() != null &&\n              NodeUtil.isExprCall(firstNode)) ?\n          firstNode.getFirstChild().getLastChild() :\n          null;\n    }\n  }\n\n  /**\n   * @return Whether the node is namespace placeholder.\n   */\n  private static boolean isNamespacePlaceholder(Node n) {\n    if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n      return false;\n    }\n\n    Node value = null;\n    if (n.isExprResult()) {\n      Node assign = n.getFirstChild();\n      value = assign.getLastChild();\n    } else if (n.isVar()) {\n      Node name = n.getFirstChild();\n      value = name.getFirstChild();\n    }\n\n    return value != null\n      && value.isObjectLit()\n      && !value.hasChildren();\n  }\n\n  /**\n   * The string in {@code n} is a reference name. Create a synthetic\n   * node for it with all the proper source info, and add it to the symbol\n   * table.\n   */\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (preprocessorSymbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    Node syntheticRef = NodeUtil.newQualifiedNameNode(\n        compiler.getCodingConvention(), name,\n        n /* real source offsets will be filled in below */,\n        name);\n\n    // Offsets to add to source. Named for documentation purposes.\n    final int forQuote = 1;\n    final int forDot = 1;\n\n    Node current = null;\n    for (current = syntheticRef;\n         current.isGetProp();\n         current = current.getFirstChild()) {\n      int fullLen = current.getQualifiedName().length();\n      int namespaceLen = current.getFirstChild().getQualifiedName().length();\n\n      current.setSourceEncodedPosition(n.getSourcePosition() + forQuote);\n      current.setLength(fullLen);\n\n      current.getLastChild().setSourceEncodedPosition(\n          n.getSourcePosition() + namespaceLen + forQuote + forDot);\n      current.getLastChild().setLength(\n          current.getLastChild().getString().length());\n    }\n\n    current.setSourceEncodedPosition(n.getSourcePosition() + forQuote);\n    current.setLength(current.getString().length());\n\n    maybeAddToSymbolTable(syntheticRef);\n  }\n\n  /**\n   * Add the given qualified name node to the symbol table.\n   */\n  private void maybeAddToSymbolTable(Node n) {\n    if (preprocessorSymbolTable != null) {\n      preprocessorSymbolTable.addReference(n);\n    }\n  }\n\n  // -------------------------------------------------------------------------\n\n  /**\n   * Information required to create a {@code MISSING_PROVIDE_ERROR} warning.\n   */\n  private class UnrecognizedRequire {\n    final Node requireNode;\n    final String namespace;\n    final String inputName;\n\n    UnrecognizedRequire(Node requireNode, String namespace, String inputName) {\n      this.requireNode = requireNode;\n      this.namespace = namespace;\n      this.inputName = inputName;\n    }\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"location\": \"ProcessClosurePrimitives.java:123\",\n         \"message\": \"The compiler object may be null when calling getModuleGraph()\"\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"location\": \"ProcessClosurePrimitives.java:125\",\n         \"message\": \"The preprocessorSymbolTable object may be null when calling getModuleGraph()\"\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"location\": \"ProcessClosurePrimitives.java:127\",\n         \"message\": \"The requiresLevel object may be null when calling getModuleGraph()\"\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"location\": \"ProcessClosurePrimitives.java:129\",\n         \"message\": \"The moduleGraph object may be null when calling getExportedVariableNames()\"\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"location\": \"ProcessClosurePrimitives.java:131\",\n         \"message\": \"The exportedVariables object may be null when calling getExportedVariableNames()\"\n      },\n      {\n         \"type\": \"Potential IndexOutOfBoundsException\",\n         \"location\": \"ProcessClosurePrimitives.java:133\",\n         \"message\": \"The defineCalls list may be empty when calling process()\"\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"location\": \"ProcessClosurePrimitives.java:135\",\n         \"message\": \"The providedNames object may be null when calling process()\"\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"location\": \"ProcessClosurePrimitives.java:137\",\n         \"message\": \"The pn object may be null when calling process()\"\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"location\": \"ProcessClosurePrimitives.java:139\",\n         \"message\": \"The compiler object may be null when calling process()\"\n      }\n   ]\n}"}}