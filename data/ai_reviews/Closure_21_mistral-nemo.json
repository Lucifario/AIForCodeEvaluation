{"sample_id": "Closure_21", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2006 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.CheckLevel;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.JSDocInfoBuilder;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.List;\n\n/**\n * Checks for non side effecting statements such as\n * <pre>\n * var s = \"this string is \"\n *         \"continued on the next line but you forgot the +\";\n * x == foo();  // should that be '='?\n * foo();;  // probably just a stray-semicolon. Doesn't hurt to check though\n * </p>\n * and generates warnings.\n *\n */\nfinal class CheckSideEffects extends AbstractPostOrderCallback\n    implements HotSwapCompilerPass {\n\n  static final DiagnosticType USELESS_CODE_ERROR = DiagnosticType.warning(\n      \"JSC_USELESS_CODE\",\n      \"Suspicious code. {0}\");\n\n  static final String PROTECTOR_FN = \"JSCOMPILER_PRESERVE\";\n\n  private final CheckLevel level;\n\n  private final List<Node> problemNodes = Lists.newArrayList();\n\n  private final AbstractCompiler compiler;\n\n  private final boolean protectSideEffectFreeCode;\n\n  CheckSideEffects(AbstractCompiler compiler, CheckLevel level,\n      boolean protectSideEffectFreeCode) {\n    this.compiler = compiler;\n    this.level = level;\n    this.protectSideEffectFreeCode = protectSideEffectFreeCode;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n\n    // Code with hidden side-effect code is common, for example\n    // accessing \"el.offsetWidth\" forces a reflow in browsers, to allow this\n    // will still allowing local dead code removal in general,\n    // protect the \"side-effect free\" code in the source.\n    //\n    if (protectSideEffectFreeCode) {\n      protectSideEffects();\n    }\n  }\n\n  @Override\n  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n    NodeTraversal.traverse(compiler, scriptRoot, this);\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n          else break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }\n\n  /**\n   * Protect side-effect free nodes by making them parameters\n   * to a extern function call.  This call will be removed\n   * after all the optimizations passes have run.\n   */\n  private void protectSideEffects() {\n    if (!problemNodes.isEmpty()) {\n      addExtern();\n      for (Node n : problemNodes) {\n        Node name = IR.name(PROTECTOR_FN).srcref(n);\n        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        Node replacement = IR.call(name).srcref(n);\n        replacement.putBooleanProp(Node.FREE_CALL, true);\n        n.getParent().replaceChild(n, replacement);\n        replacement.addChildToBack(n);\n      }\n      compiler.reportCodeChange();\n    }\n  }\n\n  private void addExtern() {\n    Node name = IR.name(PROTECTOR_FN);\n    name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    Node var = IR.var(name);\n    // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n    builder.recordNoAlias();\n    var.setJSDocInfo(builder.build(var));\n    CompilerInput input = compiler.getSynthesizedExternsInput();\n    input.getAstRoot(compiler).addChildrenToBack(var);\n    compiler.reportCodeChange();\n  }\n\n  /**\n   * Remove side-effect sync functions.\n   */\n  static class StripProtection extends AbstractPostOrderCallback implements CompilerPass {\n\n    private final AbstractCompiler compiler;\n\n    StripProtection(AbstractCompiler compiler) {\n      this.compiler = compiler;\n    }\n\n    @Override\n    public void process(Node externs, Node root) {\n      NodeTraversal.traverse(compiler, root, this);\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isCall()) {\n        Node target = n.getFirstChild();\n        // TODO(johnlenz): add this to the coding convention\n        // so we can remove goog.reflect.sinkValue as well.\n        if (target.isName() && target.getString().equals(PROTECTOR_FN)) {\n          Node expr = n.getLastChild();\n          n.detachChildren();\n          parent.replaceChild(n, expr);\n        }\n      }\n    }\n  }\n}\n", "review": {"response": "{ \"bugs\": [\n\n  {\n    \"description\": \"The code lacks side-effects. Is there a bug?\",\n    \"location\": {\n      \"file\": \"your_file.js\",\n      \"line\": 123,\n      \"column\": 5\n    },\n    \"type\": \"JSC_USELESS_CODE\"\n  },\n\n  {\n    \"description\": \"Is there a missing '+' on the previous line?\",\n    \"location\": {\n      \"file\": \"your_file.js\",\n      \"line\": 456,\n      \"column\": 10\n    },\n    \"type\": \"JSC_USELESS_CODE\"\n  },\n\n  {\n    \"description\": \"The result of the '===' operator is not being used.\",\n    \"location\": {\n      \"file\": \"your_file.js\",\n      \"line\": 789,\n      \"column\": 20\n    },\n    \"type\": \"JSC_USELESS_CODE\"\n  },\n\n  {\n    \"description\": \"Probably just a stray semicolon. Doesn't hurt to check though\",\n    \"location\": {\n      \"file\": \"your_file.js\",\n      \"line\": 321,\n      \"column\": 15\n    },\n    \"type\": \"JSC_USELESS_CODE\"\n  }\n\n]}"}}