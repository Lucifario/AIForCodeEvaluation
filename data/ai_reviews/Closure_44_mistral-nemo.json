{"sample_id": "Closure_44", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.javascript.rhino.Node;\n\n\n/**\n * Abstracted consumer of the CodeGenerator output.\n *\n * @see CodeGenerator\n * @see CodePrinter\n * @see InlineCostEstimator\n */\nabstract class CodeConsumer {\n  boolean statementNeedsEnded = false;\n  boolean statementStarted = false;\n  boolean sawFunction = false;\n\n  /**\n   * Starts the source mapping for the given\n   * node at the current position.\n   */\n  void startSourceMapping(Node node) {\n  }\n\n  /**\n   * Finishes the source mapping for the given\n   * node at the current position.\n   */\n  void endSourceMapping(Node node) {\n  }\n\n  /**\n   * Provides a means of interrupting the CodeGenerator. Derived classes should\n   * return false to stop further processing.\n   */\n  boolean continueProcessing() {\n    return true;\n  }\n\n  /**\n   * Retrieve the last character of the last string sent to append.\n   */\n  abstract char getLastChar();\n\n  void addIdentifier(String identifier) {\n    add(identifier);\n  }\n\n  /**\n   * Appends a string to the code, keeping track of the current line length.\n   *\n   * NOTE: the string must be a complete token--partial strings or\n   * partial regexes will run the risk of being split across lines.\n   *\n   * Do not directly append newlines with this method. Instead use\n   * {@link #startNewLine}.\n   */\n  abstract void append(String str);\n\n  void appendBlockStart() {\n    append(\"{\");\n  }\n\n  void appendBlockEnd() {\n    append(\"}\");\n  }\n\n  void startNewLine() {\n  }\n\n  void maybeLineBreak() {\n    maybeCutLine();\n  }\n\n  void maybeCutLine() {\n  }\n\n  void endLine() {\n  }\n\n  void notePreferredLineBreak() {\n  }\n\n  void beginBlock() {\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n    }\n    appendBlockStart();\n\n    endLine();\n    statementNeedsEnded = false;\n  }\n\n  void endBlock() {\n    endBlock(false);\n  }\n\n  void endBlock(boolean shouldEndLine) {\n    appendBlockEnd();\n    if (shouldEndLine) {\n      endLine();\n    }\n    statementNeedsEnded = false;\n  }\n\n  void listSeparator() {\n    add(\",\");\n    maybeLineBreak();\n  }\n\n  /**\n   * Indicates the end of a statement and a ';' may need to be added.\n   * But we don't add it now, in case we're at the end of a block (in which\n   * case we don't have to add the ';').\n   * See maybeEndStatement()\n   */\n  void endStatement() {\n    endStatement(false);\n  }\n\n  void endStatement(boolean needSemiColon) {\n    if (needSemiColon) {\n      append(\";\");\n      maybeLineBreak();\n      statementNeedsEnded = false;\n    } else if (statementStarted) {\n      statementNeedsEnded = true;\n    }\n  }\n\n  /**\n   * This is to be called when we're in a statement. If the prev statement\n   * needs to be ended, add a ';'.\n   */\n  void maybeEndStatement() {\n    // Add a ';' if we need to.\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n      endLine();\n      statementNeedsEnded = false;\n    }\n    statementStarted = true;\n  }\n\n  void endFunction() {\n    endFunction(false);\n  }\n\n  void endFunction(boolean statementContext) {\n    sawFunction = true;\n    if (statementContext) {\n      endLine();\n    }\n  }\n\n  void beginCaseBody() {\n    append(\":\");\n  }\n\n  void endCaseBody() {\n  }\n\n  void add(String newcode) {\n    maybeEndStatement();\n\n    if (newcode.length() == 0) {\n      return;\n    }\n\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') &&\n        isWordChar(getLastChar())) {\n      // need space to separate. This is not pretty printing.\n      // For example: \"return foo;\"\n      append(\" \");\n      // Do not allow a forward slash to appear after a DIV.\n      // For example,\n      // REGEXP DIV REGEXP\n      // is valid and should print like\n      // / // / /\n    }\n\n    append(newcode);\n  }\n\n  void appendOp(String op, boolean binOp) {\n    append(op);\n  }\n\n  void addOp(String op, boolean binOp) {\n    maybeEndStatement();\n\n    char first = op.charAt(0);\n    char prev = getLastChar();\n\n    if ((first == '+' || first == '-') && prev == first) {\n      // This is not pretty printing. This is to prevent misparsing of\n      // things like \"x + ++y\" or \"x++ + ++y\"\n      append(\" \");\n    } else if (Character.isLetter(first) &&\n               isWordChar(prev)) {\n      // Make sure there is a space after e.g. instanceof , typeof\n      append(\" \");\n    } else if (prev == '-' && first == '>') {\n      // Make sure that we don't emit -->\n      append(\" \");\n    }\n\n    // Allow formating around the operator.\n    appendOp(op, binOp);\n\n    // Line breaking after an operator is always safe. Line breaking before an\n    // operator on the other hand is not. We only line break after a bin op\n    // because it looks strange.\n    if (binOp) {\n      maybeCutLine();\n    }\n  }\n\n  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    if (x < 0 && prev == '-') {\n      add(\" \");\n    }\n\n    if ((long) x == x && !isNegativeZero(x)) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }\n\n  static boolean isNegativeZero(double x) {\n    return x == 0.0 && Math.copySign(1, x) == -1.0;\n  }\n\n  static boolean isWordChar(char ch) {\n    return (ch == '_' ||\n            ch == '$' ||\n            Character.isLetterOrDigit(ch));\n  }\n\n  /**\n   * If the body of a for loop or the then clause of an if statement has\n   * a single statement, should it be wrapped in a block?  Doing so can\n   * help when pretty-printing the code, and permits putting a debugging\n   * breakpoint on the statement inside the condition.\n   *\n   * @return {@boolean true} if such expressions should be wrapped\n   */\n  boolean shouldPreserveExtraBlocks() {\n    return false;\n  }\n\n  /**\n   * @return Whether the a line break can be added after the specified BLOCK.\n   */\n  boolean breakAfterBlockFor(Node n, boolean statementContext) {\n    return statementContext;\n  }\n\n  /** Called when we're at the end of a file. */\n  void endFile() {}\n}\n", "review": {"response": "[{\"code\": \"```java\\nvoid startSourceMapping(Node node) {\\n    // TODO: Implement source mapping for the given node\\n}\\n\\nvoid endSourceMapping(Node node) {\\n    // TODO: Implement source mapping for the given node\\n}\\n\\nboolean continueProcessing() {\\n    // TODO: Implement interruption for the CodeGenerator\\n    return true;\\n}\\n\\nabstract char getLastChar();\\n\\nvoid addIdentifier(String identifier) {\\n    add(identifier);\\n}\\n\\nvoid append(String str) {\\n    // TODO: Implement appending a string to the code\\n}\\n\\nvoid appendBlockStart() {\\n    append(\\\"{{\\\");\\n}\\n\\nvoid appendBlockEnd() {\\n    append(\\\"}}\\\");\\n}\\n\\nvoid startNewLine() {\\n    // TODO: Implement starting a new line\\n}\\n\\nvoid maybeLineBreak() {\\n    maybeCutLine();\\n}\\n\\nvoid maybeCutLine() {\\n    // TODO: Implement cutting a line\\n}\\n\\nvoid endLine() {\\n    // TODO: Implement ending a line\\n}\\n\\nvoid notePreferredLineBreak() {\\n    // TODO: Implement noting a preferred line break\\n}\\n\\nvoid beginBlock() {\\n    if (statementNeedsEnded) {\\n        append(\\\";\\\");\\n        maybeLineBreak();\\n    }\\n    appendBlockStart();\\n\\n    endLine();\\n    statementNeedsEnded = false;\\n}\\n\\nvoid endBlock() {\\n    endBlock(false);\\n}\\n\\nvoid endBlock(boolean shouldEndLine) {\\n    appendBlockEnd();\\n    if (shouldEndLine) {\\n        endLine();\\n    }\\n    statementNeedsEnded = false;\\n}\\n\\nvoid listSeparator() {\\n    add(\\\",\\\");\\n    maybeLineBreak();\\n}\\n\\nvoid endStatement() {\\n    endStatement(false);\\n}\\n\\nvoid endStatement(boolean needSemiColon) {\\n    if (needSemiColon) {\\n        append(\\\";\\\");\\n        maybeLineBreak();\\n        statementNeedsEnded = false;\\n    } else if (statementStarted) {\\n        statementNeedsEnded = true;\\n    }\\n}\\n\\nvoid maybeEndStatement() {\\n    // Add a ';' if we need to.\\n    if (statementNeedsEnded) {\\n        append(\\\";\\\");\\n        maybeLineBreak();\\n        endLine();\\n        statementNeedsEnded = false;\\n    }\\n    statementStarted = true;\\n}\\n\\nvoid endFunction() {\\n    endFunction(false);\\n}\\n\\nvoid endFunction(boolean statementContext) {\\n    sawFunction = true;\\n    if (statementContext) {\\n        endLine();\\n    }\\n}\\n\\nvoid beginCaseBody() {\\n    append(\\\":\\\");\\n}\\n\\nvoid endCaseBody() {\\n    // TODO: Implement ending a case body\\n}\\n\\nvoid add(String newcode) {\\n    maybeEndStatement();\\n\\n    if (newcode.length() == 0) {\\n        return;\\n    }\\n\\n    char c = newcode.charAt(0);\\n    if ((isWordChar(c) || c == '\\\\') && isWordChar(getLastChar())) {\\n        // need space to separate. This is not pretty printing.\\n        // For example: \\\"return foo;\\\"\\n        append(\\\" \\\");\\n        // Do not allow a forward slash to appear after a DIV.\\n        // For example,\\n        // REGEXP DIV REGEXP\\n        // is valid and should print like\\n        // / // / /\\n    }\\n\\n    append(newcode);\\n}\\n\\nvoid appendOp(String op, boolean binOp) {\\n    append(op);\\n}\\n\\nvoid addOp(String op, boolean binOp) {\\n    maybeEndStatement();\\n\\n    char first = op.charAt(0);\\n    char prev = getLastChar();\\n\\n    if ((first == '+' || first == '-') && prev == first) {\\n        // This is not pretty printing. This is to prevent misparsing of\\n        // things like \\\"x + ++y\\\" or \\\"x++ + ++y\\\"\\n        append(\\\" \\\");\\n    } else if (Character.isLetter(first) && isWordChar(prev)) {\\n        // Make sure there is a space after e.g. instanceof , typeof\\n        append(\\\" \\\");\\n    } else if (prev == '-' && first == '>') {\\n        // Make sure that we don't emit -->\\n        append(\\\" \\\");\\n    }\\n\\n    // Allow formating around the operator.\\n    appendOp(op, binOp);\\n\\n    // Line breaking after an operator is always safe. Line breaking before an\\n    // operator on the other hand is not. We only line break after a bin op\\n    // because it looks strange.\\n    if (binOp) {\\n        maybeCutLine();\\n    }\\n}\\n\\nvoid addNumber(double x) {\\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\\n    // x--4 (which is a syntax error).\\n    char prev = getLastChar();\\n    if (x < 0 && prev == '-') {\\n        add(\\\" \\\");\\n    }\\n\\n    if ((long) x == x && !isNegativeZero(x)) {\\n        long value = (long) x;\\n        long mantissa = value;\\n        int exp = 0;\\n        if (Math.abs(x) >= 100) {\\n            while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\\n                mantissa /= 10;\\n                exp++;\\n            }\\n        }\\n        if (exp > 2) {\\n            add(Long.toString(mantissa) + \\\"E\\\" + Integer.toString(exp));\\n        } else {\\n            add(Long.toString(value));\\n        }\\n    } else {\\n        add(Double.toString(x));\\n    }\\n}\\n```\"}\n\n, \"bugs\" ]"}}