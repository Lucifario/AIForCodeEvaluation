{"sample_id": "Closure_24", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2010 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.javascript.jscomp.CompilerOptions.AliasTransformation;\nimport com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.SourcePosition;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.annotation.Nullable;\n\n/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  /** Name used to denote an scoped function block used for aliasing. */\n  static final String SCOPING_METHOD_NAME = \"goog.scope\";\n\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n\n  // Errors\n  static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USED_IMPROPERLY\",\n      \"The call to goog.scope must be alone in a single statement.\");\n\n  static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS =\n      DiagnosticType.error(\n          \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\",\n          \"The call to goog.scope must take only a single parameter.  It must\" +\n              \" be an anonymous function that itself takes no parameters.\");\n\n  static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_REFERENCES_THIS\",\n      \"The body of a goog.scope function cannot reference 'this'.\");\n\n  static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_RETURN\",\n      \"The body of a goog.scope function cannot use 'return'.\");\n\n  static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_THROW\",\n      \"The body of a goog.scope function cannot use 'throw'.\");\n\n  static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\",\n      \"The alias {0} is assigned a value more than once.\");\n\n  static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\",\n      \"The local variable {0} is in a goog.scope and is not an alias.\");\n\n  ScopedAliases(AbstractCompiler compiler,\n      @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n      AliasTransformationHandler transformationHandler) {\n    this.compiler = compiler;\n    this.preprocessorSymbolTable = preprocessorSymbolTable;\n    this.transformationHandler = transformationHandler;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    hotSwapScript(root, null);\n  }\n\n  @Override\n  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      for (AliasUsage aliasUsage : traversal.getAliasUsages()) {\n        aliasUsage.applyAlias();\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  private interface AliasUsage {\n    public void applyAlias();\n  }\n\n  private class AliasedNode implements AliasUsage {\n    private final Node aliasReference;\n\n    private final Node aliasDefinition;\n\n    AliasedNode(Node aliasReference, Node aliasDefinition) {\n      this.aliasReference = aliasReference;\n      this.aliasDefinition = aliasDefinition;\n    }\n\n    @Override\n    public void applyAlias() {\n      aliasReference.getParent().replaceChild(\n          aliasReference, aliasDefinition.cloneTree());\n    }\n  }\n\n  private class AliasedTypeNode implements AliasUsage {\n    private final Node aliasReference;\n\n    private final String correctedType;\n\n    AliasedTypeNode(Node aliasReference, String correctedType) {\n      this.aliasReference = aliasReference;\n      this.correctedType = correctedType;\n    }\n\n    @Override\n    public void applyAlias() {\n      aliasReference.setString(correctedType);\n    }\n  }\n\n\n  private class Traversal implements NodeTraversal.ScopedCallback {\n    // The job of this class is to collect these three data sets.\n\n    // The order of this list determines the order that aliases are applied.\n    private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList();\n\n    private final List<Node> scopeCalls = Lists.newArrayList();\n\n    private final List<AliasUsage> aliasUsages = Lists.newArrayList();\n\n    // This map is temporary and cleared for each scope.\n    private final Map<String, Var> aliases = Maps.newHashMap();\n\n    private boolean hasErrors = false;\n\n    private AliasTransformation transformation = null;\n\n    Collection<Node> getAliasDefinitionsInOrder() {\n      return aliasDefinitionsInOrder;\n    }\n\n    private List<AliasUsage> getAliasUsages() {\n      return aliasUsages;\n    }\n\n    List<Node> getScopeCalls() {\n      return scopeCalls;\n    }\n\n    boolean hasErrors() {\n      return hasErrors;\n    }\n\n    private boolean isCallToScopeMethod(Node n) {\n      return n.isCall() &&\n          SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName());\n    }\n\n    @Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode().getParent();\n      if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(\n            n.getSourceFileName(), getSourceRegion(n));\n        findAliases(t);\n      }\n    }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n      if (t.getScopeDepth() == 2) {\n        aliases.clear();\n        transformation = null;\n      }\n    }\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.isFunction() && t.inGlobalScope()) {\n        // Do not traverse in to functions except for goog.scope functions.\n        if (parent == null || !isCallToScopeMethod(parent)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private SourcePosition<AliasTransformation> getSourceRegion(Node n) {\n      Node testNode = n;\n      Node next = null;\n      for (; next != null || testNode.isScript();) {\n        next = testNode.getNext();\n        testNode = testNode.getParent();\n      }\n\n      int endLine = next == null ? Integer.MAX_VALUE : next.getLineno();\n      int endChar = next == null ? Integer.MAX_VALUE : next.getCharno();\n      SourcePosition<AliasTransformation> pos =\n          new SourcePosition<AliasTransformation>() {};\n      pos.setPositionInformation(\n          n.getLineno(), n.getCharno(), endLine, endChar);\n      return pos;\n    }\n\n    private void report(NodeTraversal t, Node n, DiagnosticType error,\n        String... arguments) {\n      compiler.report(t.makeError(n, error, arguments));\n      hasErrors = true;\n    }\n\n    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n        if (parent.isVar()) {\n          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n          String name = n.getString();\n          Var aliasVar = scope.getVar(name);\n          aliases.put(name, aliasVar);\n\n          String qualifiedName =\n              aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else {\n          // TODO(robbyw): Support using locals for private variables.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n        }\n      }\n    }\n\n    private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n      if (preprocessorSymbolTable != null) {\n        preprocessorSymbolTable.addReference(n.getFirstChild());\n      }\n      if (!parent.isExprResult()) {\n        report(t, n, GOOG_SCOPE_USED_IMPROPERLY);\n      }\n      if (n.getChildCount() != 2) {\n        // The goog.scope call should have exactly 1 parameter.  The first\n        // child is the \"goog.scope\" and the second should be the parameter.\n        report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n      } else {\n        Node anonymousFnNode = n.getChildAtIndex(1);\n        if (!anonymousFnNode.isFunction() ||\n            NodeUtil.getFunctionName(anonymousFnNode) != null ||\n            NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {\n          report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n        } else {\n          scopeCalls.add(n);\n        }\n      }\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n      if (t.getScopeDepth() < 2) {\n        return;\n      }\n\n      int type = n.getType();\n      Var aliasVar = null;\n      if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n          aliasVar = lexicalVar;\n        }\n      }\n\n      // Validate the top-level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n          if (aliasVar.getNode() == n) {\n            aliasDefinitionsInOrder.add(n);\n\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n          }\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedNode(n, aliasedNode));\n        }\n\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }\n\n    private void fixTypeNode(Node typeNode) {\n      if (typeNode.isString()) {\n        String name = typeNode.getString();\n        int endIndex = name.indexOf('.');\n        if (endIndex == -1) {\n          endIndex = name.length();\n        }\n        String baseName = name.substring(0, endIndex);\n        Var aliasVar = aliases.get(baseName);\n        if (aliasVar != null) {\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedTypeNode(typeNode,\n              aliasedNode.getQualifiedName() + name.substring(endIndex)));\n        }\n      }\n\n      for (Node child = typeNode.getFirstChild(); child != null;\n           child = child.getNext()) {\n        fixTypeNode(child);\n      }\n    }\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"description\": \"The `GOOG_SCOPE_USED_IMPROPERLY` error is not checked or handled in the `process` method. It should be reported if the call to `goog.scope` is not alone in a single statement.\",\n      \"location\": \"process method\"\n    },\n    {\n      \"description\": \"The `GOOG_SCOPE_HAS_BAD_PARAMETERS` error is not checked or handled in the `process` method. It should be reported if the call to `goog.scope` does not take a single anonymous function parameter.\",\n      \"location\": \"process method\"\n    },\n    {\n      \"description\": \"The `GOOG_SCOPE_REFERENCES_THIS` error is not checked or handled in the `process` method. It should be reported if the body of a `goog.scope` function references 'this'.\",\n      \"location\": \"process method\"\n    },\n    {\n      \"description\": \"The `GOOG_SCOPE_USES_RETURN` error is not checked or handled in the `process` method. It should be reported if the body of a `goog.scope` function uses 'return'.\",\n      \"location\": \"process method\"\n    },\n    {\n      \"description\": \"The `GOOG_SCOPE_USES_THROW` error is not checked or handled in the `process` method. It should be reported if the body of a `goog.scope` function uses 'throw'.\",\n      \"location\": \"process method\"\n    },\n    {\n      \"description\": \"The `GOOG_SCOPE_ALIAS_REDEFINED` error is not checked or handled in the `process` method. It should be reported if an alias is assigned a value more than once.\",\n      \"location\": \"process method\"\n    },\n    {\n      \"description\": \"The `GOOG_SCOPE_NON_ALIAS_LOCAL` error is not checked or handled in the `process` method. It should be reported if a local variable in a `goog.scope` is not an alias.\",\n      \"location\": \"process method\"\n    }\n  ]\n}"}}