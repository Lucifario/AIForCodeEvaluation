{"sample_id": "Closure_40", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2006 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\nimport com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.CopySideEffectSubexpressions;\nimport com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.SideEffectAccumulator;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.graph.DiGraph;\nimport com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\nimport com.google.javascript.jscomp.graph.LinkedDirectedGraph;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\nimport com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * This pass identifies all global names, simple (e.g. <code>a</code>) or\n * qualified (e.g. <code>a.b.c</code>), and the dependencies between them, then\n * removes code associated with unreferenced names. It starts by assuming that\n * only externally accessible names (e.g. <code>window</code>) are referenced,\n * then iteratively marks additional names as referenced (e.g. <code>Foo</code>\n * in <code>window['foo'] = new Foo();</code>). This makes it possible to\n * eliminate code containing circular references.\n *\n * <p>Qualified names can be defined using dotted or object literal syntax\n * (<code>a.b.c = x;</code> or <code>a.b = {c: x};</code>, respectively).\n *\n * <p>Removal of prototype classes is currently all or nothing. In other words,\n * prototype properties and methods are never individually removed.\n *\n * <p>Optionally generates pretty HTML output of data so that it is easy to\n * analyze dependencies.\n *\n * <p>Only operates on names defined in the global scope, but it would be easy\n * to extend the pass to names defined in local scopes.\n *\n * TODO(nicksantos): In the initial implementation of this pass, it was\n * important to understand namespaced names (e.g., that a.b is distinct from\n * a.b.c). Now that this pass comes after CollapseProperties, this is no longer\n * necessary. For now, I've changed so that {@code refernceParentNames}\n * creates a two-way reference between a.b and a.b.c, so that they're\n * effectively the same name. When someone has the time, we should completely\n * rip out all the logic that understands namespaces.\n *\n */\nfinal class NameAnalyzer implements CompilerPass {\n\n  /** Reference to the JS compiler */\n  private final AbstractCompiler compiler;\n\n  /** Map of all JS names found */\n  private final Map<String, JsName> allNames = Maps.newTreeMap();\n\n  /** Reference dependency graph */\n  private DiGraph<JsName, RefType> referenceGraph =\n      LinkedDirectedGraph.createWithoutAnnotations();\n\n  /**\n   * Map of name scopes - all children of the Node key have a dependency on the\n   * name value.\n   *\n   * If scopes.get(node).equals(name) && node2 is a child of node, then node2\n   * will not get executed unless name is referenced via a get operation\n   */\n  private final Map<Node, NameInformation> scopes = Maps.newHashMap();\n\n  /** Used to parse prototype names */\n  private static final String PROTOTYPE_SUBSTRING = \".prototype.\";\n\n  private static final int PROTOTYPE_SUBSTRING_LEN =\n      PROTOTYPE_SUBSTRING.length();\n\n  private static final int PROTOTYPE_SUFFIX_LEN = \".prototype\".length();\n\n  /** Window root */\n  private static final String WINDOW = \"window\";\n\n  /** Function class name */\n  private static final String FUNCTION = \"Function\";\n\n  /** All of these refer to global scope. These can be moved to config */\n  static final Set<String> DEFAULT_GLOBAL_NAMES = ImmutableSet.of(\n      \"window\", \"goog.global\");\n\n  /** Whether to remove unreferenced variables in main pass */\n  private final boolean removeUnreferenced;\n\n  /** Names that refer to the global scope */\n  private final Set<String> globalNames;\n\n  /** Ast change helper */\n  private final AstChangeProxy changeProxy;\n\n  /** Names that are externally defined */\n  private final Set<String> externalNames = Sets.newHashSet();\n\n  /** Name declarations or assignments, in post-order traversal order */\n  private final List<RefNode> refNodes = Lists.newArrayList();\n\n  /**\n   * When multiple names in the global scope point to the same object, we\n   * call them aliases. Store a map from each alias name to the alias set.\n   */\n  private final Map<String, AliasSet> aliases = Maps.newHashMap();\n\n  /**\n   * All the aliases in a program form a graph, where each global name is\n   * a node in the graph, and two names are connected if one directly aliases\n   * the other.\n   *\n   * An {@code AliasSet} represents a connected component in that graph. We do\n   * not explicitly track the graph--we just track the connected components.\n   */\n  private static class AliasSet {\n    Set<String> names = Sets.newHashSet();\n\n    // Every alias set starts with exactly 2 names.\n    AliasSet(String name1, String name2) {\n      names.add(name1);\n      names.add(name2);\n    }\n  }\n\n  /**\n   * Relationship between the two names.\n   * Currently only two different reference types exists:\n   * goog.inherits class relations and all other references.\n   */\n  private static enum RefType {\n    REGULAR,\n    INHERITANCE,\n  }\n\n  /**\n   * Callback that propagates reference information.\n   */\n  private static class ReferencePropagationCallback\n      implements EdgeCallback<JsName, RefType> {\n    @Override\n    public boolean traverseEdge(JsName from,\n                                RefType callSite,\n                                JsName to) {\n      if (from.referenced && !to.referenced) {\n        to.referenced = true;\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Class to hold information that can be determined from a node tree about a\n   * given name\n   */\n  private static class NameInformation {\n    /** Fully qualified name */\n    String name;\n\n    /** Whether the name is guaranteed to be externally referenceable */\n    boolean isExternallyReferenceable = false;\n\n    /** Whether this name is a prototype function */\n    boolean isPrototype = false;\n\n    /** Name of the prototype class, i.e. \"a\" if name is \"a.prototype.b\" */\n    String prototypeClass = null;\n\n    /** Local name of prototype property i.e. \"b\" if name is \"a.prototype.b\" */\n    String prototypeProperty = null;\n\n    /** Name of the super class of name */\n    String superclass = null;\n\n    /** Whether this is a call that only affects the class definition */\n    boolean onlyAffectsClassDef = false;\n  }\n\n  /**\n   * Struct to hold information about a fully qualified JS name\n   */\n  private static class JsName implements Comparable<JsName> {\n    /** Fully qualified name */\n    String name;\n\n    /** Name of prototype functions attached to this name */\n    List<String> prototypeNames = Lists.newArrayList();\n\n    /** Whether this is an externally defined name */\n    boolean externallyDefined = false;\n\n    /** Whether this node is referenced */\n    boolean referenced = false;\n\n    /** Whether the name has descendants that are written to. */\n    boolean hasWrittenDescendants = false;\n\n    /** Whether the name is used in a instanceof check */\n    boolean hasInstanceOfReference = false;\n\n    /**\n     * Output the node as a string\n     *\n     * @return Node as a string\n     */\n    @Override\n    public String toString() {\n      StringBuilder out = new StringBuilder();\n      out.append(name);\n\n      if (prototypeNames.size() > 0) {\n        out.append(\" (CLASS)\\n\");\n        out.append(\" - FUNCTIONS: \");\n        Iterator<String> pIter = prototypeNames.iterator();\n        while (pIter.hasNext()) {\n          out.append(pIter.next());\n          if (pIter.hasNext()) {\n            out.append(\", \");\n          }\n        }\n      }\n\n      return out.toString();\n    }\n\n    @Override\n    public int compareTo(JsName rhs) {\n      return this.name.compareTo(rhs.name);\n    }\n  }\n\n  /**\n   * Interface to get information about and remove unreferenced names.\n   */\n  interface RefNode {\n    JsName name();\n    void remove();\n  }\n\n  /**\n   * Class for nodes that reference a fully-qualified JS name. Fully qualified\n   * names are of form A or A.B (A.B.C, etc.). References can get the value or\n   * set the value of the JS name.\n   */\n  private class JsNameRefNode implements RefNode {\n    /** JsName node for this reference */\n    JsName name;\n\n    /**\n     * Top GETPROP or NAME or STRING [objlit key] node defining the name of\n     * this node\n     */\n    @SuppressWarnings(\"unused\")\n    Node node;\n\n    /**\n     * Parent node of the name access\n     * (ASSIGN, VAR, FUNCTION, OBJECTLIT, or CALL)\n     */\n    Node parent;\n\n\n    /**\n     * Create a node that refers to a name\n     *\n     * @param name The name\n     * @param node The top node representing the name (GETPROP, NAME, STRING)\n     */\n    JsNameRefNode(JsName name, Node node) {\n      this.name = name;\n      this.node = node;\n      this.parent = node.getParent();\n    }\n\n    @Override\n    public JsName name() {\n      return name;\n    }\n\n    @Override\n    public void remove() {\n      // Setters have VAR, FUNCTION, or ASSIGN parent nodes. CALL parent\n      // nodes are global refs, and are handled later in this function.\n      Node containingNode = parent.getParent();\n      switch (parent.getType()) {\n        case Token.VAR:\n          Preconditions.checkState(parent.hasOneChild());\n          replaceWithRhs(containingNode, parent);\n          break;\n        case Token.FUNCTION:\n          replaceWithRhs(containingNode, parent);\n          break;\n        case Token.ASSIGN:\n          if (containingNode.isExprResult()) {\n            replaceWithRhs(containingNode.getParent(), containingNode);\n          } else {\n            replaceWithRhs(containingNode, parent);\n          }\n          break;\n        case Token.OBJECTLIT:\n          // TODO(nicksantos): Come up with a way to remove this.\n          // If we remove object lit keys, then we will need to also\n          // create dependency scopes for them.\n          break;\n      }\n    }\n  }\n\n\n  /**\n   * Class for nodes that set prototype properties or methods.\n   */\n  private class PrototypeSetNode extends JsNameRefNode {\n    /**\n     * Create a set node from the name & setter node\n     *\n     * @param name The name\n     * @param parent Parent node that assigns the expression (an ASSIGN)\n     */\n    PrototypeSetNode(JsName name, Node parent) {\n      super(name, parent.getFirstChild());\n\n      Preconditions.checkState(parent.isAssign());\n    }\n\n    @Override public void remove() {\n      Node gramps = parent.getParent();\n      if (gramps.isExprResult()) {\n        // name.prototype.foo = function() { ... };\n        changeProxy.removeChild(gramps.getParent(), gramps);\n      } else {\n        // ... name.prototype.foo = function() { ... } ...\n        changeProxy.replaceWith(gramps, parent,\n                                parent.getLastChild().cloneTree());\n      }\n    }\n  }\n\n  /**\n   * Base class for special reference nodes.\n   */\n  private abstract class SpecialReferenceNode implements RefNode {\n    /** JsName node for the function */\n    JsName name;\n\n    /** The CALL node */\n    Node node;\n\n    /** The parent of {@code node} */\n    Node parent;\n\n    /** The parent of {@code parent} */\n    Node gramps;\n\n    /**\n     * Create a special reference node.\n     *\n     * @param name The name\n     * @param node The CALL node\n     * @param parent The parent of {@code node}\n     * @param gramps The parent of {@code parent}\n     */\n    SpecialReferenceNode(JsName name, Node node, Node parent,\n        Node gramps) {\n      this.name = name;\n      this.node = node;\n      this.parent = parent;\n      this.gramps = gramps;\n    }\n\n    @Override\n    public JsName name() {\n      return name;\n    }\n  }\n\n\n\n  /**\n   * Class for nodes that are function calls that may change a function's\n   * prototype\n   */\n  private class ClassDefiningFunctionNode extends SpecialReferenceNode {\n    /**\n     * Create a class defining function node from the name & setter node\n     *\n     * @param name The name\n     * @param node The CALL node\n     * @param parent The parent of {@code node}\n     * @param gramps The parent of {@code parent}\n     */\n    ClassDefiningFunctionNode(JsName name, Node node, Node parent,\n        Node gramps) {\n      super(name, node, parent, gramps);\n      Preconditions.checkState(node.isCall());\n    }\n\n    @Override\n    public void remove() {\n      Preconditions.checkState(node.isCall());\n      if (parent.isExprResult()) {\n        changeProxy.removeChild(gramps, parent);\n      } else {\n        changeProxy.replaceWith(parent, node, IR.voidNode(IR.number(0)));\n      }\n    }\n  }\n\n\n\n  /**\n   * Class for nodes that check instanceof\n   */\n  private class InstanceOfCheckNode extends SpecialReferenceNode {\n    /**\n     * Create an instanceof node from the name and parent node\n     *\n     * @param name The name\n     * @param node The qualified name node\n     * @param parent The parent of {@code node}, this should be an instanceof\n     *     node.\n     * @param gramps The parent of {@code parent}.\n     */\n    InstanceOfCheckNode(JsName name, Node node, Node parent, Node gramps) {\n      super(name, node, parent, gramps);\n      Preconditions.checkState(node.isQualifiedName());\n      Preconditions.checkState(parent.isInstanceOf());\n    }\n\n    @Override\n    public void remove() {\n      changeProxy.replaceWith(gramps, parent, IR.falseNode());\n    }\n  }\n\n  /**\n   * Walk through externs and mark nodes as externally declared if declared\n   */\n  private class ProcessExternals extends AbstractPostOrderCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      NameInformation ns = null;\n      if (NodeUtil.isVarDeclaration(n)) {\n        ns = createNameInformation(t, n, parent);\n      } else if (NodeUtil.isFunctionDeclaration(n)) {\n        ns = createNameInformation(t, n.getFirstChild(), n);\n      }\n      if (ns != null) {\n        JsName jsName = getName(ns.name, true);\n        jsName.externallyDefined = true;\n        externalNames.add(ns.name);\n      }\n    }\n  }\n\n  /**\n   * <p>Identifies all dependency scopes.\n   *\n   * <p>A dependency scope is a relationship between a node tree and a name that\n   * implies that the node tree will not execute (and thus can be eliminated) if\n   * the name is never referenced.\n   *\n   * <p>The entire parse tree is ultimately in a dependency scope relationship\n   * with <code>window</code> (or an equivalent name for the global scope), but\n   * the goal here is to find finer-grained relationships. This callback creates\n   * dependency scopes for every assignment statement, variable declaration, and\n   * function call in the global scope.\n   *\n   * <p>Note that dependency scope node trees aren't necessarily disjoint.\n   * In the following code snippet, for example, the function definition\n   * forms a dependency scope with the name <code>f</code> and the assignment\n   * inside the function forms a dependency scope with the name <code>x</code>.\n   * <pre>\n   * var x; function f() { x = 1; }\n   * </pre>\n   */\n  private class FindDependencyScopes extends AbstractPostOrderCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n          if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n            // Patch for assignments that appear in the init,\n            // condition or iteration part of a FOR loop.  Without\n            // this change, all 3 of those parts try to claim the for\n            // loop as their dependency scope.  The last assignment in\n            // those three fields wins, which can result in incorrect\n            // reference edges between referenced and assigned variables.\n            //\n            // TODO(user) revisit the dependency scope calculation\n            // logic.\n            if (parent.getFirstChild().getNext() != n) {\n              recordDepScope(n, ns);\n            } else {\n              recordDepScope(nameNode, ns);\n            }\n          } else {\n            recordDepScope(n, ns);\n          }\n        }\n      } else if (NodeUtil.isVarDeclaration(n)) {\n        NameInformation ns = createNameInformation(t, n, parent);\n        recordDepScope(n, ns);\n      } else if (NodeUtil.isFunctionDeclaration(n)) {\n        NameInformation ns = createNameInformation(t, n.getFirstChild(), n);\n        recordDepScope(n, ns);\n      } else if (NodeUtil.isExprCall(n)) {\n        Node callNode = n.getFirstChild();\n        Node nameNode = callNode.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, callNode);\n        if (ns != null && ns.onlyAffectsClassDef) {\n          recordDepScope(n, ns);\n        }\n      }\n    }\n\n    /**\n     * Defines a dependency scope.\n     */\n    private void recordDepScope(Node node, NameInformation name) {\n      scopes.put(node, name);\n    }\n  }\n\n  /**\n   * Create JsName objects for variable and function declarations in\n   * the global scope before computing name references.  In javascript\n   * it is legal to refer to variable and function names before the\n   * actual declaration.\n   */\n  private class HoistVariableAndFunctionDeclarations\n      extends NodeTraversal.AbstractShallowCallback {\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (NodeUtil.isVarDeclaration(n)) {\n        NameInformation ns = createNameInformation(t, n, parent);\n        Preconditions.checkNotNull(ns, \"NameInformation is null\");\n        createName(ns.name);\n      } else if (NodeUtil.isFunctionDeclaration(n)) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        Preconditions.checkNotNull(ns, \"NameInformation is null\");\n        createName(nameNode.getString());\n      }\n    }\n  }\n\n  /**\n   * Identifies all declarations of global names and setter statements\n   * affecting global symbols (assignments to global names).\n   *\n   * All declarations and setters must be gathered in a single\n   * traversal and stored in traversal order so \"removeUnreferenced\"\n   * can perform modifications in traversal order.\n   */\n  private class FindDeclarationsAndSetters extends AbstractPostOrderCallback {\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      // Record global variable and function declarations\n      if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          Preconditions.checkNotNull(ns);\n          recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n          Node nameNode = n.getFirstChild();\n          NameInformation ns = createNameInformation(t, nameNode, n);\n          if (ns != null) {\n            JsName nameInfo = getName(nameNode.getString(), true);\n            recordSet(nameInfo.name, nameNode);\n          }\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          if (ns != null) {\n            recordSet(ns.name, n);\n          }\n        }\n      }\n\n      // Record assignments and call sites\n      if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n          if (ns.isPrototype) {\n            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n          } else {\n            recordSet(ns.name, nameNode);\n          }\n        }\n      } else if (n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, false);\n          if (name != null) {\n          refNodes.add(new ClassDefiningFunctionNode(\n              name, n, parent, parent.getParent()));\n          }\n        }\n      }\n    }\n\n    /**\n     * Records the assignment of a value to a global name.\n     *\n     * @param name Fully qualified name\n     * @param node The top node representing the name (GETPROP, NAME, or STRING\n     * [objlit key])\n     */\n    private void recordSet(String name, Node node) {\n      JsName jsn = getName(name, true);\n      JsNameRefNode nameRefNode = new JsNameRefNode(jsn, node);\n      refNodes.add(nameRefNode);\n\n      // Now, look at all parent names and record that their properties have\n      // been written to.\n      if (node.isGetElem()) {\n        recordWriteOnProperties(name);\n      } else if (name.indexOf('.') != -1) {\n        recordWriteOnProperties(name.substring(0, name.lastIndexOf('.')));\n      }\n    }\n\n    /**\n     * Records the assignment to a prototype property of a global name,\n     * if possible.\n     *\n     * @param className The name of the class.\n     * @param prototypeProperty The name of the prototype property.\n     * @param node The top node representing the name (GETPROP)\n     */\n    private void recordPrototypeSet(String className, String prototypeProperty,\n        Node node) {\n      JsName name = getName(className, true);\n      name.prototypeNames.add(prototypeProperty);\n      refNodes.add(new PrototypeSetNode(name, node));\n      recordWriteOnProperties(className);\n    }\n\n    /**\n     * Record that the properties of this name have been written to.\n     */\n    private void recordWriteOnProperties(String parentName) {\n      do {\n        JsName parent = getName(parentName, true);\n        if (parent.hasWrittenDescendants) {\n          // If we already recorded this name, then all its parents must\n          // also be recorded. short-circuit this loop.\n          return;\n        } else {\n          parent.hasWrittenDescendants = true;\n        }\n\n        if (parentName.indexOf('.') == -1) {\n          return;\n        }\n        parentName = parentName.substring(0, parentName.lastIndexOf('.'));\n      } while(true);\n    }\n  }\n\n  private static final Predicate<Node> NON_LOCAL_RESULT_PREDICATE =\n      new Predicate<Node>() {\n        @Override\n        public boolean apply(Node input) {\n          if (input.isCall()) {\n            return false;\n          }\n          // TODO(johnlenz): handle NEW calls that record their 'this'\n          // in global scope and effectly return an alias.\n          // Other non-local references are handled by this pass.\n          return true;\n        }\n      };\n\n  /**\n   * <p>Identifies all references between global names.\n   *\n   * <p>A reference from a name <code>f</code> to a name <code>g</code> means\n   * that if the name <code>f</code> must be defined, then the name\n   * <code>g</code> must also be defined. This would be the case if, for\n   * example, <code>f</code> were a function that called <code>g</code>.\n   */\n  private class FindReferences implements Callback {\n    Set<Node> nodesToKeep;\n    FindReferences() {\n      nodesToKeep = Sets.newHashSet();\n    }\n\n    private void addAllChildren(Node n) {\n      nodesToKeep.add(n);\n      for (Node child = n.getFirstChild();\n           child != null;\n           child = child.getNext()) {\n        addAllChildren(child);\n      }\n    }\n\n    private void addSimplifiedChildren(Node n) {\n      NodeTraversal.traverse(\n          compiler, n,\n          new GatherSideEffectSubexpressionsCallback(\n              compiler, new NodeAccumulator()));\n    }\n\n    private void addSimplifiedExpression(Node n, Node parent) {\n      if (parent.isVar()) {\n        Node value = n.getFirstChild();\n        if (value != null) {\n          addSimplifiedChildren(value);\n        }\n      } else if (n.isAssign() &&\n          (parent.isExprResult() ||\n           parent.isFor() ||\n           parent.isReturn())) {\n        for (Node child : n.children()) {\n          addSimplifiedChildren(child);\n        }\n      } else if (n.isCall() &&\n                 parent.isExprResult()) {\n        addSimplifiedChildren(n);\n      } else {\n        addAllChildren(n);\n      }\n    }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (parent == null) {\n        return true;\n      }\n\n      // Gather the list of nodes that either have side effects, are\n      // arguments to function calls with side effects or are used in\n      // control structure predicates.  These names are always\n      // referenced when the enclosing function is called.\n      if (n.isFor()) {\n        if (!NodeUtil.isForIn(n)) {\n          Node decl = n.getFirstChild();\n          Node pred = decl.getNext();\n          Node step = pred.getNext();\n          addSimplifiedExpression(decl, n);\n          addSimplifiedExpression(pred, n);\n          addSimplifiedExpression(step, n);\n        } else { // n.getChildCount() == 3\n          Node decl = n.getFirstChild();\n          Node iter = decl.getNext();\n          addAllChildren(decl);\n          addAllChildren(iter);\n        }\n      }\n\n      if (parent.isVar() ||\n          parent.isExprResult() ||\n          parent.isReturn() ||\n          parent.isThrow()) {\n        addSimplifiedExpression(n, parent);\n      }\n\n      if ((parent.isIf() ||\n           parent.isWhile() ||\n           parent.isWith() ||\n           parent.isSwitch() ||\n           parent.isCase()) &&\n          parent.getFirstChild() == n) {\n        addAllChildren(n);\n      }\n\n      if (parent.isDo() && parent.getLastChild() == n) {\n        addAllChildren(n);\n      }\n\n      return true;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!(n.isName() ||\n            NodeUtil.isGet(n) && !parent.isGetProp())) {\n        // This is not a simple or qualified name.\n        return;\n      }\n\n      NameInformation nameInfo = createNameInformation(t, n, parent);\n      if (nameInfo == null) {\n        // The name is not a global name\n        return;\n      }\n\n      if (nameInfo.onlyAffectsClassDef) {\n        if (nameInfo.superclass != null) {\n          recordReference(\n              nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n        }\n\n        // Make sure that we record a reference to the function that does\n        // the inheritance, so that the inherits() function itself does\n        // not get stripped.\n        String nodeName = n.getQualifiedName();\n        if (nodeName != null) {\n          recordReference(\n              nameInfo.name, nodeName, RefType.REGULAR);\n        }\n\n        return;\n      }\n\n      if (parent.isInstanceOf() &&\n          parent.getLastChild() == n &&\n          // Don't cover GETELEMs with a global root node.\n          n.isQualifiedName()) {\n        JsName checkedClass = getName(nameInfo.name, true);\n        refNodes.add(\n            new InstanceOfCheckNode(\n                checkedClass, n, parent, parent.getParent()));\n        checkedClass.hasInstanceOfReference = true;\n        return;\n      }\n\n      // Determine which name might be potentially referring to this one by\n      // looking up the nearest enclosing dependency scope. It's unnecessary to\n      // determine all enclosing dependency scopes because this callback should\n      // create a chain of references between them.\n      NameInformation referring = getDependencyScope(n);\n      String referringName = \"\";\n      if (referring != null) {\n        referringName = referring.isPrototype\n                      ? referring.prototypeClass\n                      : referring.name;\n      }\n\n      String name = nameInfo.name;\n\n      // A value whose result is the return value of a function call\n      // can be an alias to global object.\n      // Here we add a alias to the general \"global\" object\n      // to act as a placeholder for the actual (unnamed) value.\n      if (maybeHiddenAlias(name, n)) {\n        recordAlias(name, WINDOW);\n      }\n\n      // An externally referenceable name must always be defined, so we add a\n      // reference to it from the global scope (a.k.a. window).\n      if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name, RefType.REGULAR);\n        maybeRecordAlias(name, parent, referring, referringName);\n        return;\n      }\n\n      // An assignment implies a reference from the enclosing dependency scope.\n      // For example, foo references bar in: function foo() {bar=5}.\n      if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n        if (referring != null) {\n          recordReference(referringName, name, RefType.REGULAR);\n        }\n        return;\n      }\n\n      if (nodesToKeep.contains(n)) {\n        NameInformation functionScope = getEnclosingFunctionDependencyScope(t);\n        if (functionScope != null) {\n          recordReference(functionScope.name, name, RefType.REGULAR);\n        } else {\n          recordReference(WINDOW, name, RefType.REGULAR);\n        }\n      } else if (referring != null) {\n        if (!maybeRecordAlias(name, parent, referring, referringName)) {\n          RefType depType = referring.onlyAffectsClassDef ?\n              RefType.INHERITANCE : RefType.REGULAR;\n          recordReference(referringName, name, depType);\n        }\n      } else {\n        // No named dependency scope found.  Unfortunately that might\n        // mean that the expression is a child of an function expression\n        // or assignment with a complex lhs.  In those cases,\n        // protect this node by creating a reference to WINDOW.\n        for (Node ancestor : n.getAncestors()) {\n          if (NodeUtil.isAssignmentOp(ancestor) ||\n              ancestor.isFunction()) {\n            recordReference(WINDOW, name, RefType.REGULAR);\n            break;\n          }\n        }\n      }\n    }\n\n    /**\n     * A value whose result is the return value of a function call\n     * can be an alias to global object. The dependency on the call target will\n     * prevent the removal of the function and its dependent values, but won't\n     * prevent the alias' removal.\n     */\n    private boolean maybeHiddenAlias(String name, Node n) {\n      Node parent = n.getParent();\n      if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n        Node rhs = (parent.isVar())\n            ? n.getFirstChild() : parent.getLastChild();\n        return (rhs != null && !NodeUtil.evaluatesToLocalValue(\n            rhs, NON_LOCAL_RESULT_PREDICATE));\n      }\n      return false;\n    }\n\n    /**\n     * @return Whether the alias was recorded.\n     */\n    private boolean maybeRecordAlias(\n        String name, Node parent,\n        NameInformation referring, String referringName) {\n      if ((parent.isName() ||\n          parent.isAssign()) &&\n          referring != null &&\n          scopes.get(parent) == referring) {\n        recordAlias(referringName, name);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Helper class that gathers the list of nodes that would be left\n     * behind after simplification.\n     */\n    private class NodeAccumulator\n        implements SideEffectAccumulator {\n\n      @Override\n      public boolean classDefiningCallsHaveSideEffects() {\n        return false;\n      }\n\n      @Override\n      public void keepSubTree(Node original) {\n        addAllChildren(original);\n      }\n\n      @Override\n      public void keepSimplifiedShortCircuitExpression(Node original) {\n        Node condition = original.getFirstChild();\n        Node thenBranch = condition.getNext();\n        addAllChildren(condition);\n        addSimplifiedChildren(thenBranch);\n      }\n\n      @Override\n      public void keepSimplifiedHookExpression(Node hook,\n                                               boolean thenHasSideEffects,\n                                               boolean elseHasSideEffects) {\n        Node condition = hook.getFirstChild();\n        Node thenBranch = condition.getNext();\n        Node elseBranch = thenBranch.getNext();\n        addAllChildren(condition);\n        if (thenHasSideEffects) {\n          addSimplifiedChildren(thenBranch);\n        }\n        if (elseHasSideEffects) {\n          addSimplifiedChildren(elseBranch);\n        }\n      }\n    }\n  }\n\n  private class RemoveListener implements AstChangeProxy.ChangeListener {\n    @Override\n    public void nodeRemoved(Node n) {\n      compiler.reportCodeChange();\n    }\n  }\n\n  /**\n   * Creates a name analyzer, with option to remove unreferenced variables when\n   * calling process().\n   *\n   * The analyzer make a best guess at whether functions affect global scope\n   * based on usage (no assignment of return value means that a function has\n   * side effects).\n   *\n   * @param compiler The AbstractCompiler\n   * @param removeUnreferenced If true, remove unreferenced variables during\n   *        process()\n   */\n  NameAnalyzer(AbstractCompiler compiler, boolean removeUnreferenced) {\n    this.compiler = compiler;\n    this.removeUnreferenced = removeUnreferenced;\n    this.globalNames = DEFAULT_GLOBAL_NAMES;\n    this.changeProxy = new AstChangeProxy();\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, externs, new ProcessExternals());\n    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());\n    NodeTraversal.traverse(\n        compiler, root, new HoistVariableAndFunctionDeclarations());\n    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());\n    NodeTraversal.traverse(compiler, root, new FindReferences());\n\n    // Create bi-directional references between parent names and their\n    // descendents. This may create new names.\n    referenceParentNames();\n\n    // If we modify the property of an alias, make sure that modification\n    // gets reflected in the original object.\n    referenceAliases();\n\n    calculateReferences();\n\n    if (removeUnreferenced) {\n      removeUnreferenced();\n    }\n  }\n\n  /**\n   * Records an alias of one name to another name.\n   */\n  private void recordAlias(String fromName, String toName) {\n    recordReference(fromName, toName, RefType.REGULAR);\n\n    // We need to add an edge to the alias graph. The alias graph is expressed\n    // implicitly as a set of connected components, called AliasSets.\n    //\n    // There are three possibilities:\n    // 1) Neither name is part of a connected component. Create a new one.\n    // 2) Exactly one name is part of a connected component. Merge the new\n    //    name into the component.\n    // 3) The two names are already part of connected components. Merge\n    //    those components together.\n    AliasSet toNameAliasSet = aliases.get(toName);\n    AliasSet fromNameAliasSet = aliases.get(fromName);\n    AliasSet resultSet = null;\n    if (toNameAliasSet == null && fromNameAliasSet == null) {\n      resultSet = new AliasSet(toName, fromName);\n    } else if (toNameAliasSet != null && fromNameAliasSet != null) {\n      resultSet = toNameAliasSet;\n      resultSet.names.addAll(fromNameAliasSet.names);\n      for (String name : fromNameAliasSet.names) {\n        aliases.put(name, resultSet);\n      }\n    } else if (toNameAliasSet != null) {\n      resultSet = toNameAliasSet;\n      resultSet.names.add(fromName);\n    } else {\n      resultSet = fromNameAliasSet;\n      resultSet.names.add(toName);\n    }\n    aliases.put(fromName, resultSet);\n    aliases.put(toName, resultSet);\n  }\n\n  /**\n   * Records a reference from one name to another name.\n   */\n  private void recordReference(String fromName, String toName,\n                               RefType depType) {\n    if (fromName.equals(toName)) {\n      // Don't bother recording self-references.\n      return;\n    }\n\n    JsName from = getName(fromName, true);\n    JsName to = getName(toName, true);\n    referenceGraph.createNode(from);\n    referenceGraph.createNode(to);\n    if (!referenceGraph.isConnectedInDirection(from, depType, to)) {\n      referenceGraph.connect(from, depType, to);\n    }\n  }\n\n  /**\n   * Removes all unreferenced variables.\n   */\n  void removeUnreferenced() {\n    RemoveListener listener = new RemoveListener();\n    changeProxy.registerListener(listener);\n\n    for (RefNode refNode : refNodes) {\n      JsName name = refNode.name();\n      if (!name.referenced && !name.externallyDefined) {\n        refNode.remove();\n      }\n    }\n\n    changeProxy.unregisterListener(listener);\n  }\n\n  /**\n   * Generates an HTML report\n   *\n   * @return The report\n   */\n  String getHtmlReport() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"<html><body><style type=\\\"text/css\\\">\"\n        + \"body, td, p {font-family: Arial; font-size: 83%} \"\n        + \"ul {margin-top:2px; margin-left:0px; padding-left:1em;} \"\n        + \"li {margin-top:3px; margin-left:24px; padding-left:0px;\"\n        + \"padding-bottom: 4px}</style>\");\n    sb.append(\"OVERALL STATS<ul>\");\n    appendListItem(sb, \"Total Names: \" + countOf(TriState.BOTH, TriState.BOTH));\n    appendListItem(sb, \"Total Classes: \"\n        + countOf(TriState.TRUE, TriState.BOTH));\n    appendListItem(sb, \"Total Static Functions: \"\n        + countOf(TriState.FALSE, TriState.BOTH));\n    appendListItem(sb, \"Referenced Names: \"\n        + countOf(TriState.BOTH, TriState.TRUE));\n    appendListItem(sb, \"Referenced Classes: \"\n        + countOf(TriState.TRUE, TriState.TRUE));\n    appendListItem(sb, \"Referenced Functions: \"\n        + countOf(TriState.FALSE, TriState.TRUE));\n    sb.append(\"</ul>\");\n\n    sb.append(\"ALL NAMES<ul>\\n\");\n    for (JsName node : allNames.values()) {\n      sb.append(\"<li>\" + nameAnchor(node.name) + \"<ul>\");\n      if (node.prototypeNames.size() > 0) {\n        sb.append(\"<li>PROTOTYPES: \");\n        Iterator<String> protoIter = node.prototypeNames.iterator();\n        while (protoIter.hasNext()) {\n          sb.append(protoIter.next());\n          if (protoIter.hasNext()) {\n            sb.append(\", \");\n          }\n        }\n      }\n\n      if (referenceGraph.hasNode(node)) {\n        List<DiGraphEdge<JsName, RefType>> refersTo =\n            referenceGraph.getOutEdges(node);\n        if (refersTo.size() > 0) {\n          sb.append(\"<li>REFERS TO: \");\n          Iterator<DiGraphEdge<JsName, RefType>> toIter = refersTo.iterator();\n          while (toIter.hasNext()) {\n            sb.append(nameLink(toIter.next().getDestination().getValue().name));\n            if (toIter.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n        }\n\n        List<DiGraphEdge<JsName, RefType>> referencedBy =\n            referenceGraph.getInEdges(node);\n        if (referencedBy.size() > 0) {\n          sb.append(\"<li>REFERENCED BY: \");\n          Iterator<DiGraphEdge<JsName, RefType>> fromIter = refersTo.iterator();\n          while (fromIter.hasNext()) {\n            sb.append(\n                nameLink(fromIter.next().getDestination().getValue().name));\n            if (fromIter.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n        }\n      }\n      sb.append(\"</li>\");\n      sb.append(\"</ul></li>\");\n    }\n    sb.append(\"</ul>\");\n    sb.append(\"</body></html>\");\n\n    return sb.toString();\n  }\n\n  private void appendListItem(StringBuilder sb, String text) {\n    sb.append(\"<li>\" + text + \"</li>\\n\");\n  }\n\n  private String nameLink(String name) {\n    return \"<a href=\\\"#\" + name + \"\\\">\" + name + \"</a>\";\n  }\n\n  private String nameAnchor(String name) {\n    return \"<a name=\\\"\" + name + \"\\\">\" + name + \"</a>\";\n  }\n\n  /**\n   * Looks up a {@link JsName} by name, optionally creating one if it doesn't\n   * already exist.\n   *\n   * @param name A fully qualified name\n   * @param canCreate Whether to create the object if necessary\n   * @return The {@code JsName} object, or null if one can't be found and\n   *   can't be created.\n   */\n  private JsName getName(String name, boolean canCreate) {\n    if (canCreate) {\n      createName(name);\n    }\n    return allNames.get(name);\n  }\n\n  /**\n   * Creates a {@link JsName} for the given name if it doesn't already\n   * exist.\n   *\n   * @param name A fully qualified name\n   */\n  private void createName(String name) {\n    JsName jsn = allNames.get(name);\n    if (jsn == null) {\n      jsn = new JsName();\n      jsn.name = name;\n      allNames.put(name, jsn);\n    }\n  }\n\n  /**\n   * The NameAnalyzer algorithm works best when all objects have a canonical\n   * name in the global scope. When multiple names in the global scope\n   * point to the same object, things start to break down.\n   *\n   * For example, if we have\n   * <code>\n   * var a = {};\n   * var b = a;\n   * a.foo = 3;\n   * alert(b.foo);\n   * </code>\n   * then a.foo and b.foo are the same name, even though NameAnalyzer doesn't\n   * represent them as such.\n   *\n   * To handle this case, we look at all the aliases in the program.\n   * If descendant properties of that alias are assigned, then we create a\n   * directional reference from the original name to the alias. For example,\n   * in this case, the assign to {@code a.foo} triggers a reference from\n   * {@code b} to {@code a}, but NOT from a to b.\n   *\n   * Similarly, \"instanceof\" checks do not prevent the removal\n   * of a unaliased name but an instanceof check on an alias can only be removed\n   * if the other aliases are also removed, so we add a connection here.\n   */\n  private void referenceAliases() {\n    for (Map.Entry<String, AliasSet> entry : aliases.entrySet()) {\n      JsName name = getName(entry.getKey(), false);\n      if (name.hasWrittenDescendants || name.hasInstanceOfReference) {\n        for (String alias : entry.getValue().names) {\n          recordReference(alias, entry.getKey(), RefType.REGULAR);\n        }\n      }\n    }\n  }\n\n  /**\n   * Adds mutual references between all known global names and their parent\n   * names. (e.g. between <code>a.b.c</code> and <code>a.b</code>).\n   */\n  private void referenceParentNames() {\n    // Duplicate set of nodes to process so we don't modify set we are\n    // currently iterating over\n    Set<JsName> allNamesCopy = Sets.newHashSet(allNames.values());\n\n    for (JsName name : allNamesCopy) {\n      String curName = name.name;\n      JsName curJsName = name;\n      while (curName.indexOf('.') != -1) {\n        String parentName = curName.substring(0, curName.lastIndexOf('.'));\n        if (!globalNames.contains(parentName)) {\n\n          JsName parentJsName = getName(parentName, true);\n\n          recordReference(curJsName.name, parentJsName.name, RefType.REGULAR);\n          recordReference(parentJsName.name, curJsName.name, RefType.REGULAR);\n\n          curJsName = parentJsName;\n        }\n        curName = parentName;\n      }\n    }\n  }\n\n  /**\n   * Creates name information for the current node during a traversal.\n   *\n   * @param t The node traversal\n   * @param n The current node\n   * @param parent The parent of n\n   * @return The name information, or null if the name is irrelevant to this\n   *     pass\n   */\n  private NameInformation createNameInformation(NodeTraversal t, Node n,\n      Node parent) {\n    // Build the full name and find its root node by iterating down through all\n    // GETPROP/GETELEM nodes.\n    String name = \"\";\n    Node rootNameNode = n;\n    boolean bNameWasShortened = false;\n    while (true) {\n      if (NodeUtil.isGet(rootNameNode)) {\n        Node prop = rootNameNode.getLastChild();\n        if (rootNameNode.isGetProp()) {\n          name = \".\" + prop.getString() + name;\n        } else {\n          // We consider the name to be \"a.b\" in a.b['c'] or a.b[x].d.\n          bNameWasShortened = true;\n          name = \"\";\n        }\n        rootNameNode = rootNameNode.getFirstChild();\n      } else if (NodeUtil.isObjectLitKey(\n          rootNameNode, rootNameNode.getParent())) {\n        name = \".\" + rootNameNode.getString() + name;\n\n        // Check if this is an object literal assigned to something.\n        Node objLit = rootNameNode.getParent();\n        Node objLitParent = objLit.getParent();\n        if (objLitParent.isAssign()) {\n          // This must be the right side of the assign.\n          rootNameNode = objLitParent.getFirstChild();\n        } else if (objLitParent.isName()) {\n          // This must be a VAR initialization.\n          rootNameNode = objLitParent;\n        } else if (objLitParent.isString()) {\n          // This must be a object literal key initialization.\n          rootNameNode = objLitParent;\n        } else {\n          return null;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Check whether this is a class-defining call. Classes may only be defined\n    // in the global scope.\n    if (parent.isCall() && t.inGlobalScope()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship classes = convention.getClassesDefinedByCall(parent);\n      if (classes != null) {\n        NameInformation nameInfo = new NameInformation();\n        nameInfo.name = classes.subclassName;\n        nameInfo.onlyAffectsClassDef = true;\n        nameInfo.superclass = classes.superclassName;\n        return nameInfo;\n      }\n\n      String singletonGetterClass =\n          convention.getSingletonGetterClassName(parent);\n      if (singletonGetterClass != null) {\n        NameInformation nameInfo = new NameInformation();\n        nameInfo.name = singletonGetterClass;\n        nameInfo.onlyAffectsClassDef = true;\n        return nameInfo;\n      }\n    }\n\n    switch (rootNameNode.getType()) {\n      case Token.NAME:\n        // Check whether this is an assignment to a prototype property\n        // of an object defined in the global scope.\n        if (!bNameWasShortened &&\n            n.isGetProp() &&\n            parent.isAssign() &&\n            \"prototype\".equals(n.getLastChild().getString())) {\n          if (createNameInformation(t, n.getFirstChild(), n) != null) {\n            name = rootNameNode.getString() + name;\n            name = name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);\n            NameInformation nameInfo = new NameInformation();\n            nameInfo.name = name;\n            return nameInfo;\n          } else {\n            return null;\n          }\n        }\n        return createNameInformation(\n            rootNameNode.getString() + name, t.getScope(), rootNameNode);\n      case Token.THIS:\n        if (t.inGlobalScope()) {\n          NameInformation nameInfo = new NameInformation();\n          if (name.indexOf('.') == 0) {\n            nameInfo.name = name.substring(1);  // strip leading \".\"\n          } else {\n            nameInfo.name = name;\n          }\n          nameInfo.isExternallyReferenceable = true;\n          return nameInfo;\n        }\n        return null;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Creates name information for a particular qualified name that occurs in a\n   * particular scope.\n   *\n   * @param name A qualified name (e.g. \"x\" or \"a.b.c\")\n   * @param scope The scope in which {@code name} occurs\n   * @param rootNameNode The NAME node for the first token of {@code name}\n   * @return The name information, or null if the name is irrelevant to this\n   *     pass\n   */\n  private NameInformation createNameInformation(\n      String name, Scope scope, Node rootNameNode) {\n    // Check the scope. Currently we're only looking at globally scoped vars.\n    String rootName = rootNameNode.getString();\n    Var v = scope.getVar(rootName);\n    boolean isExtern = (v == null && externalNames.contains(rootName));\n    boolean isGlobalRef = (v != null && v.isGlobal()) || isExtern ||\n        rootName.equals(WINDOW);\n    if (!isGlobalRef) {\n      return null;\n    }\n\n    NameInformation nameInfo = new NameInformation();\n\n    // If a prototype property or method, fill in prototype information.\n    int idx = name.indexOf(PROTOTYPE_SUBSTRING);\n    if (idx != -1) {\n      nameInfo.isPrototype = true;\n      nameInfo.prototypeClass = name.substring(0, idx);\n      nameInfo.prototypeProperty = name.substring(\n          idx + PROTOTYPE_SUBSTRING_LEN);\n    }\n\n    nameInfo.name = name;\n    nameInfo.isExternallyReferenceable =\n        isExtern || isExternallyReferenceable(scope, name);\n    return nameInfo;\n  }\n\n  /**\n   * Checks whether a name can be referenced outside of the compiled code.\n   * These names will be the root of dependency trees.\n   *\n   * @param scope The current variable scope\n   * @param name The name\n   * @return True if can be referenced outside\n   */\n  private boolean isExternallyReferenceable(Scope scope, String name) {\n    if (compiler.getCodingConvention().isExported(name)) {\n      return true;\n    }\n    if (scope.isLocal()) {\n      return false;\n    }\n    for (String s : globalNames) {\n      if (name.startsWith(s)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the nearest enclosing dependency scope, or null if there isn't one.\n   */\n  private NameInformation getDependencyScope(Node n) {\n    for (Node node : n.getAncestors()) {\n      NameInformation ref = scopes.get(node);\n      if (ref != null) {\n        return ref;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get dependency scope defined by the enclosing function, or null.\n   * If enclosing function is a function expression, determine scope based on\n   * its parent if the parent node is a variable declaration or\n   * assignment.\n   */\n  private NameInformation getEnclosingFunctionDependencyScope(NodeTraversal t) {\n    Node function = t.getEnclosingFunction();\n    if (function == null) {\n      return null;\n    }\n\n    NameInformation ref = scopes.get(function);\n    if (ref != null) {\n      return ref;\n    }\n\n    // Function expression.  try to get a name from the parent var\n    // declaration or assignment.\n    Node parent = function.getParent();\n    if (parent != null) {\n      // Account for functions defined in the form:\n      //   var a = cond ? function a() {} : function b() {};\n      while (parent.isHook()) {\n        parent = parent.getParent();\n      }\n\n      if (parent.isName()) {\n        return scopes.get(parent);\n      }\n\n      if (parent.isAssign()) {\n        return scopes.get(parent);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Propagate \"referenced\" property down the graph.\n   */\n  private void calculateReferences() {\n    JsName window = getName(WINDOW, true);\n    window.referenced = true;\n    JsName function = getName(FUNCTION, true);\n    function.referenced = true;\n\n    // Propagate \"referenced\" property to a fixed point.\n    FixedPointGraphTraversal.newTraversal(new ReferencePropagationCallback())\n        .computeFixedPoint(referenceGraph);\n  }\n\n\n  /**\n   * Enum for saying a value can be true, false, or either (cleaner than using a\n   * Boolean with null)\n   */\n  private enum TriState {\n    /** If value is true */\n    TRUE,\n    /** If value is false */\n    FALSE,\n    /** If value can be true or false */\n    BOTH\n  }\n\n  /**\n   * Gets the count of nodes matching the criteria\n   *\n   * @param isClass Whether the node is a class\n   * @param referenced Whether the node is referenced\n   * @return Number of matches\n   */\n  private int countOf(TriState isClass, TriState referenced) {\n    int count = 0;\n    for (JsName name : allNames.values()) {\n\n      boolean nodeIsClass = name.prototypeNames.size() > 0;\n\n      boolean classMatch = isClass == TriState.BOTH\n          || (nodeIsClass && isClass == TriState.TRUE)\n          || (!nodeIsClass && isClass == TriState.FALSE);\n\n      boolean referenceMatch = referenced == TriState.BOTH\n          || (name.referenced && referenced == TriState.TRUE)\n          || (!name.referenced && referenced == TriState.FALSE);\n\n      if (classMatch && referenceMatch && !name.externallyDefined) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n\n  /**\n   * Extract a list of replacement nodes to use.\n   */\n  private List<Node> getSideEffectNodes(Node n) {\n    List<Node> subexpressions = Lists.newArrayList();\n    NodeTraversal.traverse(\n        compiler, n,\n        new GatherSideEffectSubexpressionsCallback(\n            compiler,\n            new CopySideEffectSubexpressions(compiler, subexpressions)));\n\n    List<Node> replacements =\n        Lists.newArrayListWithExpectedSize(subexpressions.size());\n    for (Node subexpression : subexpressions) {\n      replacements.add(NodeUtil.newExpr(subexpression));\n    }\n    return replacements;\n  }\n\n  /**\n   * Replace n with a simpler expression, while preserving program\n   * behavior.\n   *\n   * If the n's value is used, replace it with its rhs; otherwise\n   * replace it with the subexpressions that have side effects.\n   */\n  private void replaceWithRhs(Node parent, Node n) {\n    if (valueConsumedByParent(n, parent)) {\n      // parent reads from n directly; replace it with n's rhs + lhs\n      // subexpressions with side effects.\n      List<Node> replacements = getRhsSubexpressions(n);\n      List<Node> newReplacements = Lists.newArrayList();\n      for (int i = 0; i < replacements.size() - 1; i++) {\n        newReplacements.addAll(getSideEffectNodes(replacements.get(i)));\n      }\n      Node valueExpr = replacements.get(replacements.size() - 1);\n      valueExpr.detachFromParent();\n      newReplacements.add(valueExpr);\n      changeProxy.replaceWith(\n          parent, n, collapseReplacements(newReplacements));\n    } else if (n.isAssign() && !parent.isFor()) {\n      // assignment appears in a RHS expression.  we have already\n      // considered names in the assignment's RHS as being referenced;\n      // replace the assignment with its RHS.\n      // TODO(user) make the pass smarter about these cases and/or run\n      // this pass and RemoveConstantExpressions together in a loop.\n      Node replacement = n.getLastChild();\n      replacement.detachFromParent();\n      changeProxy.replaceWith(parent, n, replacement);\n    } else {\n      replaceTopLevelExpressionWithRhs(parent, n);\n    }\n  }\n\n  /**\n   * Simplify a toplevel expression, while preserving program\n   * behavior.\n   */\n  private void replaceTopLevelExpressionWithRhs(Node parent, Node n) {\n    // validate inputs\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.SCRIPT:\n      case Token.FOR:\n      case Token.LABEL:\n        break;\n      default:\n        throw new IllegalArgumentException(\n            \"Unsupported parent node type in replaceWithRhs \" +\n            Token.name(parent.getType()));\n    }\n\n    switch (n.getType()) {\n      case Token.EXPR_RESULT:\n      case Token.FUNCTION:\n      case Token.VAR:\n        break;\n      case Token.ASSIGN:\n        Preconditions.checkArgument(parent.isFor(),\n            \"Unsupported assignment in replaceWithRhs. parent: %s\", Token.name(parent.getType()));\n        break;\n      default:\n        throw new IllegalArgumentException(\n            \"Unsupported node type in replaceWithRhs \" +\n            Token.name(n.getType()));\n    }\n\n    // gather replacements\n    List<Node> replacements = Lists.newArrayList();\n    for (Node rhs : getRhsSubexpressions(n)) {\n      replacements.addAll(getSideEffectNodes(rhs));\n    }\n\n    if (parent.isFor()) {\n      // tweak replacements array s.t. it is a single expression node.\n      if (replacements.isEmpty()) {\n        replacements.add(IR.empty());\n      } else {\n        Node expr = collapseReplacements(replacements);\n        replacements.clear();\n        replacements.add(expr);\n      }\n    }\n\n    changeProxy.replaceWith(parent, n, replacements);\n  }\n\n  /**\n   * Determine if the parent reads the value of a child expression\n   * directly.  This is true children used in predicates, RETURN\n   * statements and, rhs of variable declarations and assignments.\n   *\n   * In the case of:\n   * if (a) b else c\n   *\n   * This method returns true for \"a\", and false for \"b\" and \"c\": the\n   * IF expression does something special based on \"a\"'s value.  \"b\"\n   * and \"c\" are effectivelly outputs.  Same logic applies to FOR,\n   * WHILE and DO loop predicates.  AND/OR/HOOK expressions are\n   * syntactic sugar for IF statements; therefore this method returns\n   * true for the predicate and false otherwise.\n   */\n  private boolean valueConsumedByParent(Node n, Node parent) {\n    if (NodeUtil.isAssignmentOp(parent)) {\n      return parent.getLastChild() == n;\n    }\n\n    switch (parent.getType()) {\n      case Token.NAME:\n      case Token.RETURN:\n        return true;\n      case Token.AND:\n      case Token.OR:\n      case Token.HOOK:\n        return parent.getFirstChild() == n;\n      case Token.FOR:\n        return parent.getFirstChild().getNext() == n;\n      case Token.IF:\n      case Token.WHILE:\n        return parent.getFirstChild() == n;\n      case Token.DO:\n        return parent.getLastChild() == n;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Merge a list of nodes into a single expression.  The value of the\n   * new expression is determined by the last expression in the list.\n   */\n  private Node collapseReplacements(List<Node> replacements) {\n    Node expr = null;\n    for (Node rep : replacements) {\n      if (rep.isExprResult()) {\n        rep = rep.getFirstChild();\n        rep.detachFromParent();\n      }\n\n      if (expr == null) {\n        expr = rep;\n      } else {\n        expr = IR.comma(expr, rep);\n      }\n    }\n\n    return expr;\n  }\n\n  /**\n   * Extract a list of subexpressions that act as right hand sides.\n   */\n  private List<Node> getRhsSubexpressions(Node n) {\n    switch (n.getType()) {\n      case Token.EXPR_RESULT:\n        // process body\n        return getRhsSubexpressions(n.getFirstChild());\n      case Token.FUNCTION:\n        // function nodes have no rhs\n        return Collections.emptyList();\n      case Token.NAME:\n        {\n          // parent is a var node.  rhs is first child\n          Node rhs = n.getFirstChild();\n          if (rhs != null) {\n            return Lists.newArrayList(rhs);\n          } else {\n            return Collections.emptyList();\n          }\n        }\n      case Token.ASSIGN:\n        {\n          // add lhs and rhs expressions - lhs may be a complex expression\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          return Lists.newArrayList(lhs, rhs);\n        }\n      case Token.VAR:\n        {\n          // recurse on all children\n          List<Node> nodes = Lists.newArrayList();\n          for (Node child : n.children()) {\n            nodes.addAll(getRhsSubexpressions(child));\n          }\n          return nodes;\n        }\n      default:\n        throw new IllegalArgumentException(\"AstChangeProxy::getRhs \" + n);\n    }\n  }\n}\n", "review": {"response": "{\n  \"bugs\": []\n}"}}