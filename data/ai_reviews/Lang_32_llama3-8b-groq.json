{"sample_id": "Lang_32", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.lang3.builder;\n\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\n/**\n * <p>\n * Assists in implementing {@link Object#hashCode()} methods.\n * </p>\n * \n * <p>\n * This class enables a good <code>hashCode</code> method to be built for any class. It follows the rules laid out in\n * the book <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a> by Joshua Bloch. Writing a\n * good <code>hashCode</code> method is actually quite difficult. This class aims to simplify the process.\n * </p>\n * \n * <p>\n * All relevant fields from the object should be included in the <code>hashCode</code> method. Derived fields may be\n * excluded. In general, any field used in the <code>equals</code> method must be used in the <code>hashCode</code>\n * method.\n * </p>\n * \n * <p>\n * To use this class write code as follows:\n * </p>\n * \n * <pre>\n * public class Person {\n *   String name;\n *   int age;\n *   boolean smoker;\n *   ...\n *\n *   public int hashCode() {\n *     // you pick a hard-coded, randomly chosen, non-zero, odd number\n *     // ideally different for each class\n *     return new HashCodeBuilder(17, 37).\n *       append(name).\n *       append(age).\n *       append(smoker).\n *       toHashCode();\n *   }\n * }\n * </pre>\n * \n * <p>\n * If required, the superclass <code>hashCode()</code> can be added using {@link #appendSuper}.\n * </p>\n * \n * <p>\n * Alternatively, there is a method that uses reflection to determine the fields to test. Because these fields are\n * usually private, the method, <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code>\n * to change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions\n * are set up correctly. It is also slower than testing explicitly.\n * </p>\n * \n * <p>\n * A typical invocation for this method would look like:\n * </p>\n * \n * <pre>\n * public int hashCode() {\n *   return HashCodeBuilder.reflectionHashCode(this);\n * }\n * </pre>\n * \n * @author Apache Software Foundation\n * @author Gary Gregory\n * @author Pete Gieser\n * @since 1.0\n * @version $Id$\n */\npublic class HashCodeBuilder {\n    /**\n     * <p>\n     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n     * </p>\n     * \n     * @since 2.3\n     */\n    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {\n        @Override\n        protected Set<IDKey> initialValue() {\n            return new HashSet<IDKey>();\n        }\n    };\n\n    /*\n     * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n     * we are in the process of calculating.\n     * \n     * So we generate a one-to-one mapping from the original object to a new object.\n     * \n     * Now HashSet uses equals() to determine if two elements with the same hashcode really\n     * are equal, so we also need to ensure that the replacement objects are only equal\n     * if the original objects are identical.\n     * \n     * The original implementation (2.4 and before) used the System.indentityHashCode()\n     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\n     *  \n     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\n     * to disambiguate the duplicate ids.\n     */\n    \n    /**\n     * <p>\n     * Returns the registry of objects being traversed by the reflection methods in the current thread.\n     * </p>\n     * \n     * @return Set the registry of objects being traversed\n     * @since 2.3\n     */\n    static Set<IDKey> getRegistry() {\n        return REGISTRY.get();\n    }\n\n    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n     * infinite loops.\n     * </p>\n     * \n     * @param value\n     *            The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given object.\n     * @since 2.3\n     */\n    static boolean isRegistered(Object value) {\n        return getRegistry().contains(new IDKey(value));\n    }\n\n    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given <code>Class</code>.\n     * </p>\n     * \n     * @param object\n     *            the object to append details of\n     * @param clazz\n     *            the class to append details of\n     * @param builder\n     *            the builder to append to\n     * @param useTransients\n     *            whether to use transient fields\n     * @param excludeFields\n     *            Collection of String field names to exclude from use in calculation of hash code\n     */\n    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\n            String[] excludeFields) {\n        if (isRegistered(object)) {\n            return;\n        }\n        try {\n            register(object);\n            Field[] fields = clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (Field field : fields) {\n                if (!ArrayUtils.contains(excludeFields, field.getName())\n                    && (field.getName().indexOf('$') == -1)\n                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\n                    && (!Modifier.isStatic(field.getModifiers()))) {\n                    try {\n                        Object fieldValue = field.get(object);\n                        builder.append(fieldValue);\n                    } catch (IllegalAccessException e) {\n                        // this can't happen. Would get a Security exception instead\n                        // throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(object);\n        }\n    }\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n     * <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * <p>\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n     * </p>\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the number is zero or even\n     */\n    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null, null);\n    }\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * <p>\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n     * </p>\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param testTransients\n     *            whether to include transient fields\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the number is zero or even\n     */\n    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n            boolean testTransients) {\n        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null,\n                null);\n    }\n\n    /**\n     * Calls {@link #reflectionHashCode(int, int, Object, boolean, Class, String[])} with excludeFields set to\n     * <code>null</code>.\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param testTransients\n     *            whether to include transient fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return int hash code\n     */\n    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n            boolean testTransients, Class<? super T> reflectUpToClass) {\n        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients,\n                reflectUpToClass, null);\n    }\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be included. Superclass fields will be included up to and including the specified\n     * superclass. A null superclass is treated as java.lang.Object.\n     * </p>\n     * \n     * <p>\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n     * </p>\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param testTransients\n     *            whether to include transient fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @param excludeFields\n     *            array of field names to exclude from use in calculation of hash code\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the number is zero or even\n     * @since 2.0\n     */\n    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n            boolean testTransients, Class<? super T> reflectUpToClass, String[] excludeFields) {\n\n        if (object == null) {\n            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n        }\n        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n        Class<?> clazz = object.getClass();\n        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n            clazz = clazz.getSuperclass();\n            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        }\n        return builder.toHashCode();\n    }\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n     * <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the object is <code>null</code>\n     */\n    public static int reflectionHashCode(Object object) {\n        return reflectionHashCode(17, 37, object, false, null, null);\n    }\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <P>\n     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param testTransients\n     *            whether to include transient fields\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the object is <code>null</code>\n     */\n    public static int reflectionHashCode(Object object, boolean testTransients) {\n        return reflectionHashCode(17, 37, object, testTransients, null, null);\n    }\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n     * <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param excludeFields\n     *            Collection of String field names to exclude from use in calculation of hash code\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the object is <code>null</code>\n     */\n    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\n        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n    }\n\n    // -------------------------------------------------------------------------\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n     * <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param excludeFields\n     *            array of field names to exclude from use in calculation of hash code\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the object is <code>null</code>\n     */\n    public static int reflectionHashCode(Object object, String[] excludeFields) {\n        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n    }\n\n    /**\n     * <p>\n     * Registers the given object. Used by the reflection methods to avoid infinite loops.\n     * </p>\n     * \n     * @param value\n     *            The object to register.\n     */\n    static void register(Object value) {\n        getRegistry().add(new IDKey(value));\n    }\n\n    /**\n     * <p>\n     * Unregisters the given object.\n     * </p>\n     * \n     * <p>\n     * Used by the reflection methods to avoid infinite loops.\n     * \n     * @param value\n     *            The object to unregister.\n     * @since 2.3\n     */\n    static void unregister(Object value) {\n        getRegistry().remove(new IDKey(value));\n    }\n\n    /**\n     * Constant to use in building the hashCode.\n     */\n    private final int iConstant;\n\n    /**\n     * Running total of the hashCode.\n     */\n    private int iTotal = 0;\n\n    /**\n     * <p>\n     * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\n     * </p>\n     */\n    public HashCodeBuilder() {\n        iConstant = 37;\n        iTotal = 17;\n    }\n\n    /**\n     * <p>\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n     * however this is not vital.\n     * </p>\n     * \n     * <p>\n     * Prime numbers are preferred, especially for the multiplier.\n     * </p>\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @throws IllegalArgumentException\n     *             if the number is zero or even\n     */\n    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n        if (initialNonZeroOddNumber == 0) {\n            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n        }\n        if (initialNonZeroOddNumber % 2 == 0) {\n            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n        }\n        if (multiplierNonZeroOddNumber == 0) {\n            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n        }\n        if (multiplierNonZeroOddNumber % 2 == 0) {\n            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n        }\n        iConstant = multiplierNonZeroOddNumber;\n        iTotal = initialNonZeroOddNumber;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>boolean</code>.\n     * </p>\n     * <p>\n     * This adds <code>iConstant * 1</code> to the <code>hashCode</code> and not a <code>1231</code> or\n     * <code>1237</code> as done in java.lang.Boolean. This is in accordance with the <quote>Effective Java</quote>\n     * design.\n     * </p>\n     * \n     * @param value\n     *            the boolean to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(boolean value) {\n        iTotal = iTotal * iConstant + (value ? 0 : 1);\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>boolean</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(boolean[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>byte</code>.\n     * </p>\n     * \n     * @param value\n     *            the byte to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(byte value) {\n        iTotal = iTotal * iConstant + value;\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>byte</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(byte[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>char</code>.\n     * </p>\n     * \n     * @param value\n     *            the char to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(char value) {\n        iTotal = iTotal * iConstant + value;\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>char</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(char[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>double</code>.\n     * </p>\n     * \n     * @param value\n     *            the double to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(double value) {\n        return append(Double.doubleToLongBits(value));\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>double</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(double[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>float</code>.\n     * </p>\n     * \n     * @param value\n     *            the float to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(float value) {\n        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>float</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(float[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for an <code>int</code>.\n     * </p>\n     * \n     * @param value\n     *            the int to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(int value) {\n        iTotal = iTotal * iConstant + value;\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for an <code>int</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(int[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>long</code>.\n     * </p>\n     * \n     * @param value\n     *            the long to add to the <code>hashCode</code>\n     * @return this\n     */\n    // NOTE: This method uses >> and not >>> as Effective Java and \n    //       Long.hashCode do. Ideally we should switch to >>> at \n    //       some stage. There are backwards compat issues, so \n    //       that will have to wait for the time being. cf LANG-342.\n    public HashCodeBuilder append(long value) {\n        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>long</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(long[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for an <code>Object</code>.\n     * </p>\n     * \n     * @param object\n     *            the Object to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(Object object) {\n        if (object == null) {\n            iTotal = iTotal * iConstant;\n\n        } else {\n            if(object.getClass().isArray()) {\n                // 'Switch' on type of array, to dispatch to the correct handler\n                // This handles multi dimensional arrays\n                if (object instanceof long[]) {\n                    append((long[]) object);\n                } else if (object instanceof int[]) {\n                    append((int[]) object);\n                } else if (object instanceof short[]) {\n                    append((short[]) object);\n                } else if (object instanceof char[]) {\n                    append((char[]) object);\n                } else if (object instanceof byte[]) {\n                    append((byte[]) object);\n                } else if (object instanceof double[]) {\n                    append((double[]) object);\n                } else if (object instanceof float[]) {\n                    append((float[]) object);\n                } else if (object instanceof boolean[]) {\n                    append((boolean[]) object);\n                } else {\n                    // Not an array of primitives\n                    append((Object[]) object);\n                }\n            } else {\n                iTotal = iTotal * iConstant + object.hashCode();\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(Object[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>short</code>.\n     * </p>\n     * \n     * @param value\n     *            the short to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(short value) {\n        iTotal = iTotal * iConstant + value;\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>short</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(short[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Adds the result of super.hashCode() to this builder.\n     * </p>\n     * \n     * @param superHashCode\n     *            the result of calling <code>super.hashCode()</code>\n     * @return this HashCodeBuilder, used to chain calls.\n     * @since 2.0\n     */\n    public HashCodeBuilder appendSuper(int superHashCode) {\n        iTotal = iTotal * iConstant + superHashCode;\n        return this;\n    }\n\n    /**\n     * <p>\n     * Return the computed <code>hashCode</code>.\n     * </p>\n     * \n     * @return <code>hashCode</code> based on the fields appended\n     */\n    public int toHashCode() {\n        return iTotal;\n    }\n\n    /**\n     * <p>\n     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelyhood \n     * of bugs in mis-calling toHashCode() and the unlikelyness of it mattering what the hashCode for \n     * HashCodeBuilder itself is.\n     * \n     * @return <code>hashCode</code> based on the fields appended\n     */\n    @Override\n    public int hashCode() {\n        return toHashCode();\n    }\n\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"code\": \"java.lang.NoSuchMethodException: java.lang.Class.getDecla\",\n         \"message\": \"Method 'getDecla' not found in class 'java.lang.Class'\",\n         \"location\": \"HashCodeBuilder.java:247\"\n      },\n      {\n         \"code\": \"java.lang.IllegalAccessException: Class 'org.apache.commons.lang3.builder.HashCodeBuilder' cannot access a member of class 'java.lang.Object' with modifiers 'private'\",\n         \"message\": \"Cannot access field 'field' (java.lang.reflect.Field) from class 'java.lang.Object'\",\n         \"location\": \"HashCodeBuilder.java:261\"\n      },\n      {\n         \"code\": \"java.lang.SecurityException: AccessControlContext not granted\",\n         \"message\": \"Access to field 'field' (java.lang.reflect.Field) denied due to security constraints\",\n         \"location\": \"HashCodeBuilder.java:275\"\n      }\n   ]\n}"}}