{
  "source_item_id": 137088,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:31:21.940450",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.action.fieldcaps;\n\nimport org.elasticsearch.action.ActionResponse;\nimport org.elasticsearch.common.Strings;\nimport org.elasticsearch.common.collect.Iterators;\nimport org.elasticsearch.common.io.stream.StreamInput;\nimport org.elasticsearch.common.io.stream.StreamOutput;\nimport org.elasticsearch.common.xcontent.ChunkedToXContentObject;\nimport org.elasticsearch.xcontent.ParseField;\nimport org.elasticsearch.xcontent.ToXContent;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * Response for {@link FieldCapabilitiesRequest} requests.\n */\npublic class FieldCapabilitiesResponse extends ActionResponse implements ChunkedToXContentObject {\n    public static final ParseField INDICES_FIELD = new ParseField(\"indices\");\n    public static final ParseField FIELDS_FIELD = new ParseField(\"fields\");\n    private static final ParseField FAILED_INDICES_FIELD = new ParseField(\"failed_indices\");\n    public static final ParseField FAILURES_FIELD = new ParseField(\"failures\");\n\n    private final String[] indices;\n    private final Map<String, Map<String, FieldCapabilities>> fields;\n    private final List<FieldCapabilitiesFailure> failures;\n    private final List<FieldCapabilitiesIndexResponse> indexResponses;\n\n    public FieldCapabilitiesResponse(\n        String[] indices,\n        Map<String, Map<String, FieldCapabilities>> fields,\n        List<FieldCapabilitiesFailure> failures\n    ) {\n        this(indices, fields, Collections.emptyList(), failures);\n    }\n\n    public FieldCapabilitiesResponse(String[] indices, Map<String, Map<String, FieldCapabilities>> fields) {\n        this(indices, fields, Collections.emptyList(), Collections.emptyList());\n    }\n\n    public FieldCapabilitiesResponse(List<FieldCapabilitiesIndexResponse> indexResponses, List<FieldCapabilitiesFailure> failures) {\n        this(Strings.EMPTY_ARRAY, Collections.emptyMap(), indexResponses, failures);\n    }\n\n    private FieldCapabilitiesResponse(\n        String[] indices,\n        Map<String, Map<String, FieldCapabilities>> fields,\n        List<FieldCapabilitiesIndexResponse> indexResponses,\n        List<FieldCapabilitiesFailure> failures\n    ) {\n        this.fields = Objects.requireNonNull(fields);\n        this.indexResponses = Objects.requireNonNull(indexResponses);\n        this.indices = indices;\n        this.failures = failures;\n    }\n\n    public FieldCapabilitiesResponse(StreamInput in) throws IOException {\n        this.indices = in.readStringArray();\n        this.fields = in.readMap(FieldCapabilitiesResponse::readField);\n        this.indexResponses = FieldCapabilitiesIndexResponse.readList(in);\n        this.failures = in.readCollectionAsList(FieldCapabilitiesFailure::new);\n    }\n\n    /**\n     * Get the concrete list of indices that were requested and returned a response.\n     */\n    public String[] getIndices() {\n        return indices;\n    }\n\n    /**\n     * Get the concrete list of indices that failed\n     */\n    public int getFailedIndicesCount() {\n        int count = 0;\n        for (FieldCapabilitiesFailure fieldCapabilitiesFailure : this.failures) {\n            int length = fieldCapabilitiesFailure.getIndices().length;\n            count += length;\n        }\n        return count;\n    }\n\n    /**\n     * Get the field capabilities map.\n     */\n    public Map<String, Map<String, FieldCapabilities>> get() {\n        return fields;\n    }\n\n    /**\n     * Get possible request failures keyed by index name\n     */\n    public List<FieldCapabilitiesFailure> getFailures() {\n        return failures;\n    }\n\n    /**\n     * Returns the actual per-index field caps responses\n     */\n    public List<FieldCapabilitiesIndexResponse> getIndexResponses() {\n        return indexResponses;\n    }\n\n    /**\n     *\n     * Get the field capabilities per type for the provided {@code field}.\n     */\n    public Map<String, FieldCapabilities> getField(String field) {\n        return fields.get(field);\n    }\n\n    /**\n     * Returns <code>true</code> if the provided field is a metadata field.\n     */\n    public boolean isMetadataField(String field) {\n        Map<String, FieldCapabilities> caps = getField(field);\n        if (caps == null) {\n            return false;\n        }\n        return caps.values().stream().anyMatch(FieldCapabilities::isMetadataField);\n    }\n\n    private static Map<String, FieldCapabilities> readField(StreamInput in) throws IOException {\n        return in.readMap(FieldCapabilities::new);\n    }\n\n    @Override\n    public void writeTo(StreamOutput out) throws IOException {\n        out.writeStringArray(indices);\n        out.writeMap(fields, FieldCapabilitiesResponse::writeField);\n        FieldCapabilitiesIndexResponse.writeList(out, indexResponses);\n        out.writeCollection(failures);\n    }\n\n    private static void writeField(StreamOutput out, Map<String, FieldCapabilities> map) throws IOException {\n        out.writeMap(map, StreamOutput::writeWriteable);\n    }\n\n    @Override\n    public Iterator<? extends ToXContent> toXContentChunked(ToXContent.Params params) {\n        if (indexResponses.size() > 0) {\n            throw new IllegalStateException(\"cannot serialize non-merged response\");\n        }\n\n        return Iterators.concat(\n            Iterators.single(\n                (b, p) -> b.startObject().array(INDICES_FIELD.getPreferredName(), indices).startObject(FIELDS_FIELD.getPreferredName())\n            ),\n            Iterators.map(fields.entrySet().iterator(), r -> (b, p) -> b.xContentValuesMap(r.getKey(), r.getValue())),\n            this.failures.size() > 0\n                ? Iterators.concat(\n                    Iterators.single(\n                        (ToXContent) (b, p) -> b.endObject()\n                            .field(FAILED_INDICES_FIELD.getPreferredName(), getFailedIndicesCount())\n                            .field(FAILURES_FIELD.getPreferredName())\n                            .startArray()\n                    ),\n                    failures.iterator(),\n                    Iterators.single((b, p) -> b.endArray().endObject())\n                )\n                : Iterators.single((b, p) -> b.endObject().endObject())\n        );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        FieldCapabilitiesResponse that = (FieldCapabilitiesResponse) o;\n        return Arrays.equals(indices, that.indices)\n            && Objects.equals(fields, that.fields)\n            && Objects.equals(indexResponses, that.indexResponses)\n            && Objects.equals(failures, that.failures);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = Objects.hash(fields, indexResponses, failures);\n        result = 31 * result + Arrays.hashCode(indices);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        if (indexResponses.size() > 0) {\n            return \"FieldCapabilitiesResponse{unmerged}\";\n        }\n        return Strings.toString(this);\n    }\n}\n",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The FieldCapabilitiesResponse class has multiple constructors with different parameters. This can lead to confusion and bugs when creating instances of the class. Consider removing the constructors with fewer parameters and using the constructor with the most parameters instead.\",\n         \"suggested_fix\": \"Remove the constructors with fewer parameters and use the constructor with the most parameters instead.\\npublic FieldCapabilitiesResponse(String[] indices, Map<String, Map<String, FieldCapabilities>> fields, List<FieldCapabilitiesIndexResponse> indexResponses, List<FieldCapabilitiesFailure> failures) {\\n    this.fields = Objects.requireNonNull(fields);\\n    this.indexResponses = Objects.requireNonNull(indexResponses);\\n    this.indices = indices;\\n    this.failures = failures;\\n}\"\n      },\n      {\n         \"explanation\": \"The FieldCapabilitiesResponse class has a method getFailedIndicesCount() that iterates over the failures list to count the number of failed indices. This can be optimized by using a single loop to count the total number of failed indices.\",\n         \"suggested_fix\": \"Optimize the getFailedIndicesCount() method to use a single loop to count the total number of failed indices.\\npublic int getFailedIndicesCount() {\\n    int count = 0;\\n    for (FieldCapabilitiesFailure fieldCapabilitiesFailure : this.failures) {\\n        count += fieldCapabilitiesFailure.getIndices().length;\\n    }\\n    return count;\\n}\"\n      },\n      {\n         \"explanation\": \"The FieldCapabilitiesResponse class has a method toXContentChunked() that throws an IllegalStateException if the indexResponses list is not empty. However, this method is not used in the provided code snippet. Consider removing this method or using it correctly.\",\n         \"suggested_fix\": \"Remove the toXContentChunked() method or use it correctly.\\n@Override\\npublic Iterator<? extends ToXContent> toXContentChunked(ToXContent.Params params) {\\n    // ...\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs found in the provided code snippet.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The FieldCapabilitiesResponse class has multiple constructors with different parameters. This can lead to confusion and bugs when creating instances of the class. Consider removing the constructors with fewer parameters and using the constructor with the most parameters instead.",
        "suggested_fix": "Remove the constructors with fewer parameters and use the constructor with the most parameters instead.\npublic FieldCapabilitiesResponse(String[] indices, Map<String, Map<String, FieldCapabilities>> fields, List<FieldCapabilitiesIndexResponse> indexResponses, List<FieldCapabilitiesFailure> failures) {\n    this.fields = Objects.requireNonNull(fields);\n    this.indexResponses = Objects.requireNonNull(indexResponses);\n    this.indices = indices;\n    this.failures = failures;\n}"
      },
      {
        "explanation": "The FieldCapabilitiesResponse class has a method getFailedIndicesCount() that iterates over the failures list to count the number of failed indices. This can be optimized by using a single loop to count the total number of failed indices.",
        "suggested_fix": "Optimize the getFailedIndicesCount() method to use a single loop to count the total number of failed indices.\npublic int getFailedIndicesCount() {\n    int count = 0;\n    for (FieldCapabilitiesFailure fieldCapabilitiesFailure : this.failures) {\n        count += fieldCapabilitiesFailure.getIndices().length;\n    }\n    return count;\n}"
      },
      {
        "explanation": "The FieldCapabilitiesResponse class has a method toXContentChunked() that throws an IllegalStateException if the indexResponses list is not empty. However, this method is not used in the provided code snippet. Consider removing this method or using it correctly.",
        "suggested_fix": "Remove the toXContentChunked() method or use it correctly.\n@Override\npublic Iterator<? extends ToXContent> toXContentChunked(ToXContent.Params params) {\n    // ..."
      }
    ],
    "no_bugs_reasoning": "No bugs found in the provided code snippet."
  },
  "error": null
}