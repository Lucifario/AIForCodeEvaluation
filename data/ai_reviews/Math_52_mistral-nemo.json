{"sample_id": "Math_52", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.geometry.euclidean.threed;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.util.FastMath;\n\n/**\n * This class implements rotations in a three-dimensional space.\n *\n * <p>Rotations can be represented by several different mathematical\n * entities (matrices, axe and angle, Cardan or Euler angles,\n * quaternions). This class presents an higher level abstraction, more\n * user-oriented and hiding this implementation details. Well, for the\n * curious, we use quaternions for the internal representation. The\n * user can build a rotation from any of these representations, and\n * any of these representations can be retrieved from a\n * <code>Rotation</code> instance (see the various constructors and\n * getters). In addition, a rotation can also be built implicitly\n * from a set of vectors and their image.</p>\n * <p>This implies that this class can be used to convert from one\n * representation to another one. For example, converting a rotation\n * matrix into a set of Cardan angles from can be done using the\n * following single line of code:</p>\n * <pre>\n * double[] angles = new Rotation(matrix, 1.0e-10).getAngles(RotationOrder.XYZ);\n * </pre>\n * <p>Focus is oriented on what a rotation <em>do</em> rather than on its\n * underlying representation. Once it has been built, and regardless of its\n * internal representation, a rotation is an <em>operator</em> which basically\n * transforms three dimensional {@link Vector3D vectors} into other three\n * dimensional {@link Vector3D vectors}. Depending on the application, the\n * meaning of these vectors may vary and the semantics of the rotation also.</p>\n * <p>For example in an spacecraft attitude simulation tool, users will often\n * consider the vectors are fixed (say the Earth direction for example) and the\n * frames change. The rotation transforms the coordinates of the vector in inertial\n * frame into the coordinates of the same vector in satellite frame. In this\n * case, the rotation implicitly defines the relation between the two frames.</p>\n * <p>Another example could be a telescope control application, where the rotation\n * would transform the sighting direction at rest into the desired observing\n * direction when the telescope is pointed towards an object of interest. In this\n * case the rotation transforms the direction at rest in a topocentric frame\n * into the sighting direction in the same topocentric frame. This implies in this\n * case the frame is fixed and the vector moves.</p>\n * <p>In many case, both approaches will be combined. In our telescope example,\n * we will probably also need to transform the observing direction in the topocentric\n * frame into the observing direction in inertial frame taking into account the observatory\n * location and the Earth rotation, which would essentially be an application of the\n * first approach.</p>\n *\n * <p>These examples show that a rotation is what the user wants it to be. This\n * class does not push the user towards one specific definition and hence does not\n * provide methods like <code>projectVectorIntoDestinationFrame</code> or\n * <code>computeTransformedDirection</code>. It provides simpler and more generic\n * methods: {@link #applyTo(Vector3D) applyTo(Vector3D)} and {@link\n * #applyInverseTo(Vector3D) applyInverseTo(Vector3D)}.</p>\n *\n * <p>Since a rotation is basically a vectorial operator, several rotations can be\n * composed together and the composite operation <code>r = r<sub>1</sub> o\n * r<sub>2</sub></code> (which means that for each vector <code>u</code>,\n * <code>r(u) = r<sub>1</sub>(r<sub>2</sub>(u))</code>) is also a rotation. Hence\n * we can consider that in addition to vectors, a rotation can be applied to other\n * rotations as well (or to itself). With our previous notations, we would say we\n * can apply <code>r<sub>1</sub></code> to <code>r<sub>2</sub></code> and the result\n * we get is <code>r = r<sub>1</sub> o r<sub>2</sub></code>. For this purpose, the\n * class provides the methods: {@link #applyTo(Rotation) applyTo(Rotation)} and\n * {@link #applyInverseTo(Rotation) applyInverseTo(Rotation)}.</p>\n *\n * <p>Rotations are guaranteed to be immutable objects.</p>\n *\n * @version $Id$\n * @see Vector3D\n * @see RotationOrder\n * @since 1.2\n */\n\npublic class Rotation implements Serializable {\n\n  /** Identity rotation. */\n  public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);\n\n  /** Serializable version identifier */\n  private static final long serialVersionUID = -2153622329907944313L;\n\n  /** Scalar coordinate of the quaternion. */\n  private final double q0;\n\n  /** First coordinate of the vectorial part of the quaternion. */\n  private final double q1;\n\n  /** Second coordinate of the vectorial part of the quaternion. */\n  private final double q2;\n\n  /** Third coordinate of the vectorial part of the quaternion. */\n  private final double q3;\n\n  /** Build a rotation from the quaternion coordinates.\n   * <p>A rotation can be built from a <em>normalized</em> quaternion,\n   * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n   * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n   * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n   * the constructor can normalize it in a preprocessing step.</p>\n   * <p>Note that some conventions put the scalar part of the quaternion\n   * as the 4<sup>th</sup> component and the vector part as the first three\n   * components. This is <em>not</em> our convention. We put the scalar part\n   * as the first component.</p>\n   * @param q0 scalar part of the quaternion\n   * @param q1 first coordinate of the vectorial part of the quaternion\n   * @param q2 second coordinate of the vectorial part of the quaternion\n   * @param q3 third coordinate of the vectorial part of the quaternion\n   * @param needsNormalization if true, the coordinates are considered\n   * not to be normalized, a normalization preprocessing step is performed\n   * before using them\n   */\n  public Rotation(double q0, double q1, double q2, double q3,\n                  boolean needsNormalization) {\n\n    if (needsNormalization) {\n      // normalization preprocessing\n      double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n      q0 *= inv;\n      q1 *= inv;\n      q2 *= inv;\n      q3 *= inv;\n    }\n\n    this.q0 = q0;\n    this.q1 = q1;\n    this.q2 = q2;\n    this.q3 = q3;\n\n  }\n\n  /** Build a rotation from an axis and an angle.\n   * <p>We use the convention that angles are oriented according to\n   * the effect of the rotation on vectors around the axis. That means\n   * that if (i, j, k) is a direct frame and if we first provide +k as\n   * the axis and &pi;/2 as the angle to this constructor, and then\n   * {@link #applyTo(Vector3D) apply} the instance to +i, we will get\n   * +j.</p>\n   * <p>Another way to represent our convention is to say that a rotation\n   * of angle &theta; about the unit vector (x, y, z) is the same as the\n   * rotation build from quaternion components { cos(-&theta;/2),\n   * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n   * Note the minus sign on the angle!</p>\n   * <p>On the one hand this convention is consistent with a vectorial\n   * perspective (moving vectors in fixed frames), on the other hand it\n   * is different from conventions with a frame perspective (fixed vectors\n   * viewed from different frames) like the ones used for example in spacecraft\n   * attitude community or in the graphics community.</p>\n   * @param axis axis around which to rotate\n   * @param angle rotation angle.\n   * @exception ArithmeticException if the axis norm is zero\n   */\n  public Rotation(Vector3D axis, double angle) {\n\n    double norm = axis.getNorm();\n    if (norm == 0) {\n      throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n\n    double halfAngle = -0.5 * angle;\n    double coeff = FastMath.sin(halfAngle) / norm;\n\n    q0 = FastMath.cos (halfAngle);\n    q1 = coeff * axis.getX();\n    q2 = coeff * axis.getY();\n    q3 = coeff * axis.getZ();\n\n  }\n\n  /** Build a rotation from a 3X3 matrix.\n\n   * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n   * (which are matrices for which m.m<sup>T</sup> = I) with real\n   * coefficients. The module of the determinant of unit matrices is\n   * 1, among the orthogonal 3X3 matrices, only the ones having a\n   * positive determinant (+1) are rotation matrices.</p>\n\n   * <p>When a rotation is defined by a matrix with truncated values\n   * (typically when it is extracted from a technical sheet where only\n   * four to five significant digits are available), the matrix is not\n   * orthogonal anymore. This constructor handles this case\n   * transparently by using a copy of the given matrix and applying a\n   * correction to the copy in order to perfect its orthogonality. If\n   * the Frobenius norm of the correction needed is above the given\n   * threshold, then the matrix is considered to be too far from a\n   * true rotation matrix and an exception is thrown.<p>\n\n   * @param m rotation matrix\n   * @param threshold convergence threshold for the iterative\n   * orthogonality correction (convergence is reached when the\n   * difference between two steps of the Frobenius norm of the\n   * correction is below this threshold)\n\n   * @exception NotARotationMatrixException if the matrix is not a 3X3\n   * matrix, or if it cannot be transformed into an orthogonal matrix\n   * with the given threshold, or if the determinant of the resulting\n   * orthogonal matrix is negative\n\n   */\n  public Rotation(double[][] m, double threshold)\n    throws NotARotationMatrixException {\n\n    // dimension check\n    if ((m.length != 3) || (m[0].length != 3) ||\n        (m[1].length != 3) || (m[2].length != 3)) {\n      throw new NotARotationMatrixException(\n              LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n              m.length, m[0].length);\n    }\n\n    // compute a \"close\" orthogonal matrix\n    double[][] ort = orthogonalizeMatrix(m, threshold);\n\n    // check the sign of the determinant\n    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) -\n                 ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) +\n                 ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);\n    if (det < 0.0) {\n      throw new NotARotationMatrixException(\n              LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n              det);\n    }\n\n    // There are different ways to compute the quaternions elements\n    // from the matrix. They all involve computing one element from\n    // the diagonal of the matrix, and computing the three other ones\n    // using a formula involving a division by the first element,\n    // which unfortunately can be zero. Since the norm of the\n    // quaternion is 1, we know at least one element has an absolute\n    // value greater or equal to 0.5, so it is always possible to\n    // select the right formula and avoid division by zero and even\n    // numerical inaccuracy. Checking the elements in turn and using\n    // the first one greater than 0.45 is safe (this leads to a simple\n    // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n    double s = ort[0][0] + ort[1][1] + ort[2][2];\n    if (s > -0.19) {\n      // compute q0 and deduce q1, q2 and q3\n      q0 = 0.5 * FastMath.sqrt(s + 1.0);\n      double inv = 0.25 / q0;\n      q1 = inv * (ort[1][2] - ort[2][1]);\n      q2 = inv * (ort[2][0] - ort[0][2]);\n      q3 = inv * (ort[0][1] - ort[1][0]);\n    } else {\n      s = ort[0][0] - ort[1][1] - ort[2][2];\n      if (s > -0.19) {\n        // compute q1 and deduce q0, q2 and q3\n        q1 = 0.5 * FastMath.sqrt(s + 1.0);\n        double inv = 0.25 / q1;\n        q0 = inv * (ort[1][2] - ort[2][1]);\n        q2 = inv * (ort[0][1] + ort[1][0]);\n        q3 = inv * (ort[0][2] + ort[2][0]);\n      } else {\n        s = ort[1][1] - ort[0][0] - ort[2][2];\n        if (s > -0.19) {\n          // compute q2 and deduce q0, q1 and q3\n          q2 = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / q2;\n          q0 = inv * (ort[2][0] - ort[0][2]);\n          q1 = inv * (ort[0][1] + ort[1][0]);\n          q3 = inv * (ort[2][1] + ort[1][2]);\n        } else {\n          // compute q3 and deduce q0, q1 and q2\n          s = ort[2][2] - ort[0][0] - ort[1][1];\n          q3 = 0.5 * FastMath.sqrt(s + 1.0);\n          double inv = 0.25 / q3;\n          q0 = inv * (ort[0][1] - ort[1][0]);\n          q1 = inv * (ort[0][2] + ort[2][0]);\n          q2 = inv * (ort[2][1] + ort[1][2]);\n        }\n      }\n    }\n\n  }\n\n  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n  // norms computation\n  double u1u1 = u1.getNormSq();\n  double u2u2 = u2.getNormSq();\n  double v1v1 = v1.getNormSq();\n  double v2v2 = v2.getNormSq();\n  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n  }\n\n  // normalize v1 in order to have (v1'|v1') = (u1|u1)\n  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n  double u1u2   = u1.dotProduct(u2);\n  double v1v2   = v1.dotProduct(v2);\n  double coeffU = u1u2 / u1u1;\n  double coeffV = v1v2 / u1u1;\n  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n  double alpha  = coeffU - beta * coeffV;\n  v2 = new Vector3D(alpha, v1, beta, v2);\n\n  // preliminary computation\n  Vector3D uRef  = u1;\n  Vector3D vRef  = v1;\n  Vector3D v1Su1 = v1.subtract(u1);\n  Vector3D v2Su2 = v2.subtract(u2);\n  Vector3D k     = v1Su1.crossProduct(v2Su2);\n  Vector3D u3    = u1.crossProduct(u2);\n  double c       = k.dotProduct(u3);\n  if (c == 0) {\n    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n    // we try other vectors\n    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n    Vector3D v3Su3 = v3.subtract(u3);\n    k = v1Su1.crossProduct(v3Su3);\n    Vector3D u2Prime = u1.crossProduct(u3);\n    c = k.dotProduct(u2Prime);\n\n    if (c == 0) {\n      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n      k = v2Su2.crossProduct(v3Su3);;\n      c = k.dotProduct(u2.crossProduct(u3));;\n\n      if (c == 0) {\n        // the (q1, q2, q3) vector is aligned with everything\n        // this is really the identity rotation\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n        return;\n      }\n\n      // we will have to use u2 and v2 to compute the scalar part\n      uRef = u2;\n      vRef = v2;\n\n    }\n\n  }\n\n  // compute the vectorial part\n  c = FastMath.sqrt(c);\n  double inv = 1.0 / (c + c);\n  q1 = inv * k.getX();\n  q2 = inv * k.getY();\n  q3 = inv * k.getZ();\n\n  // compute the scalar part\n   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n                    uRef.getZ() * q1 - uRef.getX() * q3,\n                    uRef.getX() * q2 - uRef.getY() * q1);\n  q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n\n  }\n\n  /** Build one of the rotations that transform one vector into another one.\n\n   * <p>Except for a possible scale factor, if the instance were\n   * applied to the vector u it will produce the vector v. There is an\n   * infinite number of such rotations, this constructor choose the\n   * one with the smallest associated angle (i.e. the one whose axis\n   * is orthogonal to the (u, v) plane). If u and v are colinear, an\n   * arbitrary rotation axis is chosen.</p>\n\n   * @param u origin vector\n   * @param v desired image of u by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u, Vector3D v) {\n\n    double normProduct = u.getNorm() * v.getNorm();\n    if (normProduct == 0) {\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    double dot = u.dotProduct(v);\n\n    if (dot < ((2.0e-15 - 1.0) * normProduct)) {\n      // special case u = -v: we select a PI angle rotation around\n      // an arbitrary vector orthogonal to u\n      Vector3D w = u.orthogonal();\n      q0 = 0.0;\n      q1 = -w.getX();\n      q2 = -w.getY();\n      q3 = -w.getZ();\n    } else {\n      // general case: (u, v) defines a plane, we select\n      // the shortest possible rotation: axis orthogonal to this plane\n      q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));\n      double coeff = 1.0 / (2.0 * q0 * normProduct);\n      Vector3D q = v.crossProduct(u);\n      q1 = coeff * q.getX();\n      q2 = coeff * q.getY();\n      q3 = coeff * q.getZ();\n    }\n\n  }\n\n  /** Build a rotation from three Cardan or Euler elementary rotations.\n\n   * <p>Cardan rotations are three successive rotations around the\n   * canonical axes X, Y and Z, each axis being used once. There are\n   * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n   * rotations are three successive rotations around the canonical\n   * axes X, Y and Z, the first and last rotations being around the\n   * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n   * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n   * <p>Beware that many people routinely use the term Euler angles even\n   * for what really are Cardan angles (this confusion is especially\n   * widespread in the aerospace business where Roll, Pitch and Yaw angles\n   * are often wrongly tagged as Euler angles).</p>\n\n   * @param order order of rotations to use\n   * @param alpha1 angle of the first elementary rotation\n   * @param alpha2 angle of the second elementary rotation\n   * @param alpha3 angle of the third elementary rotation\n   */\n  public Rotation(RotationOrder order,\n                  double alpha1, double alpha2, double alpha3) {\n    Rotation r1 = new Rotation(order.getA1(), alpha1);\n    Rotation r2 = new Rotation(order.getA2(), alpha2);\n    Rotation r3 = new Rotation(order.getA3(), alpha3);\n    Rotation composed = r1.applyTo(r2.applyTo(r3));\n    q0 = composed.q0;\n    q1 = composed.q1;\n    q2 = composed.q2;\n    q3 = composed.q3;\n  }\n\n  /** Revert a rotation.\n   * Build a rotation which reverse the effect of another\n   * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n   * instance is not changed.\n   * @return a new rotation whose effect is the reverse of the effect\n   * of the instance\n   */\n  public Rotation revert() {\n    return new Rotation(-q0, q1, q2, q3, false);\n  }\n\n  /** Get the scalar coordinate of the quaternion.\n   * @return scalar coordinate of the quaternion\n   */\n  public double getQ0() {\n    return q0;\n  }\n\n  /** Get the first coordinate of the vectorial part of the quaternion.\n   * @return first coordinate of the vectorial part of the quaternion\n   */\n  public double getQ1() {\n    return q1;\n  }\n\n  /** Get the second coordinate of the vectorial part of the quaternion.\n   * @return second coordinate of the vectorial part of the quaternion\n   */\n  public double getQ2() {\n    return q2;\n  }\n\n  /** Get the third coordinate of the vectorial part of the quaternion.\n   * @return third coordinate of the vectorial part of the quaternion\n   */\n  public double getQ3() {\n    return q3;\n  }\n\n  /** Get the normalized axis of the rotation.\n   * @return normalized axis of the rotation\n   * @see #Rotation(Vector3D, double)\n   */\n  public Vector3D getAxis() {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n      return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n      double inverse = 1 / FastMath.sqrt(squaredSine);\n      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n    }\n    double inverse = -1 / FastMath.sqrt(squaredSine);\n    return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n  }\n\n  /** Get the angle of the rotation.\n   * @return angle of the rotation (between 0 and &pi;)\n   * @see #Rotation(Vector3D, double)\n   */\n  public double getAngle() {\n    if ((q0 < -0.1) || (q0 > 0.1)) {\n      return 2 * FastMath.asin(FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3));\n    } else if (q0 < 0) {\n      return 2 * FastMath.acos(-q0);\n    }\n    return 2 * FastMath.acos(q0);\n  }\n\n  /** Get the Cardan or Euler angles corresponding to the instance.\n\n   * <p>The equations show that each rotation can be defined by two\n   * different values of the Cardan or Euler angles set. For example\n   * if Cardan angles are used, the rotation defined by the angles\n   * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n   * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n   * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n   * the following arbitrary choices:</p>\n   * <ul>\n   *   <li>for Cardan angles, the chosen set is the one for which the\n   *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n   *   positive),</li>\n   *   <li>for Euler angles, the chosen set is the one for which the\n   *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n   * </ul>\n\n   * <p>Cardan and Euler angle have a very disappointing drawback: all\n   * of them have singularities. This means that if the instance is\n   * too close to the singularities corresponding to the given\n   * rotation order, it will be impossible to retrieve the angles. For\n   * Cardan angles, this is often called gimbal lock. There is\n   * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n   * with Cardan and Euler representation (but not a problem with the\n   * rotation itself, which is perfectly well defined). For Cardan\n   * angles, singularities occur when the second angle is close to\n   * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n   * second angle is close to 0 or &pi;, this implies that the identity\n   * rotation is always singular for Euler angles!</p>\n\n   * @param order rotation order to use\n   * @return an array of three angles, in the order specified by the set\n   * @exception CardanEulerSingularityException if the rotation is\n   * singular with respect to the angles set specified\n   */\n  public double[] getAngles(RotationOrder order)\n    throws CardanEulerSingularityException {\n\n    if (order == RotationOrder.XYZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getY()), v1.getZ()),\n        FastMath.asin(v2.getZ()),\n        FastMath.atan2(-(v2.getY()), v2.getX())\n      };\n\n    } else if (order == RotationOrder.XZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n       -FastMath.asin(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.YXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n       -FastMath.asin(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else if (order == RotationOrder.YZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getZ()), v1.getX()),\n        FastMath.asin(v2.getX()),\n        FastMath.atan2(-(v2.getZ()), v2.getY())\n      };\n\n    } else if (order == RotationOrder.ZXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(-(v1.getX()), v1.getY()),\n        FastMath.asin(v2.getY()),\n        FastMath.atan2(-(v2.getX()), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.ZYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(true);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n       -FastMath.asin(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XYX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), -v1.getZ()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getY(), v2.getZ())\n      };\n\n    } else if (order == RotationOrder.XZX) {\n\n      // r (Vector3D.plusI) coordinates are :\n      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n      // (-r) (Vector3D.plusI) coordinates are :\n      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), v1.getY()),\n        FastMath.acos(v2.getX()),\n        FastMath.atan2(v2.getZ(), -v2.getY())\n      };\n\n    } else if (order == RotationOrder.YXY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), v1.getZ()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getX(), -v2.getZ())\n      };\n\n    } else if (order == RotationOrder.YZY) {\n\n      // r (Vector3D.plusJ) coordinates are :\n      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n      // (-r) (Vector3D.plusJ) coordinates are :\n      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n      // and we can choose to have psi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getZ(), -v1.getX()),\n        FastMath.acos(v2.getY()),\n        FastMath.atan2(v2.getZ(), v2.getX())\n      };\n\n    } else if (order == RotationOrder.ZXZ) {\n\n      // r (Vector3D.plusK) coordinates are :\n      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n      // and we can choose to have phi in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getX(), -v1.getY()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getX(), v2.getY())\n      };\n\n    } else { // last possibility is ZYZ\n\n      // r (Vector3D.plusK) coordinates are :\n      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n      // (-r) (Vector3D.plusK) coordinates are :\n      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n      // and we can choose to have theta in the interval [0 ; PI]\n      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n        throw new CardanEulerSingularityException(false);\n      }\n      return new double[] {\n        FastMath.atan2(v1.getY(), v1.getX()),\n        FastMath.acos(v2.getZ()),\n        FastMath.atan2(v2.getY(), -v2.getX())\n      };\n\n    }\n\n  }\n\n  /** Get the 3X3 matrix corresponding to the instance\n   * @return the matrix corresponding to the instance\n   */\n  public double[][] getMatrix() {\n\n    // products\n    double q0q0  = q0 * q0;\n    double q0q1  = q0 * q1;\n    double q0q2  = q0 * q2;\n    double q0q3  = q0 * q3;\n    double q1q1  = q1 * q1;\n    double q1q2  = q1 * q2;\n    double q1q3  = q1 * q3;\n    double q2q2  = q2 * q2;\n    double q2q3  = q2 * q3;\n    double q3q3  = q3 * q3;\n\n    // create the matrix\n    double[][] m = new double[3][];\n    m[0] = new double[3];\n    m[1] = new double[3];\n    m[2] = new double[3];\n\n    m [0][0] = 2.0 * (q0q0 + q1q1) - 1.0;\n    m [1][0] = 2.0 * (q1q2 - q0q3);\n    m [2][0] = 2.0 * (q1q3 + q0q2);\n\n    m [0][1] = 2.0 * (q1q2 + q0q3);\n    m [1][1] = 2.0 * (q0q0 + q2q2) - 1.0;\n    m [2][1] = 2.0 * (q2q3 - q0q1);\n\n    m [0][2] = 2.0 * (q1q3 - q0q2);\n    m [1][2] = 2.0 * (q2q3 + q0q1);\n    m [2][2] = 2.0 * (q0q0 + q3q3) - 1.0;\n\n    return m;\n\n  }\n\n  /** Apply the rotation to a vector.\n   * @param u vector to apply the rotation to\n   * @return a new vector which is the image of u by the rotation\n   */\n  public Vector3D applyTo(Vector3D u) {\n\n    double x = u.getX();\n    double y = u.getY();\n    double z = u.getZ();\n\n    double s = q1 * x + q2 * y + q3 * z;\n\n    return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,\n                        2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,\n                        2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);\n\n  }\n\n  /** Apply the inverse of the rotation to a vector.\n   * @param u vector to apply the inverse of the rotation to\n   * @return a new vector which such that u is its image by the rotation\n   */\n  public Vector3D applyInverseTo(Vector3D u) {\n\n    double x = u.getX();\n    double y = u.getY();\n    double z = u.getZ();\n\n    double s = q1 * x + q2 * y + q3 * z;\n    double m0 = -q0;\n\n    return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,\n                        2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,\n                        2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);\n\n  }\n\n  /** Apply the instance to another rotation.\n   * Applying the instance to a rotation is computing the composition\n   * in an order compliant with the following rule : let u be any\n   * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image\n   * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),\n   * where comp = applyTo(r).\n   * @param r rotation to apply the rotation to\n   * @return a new rotation which is the composition of r by the instance\n   */\n  public Rotation applyTo(Rotation r) {\n    return new Rotation(r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n                        r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n                        r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n                        r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n                        false);\n  }\n\n  /** Apply the inverse of the instance to another rotation.\n   * Applying the inverse of the instance to a rotation is computing\n   * the composition in an order compliant with the following rule :\n   * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),\n   * let w be the inverse image of v by the instance\n   * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where\n   * comp = applyInverseTo(r).\n   * @param r rotation to apply the rotation to\n   * @return a new rotation which is the composition of r by the inverse\n   * of the instance\n   */\n  public Rotation applyInverseTo(Rotation r) {\n    return new Rotation(-r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n                        -r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n                        -r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n                        -r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n                        false);\n  }\n\n  /** Perfect orthogonality on a 3X3 matrix.\n   * @param m initial matrix (not exactly orthogonal)\n   * @param threshold convergence threshold for the iterative\n   * orthogonality correction (convergence is reached when the\n   * difference between two steps of the Frobenius norm of the\n   * correction is below this threshold)\n   * @return an orthogonal matrix close to m\n   * @exception NotARotationMatrixException if the matrix cannot be\n   * orthogonalized with the given threshold after 10 iterations\n   */\n  private double[][] orthogonalizeMatrix(double[][] m, double threshold)\n    throws NotARotationMatrixException {\n    double[] m0 = m[0];\n    double[] m1 = m[1];\n    double[] m2 = m[2];\n    double x00 = m0[0];\n    double x01 = m0[1];\n    double x02 = m0[2];\n    double x10 = m1[0];\n    double x11 = m1[1];\n    double x12 = m1[2];\n    double x20 = m2[0];\n    double x21 = m2[1];\n    double x22 = m2[2];\n    double fn = 0;\n    double fn1;\n\n    double[][] o = new double[3][3];\n    double[] o0 = o[0];\n    double[] o1 = o[1];\n    double[] o2 = o[2];\n\n    // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n    int i = 0;\n    while (++i < 11) {\n\n      // Mt.Xn\n      double mx00 = m0[0] * x00 + m1[0] * x10 + m2[0] * x20;\n      double mx10 = m0[1] * x00 + m1[1] * x10 + m2[1] * x20;\n      double mx20 = m0[2] * x00 + m1[2] * x10 + m2[2] * x20;\n      double mx01 = m0[0] * x01 + m1[0] * x11 + m2[0] * x21;\n      double mx11 = m0[1] * x01 + m1[1] * x11 + m2[1] * x21;\n      double mx21 = m0[2] * x01 + m1[2] * x11 + m2[2] * x21;\n      double mx02 = m0[0] * x02 + m1[0] * x12 + m2[0] * x22;\n      double mx12 = m0[1] * x02 + m1[1] * x12 + m2[1] * x22;\n      double mx22 = m0[2] * x02 + m1[2] * x12 + m2[2] * x22;\n\n      // Xn+1\n      o0[0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m0[0]);\n      o0[1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m0[1]);\n      o0[2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m0[2]);\n      o1[0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m1[0]);\n      o1[1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m1[1]);\n      o1[2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m1[2]);\n      o2[0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m2[0]);\n      o2[1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m2[1]);\n      o2[2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m2[2]);\n\n      // correction on each elements\n      double corr00 = o0[0] - m0[0];\n      double corr01 = o0[1] - m0[1];\n      double corr02 = o0[2] - m0[2];\n      double corr10 = o1[0] - m1[0];\n      double corr11 = o1[1] - m1[1];\n      double corr12 = o1[2] - m1[2];\n      double corr20 = o2[0] - m2[0];\n      double corr21 = o2[1] - m2[1];\n      double corr22 = o2[2] - m2[2];\n\n      // Frobenius norm of the correction\n      fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n            corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n            corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n\n      // convergence test\n      if (FastMath.abs(fn1 - fn) <= threshold) {\n          return o;\n      }\n\n      // prepare next iteration\n      x00 = o0[0];\n      x01 = o0[1];\n      x02 = o0[2];\n      x10 = o1[0];\n      x11 = o1[1];\n      x12 = o1[2];\n      x20 = o2[0];\n      x21 = o2[1];\n      x22 = o2[2];\n      fn  = fn1;\n\n    }\n\n    // the algorithm did not converge after 10 iterations\n    throw new NotARotationMatrixException(\n            LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n            i - 1);\n  }\n\n  /** Compute the <i>distance</i> between two rotations.\n   * <p>The <i>distance</i> is intended here as a way to check if two\n   * rotations are almost similar (i.e. they transform vectors the same way)\n   * or very different. It is mathematically defined as the angle of\n   * the rotation r that prepended to one of the rotations gives the other\n   * one:</p>\n   * <pre>\n   *        r<sub>1</sub>(r) = r<sub>2</sub>\n   * </pre>\n   * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n   * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n   * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n   * reached for some v. The distance is equal to 0 if and only if the two\n   * rotations are identical.</p>\n   * <p>Comparing two rotations should always be done using this value rather\n   * than for example comparing the components of the quaternions. It is much\n   * more stable, and has a geometric meaning. Also comparing quaternions\n   * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n   * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n   * their components are different (they are exact opposites).</p>\n   * @param r1 first rotation\n   * @param r2 second rotation\n   * @return <i>distance</i> between r1 and r2\n   */\n  public static double distance(Rotation r1, Rotation r2) {\n      return r1.applyInverseTo(r2).getAngle();\n  }\n\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"description\": \"The constructor for Rotation does not check if the quaternion is normalized. The quaternion should have a magnitude of 1 for it to be a valid rotation, but there is no check for this in the constructor. This could lead to incorrect rotations being created.\",\n      \"code_snippet\": \"public Rotation(double q0, double q1, double q2, double q3) { ... }\"\n    },\n    {\n      \"description\": \"The applyTo(Vector3D) and applyInverseTo(Vector3D) methods do not check if the input vector is null. This could lead to a NullPointerException if a null vector is passed to these methods.\",\n      \"code_snippet\": \"public Vector3D applyTo(Vector3D v) { ... }\\npublic Vector3D applyInverseTo(Vector3D v) { ... }\"\n    },\n    {\n      \"description\": \"The applyTo(Rotation) and applyInverseTo(Rotation) methods do not check if the input rotation is null. This could lead to a NullPointerException if a null rotation is passed to these methods.\",\n      \"code_snippet\": \"public Rotation applyTo(Rotation r) { ... }\\npublic Rotation applyInverseTo(Rotation r) { ... }\"\n    },\n    {\n      \"description\": \"The getAngles(RotationOrder) method does not check if the input order is null. This could lead to a NullPointerException if a null order is passed to this method.\",\n      \"code_snippet\": \"public double[] getAngles(RotationOrder order) { ... }\"\n    },\n    {\n      \"description\": \"The setAngles(double[], RotationOrder) method does not check if the input angles array is null or empty. This could lead to an ArrayIndexOutOfBoundsException if a null or empty array is passed to this method.\",\n      \"code_snippet\": \"public void setAngles(double[] angles, RotationOrder order) { ... }\"\n    }\n  ]\n}"}}