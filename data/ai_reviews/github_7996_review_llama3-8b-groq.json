{
  "source_item_id": 7996,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:43:49.622637",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Predicates.instanceOf;\nimport static com.google.common.collect.CollectPreconditions.checkRemove;\nimport static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.unmodifiableList;\nimport static java.util.Objects.requireNonNull;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Function;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.primitives.Ints;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.InlineMe;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport org.jspecify.annotations.NonNull;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * This class contains static utility methods that operate on or return objects of type {@link\n * Iterator}. Except as noted, each method has a corresponding {@link Iterable}-based method in the\n * {@link Iterables} class.\n *\n * <p><i>Performance notes:</i> Unless otherwise noted, all of the iterators produced in this class\n * are <i>lazy</i>, which means that they only advance the backing iteration when absolutely\n * necessary.\n *\n * <p>See the Guava User Guide section on <a href=\n * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables\">{@code\n * Iterators}</a>.\n *\n * @author Kevin Bourrillion\n * @author Jared Levy\n * @since 2.0\n */\n@GwtCompatible\npublic final class Iterators {\n  private Iterators() {}\n\n  /**\n   * Returns the empty iterator.\n   *\n   * <p>The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.\n   */\n  static <T extends @Nullable Object> UnmodifiableIterator<T> emptyIterator() {\n    return emptyListIterator();\n  }\n\n  /**\n   * Returns the empty iterator.\n   *\n   * <p>The {@link Iterable} equivalent of this method is {@link ImmutableSet#of()}.\n   */\n  // Casting to any type is safe since there are no actual elements.\n  @SuppressWarnings(\"unchecked\")\n  static <T extends @Nullable Object> UnmodifiableListIterator<T> emptyListIterator() {\n    return (UnmodifiableListIterator<T>) ArrayItr.EMPTY;\n  }\n\n  /**\n   * This is an enum singleton rather than an anonymous class so ProGuard can figure out it's only\n   * referenced by emptyModifiableIterator().\n   */\n  private enum EmptyModifiableIterator implements Iterator<Object> {\n    INSTANCE;\n\n    @Override\n    public boolean hasNext() {\n      return false;\n    }\n\n    @Override\n    public Object next() {\n      throw new NoSuchElementException();\n    }\n\n    @Override\n    public void remove() {\n      checkRemove(false);\n    }\n  }\n\n  /**\n   * Returns the empty {@code Iterator} that throws {@link IllegalStateException} instead of {@link\n   * UnsupportedOperationException} on a call to {@link Iterator#remove()}.\n   */\n  // Casting to any type is safe since there are no actual elements.\n  @SuppressWarnings(\"unchecked\")\n  static <T extends @Nullable Object> Iterator<T> emptyModifiableIterator() {\n    return (Iterator<T>) EmptyModifiableIterator.INSTANCE;\n  }\n\n  /** Returns an unmodifiable view of {@code iterator}. */\n  public static <T extends @Nullable Object> UnmodifiableIterator<T> unmodifiableIterator(\n      Iterator<? extends T> iterator) {\n    checkNotNull(iterator);\n    if (iterator instanceof UnmodifiableIterator) {\n      @SuppressWarnings(\"unchecked\") // Since it's unmodifiable, the covariant cast is safe\n      UnmodifiableIterator<T> result = (UnmodifiableIterator<T>) iterator;\n      return result;\n    }\n    return new UnmodifiableIterator<T>() {\n      @Override\n      public boolean hasNext() {\n        return iterator.hasNext();\n      }\n\n      @Override\n      @ParametricNullness\n      public T next() {\n        return iterator.next();\n      }\n    };\n  }\n\n  /**\n   * Simply returns its argument.\n   *\n   * @deprecated no need to use this\n   * @since 10.0\n   */\n  @InlineMe(\n      replacement = \"checkNotNull(iterator)\",\n      staticImports = \"com.google.common.base.Preconditions.checkNotNull\")\n  @Deprecated\n  public static <T extends @Nullable Object> UnmodifiableIterator<T> unmodifiableIterator(\n      UnmodifiableIterator<T> iterator) {\n    return checkNotNull(iterator);\n  }\n\n  /**\n   * Returns the number of elements remaining in {@code iterator}. The iterator will be left\n   * exhausted: its {@code hasNext()} method will return {@code false}.\n   */\n  public static int size(Iterator<?> iterator) {\n    long count = 0L;\n    while (iterator.hasNext()) {\n      iterator.next();\n      count++;\n    }\n    return Ints.saturatedCast(count);\n  }\n\n  /** Returns {@code true} if {@code iterator} contains {@code element}. */\n  public static boolean contains(Iterator<?> iterator, @Nullable Object element) {\n    if (element == null) {\n      while (iterator.hasNext()) {\n        if (iterator.next() == null) {\n          return true;\n        }\n      }\n    } else {\n      while (iterator.hasNext()) {\n        if (element.equals(iterator.next())) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Traverses an iterator and removes every element that belongs to the provided collection. The\n   * iterator will be left exhausted: its {@code hasNext()} method will return {@code false}.\n   *\n   * @param removeFrom the iterator to (potentially) remove elements from\n   * @param elementsToRemove the elements to remove\n   * @return {@code true} if any element was removed from {@code iterator}\n   */\n  @CanIgnoreReturnValue\n  public static boolean removeAll(Iterator<?> removeFrom, Collection<?> elementsToRemove) {\n    checkNotNull(elementsToRemove);\n    boolean result = false;\n    while (removeFrom.hasNext()) {\n      if (elementsToRemove.contains(removeFrom.next())) {\n        removeFrom.remove();\n        result = true;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Removes every element that satisfies the provided predicate from the iterator. The iterator\n   * will be left exhausted: its {@code hasNext()} method will return {@code false}.\n   *\n   * @param removeFrom the iterator to (potentially) remove elements from\n   * @param predicate a predicate that determines whether an element should be removed\n   * @return {@code true} if any elements were removed from the iterator\n   * @since 2.0\n   */\n  @CanIgnoreReturnValue\n  public static <T extends @Nullable Object> boolean removeIf(\n      Iterator<T> removeFrom, Predicate<? super T> predicate) {\n    checkNotNull(predicate);\n    boolean modified = false;\n    while (removeFrom.hasNext()) {\n      if (predicate.apply(removeFrom.next())) {\n        removeFrom.remove();\n        modified = true;\n      }\n    }\n    return modified;\n  }\n\n  /**\n   * Traverses an iterator and removes every",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The method 'contains' does not handle the case where the iterator is empty correctly. It will throw a NoSuchElementException.\",\n         \"suggested_fix\": \"if (!iterator.hasNext()) return false;\"\n      },\n      {\n         \"explanation\": \"The method 'removeAll' does not handle the case where the iterator is empty correctly. It will throw a NoSuchElementException.\",\n         \"suggested_fix\": \"if (!removeFrom.hasNext()) return false;\"\n      },\n      {\n         \"explanation\": \"The method 'removeIf' does not handle the case where the iterator is empty correctly. It will throw a NoSuchElementException.\",\n         \"suggested_fix\": \"if (!removeFrom.hasNext()) return false;\"\n      },\n      {\n         \"explanation\": \"The method 'size' does not handle the case where the iterator is empty correctly. It will return 0.\",\n         \"suggested_fix\": \"if (!iterator.hasNext()) return 0;\"\n      },\n      {\n         \"explanation\": \"The method 'unmodifiableIterator' does not check if the iterator is already unmodifiable.\",\n         \"suggested_fix\": \"if (iterator instanceof UnmodifiableIterator) return (UnmodifiableIterator<T>) iterator;\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs found in the provided code snippet.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The method 'contains' does not handle the case where the iterator is empty correctly. It will throw a NoSuchElementException.",
        "suggested_fix": "if (!iterator.hasNext()) return false;"
      },
      {
        "explanation": "The method 'removeAll' does not handle the case where the iterator is empty correctly. It will throw a NoSuchElementException.",
        "suggested_fix": "if (!removeFrom.hasNext()) return false;"
      },
      {
        "explanation": "The method 'removeIf' does not handle the case where the iterator is empty correctly. It will throw a NoSuchElementException.",
        "suggested_fix": "if (!removeFrom.hasNext()) return false;"
      },
      {
        "explanation": "The method 'size' does not handle the case where the iterator is empty correctly. It will return 0.",
        "suggested_fix": "if (!iterator.hasNext()) return 0;"
      },
      {
        "explanation": "The method 'unmodifiableIterator' does not check if the iterator is already unmodifiable.",
        "suggested_fix": "if (iterator instanceof UnmodifiableIterator) return (UnmodifiableIterator<T>) iterator;"
      }
    ],
    "no_bugs_reasoning": "No bugs found in the provided code snippet."
  },
  "error": null
}