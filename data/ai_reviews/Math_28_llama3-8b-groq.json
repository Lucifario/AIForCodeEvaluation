{"sample_id": "Math_28", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.optimization.linear;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.exception.MaxCountExceededException;\nimport org.apache.commons.math3.optimization.PointValuePair;\nimport org.apache.commons.math3.util.Precision;\n\n\n/**\n * Solves a linear problem using the Two-Phase Simplex Method.\n * @version $Id$\n * @since 2.0\n */\npublic class SimplexSolver extends AbstractLinearOptimizer {\n\n    /** Default amount of error to accept for algorithm convergence. */\n    private static final double DEFAULT_EPSILON = 1.0e-6;\n\n    /** Default amount of error to accept in floating point comparisons (as ulps). */\n    private static final int DEFAULT_ULPS = 10;\n\n    /** Amount of error to accept for algorithm convergence. */\n    private final double epsilon;\n\n    /** Amount of error to accept in floating point comparisons (as ulps). */\n    private final int maxUlps;\n\n    /**\n     * Build a simplex solver with default settings.\n     */\n    public SimplexSolver() {\n        this(DEFAULT_EPSILON, DEFAULT_ULPS);\n    }\n\n    /**\n     * Build a simplex solver with a specified accepted amount of error\n     * @param epsilon the amount of error to accept for algorithm convergence\n     * @param maxUlps amount of error to accept in floating point comparisons\n     */\n    public SimplexSolver(final double epsilon, final int maxUlps) {\n        this.epsilon = epsilon;\n        this.maxUlps = maxUlps;\n    }\n\n    /**\n     * Returns the column with the most negative coefficient in the objective function row.\n     * @param tableau simple tableau for the problem\n     * @return column with the most negative coefficient\n     */\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            final double entry = tableau.getEntry(0, i);\n            // check if the entry is strictly smaller than the current minimum\n            // do not use a ulp/epsilon check\n            if (entry < minValue) {\n                minValue = entry;\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n\n    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n\n    /**\n     * Runs one iteration of the Simplex method on the given model.\n     * @param tableau simple tableau for the problem\n     * @throws MaxCountExceededException if the maximal iteration count has been exceeded\n     * @throws UnboundedSolutionException if the model is found not to have a bounded solution\n     */\n    protected void doIteration(final SimplexTableau tableau)\n        throws MaxCountExceededException, UnboundedSolutionException {\n\n        incrementIterationsCounter();\n\n        Integer pivotCol = getPivotColumn(tableau);\n        Integer pivotRow = getPivotRow(tableau, pivotCol);\n        if (pivotRow == null) {\n            throw new UnboundedSolutionException();\n        }\n\n        // set the pivot element to 1\n        double pivotVal = tableau.getEntry(pivotRow, pivotCol);\n        tableau.divideRow(pivotRow, pivotVal);\n\n        // set the rest of the pivot column to 0\n        for (int i = 0; i < tableau.getHeight(); i++) {\n            if (i != pivotRow) {\n                final double multiplier = tableau.getEntry(i, pivotCol);\n                tableau.subtractRow(i, pivotRow, multiplier);\n            }\n        }\n    }\n\n    /**\n     * Solves Phase 1 of the Simplex method.\n     * @param tableau simple tableau for the problem\n     * @throws MaxCountExceededException if the maximal iteration count has been exceeded\n     * @throws UnboundedSolutionException if the model is found not to have a bounded solution\n     * @throws NoFeasibleSolutionException if there is no feasible solution\n     */\n    protected void solvePhase1(final SimplexTableau tableau)\n        throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {\n\n        // make sure we're in Phase 1\n        if (tableau.getNumArtificialVariables() == 0) {\n            return;\n        }\n\n        while (!tableau.isOptimal()) {\n            doIteration(tableau);\n        }\n\n        // if W is not zero then we have no feasible solution\n        if (!Precision.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {\n            throw new NoFeasibleSolutionException();\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public PointValuePair doOptimize()\n        throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {\n        final SimplexTableau tableau =\n            new SimplexTableau(getFunction(),\n                               getConstraints(),\n                               getGoalType(),\n                               restrictToNonNegative(),\n                               epsilon,\n                               maxUlps);\n\n        solvePhase1(tableau);\n        tableau.dropPhase1Objective();\n\n        while (!tableau.isOptimal()) {\n            doIteration(tableau);\n        }\n        return tableau.getSolution();\n    }\n\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"description\": \"In the getPivotColumn method, if the tableau object is null, a NullPointerException will be thrown when trying to access its methods.\",\n         \"location\": \"SimplexSolver.java:62\"\n      },\n      {\n         \"type\": \"Potential IndexOutOfBoundsException\",\n         \"description\": \"In the getPivotColumn method, if the tableau object's width is less than or equal to the number of objective functions, an IndexOutOfBoundsException will be thrown when trying to access the tableau's entries.\",\n         \"location\": \"SimplexSolver.java:67\"\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"description\": \"In the getPivotRow method, if the tableau object is null, a NullPointerException will be thrown when trying to access its methods.\",\n         \"location\": \"SimplexSolver.java:97\"\n      },\n      {\n         \"type\": \"Potential IndexOutOfBoundsException\",\n         \"description\": \"In the getPivotRow method, if the tableau object's height is less than or equal to the number of objective functions, an IndexOutOfBoundsException will be thrown when trying to access the tableau's entries.\",\n         \"location\": \"SimplexSolver.java:104\"\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"description\": \"In the getPivotRow method, if the tableau object's entries are null, a NullPointerException will be thrown when trying to access their values.\",\n         \"location\": \"SimplexSolver.java:109\"\n      },\n      {\n         \"type\": \"Potential ArithmeticException\",\n         \"description\": \"In the getPivotRow method, if the entry value is zero, an ArithmeticException will be thrown when trying to divide by zero.\",\n         \"location\": \"SimplexSolver.java:115\"\n      },\n      {\n         \"type\": \"Potential ClassCastException\",\n         \"description\": \"In the getPivotRow method, if the entry value is not a number, a ClassCastException will be thrown when trying to compare it with a number.\",\n         \"location\": \"SimplexSolver.java:116\"\n      }\n   ]\n}"}}