{"sample_id": "Closure_70", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport static com.google.javascript.jscomp.TypeCheck.ENUM_DUP;\nimport static com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT;\nimport static com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.DATE_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.RANGE_ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.URI_ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.CodingConvention.DelegateRelationship;\nimport com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;\nimport com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\nimport com.google.javascript.jscomp.CodingConvention.SubclassType;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.ErrorReporter;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.jstype.EnumType;\nimport com.google.javascript.rhino.jstype.FunctionParamBuilder;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.rhino.jstype.JSTypeNative;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\nimport com.google.javascript.rhino.jstype.ObjectType;\n\nimport java.util.Iterator;\nimport java.util.List;\n\nimport javax.annotation.Nullable;\n\n/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  /**\n   * A suffix for naming delegate proxies differently from their base.\n   */\n  static final String DELEGATE_PROXY_SUFFIX =\n      ObjectType.createDelegateSuffix(\"Proxy\");\n\n  private static final String LEGACY_TYPEDEF = \"goog.typedef\";\n\n  static final DiagnosticType MALFORMED_TYPEDEF =\n      DiagnosticType.warning(\n          \"JSC_MALFORMED_TYPEDEF\",\n          \"Typedef for {0} does not have any type information\");\n\n  static final DiagnosticType ENUM_INITIALIZER =\n      DiagnosticType.warning(\n          \"JSC_ENUM_INITIALIZER_NOT_ENUM\",\n          \"enum initializer must be an object literal or an enum\");\n\n  static final DiagnosticType CTOR_INITIALIZER =\n      DiagnosticType.warning(\n          \"JSC_CTOR_INITIALIZER_NOT_CTOR\",\n          \"Constructor {0} must be initialized at declaration\");\n\n  static final DiagnosticType IFACE_INITIALIZER =\n      DiagnosticType.warning(\n          \"JSC_IFACE_INITIALIZER_NOT_IFACE\",\n          \"Interface {0} must be initialized at declaration\");\n\n  static final DiagnosticType CONSTRUCTOR_EXPECTED =\n      DiagnosticType.warning(\n          \"JSC_REFLECT_CONSTRUCTOR_EXPECTED\",\n          \"Constructor expected as first argument\");\n\n  static final DiagnosticType UNKNOWN_LENDS =\n      DiagnosticType.warning(\n          \"JSC_UNKNOWN_LENDS\",\n          \"Variable {0} not declared before @lends annotation.\");\n\n  static final DiagnosticType LENDS_ON_NON_OBJECT =\n      DiagnosticType.warning(\n          \"JSC_LENDS_ON_NON_OBJECT\",\n          \"May only lend properties to object types. {0} has type {1}.\");\n\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n\n  /**\n   * Defer attachment of types to nodes until all type names\n   * have been resolved. Then, we can resolve the type and attach it.\n   */\n  private class DeferredSetType {\n    final Node node;\n    final JSType type;\n\n    DeferredSetType(Node node, JSType type) {\n      Preconditions.checkNotNull(node);\n      Preconditions.checkNotNull(type);\n      this.node = node;\n      this.type = type;\n\n      // Other parts of this pass may read off the node.\n      // (like when we set the LHS of an assign with a typed RHS function.)\n      node.setJSType(type);\n    }\n\n    void resolve(Scope scope) {\n      node.setJSType(type.resolve(typeParsingErrorReporter, scope));\n    }\n  }\n\n  TypedScopeCreator(AbstractCompiler compiler) {\n    this(compiler, compiler.getCodingConvention());\n  }\n\n  TypedScopeCreator(AbstractCompiler compiler,\n      CodingConvention codingConvention) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.codingConvention = codingConvention;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.typeParsingErrorReporter = typeRegistry.getErrorReporter();\n  }\n\n  /**\n   * Creates a scope with all types declared. Declares newly discovered types\n   * and type properties in the type registry.\n   */\n  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    AbstractScopeBuilder scopeBuilder = null;\n    if (parent == null) {\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n      scopeBuilder = globalScopeBuilder;\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n    } else {\n      newScope = new Scope(parent, root);\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n      scopeBuilder = localScopeBuilder;\n      localScopeBuilder.build();\n    }\n\n    scopeBuilder.resolveStubDeclarations();\n    scopeBuilder.resolveTypes();\n\n    // Gather the properties in each function that we found in the\n    // global scope, if that function has a @this type that we can\n    // build properties on.\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n      JSType type = functionNode.getJSType();\n      if (type != null && type instanceof FunctionType) {\n        FunctionType fnType = (FunctionType) type;\n        ObjectType fnThisType = fnType.getTypeOfThis();\n        if (!fnThisType.isUnknownType()) {\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n              scopeBuilder.new CollectProperties(fnThisType));\n        }\n      }\n    }\n\n    if (parent == null) {\n      codingConvention.defineDelegateProxyPrototypeProperties(\n          typeRegistry, newScope, delegateProxyPrototypes);\n    }\n    return newScope;\n  }\n\n  /**\n   * Create the outermost scope. This scope contains native binding such as\n   * {@code Object}, {@code Date}, etc.\n   */\n  @VisibleForTesting\n  Scope createInitialScope(Node root) {\n\n    NodeTraversal.traverse(\n        compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));\n\n    Scope s = new Scope(root, compiler);\n    declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n    declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, DATE_FUNCTION_TYPE);\n    declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE);\n    declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE);\n    declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);\n    declareNativeValueType(s, \"undefined\", VOID_TYPE);\n\n    // The typedef construct needs the any type, so that it can be assigned\n    // to anything. This is kind of a hack, and an artifact of the typedef\n    // syntax we've chosen.\n    declareNativeValueType(s, LEGACY_TYPEDEF, NO_TYPE);\n\n    // ActiveXObject is unqiuely special, because it can be used to construct\n    // any type (the type that it creates is related to the arguments you\n    // pass to it).\n    declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE);\n\n    return s;\n  }\n\n  private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n    FunctionType t = typeRegistry.getNativeFunctionType(tId);\n    declareNativeType(scope, t.getInstanceType().getReferenceName(), t);\n    declareNativeType(\n        scope, t.getPrototype().getReferenceName(), t.getPrototype());\n  }\n\n  private void declareNativeValueType(Scope scope, String name,\n      JSTypeNative tId) {\n    declareNativeType(scope, name, typeRegistry.getNativeType(tId));\n  }\n\n  private void declareNativeType(Scope scope, String name, JSType t) {\n    scope.declare(name, null, t, null, false);\n  }\n\n  private static class DiscoverEnumsAndTypedefs\n      extends AbstractShallowStatementCallback {\n    private final JSTypeRegistry registry;\n\n    DiscoverEnumsAndTypedefs(JSTypeRegistry registry) {\n      this.registry = registry;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      Node nameNode = null;\n      switch (node.getType()) {\n        case Token.VAR:\n          for (Node child = node.getFirstChild();\n               child != null; child = child.getNext()) {\n            identifyNameNode(\n                child, child.getFirstChild(),\n                NodeUtil.getInfoForNameNode(child));\n          }\n          break;\n        case Token.EXPR_RESULT:\n          Node firstChild = node.getFirstChild();\n          if (firstChild.getType() == Token.ASSIGN) {\n            identifyNameNode(\n                firstChild.getFirstChild(), firstChild.getLastChild(),\n                firstChild.getJSDocInfo());\n          } else {\n            identifyNameNode(\n                firstChild, null, firstChild.getJSDocInfo());\n          }\n          break;\n      }\n    }\n\n    private void identifyNameNode(\n        Node nameNode, Node valueNode, JSDocInfo info) {\n      if (nameNode.isQualifiedName()) {\n        if (info != null) {\n          if (info.hasEnumParameterType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          } else if (info.hasTypedefType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          }\n        }\n\n        if (valueNode != null &&\n            LEGACY_TYPEDEF.equals(valueNode.getQualifiedName())) {\n          registry.identifyNonNullableName(nameNode.getQualifiedName());\n        }\n      }\n    }\n  }\n\n  /**\n   * Given a node, determines whether that node names a prototype\n   * property, and if so, returns the qualified name node representing\n   * the owner of that property. Otherwise, returns null.\n   */\n  private static Node getPrototypePropertyOwner(Node n) {\n    if (n.getType() == Token.GETPROP) {\n      Node firstChild = n.getFirstChild();\n      if (firstChild.getType() == Token.GETPROP &&\n          firstChild.getLastChild().getString().equals(\"prototype\")) {\n        Node maybeOwner = firstChild.getFirstChild();\n        if (maybeOwner.isQualifiedName()) {\n          return maybeOwner;\n        }\n      }\n    }\n    return null;\n  }\n\n  private JSType getNativeType(JSTypeNative nativeType) {\n    return typeRegistry.getNativeType(nativeType);\n  }\n\n  private abstract class AbstractScopeBuilder\n      implements NodeTraversal.Callback {\n\n    /**\n     * The scope that we're builidng.\n     */\n    final Scope scope;\n\n    private final List<DeferredSetType> deferredSetTypes =\n        Lists.newArrayList();\n\n    /**\n     * Functions that we found in the global scope and not in externs.\n     */\n    private final List<Node> nonExternFunctions = Lists.newArrayList();\n\n    /**\n     * Type-less stubs.\n     *\n     * If at the end of traversal, we still don't have types for these\n     * stubs, then we should declare UNKNOWN types.\n     */\n    private final List<StubDeclaration> stubDeclarations =\n        Lists.newArrayList();\n\n    /**\n     * The current source file that we're in.\n     */\n    private String sourceName = null;\n\n    private AbstractScopeBuilder(Scope scope) {\n      this.scope = scope;\n    }\n\n    void setDeferredType(Node node, JSType type) {\n      deferredSetTypes.add(new DeferredSetType(node, type));\n    }\n\n    void resolveTypes() {\n      // Resolve types and attach them to nodes.\n      for (DeferredSetType deferred : deferredSetTypes) {\n        deferred.resolve(scope);\n      }\n\n      // Resolve types and attach them to scope slots.\n      Iterator<Var> vars = scope.getVars();\n      while (vars.hasNext()) {\n        vars.next().resolveType(typeParsingErrorReporter);\n      }\n\n      // Tell the type registry that any remaining types\n      // are unknown.\n      typeRegistry.resolveTypesInScope(scope);\n    }\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      if (n.getType() == Token.FUNCTION ||\n          n.getType() == Token.SCRIPT) {\n        sourceName = NodeUtil.getSourceName(n);\n      }\n\n      // We do want to traverse the name of a named function, but we don't\n      // want to traverse the arguments or body.\n      boolean descend = parent == null || parent.getType() != Token.FUNCTION ||\n          n == parent.getFirstChild() || parent == scope.getRootNode();\n\n      if (descend) {\n        // Handle hoisted functions on pre-order traversal, so that they\n        // get hit before other things in the scope.\n        if (NodeUtil.isStatementParent(n)) {\n          for (Node child = n.getFirstChild();\n               child != null;\n               child = child.getNext()) {\n            if (NodeUtil.isHoistedFunctionDeclaration(child)) {\n              defineFunctionLiteral(child, n);\n            }\n          }\n        }\n      }\n\n      return descend;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      attachLiteralTypes(t, n);\n\n      switch (n.getType()) {\n        case Token.CALL:\n          checkForClassDefiningCalls(t, n, parent);\n          break;\n\n        case Token.FUNCTION:\n          if (t.getInput() == null || !t.getInput().isExtern()) {\n            nonExternFunctions.add(n);\n          }\n\n          // Hoisted functions are handled during pre-traversal.\n          if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\n            defineFunctionLiteral(n, parent);\n          }\n          break;\n\n        case Token.ASSIGN:\n          // Handle initialization of properties.\n          Node firstChild = n.getFirstChild();\n          if (firstChild.getType() == Token.GETPROP &&\n              firstChild.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n                firstChild, n, firstChild.getNext());\n          }\n          break;\n\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n\n        case Token.VAR:\n          defineVar(n, parent);\n          break;\n\n        case Token.GETPROP:\n          // Handle stubbed properties.\n          if (parent.getType() == Token.EXPR_RESULT &&\n              n.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n          }\n          break;\n      }\n    }\n\n    private void attachLiteralTypes(NodeTraversal t, Node n) {\n      switch (n.getType()) {\n        case Token.NULL:\n          n.setJSType(getNativeType(NULL_TYPE));\n          break;\n\n        case Token.VOID:\n          n.setJSType(getNativeType(VOID_TYPE));\n          break;\n\n        case Token.STRING:\n          // Defer keys to the Token.OBJECTLIT case\n          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n            n.setJSType(getNativeType(STRING_TYPE));\n          }\n          break;\n\n        case Token.NUMBER:\n          n.setJSType(getNativeType(NUMBER_TYPE));\n          break;\n\n        case Token.TRUE:\n        case Token.FALSE:\n          n.setJSType(getNativeType(BOOLEAN_TYPE));\n          break;\n\n        case Token.REGEXP:\n          n.setJSType(getNativeType(REGEXP_TYPE));\n          break;\n\n        case Token.REF_SPECIAL:\n          n.setJSType(getNativeType(UNKNOWN_TYPE));\n          break;\n\n        case Token.OBJECTLIT:\n          defineObjectLiteral(t, n);\n          break;\n\n          // NOTE(nicksantos): If we ever support Array tuples,\n          // we will need to put ARRAYLIT here as well.\n      }\n    }\n\n    private void defineObjectLiteral(NodeTraversal t, Node objectLit) {\n      // Handle the @lends annotation.\n      JSType type = null;\n      JSDocInfo info = objectLit.getJSDocInfo();\n      if (info != null &&\n          info.getLendsName() != null) {\n        String lendsName = info.getLendsName();\n        Var lendsVar = scope.getVar(lendsName);\n        if (lendsVar == null) {\n          compiler.report(\n              JSError.make(sourceName, objectLit, UNKNOWN_LENDS, lendsName));\n        } else {\n          type = lendsVar.getType();\n          if (type == null) {\n            type = typeRegistry.getNativeType(UNKNOWN_TYPE);\n          }\n          if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n            compiler.report(\n                JSError.make(sourceName, objectLit, LENDS_ON_NON_OBJECT,\n                    lendsName, type.toString()));\n            type = null;\n          } else {\n            objectLit.setJSType(type);\n          }\n        }\n      }\n\n      info = getBestJSDocInfo(objectLit);\n      Node lValue = getBestLValue(objectLit);\n      String lValueName = getBestLValueName(lValue);\n      boolean createdEnumType = false;\n      if (info != null && info.hasEnumParameterType()) {\n        type = createEnumTypeFromNodes(objectLit, lValueName, info, lValue);\n        createdEnumType = true;\n      }\n\n      if (type == null) {\n        type = typeRegistry.createAnonymousObjectType();\n      }\n\n      setDeferredType(objectLit, type);\n\n      // If this is an enum, the properties were already taken care of above.\n      if (!createdEnumType) {\n        processObjectLitProperties(\n            t, objectLit, ObjectType.cast(objectLit.getJSType()));\n      }\n    }\n\n    /**\n     * Process an object literal and all the types on it.\n     * @param objLit The OBJECTLIT node.\n     * @param objLitType The type of the OBJECTLIT node. This might be a named\n     *     type, because of the lends annotation.\n     */\n    void processObjectLitProperties(\n        NodeTraversal t, Node objLit, ObjectType objLitType) {\n      for (Node keyNode = objLit.getFirstChild(); keyNode != null;\n           keyNode = keyNode.getNext()) {\n        Node value = keyNode.getFirstChild();\n        String memberName = NodeUtil.getObjectLitKeyName(keyNode);\n        JSDocInfo info = keyNode.getJSDocInfo();\n        JSType valueType = getDeclaredType(\n            t.getSourceName(), info, keyNode, value);\n        JSType keyType = NodeUtil.getObjectLitKeyTypeFromValueType(\n            keyNode, valueType);\n        if (keyType != null) {\n          // Try to declare this property in the current scope if it\n          // has an authoritative name.\n          String qualifiedName = getBestLValueName(keyNode);\n          if (qualifiedName != null) {\n            defineSlot(keyNode, objLit, qualifiedName, keyType, false);\n          } else {\n            setDeferredType(keyNode, keyType);\n          }\n\n          if (objLitType != null) {\n            // Declare this property on its object literal.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            objLitType.defineDeclaredProperty(\n                memberName, keyType, isExtern, keyNode);\n          }\n        }\n      }\n    }\n\n    /**\n     * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.\n     *\n     * Extracts type information from either the {@code @type} tag or from\n     * the {@code @return} and {@code @param} tags.\n     */\n    private JSType getDeclaredTypeInAnnotation(String sourceName,\n        Node node, JSDocInfo info) {\n      JSType jsType = null;\n      Node objNode =\n          node.getType() == Token.GETPROP ? node.getFirstChild() :\n          NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() :\n          null;\n      if (info != null) {\n        if (info.hasType()) {\n          jsType = info.getType().evaluate(scope, typeRegistry);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          String fnName = node.getQualifiedName();\n          jsType = createFunctionTypeFromNodes(\n              null, fnName, info, node);\n        }\n      }\n      return jsType;\n    }\n\n    /**\n     * Asserts that it's ok to define this node's name.\n     * The node should have a source name and be of the specified type.\n     */\n    void assertDefinitionNode(Node n, int type) {\n      Preconditions.checkState(sourceName != null);\n      Preconditions.checkState(n.getType() == type);\n    }\n\n    /**\n     * Defines a catch parameter.\n     */\n    void defineCatch(Node n, Node parent) {\n      assertDefinitionNode(n, Token.CATCH);\n      Node catchName = n.getFirstChild();\n      defineSlot(catchName, n, null);\n    }\n\n    /**\n     * Defines a VAR initialization.\n     */\n    void defineVar(Node n, Node parent) {\n      assertDefinitionNode(n, Token.VAR);\n      JSDocInfo info = n.getJSDocInfo();\n      if (n.hasMoreThanOneChild()) {\n        if (info != null) {\n          // multiple children\n          compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n        }\n        for (Node name : n.children()) {\n          defineName(name, n, parent, name.getJSDocInfo());\n        }\n      } else {\n        Node name = n.getFirstChild();\n        defineName(name, n, parent,\n            (info != null) ? info : name.getJSDocInfo());\n      }\n    }\n\n    /**\n     * Defines a function literal.\n     */\n    void defineFunctionLiteral(Node n, Node parent) {\n      assertDefinitionNode(n, Token.FUNCTION);\n\n      // Determine the name and JSDocInfo and lvalue for the function.\n      // Any of these may be null.\n      Node lValue = getBestLValue(n);\n      JSDocInfo info = getBestJSDocInfo(n);\n      String functionName = getBestLValueName(lValue);\n      FunctionType functionType =\n          createFunctionTypeFromNodes(n, functionName, info, lValue);\n\n      // Assigning the function type to the function node\n      setDeferredType(n, functionType);\n\n      // Declare this symbol in the current scope iff it's a function\n      // declaration. Otherwise, the declaration will happen in other\n      // code paths.\n      if (NodeUtil.isFunctionDeclaration(n)) {\n        defineSlot(n.getFirstChild(), n, functionType);\n      }\n    }\n\n    /**\n     * Defines a variable based on the {@link Token#NAME} node passed.\n     * @param name The {@link Token#NAME} node.\n     * @param var The parent of the {@code name} node, which must be a\n     *     {@link Token#VAR} node.\n     * @param parent {@code var}'s parent.\n     * @param info the {@link JSDocInfo} information relating to this\n     *     {@code name} node.\n     */\n    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n      Node value = name.getFirstChild();\n\n      // variable's type\n      JSType type = getDeclaredType(sourceName, info, name, value);\n      if (type == null) {\n        // The variable's type will be inferred.\n        CompilerInput input = compiler.getInput(sourceName);\n        Preconditions.checkNotNull(input, sourceName);\n        type = input.isExtern() ?\n            getNativeType(UNKNOWN_TYPE) : null;\n      }\n      defineSlot(name, var, type);\n    }\n\n    /**\n     * If a variable is assigned a function literal in the global scope,\n     * make that a declared type (even if there's no doc info).\n     * There's only one exception to this rule:\n     * if the return type is inferred, and we're in a local\n     * scope, we should assume the whole function is inferred.\n     */\n    private boolean shouldUseFunctionLiteralType(\n        FunctionType type, JSDocInfo info, Node lValue) {\n      if (info != null) {\n        return true;\n      }\n      if (lValue != null &&\n          NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {\n        return false;\n      }\n      return scope.isGlobal() || !type.isReturnTypeInferred();\n    }\n\n    /**\n     * Creates a new function type, based on the given nodes.\n     *\n     * This handles two cases that are semantically very different, but\n     * are not mutually exclusive:\n     * - A function literal that needs a type attached to it.\n     * - An assignment expression with function-type info in the jsdoc.\n     *\n     * All parameters are optional, and we will do the best we can to create\n     * a function type.\n     *\n     * This function will always create a function type, so only call it if\n     * you're sure that's what you want.\n     *\n     * @param rValue The function node.\n     * @param name the function's name\n     * @param info the {@link JSDocInfo} attached to the function definition\n     * @param lvalueNode The node where this function is being\n     *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n     *     determine that this function is a method of A.prototype. May be\n     *     null to indicate that this is not being assigned to a qualified name.\n     */\n    private FunctionType createFunctionTypeFromNodes(\n        @Nullable Node rValue,\n        @Nullable String name,\n        @Nullable JSDocInfo info,\n        @Nullable Node lvalueNode) {\n\n      FunctionType functionType = null;\n\n      // Global ctor aliases should be registered with the type registry.\n      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n          FunctionType aliasedType  = (FunctionType) var.getType();\n          if ((aliasedType.isConstructor() || aliasedType.isInterface()) &&\n              !aliasedType.isNativeObjectType()) {\n            functionType = aliasedType;\n\n            if (name != null && scope.isGlobal()) {\n              typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n          }\n        }\n      }\n\n      if (functionType == null) {\n        Node errorRoot = rValue == null ? lvalueNode : rValue;\n        boolean isFnLiteral =\n            rValue != null && rValue.getType() == Token.FUNCTION;\n        Node fnRoot = isFnLiteral ? rValue : null;\n        Node parametersNode = isFnLiteral ?\n            rValue.getFirstChild().getNext() : null;\n        Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n\n        if (info != null && info.hasType()) {\n          JSType type = info.getType().evaluate(scope, typeRegistry);\n\n          // Known to be not null since we have the FUNCTION token there.\n          type = type.restrictByNotNullOrUndefined();\n          if (type.isFunctionType()) {\n            functionType = (FunctionType) type;\n            functionType.setJSDocInfo(info);\n          }\n        }\n\n        if (functionType == null) {\n          // Find the type of any overridden function.\n          FunctionType overriddenPropType = null;\n          if (lvalueNode != null &&\n              lvalueNode.getType() == Token.GETPROP &&\n              lvalueNode.isQualifiedName()) {\n            Var var = scope.getVar(\n                lvalueNode.getFirstChild().getQualifiedName());\n            if (var != null) {\n              ObjectType ownerType = ObjectType.cast(var.getType());\n              if (ownerType != null) {\n                String propName = lvalueNode.getLastChild().getString();\n                overriddenPropType =\n                    findOverriddenFunction(ownerType, propName);\n              }\n            }\n          }\n\n          FunctionTypeBuilder builder =\n              new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                  scope)\n              .setSourceNode(fnRoot)\n              .inferFromOverriddenFunction(overriddenPropType, parametersNode)\n              .inferTemplateTypeName(info)\n              .inferReturnType(info)\n              .inferInheritance(info);\n\n          // Infer the context type.\n          boolean searchedForThisType = false;\n          if (lvalueNode != null &&\n              lvalueNode.getType() == Token.GETPROP) {\n            Node objNode = lvalueNode.getFirstChild();\n            if (objNode.getType() == Token.GETPROP &&\n                objNode.getLastChild().getString().equals(\"prototype\")) {\n              builder.inferThisType(info, objNode.getFirstChild());\n              searchedForThisType = true;\n            } else if (objNode.getType() == Token.THIS) {\n              builder.inferThisType(info, objNode.getJSType());\n              searchedForThisType = true;\n            }\n          }\n\n          if (!searchedForThisType) {\n            builder.inferThisType(info, (Node) null);\n          }\n\n          functionType = builder\n              .inferParameterTypes(parametersNode, info)\n              .inferReturnStatementsAsLastResort(fnBlock)\n              .buildAndRegister();\n        }\n      }\n\n      // all done\n      return functionType;\n    }\n\n    /**\n     * Find the function that's being overridden on this type, if any.\n     */\n    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName) {\n      // First, check to see if the property is implemented\n      // on a superclass.\n      JSType propType = ownerType.getPropertyType(propName);\n      if (propType instanceof FunctionType) {\n        return (FunctionType) propType;\n      } else {\n        // If it's not, then check to see if it's implemented\n        // on an implemented interface.\n        for (ObjectType iface :\n                 ownerType.getCtorImplementedInterfaces()) {\n          propType = iface.getPropertyType(propName);\n          if (propType instanceof FunctionType) {\n            return (FunctionType) propType;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    /**\n     * Creates a new enum type, based on the given nodes.\n     *\n     * This handles two cases that are semantically very different, but\n     * are not mutually exclusive:\n     * - An object literal that needs an enum type attached to it.\n     * - An assignment expression with an enum tag in the jsdoc.\n     *\n     * This function will always create an enum type, so only call it if\n     * you're sure that's what you want.\n     *\n     * @param rValue The node of the enum.\n     * @param name The enum's name\n     * @param info The {@link JSDocInfo} attached to the enum definition.\n     * @param lvalueNode The node where this function is being\n     *     assigned.\n     */\n    private EnumType createEnumTypeFromNodes(Node rValue, String name,\n        JSDocInfo info, Node lValueNode) {\n      Preconditions.checkNotNull(info);\n      Preconditions.checkState(info.hasEnumParameterType());\n\n      EnumType enumType = null;\n      if (rValue != null && rValue.isQualifiedName()) {\n        // Handle an aliased enum.\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof EnumType) {\n          enumType = (EnumType) var.getType();\n        }\n      }\n\n      if (enumType == null) {\n        JSType elementsType =\n            info.getEnumParameterType().evaluate(scope, typeRegistry);\n        enumType = typeRegistry.createEnumType(name, elementsType);\n\n        if (rValue != null && rValue.getType() == Token.OBJECTLIT) {\n          // collect enum elements\n          Node key = rValue.getFirstChild();\n          while (key != null) {\n            String keyName = NodeUtil.getStringValue(key);\n            if (keyName == null) {\n              // GET and SET don't have a String value;\n              compiler.report(\n                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n            } else if (enumType.hasOwnProperty(keyName)) {\n              compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n            } else if (!codingConvention.isValidEnumKey(keyName)) {\n              compiler.report(\n                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n            } else {\n              enumType.defineElement(keyName, key);\n            }\n            key = key.getNext();\n          }\n        }\n      }\n\n      if (name != null && scope.isGlobal()) {\n        typeRegistry.declareType(name, enumType.getElementsType());\n      }\n\n      return enumType;\n    }\n\n    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type or {@code null} if its type is inferred.\n     * @param name the defining node. It must be a {@link Token#NAME}.\n     * @param parent the {@code name}'s parent.\n     * @param type the variable's type. It may be {@code null}, in which case\n     *     the variable's type will be inferred.\n     */\n    private void defineSlot(Node name, Node parent, JSType type) {\n      defineSlot(name, parent, type, type == null);\n    }\n\n    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name in the global scope.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     */\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualfied names.\n      // Object literal keys will have to compute their names themselves.\n      if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(\n            parent.getType() == Token.FUNCTION ||\n            parent.getType() == Token.VAR ||\n            parent.getType() == Token.LP ||\n            parent.getType() == Token.CATCH);\n      } else {\n        Preconditions.checkArgument(\n            n.getType() == Token.GETPROP &&\n            (parent.getType() == Token.ASSIGN ||\n             parent.getType() == Token.EXPR_RESULT));\n      }\n      defineSlot(n, parent, n.getQualifiedName(), type, inferred);\n    }\n\n\n    /**\n     * Defines a symbol in the current scope.\n     *\n     * @param n the defining NAME or GETPROP or object literal key node.\n     * @param parent the {@code n}'s parent.\n     * @param variableName The name that this should be known by.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     * @param inferred Whether the type is inferred or declared.\n     */\n    void defineSlot(Node n, Node parent, String variableName,\n        JSType type, boolean inferred) {\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      boolean isGlobalVar = n.getType() == Token.NAME && scope.isGlobal();\n      boolean shouldDeclareOnGlobalThis =\n          isGlobalVar &&\n          (parent.getType() == Token.VAR ||\n           parent.getType() == Token.FUNCTION);\n\n      // If n is a property, then we should really declare it in the\n      // scope where the root object appears. This helps out people\n      // who declare \"global\" names in an anonymous namespace.\n      Scope scopeToDeclareIn = scope;\n      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n          isQnameRootedInGlobalScope(n)) {\n        Scope globalScope = scope.getGlobalScope();\n\n        // don't try to declare in the global scope if there's\n        // already a symbol there with this name.\n        if (!globalScope.isDeclared(variableName, false)) {\n          scopeToDeclareIn = scope.getGlobalScope();\n        }\n      }\n\n      // declared in closest scope?\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(\n            sourceName, n, parent, oldVar, variableName, type);\n      } else {\n        if (!inferred) {\n          setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        boolean isExtern = input.isExtern();\n        Var newVar =\n            scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        if (shouldDeclareOnGlobalThis) {\n          ObjectType globalThis =\n              typeRegistry.getNativeObjectType(GLOBAL_THIS);\n          if (inferred) {\n            globalThis.defineInferredProperty(variableName,\n                type == null ?\n                    getNativeType(JSTypeNative.NO_TYPE) :\n                    type,\n                isExtern, n);\n          } else {\n            globalThis.defineDeclaredProperty(variableName, type, isExtern, n);\n          }\n        }\n\n        if (type instanceof EnumType) {\n          Node initialValue = newVar.getInitialValue();\n          boolean isValidValue = initialValue != null &&\n              (initialValue.getType() == Token.OBJECTLIT ||\n               initialValue.isQualifiedName());\n          if (!isValidValue) {\n            compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n          }\n        }\n\n        // We need to do some additional work for constructors and interfaces.\n        if (type instanceof FunctionType &&\n            // We don't want to look at empty function types.\n            !type.isEmptyType()) {\n          FunctionType fnType = (FunctionType) type;\n          if ((fnType.isConstructor() || fnType.isInterface()) &&\n              !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n            // Declare var.prototype in the scope chain.\n            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n                fnType.getPrototype(), input,\n                /* declared iff there's an explicit supertype */\n                superClassCtor == null ||\n                superClassCtor.getInstanceType().equals(\n                    getNativeType(OBJECT_TYPE)));\n\n            // Make sure the variable is initialized to something if\n            // it constructs itself.\n            if (newVar.getInitialValue() == null &&\n                !isExtern &&\n                // We want to make sure that when we declare a new instance\n                // type (with @constructor) that there's actually a ctor for it.\n                // This doesn't apply to structural constructors\n                // (like function(new:Array). Checking the constructed\n                // type against the variable name is a sufficient check for\n                // this.\n                variableName.equals(\n                    fnType.getInstanceType().getReferenceName())) {\n              compiler.report(\n                  JSError.make(sourceName, n,\n                      fnType.isConstructor() ?\n                          CTOR_INITIALIZER : IFACE_INITIALIZER,\n                      variableName));\n            }\n          }\n        }\n      }\n\n      if (isGlobalVar && \"Window\".equals(variableName)\n          && type instanceof FunctionType\n          && type.isConstructor()) {\n        FunctionType globalThisCtor =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor();\n        globalThisCtor.getInstanceType().clearCachedValues();\n        globalThisCtor.getPrototype().clearCachedValues();\n        globalThisCtor\n            .setPrototypeBasedOn(((FunctionType) type).getInstanceType());\n      }\n    }\n\n    /**\n     * Check if the given node is a property of a name in the global scope.\n     */\n    private boolean isQnameRootedInGlobalScope(Node n) {\n      Node root = NodeUtil.getRootOfQualifiedName(n);\n      if (root.getType() == Token.NAME) {\n        Var var = scope.getVar(root.getString());\n        if (var != null) {\n          return var.isGlobal();\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      } else if (rValue != null && rValue.getType() == Token.FUNCTION &&\n          shouldUseFunctionLiteralType(\n              (FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n      } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.getType() == Token.OBJECTLIT) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n          // Check if this is constant, and if it has a known type.\n          if (info.isConstant()) {\n            JSType knownType = null;\n            if (rValue != null) {\n              if (rValue.getJSType() != null\n                  && !rValue.getJSType().isUnknownType()) {\n                return rValue.getJSType();\n              } else if (rValue.getType() == Token.OR) {\n                // Check for a very specific JS idiom:\n                // var x = x || TYPE;\n                // This is used by Closure's base namespace for esoteric\n                // reasons.\n                Node firstClause = rValue.getFirstChild();\n                Node secondClause = firstClause.getNext();\n                boolean namesMatch = firstClause.getType() == Token.NAME\n                    && lValue.getType() == Token.NAME\n                    && firstClause.getString().equals(lValue.getString());\n                if (namesMatch && secondClause.getJSType() != null\n                    && !secondClause.getJSType().isUnknownType()) {\n                  return secondClause.getJSType();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }\n\n    /**\n     * Look for class-defining calls.\n     * Because JS has no 'native' syntax for defining classes,\n     * this is often very coding-convention dependent and business-logic heavy.\n     */\n    private void checkForClassDefiningCalls(\n        NodeTraversal t, Node n, Node parent) {\n      SubclassRelationship relationship =\n          codingConvention.getClassesDefinedByCall(n);\n      if (relationship != null) {\n        ObjectType superClass = ObjectType.cast(\n            typeRegistry.getType(relationship.superclassName));\n        ObjectType subClass = ObjectType.cast(\n            typeRegistry.getType(relationship.subclassName));\n        if (superClass != null && subClass != null) {\n          FunctionType superCtor = superClass.getConstructor();\n          FunctionType subCtor = subClass.getConstructor();\n\n          if (relationship.type == SubclassType.INHERITS) {\n            validator.expectSuperType(t, n, superClass, subClass);\n          }\n\n          if (superCtor != null && subCtor != null) {\n            codingConvention.applySubclassRelationship(\n                superCtor, subCtor, relationship.type);\n          }\n        }\n      }\n\n      String singletonGetterClassName =\n          codingConvention.getSingletonGetterClassName(n);\n      if (singletonGetterClassName != null) {\n        ObjectType objectType = ObjectType.cast(\n            typeRegistry.getType(singletonGetterClassName));\n        if (objectType != null) {\n          FunctionType functionType = objectType.getConstructor();\n\n          if (functionType != null) {\n            FunctionType getterType =\n                typeRegistry.createFunctionType(objectType);\n            codingConvention.applySingletonGetter(functionType, getterType,\n                objectType);\n          }\n        }\n      }\n\n      DelegateRelationship delegateRelationship =\n          codingConvention.getDelegateRelationship(n);\n      if (delegateRelationship != null) {\n        applyDelegateRelationship(delegateRelationship);\n      }\n\n      ObjectLiteralCast objectLiteralCast =\n          codingConvention.getObjectLiteralCast(t, n);\n      if (objectLiteralCast != null) {\n        ObjectType type = ObjectType.cast(\n            typeRegistry.getType(objectLiteralCast.typeName));\n        if (type != null && type.getConstructor() != null) {\n          setDeferredType(objectLiteralCast.objectNode, type);\n        } else {\n          compiler.report(JSError.make(t.getSourceName(), n,\n                  CONSTRUCTOR_EXPECTED));\n        }\n      }\n    }\n\n    /**\n     * Apply special properties that only apply to delegates.\n     */\n    private void applyDelegateRelationship(\n        DelegateRelationship delegateRelationship) {\n      ObjectType delegatorObject = ObjectType.cast(\n          typeRegistry.getType(delegateRelationship.delegator));\n      ObjectType delegateBaseObject = ObjectType.cast(\n          typeRegistry.getType(delegateRelationship.delegateBase));\n      ObjectType delegateSuperObject = ObjectType.cast(\n          typeRegistry.getType(codingConvention.getDelegateSuperclassName()));\n      if (delegatorObject != null &&\n          delegateBaseObject != null &&\n          delegateSuperObject != null) {\n        FunctionType delegatorCtor = delegatorObject.getConstructor();\n        FunctionType delegateBaseCtor = delegateBaseObject.getConstructor();\n        FunctionType delegateSuperCtor = delegateSuperObject.getConstructor();\n\n        if (delegatorCtor != null && delegateBaseCtor != null &&\n            delegateSuperCtor != null) {\n          FunctionParamBuilder functionParamBuilder =\n              new FunctionParamBuilder(typeRegistry);\n          functionParamBuilder.addRequiredParams(\n              getNativeType(U2U_CONSTRUCTOR_TYPE));\n          FunctionType findDelegate = typeRegistry.createFunctionType(\n              typeRegistry.createDefaultObjectUnion(delegateBaseObject),\n              functionParamBuilder.build());\n\n          FunctionType delegateProxy = typeRegistry.createConstructorType(\n              delegateBaseObject.getReferenceName() + DELEGATE_PROXY_SUFFIX,\n              null, null, null);\n          delegateProxy.setPrototypeBasedOn(delegateBaseObject);\n\n          codingConvention.applyDelegateRelationship(\n              delegateSuperObject, delegateBaseObject, delegatorObject,\n              delegateProxy, findDelegate);\n          delegateProxyPrototypes.add(delegateProxy.getPrototype());\n        }\n      }\n    }\n\n    /**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          if (!qVar.isTypeInferred()) {\n            // Just ignore assigns to declared prototypes.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            !scope.isDeclared(qName, false));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, isExtern, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType instanceof FunctionType) {\n          JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),\n                true);\n          }\n        }\n      }\n    }\n\n    /**\n     * Find the ObjectType associated with the given slot.\n     * @param slotName The name of the slot to find the type in.\n     * @return An object type, or null if this slot does not contain an object.\n     */\n    private ObjectType getObjectSlot(String slotName) {\n      Var ownerVar = scope.getVar(slotName);\n      if (ownerVar != null) {\n        JSType ownerVarType = ownerVar.getType();\n        return ObjectType.cast(ownerVarType == null ?\n            null : ownerVarType.restrictByNotNullOrUndefined());\n      }\n      return null;\n    }\n\n    /**\n     * Resolve any stub delcarations to unknown types if we could not\n     * find types for them during traversal.\n     */\n    void resolveStubDeclarations() {\n      for (StubDeclaration stub : stubDeclarations) {\n        Node n = stub.node;\n        Node parent = n.getParent();\n        String qName = n.getQualifiedName();\n        String propName = n.getLastChild().getString();\n        String ownerName = stub.ownerName;\n        boolean isExtern = stub.isExtern;\n\n        if (scope.isDeclared(qName, false)) {\n          continue;\n        }\n\n        // If we see a stub property, make sure to register this property\n        // in the type registry.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n        defineSlot(n, parent, unknownType, true);\n\n        if (ownerType != null &&\n            (isExtern || ownerType.isFunctionPrototypeType())) {\n          // If this is a stub for a prototype, just declare it\n          // as an unknown type. These are seen often in externs.\n          ownerType.defineInferredProperty(\n              propName, unknownType, isExtern, n);\n        } else {\n          typeRegistry.registerPropertyOnType(\n              propName, ownerType == null ? unknownType : ownerType);\n        }\n      }\n    }\n\n    /**\n     * Collects all declared properties in a function, and\n     * resolves them relative to the global scope.\n     */\n    private final class CollectProperties\n        extends AbstractShallowStatementCallback {\n      private final ObjectType thisType;\n\n      CollectProperties(ObjectType thisType) {\n        this.thisType = thisType;\n      }\n\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.getType() == Token.EXPR_RESULT) {\n          Node child = n.getFirstChild();\n          switch (child.getType()) {\n            case Token.ASSIGN:\n              maybeCollectMember(t, child.getFirstChild(), child,\n                  child.getLastChild());\n              break;\n            case Token.GETPROP:\n              maybeCollectMember(t, child, child, null);\n              break;\n          }\n        }\n      }\n\n      private void maybeCollectMember(NodeTraversal t,\n          Node member, Node nodeWithJsDocInfo, @Nullable Node value) {\n        JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo();\n\n        // Do nothing if there is no JSDoc type info, or\n        // if the node is not a member expression, or\n        // if the member expression is not of the form: this.someProperty.\n        if (info == null ||\n            member.getType() != Token.GETPROP ||\n            member.getFirstChild().getType() != Token.THIS) {\n          return;\n        }\n\n        member.getFirstChild().setJSType(thisType);\n        JSType jsType = getDeclaredType(t.getSourceName(), info, member, value);\n        Node name = member.getLastChild();\n        if (jsType != null &&\n            (name.getType() == Token.NAME || name.getType() == Token.STRING)) {\n          thisType.defineDeclaredProperty(\n              name.getString(),\n              jsType,\n              false /* functions with implementations are not in externs */,\n              member);\n        }\n      }\n    } // end CollectProperties\n  }\n\n  /**\n   * A stub declaration without any type information.\n   */\n  private static final class StubDeclaration {\n    private final Node node;\n    private final boolean isExtern;\n    private final String ownerName;\n\n    private StubDeclaration(Node node, boolean isExtern, String ownerName) {\n      this.node = node;\n      this.isExtern = isExtern;\n      this.ownerName = ownerName;\n    }\n  }\n\n  /**\n   * A shallow traversal of the global scope to build up all classes,\n   * functions, and methods.\n   */\n  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n\n    private GlobalScopeBuilder(Scope scope) {\n      super(scope);\n    }\n\n    /**\n     * Visit a node in the global scope, and add anything it declares to the\n     * global symbol table.\n     *\n     * @param t The current traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      super.visit(t, n, parent);\n\n      switch (n.getType()) {\n\n        case Token.ASSIGN:\n          // Handle typedefs.\n          checkForOldStyleTypedef(t, n);\n          break;\n\n        case Token.VAR:\n          // Handle typedefs.\n          if (n.hasOneChild()) {\n            checkForOldStyleTypedef(t, n);\n            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n          }\n          break;\n      }\n    }\n\n    @Override\n    void maybeDeclareQualifiedName(\n        NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      checkForTypedef(t, n, info);\n      super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n    }\n\n    /**\n     * Handle typedefs.\n     * @param t The current traversal.\n     * @param candidate A qualified name node.\n     * @param info JSDoc comments.\n     */\n    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n      if (info == null || !info.hasTypedefType()) {\n        return;\n      }\n\n      String typedef = candidate.getQualifiedName();\n      if (typedef == null) {\n        return;\n      }\n\n      // TODO(nicksantos|user): This is a terrible, terrible hack\n      // to bail out on recusive typedefs. We'll eventually need\n      // to handle these properly.\n      typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));\n\n      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n      if (realType == null) {\n        compiler.report(\n            JSError.make(\n                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n      }\n\n      typeRegistry.overwriteDeclaredType(typedef, realType);\n      if (candidate.getType() == Token.GETPROP) {\n        defineSlot(candidate, candidate.getParent(),\n            getNativeType(NO_TYPE), false);\n      }\n    }\n\n    /**\n     * Handle typedefs.\n     * @param t The current traversal.\n     * @param candidate An ASSIGN or VAR node.\n     */\n    // TODO(nicksantos): Kill this.\n    private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {\n      // old-style typedefs\n      String typedef = codingConvention.identifyTypeDefAssign(candidate);\n      if (typedef != null) {\n        // TODO(nicksantos|user): This is a terrible, terrible hack\n        // to bail out on recusive typedefs. We'll eventually need\n        // to handle these properly.\n        typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));\n\n        JSDocInfo info = candidate.getJSDocInfo();\n        JSType realType = null;\n        if (info != null && info.getType() != null) {\n          realType = info.getType().evaluate(scope, typeRegistry);\n        }\n\n        if (realType == null) {\n          compiler.report(\n              JSError.make(\n                  t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n        }\n\n        typeRegistry.overwriteDeclaredType(typedef, realType);\n\n        // Duplicate typedefs get handled when we try to register\n        // this typedef in the scope.\n      }\n    }\n  } // end GlobalScopeBuilder\n\n  /**\n   * A shallow traversal of a local scope to find all arguments and\n   * local variables.\n   */\n  private final class LocalScopeBuilder extends AbstractScopeBuilder {\n    /**\n     * @param scope The scope that we're builidng.\n     */\n    private LocalScopeBuilder(Scope scope) {\n      super(scope);\n    }\n\n    /**\n     * Traverse the scope root and build it.\n     */\n    void build() {\n      NodeTraversal.traverse(compiler, scope.getRootNode(), this);\n    }\n\n    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      super.visit(t, n, parent);\n    }\n\n    /** Handle bleeding functions and function parameters. */\n    private void handleFunctionInputs(Node fnNode) {\n      // Handle bleeding functions.\n      Node fnNameNode = fnNode.getFirstChild();\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty()) {\n        Scope.Var fnVar = scope.getVar(fnName);\n        if (fnVar == null ||\n            // Make sure we're not touching a native function. Native\n            // functions aren't bleeding, but may not have a declaration\n            // node.\n            (fnVar.getNameNode() != null &&\n                // Make sure that the function is actually bleeding by checking\n                // if has already been declared.\n                fnVar.getInitialValue() != fnNode)) {\n          defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n        }\n      }\n\n      declareArguments(fnNode);\n    }\n\n    /**\n     * Declares all of a function's arguments.\n     */\n    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      FunctionType functionType = (FunctionType) functionNode.getJSType();\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } // end declareArguments\n  } // end LocalScopeBuilder\n\n\n  /** Find the best JSDoc for the given node. */\n  static JSDocInfo getBestJSDocInfo(Node n) {\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      Node parent = n.getParent();\n      int parentType = parent.getType();\n      if (parentType == Token.NAME) {\n        info = parent.getJSDocInfo();\n        if (info == null && parent.getParent().hasOneChild()) {\n          info = parent.getParent().getJSDocInfo();\n        }\n      } else if (parentType == Token.ASSIGN) {\n        info = parent.getJSDocInfo();\n      } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {\n        info = parent.getJSDocInfo();\n      }\n    }\n    return info;\n  }\n\n  /** Find the l-value that the given r-value is being assigned to. */\n  private static Node getBestLValue(Node n) {\n    Node parent = n.getParent();\n    int parentType = parent.getType();\n    boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(n);\n    if (isFunctionDeclaration) {\n      return n.getFirstChild();\n    } else if (parentType == Token.NAME) {\n      return parent;\n    } else if (parentType == Token.ASSIGN) {\n      return parent.getFirstChild();\n    } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {\n      return parent;\n    }\n    return null;\n  }\n\n  /** Get the name of the given l-value node. */\n  private static String getBestLValueName(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {\n      Node owner = getBestLValue(lValue.getParent());\n      if (owner != null) {\n        String ownerName = getBestLValueName(owner);\n        if (ownerName != null) {\n          return ownerName + \".\" + NodeUtil.getObjectLitKeyName(lValue);\n        }\n      }\n      return null;\n    }\n    return lValue.getQualifiedName();\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"type\": \"NullPointerException\",\n      \"description\": \"The 'jsTypeRegistry' object is not initialized before it's used in the constructor of TypedScopeCreator.\"\n    },\n    {\n      \"type\": \"NullPointerException\",\n      \"description\": \"The 'errorReporter' object is not initialized before it's used in the constructor of TypedScopeCreator.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 'compilationUnit' parameter in the constructor of TypedScopeCreator is null.\"\n    },\n    {\n      \"type\": \"NullPointerException\",\n      \"description\": \"The 'jsTypeRegistry' object is not initialized before it's used in the 'createScope' method.\"\n    },\n    {\n      \"type\": \"NullPointerException\",\n      \"description\": \"The 'errorReporter' object is not initialized before it's used in the 'createScope' method.\"\n    },\n    {\n      \"type\": \"NullPointerException\",\n      \"description\": \"The 'compilationUnit' object is null when the 'createScope' method is called.\"\n    },\n    {\n      \"type\": \"IllegalStateException\",\n      \"description\": \"The 'compilationUnit' object is already visited when the 'createScope' method is called.\"\n    },\n    {\n      \"type\": \"NullPointerException\",\n      \"description\": \"The 'currentScope' object is null when the 'createScope' method is called.\"\n    },\n    {\n      \"type\": \"IllegalStateException\",\n      \"description\": \"The 'currentScope' object is not a 'FunctionScope' when the 'createScope' method is called.\"\n    },\n    {\n      \"type\": \"IllegalStateException\",\n      \"description\": \"The 'currentScope' object is not a 'BlockScope' when the 'createScope' method is called.\"\n    },\n    {\n      \"type\": \"NullPointerException\",\n      \"description\": \"The 'currentScope' object is null when the 'createVar' method is called.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 'name' parameter in the 'createVar' method is null or empty.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 'jsType' parameter in the 'createVar' method is null.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 'jsType' parameter in the 'createVar' method is not a 'FunctionType' when creating a function variable.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 'jsType' parameter in the 'createVar' method is not an 'EnumType' when creating an enum variable.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 'jsType' parameter in the 'createVar' method is not an 'ObjectType' when creating an object variable.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 'jsType' parameter in the 'createVar' method is not a 'JSType' when creating a variable with a qualified name.\"\n    },\n    {\n      \"type\": \"NullPointerException\",\n      \"description\": \"The 'currentScope' object is null when the 'createType' method is called.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 'name' parameter in the 'createType' method is null or empty.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 'jsType' parameter in the 'createType' method is null.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 'jsType' parameter in the 'createType' method is not a 'JSType' when creating a type.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 'jsType' parameter in the 'createType' method is not an 'EnumType' when creating an enum type.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 'jsType' parameter in the 'createType' method is not an 'ObjectType' when creating an object type.\"\n    }\n  ]\n}"}}