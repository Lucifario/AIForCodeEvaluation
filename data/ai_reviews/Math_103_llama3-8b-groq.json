{"sample_id": "Math_103", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.distribution;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.MaxIterationsExceededException;\nimport org.apache.commons.math.special.Erf;\n\n/**\n * Default implementation of\n * {@link org.apache.commons.math.distribution.NormalDistribution}.\n *\n * @version $Revision$ $Date$\n */\npublic class NormalDistributionImpl extends AbstractContinuousDistribution \n        implements NormalDistribution, Serializable {\n    \n    /** Serializable version identifier */\n    private static final long serialVersionUID = 8589540077390120676L;\n\n    /** The mean of this distribution. */\n    private double mean = 0;\n    \n    /** The standard deviation of this distribution. */\n    private double standardDeviation = 1;\n    \n    /**\n     * Create a normal distribution using the given mean and standard deviation.\n     * @param mean mean for this distribution\n     * @param sd standard deviation for this distribution\n     */\n    public NormalDistributionImpl(double mean, double sd){\n        super();\n        setMean(mean);\n        setStandardDeviation(sd);\n    }\n    \n    /**\n     * Creates normal distribution with the mean equal to zero and standard\n     * deviation equal to one. \n     */\n    public NormalDistributionImpl(){\n        this(0.0, 1.0);\n    }\n    \n    /**\n     * Access the mean.\n     * @return mean for this distribution\n     */ \n    public double getMean() {\n        return mean;\n    }\n    \n    /**\n     * Modify the mean.\n     * @param mean for this distribution\n     */\n    public void setMean(double mean) {\n        this.mean = mean;\n    }\n\n    /**\n     * Access the standard deviation.\n     * @return standard deviation for this distribution\n     */\n    public double getStandardDeviation() {\n        return standardDeviation;\n    }\n\n    /**\n     * Modify the standard deviation.\n     * @param sd standard deviation for this distribution\n     * @throws IllegalArgumentException if <code>sd</code> is not positive.\n     */\n    public void setStandardDeviation(double sd) {\n        if (sd <= 0.0) {\n            throw new IllegalArgumentException(\n                \"Standard deviation must be positive.\");\n        }       \n        standardDeviation = sd;\n    }\n\n    /**\n     * For this disbution, X, this method returns P(X &lt; <code>x</code>).\n     * @param x the value at which the CDF is evaluated.\n     * @return CDF evaluted at <code>x</code>. \n     * @throws MathException if the algorithm fails to converge; unless\n     * x is more than 20 standard deviations from the mean, in which case the\n     * convergence exception is caught and 0 or 1 is returned.\n     */\n    public double cumulativeProbability(double x) throws MathException {\n            return 0.5 * (1.0 + Erf.erf((x - mean) /\n                    (standardDeviation * Math.sqrt(2.0))));\n    }\n    \n    /**\n     * For this distribution, X, this method returns the critical point x, such\n     * that P(X &lt; x) = <code>p</code>.\n     * <p>\n     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n     * <code>Double.POSITIVE_INFINITY</code> for p=1.\n     *\n     * @param p the desired probability\n     * @return x, such that P(X &lt; x) = <code>p</code>\n     * @throws MathException if the inverse cumulative probability can not be\n     *         computed due to convergence or other numerical errors.\n     * @throws IllegalArgumentException if <code>p</code> is not a valid\n     *         probability.\n     */\n    public double inverseCumulativeProbability(final double p) \n    throws MathException {\n        if (p == 0) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        if (p == 1) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return super.inverseCumulativeProbability(p);\n    }\n    \n    /**\n     * Access the domain value lower bound, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return domain value lower bound, i.e.\n     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n     */\n    protected double getDomainLowerBound(double p) {\n        double ret;\n\n        if (p < .5) {\n            ret = -Double.MAX_VALUE;\n        } else {\n            ret = getMean();\n        }\n        \n        return ret;\n    }\n\n    /**\n     * Access the domain value upper bound, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return domain value upper bound, i.e.\n     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n     */\n    protected double getDomainUpperBound(double p) {\n        double ret;\n\n        if (p < .5) {\n            ret = getMean();\n        } else {\n            ret = Double.MAX_VALUE;\n        }\n        \n        return ret;\n    }\n\n    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n\n        if (p < .5) {\n            ret = getMean() - getStandardDeviation();\n        } else if (p > .5) {\n            ret = getMean() + getStandardDeviation();\n        } else {\n            ret = getMean();\n        }\n        \n        return ret;\n    }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"message\": \"The class NormalDistributionImpl does not override the abstract method inverseCumulativeProbability in class AbstractContinuousDistribution.\",\n         \"line\": 55,\n         \"column\": 12\n      },\n      {\n         \"message\": \"The method getDomainLowerBound(double) in the type NormalDistributionImpl must override a method from its superclass.\",\n         \"line\": 173,\n         \"column\": 5\n      },\n      {\n         \"message\": \"The method getDomainUpperBound(double) in the type NormalDistributionImpl must override a method from its superclass.\",\n         \"line\": 193,\n         \"column\": 5\n      },\n      {\n         \"message\": \"The method getInitialDomainValue(double) in the type NormalDistributionImpl must override a method from its superclass.\",\n         \"line\": 213,\n         \"column\": 5\n      },\n      {\n         \"message\": \"The method cumulativeProbability(double) in the type NormalDistributionImpl does not handle the case where x is more than 20 standard deviations from the mean, it should return 0 or 1 in this case.\",\n         \"line\": 105,\n         \"column\": 5\n      }\n   ]\n}"}}