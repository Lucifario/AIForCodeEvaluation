{
  "source_item_id": 137120,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:40:39.080160",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0; you may not use this file except in compliance with the Elastic License\n * 2.0.\n */\npackage org.elasticsearch.xpack.core.ilm;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.elasticsearch.TransportVersions;\nimport org.elasticsearch.action.admin.indices.shrink.ResizeType;\nimport org.elasticsearch.client.internal.Client;\nimport org.elasticsearch.cluster.health.ClusterHealthStatus;\nimport org.elasticsearch.cluster.metadata.IndexAbstraction;\nimport org.elasticsearch.cluster.metadata.IndexMetadata;\nimport org.elasticsearch.cluster.metadata.LifecycleExecutionState;\nimport org.elasticsearch.common.Strings;\nimport org.elasticsearch.common.io.stream.StreamInput;\nimport org.elasticsearch.common.io.stream.StreamOutput;\nimport org.elasticsearch.common.settings.Settings;\nimport org.elasticsearch.core.Nullable;\nimport org.elasticsearch.core.TimeValue;\nimport org.elasticsearch.license.LicenseUtils;\nimport org.elasticsearch.license.XPackLicenseState;\nimport org.elasticsearch.xcontent.ConstructingObjectParser;\nimport org.elasticsearch.xcontent.ObjectParser;\nimport org.elasticsearch.xcontent.ParseField;\nimport org.elasticsearch.xcontent.XContentBuilder;\nimport org.elasticsearch.xcontent.XContentParser;\nimport org.elasticsearch.xpack.core.ilm.Step.StepKey;\nimport org.elasticsearch.xpack.core.searchablesnapshots.MountSearchableSnapshotRequest;\n\nimport java.io.IOException;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport static org.elasticsearch.snapshots.SearchableSnapshotsSettings.SEARCHABLE_SNAPSHOTS_REPOSITORY_NAME_SETTING_KEY;\nimport static org.elasticsearch.snapshots.SearchableSnapshotsSettings.SEARCHABLE_SNAPSHOTS_SNAPSHOT_NAME_SETTING_KEY;\nimport static org.elasticsearch.snapshots.SearchableSnapshotsSettings.SEARCHABLE_SNAPSHOT_PARTIAL_SETTING_KEY;\nimport static org.elasticsearch.xpack.core.searchablesnapshots.SearchableSnapshotsConstants.SEARCHABLE_SNAPSHOT_FEATURE;\n\n/**\n * A {@link LifecycleAction} that will convert the index into a searchable snapshot, by taking a snapshot of the index, creating a\n * searchable snapshot and the corresponding \"searchable snapshot index\", deleting the original index and swapping its aliases to the\n * newly created searchable snapshot backed index.\n */\npublic class SearchableSnapshotAction implements LifecycleAction {\n    private static final Logger logger = LogManager.getLogger(SearchableSnapshotAction.class);\n\n    public static final String NAME = \"searchable_snapshot\";\n\n    public static final ParseField SNAPSHOT_REPOSITORY = new ParseField(\"snapshot_repository\");\n    public static final ParseField FORCE_MERGE_INDEX = new ParseField(\"force_merge_index\");\n    public static final ParseField TOTAL_SHARDS_PER_NODE = new ParseField(\"total_shards_per_node\");\n    public static final ParseField REPLICATE_FOR = new ParseField(\"replicate_for\");\n    public static final String CONDITIONAL_SKIP_ACTION_STEP = BranchingStep.NAME + \"-check-prerequisites\";\n    public static final String CONDITIONAL_SKIP_GENERATE_AND_CLEAN = BranchingStep.NAME + \"-check-existing-snapshot\";\n    public static final String CONDITIONAL_SKIP_CLONE_STEP = BranchingStep.NAME + \"-skip-clone-check\";\n    public static final String WAIT_FOR_CLONED_INDEX_GREEN = WaitForIndexColorStep.NAME + \"-cloned-index\";\n    public static final String CONDITIONAL_DATASTREAM_CHECK_KEY = BranchingStep.NAME + \"-on-datastream-check\";\n    public static final String CONDITIONAL_DELETE_FORCE_MERGED_INDEX_KEY = BranchingStep.NAME + \"-delete-force-merged-index\";\n    public static final String DELETE_FORCE_MERGED_INDEX_KEY = DeleteStep.NAME + \"-force-merged-index\";\n\n    public static final String FULL_RESTORED_INDEX_PREFIX = \"restored-\";\n    public static final String PARTIAL_RESTORED_INDEX_PREFIX = \"partial-\";\n    public static final String FORCE_MERGE_CLONE_INDEX_PREFIX = \"fm-clone-\";\n    /** An index name supplier that always returns the force merge index name (possibly null). */\n    public static final BiFunction<String, LifecycleExecutionState, String> FORCE_MERGE_CLONE_INDEX_NAME_SUPPLIER = (\n        indexName,\n        state) -> state.forceMergeCloneIndexName();\n    /** An index name supplier that returns the force merge index name if it exists, or the original index name if not. */\n    public static final BiFunction<String, LifecycleExecutionState, String> FORCE_MERGE_CLONE_INDEX_NAME_FALLBACK_SUPPLIER = (\n        indexName,\n        state) -> state.forceMergeCloneIndexName() != null ? state.forceMergeCloneIndexName() : indexName;\n\n    private static final Settings CLONE_SETTINGS = Settings.builder().put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0).build();\n    private static final Function<IndexMetadata, Settings> CLONE_SETTINGS_SUPPLIER = indexMetadata -> CLONE_SETTINGS;\n\n    private static final ConstructingObjectParser<SearchableSnapshotAction, Void> PARSER = new ConstructingObjectParser<>(\n        NAME,\n        a -> new SearchableSnapshotAction((String) a[0], a[1] == null || (boolean) a[1], (Integer) a[2], (TimeValue) a[3])\n    );\n\n    static {\n        PARSER.declareString(ConstructingObjectParser.constructorArg(), SNAPSHOT_REPOSITORY);\n        PARSER.declareBoolean(ConstructingObjectParser.optionalConstructorArg(), FORCE_MERGE_INDEX);\n        PARSER.declareInt(ConstructingObjectParser.optionalConstructorArg(), TOTAL_SHARDS_PER_NODE);\n        PARSER.declareField(\n            ConstructingObjectParser.optionalConstructorArg(),\n            p -> TimeValue.parseTimeValue(p.textOrNull(), REPLICATE_FOR.getPreferredName()),\n            REPLICATE_FOR,\n            ObjectParser.ValueType.STRING\n        );\n    }\n\n    public static SearchableSnapshotAction parse(XContentParser parser) {\n        return PARSER.apply(parser, null);\n    }\n\n    private final String snapshotRepository;\n    private final boolean forceMergeIndex;\n    @Nullable\n    private final Integer totalShardsPerNode;\n    @Nullable\n    private final TimeValue replicateFor;\n\n    public SearchableSnapshotAction(\n        String snapshotRepository,\n        boolean forceMergeIndex,\n        @Nullable Integer totalShardsPerNode,\n        @Nullable TimeValue replicateFor\n    ) {\n        if (Strings.hasText(snapshotRepository) == false) {\n            throw new IllegalArgumentException(\"the snapshot repository must be specified\");\n        }\n        this.snapshotRepository = snapshotRepository;\n        this.forceMergeIndex = forceMergeIndex;\n\n        if (totalShardsPerNode != null && totalShardsPerNode < 1) {\n            throw new IllegalArgumentException(\"[\" + TOTAL_SHARDS_PER_NODE.getPreferredName() + \"] must be >= 1\");\n        }\n        this.totalShardsPerNode = totalShardsPerNode;\n\n        if (replicateFor != null && replicateFor.millis() <= 0) {\n            throw new IllegalArgumentException(\n                \"[\" + REPLICATE_FOR.getPreferredName() + \"] must be positive [\" + replicateFor.getStringRep() + \"]\"\n            );\n        }\n        this.replicateFor = replicateFor;\n    }\n\n    public SearchableSnapshotAction(String snapshotRepository, boolean forceMergeIndex) {\n        this(snapshotRepository, forceMergeIndex, null, null);\n    }\n\n    public SearchableSnapshotAction(String snapshotRepository) {\n        this(snapshotRepository, true, null, null);\n    }\n\n    public SearchableSnapshotAction(StreamInput in) throws IOException {\n        this.snapshotRepository = in.readString();\n        this.forceMergeIndex = in.readBoolean();\n        this.totalShardsPerNode = in.getTransportVersion().onOrAfter(TransportVersions.V_8_16_0) ? in.readOptionalInt() : null;\n        this.replicateFor = in.getTransportVersion().supports(TransportVersions.V_8_18_0) ? in.readOptionalTimeValue() : null;\n    }\n\n    boolea",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The constructor SearchableSnapshotAction(String snapshotRepository, boolean forceMergeIndex) is missing the required parameters totalShardsPerNode and replicateFor, which are not null in the other constructors.\",\n         \"suggested_fix\": \"Add default values for totalShardsPerNode and replicateFor to the constructor SearchableSnapshotAction(String snapshotRepository, boolean forceMergeIndex):\\npublic SearchableSnapshotAction(String snapshotRepository, boolean forceMergeIndex) {\\n    this(snapshotRepository, forceMergeIndex, 1, null);\\n}\"\n      },\n      {\n         \"explanation\": \"The constructor SearchableSnapshotAction(String snapshotRepository) is missing the required parameters totalShardsPerNode and replicateFor, which are not null in the other constructors.\",\n         \"suggested_fix\": \"Add default values for totalShardsPerNode and replicateFor to the constructor SearchableSnapshotAction(String snapshotRepository):\\npublic SearchableSnapshotAction(String snapshotRepository) {\\n    this(snapshotRepository, true, 1, null);\\n}\"\n      },\n      {\n         \"explanation\": \"The method parse(XContentParser parser) does not handle the case where the input is not a valid XContentParser.\",\n         \"suggested_fix\": \"Add a try-catch block to handle the IOException that may be thrown by the XContentParser:\\npublic static SearchableSnapshotAction parse(XContentParser parser) {\\n    try {\\n        return PARSER.apply(parser, null);\\n    } catch (IOException e) {\\n        // handle the exception\\n    }\\n}\"\n      },\n      {\n         \"explanation\": \"The class SearchableSnapshotAction does not implement the equals and hashCode methods, which are necessary for proper object comparison.\",\n         \"suggested_fix\": \"Implement the equals and hashCode methods in the class SearchableSnapshotAction:\\n@Override\\npublic boolean equals(Object o) {\\n    if (this == o) return true;\\n    if (o == null || getClass() != o.getClass()) return false;\\n    SearchableSnapshotAction that = (SearchableSnapshotAction) o;\\n    return Objects.equals(snapshotRepository, that.snapshotRepository) &&\\n           Objects.equals(forceMergeIndex, that.forceMergeIndex) &&\\n           Objects.equals(totalShardsPerNode, that.totalShardsPerNode) &&\\n           Objects.equals(replicateFor, that.replicateFor);\\n}\\n\\n@Override\\npublic int hashCode() {\\n    return Objects.hash(snapshotRepository, forceMergeIndex, totalShardsPerNode, replicateFor);\\n}\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs were found in the provided code snippet.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The constructor SearchableSnapshotAction(String snapshotRepository, boolean forceMergeIndex) is missing the required parameters totalShardsPerNode and replicateFor, which are not null in the other constructors.",
        "suggested_fix": "Add default values for totalShardsPerNode and replicateFor to the constructor SearchableSnapshotAction(String snapshotRepository, boolean forceMergeIndex):\npublic SearchableSnapshotAction(String snapshotRepository, boolean forceMergeIndex) {\n    this(snapshotRepository, forceMergeIndex, 1, null);\n}"
      },
      {
        "explanation": "The constructor SearchableSnapshotAction(String snapshotRepository) is missing the required parameters totalShardsPerNode and replicateFor, which are not null in the other constructors.",
        "suggested_fix": "Add default values for totalShardsPerNode and replicateFor to the constructor SearchableSnapshotAction(String snapshotRepository):\npublic SearchableSnapshotAction(String snapshotRepository) {\n    this(snapshotRepository, true, 1, null);\n}"
      },
      {
        "explanation": "The method parse(XContentParser parser) does not handle the case where the input is not a valid XContentParser.",
        "suggested_fix": "Add a try-catch block to handle the IOException that may be thrown by the XContentParser:\npublic static SearchableSnapshotAction parse(XContentParser parser) {\n    try {\n        return PARSER.apply(parser, null);\n    } catch (IOException e) {\n        // handle the exception\n    }\n}"
      },
      {
        "explanation": "The class SearchableSnapshotAction does not implement the equals and hashCode methods, which are necessary for proper object comparison.",
        "suggested_fix": "Implement the equals and hashCode methods in the class SearchableSnapshotAction:\n@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    SearchableSnapshotAction that = (SearchableSnapshotAction) o;\n    return Objects.equals(snapshotRepository, that.snapshotRepository) &&\n           Objects.equals(forceMergeIndex, that.forceMergeIndex) &&\n           Objects.equals(totalShardsPerNode, that.totalShardsPerNode) &&\n           Objects.equals(replicateFor, that.replicateFor);\n}\n\n@Override\npublic int hashCode() {\n    return Objects.hash(snapshotRepository, forceMergeIndex, totalShardsPerNode, replicateFor);\n}"
      }
    ],
    "no_bugs_reasoning": "No bugs were found in the provided code snippet."
  },
  "error": null
}