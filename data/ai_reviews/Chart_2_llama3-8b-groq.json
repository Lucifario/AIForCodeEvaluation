{"sample_id": "Chart_2", "model": "llama3-8b-groq", "code_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * ---------------------\n * DatasetUtilities.java\n * ---------------------\n * (C) Copyright 2000-2009, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Andrzej Porebski (bug fix);\n *                   Jonathan Nash (bug fix);\n *                   Richard Atkinson;\n *                   Andreas Schroeder;\n *                   Rafal Skalny (patch 1925366);\n *                   Jerome David (patch 2131001);\n *                   Peter Kolb (patch 2791407);\n *\n * Changes (from 18-Sep-2001)\n * --------------------------\n * 18-Sep-2001 : Added standard header and fixed DOS encoding problem (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 15-Nov-2001 : Moved to package com.jrefinery.data.* in the JCommon class\n *               library (DG);\n *               Changed to handle null values from datasets (DG);\n *               Bug fix (thanks to Andrzej Porebski) - initial value now set\n *               to positive or negative infinity when iterating (DG);\n * 22-Nov-2001 : Datasets with containing no data now return null for min and\n *               max calculations (DG);\n * 13-Dec-2001 : Extended to handle HighLowDataset and IntervalXYDataset (DG);\n * 15-Feb-2002 : Added getMinimumStackedRangeValue() and\n *               getMaximumStackedRangeValue() (DG);\n * 28-Feb-2002 : Renamed Datasets.java --> DatasetUtilities.java (DG);\n * 18-Mar-2002 : Fixed bug in min/max domain calculation for datasets that\n *               implement the CategoryDataset interface AND the XYDataset\n *               interface at the same time.  Thanks to Jonathan Nash for the\n *               fix (DG);\n * 23-Apr-2002 : Added getDomainExtent() and getRangeExtent() methods (DG);\n * 13-Jun-2002 : Modified range measurements to handle\n *               IntervalCategoryDataset (DG);\n * 12-Jul-2002 : Method name change in DomainInfo interface (DG);\n * 30-Jul-2002 : Added pie dataset summation method (DG);\n * 01-Oct-2002 : Added a method for constructing an XYDataset from a Function2D\n *               instance (DG);\n * 24-Oct-2002 : Amendments required following changes to the CategoryDataset\n *               interface (DG);\n * 18-Nov-2002 : Changed CategoryDataset to TableDataset (DG);\n * 04-Mar-2003 : Added isEmpty(XYDataset) method (DG);\n * 05-Mar-2003 : Added a method for creating a CategoryDataset from a\n *               KeyedValues instance (DG);\n * 15-May-2003 : Renamed isEmpty --> isEmptyOrNull (DG);\n * 25-Jun-2003 : Added limitPieDataset methods (RA);\n * 26-Jun-2003 : Modified getDomainExtent() method to accept null datasets (DG);\n * 27-Jul-2003 : Added getStackedRangeExtent(TableXYDataset data) (RA);\n * 18-Aug-2003 : getStackedRangeExtent(TableXYDataset data) now handles null\n *               values (RA);\n * 02-Sep-2003 : Added method to check for null or empty PieDataset (DG);\n * 18-Sep-2003 : Fix for bug 803660 (getMaximumRangeValue for\n *               CategoryDataset) (DG);\n * 20-Oct-2003 : Added getCumulativeRangeExtent() method (DG);\n * 09-Jan-2003 : Added argument checking code to the createCategoryDataset()\n *               method (DG);\n * 23-Mar-2004 : Fixed bug in getMaximumStackedRangeValue() method (DG);\n * 31-Mar-2004 : Exposed the extent iteration algorithms to use one of them and\n *               applied noninstantiation pattern (AS);\n * 11-May-2004 : Renamed getPieDatasetTotal --> calculatePieDatasetTotal (DG);\n * 15-Jul-2004 : Switched getX() with getXValue() and getY() with getYValue();\n * 24-Aug-2004 : Added argument checks to createCategoryDataset() method (DG);\n * 04-Oct-2004 : Renamed ArrayUtils --> ArrayUtilities (DG);\n * 06-Oct-2004 : Renamed findDomainExtent() --> findDomainBounds(),\n *               findRangeExtent() --> findRangeBounds() (DG);\n * 07-Jan-2005 : Renamed findStackedRangeExtent() --> findStackedRangeBounds(),\n *               findCumulativeRangeExtent() --> findCumulativeRangeBounds(),\n *               iterateXYRangeExtent() --> iterateXYRangeBounds(),\n *               removed deprecated methods (DG);\n * 03-Feb-2005 : The findStackedRangeBounds() methods now return null for\n *               empty datasets (DG);\n * 03-Mar-2005 : Moved createNumberArray() and createNumberArray2D() methods\n *               from DatasetUtilities --> DataUtilities (DG);\n * 22-Sep-2005 : Added new findStackedRangeBounds() method that takes base\n *               argument (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 15-Mar-2007 : Added calculateStackTotal() method (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 27-Mar-2008 : Fixed bug in findCumulativeRangeBounds() method (DG);\n * 28-Mar-2008 : Fixed sample count in sampleFunction2D() method, renamed\n *               iterateXYRangeBounds() --> iterateRangeBounds(XYDataset), and\n *               fixed a bug in findRangeBounds(XYDataset, false) (DG);\n * 28-Mar-2008 : Applied a variation of patch 1925366 (from Rafal Skalny) for\n *               slightly more efficient iterateRangeBounds() methods (DG);\n * 08-Apr-2008 : Fixed typo in iterateRangeBounds() (DG);\n * 08-Oct-2008 : Applied patch 2131001 by Jerome David, with some modifications\n *               and additions and some new unit tests (DG);\n * 12-Feb-2009 : Added sampleFunction2DToSeries() method (DG);\n * 27-Mar-2009 : Added new methods to find domain and range bounds taking into\n *               account hidden series (DG);\n * 01-Apr-2009 : Handle a StatisticalCategoryDataset in\n *               iterateToFindRangeBounds() (DG);\n * 16-May-2009 : Patch 2791407 - fix iterateToFindRangeBounds for\n *               MultiValueCategoryDataset (PK);\n * 10-Sep-2009 : Fix bug 2849731 for IntervalCategoryDataset (DG);\n *\n */\n\npackage org.jfree.data.general;\n\nimport org.jfree.data.pie.PieDataset;\nimport org.jfree.data.pie.DefaultPieDataset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.jfree.chart.util.ArrayUtilities;\nimport org.jfree.data.DomainInfo;\nimport org.jfree.data.KeyToGroupMap;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.Range;\nimport org.jfree.data.RangeInfo;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryRangeInfo;\nimport org.jfree.data.category.DefaultCategoryDataset;\nimport org.jfree.data.category.IntervalCategoryDataset;\nimport org.jfree.data.function.Function2D;\nimport org.jfree.data.statistics.BoxAndWhiskerCategoryDataset;\nimport org.jfree.data.statistics.BoxAndWhiskerXYDataset;\nimport org.jfree.data.statistics.MultiValueCategoryDataset;\nimport org.jfree.data.statistics.StatisticalCategoryDataset;\nimport org.jfree.data.xy.IntervalXYDataset;\nimport org.jfree.data.xy.OHLCDataset;\nimport org.jfree.data.xy.TableXYDataset;\nimport org.jfree.data.xy.XYDataset;\nimport org.jfree.data.xy.XYDomainInfo;\nimport org.jfree.data.xy.XYRangeInfo;\nimport org.jfree.data.xy.XYSeries;\nimport org.jfree.data.xy.XYSeriesCollection;\n\n/**\n * A collection of useful static methods relating to datasets.\n */\npublic final class DatasetUtilities {\n\n    /**\n     * Private constructor for non-instanceability.\n     */\n    private DatasetUtilities() {\n        // now try to instantiate this ;-)\n    }\n\n    /**\n     * Calculates the total of all the values in a {@link PieDataset}.  If\n     * the dataset contains negative or <code>null</code> values, they are\n     * ignored.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The total.\n     */\n    public static double calculatePieDatasetTotal(PieDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        List keys = dataset.getKeys();\n        double totalValue = 0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable current = (Comparable) iterator.next();\n            if (current != null) {\n                Number value = dataset.getValue(current);\n                double v = 0.0;\n                if (value != null) {\n                    v = value.doubleValue();\n                }\n                if (v > 0) {\n                    totalValue = totalValue + v;\n                }\n            }\n        }\n        return totalValue;\n    }\n\n    /**\n     * Creates a pie dataset from a table dataset by taking all the values\n     * for a single row.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param rowKey  the row key.\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n                                                    Comparable rowKey) {\n        int row = dataset.getRowIndex(rowKey);\n        return createPieDatasetForRow(dataset, row);\n    }\n\n    /**\n     * Creates a pie dataset from a table dataset by taking all the values\n     * for a single row.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param row  the row (zero-based index).\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n                                                    int row) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int columnCount = dataset.getColumnCount();\n        for (int current = 0; current < columnCount; current++) {\n            Comparable columnKey = dataset.getColumnKey(current);\n            result.setValue(columnKey, dataset.getValue(row, current));\n        }\n        return result;\n    }\n\n    /**\n     * Creates a pie dataset from a table dataset by taking all the values\n     * for a single column.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param columnKey  the column key.\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n                                                       Comparable columnKey) {\n        int column = dataset.getColumnIndex(columnKey);\n        return createPieDatasetForColumn(dataset, column);\n    }\n\n    /**\n     * Creates a pie dataset from a {@link CategoryDataset} by taking all the\n     * values for a single column.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param column  the column (zero-based index).\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n                                                       int column) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int rowCount = dataset.getRowCount();\n        for (int i = 0; i < rowCount; i++) {\n            Comparable rowKey = dataset.getRowKey(i);\n            result.setValue(rowKey, dataset.getValue(i, column));\n        }\n        return result;\n    }\n\n    /**\n     * Creates a new pie dataset based on the supplied dataset, but modified\n     * by aggregating all the low value items (those whose value is lower\n     * than the <code>percentThreshold</code>) into a single item with the\n     * key \"Other\".\n     *\n     * @param source  the source dataset (<code>null</code> not permitted).\n     * @param key  a new key for the aggregated items (<code>null</code> not\n     *             permitted).\n     * @param minimumPercent  the percent threshold.\n     *\n     * @return The pie dataset with (possibly) aggregated items.\n     */\n    public static PieDataset createConsolidatedPieDataset(PieDataset source,\n            Comparable key, double minimumPercent) {\n        return DatasetUtilities.createConsolidatedPieDataset(source, key,\n                minimumPercent, 2);\n    }\n\n    /**\n     * Creates a new pie dataset based on the supplied dataset, but modified\n     * by aggregating all the low value items (those whose value is lower\n     * than the <code>percentThreshold</code>) into a single item.  The\n     * aggregated items are assigned the specified key.  Aggregation only\n     * occurs if there are at least <code>minItems</code> items to aggregate.\n     *\n     * @param source  the source dataset (<code>null</code> not permitted).\n     * @param key  the key to represent the aggregated items.\n     * @param minimumPercent  the percent threshold (ten percent is 0.10).\n     * @param minItems  only aggregate low values if there are at least this\n     *                  many.\n     *\n     * @return The pie dataset with (possibly) aggregated items.\n     */\n    public static PieDataset createConsolidatedPieDataset(PieDataset source,\n            Comparable key, double minimumPercent, int minItems) {\n\n        DefaultPieDataset result = new DefaultPieDataset();\n        double total = DatasetUtilities.calculatePieDatasetTotal(source);\n\n        //  Iterate and find all keys below threshold percentThreshold\n        List keys = source.getKeys();\n        ArrayList otherKeys = new ArrayList();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = source.getValue(currentKey);\n            if (dataValue != null) {\n                double value = dataValue.doubleValue();\n                if (value / total < minimumPercent) {\n                    otherKeys.add(currentKey);\n                }\n            }\n        }\n\n        //  Create new dataset with keys above threshold percentThreshold\n        iterator = keys.iterator();\n        double otherValue = 0;\n        while (iterator.hasNext()) {\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = source.getValue(currentKey);\n            if (dataValue != null) {\n                if (otherKeys.contains(currentKey)\n                    && otherKeys.size() >= minItems) {\n                    //  Do not add key to dataset\n                    otherValue += dataValue.doubleValue();\n                }\n                else {\n                    //  Add key to dataset\n                    result.setValue(currentKey, dataValue);\n                }\n            }\n        }\n        //  Add other category if applicable\n        if (otherKeys.size() >= minItems) {\n            result.setValue(key, otherValue);\n        }\n        return result;\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} that contains a copy of the data in an\n     * array (instances of <code>Double</code> are created to represent the\n     * data items).\n     * <p>\n     * Row and column keys are created by appending 0, 1, 2, ... to the\n     * supplied prefixes.\n     *\n     * @param rowKeyPrefix  the row key prefix.\n     * @param columnKeyPrefix  the column key prefix.\n     * @param data  the data.\n     *\n     * @return The dataset.\n     */\n    public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\n            String columnKeyPrefix, double[][] data) {\n\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            String rowKey = rowKeyPrefix + (r + 1);\n            for (int c = 0; c < data[r].length; c++) {\n                String columnKey = columnKeyPrefix + (c + 1);\n                result.addValue(new Double(data[r][c]), rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} that contains a copy of the data in\n     * an array.\n     * <p>\n     * Row and column keys are created by appending 0, 1, 2, ... to the\n     * supplied prefixes.\n     *\n     * @param rowKeyPrefix  the row key prefix.\n     * @param columnKeyPrefix  the column key prefix.\n     * @param data  the data.\n     *\n     * @return The dataset.\n     */\n    public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\n            String columnKeyPrefix, Number[][] data) {\n\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            String rowKey = rowKeyPrefix + (r + 1);\n            for (int c = 0; c < data[r].length; c++) {\n                String columnKey = columnKeyPrefix + (c + 1);\n                result.addValue(data[r][c], rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} that contains a copy of the data in\n     * an array (instances of <code>Double</code> are created to represent the\n     * data items).\n     * <p>\n     * Row and column keys are taken from the supplied arrays.\n     *\n     * @param rowKeys  the row keys (<code>null</code> not permitted).\n     * @param columnKeys  the column keys (<code>null</code> not permitted).\n     * @param data  the data.\n     *\n     * @return The dataset.\n     */\n    public static CategoryDataset createCategoryDataset(Comparable[] rowKeys,\n            Comparable[] columnKeys, double[][] data) {\n\n        // check arguments...\n        if (rowKeys == null) {\n            throw new IllegalArgumentException(\"Null 'rowKeys' argument.\");\n        }\n        if (columnKeys == null) {\n            throw new IllegalArgumentException(\"Null 'columnKeys' argument.\");\n        }\n        if (ArrayUtilities.hasDuplicateItems(rowKeys)) {\n            throw new IllegalArgumentException(\"Duplicate items in 'rowKeys'.\");\n        }\n        if (ArrayUtilities.hasDuplicateItems(columnKeys)) {\n            throw new IllegalArgumentException(\n                    \"Duplicate items in 'columnKeys'.\");\n        }\n        if (rowKeys.length != data.length) {\n            throw new IllegalArgumentException(\n                \"The number of row keys does not match the number of rows in \"\n                + \"the data array.\");\n        }\n        int columnCount = 0;\n        for (int r = 0; r < data.length; r++) {\n            columnCount = Math.max(columnCount, data[r].length);\n        }\n        if (columnKeys.length != columnCount) {\n            throw new IllegalArgumentException(\n                \"The number of column keys does not match the number of \"\n                + \"columns in the data array.\");\n        }\n\n        // now do the work...\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            Comparable rowKey = rowKeys[r];\n            for (int c = 0; c < data[r].length; c++) {\n                Comparable columnKey = columnKeys[c];\n                result.addValue(new Double(data[r][c]), rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} by copying the data from the supplied\n     * {@link KeyedValues} instance.\n     *\n     * @param rowKey  the row key (<code>null</code> not permitted).\n     * @param rowData  the row data (<code>null</code> not permitted).\n     *\n     * @return A dataset.\n     */\n    public static CategoryDataset createCategoryDataset(Comparable rowKey,\n                                                        KeyedValues rowData) {\n\n        if (rowKey == null) {\n            throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n        }\n        if (rowData == null) {\n            throw new IllegalArgumentException(\"Null 'rowData' argument.\");\n        }\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int i = 0; i < rowData.getItemCount(); i++) {\n            result.addValue(rowData.getValue(i), rowKey, rowData.getKey(i));\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates an {@link XYDataset} by sampling the specified function over a\n     * fixed range.\n     *\n     * @param f  the function (<code>null</code> not permitted).\n     * @param start  the start value for the range.\n     * @param end  the end value for the range.\n     * @param samples  the number of sample points (must be > 1).\n     * @param seriesKey  the key to give the resulting series\n     *                   (<code>null</code> not permitted).\n     *\n     * @return A dataset.\n     */\n    public static XYDataset sampleFunction2D(Function2D f, double start,\n            double end, int samples, Comparable seriesKey) {\n\n        // defer argument checking\n        XYSeries series = sampleFunction2DToSeries(f, start, end, samples,\n                seriesKey);\n        XYSeriesCollection collection = new XYSeriesCollection(series);\n        return collection;\n    }\n\n    /**\n     * Creates an {@link XYSeries} by sampling the specified function over a\n     * fixed range.\n     *\n     * @param f  the function (<code>null</code> not permitted).\n     * @param start  the start value for the range.\n     * @param end  the end value for the range.\n     * @param samples  the number of sample points (must be > 1).\n     * @param seriesKey  the key to give the resulting series\n     *                   (<code>null</code> not permitted).\n     *\n     * @return A series.\n     *\n     * @since 1.0.13\n     */\n    public static XYSeries sampleFunction2DToSeries(Function2D f,\n            double start, double end, int samples, Comparable seriesKey) {\n\n        if (f == null) {\n            throw new IllegalArgumentException(\"Null 'f' argument.\");\n        }\n        if (seriesKey == null) {\n            throw new IllegalArgumentException(\"Null 'seriesKey' argument.\");\n        }\n        if (start >= end) {\n            throw new IllegalArgumentException(\"Requires 'start' < 'end'.\");\n        }\n        if (samples < 2) {\n            throw new IllegalArgumentException(\"Requires 'samples' > 1\");\n        }\n\n        XYSeries series = new XYSeries(seriesKey);\n        double step = (end - start) / (samples - 1);\n        for (int i = 0; i < samples; i++) {\n            double x = start + (step * i);\n            series.add(x, f.getValue(x));\n        }\n        return series;\n    }\n\n    /**\n     * Returns <code>true</code> if the dataset is empty (or <code>null</code>),\n     * and <code>false</code> otherwise.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean isEmptyOrNull(PieDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int itemCount = dataset.getItemCount();\n        if (itemCount == 0) {\n            return true;\n        }\n\n        for (int item = 0; item < itemCount; item++) {\n            Number y = dataset.getValue(item);\n            if (y != null) {\n                double yy = y.doubleValue();\n                if (yy > 0.0) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n\n    }\n\n    /**\n     * Returns <code>true</code> if the dataset is empty (or <code>null</code>),\n     * and <code>false</code> otherwise.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean isEmptyOrNull(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (rowCount == 0 || columnCount == 0) {\n            return true;\n        }\n\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < columnCount; c++) {\n                if (dataset.getValue(r, c) != null) {\n                    return false;\n                }\n\n            }\n        }\n\n        return true;\n\n    }\n\n    /**\n     * Returns <code>true</code> if the dataset is empty (or <code>null</code>),\n     * and <code>false</code> otherwise.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean isEmptyOrNull(XYDataset dataset) {\n        if (dataset != null) {\n            for (int s = 0; s < dataset.getSeriesCount(); s++) {\n                if (dataset.getItemCount(s) > 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the range of values in the domain (x-values) of a dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range of values (possibly <code>null</code>).\n     */\n    public static Range findDomainBounds(XYDataset dataset) {\n        return findDomainBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the domain (x-values) of a dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  determines whether or not the x-interval is taken\n     *                         into account (only applies if the dataset is an\n     *                         {@link IntervalXYDataset}).\n     *\n     * @return The range of values (possibly <code>null</code>).\n     */\n    public static Range findDomainBounds(XYDataset dataset,\n                                         boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        Range result = null;\n        // if the dataset implements DomainInfo, life is easier\n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            result = info.getDomainBounds(includeInterval);\n        }\n        else {\n            result = iterateDomainBounds(dataset, includeInterval);\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the bounds of the x-values in the specified <code>dataset</code>\n     * taking into account only the visible series and including any x-interval\n     * if requested.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the visible series keys (<code>null</code>\n     *     not permitted).\n     * @param includeInterval  include the x-interval (if any)?\n     *\n     * @return The bounds (or <code>null</code> if the dataset contains no\n     *     values.\n     *\n     * @since 1.0.13\n     */\n    public static Range findDomainBounds(XYDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof XYDomainInfo) {\n            XYDomainInfo info = (XYDomainInfo) dataset;\n            result = info.getDomainBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindDomainBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Iterates over the items in an {@link XYDataset} to find\n     * the range of x-values.  If the dataset is an instance of\n     * {@link IntervalXYDataset}, the starting and ending x-values\n     * will be used for the bounds calculation.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range iterateDomainBounds(XYDataset dataset) {\n        return iterateDomainBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the items in an {@link XYDataset} to find\n     * the range of x-values.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the x-interval or just the\n     *          x-value is used to determine the overall range.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum > maximum) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range findRangeBounds(CategoryDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range findRangeBounds(CategoryDataset dataset,\n                                        boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Finds the bounds of the y-values in the specified dataset, including\n     * only those series that are listed in visibleSeriesKeys.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the keys for the visible series\n     *     (<code>null</code> not permitted).\n     * @param includeInterval  include the y-interval (if the dataset has a\n     *     y-interval).\n     *\n     * @return The data bounds.\n     *\n     * @since 1.0.13\n     */\n    public static Range findRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof CategoryRangeInfo) {\n            CategoryRangeInfo info = (CategoryRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.  This method\n     * is the partner for the {@link #findDomainBounds(XYDataset)} method.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range findRangeBounds(XYDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.  This method\n     * is the partner for the {@link #findDomainBounds(XYDataset, boolean)}\n     * method.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n    public static Range findRangeBounds(XYDataset dataset,\n                                        boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Finds the bounds of the y-values in the specified dataset, including\n     * only those series that are listed in visibleSeriesKeys, and those items\n     * whose x-values fall within the specified range.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the keys for the visible series\n     *     (<code>null</code> not permitted).\n     * @param xRange  the x-range (<code>null</code> not permitted).\n     * @param includeInterval  include the y-interval (if the dataset has a\n     *     y-interval).\n     *\n     * @return The data bounds.\n     *\n     * @since 1.0.13\n     */\n    public static Range findRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof XYRangeInfo) {\n            XYRangeInfo info = (XYRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, xRange,\n                    includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    xRange, includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @deprecated As of 1.0.10, use\n     *         {@link #iterateRangeBounds(CategoryDataset, boolean)}.\n     */\n    public static Range iterateCategoryRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        return iterateRangeBounds(dataset, includeInterval);\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n    public static Range iterateRangeBounds(CategoryDataset dataset) {\n        return iterateRangeBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n    public static Range iterateRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (includeInterval && dataset instanceof IntervalCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset;\n            Number value, lvalue, uvalue;\n            for (int row = 0; row < rowCount; row++) {\n                for (int column = 0; column < columnCount; column++) {\n                    value = icd.getValue(row, column);\n                    double v;\n                    if ((value != null)\n                            && !Double.isNaN(v = value.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                    lvalue = icd.getStartValue(row, column);\n                    if (lvalue != null\n                            && !Double.isNaN(v = lvalue.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                    uvalue = icd.getEndValue(row, column);\n                    if (uvalue != null \n                            && !Double.isNaN(v = uvalue.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                }\n            }\n        }\n        else {\n            // handle the standard case (plain CategoryDataset)\n            for (int row = 0; row < rowCount; row++) {\n                for (int column = 0; column < columnCount; column++) {\n                    Number value = dataset.getValue(row, column);\n                    if (value != null) {\n                        double v = value.doubleValue();\n                        if (!Double.isNaN(v)) {\n                            minimum = Math.min(minimum, v);\n                            maximum = Math.max(maximum, v);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     * @param visibleSeriesKeys  the visible series keys.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.13\n     */\n    public static Range iterateToFindRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int columnCount = dataset.getColumnCount();\n        if (includeInterval\n                && dataset instanceof BoxAndWhiskerCategoryDataset) {\n            // handle special case of BoxAndWhiskerDataset\n            BoxAndWhiskerCategoryDataset bx\n                    = (BoxAndWhiskerCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                int itemCount = dataset.getColumnCount();\n                for (int item = 0; item < itemCount; item++) {\n                    Number lvalue = bx.getMinRegularValue(series, item);\n                    if (lvalue == null) {\n                        lvalue = bx.getValue(series, item);\n                    }\n                    Number uvalue = bx.getMaxRegularValue(series, item);\n                    if (uvalue == null) {\n                        uvalue = bx.getValue(series, item);\n                    }\n                    if (lvalue != null) {\n                        minimum = Math.min(minimum, lvalue.doubleValue());\n                    }\n                    if (uvalue != null) {\n                        maximum = Math.max(maximum, uvalue.doubleValue());\n                    }\n                }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof IntervalCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset;\n            Number lvalue, uvalue;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    lvalue = icd.getStartValue(series, column);\n                    uvalue = icd.getEndValue(series, column);\n                    if (lvalue != null && !Double.isNaN(lvalue.doubleValue())) {\n                        minimum = Math.min(minimum, lvalue.doubleValue());\n                    }\n                    if (uvalue != null && !Double.isNaN(uvalue.doubleValue())) {\n                        maximum = Math.max(maximum, uvalue.doubleValue());\n                    }\n                }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof MultiValueCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            MultiValueCategoryDataset mvcd\n                    = (MultiValueCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    List values = mvcd.getValues(series, column);\n                    Iterator valueIterator = values.iterator();\n                    while (valueIterator.hasNext()) {\n                    \tObject o = valueIterator.next();\n\t\t\t\t\t\tif (o instanceof Number){\n\t\t\t\t\t\t\tdouble v = ((Number) o).doubleValue();\n\t\t\t\t\t\t\tif (!Double.isNaN(v)){\n\t                            minimum = Math.min(minimum, v);\n\t                            maximum = Math.max(maximum, v);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n                    }\n               }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof StatisticalCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            StatisticalCategoryDataset scd\n                    = (StatisticalCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    Number meanN = scd.getMeanValue(series, column);\n                    if (meanN != null) {\n                        double std = 0.0;\n                        Number stdN = scd.getStdDevValue(series, column);\n                        if (stdN != null) {\n                            std = stdN.doubleValue();\n                            if (Double.isNaN(std)) {\n                                std = 0.0;\n                            }\n                        }\n                        double mean = meanN.doubleValue();\n                        if (!Double.isNaN(mean)) {\n                            minimum = Math.min(minimum, mean - std);\n                            maximum = Math.max(maximum, mean + std);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            // handle the standard case (plain CategoryDataset)\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    Number value = dataset.getValue(series, column);\n                    if (value != null) {\n                        double v = value.doubleValue();\n                        if (!Double.isNaN(v)) {\n                            minimum = Math.min(minimum, v);\n                            maximum = Math.max(maximum, v);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Iterates over the data item of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @deprecated As of 1.0.10, use {@link #iterateRangeBounds(XYDataset)}.\n     */\n    public static Range iterateXYRangeBounds(XYDataset dataset) {\n        return iterateRangeBounds(dataset);\n    }\n\n    /**\n     * Iterates over the data item of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n    public static Range iterateRangeBounds(XYDataset dataset) {\n        return iterateRangeBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the data items of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the y-interval or just the\n     *          y-value is used to determine the overall range.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of x-values in the specified dataset for the\n     * data items belonging to the visible series.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the visible series keys (<code>null</code> not\n     *     permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *     y-interval for the dataset is included (this only applies if the\n     *     dataset is an instance of IntervalXYDataset).\n     *\n     * @return The x-range (possibly <code>null</code>).\n     *\n     * @since 1.0.13\n     */\n    public static Range iterateToFindDomainBounds(XYDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartXValue(series, item);\n                    double uvalue = ixyd.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = dataset.getXValue(series, item);\n                    if (!Double.isNaN(x)) {\n                        minimum = Math.min(minimum, x);\n                        maximum = Math.max(maximum, x);\n                    }\n                }\n            }\n        }\n\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of y-values in the specified dataset for the\n     * data items belonging to the visible series and with x-values in the\n     * given range.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param visibleSeriesKeys  the visible series keys (<code>null</code> not\n     *     permitted).\n     * @param xRange  the x-range (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *     y-interval for the dataset is included (this only applies if the\n     *     dataset is an instance of IntervalXYDataset).\n     *\n     * @return The y-range (possibly <code>null</code>).\n     *\n     * @since 1.0.13\n     */\n    public static Range iterateToFindRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        if (visibleSeriesKeys == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'visibleSeriesKeys' argument.\");\n        }\n        if (xRange == null) {\n            throw new IllegalArgumentException(\"Null 'xRange' argument\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = ohlc.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        double lvalue = ohlc.getLowValue(series, item);\n                        double uvalue = ohlc.getHighValue(series, item);\n                        if (!Double.isNaN(lvalue)) {\n                            minimum = Math.min(minimum, lvalue);\n                        }\n                        if (!Double.isNaN(uvalue)) {\n                            maximum = Math.max(maximum, uvalue);\n                        }\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof BoxAndWhiskerXYDataset) {\n            // handle special case of BoxAndWhiskerXYDataset\n            BoxAndWhiskerXYDataset bx = (BoxAndWhiskerXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = bx.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        Number lvalue = bx.getMinRegularValue(series, item);\n                        Number uvalue = bx.getMaxRegularValue(series, item);\n                        if (lvalue != null) {\n                            minimum = Math.min(minimum, lvalue.doubleValue());\n                        }\n                        if (uvalue != null) {\n                            maximum = Math.max(maximum, uvalue.doubleValue());\n                        }\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = ixyd.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        double lvalue = ixyd.getStartYValue(series, item);\n                        double uvalue = ixyd.getEndYValue(series, item);\n                        if (!Double.isNaN(lvalue)) {\n                            minimum = Math.min(minimum, lvalue);\n                        }\n                        if (!Double.isNaN(uvalue)) {\n                            maximum = Math.max(maximum, uvalue);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = dataset.getXValue(series, item);\n                    double y = dataset.getYValue(series, item);\n                    if (xRange.contains(x)) {\n                        if (!Double.isNaN(y)) {\n                            minimum = Math.min(minimum, y);\n                            maximum = Math.max(maximum, y);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Finds the minimum domain (or X) value for the specified dataset.  This\n     * is easy if the dataset implements the {@link DomainInfo} interface (a\n     * good idea if there is an efficient way to determine the minimum value).\n     * Otherwise, it involves iterating over the entire data-set.\n     * <p>\n     * Returns <code>null</code> if all the data values in the dataset are\n     * <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value (possibly <code>null</code>).\n     */\n    public static Number findMinimumDomainValue(XYDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        // if the dataset implements DomainInfo, life is easy\n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return new Double(info.getDomainLowerBound(true));\n        }\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = new Double(minimum);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the maximum domain value for the specified dataset.  This is\n     * easy if the dataset implements the {@link DomainInfo} interface (a good\n     * idea if there is an efficient way to determine the maximum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values in the dataset are\n     * <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     */\n    public static Number findMaximumDomainValue(XYDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        // if the dataset implements DomainInfo, life is easy\n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return new Double(info.getDomainUpperBound(true));\n        }\n\n        // hasn't implemented DomainInfo, so iterate...\n        else {\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getEndXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = new Double(maximum);\n            }\n\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the minimum range value for the specified dataset.  This is\n     * easy if the dataset implements the {@link RangeInfo} interface (a good\n     * idea if there is an efficient way to determine the minimum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values in the dataset are\n     * <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value (possibly <code>null</code>).\n     */\n    public static Number findMinimumRangeValue(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeLowerBound(true));\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getRowCount();\n            int itemCount = dataset.getColumnCount();\n            for (int series = 0; series < seriesCount; series++) {\n                for (int item = 0; item < itemCount; item++) {\n                    Number value;\n                    if (dataset instanceof IntervalCategoryDataset) {\n                        IntervalCategoryDataset icd\n                                = (IntervalCategoryDataset) dataset;\n                        value = icd.getStartValue(series, item);\n                    }\n                    else {\n                        value = dataset.getValue(series, item);\n                    }\n                    if (value != null) {\n                        minimum = Math.min(minimum, value.doubleValue());\n                    }\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(minimum);\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the minimum range value for the specified dataset.  This is\n     * easy if the dataset implements the {@link RangeInfo} interface (a good\n     * idea if there is an efficient way to determine the minimum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values in the dataset are\n     * <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value (possibly <code>null</code>).\n     */\n    public static Number findMinimumRangeValue(XYDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        // work out the minimum value...\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeLowerBound(true));\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                                = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartYValue(series, item);\n                    }\n                    else if (dataset instanceof OHLCDataset) {\n                        OHLCDataset highLowData = (OHLCDataset) dataset;\n                        value = highLowData.getLowValue(series, item);\n                    }\n                    else {\n                        value = dataset.getYValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(minimum);\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the maximum range value for the specified dataset.  This is easy\n     * if the dataset implements the {@link RangeInfo} interface (a good idea\n     * if there is an efficient way to determine the maximum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values are <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     */\n    public static Number findMaximumRangeValue(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        // work out the minimum value...\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeUpperBound(true));\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else {\n\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getRowCount();\n            int itemCount = dataset.getColumnCount();\n            for (int series = 0; series < seriesCount; series++) {\n                for (int item = 0; item < itemCount; item++) {\n                    Number value;\n                    if (dataset instanceof IntervalCategoryDataset) {\n                        IntervalCategoryDataset icd\n                            = (IntervalCategoryDataset) dataset;\n                        value = icd.getEndValue(series, item);\n                    }\n                    else {\n                        value = dataset.getValue(series, item);\n                    }\n                    if (value != null) {\n                        maximum = Math.max(maximum, value.doubleValue());\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(maximum);\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the maximum range value for the specified dataset.  This is\n     * easy if the dataset implements the {@link RangeInfo} interface (a good\n     * idea if there is an efficient way to determine the maximum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * <code>null</code> if all the data values are <code>null</code>.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     */\n    public static Number findMaximumRangeValue(XYDataset dataset) {\n\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        // work out the minimum value...\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return new Double(info.getRangeUpperBound(true));\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else  {\n\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getEndYValue(series, item);\n                    }\n                    else if (dataset instanceof OHLCDataset) {\n                        OHLCDataset highLowData = (OHLCDataset) dataset;\n                        value = highLowData.getHighValue(series, item);\n                    }\n                    else {\n                        value = dataset.getYValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return new Double(maximum);\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param base  the base value for the bars.\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n            double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive = positive + value;\n                    }\n                    if (value < 0.0) {\n                        negative = negative + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, negative);\n            maximum = Math.max(maximum, positive);\n        }\n        if (minimum <= maximum) {\n            result = new Range(minimum, maximum);\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset.\n     * @param map  a structure that maps series to groups.\n     *\n     * @return The value range (<code>null</code> if the dataset contains no\n     *         values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n                                               KeyToGroupMap map) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean hasValidData = false;\n        Range result = null;\n\n        // create an array holding the group indices for each series...\n        int[] groupIndex = new int[dataset.getRowCount()];\n        for (int i = 0; i < dataset.getRowCount(); i++) {\n            groupIndex[i] = map.getGroupIndex(map.getGroup(\n                    dataset.getRowKey(i)));\n        }\n\n        // minimum and maximum for each group...\n        int groupCount = map.getGroupCount();\n        double[] minimum = new double[groupCount];\n        double[] maximum = new double[groupCount];\n\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The minimum value.\n     *\n     * @see #findMaximumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMinimumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double minimum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value < 0.0) {\n                        total = total + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, total);\n        }\n        if (hasValidData) {\n            result = new Double(minimum);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The maximum value (possibly <code>null</code>).\n     *\n     * @see #findMinimumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMaximumStackedRangeValue(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Number result = null;\n        boolean hasValidData = false;\n        double maximum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        total = total + value;\n                    }\n                }\n            }\n            maximum = Math.max(maximum, total);\n        }\n        if (hasValidData) {\n            result = new Double(maximum);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range,\n     * assuming that the series are stacked.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range ([0.0, 0.0] if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(TableXYDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range,\n     * assuming that the series are stacked, using the specified base value.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param base  the base value.\n     *\n     * @return The range (<code>null</code> if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(TableXYDataset dataset,\n                                               double base) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = base;\n        double maximum = base;\n        for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getSeriesCount();\n            for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n                double y = dataset.getYValue(seriesNo, itemNo);\n                if (!Double.isNaN(y)) {\n                    if (y > 0.0) {\n                        positive += y;\n                    }\n                    else {\n                        negative += y;\n                    }\n                }\n            }\n            if (positive > maximum) {\n                maximum = positive;\n            }\n            if (negative < minimum) {\n                minimum = negative;\n            }\n        }\n        if (minimum <= maximum) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Calculates the total for the y-values in all series for a given item\n     * index.\n     *\n     * @param dataset  the dataset.\n     * @param item  the item index.\n     *\n     * @return The total.\n     *\n     * @since 1.0.5\n     */\n    public static double calculateStackTotal(TableXYDataset dataset, int item) {\n        double total = 0.0;\n        int seriesCount = dataset.getSeriesCount();\n        for (int s = 0; s < seriesCount; s++) {\n            double value = dataset.getYValue(s, item);\n            if (!Double.isNaN(value)) {\n                total = total + value;\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Calculates the range of values for a dataset where each item is the\n     * running total of the items for the current series.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The range.\n     *\n     * @see #findRangeBounds(CategoryDataset)\n     */\n    public static Range findCumulativeRangeBounds(CategoryDataset dataset) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        boolean allItemsNull = true; // we'll set this to false if there is at\n                                     // least one non-null data item...\n        double minimum = 0.0;\n        double maximum = 0.0;\n        for (int row = 0; row < dataset.getRowCount(); row++) {\n            double runningTotal = 0.0;\n            for (int column = 0; column <= dataset.getColumnCount() - 1;\n                 column++) {\n                Number n = dataset.getValue(row, column);\n                if (n != null) {\n                    allItemsNull = false;\n                    double value = n.doubleValue();\n                    if (!Double.isNaN(value)) {\n                        runningTotal = runningTotal + value;\n                        minimum = Math.min(minimum, runningTotal);\n                        maximum = Math.max(maximum, runningTotal);\n                    }\n                }\n            }\n        }\n        if (!allItemsNull) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"code\": \"DatasetUtilities.java\",\n         \"line\": 15,\n         \"severity\": \"warning\",\n         \"message\": \"The method 'createCategoryDataset()' is not called with any arguments\"\n      },\n      {\n         \"code\": \"DatasetUtilities.java\",\n         \"line\": 18,\n         \"severity\": \"error\",\n         \"message\": \"The method 'createNumberArray()' is deprecated and removed from 'DataUtilities'\"\n      },\n      {\n         \"code\": \"DatasetUtilities.java\",\n         \"line\": 21,\n         \"severity\": \"error\",\n         \"message\": \"The method 'createNumberArray2D()' is deprecated and removed from 'DataUtilities'\"\n      },\n      {\n         \"code\": \"DatasetUtilities.java\",\n         \"line\": 24,\n         \"severity\": \"warning\",\n         \"message\": \"The method 'findStackedRangeBounds()' is not null-safe\"\n      },\n      {\n         \"code\": \"DatasetUtilities.java\",\n         \"line\": 27,\n         \"severity\": \"warning\",\n         \"message\": \"The method 'findCumulativeRangeBounds()' is not null-safe\"\n      },\n      {\n         \"code\": \"DatasetUtilities.java\",\n         \"line\": 30,\n         \"severity\": \"warning\",\n         \"message\": \"The method 'iterateXYRangeBounds()' is not null-safe\"\n      }\n   ]\n}"}}