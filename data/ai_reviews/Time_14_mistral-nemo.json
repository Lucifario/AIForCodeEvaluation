{"sample_id": "Time_14", "model": "mistral-nemo", "code_context": "/*\n *  Copyright 2001-2005 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.chrono;\n\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DurationField;\nimport org.joda.time.ReadablePartial;\nimport org.joda.time.field.FieldUtils;\nimport org.joda.time.field.ImpreciseDateTimeField;\n\n/**\n * Provides time calculations for the month of the year component of time.\n *\n * @author Guy Allard\n * @author Stephen Colebourne\n * @author Brian S O'Neill\n * @since 1.2, refactored from GJMonthOfYearDateTimeField\n */\nclass BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -8258715387168736L;\n\n    private static final int MIN = DateTimeConstants.JANUARY;\n\n    private final BasicChronology iChronology;\n    private final int iMax;\n    private final int iLeapMonth;\n\n    /**\n     * Restricted constructor.\n     * \n     * @param leapMonth the month of year that leaps\n     */\n    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n        iChronology = chronology;\n        iMax = iChronology.getMaxMonth();\n        iLeapMonth = leapMonth;\n    }\n\n    //-----------------------------------------------------------------------\n    public boolean isLenient() {\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Get the Month component of the specified time instant.\n     *\n     * @see org.joda.time.DateTimeField#get(long)\n     * @see org.joda.time.ReadableDateTime#getMonthOfYear()\n     * @param instant  the time instant in millis to query.\n     * @return the month extracted from the input.\n     */\n    public int get(long instant) {\n        return iChronology.getMonthOfYear(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Add the specified month to the specified time instant.\n     * The amount added may be negative.<p>\n     * If the new month has less total days than the specified\n     * day of the month, this value is coerced to the nearest\n     * sane value. e.g.<p>\n     * 07-31 - (1 month) = 06-30<p>\n     * 03-31 - (1 month) = 02-28 or 02-29 depending<p>\n     * \n     * @see org.joda.time.DateTimeField#add\n     * @see org.joda.time.ReadWritableDateTime#addMonths(int)\n     * @param instant  the time instant in millis to update.\n     * @param months  the months to add (can be negative).\n     * @return the updated time instant.\n     */\n    public long add(long instant, int months) {\n        if (months == 0) {\n            return instant; // the easy case\n        }\n        //\n        // Save time part first.\n        //\n        long timePart = iChronology.getMillisOfDay(instant);\n        //\n        //\n        // Get this year and month.\n        //\n        int thisYear = iChronology.getYear(instant);\n        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n        // ----------------------------------------------------------\n        //\n        // Do not refactor without careful consideration.\n        // Order of calculation is important.\n        //\n        int yearToUse;\n        // Initially, monthToUse is zero-based\n        int monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / iMax);\n            monthToUse = (monthToUse % iMax) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / iMax) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = monthToUse % iMax;\n            // Take care of the boundary condition\n            if (remMonthToUse == 0) {\n                remMonthToUse = iMax;\n            }\n            monthToUse = iMax - remMonthToUse + 1;\n            // Take care of the boundary condition\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n        // End of do not refactor.\n        // ----------------------------------------------------------\n\n        //\n        // Quietly force DOM to nearest sane value.\n        //\n        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n        //\n        // get proper date part, and return result\n        //\n        long datePart =\n            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n        return datePart + timePart;\n    }\n\n    //-----------------------------------------------------------------------\n    public long add(long instant, long months) {\n        int i_months = (int)months;\n        if (i_months == months) {\n            return add(instant, i_months);\n        }\n\n        // Copied from add(long, int) and modified slightly:\n\n        long timePart = iChronology.getMillisOfDay(instant);\n\n        int thisYear = iChronology.getYear(instant);\n        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n\n        long yearToUse;\n        long monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / iMax);\n            monthToUse = (monthToUse % iMax) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / iMax) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = (int)(monthToUse % iMax);\n            if (remMonthToUse == 0) {\n                remMonthToUse = iMax;\n            }\n            monthToUse = iMax - remMonthToUse + 1;\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n\n        if (yearToUse < iChronology.getMinYear() ||\n            yearToUse > iChronology.getMaxYear()) {\n\n            throw new IllegalArgumentException\n                (\"Magnitude of add amount is too large: \" + months);\n        }\n\n        int i_yearToUse = (int)yearToUse;\n        int i_monthToUse = (int)monthToUse;\n\n        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n\n        long datePart =\n            iChronology.getYearMonthDayMillis(i_yearToUse, i_monthToUse, dayToUse);\n        return datePart + timePart;\n    }\n\n    //-----------------------------------------------------------------------\n    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Add to the Month component of the specified time instant\n     * wrapping around within that component if necessary.\n     * \n     * @see org.joda.time.DateTimeField#addWrapField\n     * @param instant  the time instant in millis to update.\n     * @param months  the months to add (can be negative).\n     * @return the updated time instant.\n     */\n    public long addWrapField(long instant, int months) {\n        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, iMax));\n    }\n\n    //-----------------------------------------------------------------------\n    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        if (minuendInstant < subtrahendInstant) {\n            return -getDifference(subtrahendInstant, minuendInstant);\n        }\n\n        int minuendYear = iChronology.getYear(minuendInstant);\n        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);\n        int subtrahendYear = iChronology.getYear(subtrahendInstant);\n        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);\n\n        long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth;\n\n        // Before adjusting for remainder, account for special case of add\n        // where the day-of-month is forced to the nearest sane value.\n        int minuendDom = iChronology.getDayOfMonth\n            (minuendInstant, minuendYear, minuendMonth);\n        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n            // Last day of the minuend month...\n            int subtrahendDom = iChronology.getDayOfMonth\n                (subtrahendInstant, subtrahendYear, subtrahendMonth);\n            if (subtrahendDom > minuendDom) {\n                // ...and day of subtrahend month is larger.\n                // Note: This works fine, but it ideally shouldn't invoke other\n                // fields from within a field.\n                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);\n            }\n        }\n\n        // Inlined remainder method to avoid duplicate calls.\n        long minuendRem = minuendInstant\n            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n        long subtrahendRem = subtrahendInstant\n            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n\n        if (minuendRem < subtrahendRem) {\n            difference--;\n        }\n\n        return difference;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Set the Month component of the specified time instant.<p>\n     * If the new month has less total days than the specified\n     * day of the month, this value is coerced to the nearest\n     * sane value. e.g.<p>\n     * 07-31 to month 6 = 06-30<p>\n     * 03-31 to month 2 = 02-28 or 02-29 depending<p>\n     * \n     * @param instant  the time instant in millis to update.\n     * @param month  the month (1,12) to update the time to.\n     * @return the updated time instant.\n     * @throws IllegalArgumentException  if month is invalid\n     */\n    public long set(long instant, int month) {\n        FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n        //\n        int thisYear = iChronology.getYear(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.getMillisOfDay(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }\n\n    //-----------------------------------------------------------------------\n    public boolean isLeap(long instant) {\n        int thisYear = iChronology.getYear(instant);\n        if (iChronology.isLeapYear(thisYear)) {\n            return (iChronology.getMonthOfYear(instant, thisYear) == iLeapMonth);\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    public int getLeapAmount(long instant) {\n        return isLeap(instant) ? 1 : 0;\n    }\n\n    //-----------------------------------------------------------------------\n    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }\n\n    //-----------------------------------------------------------------------\n    public int getMinimumValue() {\n        return MIN;\n    }\n\n    //-----------------------------------------------------------------------\n    public int getMaximumValue() {\n        return iMax;\n    }\n\n    //-----------------------------------------------------------------------\n    public long roundFloor(long instant) {\n        int year = iChronology.getYear(instant);\n        int month = iChronology.getMonthOfYear(instant, year);\n        return iChronology.getYearMonthMillis(year, month);\n    }\n\n    //-----------------------------------------------------------------------\n    public long remainder(long instant) {\n        return instant - roundFloor(instant);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Serialization singleton\n     */\n    private Object readResolve() {\n        return iChronology.monthOfYear();\n    }\n}\n", "review": {"response": "{ \"bugs\": [] }"}}