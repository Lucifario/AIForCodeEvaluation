{"sample_id": "Closure_56", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2009 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Charsets;\nimport com.google.common.io.CharStreams;\nimport com.google.common.io.Files;\nimport com.google.javascript.rhino.jstype.StaticSourceFile;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.io.StringReader;\nimport java.nio.charset.Charset;\n\n/**\n * An abstract representation of a source file that provides access to\n * language-neutral features. The source file can be loaded from various\n * locations, such as from disk or from a preloaded string.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\npublic class SourceFile implements StaticSourceFile, Serializable {\n  private static final long serialVersionUID = 1L;\n\n  /** A JavaScript source code provider.  The value should\n   * be cached so that the source text stays consistent throughout a single\n   * compile. */\n  public interface Generator {\n    public String getCode();\n  }\n\n  /**\n   * Number of lines in the region returned by {@link #getRegion(int)}.\n   * This length must be odd.\n   */\n  private static final int SOURCE_EXCERPT_REGION_LENGTH = 5;\n\n  private final String fileName;\n  private boolean isExternFile = false;\n\n  // The fileName may not always identify the original file - for example,\n  // supersourced Java inputs, or Java inputs that come from Jar files. This\n  // is an optional field that the creator of an AST or SourceFile can set.\n  // It could be a path to the original file, or in case this SourceFile came\n  // from a Jar, it could be the path to the Jar.\n  private String originalPath = null;\n\n  // Source Line Information\n  private int[] lineOffsets = null;\n\n  // Remember the offset for the previous line query.  If the next line\n  // is after this point, we can start scanning at the previous offset rather\n  // than starting at the beginning of the file.\n  private int lastOffset;\n  private int lastLine;\n\n  private String code = null;\n\n  /**\n   * Construct a new abstract source file.\n   *\n   * @param fileName The file name of the source file. It does not necessarily\n   *     need to correspond to a real path. But it should be unique. Will\n   *     appear in warning messages emitted by the compiler.\n   */\n  public SourceFile(String fileName) {\n    if (fileName == null || fileName.isEmpty()) {\n      throw new IllegalArgumentException(\"a source must have a name\");\n    }\n    this.fileName = fileName;\n    // Starting point: offset 0 is at line 1.\n    this.lastOffset = 0;\n    this.lastLine = 1;\n  }\n\n  @Override\n  public int getLineOffset(int lineno) {\n    if (lineOffsets == null) {\n      findLineOffsets();\n    }\n    if (lineno < 1 || lineno > lineOffsets.length) {\n      throw new IllegalArgumentException(\n          \"Expected line number between 1 and \" + lineOffsets.length +\n          \"\\nActual: \" + lineno);\n    }\n    return lineOffsets[lineno - 1];\n  }\n\n  /** @return The number of lines in this source file. */\n  int getNumLines() {\n    if (lineOffsets == null) {\n      findLineOffsets();\n    }\n    return lineOffsets.length;\n  }\n\n  private void findLineOffsets() {\n    try {\n      String[] sourceLines = getCode().split(\"\\n\");\n      lineOffsets = new int[sourceLines.length];\n      for (int ii = 1; ii < sourceLines.length; ++ii) {\n        lineOffsets[ii] =\n            lineOffsets[ii - 1] + sourceLines[ii - 1].length() + 1;\n      }\n    } catch (IOException e) {\n      lineOffsets = new int[1];\n      lineOffsets[0] = 0;\n    }\n  }\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementation\n\n  /**\n   * Gets all the code in this source file.\n   * @throws IOException\n   */\n  public String getCode() throws IOException {\n    return code;\n  }\n\n  /**\n   * Gets a reader for the code in this source file.\n   */\n  public Reader getCodeReader() throws IOException {\n    return new StringReader(getCode());\n  }\n\n  @VisibleForTesting\n  String getCodeNoCache() {\n    return code;\n  }\n\n  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }\n\n  public String getOriginalPath() {\n    return originalPath != null ? originalPath : fileName;\n  }\n\n  public void setOriginalPath(String originalPath) {\n    this.originalPath = originalPath;\n  }\n\n  // For SourceFile types which cache source code that can be regenerated\n  // easily, flush the cache.  We maintain the cache mostly to speed up\n  // generating source when displaying error messages, so dumping the file\n  // contents after the compile is a fine thing to do.\n  public void clearCachedSource() {\n    // By default, do nothing.  Not all kinds of SourceFiles can regenerate\n    // code.\n  }\n\n  boolean hasSourceInMemory() {\n    return code != null;\n  }\n\n  /** Returns a unique name for the source file. */\n  @Override\n  public String getName() {\n    return fileName;\n  }\n\n  /** Returns whether this is an extern. */\n  @Override\n  public boolean isExtern() {\n    return isExternFile;\n  }\n\n  /** Sets that this is an extern. */\n  void setIsExtern(boolean newVal) {\n    isExternFile = newVal;\n  }\n\n  /**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }\n\n  /**\n   * Get a region around the indicated line number. The exact definition of a\n   * region is implementation specific, but it must contain the line indicated\n   * by the line number. A region must not start or end by a carriage return.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public Region getRegion(int lineNumber) {\n    String js = \"\";\n    try {\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n    int pos = 0;\n    int startLine = Math.max(1,\n        lineNumber - (SOURCE_EXCERPT_REGION_LENGTH + 1) / 2 + 1);\n    for (int n = 1; n < startLine; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        break;\n      }\n      pos = nextpos + 1;\n    }\n    int end = pos;\n    int endLine = startLine;\n    for (int n = 0; n < SOURCE_EXCERPT_REGION_LENGTH; n++, endLine++) {\n      end = js.indexOf('\\n', end);\n      if (end == -1) {\n        break;\n      }\n      end++;\n    }\n    if (lineNumber >= endLine) {\n      return null;\n    }\n    if (end == -1) {\n      int last = js.length() - 1;\n      if (js.charAt(last) == '\\n') {\n        return\n            new SimpleRegion(startLine, endLine, js.substring(pos, last));\n      } else {\n        return new SimpleRegion(startLine, endLine, js.substring(pos));\n      }\n    } else {\n      return new SimpleRegion(startLine, endLine, js.substring(pos, end));\n    }\n  }\n\n  @Override\n  public String toString() {\n    return fileName;\n  }\n\n  public static SourceFile fromFile(String fileName, Charset c) {\n    return fromFile(new File(fileName), c);\n  }\n\n  public static SourceFile fromFile(String fileName) {\n    return fromFile(new File(fileName));\n  }\n\n  public static SourceFile fromFile(File file, Charset c) {\n    return new OnDisk(file, c);\n  }\n\n  public static SourceFile fromFile(File file) {\n    return new OnDisk(file);\n  }\n\n  public static SourceFile fromCode(String fileName, String code) {\n    return new Preloaded(fileName, code);\n  }\n\n  public static SourceFile fromCode(String fileName,\n      String originalPath, String code) {\n    return new Preloaded(fileName, originalPath, code);\n  }\n\n  public static SourceFile fromInputStream(String fileName, InputStream s)\n      throws IOException {\n    return fromCode(fileName,\n        CharStreams.toString(new InputStreamReader(s, Charsets.UTF_8)));\n  }\n\n  public static SourceFile fromInputStream(String fileName,\n      String originalPath, InputStream s) throws IOException {\n    return fromCode(fileName, originalPath,\n        CharStreams.toString(new InputStreamReader(s, Charsets.UTF_8)));\n  }\n\n  public static SourceFile fromReader(String fileName, Reader r)\n      throws IOException {\n    return fromCode(fileName, CharStreams.toString(r));\n  }\n\n  public static SourceFile fromGenerator(String fileName,\n      Generator generator) {\n    return new Generated(fileName, generator);\n  }\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Implementations\n\n  /**\n   * A source file where the code has been preloaded.\n   */\n  static class Preloaded extends SourceFile {\n    private static final long serialVersionUID = 1L;\n\n    Preloaded(String fileName, String code) {\n      this(fileName, fileName, code);\n    }\n\n    Preloaded(String fileName, String originalPath, String code) {\n      super(fileName);\n      super.setOriginalPath(originalPath);\n      super.setCode(code);\n    }\n  }\n\n  /**\n   * A source file where the code will be dynamically generated\n   * from the injected interface.\n   */\n  static class Generated extends SourceFile {\n    private static final long serialVersionUID = 1L;\n    private final Generator generator;\n\n    // Not private, so that LazyInput can extend it.\n    Generated(String fileName, Generator generator) {\n      super(fileName);\n      this.generator = generator;\n    }\n\n    @Override\n    public synchronized String getCode() throws IOException {\n      String cachedCode = super.getCode();\n\n      if (cachedCode == null) {\n        cachedCode = generator.getCode();\n        super.setCode(cachedCode);\n      }\n      return cachedCode;\n    }\n\n    // Clear out the generated code when finished with a compile; we can\n    // regenerate it if we ever need it again.\n    @Override\n    public void clearCachedSource() {\n      super.setCode(null);\n    }\n  }\n\n  /**\n   * A source file where the code is only read into memory if absolutely\n   * necessary. We will try to delay loading the code into memory as long as\n   * possible.\n   */\n  static class OnDisk extends SourceFile {\n    private static final long serialVersionUID = 1L;\n    private final File file;\n\n    // This is stored as a String, but passed in and out as a Charset so that\n    // we can serialize the class.\n    // Default input file format for JSCompiler has always been UTF_8.\n    protected String inputCharset = Charsets.UTF_8.name();\n\n    OnDisk(File file, Charset c) {\n      this(file);\n      if (c != null) {\n        this.setCharset(c);\n      }\n    }\n\n    // No Charset provided?\n    OnDisk(File file) {\n      super(file.getPath());\n      this.file = file;\n    }\n\n    @Override\n    public synchronized String getCode() throws IOException {\n      String cachedCode = super.getCode();\n\n      if (cachedCode == null) {\n        cachedCode = Files.toString(file, this.getCharset());\n        super.setCode(cachedCode);\n      }\n      return cachedCode;\n    }\n\n    /**\n     * Gets a reader for the code in this source file.\n     */\n    @Override\n    public Reader getCodeReader() throws IOException {\n      if (hasSourceInMemory()) {\n        return super.getCodeReader();\n      } else {\n        // If we haven't pulled the code into memory yet, don't.\n        return new FileReader(file);\n      }\n    }\n\n    // Flush the cached code after the compile; we can read it off disk\n    // if we need it again.\n    @Override\n    public void clearCachedSource() {\n      super.setCode(null);\n    }\n\n    /**\n     * Store the Charset specification as the string version of the name,\n     * rather than the Charset itself.  This allows us to serialize the\n     * SourceFile class.\n     * @param c charset to use when reading the input.\n     */\n    public void setCharset(Charset c) {\n      inputCharset = c.name();\n    }\n\n    /**\n     * Get the Charset specifying how we're supposed to read the file\n     * in off disk and into UTF-16.  This is stored as a strong to allow\n     * SourceFile to be serialized.\n     * @return Charset object representing charset to use.\n     */\n    public Charset getCharset() {\n      return Charset.forName(inputCharset);\n    }\n  }\n}\n", "review": {"response": "{ \"bugs\": [\n\n  ]}"}}