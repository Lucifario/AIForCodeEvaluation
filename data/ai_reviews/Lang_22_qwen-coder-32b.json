{"sample_id": "Lang_22", "model": "qwen-coder-32b", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.math;\n\nimport java.math.BigInteger;\n\n/**\n * <p><code>Fraction</code> is a <code>Number</code> implementation that\n * stores fractions accurately.</p>\n *\n * <p>This class is immutable, and interoperable with most methods that accept\n * a <code>Number</code>.</p>\n *\n * <p>Note that this class is intended for common use cases, it is <i>int</i>\n * based and thus suffers from various overflow issues. For a BigInteger based \n * equivalent, please see the Commons Math BigFraction class. </p>\n *\n * @author Apache Software Foundation\n * @author Travis Reeder\n * @author Tim O'Brien\n * @author Pete Gieser\n * @author C. Scott Ananian\n * @since 2.0\n * @version $Id$\n */\npublic final class Fraction extends Number implements Comparable<Fraction> {\n\n    /**\n     * Required for serialization support. Lang version 2.0.\n     * \n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 65382027393090L;\n\n    /**\n     * <code>Fraction</code> representation of 0.\n     */\n    public static final Fraction ZERO = new Fraction(0, 1);\n    /**\n     * <code>Fraction</code> representation of 1.\n     */\n    public static final Fraction ONE = new Fraction(1, 1);\n    /**\n     * <code>Fraction</code> representation of 1/2.\n     */\n    public static final Fraction ONE_HALF = new Fraction(1, 2);\n    /**\n     * <code>Fraction</code> representation of 1/3.\n     */\n    public static final Fraction ONE_THIRD = new Fraction(1, 3);\n    /**\n     * <code>Fraction</code> representation of 2/3.\n     */\n    public static final Fraction TWO_THIRDS = new Fraction(2, 3);\n    /**\n     * <code>Fraction</code> representation of 1/4.\n     */\n    public static final Fraction ONE_QUARTER = new Fraction(1, 4);\n    /**\n     * <code>Fraction</code> representation of 2/4.\n     */\n    public static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n    /**\n     * <code>Fraction</code> representation of 3/4.\n     */\n    public static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n    /**\n     * <code>Fraction</code> representation of 1/5.\n     */\n    public static final Fraction ONE_FIFTH = new Fraction(1, 5);\n    /**\n     * <code>Fraction</code> representation of 2/5.\n     */\n    public static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n    /**\n     * <code>Fraction</code> representation of 3/5.\n     */\n    public static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n    /**\n     * <code>Fraction</code> representation of 4/5.\n     */\n    public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n\n\n    /**\n     * The numerator number part of the fraction (the three in three sevenths).\n     */\n    private final int numerator;\n    /**\n     * The denominator number part of the fraction (the seven in three sevenths).\n     */\n    private final int denominator;\n\n    /**\n     * Cached output hashCode (class is immutable).\n     */\n    private transient int hashCode = 0;\n    /**\n     * Cached output toString (class is immutable).\n     */\n    private transient String toString = null;\n    /**\n     * Cached output toProperString (class is immutable).\n     */\n    private transient String toProperString = null;\n\n    /**\n     * <p>Constructs a <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     */\n    private Fraction(int numerator, int denominator) {\n        super();\n        this.numerator = numerator;\n        this.denominator = denominator;\n    }\n\n    /**\n     * <p>Creates a <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance\n     * @throws ArithmeticException if the denominator is <code>zero</code>\n     * or the denominator is {@code negative} and the numerator is {@code Integer#MIN_VALUE}\n     */\n    public static Fraction getFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        return new Fraction(numerator, denominator);\n    }\n\n    /**\n     * <p>Creates a <code>Fraction</code> instance with the 3 parts\n     * of a fraction X Y/Z.</p>\n     *\n     * <p>The negative sign must be passed in on the whole number part.</p>\n     *\n     * @param whole  the whole number, for example the one in 'one and three sevenths'\n     * @param numerator  the numerator, for example the three in 'one and three sevenths'\n     * @param denominator  the denominator, for example the seven in 'one and three sevenths'\n     * @return a new fraction instance\n     * @throws ArithmeticException if the denominator is <code>zero</code>\n     * @throws ArithmeticException if the denominator is negative\n     * @throws ArithmeticException if the numerator is negative\n     * @throws ArithmeticException if the resulting numerator exceeds \n     *  <code>Integer.MAX_VALUE</code>\n     */\n    public static Fraction getFraction(int whole, int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (denominator < 0) {\n            throw new ArithmeticException(\"The denominator must not be negative\");\n        }\n        if (numerator < 0) {\n            throw new ArithmeticException(\"The numerator must not be negative\");\n        }\n        long numeratorValue;\n        if (whole < 0) {\n            numeratorValue = whole * (long)denominator - numerator;\n        } else {\n            numeratorValue = whole * (long)denominator + numerator;\n        }\n        if (numeratorValue < Integer.MIN_VALUE ||\n                numeratorValue > Integer.MAX_VALUE)  {\n            throw new ArithmeticException(\"Numerator too large to represent as an Integer.\");\n        }\n        return new Fraction((int) numeratorValue, denominator);\n    }\n\n    /**\n     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>For example, if the input parameters represent 2/4, then the created\n     * fraction will be 1/2.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws ArithmeticException if the denominator is <code>zero</code>\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator==0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = greatestCommonDivisor(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n\n    /**\n     * <p>Creates a <code>Fraction</code> instance from a <code>double</code> value.</p>\n     *\n     * <p>This method uses the <a href=\"http://archives.math.utk.edu/articles/atuyl/confrac/\">\n     *  continued fraction algorithm</a>, computing a maximum of\n     *  25 convergents and bounding the denominator by 10,000.</p>\n     *\n     * @param value  the double value to convert\n     * @return a new fraction instance that is close to the value\n     * @throws ArithmeticException if <code>|value| > Integer.MAX_VALUE</code> \n     *  or <code>value = NaN</code>\n     * @throws ArithmeticException if the calculated denominator is <code>zero</code>\n     * @throws ArithmeticException if the the algorithm does not converge\n     */\n    public static Fraction getFraction(double value) {\n        int sign = (value < 0 ? -1 : 1);\n        value = Math.abs(value);\n        if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n            throw new ArithmeticException\n                (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n        }\n        int wholeNumber = (int) value;\n        value -= wholeNumber;\n        \n        int numer0 = 0;  // the pre-previous\n        int denom0 = 1;  // the pre-previous\n        int numer1 = 1;  // the previous\n        int denom1 = 0;  // the previous\n        int numer2 = 0;  // the current, setup in calculation\n        int denom2 = 0;  // the current, setup in calculation\n        int a1 = (int) value;\n        int a2 = 0;\n        double x1 = 1;\n        double x2 = 0;\n        double y1 = value - a1;\n        double y2 = 0;\n        double delta1, delta2 = Double.MAX_VALUE;\n        double fraction;\n        int i = 1;\n//        System.out.println(\"---\");\n        do {\n            delta1 = delta2;\n            a2 = (int) (x1 / y1);\n            x2 = y1;\n            y2 = x1 - a2 * y1;\n            numer2 = a1 * numer1 + numer0;\n            denom2 = a1 * denom1 + denom0;\n            fraction = (double) numer2 / (double) denom2;\n            delta2 = Math.abs(value - fraction);\n//            System.out.println(numer2 + \" \" + denom2 + \" \" + fraction + \" \" + delta2 + \" \" + y1);\n            a1 = a2;\n            x1 = x2;\n            y1 = y2;\n            numer0 = numer1;\n            denom0 = denom1;\n            numer1 = numer2;\n            denom1 = denom2;\n            i++;\n//            System.out.println(\">>\" + delta1 +\" \"+ delta2+\" \"+(delta1 > delta2)+\" \"+i+\" \"+denom2);\n        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));\n        if (i == 25) {\n            throw new ArithmeticException(\"Unable to convert double to fraction\");\n        }\n        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n    }\n\n    /**\n     * <p>Creates a Fraction from a <code>String</code>.</p>\n     *\n     * <p>The formats accepted are:</p>\n     *\n     * <ol>\n     *  <li><code>double</code> String containing a dot</li>\n     *  <li>'X Y/Z'</li>\n     *  <li>'Y/Z'</li>\n     *  <li>'X' (a simple whole number)</li>\n     * </ol>\n     * and a .</p>\n     *\n     * @param str  the string to parse, must not be <code>null</code>\n     * @return the new <code>Fraction</code> instance\n     * @throws IllegalArgumentException if the string is <code>null</code>\n     * @throws NumberFormatException if the number format is invalid\n     */\n    public static Fraction getFraction(String str) {\n        if (str == null) {\n            throw new IllegalArgumentException(\"The string must not be null\");\n        }\n        // parse double format\n        int pos = str.indexOf('.');\n        if (pos >= 0) {\n            return getFraction(Double.parseDouble(str));\n        }\n\n        // parse X Y/Z format\n        pos = str.indexOf(' ');\n        if (pos > 0) {\n            int whole = Integer.parseInt(str.substring(0, pos));\n            str = str.substring(pos + 1);\n            pos = str.indexOf('/');\n            if (pos < 0) {\n                throw new NumberFormatException(\"The fraction could not be parsed as the format X Y/Z\");\n            } else {\n                int numer = Integer.parseInt(str.substring(0, pos));\n                int denom = Integer.parseInt(str.substring(pos + 1));\n                return getFraction(whole, numer, denom);\n            }\n        }\n\n        // parse Y/Z format\n        pos = str.indexOf('/');\n        if (pos < 0) {\n            // simple whole number\n            return getFraction(Integer.parseInt(str), 1);\n        } else {\n            int numer = Integer.parseInt(str.substring(0, pos));\n            int denom = Integer.parseInt(str.substring(pos + 1));\n            return getFraction(numer, denom);\n        }\n    }\n\n    // Accessors\n    //-------------------------------------------------------------------\n\n    /**\n     * <p>Gets the numerator part of the fraction.</p>\n     *\n     * <p>This method may return a value greater than the denominator, an\n     * improper fraction, such as the seven in 7/4.</p>\n     *\n     * @return the numerator fraction part\n     */\n    public int getNumerator() {\n        return numerator;\n    }\n\n    /**\n     * <p>Gets the denominator part of the fraction.</p>\n     *\n     * @return the denominator fraction part\n     */\n    public int getDenominator() {\n        return denominator;\n    }\n\n    /**\n     * <p>Gets the proper numerator, always positive.</p>\n     *\n     * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.\n     * This method returns the 3 from the proper fraction.</p>\n     *\n     * <p>If the fraction is negative such as -7/4, it can be resolved into\n     * -1 3/4, so this method returns the positive proper numerator, 3.</p>\n     *\n     * @return the numerator fraction part of a proper fraction, always positive\n     */\n    public int getProperNumerator() {\n        return Math.abs(numerator % denominator);\n    }\n\n    /**\n     * <p>Gets the proper whole part of the fraction.</p>\n     *\n     * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.\n     * This method returns the 1 from the proper fraction.</p>\n     *\n     * <p>If the fraction is negative such as -7/4, it can be resolved into\n     * -1 3/4, so this method returns the positive whole part -1.</p>\n     *\n     * @return the whole fraction part of a proper fraction, that includes the sign\n     */\n    public int getProperWhole() {\n        return numerator / denominator;\n    }\n\n    // Number methods\n    //-------------------------------------------------------------------\n\n    /**\n     * <p>Gets the fraction as an <code>int</code>. This returns the whole number\n     * part of the fraction.</p>\n     *\n     * @return the whole number fraction part\n     */\n    @Override\n    public int intValue() {\n        return numerator / denominator;\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>long</code>. This returns the whole number\n     * part of the fraction.</p>\n     *\n     * @return the whole number fraction part\n     */\n    @Override\n    public long longValue() {\n        return (long) numerator / denominator;\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>float</code>. This calculates the fraction\n     * as the numerator divided by denominator.</p>\n     *\n     * @return the fraction as a <code>float</code>\n     */\n    @Override\n    public float floatValue() {\n        return ((float) numerator) / ((float) denominator);\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>double</code>. This calculates the fraction\n     * as the numerator divided by denominator.</p>\n     *\n     * @return the fraction as a <code>double</code>\n     */\n    @Override\n    public double doubleValue() {\n        return ((double) numerator) / ((double) denominator);\n    }\n\n    // Calculations\n    //-------------------------------------------------------------------\n\n    /**\n     * <p>Reduce the fraction to the smallest values for the numerator and\n     * denominator, returning the result.</p>\n     * \n     * <p>For example, if this fraction represents 2/4, then the result\n     * will be 1/2.</p>\n     *\n     * @return a new reduced fraction instance, or this if no simplification possible\n     */\n    public Fraction reduce() {\n        if (numerator == 0) {\n            return equals(ZERO) ? this : ZERO;\n        }\n        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n        if (gcd == 1) {\n            return this;\n        }\n        return Fraction.getFraction(numerator / gcd, denominator / gcd);\n    }\n\n    /**\n     * <p>Gets a fraction that is the inverse (1/fraction) of this one.</p>\n     * \n     * <p>The returned fraction is not reduced.</p>\n     *\n     * @return a new fraction instance with the numerator and denominator\n     *         inverted.\n     * @throws ArithmeticException if the fraction represents zero.\n     */\n    public Fraction invert() {\n        if (numerator == 0) {\n            throw new ArithmeticException(\"Unable to invert zero.\");\n        }\n        if (numerator==Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"overflow: can't negate numerator\");\n        }\n        if (numerator<0) {\n            return new Fraction(-denominator, -numerator);\n        } else {\n            return new Fraction(denominator, numerator);\n        }\n    }\n\n    /**\n     * <p>Gets a fraction that is the negative (-fraction) of this one.</p>\n     *\n     * <p>The returned fraction is not reduced.</p>\n     *\n     * @return a new fraction instance with the opposite signed numerator\n     */\n    public Fraction negate() {\n        // the positive range is one smaller than the negative range of an int.\n        if (numerator==Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"overflow: too large to negate\");\n        }\n        return new Fraction(-numerator, denominator);\n    }\n\n    /**\n     * <p>Gets a fraction that is the positive equivalent of this one.</p>\n     * <p>More precisely: <code>(fraction >= 0 ? this : -fraction)</code></p>\n     *\n     * <p>The returned fraction is not reduced.</p>\n     *\n     * @return <code>this</code> if it is positive, or a new positive fraction\n     *  instance with the opposite signed numerator\n     */\n    public Fraction abs() {\n        if (numerator >= 0) {\n            return this;\n        }\n        return negate();\n    }\n\n    /**\n     * <p>Gets a fraction that is raised to the passed in power.</p>\n     *\n     * <p>The returned fraction is in reduced form.</p>\n     *\n     * @param power  the power to raise the fraction to\n     * @return <code>this</code> if the power is one, <code>ONE</code> if the power\n     * is zero (even if the fraction equals ZERO) or a new fraction instance \n     * raised to the appropriate power\n     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n     *  <code>Integer.MAX_VALUE</code>\n     */\n    public Fraction pow(int power) {\n        if (power == 1) {\n            return this;\n        } else if (power == 0) {\n            return ONE;\n        } else if (power < 0) {\n            if (power==Integer.MIN_VALUE) { // MIN_VALUE can't be negated.\n                return this.invert().pow(2).pow(-(power/2));\n            }\n            return this.invert().pow(-power);\n        } else {\n            Fraction f = this.multiplyBy(this);\n            if ((power % 2) == 0) { // if even...\n                return f.pow(power/2);\n            } else { // if odd...\n                return f.pow(power/2).multiplyBy(this);\n            }\n        }\n    }\n\n    /**\n     * <p>Gets the greatest common divisor of the absolute value of\n     * two numbers, using the \"binary gcd\" method which avoids\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n     * This algorithm is due to Josef Stein (1961).</p>\n     *\n     * @param u  a non-zero number\n     * @param v  a non-zero number\n     * @return the greatest common divisor, never zero\n     */\n    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        //if either operand is abs 1, return 1:\n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }\n\n    // Arithmetic\n    //-------------------------------------------------------------------\n\n    /** \n     * Multiply two integers, checking for overflow.\n     * \n     * @param x a factor\n     * @param y a factor\n     * @return the product <code>x*y</code>\n     * @throws ArithmeticException if the result can not be represented as\n     *                             an int\n     */\n    private static int mulAndCheck(int x, int y) {\n        long m = ((long)x)*((long)y);\n        if (m < Integer.MIN_VALUE ||\n            m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n    \n    /**\n     *  Multiply two non-negative integers, checking for overflow.\n     * \n     * @param x a non-negative factor\n     * @param y a non-negative factor\n     * @return the product <code>x*y</code>\n     * @throws ArithmeticException if the result can not be represented as\n     * an int\n     */\n    private static int mulPosAndCheck(int x, int y) {\n        /* assert x>=0 && y>=0; */\n        long m = ((long)x)*((long)y);\n        if (m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mulPos\");\n        }\n        return (int)m;\n    }\n    \n    /** \n     * Add two integers, checking for overflow.\n     * \n     * @param x an addend\n     * @param y an addend\n     * @return the sum <code>x+y</code>\n     * @throws ArithmeticException if the result can not be represented as\n     * an int\n     */\n    private static int addAndCheck(int x, int y) {\n        long s = (long)x+(long)y;\n        if (s < Integer.MIN_VALUE ||\n            s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n    \n    /** \n     * Subtract two integers, checking for overflow.\n     * \n     * @param x the minuend\n     * @param y the subtrahend\n     * @return the difference <code>x-y</code>\n     * @throws ArithmeticException if the result can not be represented as\n     * an int\n     */\n    private static int subAndCheck(int x, int y) {\n        long s = (long)x-(long)y;\n        if (s < Integer.MIN_VALUE ||\n            s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n    \n    /**\n     * <p>Adds the value of this fraction to another, returning the result in reduced form.\n     * The algorithm follows Knuth, 4.5.1.</p>\n     *\n     * @param fraction  the fraction to add, must not be <code>null</code>\n     * @return a <code>Fraction</code> instance with the resulting values\n     * @throws IllegalArgumentException if the fraction is <code>null</code>\n     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n     *  <code>Integer.MAX_VALUE</code>\n     */\n    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true /* add */);\n    }\n\n    /**\n     * <p>Subtracts the value of another fraction from the value of this one, \n     * returning the result in reduced form.</p>\n     *\n     * @param fraction  the fraction to subtract, must not be <code>null</code>\n     * @return a <code>Fraction</code> instance with the resulting values\n     * @throws IllegalArgumentException if the fraction is <code>null</code>\n     * @throws ArithmeticException if the resulting numerator or denominator\n     *   cannot be represented in an <code>int</code>.\n     */\n    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false /* subtract */);\n    }\n\n    /** \n     * Implement add and subtract using algorithm described in Knuth 4.5.1.\n     * \n     * @param fraction the fraction to subtract, must not be <code>null</code>\n     * @param isAdd true to add, false to subtract\n     * @return a <code>Fraction</code> instance with the resulting values\n     * @throws IllegalArgumentException if the fraction is <code>null</code>\n     * @throws ArithmeticException if the resulting numerator or denominator\n     *   cannot be represented in an <code>int</code>.\n     */\n    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            int uvp = mulAndCheck(numerator, fraction.denominator);\n            int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }\n\n    /**\n     * <p>Multiplies the value of this fraction by another, returning the \n     * result in reduced form.</p>\n     *\n     * @param fraction  the fraction to multiply by, must not be <code>null</code>\n     * @return a <code>Fraction</code> instance with the resulting values\n     * @throws IllegalArgumentException if the fraction is <code>null</code>\n     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n     *  <code>Integer.MAX_VALUE</code>\n     */\n    public Fraction multiplyBy(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        // knuth 4.5.1\n        // make sure we don't overflow unless the result *must* overflow.\n        int d1 = greatestCommonDivisor(numerator, fraction.denominator);\n        int d2 = greatestCommonDivisor(fraction.numerator, denominator);\n        return getReducedFraction\n            (mulAndCheck(numerator/d1, fraction.numerator/d2),\n             mulPosAndCheck(denominator/d2, fraction.denominator/d1));\n    }\n\n    /**\n     * <p>Divide the value of this fraction by another.</p>\n     *\n     * @param fraction  the fraction to divide by, must not be <code>null</code>\n     * @return a <code>Fraction</code> instance with the resulting values\n     * @throws IllegalArgumentException if the fraction is <code>null</code>\n     * @throws ArithmeticException if the fraction to divide by is zero\n     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n     *  <code>Integer.MAX_VALUE</code>\n     */\n    public Fraction divideBy(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (fraction.numerator == 0) {\n            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n        }\n        return multiplyBy(fraction.invert());\n    }\n\n    // Basics\n    //-------------------------------------------------------------------\n\n    /**\n     * <p>Compares this fraction to another object to test if they are equal.</p>.\n     *\n     * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>\n     *\n     * @param obj the reference object with which to compare\n     * @return <code>true</code> if this object is equal\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof Fraction == false) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        return (getNumerator() == other.getNumerator() &&\n                getDenominator() == other.getDenominator());\n    }\n\n    /**\n     * <p>Gets a hashCode for the fraction.</p>\n     *\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        if (hashCode == 0) {\n            // hashcode update should be atomic.\n            hashCode = 37 * (37 * 17 + getNumerator()) + getDenominator();\n        }\n        return hashCode;\n    }\n\n    /**\n     * <p>Compares this object to another based on size.</p>\n     *\n     * <p>Note: this class has a natural ordering that is inconsistent\n     * with equals, because, for example, equals treats 1/2 and 2/4 as\n     * different, whereas compareTo treats them as equal.\n     *\n     * @param other  the object to compare to\n     * @return -1 if this is less, 0 if equal, +1 if greater\n     * @throws ClassCastException if the object is not a <code>Fraction</code>\n     * @throws NullPointerException if the object is <code>null</code>\n     */\n    public int compareTo(Fraction other) {\n        if (this==other) {\n            return 0;\n        }\n        if (numerator == other.numerator && denominator == other.denominator) {\n            return 0;\n        }\n\n        // otherwise see which is less\n        long first = (long) numerator * (long) other.denominator;\n        long second = (long) other.numerator * (long) denominator;\n        if (first == second) {\n            return 0;\n        } else if (first < second) {\n            return -1;\n        } else {\n            return 1;\n        }\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>String</code>.</p>\n     *\n     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\n     *\n     * @return a <code>String</code> form of the fraction\n     */\n    @Override\n    public String toString() {\n        if (toString == null) {\n            toString = new StringBuilder(32)\n                .append(getNumerator())\n                .append('/')\n                .append(getDenominator()).toString();\n        }\n        return toString;\n    }\n\n    /**\n     * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>\n     *\n     * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.\n     * If the whole number is zero it will be ommitted. If the numerator is zero,\n     * only the whole number is returned.</p>\n     *\n     * @return a <code>String</code> form of the fraction\n     */\n    public String toProperString() {\n        if (toProperString == null) {\n            if (numerator == 0) {\n                toProperString = \"0\";\n            } else if (numerator == denominator) {\n                toProperString = \"1\";\n            } else if (numerator == -1 * denominator) {\n                toProperString = \"-1\";\n            } else if ((numerator>0?-numerator:numerator) < -denominator) {\n                // note that we do the magnitude comparison test above with\n                // NEGATIVE (not positive) numbers, since negative numbers\n                // have a larger range.  otherwise numerator==Integer.MIN_VALUE\n                // is handled incorrectly.\n                int properNumerator = getProperNumerator();\n                if (properNumerator == 0) {\n                    toProperString = Integer.toString(getProperWhole());\n                } else {\n                    toProperString = new StringBuilder(32)\n                        .append(getProperWhole()).append(' ')\n                        .append(properNumerator).append('/')\n                        .append(getDenominator()).toString();\n                }\n            } else {\n                toProperString = new StringBuilder(32)\n                    .append(getNumerator()).append('/')\n                    .append(getDenominator()).toString();\n            }\n        }\n        return toProperString;\n    }\n}\n", "review": {"response": "<think>\nOkay, let's take a look at this Java code for the Fraction class. I need to find any bugs in it and return them in a JSON format with a list of bugs. \n\nFirst, I'll start by reading through the code carefully. The class is supposed to represent fractions accurately. The constructor is private, and there's a static getFraction method. The static fields include ZERO, ONE, and others like TWO_QUARTERS. \n\nOne thing I notice right away is that the TWO_QUARTERS static field is initialized as new Fraction(2,4). But 2/4 can be simplified to 1/2. However, the class might handle simplification internally. Wait, looking at the getFraction method, when you create a fraction, it reduces the numerator and denominator by their GCD. Wait, no, in the getFraction method, they check if the denominator is negative and adjust signs, but there's no code to reduce the fraction to its simplest form. Oh, that's a problem. Because if someone creates a fraction like 2/4, the getFraction method would make sure the denominator is positive, but it doesn't simplify the fraction. For example, the TWO_QUARTERS static field is 2/4, but the getFraction method would create it as 2/4, not 1/2. But maybe the constructor doesn't do any simplification. Wait, the constructor just assigns numerator and denominator directly. So the class doesn't automatically reduce fractions. That's a design issue. But the user might not have considered that. However, the user is asking for bugs, not design flaws. But if the code is supposed to represent fractions accurately, maybe it's a bug that fractions aren't stored in their simplest form. For example, if you create a fraction with 2 and 4, it's 0.5, but the internal representation is 2/4. That could lead to inconsistencies. But maybe the code is designed that way for performance or other reasons. However, the documentation says \"stores fractions accurately,\" which might imply that they are stored in reduced form. Let me check the getFraction method again. \n\nLooking at getFraction(int numerator, int denominator): the code checks if denominator is negative and moves the sign to the numerator. But there's no code to compute the greatest common divisor (GCD) and divide both numerator and denominator by it. So, for example, getFraction(2,4) would create a Fraction with numerator 2 and denominator 4. But when you perform operations like addition or multiplication, those operations would need to handle the GCD. However, the code provided here doesn't show those methods, so maybe the problem is in the static fields. For example, TWO_QUARTERS is 2/4, but that's equivalent to 1/2. However, the code's getFraction method doesn't reduce it. So when someone creates a fraction with getFraction(2,4), it's stored as 2/4. But in the static fields, TWO_QUARTERS is created with new Fraction(2,4), bypassing the getFraction method. So in that case, the denominator is 4, but the getFraction method would have adjusted the denominator to be positive (which it already is) and not simplified. So the TWO_QUARTERS is indeed 2/4. But the user might expect that the static fields are in their simplest form. For example, TWO_QUARTERS is actually equal to ONE_HALF. If the equals method is based on numerator and denominator, then TWO_QUARTERS would not equal ONE_HALF, which is a problem. \n\nSo that's a potential bug. The static fields like TWO_QUARTERS are not in reduced form. For example, TWO_QUARTERS is 2/4, but it's equivalent to 1/2. If the equals method compares the actual numerator and denominator, then TWO_QUARTERS would not equal ONE_HALF, which is incorrect. \n\nAnother thing to check: the getFraction method's handling of negative denominators. The code says if denominator is negative, then it negates both numerator and denominator. But there's a check for if numerator or denominator is Integer.MIN_VALUE. For example, if denominator is negative and numerator is Integer.MIN_VALUE, then negating the numerator would cause an overflow because Integer.MIN_VALUE is -2^31, and its positive counterpart is 2^31, which is outside the range of int (which is -2^31 to 2^31-1). So negating Integer.MIN_VALUE would throw an ArithmeticException. However, in the code, the check is if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE). Wait, the code checks if either the numerator or denominator is Integer.MIN_VALUE before negating. But when the denominator is negative, the code wants to negate both numerator and denominator. So if the original denominator is negative, and the original numerator is Integer.MIN_VALUE, then when you try to negate the numerator, you get an overflow. The code correctly throws an ArithmeticException in that case. But what about if the denominator is Integer.MIN_VALUE? For example, if the denominator is -Integer.MIN_VALUE, but since Integer.MIN_VALUE is -2^31, then -Integer.MIN_VALUE is 2^31, which is outside the int range. So the code checks if either the numerator or denominator is Integer.MIN_VALUE and throws an exception. That seems correct. \n\nAnother possible issue is in the getFraction method when denominator is negative. Suppose the denominator is -5 and the numerator is 3. The code will negate both, making numerator -3 and denominator 5. Wait, no. Wait, if the denominator is negative, then numerator is set to -numerator, and denominator is set to -denominator. So original numerator is 3, denominator is -5. After negation, numerator becomes -3, denominator becomes 5. So the fraction is -3/5, which is correct. But what if the original numerator was negative? For example, numerator is -3, denominator is -5. Then after negation, numerator becomes 3, denominator becomes 5. The fraction is 3/5. That's correct. \n\nSo the getFraction method correctly handles the sign. \n\nNow, looking at the static fields. For example, TWO_QUARTERS is 2/4. If the code doesn't reduce fractions, then this is a problem. So when comparing TWO_QUARTERS to ONE_HALF, they should be considered equal, but if the equals method checks for numerator and denominator equality, they are not. So the equals method must be implemented to consider fractions that are equivalent even if their numerator and denominator differ. \n\nBut the code provided here doesn't show the equals method. However, since the class is a Number and is supposed to be comparable, the equals method must be properly implemented. If the equals method is not considering the simplification, then TWO_QUARTERS would not equal ONE_HALF, which is a bug. \n\nBut since the user is asking to review the code for bugs, and the provided code includes the static fields, but not the equals method, perhaps this is a problem. However, without seeing the equals method, it's hard to say. But given that the code is from Apache Commons Lang, I can assume that the equals method is properly implemented. Wait, but the user provided code up to the getFraction method. The rest of the code isn't here. So maybe the code is incomplete. \n\nBut given the code provided, the static fields like TWO_QUARTERS are initialized to 2/4, which is not in reduced form. If the code's equals method checks for equality of the actual numerator and denominator, then TWO_QUARTERS would not equal ONE_HALF. That would be a bug. \n\nSo that's a potential bug. The static field TWO_QUARTERS is not in its simplest form. Similarly, THREE_QUARTERS is 3/4 which is correct, but TWO_QUARTERS is 2/4. So that's a problem. \n\nAnother possible bug is in the getFraction method's handling of the denominator. For example, if the denominator is zero, it throws an exception. That's correct. \n\nAnother possible issue: in the getFraction method, when the denominator is negative, the code checks if either the numerator or denominator is Integer.MIN_VALUE. But when negating, it's possible that the numerator or denominator is Integer.MIN_VALUE. For example, if the denominator is -1, and the numerator is Integer.MIN_VALUE, then negating the numerator would be -Integer.MIN_VALUE, which is 2^31. Since that's outside the range of int, it would cause an overflow. The code throws an ArithmeticException in this case. That's correct. \n\nSo the main bug I can identify is in the static fields like TWO_QUARTERS. Since they are initialized directly with the constructor, which doesn't reduce the fraction, they are not in their simplest form. The getFraction method would create a fraction with numerator and denominator not reduced. For example, getFraction(2,4) would create a fraction with numerator 2 and denominator 4. So if the equals method compares the actual numerator and denominator, then TWO_QUARTERS would not equal ONE_HALF. \n\nTherefore, this is a bug. The static fields should be created using the getFraction method to ensure they are properly normalized. For example, TWO_QUARTERS should be created as getFraction(2,4), which would then be simplified to 1/2 if the getFraction method reduces the fraction. However, in the current code, the getFraction method does not reduce the fraction. Wait, no. The getFraction method does not perform any reduction. So even if you call getFraction(2,4), the numerator is 2 and denominator is 4. So the problem is that the code doesn't reduce fractions. \n\nWait, but the class's documentation says \"stores fractions accurately.\" If the fractions are not stored in reduced form, then perhaps that's a design flaw. But the user is asking for bugs, not design issues. However, if the code is supposed to represent fractions accurately, but they are not stored in reduced form, then that's a bug. For example, when you perform arithmetic operations, the results may not be in their simplest form, leading to incorrect comparisons or outputs. \n\nSo the main bugs here are:\n\n1. The static fields like TWO_QUARTERS are not in reduced form. For example, TWO_QUARTERS is 2/4 instead of 1/2. This would cause issues when comparing with other fractions.\n\n2. The getFraction method does not reduce the numerator and denominator by their GCD, leading to fractions not being stored in their simplest form. This would affect equality checks and other operations.\n\nAnother possible issue is that in the getFraction method, when the denominator is negative, the code checks if either the numerator or denominator is Integer.MIN_VALUE. However, the check is for if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE). But when the denominator is negative, and you negate it, you have to check if the negation would cause an overflow. For example, if the denominator is Integer.MIN_VALUE, then negating it would cause an overflow. The code throws an ArithmeticException in that case. But the code checks if either the numerator or denominator is Integer.MIN_VALUE. However, if the denominator is negative and is Integer.MIN_VALUE, then when you try to negate it, you get an overflow. The code correctly throws an exception. But what if the numerator is not Integer.MIN_VALUE, but the denominator is? For example, if the denominator is -2147483648 (Integer.MIN_VALUE), then the code would throw an exception. That's correct because negating Integer.MIN_VALUE would result in 2147483648, which is outside the int range. \n\nAnother possible bug is in the static initializer for the static fields. For example, TWO_QUARTERS is initialized as new Fraction(2,4). But if the constructor doesn't validate the denominator for zero, but the getFraction method does. However, the constructor is private and the code uses getFraction for creating instances, so the static fields are initialized directly. The constructor doesn't check if the denominator is zero. In the static fields, all denominators are non-zero. So that's okay. \n\nSo the main bugs are:\n\n- Static fields like TWO_QUARTERS are not in reduced form.\n\n- The getFraction method does not reduce fractions to their simplest form.\n\nBut according to the code provided, the getFraction method doesn't perform any reduction. So if the user expects that fractions are stored in reduced form, that's a bug. \n\nAnother possible issue is that the code doesn't handle the case where the denominator is negative. The getFraction method ensures that the denominator is positive by moving the negative sign to the numerator. However, if the code elsewhere (like in toString) doesn't take that into account, but the code provided here doesn't show that. \n\nSo the main bugs are the static fields not being reduced and the lack of reduction in getFraction. \n\nSo the JSON should list these as bugs. For example:\n\n1. The static field 'TWO_QUARTERS' is initialized with numerator 2 and denominator 4, which is not in its simplest form (should be 1/2). This could lead to incorrect equality checks and comparisons.\n\n2. The getFraction method does not reduce the numerator and denominator by their greatest common divisor (GCD), leading to fractions not being stored in their simplest form. This affects all instances created via getFraction and could cause incorrect behavior in equality checks, arithmetic operations, and string representations.\n\nTherefore, the bugs list would include these two issues.\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"line\": 56,\n      \"description\": \"The static field 'TWO_QUARTERS' is initialized with numerator 2 and denominator 4, which is not in its simplest form (should be 1/2). This could lead to incorrect equality checks and comparisons as the fraction is not reduced.\"\n    },\n    {\n      \"line\": 81,\n      \"description\": \"The 'getFraction' method does not reduce the numerator and denominator by their greatest common divisor (GCD). This results in fractions being stored in non-simplified forms, leading to inconsistencies in equality checks and arithmetic operations.\"\n    }\n  ]\n}\n```"}}