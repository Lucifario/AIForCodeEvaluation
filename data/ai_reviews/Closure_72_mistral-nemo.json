{"sample_id": "Closure_72", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2009 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.javascript.jscomp.MakeDeclaredNamesUnique.InlineRenamer;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Map.Entry;\n\n/**\n * A class to transform the body of a function into a generic block suitable\n * for inlining.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass FunctionToBlockMutator {\n\n  private AbstractCompiler compiler;\n  private Supplier<String> safeNameIdSupplier;\n\n\n  FunctionToBlockMutator(\n      AbstractCompiler compiler, Supplier<String> safeNameIdSupplier) {\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n  }\n\n  /**\n   * @param fnName The name to use when preparing human readable names.\n   * @param fnNode The function to prepare.\n   * @param callNode The call node that will be replaced.\n   * @param resultName Function results should be assigned to this name.\n   * @param needsDefaultResult Whether the result value must be set.\n   * @param isCallInLoop Whether the function body must be prepared to be\n   *   injected into the body of a loop.\n   * @return A clone of the function body mutated to be suitable for injection\n   *   as a statement into another code block.\n   */\n  Node mutate(String fnName, Node fnNode, Node callNode,\n      String resultName, boolean needsDefaultResult, boolean isCallInLoop) {\n    Node newFnNode = fnNode.cloneTree();\n    // Now that parameter names have been replaced, make sure all the local\n    // names are unique, to allow functions to be inlined multiple times\n    // without causing conflicts.\n    makeLocalNamesUnique(newFnNode, isCallInLoop);\n\n    // TODO(johnlenz): Mark NAME nodes constant for parameters that are not\n    // modified.\n    Set<String> namesToAlias =\n        FunctionArgumentInjector.findModifiedParameters(newFnNode);\n    LinkedHashMap<String, Node> args =\n        FunctionArgumentInjector.getFunctionCallParameterMap(\n            newFnNode, callNode, this.safeNameIdSupplier);\n    boolean hasArgs = !args.isEmpty();\n    if (hasArgs) {\n      FunctionArgumentInjector.maybeAddTempsForCallArguments(\n          newFnNode, args, namesToAlias, compiler.getCodingConvention());\n    }\n\n    Node newBlock = NodeUtil.getFunctionBody(newFnNode);\n    // Make the newBlock insertable .\n    newBlock.detachFromParent();\n\n    if (hasArgs) {\n      Node inlineResult = aliasAndInlineArguments(newBlock,\n          args, namesToAlias);\n      Preconditions.checkState(newBlock == inlineResult);\n    }\n\n    //\n    // For calls inlined into loops, VAR declarations are not reinitialized to\n    // undefined as they would have been if the function were called, so ensure\n    // that they are properly initialized.\n    //\n    if (isCallInLoop) {\n      fixUnitializedVarDeclarations(newBlock);\n    }\n\n    String labelName = getLabelNameForFunction(fnName);\n    Node injectableBlock = replaceReturns(\n        newBlock, resultName, labelName, needsDefaultResult);\n    Preconditions.checkState(injectableBlock != null);\n\n    return injectableBlock;\n  }\n\n\n  /**\n   *  For all VAR node with uninitialized declarations, set\n   *  the values to be \"undefined\".\n   */\n  private void fixUnitializedVarDeclarations(Node n) {\n    // Inner loop structure must already have logic to initialize its\n    // variables.  In particular FOR-IN structures must not be modified.\n    if (NodeUtil.isLoopStructure(n)) {\n      return;\n    }\n\n    // For all VARs\n    if (NodeUtil.isVar(n)) {\n      Node name = n.getFirstChild();\n      // It isn't initialized.\n      if (!name.hasChildren()) {\n        Node srcLocation = name;\n        name.addChildToBack(NodeUtil.newUndefinedNode(srcLocation));\n      }\n      return;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      fixUnitializedVarDeclarations(c);\n    }\n  }\n\n\n  /**\n   * Fix-up all local names to be unique for this subtree.\n   * @param fnNode A mutable instance of the function to be inlined.\n   */\n  private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(\n        compiler, fnNode, new MakeDeclaredNamesUnique(\n            new InlineRenamer(\n                idSupplier,\n                \"inline_\",\n                isCallInLoop)));\n    // Make label names unique to this instance.\n  }\n\n  static class LabelNameSupplier implements Supplier<String> {\n    final Supplier<String> idSupplier;\n\n    LabelNameSupplier(Supplier<String> idSupplier) {\n      this.idSupplier = idSupplier;\n    }\n\n    @Override\n    public String get() {\n        return \"JSCompiler_inline_label_\" + idSupplier.get();\n    }\n  }\n\n  /**\n   * Create a unique label name.\n   */\n  private String getLabelNameForFunction(String fnName){\n    String name = (fnName == null || fnName.isEmpty()) ? \"anon\" : fnName;\n    return \"JSCompiler_inline_label_\" + name + \"_\" + safeNameIdSupplier.get();\n  }\n\n  /**\n   * Inlines the arguments within the node tree using the given argument map,\n   * replaces \"unsafe\" names with local aliases.\n   *\n   * The aliases for unsafe require new VAR declarations, so this function\n   * can not be used in for direct CALL node replacement as VAR nodes can not be\n   * created there.\n   *\n   * @return The node or its replacement.\n   */\n  private Node aliasAndInlineArguments(\n      Node fnTemplateRoot, LinkedHashMap<String, Node> argMap,\n      Set<String> namesToAlias) {\n\n    if (namesToAlias == null || namesToAlias.isEmpty()) {\n      // There are no names to alias, just inline the arguments directly.\n      Node result = FunctionArgumentInjector.inject(\n          fnTemplateRoot, null, argMap);\n      Preconditions.checkState(result == fnTemplateRoot);\n      return result;\n    } else {\n      // Create local alias of names that can not be safely\n      // used directly.\n\n      // An arg map that will be updated to contain the\n      // safe aliases.\n      Map<String, Node> newArgMap = Maps.newHashMap(argMap);\n\n      // Declare the alias in the same order as they\n      // are declared.\n      List<Node> newVars = Lists.newLinkedList();\n      // NOTE: argMap is a linked map so we get the parameters in the\n      // order that they were declared.\n      for (Entry<String, Node> entry : argMap.entrySet()) {\n        String name = entry.getKey();\n        if (namesToAlias.contains(name)) {\n          Node newValue = entry.getValue().cloneTree();\n          Node newNode = NodeUtil.newVarNode(name, newValue)\n              .copyInformationFromForTree(newValue);\n          newVars.add(0, newNode);\n          // Remove the parameter from the list to replace.\n          newArgMap.remove(name);\n        }\n      }\n\n      // Inline the arguments.\n      Node result = FunctionArgumentInjector.inject(\n          fnTemplateRoot, null, newArgMap);\n      Preconditions.checkState(result == fnTemplateRoot);\n\n      // Now that the names have been replaced, add the new aliases for\n      // the old names.\n      for (Node n : newVars) {\n        fnTemplateRoot.addChildToFront(n);\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   *  Convert returns to assignments and breaks, as needed.\n   *  For example, with a lableName of 'foo':\n   *    {\n   *      return a;\n   *    }\n   *  becomes:\n   *    foo: {\n   *      a;\n   *      break foo;\n   *    }\n   *  or\n   *    foo: {\n   *      resultName = a;\n   *      break foo;\n   *    }\n   *\n   * @param resultMustBeSet Whether the result must always be set to a value.\n   * @return The node containing the transformed block, this may be different\n   *     than the passed in node 'block'.\n   */\n  private static Node replaceReturns(\n      Node block, String resultName, String labelName,\n      boolean resultMustBeSet) {\n    Preconditions.checkNotNull(block);\n    Preconditions.checkNotNull(labelName);\n\n    Node root = block;\n\n    boolean hasReturnAtExit = false;\n    int returnCount = NodeUtil.getNodeTypeReferenceCount(\n        block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n    if (returnCount > 0) {\n      hasReturnAtExit = hasReturnAtExit(block);\n      // TODO(johnlenz): Simpler not to special case this,\n      // and let it be optimized later.\n      if (hasReturnAtExit) {\n        convertLastReturnToStatement(block, resultName);\n        returnCount--;\n      }\n\n      if (returnCount > 0) {\n        // A label and breaks are needed.\n\n        // Add the breaks\n        replaceReturnWithBreak(block, null, resultName, labelName);\n\n        // Add label\n        Node label = new Node(Token.LABEL).copyInformationFrom(block);\n        Node name = Node.newString(Token.LABEL_NAME, labelName)\n            .copyInformationFrom(block);\n        label.addChildToFront(name);\n        label.addChildToBack(block);\n\n        Node newRoot = new Node(Token.BLOCK).copyInformationFrom(block);\n        newRoot.addChildrenToBack(label);\n\n\n        // The label is now the root.\n        root = newRoot;\n      }\n    }\n\n    // If there wasn't an return at the end of the function block, and we need\n    // a result, add one to the block.\n    if (resultMustBeSet && !hasReturnAtExit && resultName != null) {\n      addDummyAssignment(block, resultName);\n    }\n\n    return root;\n  }\n\n  /**********************************************************************\n   *  Functions following here are general node transformation functions\n   **********************************************************************/\n\n  /**\n   * Example:\n   *   a = (void) 0;\n   */\n  private static void addDummyAssignment(Node node, String resultName) {\n    Preconditions.checkArgument(node.getType() == Token.BLOCK);\n\n    // A result is needed create a dummy value.\n    Node srcLocation = node;\n    Node retVal = NodeUtil.newUndefinedNode(srcLocation);\n    Node resultNode = createAssignStatementNode(resultName, retVal);\n    resultNode.copyInformationFromForTree(node);\n\n    node.addChildrenToBack(resultNode);\n  }\n\n  /**\n   * Replace the 'return' statement with its child expression.\n   *   \"return foo()\" becomes \"foo()\" or \"resultName = foo()\"\n   *   \"return\" is removed or becomes \"resultName = void 0\".\n   *\n   * @param block\n   * @param resultName\n   */\n  private static void convertLastReturnToStatement(\n      Node block, String resultName) {\n    Node ret = block.getLastChild();\n    Preconditions.checkArgument(ret.getType() == Token.RETURN);\n    Node resultNode = getReplacementReturnStatement(ret, resultName);\n\n    if (resultNode == null) {\n      block.removeChild(ret);\n    } else {\n      resultNode.copyInformationFromForTree(ret);\n      block.replaceChild(ret, resultNode);\n    }\n  }\n\n  /**\n   * Create a valid statement Node containing an assignment to name of the\n   * given expression.\n   */\n  private static Node createAssignStatementNode(String name, Node expression) {\n    // Create 'name = result-expression;' statement.\n    // EXPR (ASSIGN (NAME, EXPRESSION))\n    Node nameNode = Node.newString(Token.NAME, name);\n    Node assign = new Node(Token.ASSIGN, nameNode, expression);\n    return NodeUtil.newExpr(assign);\n  }\n\n  /**\n   * Replace the 'return' statement with its child expression.\n   * If the result is needed (resultName != null):\n   *   \"return foo()\" becomes \"resultName = foo()\"\n   *   \"return\" becomes \"resultName = void 0\".\n   * Otherwise:\n   *   \"return foo()\" becomes \"foo()\"\n   *   \"return\", null is returned.\n   */\n  private static Node getReplacementReturnStatement(\n      Node node, String resultName) {\n    Node resultNode = null;\n\n    Node retVal = null;\n    if (node.hasChildren()) {\n      // Clone the child as the child hasn't been removed\n      // from the node yet.\n      retVal = node.getFirstChild().cloneTree();\n    }\n\n    if (resultName == null) {\n      if (retVal != null) {\n        resultNode = NodeUtil.newExpr(retVal); // maybe null.\n      }\n    } else {\n      if (retVal == null) {\n        // A result is needed create a dummy value.\n        Node srcLocation = node;\n        retVal = NodeUtil.newUndefinedNode(srcLocation);\n      }\n      // Create a \"resultName = retVal;\" statement.\n      resultNode = createAssignStatementNode(resultName, retVal);\n    }\n\n    return resultNode;\n  }\n\n  /**\n   * @return Whether the given block end with an return statement.\n   */\n  private static boolean hasReturnAtExit(Node block) {\n    // Only inline functions that return something (empty returns\n    // will be handled by ConstFolding+EmptyFunctionRemoval)\n    return (block.getLastChild().getType() == Token.RETURN);\n  }\n\n  /**\n   * Replace the 'return' statement with its child expression.\n   *   \"return foo()\" becomes \"{foo(); break;}\" or\n   *      \"{resultName = foo(); break;}\"\n   *   \"return\" becomes {break;} or \"{resultName = void 0;break;}\".\n   */\n  private static Node replaceReturnWithBreak(Node current, Node parent,\n      String resultName, String labelName) {\n\n    if (current.getType() == Token.FUNCTION\n        || current.getType() == Token.EXPR_RESULT) {\n      // Don't recurse into functions definitions, and expressions can't\n      // contain RETURN nodes.\n      return current;\n    }\n\n    if (current.getType() == Token.RETURN) {\n      Preconditions.checkState(NodeUtil.isStatementBlock(parent));\n\n      Node resultNode = getReplacementReturnStatement(current, resultName);\n      Node name = Node.newString(Token.LABEL_NAME, labelName);\n      Node breakNode = new Node(Token.BREAK, name);\n\n      // Replace the node in parent, and reset current to the first new child.\n      breakNode.copyInformationFromForTree(current);\n      parent.replaceChild(current, breakNode);\n      if (resultNode != null) {\n        resultNode.copyInformationFromForTree(current);\n        parent.addChildBefore(resultNode, breakNode);\n      }\n      current = breakNode;\n    } else {\n      for (Node c = current.getFirstChild(); c != null; c = c.getNext()) {\n        // c may be replaced.\n        c = replaceReturnWithBreak(c, current, resultName, labelName);\n      }\n    }\n\n    return current;\n  }\n}\n", "review": {"response": "[{\"code\": \"package com.google.javascript.jscomp;\\n\\nimport com.google.common.base.Preconditions;\\nimport com.google.common.base.Supplier;\\nimport com.google.common.collect.Lists;\\nimport com.google.common.collect.Maps;\\nimport com.google.javascript.jscomp.MakeDeclaredNamesUnique.InlineRenamer;\\nimport com.google.javascript.rhino.Node;\\nimport com.google.javascript.rhino.Token;\\n\\nimport java.util.LinkedHashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.Set;\\nimport java.util.Map.Entry;\\n\\n/**\\n * A class to transform the body of a function into a generic block suitable\\n * for inlining.\\n *\\n * @author johnlenz@google.com (John Lenz)\\n */\\n\\nclass FunctionToBlockMutator {\\n\\n  private AbstractCompiler compiler;\\n  private Supplier<String> safeNameIdSupplier;\\n\\n  FunctionToBlockMutator(\\n      AbstractCompiler compiler, Supplier<String> safeNameIdSupplier) {\\n    this.compiler = compiler;\\n    this.safeNameIdSupplier = safeNameIdSupplier;\\n  }\\n\\n  /**\\n   * @param fnName The name to use when preparing human readable names.\\n   * @param fnNode The function to prepare.\\n   * @param callNode The call node that will be replaced.\\n   * @param resultName Function results should be assigned to this name.\\n   * @param needsDefaultResult Whether the result value must be set.\\n   * @param isCallInLoop Whether the function body must be prepared to be\\n   *   injected into the body of a loop.\\n   * @return A clone of the function body mutated to be suitable for injection\\n   *   as a statement into another code block.\\n   */\\n  Node mutate(String fnName, Node fnNode, Node callNode,\\n      String resultName, boolean needsDefaultResult, boolean isCallInLoop) {\\n    Node newFnNode = fnNode.cloneTree();\\n    // Now that parameter names have been replaced, make sure all the local\\n    // names are unique, to allow functions to be inlined multiple times\\n    // without causing conflicts.\\n    makeLocalNamesUnique(newFnNode, isCallInLoop);\\n\\n    // TODO(johnlenz): Mark NAME nodes constant for parameters that are not\\n    // modified.\\n    Set<String> namesToAlias =\\n        FunctionArgumentInjector.findModifiedParameters(newFnNode);\\n    LinkedHashMap<String, Node> args =\\n        FunctionArgumentInjector.getFunctionCallParameterMap(\\n            newFnNode, callNode, this.safeNameIdSupplier);\\n    boolean hasArgs = !args.isEmpty();\\n    if (hasArgs) {\\n      FunctionArgumentInjector.maybeAddTempsForCallArguments(\\n          newFnNode, args, namesToAlias, compiler.getCodingConvention());\\n    }\\n\\n    Node newBlock = NodeUtil.getFunctionBody(newFnNode);\\n    // Make the newBlock insertable .\\n    newBlock.detachFromParent();\\n\\n    if (hasArgs) {\\n      Node inlineResult = aliasAndInlineArguments(newBlock,\\n          args, namesToAlias);\\n      Preconditions.checkState(newBlock == inlineResult);\\n    }\\n\\n    //\\n    // For calls inlined into loops, VAR declarations are not reinitialized to\\n    // undefined as they would have been if the function were called, so ensure\\n    // that they are properly initialized.\\n    //\\n    if (isCallInLoop) {\\n      fixUnitializedVarDeclarations(newBlock);\\n    }\\n\\n    String labelName = getLabelNameForFunction(fnName);\\n    Node injectableBlock = replaceReturns(\\n        newBlock, resultName, labelName, needsDefaultResult);\\n    Preconditions.checkState(injectableBlock != null);\\n\\n    return injectableBlock;\\n  }\\n\\n  /**\\n   *  For all VAR node with uninitialized declarations, set\\n   *  the values to be \\\"undefined\\\".\\n   */\\n  private void fixUnitializedVarDeclarations(Node n) {\\n    // Inner loop structure must already have logic to initialize its\\n    // variables.  In particular FOR-IN structures must not be modified.\\n    if (NodeUtil.isLoopStructure(n)) {\\n      return;\\n    }\\n\\n    // For all VARs\\n    if (NodeUtil.isVar(n)) {\\n      Node name = n.getFirstChild();\\n      // It isn't initialized.\\n      if (!name.hasChildren()) {\\n        Node srcLocation = name;\\n        name.addChildToBack(NodeUtil.newUndefinedNode(srcLocation));\\n      }\\n      return;\\n    }\\n\\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\\n      fixUnitializedVarDeclarations(c);\\n    }\\n  }\\n\\n  /**\\n   * Fix-up all local names to be unique for this subtree.\\n   * @param fnNode A mutable instance of the function to be inlined.\\n   */\\n  private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\\n    // Make variable names unique to this instance.\\n    NodeTraversal.traverse(\\n        compiler, fnNode, new MakeDeclaredNamesUnique(\\n            new InlineRenamer(\\n                idSupplier,\\n                \\\"inline_\\\",\\n                isCallInLoop)));\\n    // Make label names unique to this instance.\\n  }\\n\\n  static class LabelNameSupplier implements Supplier<String> {\\n    final Supplier<String> idSupplier;\\n\\n    LabelNameSupplier(Supplier<String> idSupplier) {\\n      this.idSupplier = idSupplier;\\n    }\\n\\n    @Override\\n    public String get() {\\n        return \\\"JSCompiler_inline_label_\\\" + idSupplier.get();\\n    }\\n  }\\n\\n  /**\\n   * Create a unique label name.\\n   */\\n  private String getLabelNameForFunction(String fnName){\\n    String name = (fnName == null || fnName.isEmpty()) ? \\\"anon\\\" : fnName;\\n    return \\\"JSCompiler_inline_label_\\\" + name + \\\"_\\\" + safeNameIdSupplier.get();\\n  }\\n\\n  /**\\n   * Inlines the arguments within the node tree using the given argument map,\\n   * replaces \\\"unsafe\\\" names with local aliases.\\n   *\\n   * @param block The block to be modified.\\n   * @param args The argument map.\\n   * @param namesToAlias The set of names to be replaced with local aliases.\\n   * @return The modified block.\\n   */\\n  private Node aliasAndInlineArguments(Node block, Map<String, Node> args, Set<String> namesToAlias) {\\n    // TODO(johnlenz): Implement this.\\n    throw new UnsupportedOperationException();\\n  }\\n\\n  /**\\n   * Replaces RETURN nodes with ASSIGN nodes that assign to the given\\n   * resultName.  If needsDefaultResult is true, a default result value\\n   * will be assigned to resultName if the function does not have a\\n   * RETURN node.\\n   *\\n   * @param block The block to be modified.\\n   * @param resultName The name to assign the function result to.\\n   * @param labelName The name to use for the generated label.\\n   * @param needsDefaultResult Whether the function should have a default\\n   *   result value.\\n   * @return The modified block.\\n   */\\n  private Node replaceReturns(Node block, String resultName, String labelName, boolean needsDefaultResult) {\\n    // TODO(johnlenz): Implement this.\\n    throw new UnsupportedOperationException();\\n  }\\n}\",\"bugs\":[]}]"}}