{"sample_id": "Math_98", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.linear;\n\nimport java.io.Serializable;\nimport org.apache.commons.math.util.MathUtils;\n\n\n/**\n * Implementation of RealMatrix using a double[][] array to store entries and\n * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n * LU decomposition</a> to support linear system\n * solution and inverse.\n * <p>\n * The LU decomposition is performed as needed, to support the following operations: <ul>\n * <li>solve</li>\n * <li>isSingular</li>\n * <li>getDeterminant</li>\n * <li>inverse</li> </ul></p>\n * <p>\n * <strong>Usage notes</strong>:<br>\n * <ul><li>\n * The LU decomposition is cached and reused on subsequent calls.   \n * If data are modified via references to the underlying array obtained using\n * <code>getDataRef()</code>, then the stored LU decomposition will not be\n * discarded.  In this case, you need to explicitly invoke \n * <code>LUDecompose()</code> to recompute the decomposition\n * before using any of the methods above.</li>\n * <li>\n * As specified in the {@link RealMatrix} interface, matrix element indexing\n * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n * returns the element in the first row, first column of the matrix.</li></ul>\n * </p>\n *\n * @version $Revision$ $Date$\n */\npublic class RealMatrixImpl implements RealMatrix, Serializable {\n    \n    /** Serializable version identifier */\n    private static final long serialVersionUID = -4828886979278117018L;\n\n    /** Entries of the matrix */\n    protected double data[][] = null;\n\n    /** Entries of cached LU decomposition.\n     *  All updates to data (other than luDecompose()) *must* set this to null\n     */\n    protected double lu[][] = null;\n\n    /** Permutation associated with LU decomposition */\n    protected int[] permutation = null;\n\n    /** Parity of the permutation associated with the LU decomposition */\n    protected int parity = 1;\n\n    /** Bound to determine effective singularity in LU decomposition */\n    private static final double TOO_SMALL = 10E-12;\n\n    /**\n     * Creates a matrix with no data\n     */\n    public RealMatrixImpl() {\n    }\n\n    /**\n     * Create a new RealMatrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension  the number of rows in the new matrix\n     * @param columnDimension  the number of columns in the new matrix\n     * @throws IllegalArgumentException if row or column dimension is not\n     *  positive\n     */\n    public RealMatrixImpl(int rowDimension, int columnDimension) {\n        if (rowDimension <= 0 || columnDimension <= 0) {\n            throw new IllegalArgumentException(\n                    \"row and column dimensions must be postive\");\n        }\n        data = new double[rowDimension][columnDimension];\n        lu = null;\n    }\n\n    /**\n     * Create a new RealMatrix using the input array as the underlying\n     * data array.\n     * <p>The input array is copied, not referenced. This constructor has\n     * the same effect as calling {@link #RealMatrixImpl(double[][], boolean)}\n     * with the second argument set to <code>true</code>.</p>\n     *\n     * @param d data for new matrix\n     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if <code>d</code> is null\n     * @see #RealMatrixImpl(double[][], boolean)\n     */\n    public RealMatrixImpl(double[][] d) {\n        copyIn(d);\n        lu = null;\n    }\n\n    /**\n     * Create a new RealMatrix using the input array as the underlying\n     * data array.\n     * <p>If an array is built specially in order to be embedded in a\n     * RealMatrix and not used directly, the <code>copyArray</code> may be\n     * set to <code>false</code. This will prevent the copying and improve\n     * performance as no new array will be built and no data will be copied.</p>\n     * @param d data for new matrix\n     * @param copyArray if true, the input array will be copied, otherwise\n     * it will be referenced\n     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if <code>d</code> is null\n     * @see #RealMatrixImpl(double[][])\n     */\n    public RealMatrixImpl(double[][] d, boolean copyArray) {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullPointerException();\n            }   \n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw new IllegalArgumentException(\"All input rows must have the same length.\");\n                }\n            }       \n            data = d;\n        }\n        lu = null;\n    }\n\n    /**\n     * Create a new (column) RealMatrix using <code>v</code> as the\n     * data for the unique column of the <code>v.length x 1</code> matrix\n     * created.\n     * <p>The input array is copied, not referenced.</p>\n     *\n     * @param v column vector holding data for new matrix\n     */\n    public RealMatrixImpl(double[] v) {\n        final int nRows = v.length;\n        data = new double[nRows][1];\n        for (int row = 0; row < nRows; row++) {\n            data[row][0] = v[row];\n        }\n    }\n\n    /**\n     * Create a new RealMatrix which is a copy of this.\n     *\n     * @return  the cloned matrix\n     */\n    public RealMatrix copy() {\n        return new RealMatrixImpl(copyOut(), false);\n    }\n\n    /**\n     * Compute the sum of this and <code>m</code>.\n     *\n     * @param m    matrix to be added\n     * @return     this + m\n     * @throws  IllegalArgumentException if m is not the same size as this\n     */\n    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n        try {\n            return add((RealMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            final int rowCount    = getRowDimension();\n            final int columnCount = getColumnDimension();\n            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n            }\n            final double[][] outData = new double[rowCount][columnCount];\n            for (int row = 0; row < rowCount; row++) {\n                final double[] dataRow    = data[row];\n                final double[] outDataRow = outData[row];\n                for (int col = 0; col < columnCount; col++) {\n                    outDataRow[col] = dataRow[col] + m.getEntry(row, col);\n                }  \n            }\n            return new RealMatrixImpl(outData, false);\n        }\n    }\n\n    /**\n     * Compute the sum of this and <code>m</code>.\n     *\n     * @param m    matrix to be added\n     * @return     this + m\n     * @throws  IllegalArgumentException if m is not the same size as this\n     */\n    public RealMatrixImpl add(RealMatrixImpl m) throws IllegalArgumentException {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n        }\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] mRow       = m.data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] + mRow[col];\n            }  \n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    /**\n     * Compute  this minus <code>m</code>.\n     *\n     * @param m    matrix to be subtracted\n     * @return     this + m\n     * @throws  IllegalArgumentException if m is not the same size as this\n     */\n    public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n        try {\n            return subtract((RealMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            final int rowCount    = getRowDimension();\n            final int columnCount = getColumnDimension();\n            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n            }\n            final double[][] outData = new double[rowCount][columnCount];\n            for (int row = 0; row < rowCount; row++) {\n                final double[] dataRow    = data[row];\n                final double[] outDataRow = outData[row];\n                for (int col = 0; col < columnCount; col++) {\n                    outDataRow[col] = dataRow[col] - m.getEntry(row, col);\n                }  \n            }\n            return new RealMatrixImpl(outData, false);\n        }\n    }\n\n    /**\n     * Compute  this minus <code>m</code>.\n     *\n     * @param m    matrix to be subtracted\n     * @return     this + m\n     * @throws  IllegalArgumentException if m is not the same size as this\n     */\n    public RealMatrixImpl subtract(RealMatrixImpl m) throws IllegalArgumentException {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n        }\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] mRow       = m.data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] - mRow[col];\n            }  \n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    /**\n     * Returns the result of adding d to each entry of this.\n     *\n     * @param d    value to be added to each entry\n     * @return     d + this\n     */\n    public RealMatrix scalarAdd(double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] + d;\n            }\n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    /**\n     * Returns the result of multiplying each entry of this by <code>d</code>\n     * @param d  value to multiply all entries by\n     * @return d * this\n     */\n    public RealMatrix scalarMultiply(double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] * d;\n            }\n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    /**\n     * Returns the result of postmultiplying this by <code>m</code>.\n     * @param m    matrix to postmultiply by\n     * @return     this*m\n     * @throws     IllegalArgumentException\n     *             if columnDimension(this) != rowDimension(m)\n     */\n    public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n        try {\n            return multiply((RealMatrixImpl) m);\n        } catch (ClassCastException cce) {\n            if (this.getColumnDimension() != m.getRowDimension()) {\n                throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n            }\n            final int nRows = this.getRowDimension();\n            final int nCols = m.getColumnDimension();\n            final int nSum = this.getColumnDimension();\n            final double[][] outData = new double[nRows][nCols];\n            for (int row = 0; row < nRows; row++) {\n                final double[] dataRow    = data[row];\n                final double[] outDataRow = outData[row];\n                for (int col = 0; col < nCols; col++) {\n                    double sum = 0;\n                    for (int i = 0; i < nSum; i++) {\n                        sum += dataRow[i] * m.getEntry(i, col);\n                    }\n                    outDataRow[col] = sum;\n                }\n            }\n            return new RealMatrixImpl(outData, false);\n        }\n    }\n\n    /**\n     * Returns the result of postmultiplying this by <code>m</code>.\n     * @param m    matrix to postmultiply by\n     * @return     this*m\n     * @throws     IllegalArgumentException\n     *             if columnDimension(this) != rowDimension(m)\n     */\n    public RealMatrixImpl multiply(RealMatrixImpl m) throws IllegalArgumentException {\n        if (this.getColumnDimension() != m.getRowDimension()) {\n            throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n        }\n        final int nRows = this.getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum = this.getColumnDimension();\n        final double[][] outData = new double[nRows][nCols];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < nCols; col++) {\n                double sum = 0;\n                for (int i = 0; i < nSum; i++) {\n                    sum += dataRow[i] * m.data[i][col];\n                }\n                outDataRow[col] = sum;\n            }\n        }            \n        return new RealMatrixImpl(outData, false);\n    }\n\n    /**\n     * Returns the result of premultiplying this by <code>m</code>.\n     * @param m    matrix to premultiply by\n     * @return     m * this\n     * @throws     IllegalArgumentException\n     *             if rowDimension(this) != columnDimension(m)\n     */\n    public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException {\n        return m.multiply(this);\n    }\n\n    /**\n     * Returns matrix entries as a two-dimensional array.\n     * <p>\n     * Makes a fresh copy of the underlying data.</p>\n     *\n     * @return    2-dimensional array of entries\n     */\n    public double[][] getData() {\n        return copyOut();\n    }\n\n    /**\n     * Returns a reference to the underlying data array.\n     * <p>\n     * Does not make a fresh copy of the underlying data.</p>\n     *\n     * @return 2-dimensional array of entries\n     */\n    public double[][] getDataRef() {\n        return data;\n    }\n\n    /**\n     *\n     * @return norm\n     */\n    public double getNorm() {\n        double maxColSum = 0;\n        for (int col = 0; col < this.getColumnDimension(); col++) {\n            double sum = 0;\n            for (int row = 0; row < this.getRowDimension(); row++) {\n                sum += Math.abs(data[row][col]);\n            }\n            maxColSum = Math.max(maxColSum, sum);\n        }\n        return maxColSum;\n    }\n    \n    /**\n     * Gets a submatrix. Rows and columns are indicated\n     * counting from 0 to n-1.\n     *\n     * @param startRow Initial row index\n     * @param endRow Final row index\n     * @param startColumn Initial column index\n     * @param endColumn Final column index\n     * @return The subMatrix containing the data of the\n     *         specified rows and columns\n     * @exception MatrixIndexException if row or column selections are not valid\n     */\n    public RealMatrix getSubMatrix(int startRow, int endRow,\n                                   int startColumn, int endColumn)\n        throws MatrixIndexException {\n        if (startRow < 0 || startRow > endRow || endRow > data.length ||\n             startColumn < 0 || startColumn > endColumn ||\n             endColumn > data[0].length) {\n            throw new MatrixIndexException(\n                    \"invalid row or column index selection\");\n        }\n        final double[][] subMatrixData =\n            new double[endRow - startRow + 1][endColumn - startColumn + 1];\n        for (int i = startRow; i <= endRow; i++) {\n            System.arraycopy(data[i], startColumn,\n                             subMatrixData[i - startRow], 0,\n                             endColumn - startColumn + 1);\n        }\n        return new RealMatrixImpl(subMatrixData, false);\n    }\n    \n    /**\n     * Gets a submatrix. Rows and columns are indicated\n     * counting from 0 to n-1.\n     *\n     * @param selectedRows Array of row indices must be non-empty\n     * @param selectedColumns Array of column indices must be non-empty\n     * @return The subMatrix containing the data in the\n     *     specified rows and columns\n     * @exception MatrixIndexException  if supplied row or column index arrays\n     *     are not valid\n     */\n    public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n        throws MatrixIndexException {\n        if (selectedRows.length * selectedColumns.length == 0) {\n            throw new MatrixIndexException(\n                    \"selected row and column index arrays must be non-empty\");\n        }\n        final double[][] subMatrixData =\n            new double[selectedRows.length][selectedColumns.length];\n        try  {\n            for (int i = 0; i < selectedRows.length; i++) {\n                final double[] subI = subMatrixData[i];\n                final double[] dataSelectedI = data[selectedRows[i]];\n                for (int j = 0; j < selectedColumns.length; j++) {\n                    subI[j] = dataSelectedI[selectedColumns[j]];\n                }\n            }\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\"matrix dimension mismatch\");\n        }\n        return new RealMatrixImpl(subMatrixData, false);\n    } \n\n    /**\n     * Replace the submatrix starting at <code>row, column</code> using data in\n     * the input <code>subMatrix</code> array. Indexes are 0-based.\n     * <p> \n     * Example:<br>\n     * Starting with <pre>\n     * 1  2  3  4\n     * 5  6  7  8\n     * 9  0  1  2\n     * </pre>\n     * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking \n     * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>\n     * 1  2  3  4\n     * 5  3  4  8\n     * 9  5  6  2\n     * </pre></p>\n     * \n     * @param subMatrix  array containing the submatrix replacement data\n     * @param row  row coordinate of the top, left element to be replaced\n     * @param column  column coordinate of the top, left element to be replaced\n     * @throws MatrixIndexException  if subMatrix does not fit into this \n     *    matrix from element in (row, column) \n     * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if <code>subMatrix</code> is null\n     * @since 1.1\n     */\n    public void setSubMatrix(double[][] subMatrix, int row, int column) \n        throws MatrixIndexException {\n        if ((row < 0) || (column < 0)){\n            throw new MatrixIndexException\n                (\"invalid row or column index selection\");          \n        }\n        final int nRows = subMatrix.length;\n        if (nRows == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one row.\"); \n        }\n        final int nCols = subMatrix[0].length;\n        if (nCols == 0) {\n            throw new IllegalArgumentException(\n            \"Matrix must have at least one column.\"); \n        }\n        for (int r = 1; r < nRows; r++) {\n            if (subMatrix[r].length != nCols) {\n                throw new IllegalArgumentException(\n                \"All input rows must have the same length.\");\n            }\n        }       \n        if (data == null) {\n            if ((row > 0)||(column > 0)) throw new MatrixIndexException\n                (\"matrix must be initialized to perfom this method\");\n            data = new double[nRows][nCols];\n            System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n        }   \n        if (((nRows + row) > this.getRowDimension()) ||\n            (nCols + column > this.getColumnDimension()))\n            throw new MatrixIndexException(\n                    \"invalid row or column index selection\");                   \n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n        } \n        lu = null;\n    }\n    \n    /**\n     * Returns the entries in row number <code>row</code> as a row matrix.\n     * Row indices start at 0.\n     * \n     * @param row  the row to be fetched\n     * @return row matrix\n     * @throws MatrixIndexException if the specified row index is invalid\n     */\n    public RealMatrix getRowMatrix(int row) throws MatrixIndexException {\n        if ( !isValidCoordinate( row, 0)) {\n            throw new MatrixIndexException(\"illegal row argument\");\n        }\n        final int ncols = this.getColumnDimension();\n        final double[][] out = new double[1][ncols]; \n        System.arraycopy(data[row], 0, out[0], 0, ncols);\n        return new RealMatrixImpl(out, false);\n    }\n    \n    /**\n     * Returns the entries in column number <code>column</code>\n     * as a column matrix.  Column indices start at 0.\n     *\n     * @param column the column to be fetched\n     * @return column matrix\n     * @throws MatrixIndexException if the specified column index is invalid\n     */\n    public RealMatrix getColumnMatrix(int column) throws MatrixIndexException {\n        if ( !isValidCoordinate( 0, column)) {\n            throw new MatrixIndexException(\"illegal column argument\");\n        }\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][1]; \n        for (int row = 0; row < nRows; row++) {\n            out[row][0] = data[row][column];\n        }\n        return new RealMatrixImpl(out, false);\n    }\n\n     /**\n     * Returns the entries in row number <code>row</code> as an array.\n     * <p>\n     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n     * unless <code>0 <= row < rowDimension.</code></p>\n     *\n     * @param row the row to be fetched\n     * @return array of entries in the row\n     * @throws MatrixIndexException if the specified row index is not valid\n     */\n    public double[] getRow(int row) throws MatrixIndexException {\n        if ( !isValidCoordinate( row, 0 ) ) {\n            throw new MatrixIndexException(\"illegal row argument\");\n        }\n        final int ncols = this.getColumnDimension();\n        final double[] out = new double[ncols];\n        System.arraycopy(data[row], 0, out, 0, ncols);\n        return out;\n    }\n\n    /**\n     * Returns the entries in column number <code>col</code> as an array.\n     * <p>\n     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n     * unless <code>0 <= column < columnDimension.</code></p>\n     *\n     * @param col the column to be fetched\n     * @return array of entries in the column\n     * @throws MatrixIndexException if the specified column index is not valid\n     */\n    public double[] getColumn(int col) throws MatrixIndexException {\n        if ( !isValidCoordinate(0, col) ) {\n            throw new MatrixIndexException(\"illegal column argument\");\n        }\n        final int nRows = this.getRowDimension();\n        final double[] out = new double[nRows];\n        for (int row = 0; row < nRows; row++) {\n            out[row] = data[row][col];\n        }\n        return out;\n    }\n\n    /**\n     * Returns the entry in the specified row and column.\n     * <p>\n     * Row and column indices start at 0 and must satisfy \n     * <ul>\n     * <li><code>0 <= row < rowDimension</code></li>\n     * <li><code> 0 <= column < columnDimension</code></li>\n     * </ul>\n     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n     * \n     * @param row  row location of entry to be fetched\n     * @param column  column location of entry to be fetched\n     * @return matrix entry in row,column\n     * @throws MatrixIndexException if the row or column index is not valid\n     */\n    public double getEntry(int row, int column)\n        throws MatrixIndexException {\n        try {\n            return data[row][column];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\"matrix entry does not exist\");\n        }\n    }\n\n    /**\n     * Returns the transpose matrix.\n     *\n     * @return transpose matrix\n     */\n    public RealMatrix transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final double[][] outData = new double[nCols][nRows];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n                outData[col][row] = dataRow[col];\n            }\n        }\n        return new RealMatrixImpl(outData, false);\n    }\n\n    /**\n     * Returns the inverse matrix if this matrix is invertible.\n     *\n     * @return inverse matrix\n     * @throws InvalidMatrixException if this is not invertible\n     */\n    public RealMatrix inverse() throws InvalidMatrixException {\n        return solve(MatrixUtils.createRealIdentityMatrix(getRowDimension()));\n    }\n\n    /**\n     * @return determinant\n     * @throws InvalidMatrixException if matrix is not square\n     */\n    public double getDeterminant() throws InvalidMatrixException {\n        if (!isSquare()) {\n            throw new InvalidMatrixException(\"matrix is not square\");\n        }\n        if (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null\n            return 0d;\n        } else {\n            double det = parity;\n            for (int i = 0; i < this.getRowDimension(); i++) {\n                det *= lu[i][i];\n            }\n            return det;\n        }\n    }\n\n    /**\n     * @return true if the matrix is square (rowDimension = columnDimension)\n     */\n    public boolean isSquare() {\n        return (this.getColumnDimension() == this.getRowDimension());\n    }\n\n    /**\n     * @return true if the matrix is singular\n     */\n    public boolean isSingular() {\n        if (lu == null) {\n            try {\n                luDecompose();\n                return false;\n            } catch (InvalidMatrixException ex) {\n                return true;\n            }\n        } else { // LU decomp must have been successfully performed\n            return false; // so the matrix is not singular\n        }\n    }\n\n    /**\n     * @return rowDimension\n     */\n    public int getRowDimension() {\n        return data.length;\n    }\n\n    /**\n     * @return columnDimension\n     */\n    public int getColumnDimension() {\n        return data[0].length;\n    }\n\n    /**\n     * @return trace\n     * @throws IllegalArgumentException if the matrix is not square\n     */\n    public double getTrace() throws IllegalArgumentException {\n        if (!isSquare()) {\n            throw new IllegalArgumentException(\"matrix is not square\");\n        }\n        double trace = data[0][0];\n        for (int i = 1; i < this.getRowDimension(); i++) {\n            trace += data[i][i];\n        }\n        return trace;\n    }\n\n    /**\n     * @param v vector to operate on\n     * @throws IllegalArgumentException if columnDimension != v.length\n     * @return resulting vector\n     */\n    public double[] operate(double[] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        if (v.length != nCols) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final double[] out = new double[v.length];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            double sum = 0;\n            for (int i = 0; i < nCols; i++) {\n                sum += dataRow[i] * v[i];\n            }\n            out[row] = sum;\n        }\n        return out;\n    }\n\n    /**\n     * @param v vector to premultiply by\n     * @throws IllegalArgumentException if rowDimension != v.length\n     * @return resulting matrix\n     */\n    public double[] preMultiply(double[] v) throws IllegalArgumentException {\n        final int nRows = this.getRowDimension();\n        if (v.length != nRows) {\n            throw new IllegalArgumentException(\"vector has wrong length\");\n        }\n        final int nCols = this.getColumnDimension();\n        final double[] out = new double[nCols];\n        for (int col = 0; col < nCols; col++) {\n            double sum = 0;\n            for (int i = 0; i < nRows; i++) {\n                sum += data[i][col] * v[i];\n            }\n            out[col] = sum;\n        }\n        return out;\n    }\n\n    /**\n     * Returns a matrix of (column) solution vectors for linear systems with\n     * coefficient matrix = this and constant vectors = columns of\n     * <code>b</code>.\n     *\n     * @param b  array of constant forming RHS of linear systems to\n     * to solve\n     * @return solution array\n     * @throws IllegalArgumentException if this.rowDimension != row dimension\n     * @throws InvalidMatrixException if this matrix is not square or is singular\n     */\n    public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n        final int nRows = this.getRowDimension();\n        if (b.length != nRows) {\n            throw new IllegalArgumentException(\"constant vector has wrong length\");\n        }\n        final RealMatrix bMatrix = new RealMatrixImpl(b);\n        final double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n        final double[] out = new double[nRows];\n        for (int row = 0; row < nRows; row++) {\n            out[row] = solution[row][0];\n        }\n        return out;\n    }\n\n    /**\n     * Returns a matrix of (column) solution vectors for linear systems with\n     * coefficient matrix = this and constant vectors = columns of\n     * <code>b</code>.\n     *\n     * @param b  matrix of constant vectors forming RHS of linear systems to\n     * to solve\n     * @return matrix of solution vectors\n     * @throws IllegalArgumentException if this.rowDimension != row dimension\n     * @throws InvalidMatrixException if this matrix is not square or is singular\n     */\n    public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n        if (b.getRowDimension() != this.getRowDimension()) {\n            throw new IllegalArgumentException(\"Incorrect row dimension\");\n        }\n        if (!this.isSquare()) {\n            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n        }\n        if (this.isSingular()) { // side effect: compute LU decomp\n            throw new InvalidMatrixException(\"Matrix is singular.\");\n        }\n\n        final int nCol  = this.getColumnDimension();\n        final int nColB = b.getColumnDimension();\n        final int nRowB = b.getRowDimension();\n\n        // Apply permutations to b\n        final double[][] bp = new double[nRowB][nColB];\n        for (int row = 0; row < nRowB; row++) {\n            final double[] bpRow = bp[row];\n            for (int col = 0; col < nColB; col++) {\n                bpRow[col] = b.getEntry(permutation[row], col);\n            }\n        }\n\n        // Solve LY = b\n        for (int col = 0; col < nCol; col++) {\n            for (int i = col + 1; i < nCol; i++) {\n                final double[] bpI = bp[i];\n                final double[] luI = lu[i];\n                for (int j = 0; j < nColB; j++) {\n                    bpI[j] -= bp[col][j] * luI[col];\n                }\n            }\n        }\n\n        // Solve UX = Y\n        for (int col = nCol - 1; col >= 0; col--) {\n            final double[] bpCol = bp[col];\n            final double luDiag = lu[col][col];\n            for (int j = 0; j < nColB; j++) {\n                bpCol[j] /= luDiag;\n            }\n            for (int i = 0; i < col; i++) {\n                final double[] bpI = bp[i];\n                final double[] luI = lu[i];\n                for (int j = 0; j < nColB; j++) {\n                    bpI[j] -= bp[col][j] * luI[col];\n                }\n            }\n        }\n\n        return new RealMatrixImpl(bp, false);\n\n    }\n\n    /**\n     * Computes a new\n     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n     * LU decomposition</a> for this matrix, storing the result for use by other methods.\n     * <p>\n     * <strong>Implementation Note</strong>:<br>\n     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n     * Crout's algorithm</a>, with partial pivoting.</p>\n     * <p>\n     * <strong>Usage Note</strong>:<br>\n     * This method should rarely be invoked directly. Its only use is\n     * to force recomputation of the LU decomposition when changes have been\n     * made to the underlying data using direct array references. Changes\n     * made using setXxx methods will trigger recomputation when needed\n     * automatically.</p>\n     *\n     * @throws InvalidMatrixException if the matrix is non-square or singular.\n     */\n    public void luDecompose() throws InvalidMatrixException {\n\n        final int nRows = this.getRowDimension();\n        final int nCols = this.getColumnDimension();\n        if (nRows != nCols) {\n            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n        }\n        lu = getData();\n\n        // Initialize permutation array and parity\n        permutation = new int[nRows];\n        for (int row = 0; row < nRows; row++) {\n            permutation[row] = row;\n        }\n        parity = 1;\n\n        // Loop over columns\n        for (int col = 0; col < nCols; col++) {\n\n            double sum = 0;\n\n            // upper\n            for (int row = 0; row < col; row++) {\n                final double[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < row; i++) {\n                    sum -= luRow[i] * lu[i][col];\n                }\n                luRow[col] = sum;\n            }\n\n            // lower\n            int max = col; // permutation row\n            double largest = 0d;\n            for (int row = col; row < nRows; row++) {\n                final double[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < col; i++) {\n                    sum -= luRow[i] * lu[i][col];\n                }\n                luRow[col] = sum;\n\n                // maintain best permutation choice\n                if (Math.abs(sum) > largest) {\n                    largest = Math.abs(sum);\n                    max = row;\n                }\n            }\n\n            // Singularity check\n            if (Math.abs(lu[max][col]) < TOO_SMALL) {\n                lu = null;\n                throw new InvalidMatrixException(\"matrix is singular\");\n            }\n\n            // Pivot if necessary\n            if (max != col) {\n                double tmp = 0;\n                for (int i = 0; i < nCols; i++) {\n                    tmp = lu[max][i];\n                    lu[max][i] = lu[col][i];\n                    lu[col][i] = tmp;\n                }\n                int temp = permutation[max];\n                permutation[max] = permutation[col];\n                permutation[col] = temp;\n                parity = -parity;\n            }\n\n            // Divide the lower elements by the \"winning\" diagonal elt.\n            final double luDiag = lu[col][col];\n            for (int row = col + 1; row < nRows; row++) {\n                lu[row][col] /= luDiag;\n            }\n        }\n    }\n\n    /**\n     * Get a string representation for this matrix.\n     * @return a string representation for this matrix\n     */\n    public String toString() {\n        StringBuffer res = new StringBuffer();\n        res.append(\"RealMatrixImpl{\");\n        if (data != null) {\n            for (int i = 0; i < data.length; i++) {\n                if (i > 0) {\n                    res.append(\",\");\n                }\n                res.append(\"{\");\n                for (int j = 0; j < data[0].length; j++) {\n                    if (j > 0) {\n                        res.append(\",\");\n                    }\n                    res.append(data[i][j]);\n                } \n                res.append(\"}\");\n            } \n        }\n        res.append(\"}\");\n        return res.toString();\n    } \n    \n    /**\n     * Returns true iff <code>object</code> is a \n     * <code>RealMatrixImpl</code> instance with the same dimensions as this\n     * and all corresponding matrix entries are equal.  Corresponding entries\n     * are compared using {@link java.lang.Double#doubleToLongBits(double)}\n     * \n     * @param object the object to test equality against.\n     * @return true if object equals this\n     */\n    public boolean equals(Object object) {\n        if (object == this ) {\n            return true;\n        }\n        if (object instanceof RealMatrixImpl == false) {\n            return false;\n        }\n        RealMatrix m = (RealMatrix) object;\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n            return false;\n        }\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n                if (Double.doubleToLongBits(dataRow[col]) != \n                    Double.doubleToLongBits(m.getEntry(row, col))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    /**\n     * Computes a hashcode for the matrix.\n     * \n     * @return hashcode for matrix\n     */\n    public int hashCode() {\n        int ret = 7;\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        ret = ret * 31 + nRows;\n        ret = ret * 31 + nCols;\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow = data[row];\n            for (int col = 0; col < nCols; col++) {\n               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n                   MathUtils.hash(dataRow[col]);\n           }\n        }\n        return ret;\n    }\n\n    //------------------------ Protected methods\n\n    /**\n     *  Returns the LU decomposition as a RealMatrix.\n     *  Returns a fresh copy of the cached LU matrix if this has been computed;\n     *  otherwise the composition is computed and cached for use by other methods.\n     *  Since a copy is returned in either case, changes to the returned matrix do not\n     *  affect the LU decomposition property.\n     * <p>\n     * The matrix returned is a compact representation of the LU decomposition.\n     * Elements below the main diagonal correspond to entries of the \"L\" matrix;\n     * elements on and above the main diagonal correspond to entries of the \"U\"\n     * matrix.</p>\n     * <p>\n     * Example: <pre>\n     *\n     *     Returned matrix                L                  U\n     *         2  3  1                   1  0  0            2  3  1\n     *         5  4  6                   5  1  0            0  4  6\n     *         1  7  8                   1  7  1            0  0  8\n     * </pre>\n     *\n     * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>\n     *  where permuteRows reorders the rows of the matrix to follow the order determined\n     *  by the <a href=#getPermutation()>permutation</a> property.</p>\n     *\n     * @return LU decomposition matrix\n     * @throws InvalidMatrixException if the matrix is non-square or singular.\n     */\n    protected RealMatrix getLUMatrix() throws InvalidMatrixException {\n        if (lu == null) {\n            luDecompose();\n        }\n        return new RealMatrixImpl(lu);\n    }\n\n    /**\n     * Returns the permutation associated with the lu decomposition.\n     * The entries of the array represent a permutation of the numbers 0, ... , nRows - 1.\n     * <p>\n     * Example:\n     * permutation = [1, 2, 0] means current 2nd row is first, current third row is second\n     * and current first row is last.</p>\n     * <p>\n     * Returns a fresh copy of the array.</p>\n     *\n     * @return the permutation\n     */\n    protected int[] getPermutation() {\n        final int[] out = new int[permutation.length];\n        System.arraycopy(permutation, 0, out, 0, permutation.length);\n        return out;\n    }\n\n    //------------------------ Private methods\n\n    /**\n     * Returns a fresh copy of the underlying data array.\n     *\n     * @return a copy of the underlying data array.\n     */\n    private double[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][this.getColumnDimension()];\n        // can't copy 2-d array in one shot, otherwise get row references\n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }\n\n    /**\n     * Replaces data with a fresh copy of the input array.\n     * <p>\n     * Verifies that the input array is rectangular and non-empty.</p>\n     *\n     * @param in data to copy in\n     * @throws IllegalArgumentException if input array is empty or not\n     *    rectangular\n     * @throws NullPointerException if input array is null\n     */\n    private void copyIn(double[][] in) {\n        setSubMatrix(in,0,0);\n    }\n\n    /**\n     * Tests a given coordinate as being valid or invalid\n     *\n     * @param row the row index.\n     * @param col the column index.\n     * @return true if the coordinate is with the current dimensions\n     */\n    private boolean isValidCoordinate(int row, int col) {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        return !(row < 0 || row > nRows - 1 || col < 0 || col > nCols -1);\n    }\n\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"type\": \"Potential Null Pointer Exception\",\n         \"description\": \"In the RealMatrixImpl(double[][] d, boolean copyArray) constructor, if copyArray is false and d is null, a NullPointerException will be thrown. However, the code does not check for null before trying to access d[0].length and d[r].length.\",\n         \"line\": 124\n      },\n      {\n         \"type\": \"Potential Index Out Of Bounds Exception\",\n         \"description\": \"In the RealMatrixImpl(double[][] d, boolean copyArray) constructor, if copyArray is false and d is not null, the code does not check if r is within the bounds of d before trying to access d[r].length.\",\n         \"line\": 130\n      },\n      {\n         \"type\": \"Potential IllegalArgumentException\",\n         \"description\": \"In the RealMatrixImpl(double[][] d, boolean copyArray) constructor, if copyArray is false and d is not null, the code does not check if nCols is positive before trying to access d[r].length.\",\n         \"line\": 133\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"description\": \"In the RealMatrixImpl(double[][] d) constructor, the copyIn(d) method is called without checking if d is null. If d is null, a NullPointerException will be thrown.\",\n         \"line\": 90\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"description\": \"In the RealMatrixImpl(int rowDimension, int columnDimension) constructor, the data array is initialized without checking if rowDimension or columnDimension is positive. If either of these values is not positive, an IllegalArgumentException will be thrown.\",\n         \"line\": 55\n      }\n   ]\n}"}}