{"sample_id": "Lang_41", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * <p>Operates on classes without using reflection.</p>\n *\n * <p>This class handles invalid <code>null</code> inputs as best it can.\n * Each method documents its behaviour in more detail.</p>\n *\n * <p>The notion of a <code>canonical name</code> includes the human\n * readable name for the type, for example <code>int[]</code>. The\n * non-canonical method variants work with the JVM names, such as\n * <code>[I</code>. </p>\n *\n * @author Stephen Colebourne\n * @author Gary Gregory\n * @author Norm Deane\n * @author Alban Peignier\n * @author Tomasz Blachowicz\n * @since 2.0\n * @version $Id$\n */\npublic class ClassUtils {\n\n    /**\n     * <p>The package separator character: <code>'&#x2e;' == {@value}</code>.</p>\n     */\n    public static final char PACKAGE_SEPARATOR_CHAR = '.';\n\n    /**\n     * <p>The package separator String: <code>\"&#x2e;\"</code>.</p>\n     */\n    public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n\n    /**\n     * <p>The inner class separator character: <code>'$' == {@value}</code>.</p>\n     */\n    public static final char INNER_CLASS_SEPARATOR_CHAR = '$';\n\n    /**\n     * <p>The inner class separator String: <code>\"$\"</code>.</p>\n     */\n    public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR);\n\n    /**\n     * Maps primitive <code>Class</code>es to their corresponding wrapper <code>Class</code>.\n     */\n    private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>();\n    static {\n         primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n         primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n         primitiveWrapperMap.put(Character.TYPE, Character.class);\n         primitiveWrapperMap.put(Short.TYPE, Short.class);\n         primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n         primitiveWrapperMap.put(Long.TYPE, Long.class);\n         primitiveWrapperMap.put(Double.TYPE, Double.class);\n         primitiveWrapperMap.put(Float.TYPE, Float.class);\n         primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n    }\n\n    /**\n     * Maps wrapper <code>Class</code>es to their corresponding primitive types.\n     */\n    private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>();\n    static {\n        for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) {\n            Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);\n            if (!primitiveClass.equals(wrapperClass)) {\n                wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n            }\n        }\n    }\n\n    /**\n     * Maps a primitive class name to its corresponding abbreviation used in array class names.\n     */\n    private static final Map<String, String> abbreviationMap = new HashMap<String, String>();\n\n    /**\n     * Maps an abbreviation used in array class names to corresponding primitive class name.\n     */\n    private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>();\n\n    /**\n     * Add primitive type abbreviation to maps of abbreviations.\n     *\n     * @param primitive Canonical name of primitive type\n     * @param abbreviation Corresponding abbreviation of primitive type\n     */\n    private static void addAbbreviation(String primitive, String abbreviation) {\n        abbreviationMap.put(primitive, abbreviation);\n        reverseAbbreviationMap.put(abbreviation, primitive);\n    }\n\n    /**\n     * Feed abbreviation maps\n     */\n    static {\n        addAbbreviation(\"int\", \"I\");\n        addAbbreviation(\"boolean\", \"Z\");\n        addAbbreviation(\"float\", \"F\");\n        addAbbreviation(\"long\", \"J\");\n        addAbbreviation(\"short\", \"S\");\n        addAbbreviation(\"byte\", \"B\");\n        addAbbreviation(\"double\", \"D\");\n        addAbbreviation(\"char\", \"C\");\n    }\n\n    /**\n     * <p>ClassUtils instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as\n     * <code>ClassUtils.getShortClassName(cls)</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public ClassUtils() {\n      super();\n    }\n\n    // Short class name\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Gets the class name minus the package name for an <code>Object</code>.</p>\n     *\n     * @param object  the class to get the short name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the class name of the object without the package name, or the null value\n     */\n    public static String getShortClassName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortClassName(object.getClass());\n    }\n\n    /**\n     * <p>Gets the class name minus the package name from a <code>Class</code>.</p>\n     *\n     * @param cls  the class to get the short name for.\n     * @return the class name without the package name or an empty string\n     */\n    public static String getShortClassName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortClassName(cls.getName());\n    }\n\n    /**\n     * <p>Gets the class name minus the package name from a String.</p>\n     *\n     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n     *\n     * @param className  the className to get the short name for\n     * @return the class name of the class without the package name or an empty string\n     */\n    public static String getShortClassName(String className) {\n        if (className == null) {\n            return StringUtils.EMPTY;\n        }\n        if (className.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n\n        // Handle array encoding\n            // Strip Object type encoding\n\n\n        int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        int innerIdx = className.indexOf(\n                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n        String out = className.substring(lastDotIdx + 1);\n        if (innerIdx != -1) {\n            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n        }\n        return out;\n    }\n\n    // Package name\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Gets the package name of an <code>Object</code>.</p>\n     *\n     * @param object  the class to get the package name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the package name of the object, or the null value\n     */\n    public static String getPackageName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageName(object.getClass());\n    }\n\n    /**\n     * <p>Gets the package name of a <code>Class</code>.</p>\n     *\n     * @param cls  the class to get the package name for, may be <code>null</code>.\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageName(cls.getName());\n    }\n\n    /**\n     * <p>Gets the package name from a <code>String</code>.</p>\n     *\n     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n     * <p>If the class is unpackaged, return an empty string.</p>\n     *\n     * @param className  the className to get the package name for, may be <code>null</code>\n     * @return the package name or an empty string\n     */\n    public static String getPackageName(String className) {\n        if (className == null) {\n            return StringUtils.EMPTY;\n        }\n\n        // Strip array encoding\n        // Strip Object type encoding\n\n        int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n        if (i == -1) {\n            return StringUtils.EMPTY;\n        }\n        return className.substring(0, i);\n    }\n\n    // Superclasses/Superinterfaces\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Gets a <code>List</code> of superclasses for the given class.</p>\n     *\n     * @param cls  the class to look up, may be <code>null</code>\n     * @return the <code>List</code> of superclasses in order going up from this one\n     *  <code>null</code> if null input\n     */\n    public static List<Class<?>> getAllSuperclasses(Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n        List<Class<?>> classes = new ArrayList<Class<?>>();\n        Class<?> superclass = cls.getSuperclass();\n        while (superclass != null) {\n            classes.add(superclass);\n            superclass = superclass.getSuperclass();\n        }\n        return classes;\n    }\n\n    /**\n     * <p>Gets a <code>List</code> of all interfaces implemented by the given\n     * class and its superclasses.</p>\n     *\n     * <p>The order is determined by looking through each interface in turn as\n     * declared in the source file and following its hierarchy up. Then each\n     * superclass is considered in the same way. Later duplicates are ignored,\n     * so the order is maintained.</p>\n     *\n     * @param cls  the class to look up, may be <code>null</code>\n     * @return the <code>List</code> of interfaces in order,\n     *  <code>null</code> if null input\n     */\n    public static List<Class<?>> getAllInterfaces(Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n\n        LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();\n        getAllInterfaces(cls, interfacesFound);\n\n        return new ArrayList<Class<?>>(interfacesFound);\n    }\n\n    private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) {\n        while (cls != null) {\n            Class<?>[] interfaces = cls.getInterfaces();\n\n            for (Class<?> i : interfaces) {\n                if (interfacesFound.add(i)) {\n                    getAllInterfaces(i, interfacesFound);\n                }\n            }\n\n            cls = cls.getSuperclass();\n         }\n     }\n\n    // Convert list\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Given a <code>List</code> of class names, this method converts them into classes.</p>\n     *\n     * <p>A new <code>List</code> is returned. If the class name cannot be found, <code>null</code>\n     * is stored in the <code>List</code>. If the class name in the <code>List</code> is\n     * <code>null</code>, <code>null</code> is stored in the output <code>List</code>.</p>\n     *\n     * @param classNames  the classNames to change\n     * @return a <code>List</code> of Class objects corresponding to the class names,\n     *  <code>null</code> if null input\n     * @throws ClassCastException if classNames contains a non String entry\n     */\n    public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) {\n        if (classNames == null) {\n            return null;\n        }\n        List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());\n        for (String className : classNames) {\n            try {\n                classes.add(Class.forName(className));\n            } catch (Exception ex) {\n                classes.add(null);\n            }\n        }\n        return classes;\n    }\n\n    /**\n     * <p>Given a <code>List</code> of <code>Class</code> objects, this method converts\n     * them into class names.</p>\n     *\n     * <p>A new <code>List</code> is returned. <code>null</code> objects will be copied into\n     * the returned list as <code>null</code>.</p>\n     *\n     * @param classes  the classes to change\n     * @return a <code>List</code> of class names corresponding to the Class objects,\n     *  <code>null</code> if null input\n     * @throws ClassCastException if <code>classes</code> contains a non-<code>Class</code> entry\n     */\n    public static List<String> convertClassesToClassNames(List<Class<?>> classes) {\n        if (classes == null) {\n            return null;\n        }\n        List<String> classNames = new ArrayList<String>(classes.size());\n        for (Class<?> cls : classes) {\n            if (cls == null) {\n                classNames.add(null);\n            } else {\n                classNames.add(cls.getName());\n            }\n        }\n        return classNames;\n    }\n\n    // Is assignable\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>\n     *\n     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each\n     * Class pair in the input arrays. It can be used to check if a set of arguments\n     * (the first parameter) are suitably compatible with a set of method parameter types\n     * (the second parameter).</p>\n     *\n     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this\n     * method takes into account widenings of primitive classes and\n     * <code>null</code>s.</p>\n     *\n     * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,\n     * <code>float</code> or <code>double</code>. This method returns the correct\n     * result for these cases.</p>\n     *\n     * <p><code>Null</code> may be assigned to any reference type. This method will\n     * return <code>true</code> if <code>null</code> is passed in and the toClass is\n     * non-primitive.</p>\n     *\n     * <p>Specifically, this method tests whether the type represented by the\n     * specified <code>Class</code> parameter can be converted to the type\n     * represented by this <code>Class</code> object via an identity conversion\n     * widening primitive or widening reference conversion. See\n     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n     *\n     * @param classArray  the array of Classes to check, may be <code>null</code>\n     * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>\n     * @return <code>true</code> if assignment possible\n     */\n    //TODO when we bump the major version we should default autoboxing to true on platforms >= 1.5\n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) {\n        return isAssignable(classArray, toClassArray, false);\n    }\n\n    /**\n     * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>\n     *\n     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each\n     * Class pair in the input arrays. It can be used to check if a set of arguments\n     * (the first parameter) are suitably compatible with a set of method parameter types\n     * (the second parameter).</p>\n     *\n     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this\n     * method takes into account widenings of primitive classes and\n     * <code>null</code>s.</p>\n     *\n     * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,\n     * <code>float</code> or <code>double</code>. This method returns the correct\n     * result for these cases.</p>\n     *\n     * <p><code>Null</code> may be assigned to any reference type. This method will\n     * return <code>true</code> if <code>null</code> is passed in and the toClass is\n     * non-primitive.</p>\n     *\n     * <p>Specifically, this method tests whether the type represented by the\n     * specified <code>Class</code> parameter can be converted to the type\n     * represented by this <code>Class</code> object via an identity conversion\n     * widening primitive or widening reference conversion. See\n     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n     *\n     * @param classArray  the array of Classes to check, may be <code>null</code>\n     * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>\n     * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers\n     * @return <code>true</code> if assignment possible\n     */\n    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {\n        if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {\n            return false;\n        }\n        if (classArray == null) {\n            classArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        if (toClassArray == null) {\n            toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        for (int i = 0; i < classArray.length; i++) {\n            if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if one <code>Class</code> can be assigned to a variable of\n     * another <code>Class</code>.</p>\n     *\n     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,\n     * this method takes into account widenings of primitive classes and\n     * <code>null</code>s.</p>\n     *\n     * <p>Primitive widenings allow an int to be assigned to a long, float or\n     * double. This method returns the correct result for these cases.</p>\n     *\n     * <p><code>Null</code> may be assigned to any reference type. This method\n     * will return <code>true</code> if <code>null</code> is passed in and the\n     * toClass is non-primitive.</p>\n     *\n     * <p>Specifically, this method tests whether the type represented by the\n     * specified <code>Class</code> parameter can be converted to the type\n     * represented by this <code>Class</code> object via an identity conversion\n     * widening primitive or widening reference conversion. See\n     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n     *\n     * @param cls  the Class to check, may be null\n     * @param toClass  the Class to try to assign into, returns false if null\n     * @return <code>true</code> if assignment possible\n     */\n    //TODO when we bump the major version we should default autoboxing to true on platforms >= 1.5\n    public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\n        return isAssignable(cls, toClass, false);\n    }\n\n    /**\n     * <p>Checks if one <code>Class</code> can be assigned to a variable of\n     * another <code>Class</code>.</p>\n     *\n     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,\n     * this method takes into account widenings of primitive classes and\n     * <code>null</code>s.</p>\n     *\n     * <p>Primitive widenings allow an int to be assigned to a long, float or\n     * double. This method returns the correct result for these cases.</p>\n     *\n     * <p><code>Null</code> may be assigned to any reference type. This method\n     * will return <code>true</code> if <code>null</code> is passed in and the\n     * toClass is non-primitive.</p>\n     *\n     * <p>Specifically, this method tests whether the type represented by the\n     * specified <code>Class</code> parameter can be converted to the type\n     * represented by this <code>Class</code> object via an identity conversion\n     * widening primitive or widening reference conversion. See\n     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n     *\n     * @param cls  the Class to check, may be null\n     * @param toClass  the Class to try to assign into, returns false if null\n     * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers\n     * @return <code>true</code> if assignment possible\n     */\n    public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\n        if (toClass == null) {\n            return false;\n        }\n        // have to check for null, as isAssignableFrom doesn't\n        if (cls == null) {\n            return !(toClass.isPrimitive());\n        }\n        //autoboxing:\n        if (autoboxing) {\n            if (cls.isPrimitive() && !toClass.isPrimitive()) {\n                cls = primitiveToWrapper(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n            if (toClass.isPrimitive() && !cls.isPrimitive()) {\n                cls = wrapperToPrimitive(cls);\n                if (cls == null) {\n                    return false;\n                }\n            }\n        }\n        if (cls.equals(toClass)) {\n            return true;\n        }\n        if (cls.isPrimitive()) {\n            if (toClass.isPrimitive() == false) {\n                return false;\n            }\n            if (Integer.TYPE.equals(cls)) {\n                return Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Long.TYPE.equals(cls)) {\n                return Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Boolean.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Double.TYPE.equals(cls)) {\n                return false;\n            }\n            if (Float.TYPE.equals(cls)) {\n                return Double.TYPE.equals(toClass);\n            }\n            if (Character.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Short.TYPE.equals(cls)) {\n                return Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            if (Byte.TYPE.equals(cls)) {\n                return Short.TYPE.equals(toClass)\n                    || Integer.TYPE.equals(toClass)\n                    || Long.TYPE.equals(toClass)\n                    || Float.TYPE.equals(toClass)\n                    || Double.TYPE.equals(toClass);\n            }\n            // should never get here\n            return false;\n        }\n        return toClass.isAssignableFrom(cls);\n    }\n\n    /**\n     * <p>Converts the specified primitive Class object to its corresponding\n     * wrapper Class object.</p>\n     *\n     * <p>NOTE: From v2.2, this method handles <code>Void.TYPE</code>,\n     * returning <code>Void.TYPE</code>.</p>\n     *\n     * @param cls  the class to convert, may be null\n     * @return the wrapper class for <code>cls</code> or <code>cls</code> if\n     * <code>cls</code> is not a primitive. <code>null</code> if null input.\n     * @since 2.1\n     */\n    public static Class<?> primitiveToWrapper(Class<?> cls) {\n        Class<?> convertedClass = cls;\n        if (cls != null && cls.isPrimitive()) {\n            convertedClass = primitiveWrapperMap.get(cls);\n        }\n        return convertedClass;\n    }\n\n    /**\n     * <p>Converts the specified array of primitive Class objects to an array of\n     * its corresponding wrapper Class objects.</p>\n     *\n     * @param classes  the class array to convert, may be null or empty\n     * @return an array which contains for each given class, the wrapper class or\n     * the original class if class is not a primitive. <code>null</code> if null input.\n     * Empty array if an empty array passed in.\n     * @since 2.1\n     */\n    public static Class<?>[] primitivesToWrappers(Class<?>[] classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        Class<?>[] convertedClasses = new Class[classes.length];\n        for (int i = 0; i < classes.length; i++) {\n            convertedClasses[i] = primitiveToWrapper(classes[i]);\n        }\n        return convertedClasses;\n    }\n\n    /**\n     * <p>Converts the specified wrapper class to its corresponding primitive\n     * class.</p>\n     *\n     * <p>This method is the counter part of <code>primitiveToWrapper()</code>.\n     * If the passed in class is a wrapper class for a primitive type, this\n     * primitive type will be returned (e.g. <code>Integer.TYPE</code> for\n     * <code>Integer.class</code>). For other classes, or if the parameter is\n     * <b>null</b>, the return value is <b>null</b>.</p>\n     *\n     * @param cls the class to convert, may be <b>null</b>\n     * @return the corresponding primitive type if <code>cls</code> is a\n     * wrapper class, <b>null</b> otherwise\n     * @see #primitiveToWrapper(Class)\n     * @since 2.4\n     */\n    public static Class<?> wrapperToPrimitive(Class<?> cls) {\n        return wrapperPrimitiveMap.get(cls);\n    }\n\n    /**\n     * <p>Converts the specified array of wrapper Class objects to an array of\n     * its corresponding primitive Class objects.</p>\n     *\n     * <p>This method invokes <code>wrapperToPrimitive()</code> for each element\n     * of the passed in array.</p>\n     *\n     * @param classes  the class array to convert, may be null or empty\n     * @return an array which contains for each given class, the primitive class or\n     * <b>null</b> if the original class is not a wrapper class. <code>null</code> if null input.\n     * Empty array if an empty array passed in.\n     * @see #wrapperToPrimitive(Class)\n     * @since 2.4\n     */\n    public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) {\n        if (classes == null) {\n            return null;\n        }\n\n        if (classes.length == 0) {\n            return classes;\n        }\n\n        Class<?>[] convertedClasses = new Class[classes.length];\n        for (int i = 0; i < classes.length; i++) {\n            convertedClasses[i] = wrapperToPrimitive(classes[i]);\n        }\n        return convertedClasses;\n    }\n\n    // Inner class\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Is the specified class an inner class or static nested class.</p>\n     *\n     * @param cls  the class to check, may be null\n     * @return <code>true</code> if the class is an inner or static nested class,\n     *  false if not or <code>null</code>\n     */\n    public static boolean isInnerClass(Class<?> cls) {\n        if (cls == null) {\n            return false;\n        }\n        return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0;\n    }\n\n    // Class loading\n    // ----------------------------------------------------------------------\n    /**\n     * Returns the class represented by <code>className</code> using the\n     * <code>classLoader</code>.  This implementation supports names like\n     * \"<code>java.lang.String[]</code>\" as well as \"<code>[Ljava.lang.String;</code>\".\n     *\n     * @param classLoader  the class loader to use to load the class\n     * @param className  the class name\n     * @param initialize  whether the class must be initialized\n     * @return the class represented by <code>className</code> using the <code>classLoader</code>\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(\n            ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {\n        Class<?> clazz;\n        if (abbreviationMap.containsKey(className)) {\n            String clsName = \"[\" + abbreviationMap.get(className);\n            clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n        } else {\n            clazz = Class.forName(toCanonicalName(className), initialize, classLoader);\n        }\n        return clazz;\n    }\n\n    /**\n     * Returns the (initialized) class represented by <code>className</code>\n     * using the <code>classLoader</code>.  This implementation supports names\n     * like \"<code>java.lang.String[]</code>\" as well as\n     * \"<code>[Ljava.lang.String;</code>\".\n     *\n     * @param classLoader  the class loader to use to load the class\n     * @param className  the class name\n     * @return the class represented by <code>className</code> using the <code>classLoader</code>\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n        return getClass(classLoader, className, true);\n    }\n\n    /**\n     * Returns the (initialized) class represented by <code>className</code>\n     * using the current thread's context class loader. This implementation\n     * supports names like \"<code>java.lang.String[]</code>\" as well as\n     * \"<code>[Ljava.lang.String;</code>\".\n     *\n     * @param className  the class name\n     * @return the class represented by <code>className</code> using the current thread's context class loader\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(String className) throws ClassNotFoundException {\n        return getClass(className, true);\n    }\n\n    /**\n     * Returns the class represented by <code>className</code> using the\n     * current thread's context class loader. This implementation supports\n     * names like \"<code>java.lang.String[]</code>\" as well as\n     * \"<code>[Ljava.lang.String;</code>\".\n     *\n     * @param className  the class name\n     * @param initialize  whether the class must be initialized\n     * @return the class represented by <code>className</code> using the current thread's context class loader\n     * @throws ClassNotFoundException if the class is not found\n     */\n    public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {\n        ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n        ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n        return getClass(loader, className, initialize );\n    }\n\n    // Public method\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Returns the desired Method much like <code>Class.getMethod</code>, however\n     * it ensures that the returned Method is from a public class or interface and not\n     * from an anonymous inner class. This means that the Method is invokable and\n     * doesn't fall foul of Java bug\n     * <a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957\">4071957</a>).\n     *\n     *  <code><pre>Set set = Collections.unmodifiableSet(...);\n     *  Method method = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n     *  Object result = method.invoke(set, new Object[]);</pre></code>\n     * </p>\n     *\n     * @param cls  the class to check, not null\n     * @param methodName  the name of the method\n     * @param parameterTypes  the list of parameters\n     * @return the method\n     * @throws NullPointerException if the class is null\n     * @throws SecurityException if a a security violation occured\n     * @throws NoSuchMethodException if the method is not found in the given class\n     *  or if the metothod doen't conform with the requirements\n     */\n    public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[])\n            throws SecurityException, NoSuchMethodException {\n\n        Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n        if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {\n            return declaredMethod;\n        }\n\n        List<Class<?>> candidateClasses = new ArrayList<Class<?>>();\n        candidateClasses.addAll(getAllInterfaces(cls));\n        candidateClasses.addAll(getAllSuperclasses(cls));\n\n        for (Class<?> candidateClass : candidateClasses) {\n            if (!Modifier.isPublic(candidateClass.getModifiers())) {\n                continue;\n            }\n            Method candidateMethod;\n            try {\n                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n            } catch (NoSuchMethodException ex) {\n                continue;\n            }\n            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n                return candidateMethod;\n            }\n        }\n\n        throw new NoSuchMethodException(\"Can't find a public method for \" +\n                methodName + \" \" + ArrayUtils.toString(parameterTypes));\n    }\n\n    // ----------------------------------------------------------------------\n    /**\n     * Converts a class name to a JLS style class name.\n     *\n     * @param className  the class name\n     * @return the converted name\n     */\n    private static String toCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            throw new NullPointerException(\"className must not be null.\");\n        } else if (className.endsWith(\"[]\")) {\n            StringBuffer classNameBuffer = new StringBuffer();\n            while (className.endsWith(\"[]\")) {\n                className = className.substring(0, className.length() - 2);\n                classNameBuffer.append(\"[\");\n            }\n            String abbreviation = abbreviationMap.get(className);\n            if (abbreviation != null) {\n                classNameBuffer.append(abbreviation);\n            } else {\n                classNameBuffer.append(\"L\").append(className).append(\";\");\n            }\n            className = classNameBuffer.toString();\n        }\n        return className;\n    }\n\n    /**\n     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array an <code>Object</code> array\n     * @return a <code>Class</code> array, <code>null</code> if null array input\n     * @since 2.4\n     */\n    public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }\n\n    // Short canonical name\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>\n     *\n     * @param object  the class to get the short name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the canonical name of the object without the package name, or the null value\n     * @since 2.4\n     */\n    public static String getShortCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getShortCanonicalName(object.getClass().getName());\n    }\n\n    /**\n     * <p>Gets the canonical name minus the package name from a <code>Class</code>.</p>\n     *\n     * @param cls  the class to get the short name for.\n     * @return the canonical name without the package name or an empty string\n     * @since 2.4\n     */\n    public static String getShortCanonicalName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getShortCanonicalName(cls.getName());\n    }\n\n    /**\n     * <p>Gets the canonical name minus the package name from a String.</p>\n     *\n     * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>\n     *\n     * @param canonicalName  the class name to get the short name for\n     * @return the canonical name of the class without the package name or an empty string\n     * @since 2.4\n     */\n    public static String getShortCanonicalName(String canonicalName) {\n        return ClassUtils.getShortClassName(getCanonicalName(canonicalName));\n    }\n\n    // Package name\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Gets the package name from the canonical name of an <code>Object</code>.</p>\n     *\n     * @param object  the class to get the package name for, may be null\n     * @param valueIfNull  the value to return if null\n     * @return the package name of the object, or the null value\n     * @since 2.4\n     */\n    public static String getPackageCanonicalName(Object object, String valueIfNull) {\n        if (object == null) {\n            return valueIfNull;\n        }\n        return getPackageCanonicalName(object.getClass().getName());\n    }\n\n    /**\n     * <p>Gets the package name from the canonical name of a <code>Class</code>.</p>\n     *\n     * @param cls  the class to get the package name for, may be <code>null</code>.\n     * @return the package name or an empty string\n     * @since 2.4\n     */\n    public static String getPackageCanonicalName(Class<?> cls) {\n        if (cls == null) {\n            return StringUtils.EMPTY;\n        }\n        return getPackageCanonicalName(cls.getName());\n    }\n\n    /**\n     * <p>Gets the package name from the canonical name. </p>\n     *\n     * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>\n     * <p>If the class is unpackaged, return an empty string.</p>\n     *\n     * @param canonicalName  the canonical name to get the package name for, may be <code>null</code>\n     * @return the package name or an empty string\n     * @since 2.4\n     */\n    public static String getPackageCanonicalName(String canonicalName) {\n        return ClassUtils.getPackageName(getCanonicalName(canonicalName));\n    }\n\n    /**\n     * <p>Converts a given name of class into canonical format.\n     * If name of class is not a name of array class it returns\n     * unchanged name.</p>\n     * <p>Example:\n     * <ul>\n     * <li><code>getCanonicalName(\"[I\") = \"int[]\"</code></li>\n     * <li><code>getCanonicalName(\"[Ljava.lang.String;\") = \"java.lang.String[]\"</code></li>\n     * <li><code>getCanonicalName(\"java.lang.String\") = \"java.lang.String\"</code></li>\n     * </ul>\n     * </p>\n     *\n     * @param className the name of class\n     * @return canonical form of class name\n     * @since 2.4\n     */\n    private static String getCanonicalName(String className) {\n        className = StringUtils.deleteWhitespace(className);\n        if (className == null) {\n            return null;\n        } else {\n            int dim = 0;\n            while (className.startsWith(\"[\")) {\n                dim++;\n                className = className.substring(1);\n            }\n            if (dim < 1) {\n                return className;\n            } else {\n                if (className.startsWith(\"L\")) {\n                    className = className.substring(\n                        1,\n                        className.endsWith(\";\")\n                            ? className.length() - 1\n                            : className.length());\n                } else {\n                    if (className.length() > 0) {\n                        className = reverseAbbreviationMap.get(className.substring(0, 1));\n                    }\n                }\n                StringBuffer canonicalClassNameBuffer = new StringBuffer(className);\n                for (int i = 0; i < dim; i++) {\n                    canonicalClassNameBuffer.append(\"[]\");\n                }\n                return canonicalClassNameBuffer.toString();\n            }\n        }\n    }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"description\": \"The getShortClassName method does not check for null in the case where object is an instance of a primitive type.\",\n         \"lineNumber\": 143,\n         \"columnNumber\": 5\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"description\": \"The getShortClassName method does not check for null in the case where object is an instance of an array.\",\n         \"lineNumber\": 155,\n         \"columnNumber\": 5\n      },\n      {\n         \"type\": \"Potential ClassCastException\",\n         \"description\": \"The getShortClassName method does not check the type of the class before calling getShortClassName(cls).\",\n         \"lineNumber\": 164,\n         \"columnNumber\": 5\n      }\n   ]\n}"}}