{"sample_id": "Lang_21", "model": "qwen-coder-32b", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.time;\n\nimport java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.TimeZone;\n\n/**\n * <p>A suite of utilities surrounding the use of the\n * {@link java.util.Calendar} and {@link java.util.Date} object.</p>\n * \n * <p>DateUtils contains a lot of common methods considering manipulations\n * of Dates or Calendars. Some methods require some extra explanation.\n * The truncate, ceiling and round methods could be considered the Math.floor(),\n * Math.ceil() or Math.round versions for dates\n * This way date-fields will be ignored in bottom-up order.\n * As a complement to these methods we've introduced some fragment-methods.\n * With these methods the Date-fields will be ignored in top-down order.\n * Since a date without a year is not a valid date, you have to decide in what\n * kind of date-field you want your result, for instance milliseconds or days.\n * </p>\n *   \n *   \n *\n * @author Apache Software Foundation\n * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n * @author Janek Bogucki\n * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n * @author Phil Steitz\n * @author Robert Scholte\n * @author Paul Benedict\n * @since 2.0\n * @version $Id$\n */\npublic class DateUtils {\n    \n    /**\n     * The UTC time zone  (often referred to as GMT).\n     */\n    public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\");\n    /**\n     * Number of milliseconds in a standard second.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_SECOND = 1000;\n    /**\n     * Number of milliseconds in a standard minute.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n    /**\n     * Number of milliseconds in a standard hour.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n    /**\n     * Number of milliseconds in a standard day.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n\n    /**\n     * This is half a month, so this represents whether a date is in the top\n     * or bottom half of the month.\n     */\n    public final static int SEMI_MONTH = 1001;\n\n    private static final int[][] fields = {\n            {Calendar.MILLISECOND},\n            {Calendar.SECOND},\n            {Calendar.MINUTE},\n            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM \n                /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n            },\n            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n            {Calendar.YEAR},\n            {Calendar.ERA}};\n\n    /**\n     * A week range, starting on Sunday.\n     */\n    public final static int RANGE_WEEK_SUNDAY = 1;\n\n    /**\n     * A week range, starting on Monday.\n     */\n    public final static int RANGE_WEEK_MONDAY = 2;\n\n    /**\n     * A week range, starting on the day focused.\n     */\n    public final static int RANGE_WEEK_RELATIVE = 3;\n\n    /**\n     * A week range, centered around the day focused.\n     */\n    public final static int RANGE_WEEK_CENTER = 4;\n\n    /**\n     * A month range, the week starting on Sunday.\n     */\n    public final static int RANGE_MONTH_SUNDAY = 5;\n\n    /**\n     * A month range, the week starting on Monday.\n     */\n    public final static int RANGE_MONTH_MONDAY = 6;\n    \n    /**\n     * Constant marker for truncating \n     * @since 3.0\n     */\n    public final static int MODIFY_TRUNCATE = 0;\n\n    /**\n     * Constant marker for rounding\n     * @since 3.0\n     */\n    public final static int MODIFY_ROUND = 1;\n    \n    /**\n     * Constant marker for ceiling\n     * @since 3.0\n     */\n    public final static int MODIFY_CEILING= 2;\n    \n\n    /**\n     * <p><code>DateUtils</code> instances should NOT be constructed in\n     * standard programming. Instead, the class should be used as\n     * <code>DateUtils.parse(str);</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean\n     * instance to operate.</p>\n     */\n    public DateUtils() {\n        super();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if two date objects are on the same day ignoring time.</p>\n     *\n     * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n     * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n     * </p>\n     * \n     * @param date1  the first date, not altered, not null\n     * @param date2  the second date, not altered, not null\n     * @return true if they represent the same day\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameDay(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar cal1 = Calendar.getInstance();\n        cal1.setTime(date1);\n        Calendar cal2 = Calendar.getInstance();\n        cal2.setTime(date2);\n        return isSameDay(cal1, cal2);\n    }\n\n    /**\n     * <p>Checks if two calendar objects are on the same day ignoring time.</p>\n     *\n     * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n     * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n     * </p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same day\n     * @throws IllegalArgumentException if either calendar is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if two date objects represent the same instant in time.</p>\n     *\n     * <p>This method compares the long millisecond time of the two objects.</p>\n     * \n     * @param date1  the first date, not altered, not null\n     * @param date2  the second date, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameInstant(Date date1, Date date2) {\n        if (date1 == null || date2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return date1.getTime() == date2.getTime();\n    }\n\n    /**\n     * <p>Checks if two calendar objects represent the same instant in time.</p>\n     *\n     * <p>This method compares the long millisecond time of the two objects.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return cal1.getTime().getTime() == cal2.getTime().getTime();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if two calendar objects represent the same local time.</p>\n     *\n     * <p>This method compares the values of the fields of the two objects.\n     * In addition, both calendars must be the same of the same type.</p>\n     * \n     * @param cal1  the first calendar, not altered, not null\n     * @param cal2  the second calendar, not altered, not null\n     * @return true if they represent the same millisecond instant\n     * @throws IllegalArgumentException if either date is <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n        if (cal1 == null || cal2 == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                cal1.getClass() == cal2.getClass());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n     * \n     * <p>The parse will try each parse pattern in turn.\n     * A parse is only deemed successful if it parses the whole of the input string.\n     * If no parse patterns match, a ParseException is thrown.</p>\n     * The parser will be lenient toward the parsed date.\n     * \n     * @param str  the date to parse, not null\n     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n     * @return the parsed date\n     * @throws IllegalArgumentException if the date string or pattern array is null\n     * @throws ParseException if none of the date patterns were suitable (or there were none)\n     */\n    public static Date parseDate(String str, String... parsePatterns) throws ParseException {\n        return parseDateWithLeniency(str, parsePatterns, true);\n    }\n    \n  //-----------------------------------------------------------------------\n    /**\n     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n     * \n     * <p>The parse will try each parse pattern in turn.\n     * A parse is only deemed successful if it parses the whole of the input string.\n     * If no parse patterns match, a ParseException is thrown.</p>\n     * The parser parses strictly - it does not allow for dates such as \"February 942, 1996\". \n     * \n     * @param str  the date to parse, not null\n     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n     * @return the parsed date\n     * @throws IllegalArgumentException if the date string or pattern array is null\n     * @throws ParseException if none of the date patterns were suitable\n     * @since 2.5\n     */\n    public static Date parseDateStrictly(String str, String... parsePatterns) throws ParseException {\n        return parseDateWithLeniency(str, parsePatterns, false);\n    }\n\n    /**\n     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n     * \n     * <p>The parse will try each parse pattern in turn.\n     * A parse is only deemed successful if it parses the whole of the input string.\n     * If no parse patterns match, a ParseException is thrown.</p>\n     * \n     * @param str  the date to parse, not null\n     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n     * @param lenient Specify whether or not date/time parsing is to be lenient.\n     * @return the parsed date\n     * @throws IllegalArgumentException if the date string or pattern array is null\n     * @throws ParseException if none of the date patterns were suitable\n     * @see java.util.Calender#isLenient()\n     */\n    private static Date parseDateWithLeniency(String str, String[] parsePatterns,\n            boolean lenient) throws ParseException {\n        if (str == null || parsePatterns == null) {\n            throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n        }\n        \n        SimpleDateFormat parser = new SimpleDateFormat();\n        parser.setLenient(lenient);\n        ParsePosition pos = new ParsePosition(0);\n        for (int i = 0; i < parsePatterns.length; i++) {\n\n            String pattern = parsePatterns[i];\n\n            // LANG-530 - need to make sure 'ZZ' output doesn't get passed to SimpleDateFormat\n            if (parsePatterns[i].endsWith(\"ZZ\")) {\n                pattern = pattern.substring(0, pattern.length() - 1);\n            }\n            \n            parser.applyPattern(pattern);\n            pos.setIndex(0);\n\n            String str2 = str;\n            // LANG-530 - need to make sure 'ZZ' output doesn't hit SimpleDateFormat as it will ParseException\n            if (parsePatterns[i].endsWith(\"ZZ\")) {\n                str2 = str.replaceAll(\"([-+][0-9][0-9]):([0-9][0-9])$\", \"$1$2\"); \n            }\n\n            Date date = parser.parse(str2, pos);\n            if (date != null && pos.getIndex() == str2.length()) {\n                return date;\n            }\n        }\n        throw new ParseException(\"Unable to parse the date: \" + str, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of years to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addYears(Date date, int amount) {\n        return add(date, Calendar.YEAR, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of months to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addMonths(Date date, int amount) {\n        return add(date, Calendar.MONTH, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of weeks to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addWeeks(Date date, int amount) {\n        return add(date, Calendar.WEEK_OF_YEAR, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of days to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addDays(Date date, int amount) {\n        return add(date, Calendar.DAY_OF_MONTH, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of hours to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addHours(Date date, int amount) {\n        return add(date, Calendar.HOUR_OF_DAY, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of minutes to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addMinutes(Date date, int amount) {\n        return add(date, Calendar.MINUTE, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of seconds to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addSeconds(Date date, int amount) {\n        return add(date, Calendar.SECOND, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a number of milliseconds to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    public static Date addMilliseconds(Date date, int amount) {\n        return add(date, Calendar.MILLISECOND, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param calendarField  the calendar field to add to\n     * @param amount  the amount to add, may be negative\n     * @return the new date object with the amount added\n     * @throws IllegalArgumentException if the date is null\n     */\n    private static Date add(Date date, int calendarField, int amount) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar c = Calendar.getInstance();\n        c.setTime(date);\n        c.add(calendarField, amount);\n        return c.getTime();\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Sets the years field to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount the amount to set\n     * @return a new Date object set with the specified value\n     * @throws IllegalArgumentException if the date is null\n     * @since 2.4\n     */\n    public static Date setYears(Date date, int amount) {\n        return set(date, Calendar.YEAR, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the months field to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount the amount to set\n     * @return a new Date object set with the specified value\n     * @throws IllegalArgumentException if the date is null\n     * @since 2.4\n     */\n    public static Date setMonths(Date date, int amount) {\n        return set(date, Calendar.MONTH, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the day of month field to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount the amount to set\n     * @return a new Date object set with the specified value\n     * @throws IllegalArgumentException if the date is null\n     * @since 2.4\n     */\n    public static Date setDays(Date date, int amount) {\n        return set(date, Calendar.DAY_OF_MONTH, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the hours field to a date returning a new object.  Hours range \n     * from  0-23.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount the amount to set\n     * @return a new Date object set with the specified value\n     * @throws IllegalArgumentException if the date is null\n     * @since 2.4\n     */\n    public static Date setHours(Date date, int amount) {\n        return set(date, Calendar.HOUR_OF_DAY, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the minute field to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount the amount to set\n     * @return a new Date object set with the specified value\n     * @throws IllegalArgumentException if the date is null\n     * @since 2.4\n     */\n    public static Date setMinutes(Date date, int amount) {\n        return set(date, Calendar.MINUTE, amount);\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Sets the seconds field to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount the amount to set\n     * @return a new Date object set with the specified value\n     * @throws IllegalArgumentException if the date is null\n     * @since 2.4\n     */\n    public static Date setSeconds(Date date, int amount) {\n        return set(date, Calendar.SECOND, amount);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Sets the miliseconds field to a date returning a new object.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param amount the amount to set\n     * @return a new Date object set with the specified value\n     * @throws IllegalArgumentException if the date is null\n     * @since 2.4\n     */\n    public static Date setMilliseconds(Date date, int amount) {\n        return set(date, Calendar.MILLISECOND, amount);\n    } \n    \n    //-----------------------------------------------------------------------\n    /**\n     * Sets the specified field to a date returning a new object.  \n     * This does not use a lenient calendar.\n     * The original date object is unchanged.\n     *\n     * @param date  the date, not null\n     * @param calendarField  the calendar field to set the amount to\n     * @param amount the amount to set\n     * @return a new Date object set with the specified value\n     * @throws IllegalArgumentException if the date is null\n     * @since 2.4\n     */\n    private static Date set(Date date, int calendarField, int amount) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        // getInstance() returns a new object, so this method is thread safe.\n        Calendar c = Calendar.getInstance();\n        c.setLenient(false);\n        c.setTime(date);\n        c.set(calendarField, amount);\n        return c.getTime();\n    }   \n\n    //-----------------------------------------------------------------------\n    /**\n     * Convert a Date into a Calendar object. \n     * \n     * @param date the date to convert to a Calendar\n     * @return the created Calendar\n     * @throws NullPointerException if null is passed in\n     * @since 3.0\n     */\n    public static Calendar toCalendar(Date date) {\n        Calendar c = Calendar.getInstance();\n        c.setTime(date);\n        return c;\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * <p>Round this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if this was passed with HOUR, it would return\n     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n     * would return 1 April 2002 0:00:00.000.</p>\n     * \n     * <p>For a date in a timezone that handles the change to daylight\n     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n     * date that crosses this time would produce the following values:\n     * <ul>\n     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n     * </ul>\n     * </p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Date round(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, MODIFY_ROUND);\n        return gval.getTime();\n    }\n\n    /**\n     * <p>Round this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if this was passed with HOUR, it would return\n     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n     * would return 1 April 2002 0:00:00.000.</p>\n     * \n     * <p>For a date in a timezone that handles the change to daylight\n     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n     * date that crosses this time would produce the following values:\n     * <ul>\n     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n     * </ul>\n     * </p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date (a different object)\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Calendar round(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar rounded = (Calendar) date.clone();\n        modify(rounded, field, MODIFY_ROUND);\n        return rounded;\n    }\n\n    /**\n     * <p>Round this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if this was passed with HOUR, it would return\n     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n     * would return 1 April 2002 0:00:00.000.</p>\n     * \n     * <p>For a date in a timezone that handles the change to daylight\n     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n     * date that crosses this time would produce the following values:\n     * <ul>\n     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n     * </ul>\n     * </p>\n     * \n     * @param date  the date to work with, either Date or Calendar\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ClassCastException if the object type is not a <code>Date</code>\n     *  or <code>Calendar</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Date round(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return round((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return round((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not round \" + date);\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Truncate this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Date truncate(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, MODIFY_TRUNCATE);\n        return gval.getTime();\n    }\n\n    /**\n     * <p>Truncate this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date (a different object)\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Calendar truncate(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar truncated = (Calendar) date.clone();\n        modify(truncated, field, MODIFY_TRUNCATE);\n        return truncated;\n    }\n\n    /**\n     * <p>Truncate this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with, either <code>Date</code>\n     *  or <code>Calendar</code>\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date\n     *  is <code>null</code>\n     * @throws ClassCastException if the object type is not a\n     *  <code>Date</code> or <code>Calendar</code>\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    public static Date truncate(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return truncate((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return truncate((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not truncate \" + date);\n        }\n    }\n    \n  //-----------------------------------------------------------------------\n    /**\n     * <p>Ceil this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 14:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Apr 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     * @since 2.5\n     */\n    public static Date ceiling(Date date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(date);\n        modify(gval, field, MODIFY_CEILING);\n        return gval.getTime();\n    }\n\n    /**\n     * <p>Ceil this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date (a different object)\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     * @since 2.5\n     */\n    public static Calendar ceiling(Calendar date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar ceiled = (Calendar) date.clone();\n        modify(ceiled, field, MODIFY_CEILING);\n        return ceiled;\n    }\n\n    /**\n     * <p>Ceil this date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the datetime of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     * \n     * @param date  the date to work with, either <code>Date</code>\n     *  or <code>Calendar</code>\n     * @param field  the field from <code>Calendar</code>\n     *  or <code>SEMI_MONTH</code>\n     * @return the rounded date\n     * @throws IllegalArgumentException if the date\n     *  is <code>null</code>\n     * @throws ClassCastException if the object type is not a\n     *  <code>Date</code> or <code>Calendar</code>\n     * @throws ArithmeticException if the year is over 280 million\n     * @since 2.5\n     */\n    public static Date ceiling(Object date, int field) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date instanceof Date) {\n            return ceiling((Date) date, field);\n        } else if (date instanceof Calendar) {\n            return ceiling((Calendar) date, field).getTime();\n        } else {\n            throw new ClassCastException(\"Could not find ceiling of for type: \" + date.getClass());\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param modType  type to truncate, round or ceiling\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, int modType) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n            time = time - millisecs;\n        }\n        if (field == Calendar.SECOND) {\n            done = true;\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        }\n        if (field == Calendar.MINUTE) {\n            done = true;\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- START ---------------\n                        } else if (field == Calendar.AM_PM) {\n                            // This is a special case\n                            // If the time is 0, we round up to 12, otherwise\n                            //  we subtract 12 hours and add 1 day\n                            if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n                                val.add(Calendar.HOUR_OF_DAY, 12);\n                            } else {\n                                val.add(Calendar.HOUR_OF_DAY, -12);\n                                val.add(Calendar.DATE, 1);\n                            }\n// ----------------- Fix for LANG-440 ---------------------- END ---------------\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return;\n                }\n            }\n            //We have various fields that are not easy roundings\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset >= 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            //We need to remove this field\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>This constructs an <code>Iterator</code> over each day in a date\n     * range defined by a focus date and range style.</p>\n     *\n     * <p>For instance, passing Thursday, July 4, 2002 and a\n     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n     * 2002, returning a Calendar instance for each intermediate day.</p>\n     *\n     * <p>This method provides an iterator that returns Calendar objects.\n     * The days are progressed using {@link Calendar#add(int, int)}.</p>\n     *\n     * @param focus  the date to work with, not null\n     * @param rangeStyle  the style constant to use. Must be one of\n     * {@link DateUtils#RANGE_MONTH_SUNDAY}, \n     * {@link DateUtils#RANGE_MONTH_MONDAY},\n     * {@link DateUtils#RANGE_WEEK_SUNDAY},\n     * {@link DateUtils#RANGE_WEEK_MONDAY},\n     * {@link DateUtils#RANGE_WEEK_RELATIVE},\n     * {@link DateUtils#RANGE_WEEK_CENTER}\n     * @return the date iterator, which always returns Calendar instances\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws IllegalArgumentException if the rangeStyle is invalid\n     */\n    public static Iterator<Calendar> iterator(Date focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(focus);\n        return iterator(gval, rangeStyle);\n    }\n\n    /**\n     * <p>This constructs an <code>Iterator</code> over each day in a date\n     * range defined by a focus date and range style.</p>\n     *\n     * <p>For instance, passing Thursday, July 4, 2002 and a\n     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n     * 2002, returning a Calendar instance for each intermediate day.</p>\n     *\n     * <p>This method provides an iterator that returns Calendar objects.\n     * The days are progressed using {@link Calendar#add(int, int)}.</p>\n     *\n     * @param focus  the date to work with\n     * @param rangeStyle  the style constant to use. Must be one of\n     * {@link DateUtils#RANGE_MONTH_SUNDAY}, \n     * {@link DateUtils#RANGE_MONTH_MONDAY},\n     * {@link DateUtils#RANGE_WEEK_SUNDAY},\n     * {@link DateUtils#RANGE_WEEK_MONDAY},\n     * {@link DateUtils#RANGE_WEEK_RELATIVE},\n     * {@link DateUtils#RANGE_WEEK_CENTER}\n     * @return the date iterator\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws IllegalArgumentException if the rangeStyle is invalid\n     */\n    public static Iterator<Calendar> iterator(Calendar focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar start = null;\n        Calendar end = null;\n        int startCutoff = Calendar.SUNDAY;\n        int endCutoff = Calendar.SATURDAY;\n        switch (rangeStyle) {\n            case RANGE_MONTH_SUNDAY:\n            case RANGE_MONTH_MONDAY:\n                //Set start to the first of the month\n                start = truncate(focus, Calendar.MONTH);\n                //Set end to the last of the month\n                end = (Calendar) start.clone();\n                end.add(Calendar.MONTH, 1);\n                end.add(Calendar.DATE, -1);\n                //Loop start back to the previous sunday or monday\n                if (rangeStyle == RANGE_MONTH_MONDAY) {\n                    startCutoff = Calendar.MONDAY;\n                    endCutoff = Calendar.SUNDAY;\n                }\n                break;\n            case RANGE_WEEK_SUNDAY:\n            case RANGE_WEEK_MONDAY:\n            case RANGE_WEEK_RELATIVE:\n            case RANGE_WEEK_CENTER:\n                //Set start and end to the current date\n                start = truncate(focus, Calendar.DATE);\n                end = truncate(focus, Calendar.DATE);\n                switch (rangeStyle) {\n                    case RANGE_WEEK_SUNDAY:\n                        //already set by default\n                        break;\n                    case RANGE_WEEK_MONDAY:\n                        startCutoff = Calendar.MONDAY;\n                        endCutoff = Calendar.SUNDAY;\n                        break;\n                    case RANGE_WEEK_RELATIVE:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n                        endCutoff = startCutoff - 1;\n                        break;\n                    case RANGE_WEEK_CENTER:\n                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n                        break;\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\");\n        }\n        if (startCutoff < Calendar.SUNDAY) {\n            startCutoff += 7;\n        }\n        if (startCutoff > Calendar.SATURDAY) {\n            startCutoff -= 7;\n        }\n        if (endCutoff < Calendar.SUNDAY) {\n            endCutoff += 7;\n        }\n        if (endCutoff > Calendar.SATURDAY) {\n            endCutoff -= 7;\n        }\n        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n            start.add(Calendar.DATE, -1);\n        }\n        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n            end.add(Calendar.DATE, 1);\n        }\n        return new DateIterator(start, end);\n    }\n\n    /**\n     * <p>This constructs an <code>Iterator</code> over each day in a date\n     * range defined by a focus date and range style.</p>\n     *\n     * <p>For instance, passing Thursday, July 4, 2002 and a\n     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n     * 2002, returning a Calendar instance for each intermediate day.</p>\n     *\n     * @param focus  the date to work with, either\n     *  <code>Date</code> or <code>Calendar</code>\n     * @param rangeStyle  the style constant to use. Must be one of the range\n     * styles listed for the {@link #iterator(Calendar, int)} method.\n     * @return the date iterator\n     * @throws IllegalArgumentException if the date\n     *  is <code>null</code>\n     * @throws ClassCastException if the object type is\n     *  not a <code>Date</code> or <code>Calendar</code>\n     */\n    public static Iterator<?> iterator(Object focus, int rangeStyle) {\n        if (focus == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (focus instanceof Date) {\n            return iterator((Date) focus, rangeStyle);\n        } else if (focus instanceof Calendar) {\n            return iterator((Calendar) focus, rangeStyle);\n        } else {\n            throw new ClassCastException(\"Could not iterate based on \" + focus);\n        }\n    }\n    \n    /**\n     * <p>Returns the number of milliseconds within the \n     * fragment. All datefields greater than the fragment will be ignored.</p>\n     * \n     * <p>Asking the milliseconds of any date will only return the number of milliseconds\n     * of the current second (resulting in a number between 0 and 999). This \n     * method will retrieve the number of milliseconds for any fragment. \n     * For example, if you want to calculate the number of milliseconds past today, \n     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n     * be all milliseconds of the past hour(s), minutes(s) and second(s).</p>\n     * \n     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n     * A fragment less than or equal to a SECOND field will return 0.</p> \n     * \n     * <p>\n     * <ul>\n     *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538 (10*1000 + 538)</li>\n     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n     *   (a millisecond cannot be split in milliseconds)</li>\n     * </ul>\n     * </p>\n     * \n     * @param date the date to work with, not null\n     * @param fragment the Calendar field part of date to calculate \n     * @return number of milliseconds within the fragment of date\n     * @throws IllegalArgumentException if the date is <code>null</code> or\n     * fragment is not supported\n     * @since 2.4\n     */\n    public static long getFragmentInMilliseconds(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.MILLISECOND);    \n    }\n    \n    /**\n     * <p>Returns the number of seconds within the \n     * fragment. All datefields greater than the fragment will be ignored.</p> \n     * \n     * <p>Asking the seconds of any date will only return the number of seconds\n     * of the current minute (resulting in a number between 0 and 59). This \n     * method will retrieve the number of seconds for any fragment. \n     * For example, if you want to calculate the number of seconds past today, \n     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n     * be all seconds of the past hour(s) and minutes(s).</p> \n     * \n     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n     * A fragment less than or equal to a SECOND field will return 0.</p> \n     * \n     * <p>\n     * <ul>\n     *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10\n     *   (equivalent to deprecated date.getSeconds())</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10\n     *   (equivalent to deprecated date.getSeconds())</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110\n     *   (7*3600 + 15*60 + 10)</li>\n     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n     *   (a millisecond cannot be split in seconds)</li>\n     * </ul>\n     * </p>\n     * \n     * @param date the date to work with, not null\n     * @param fragment the Calendar field part of date to calculate \n     * @return number of seconds within the fragment of date\n     * @throws IllegalArgumentException if the date is <code>null</code> or\n     * fragment is not supported\n     * @since 2.4\n     */\n    public static long getFragmentInSeconds(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.SECOND);\n    }\n    \n    /**\n     * <p>Returns the number of minutes within the \n     * fragment. All datefields greater than the fragment will be ignored.</p> \n     * \n     * <p>Asking the minutes of any date will only return the number of minutes\n     * of the current hour (resulting in a number between 0 and 59). This \n     * method will retrieve the number of minutes for any fragment. \n     * For example, if you want to calculate the number of minutes past this month, \n     * your fragment is Calendar.MONTH. The result will be all minutes of the \n     * past day(s) and hour(s).</p> \n     * \n     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n     * A fragment less than or equal to a MINUTE field will return 0.</p> \n     * \n     * <p>\n     * <ul>\n     *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15\n     *   (equivalent to deprecated date.getMinutes())</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15\n     *   (equivalent to deprecated date.getMinutes())</li>\n     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>\n     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n     *   (a millisecond cannot be split in minutes)</li>\n     * </ul>\n     * </p>\n     * \n     * @param date the date to work with, not null\n     * @param fragment the Calendar field part of date to calculate \n     * @return number of minutes within the fragment of date\n     * @throws IllegalArgumentException if the date is <code>null</code> or \n     * fragment is not supported\n     * @since 2.4\n     */\n    public static long getFragmentInMinutes(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.MINUTE);\n    }\n    \n    /**\n     * <p>Returns the number of hours within the \n     * fragment. All datefields greater than the fragment will be ignored.</p> \n     * \n     * <p>Asking the hours of any date will only return the number of hours\n     * of the current day (resulting in a number between 0 and 23). This \n     * method will retrieve the number of hours for any fragment. \n     * For example, if you want to calculate the number of hours past this month, \n     * your fragment is Calendar.MONTH. The result will be all hours of the \n     * past day(s).</p> \n     * \n     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n     * A fragment less than or equal to a HOUR field will return 0.</p> \n     * \n     * <p>\n     * <ul>\n     *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7\n     *   (equivalent to deprecated date.getHours())</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7\n     *   (equivalent to deprecated date.getHours())</li>\n     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>\n     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n     *   (a millisecond cannot be split in hours)</li>\n     * </ul>\n     * </p>\n     * \n     * @param date the date to work with, not null\n     * @param fragment the Calendar field part of date to calculate \n     * @return number of hours within the fragment of date\n     * @throws IllegalArgumentException if the date is <code>null</code> or \n     * fragment is not supported\n     * @since 2.4\n     */\n    public static long getFragmentInHours(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.HOUR_OF_DAY);\n    }\n    \n    /**\n     * <p>Returns the number of days within the \n     * fragment. All datefields greater than the fragment will be ignored.</p> \n     * \n     * <p>Asking the days of any date will only return the number of days\n     * of the current month (resulting in a number between 1 and 31). This \n     * method will retrieve the number of days for any fragment. \n     * For example, if you want to calculate the number of days past this year, \n     * your fragment is Calendar.YEAR. The result will be all days of the \n     * past month(s).</p> \n     * \n     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n     * A fragment less than or equal to a DAY field will return 0.</p> \n     *  \n     * <p>\n     * <ul>\n     *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28\n     *   (equivalent to deprecated date.getDay())</li>\n     *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28\n     *   (equivalent to deprecated date.getDay())</li>\n     *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28</li>\n     *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59</li>\n     *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0\n     *   (a millisecond cannot be split in days)</li>\n     * </ul>\n     * </p>\n     * \n     * @param date the date to work with, not null\n     * @param fragment the Calendar field part of date to calculate \n     * @return number of days  within the fragment of date\n     * @throws IllegalArgumentException if the date is <code>null</code> or \n     * fragment is not supported\n     * @since 2.4\n     */\n    public static long getFragmentInDays(Date date, int fragment) {\n        return getFragment(date, fragment, Calendar.DAY_OF_YEAR);\n    }\n\n    /**\n     * <p>Returns the number of milliseconds within the \n     * fragment. All datefields greater than the fragment will be ignored.</p> \n     * \n     * <p>Asking the milliseconds of any date will only return the number of milliseconds\n     * of the current second (resulting in a number between 0 and 999). This \n     * method will retrieve the number of milliseconds for any fragment. \n     * For example, if you want to calculate the number of seconds past today, \n     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n     * be all seconds of the past hour(s), minutes(s) and second(s).</p> \n     * \n     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n     * A fragment less than or equal to a MILLISECOND field will return 0.</p> \n     * \n     * <p>\n     * <ul>\n     *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538\n     *   (equivalent to calendar.get(Calendar.MILLISECOND))</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538\n     *   (equivalent to calendar.get(Calendar.MILLISECOND))</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538\n     *   (10*1000 + 538)</li>\n     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n     *   (a millisecond cannot be split in milliseconds)</li>\n     * </ul>\n     * </p>\n     * \n     * @param calendar the calendar to work with, not null\n     * @param fragment the Calendar field part of calendar to calculate \n     * @return number of milliseconds within the fragment of date\n     * @throws IllegalArgumentException if the date is <code>null</code> or \n     * fragment is not supported\n     * @since 2.4\n     */\n  public static long getFragmentInMilliseconds(Calendar calendar, int fragment) {\n    return getFragment(calendar, fragment, Calendar.MILLISECOND);\n  }\n    /**\n     * <p>Returns the number of seconds within the \n     * fragment. All datefields greater than the fragment will be ignored.</p> \n     * \n     * <p>Asking the seconds of any date will only return the number of seconds\n     * of the current minute (resulting in a number between 0 and 59). This \n     * method will retrieve the number of seconds for any fragment. \n     * For example, if you want to calculate the number of seconds past today, \n     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n     * be all seconds of the past hour(s) and minutes(s).</p> \n     * \n     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n     * A fragment less than or equal to a SECOND field will return 0.</p> \n     * \n     * <p>\n     * <ul>\n     *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10\n     *   (equivalent to calendar.get(Calendar.SECOND))</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10\n     *   (equivalent to calendar.get(Calendar.SECOND))</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110\n     *   (7*3600 + 15*60 + 10)</li>\n     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n     *   (a millisecond cannot be split in seconds)</li>\n     * </ul>\n     * </p>\n     * \n     * @param calendar the calendar to work with, not null\n     * @param fragment the Calendar field part of calendar to calculate \n     * @return number of seconds within the fragment of date\n     * @throws IllegalArgumentException if the date is <code>null</code> or \n     * fragment is not supported\n     * @since 2.4\n     */\n    public static long getFragmentInSeconds(Calendar calendar, int fragment) {\n        return getFragment(calendar, fragment, Calendar.SECOND);\n    }\n    \n    /**\n     * <p>Returns the number of minutes within the \n     * fragment. All datefields greater than the fragment will be ignored.</p> \n     * \n     * <p>Asking the minutes of any date will only return the number of minutes\n     * of the current hour (resulting in a number between 0 and 59). This \n     * method will retrieve the number of minutes for any fragment. \n     * For example, if you want to calculate the number of minutes past this month, \n     * your fragment is Calendar.MONTH. The result will be all minutes of the \n     * past day(s) and hour(s).</p> \n     * \n     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n     * A fragment less than or equal to a MINUTE field will return 0.</p> \n     * \n     * <p>\n     * <ul>\n     *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15\n     *   (equivalent to calendar.get(Calendar.MINUTES))</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15\n     *   (equivalent to calendar.get(Calendar.MINUTES))</li>\n     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>\n     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n     *   (a millisecond cannot be split in minutes)</li>\n     * </ul>\n     * </p>\n     * \n     * @param calendar the calendar to work with, not null\n     * @param fragment the Calendar field part of calendar to calculate \n     * @return number of minutes within the fragment of date\n     * @throws IllegalArgumentException if the date is <code>null</code> or \n     * fragment is not supported\n     * @since 2.4\n     */\n    public static long getFragmentInMinutes(Calendar calendar, int fragment) {\n        return getFragment(calendar, fragment, Calendar.MINUTE);\n    }\n    \n    /**\n     * <p>Returns the number of hours within the \n     * fragment. All datefields greater than the fragment will be ignored.</p> \n     * \n     * <p>Asking the hours of any date will only return the number of hours\n     * of the current day (resulting in a number between 0 and 23). This \n     * method will retrieve the number of hours for any fragment. \n     * For example, if you want to calculate the number of hours past this month, \n     * your fragment is Calendar.MONTH. The result will be all hours of the \n     * past day(s).</p> \n     * \n     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n     * A fragment less than or equal to a HOUR field will return 0.</p> \n     *  \n     * <p>\n     * <ul>\n     *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7\n     *   (equivalent to calendar.get(Calendar.HOUR_OF_DAY))</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7\n     *   (equivalent to calendar.get(Calendar.HOUR_OF_DAY))</li>\n     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>\n     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>\n     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n     *   (a millisecond cannot be split in hours)</li>\n     * </ul>\n     * </p>\n     *  \n     * @param calendar the calendar to work with, not null\n     * @param fragment the Calendar field part of calendar to calculate \n     * @return number of hours within the fragment of date\n     * @throws IllegalArgumentException if the date is <code>null</code> or \n     * fragment is not supported\n     * @since 2.4\n     */\n    public static long getFragmentInHours(Calendar calendar, int fragment) {\n        return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);\n    }\n    \n    /**\n     * <p>Returns the number of days within the \n     * fragment. All datefields greater than the fragment will be ignored.</p> \n     * \n     * <p>Asking the days of any date will only return the number of days\n     * of the current month (resulting in a number between 1 and 31). This \n     * method will retrieve the number of days for any fragment. \n     * For example, if you want to calculate the number of days past this year, \n     * your fragment is Calendar.YEAR. The result will be all days of the \n     * past month(s).</p> \n     * \n     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n     * A fragment less than or equal to a DAY field will return 0.</p> \n     * \n     * <p>\n     * <ul>\n     *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28\n     *   (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>\n     *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28\n     *   (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>\n     *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28\n     *   (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>\n     *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59\n     *   (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>\n     *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0\n     *   (a millisecond cannot be split in days)</li>\n     * </ul>\n     * </p>\n     * \n     * @param calendar the calendar to work with, not null\n     * @param fragment the Calendar field part of calendar to calculate \n     * @return number of days within the fragment of date\n     * @throws IllegalArgumentException if the date is <code>null</code> or \n     * fragment is not supported\n     * @since 2.4\n     */\n    public static long getFragmentInDays(Calendar calendar, int fragment) {\n        return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);\n    }\n    \n    /**\n     * Date-version for fragment-calculation in any unit\n     * \n     * @param date the date to work with, not null\n     * @param fragment the Calendar field part of date to calculate \n     * @param unit Calendar field defining the unit\n     * @return number of units within the fragment of the date\n     * @throws IllegalArgumentException if the date is <code>null</code> or \n     * fragment is not supported\n     * @since 2.4\n     */\n    private static long getFragment(Date date, int fragment, int unit) {\n        if(date == null) {\n            throw  new IllegalArgumentException(\"The date must not be null\");\n        }\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        return getFragment(calendar, fragment, unit);\n    }\n\n    /**\n     * Calendar-version for fragment-calculation in any unit\n     * \n     * @param calendar the calendar to work with, not null\n     * @param fragment the Calendar field part of calendar to calculate \n     * @param unit Calendar field defining the unit\n     * @return number of units within the fragment of the calendar\n     * @throws IllegalArgumentException if the date is <code>null</code> or \n     * fragment is not supported\n     * @since 2.4\n     */\n    private static long getFragment(Calendar calendar, int fragment, int unit) {\n        if(calendar == null) {\n            throw  new IllegalArgumentException(\"The date must not be null\"); \n        }\n        long millisPerUnit = getMillisPerUnit(unit);\n        long result = 0;\n        \n        // Fragments bigger than a day require a breakdown to days\n        switch (fragment) {\n            case Calendar.YEAR:\n                result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;\n                break;\n            case Calendar.MONTH:\n                result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;\n                break;\n        }\n\n        switch (fragment) {\n            // Number of days already calculated for these cases\n            case Calendar.YEAR:\n            case Calendar.MONTH:\n            \n            // The rest of the valid cases\n            case Calendar.DAY_OF_YEAR:\n            case Calendar.DATE:\n                result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;\n                //$FALL-THROUGH$\n            case Calendar.HOUR_OF_DAY:\n                result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;\n                //$FALL-THROUGH$\n            case Calendar.MINUTE:\n                result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;\n                //$FALL-THROUGH$\n            case Calendar.SECOND:\n                result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;\n                break;\n            case Calendar.MILLISECOND: break;//never useful\n                default: throw new IllegalArgumentException(\"The fragment \" + fragment + \" is not supported\");\n        }\n        return result;\n    }\n    \n    /**\n     * Determines if two calendars are equal up to no more than the specified \n     * most significant field.\n     * \n     * @param cal1 the first calendar, not <code>null</code>\n     * @param cal2 the second calendar, not <code>null</code>\n     * @param field the field from <code>Calendar</code>\n     * @return <code>true</code> if equal; otherwise <code>false</code>\n     * @throws IllegalArgumentException if any argument is <code>null</code>\n     * @see #truncate(Calendar, int)\n     * @see #truncatedEquals(Date, Date, int)\n     * @since 3.0\n     */\n    public static boolean truncatedEquals(Calendar cal1, Calendar cal2, int field) {\n        return truncatedCompareTo(cal1, cal2, field) == 0;\n    }\n\n    /**\n     * Determines if two dates are equal up to no more than the specified \n     * most significant field.\n     * \n     * @param date1 the first date, not <code>null</code>\n     * @param date2 the second date, not <code>null</code>\n     * @param field the field from <code>Calendar</code>\n     * @return <code>true</code> if equal; otherwise <code>false</code>\n     * @throws IllegalArgumentException if any argument is <code>null</code>\n     * @see #truncate(Date, int)\n     * @see #truncatedEquals(Calendar, Calendar, int)\n     * @since 3.0\n     */\n    public static boolean truncatedEquals(Date date1, Date date2, int field) {\n        return truncatedCompareTo(date1, date2, field) == 0;\n    }\n\n    /**\n     * Determines how two calendars compare up to no more than the specified \n     * most significant field.\n     * \n     * @param cal1 the first calendar, not <code>null</code>\n     * @param cal2 the second calendar, not <code>null</code>\n     * @param field the field from <code>Calendar</code>\n     * @return a negative integer, zero, or a positive integer as the first \n     * calendar is less than, equal to, or greater than the second.\n     * @throws IllegalArgumentException if any argument is <code>null</code>\n     * @see #truncate(Calendar, int)\n     * @see #truncatedCompareTo(Date, Date, int)\n     * @since 3.0\n     */\n    public static int truncatedCompareTo(Calendar cal1, Calendar cal2, int field) {\n        Calendar truncatedCal1 = truncate(cal1, field);\n        Calendar truncatedCal2 = truncate(cal2, field);\n        return truncatedCal1.compareTo(truncatedCal2);\n    }\n\n    /**\n     * Determines how two dates compare up to no more than the specified \n     * most significant field.\n     * \n     * @param date1 the first date, not <code>null</code>\n     * @param date2 the second date, not <code>null</code>\n     * @param field the field from <code>Calendar</code>\n     * @return a negative integer, zero, or a positive integer as the first \n     * date is less than, equal to, or greater than the second.\n     * @throws IllegalArgumentException if any argument is <code>null</code>\n     * @see #truncate(Calendar, int)\n     * @see #truncatedCompareTo(Date, Date, int)\n     * @since 3.0\n     */\n    public static int truncatedCompareTo(Date date1, Date date2, int field) {\n        Date truncatedDate1 = truncate(date1, field);\n        Date truncatedDate2 = truncate(date2, field);\n        return truncatedDate1.compareTo(truncatedDate2);\n    }\n    \n    /**\n     * Returns the number of millis of a datefield, if this is a constant value\n     * \n     * @param unit A Calendar field which is a valid unit for a fragment\n     * @return number of millis\n     * @throws IllegalArgumentException if date can't be represented in millisenconds\n     * @since 2.4 \n     */\n    private static long getMillisPerUnit(int unit) {\n        long result = Long.MAX_VALUE;\n        switch (unit) {\n            case Calendar.DAY_OF_YEAR:\n            case Calendar.DATE:\n                result = MILLIS_PER_DAY;\n                break;\n            case Calendar.HOUR_OF_DAY:\n                result = MILLIS_PER_HOUR;\n                break;\n            case Calendar.MINUTE:\n                result = MILLIS_PER_MINUTE;\n                break;\n            case Calendar.SECOND:\n                result = MILLIS_PER_SECOND;\n                break;\n            case Calendar.MILLISECOND:\n                result = 1;\n                break;\n            default: throw new IllegalArgumentException(\"The unit \" + unit + \" cannot be represented is milleseconds\");\n        }\n        return result;\n    }\n\n    /**\n     * <p>Date iterator.</p>\n     */\n    static class DateIterator implements Iterator<Calendar> {\n        private final Calendar endFinal;\n        private final Calendar spot;\n        \n        /**\n         * Constructs a DateIterator that ranges from one date to another. \n         *\n         * @param startFinal start date (inclusive)\n         * @param endFinal end date (not inclusive)\n         */\n        DateIterator(Calendar startFinal, Calendar endFinal) {\n            super();\n            this.endFinal = endFinal;\n            spot = startFinal;\n            spot.add(Calendar.DATE, -1);\n        }\n\n        /**\n         * Has the iterator not reached the end date yet?\n         *\n         * @return <code>true</code> if the iterator has yet to reach the end date\n         */\n        public boolean hasNext() {\n            return spot.before(endFinal);\n        }\n\n        /**\n         * Return the next calendar in the iteration\n         *\n         * @return Object calendar for the next date\n         */\n        public Calendar next() {\n            if (spot.equals(endFinal)) {\n                throw new NoSuchElementException();\n            }\n            spot.add(Calendar.DATE, 1);\n            return (Calendar) spot.clone();\n        }\n\n        /**\n         * Always throws UnsupportedOperationException.\n         * \n         * @throws UnsupportedOperationException\n         * @see java.util.Iterator#remove()\n         */\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    \n}\n", "review": {"response": "<think>\nOkay, let me look at this Java code for DateUtils. The user wants me to find any bugs and return them in a JSON list.\n\nFirst, I'll start by reading through the code. The method in question here is isSameDay, which checks if two dates are on the same day ignoring the time. The code provided cuts off at the end, but maybe there's an issue there. Let me check the line where the problem might be.\n\nLooking at the code snippet:\n\npublic static boolean isSameDay(Date date1, Date date2) {\n    if (date1 == null || date2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    Calendar cal1 = Calendar.getInstance();\n    cal1.setTime(date1);\n    Calendar cal2 = Calendar.getInstance();\n   ```\n\nWait, the code ends with the declaration of cal2 but doesn't set its time or compare anything. The user's code seems to be cut off here. The actual method should compare the two calendars after setting their time. But in the provided code, after creating cal2, there's no further code. That's a problem because the method would not compile. The code is missing the part where cal2 is set to date2 and then the comparison between cal1 and cal2's date fields.\n\nSo, the bug here is that the code is incomplete. The line where cal2 is created but not set with date2's time. The correct code should have cal2.setTime(date2); followed by comparing the dates. For example, using Calendar's get methods for year, month, and day to check if they are equal.\n\nAnother possible issue is that the code uses Calendar.getInstance(), which uses the default time zone. If the dates are in different time zones, this could cause incorrect comparisons. However, since both dates are being set in the same calendar instance (using the same time zone), the comparison of their date fields should be okay. But if the dates are in different time zones, this method might not work as intended. However, the method's documentation says it ignores time, so perhaps it's intended to use the default time zone.\n\nAnother thing to check: the code may not handle the comparison correctly. For example, the correct approach is to compare the year, month, and day fields of both calendars. If any of these differ, return false; otherwise, return true. The current code as provided doesn't do this because it's cut off. But given the code as presented, the main bug is the missing code after creating cal2.\n\nWait, the user provided a code snippet that's cut off. The line after creating cal2 is missing. So in the actual code, there's probably a missing part. For example, in the real DateUtils class from Apache Commons Lang, the isSameDay method uses Calendar's get methods for YEAR, MONTH, and DAY_OF_MONTH. If the code here is missing those steps, that's a bug. But in the provided code, the user's code is cut off, so the method is incomplete and would not compile. That's definitely a bug.\n\nSo the first bug is that the code for isSameDay is incomplete. The line where cal2 is created is followed by nothing, but the actual code needs to set cal2's time and then compare the date fields.\n\nAnother possible bug: if the code is using the same Calendar instance for both dates, but in the provided code, two separate Calendar instances are created. That's okay. But if there's a mistake in comparing the fields, that's another issue.\n\nWait, looking at the code again, after creating cal1 and setting it to date1, then cal2 is created but not set. So the code is missing cal2.setTime(date2);. That's a syntax error. The method would not compile as written. That's a critical bug.\n\nSo the first bug is a syntax error due to missing code. The line should have cal2.setTime(date2); followed by comparing the fields.\n\nAnother possible issue is that the code may not handle the time zone correctly. For example, if the dates are in different time zones, but the method assumes the default time zone. But the method's documentation says it ignores time, so perhaps that's intended.\n\nAdditionally, the code may not correctly compare the day of the month. For example, if the Calendar instances are in different eras or something else. But given the code as presented, the main issue is the missing code.\n\nSo the main bugs here are:\n\n1. The isSameDay method is incomplete. After creating cal2, it doesn't set it to date2 and doesn't perform the comparison. This would cause a compilation error.\n\n2. The code as written would not compile because the method is missing the necessary code to set cal2's time and compare the dates.\n\nAnother possible bug: if the code later compares the calendars using equals(), which compares all fields, including time. But the method is supposed to ignore time. However, in the actual Apache code, they compare specific fields. If the code here is missing that, then that's a bug. But since the code is cut off, we can't see that part.\n\nBut given the code provided, the immediate bug is the missing code leading to a compilation error. So I'll note that as a bug.\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"line\": 139,\n      \"description\": \"The method 'isSameDay' is incomplete and will not compile. The Calendar instance 'cal2' is created but not set with 'date2' using 'setTime'. Additionally, the comparison logic between the two Calendar instances is missing.\"\n    }\n  ]\n}\n```"}}