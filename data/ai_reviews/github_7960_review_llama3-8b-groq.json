{
  "source_item_id": 7960,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:53:14.233455",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkElementIndex;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.J2ktIncompatible;\nimport com.google.common.math.IntMath;\nimport java.util.AbstractList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.RandomAccess;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Implementation of {@link Lists#cartesianProduct(List)}.\n *\n * @author Louis Wasserman\n */\n@GwtCompatible\nfinal class CartesianList<E> extends AbstractList<List<E>> implements RandomAccess {\n\n  private final transient ImmutableList<List<E>> axes;\n  private final transient int[] axesSizeProduct;\n\n  static <E> List<List<E>> create(List<? extends List<? extends E>> lists) {\n    ImmutableList.Builder<List<E>> axesBuilder = new ImmutableList.Builder<>(lists.size());\n    for (List<? extends E> list : lists) {\n      List<E> copy = ImmutableList.copyOf(list);\n      if (copy.isEmpty()) {\n        return ImmutableList.of();\n      }\n      axesBuilder.add(copy);\n    }\n    return new CartesianList<>(axesBuilder.build());\n  }\n\n  CartesianList(ImmutableList<List<E>> axes) {\n    this.axes = axes;\n    int[] axesSizeProduct = new int[axes.size() + 1];\n    axesSizeProduct[axes.size()] = 1;\n    try {\n      for (int i = axes.size() - 1; i >= 0; i--) {\n        axesSizeProduct[i] = IntMath.checkedMultiply(axesSizeProduct[i + 1], axes.get(i).size());\n      }\n    } catch (ArithmeticException e) {\n      throw new IllegalArgumentException(\n          \"Cartesian product too large; must have size at most Integer.MAX_VALUE\");\n    }\n    this.axesSizeProduct = axesSizeProduct;\n  }\n\n  private int getAxisIndexForProductIndex(int index, int axis) {\n    return (index / axesSizeProduct[axis + 1]) % axes.get(axis).size();\n  }\n\n  @Override\n  public int indexOf(@Nullable Object o) {\n    if (!(o instanceof List)) {\n      return -1;\n    }\n    List<?> list = (List<?>) o;\n    if (list.size() != axes.size()) {\n      return -1;\n    }\n    ListIterator<?> itr = list.listIterator();\n    int computedIndex = 0;\n    while (itr.hasNext()) {\n      int axisIndex = itr.nextIndex();\n      int elemIndex = axes.get(axisIndex).indexOf(itr.next());\n      if (elemIndex == -1) {\n        return -1;\n      }\n      computedIndex += elemIndex * axesSizeProduct[axisIndex + 1];\n    }\n    return computedIndex;\n  }\n\n  @Override\n  public int lastIndexOf(@Nullable Object o) {\n    if (!(o instanceof List)) {\n      return -1;\n    }\n    List<?> list = (List<?>) o;\n    if (list.size() != axes.size()) {\n      return -1;\n    }\n    ListIterator<?> itr = list.listIterator();\n    int computedIndex = 0;\n    while (itr.hasNext()) {\n      int axisIndex = itr.nextIndex();\n      int elemIndex = axes.get(axisIndex).lastIndexOf(itr.next());\n      if (elemIndex == -1) {\n        return -1;\n      }\n      computedIndex += elemIndex * axesSizeProduct[axisIndex + 1];\n    }\n    return computedIndex;\n  }\n\n  @Override\n  public ImmutableList<E> get(int index) {\n    checkElementIndex(index, size());\n    return new ImmutableList<E>() {\n\n      @Override\n      public int size() {\n        return axes.size();\n      }\n\n      @Override\n      public E get(int axis) {\n        checkElementIndex(axis, size());\n        int axisIndex = getAxisIndexForProductIndex(index, axis);\n        return axes.get(axis).get(axisIndex);\n      }\n\n      @Override\n      boolean isPartialView() {\n        return true;\n      }\n\n      // redeclare to help optimizers with b/310253115\n      @SuppressWarnings(\"RedundantOverride\")\n      @J2ktIncompatible // serialization\n      @Override\n      @GwtIncompatible // serialization\n      Object writeReplace() {\n        return super.writeReplace();\n      }\n    };\n  }\n\n  @Override\n  public int size() {\n    return axesSizeProduct[0];\n  }\n\n  @Override\n  public boolean contains(@Nullable Object object) {\n    if (!(object instanceof List)) {\n      return false;\n    }\n    List<?> list = (List<?>) object;\n    if (list.size() != axes.size()) {\n      return false;\n    }\n    int i = 0;\n    for (Object o : list) {\n      if (!axes.get(i).contains(o)) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  }\n}\n",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The get method returns a new ImmutableList instance every time it is called, which can lead to performance issues and memory leaks if the list is large. This is because ImmutableList instances are not cleared when they are no longer referenced.\",\n         \"suggested_fix\": \"Change the get method to return a shared instance of the ImmutableList, or use a different data structure that is more memory-efficient.\"\n      },\n      {\n         \"explanation\": \"The contains method does not handle null values correctly. It will throw a NullPointerException if the object being searched for is null.\",\n         \"suggested_fix\": \"Add a null check at the beginning of the contains method to return false if the object is null.\"\n      },\n      {\n         \"explanation\": \"The get method does not handle out-of-bounds indices correctly. It will throw an IndexOutOfBoundsException if the index is out of bounds, but it does not provide any additional information about the error.\",\n         \"suggested_fix\": \"Add a more informative error message to the get method to indicate that the index is out of bounds.\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The get method returns a new ImmutableList instance every time it is called, which can lead to performance issues and memory leaks if the list is large. This is because ImmutableList instances are not cleared when they are no longer referenced.",
        "suggested_fix": "Change the get method to return a shared instance of the ImmutableList, or use a different data structure that is more memory-efficient."
      },
      {
        "explanation": "The contains method does not handle null values correctly. It will throw a NullPointerException if the object being searched for is null.",
        "suggested_fix": "Add a null check at the beginning of the contains method to return false if the object is null."
      },
      {
        "explanation": "The get method does not handle out-of-bounds indices correctly. It will throw an IndexOutOfBoundsException if the index is out of bounds, but it does not provide any additional information about the error.",
        "suggested_fix": "Add a more informative error message to the get method to indicate that the index is out of bounds."
      }
    ],
    "no_bugs_reasoning": ""
  },
  "error": null
}