{
  "source_item_id": 8024,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:45:43.679716",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2014 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.graph;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.graph.GraphConstants.NODE_NOT_IN_GRAPH;\nimport static java.util.Objects.requireNonNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Iterators;\nimport com.google.common.collect.Maps;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.util.ArrayDeque;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Queue;\nimport java.util.Set;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Static utility methods for {@link Graph}, {@link ValueGraph}, and {@link Network} instances.\n *\n * @author James Sexton\n * @author Joshua O'Madadhain\n * @since 20.0\n */\n@Beta\npublic final class Graphs extends GraphsBridgeMethods {\n\n  private Graphs() {}\n\n  // Graph query methods\n\n  /**\n   * Returns true if {@code graph} has at least one cycle. A cycle is defined as a non-empty subset\n   * of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges) starting\n   * and ending with the same node.\n   *\n   * <p>This method will detect any non-empty cycle, including self-loops (a cycle of length 1).\n   */\n  public static <N> boolean hasCycle(Graph<N> graph) {\n    int numEdges = graph.edges().size();\n    if (numEdges == 0) {\n      return false; // An edge-free graph is acyclic by definition.\n    }\n    if (!graph.isDirected() && numEdges >= graph.nodes().size()) {\n      return true; // Optimization for the undirected case: at least one cycle must exist.\n    }\n\n    Map<Object, NodeVisitState> visitedNodes =\n        Maps.newHashMapWithExpectedSize(graph.nodes().size());\n    for (N node : graph.nodes()) {\n      if (subgraphHasCycle(graph, visitedNodes, node)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if {@code network} has at least one cycle. A cycle is defined as a non-empty\n   * subset of edges in a graph arranged to form a path (a sequence of adjacent outgoing edges)\n   * starting and ending with the same node.\n   *\n   * <p>This method will detect any non-empty cycle, including self-loops (a cycle of length 1).\n   */\n  public static boolean hasCycle(Network<?, ?> network) {\n    // In a directed graph, parallel edges cannot introduce a cycle in an acyclic graph.\n    // However, in an undirected graph, any parallel edge induces a cycle in the graph.\n    if (!network.isDirected()\n        && network.allowsParallelEdges()\n        && network.edges().size() > network.asGraph().edges().size()) {\n      return true;\n    }\n    return hasCycle(network.asGraph());\n  }\n\n  /**\n   * Performs a traversal of the nodes reachable from {@code startNode}. If we ever reach a node\n   * we've already visited (following only outgoing edges and without reusing edges), we know\n   * there's a cycle in the graph.\n   */\n  private static <N> boolean subgraphHasCycle(\n      Graph<N> graph, Map<Object, NodeVisitState> visitedNodes, N startNode) {\n    Deque<NodeAndRemainingSuccessors<N>> stack = new ArrayDeque<>();\n    stack.addLast(new NodeAndRemainingSuccessors<>(startNode));\n\n    while (!stack.isEmpty()) {\n      // To peek at the top two items, we need to temporarily remove one.\n      NodeAndRemainingSuccessors<N> top = stack.removeLast();\n      NodeAndRemainingSuccessors<N> prev = stack.peekLast();\n      stack.addLast(top);\n\n      N node = top.node;\n      N previousNode = prev == null ? null : prev.node;\n      if (top.remainingSuccessors == null) {\n        NodeVisitState state = visitedNodes.get(node);\n        if (state == NodeVisitState.COMPLETE) {\n          stack.removeLast();\n          continue;\n        }\n        if (state == NodeVisitState.PENDING) {\n          return true;\n        }\n\n        visitedNodes.put(node, NodeVisitState.PENDING);\n        top.remainingSuccessors = new ArrayDeque<>(graph.successors(node));\n      }\n\n      if (!top.remainingSuccessors.isEmpty()) {\n        N nextNode = top.remainingSuccessors.remove();\n        if (canTraverseWithoutReusingEdge(graph, nextNode, previousNode)) {\n          stack.addLast(new NodeAndRemainingSuccessors<>(nextNode));\n          continue;\n        }\n      }\n\n      stack.removeLast();\n      visitedNodes.put(node, NodeVisitState.COMPLETE);\n    }\n    return false;\n  }\n\n  private static final class NodeAndRemainingSuccessors<N> {\n    final N node;\n\n    /**\n     * The successors left to be visited, or {@code null} if we just added this {@code\n     * NodeAndRemainingSuccessors} instance to the stack. In the latter case, we'll compute the\n     * successors if we determine that we need them after we've performed the initial processing of\n     * the node.\n     */\n    @Nullable Queue<N> remainingSuccessors;\n\n    NodeAndRemainingSuccessors(N node) {\n      this.node = node;\n    }\n  }\n\n  /**\n   * Determines whether an edge has already been used during traversal. In the directed case a cycle\n   * is always detected before reusing an edge, so no special logic is required. In the undirected\n   * case, we must take care not to \"backtrack\" over an edge (i.e. going from A to B and then going\n   * from B to A).\n   */\n  private static boolean canTraverseWithoutReusingEdge(\n      Graph<?> graph, Object nextNode, @Nullable Object previousNode) {\n    if (graph.isDirected() || !Objects.equals(previousNode, nextNode)) {\n      return true;\n    }\n    // This falls into the undirected A->B->A case. The Graph interface does not support parallel\n    // edges, so this traversal would require reusing the undirected AB edge.\n    return false;\n  }\n\n  /**\n   * Returns the transitive closure of {@code graph}. The transitive closure of a graph is another\n   * graph with an edge connecting node A to node B if node B is {@link #reachableNodes(Graph,\n   * Object) reachable} from node A.\n   *\n   * <p>This is a \"snapshot\" based on the current topology of {@code graph}, rather than a live view\n   * of the transitive closure of {@code graph}. In other words, the returned {@link Graph} will not\n   * be updated after modifications to {@code graph}.\n   *\n   * @since 33.1.0 (present with return type {@code Graph} since 20.0)\n   */\n  // TODO(b/31438252): Consider potential optimizations for this algorithm.\n  public static <N> ImmutableGraph<N> transitiveClosure(Graph<N> graph) {\n    ImmutableGraph.Builder<N> transitiveClosure =\n        GraphBuilder.from(graph).allowsSelfLoops(true).<N>immutable();\n    // Every node is, at a minimum, reachable from itself. Since the resulting transitive closure\n    // will have no isolated nodes, we can skip adding nodes explicitly and let putEdge() do it.\n\n    if (graph.isDirected()) {\n      // Note: works for both directed and undirected graphs, but we only use in the directed case.\n      for (N node : graph.nodes()) {\n        for (N reachableNode : reachableNodes(graph, node)) {\n          transitiveClosure.putEdge(node, reachableNode);\n        }\n      }\n    } else {\n      // An optimization for the undirected case: for every node B reachable from node A,\n      // node A and node B have the same reachability set.\n      Set<N> visitedNodes = new HashSet<>();\n      for (N node : graph.nodes()) {\n        if (!visitedNodes.contains(node))",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The method 'subgraphHasCycle' does not handle the case where the graph has a self-loop.\",\n         \"suggested_fix\": \"Add a check for self-loops before starting the traversal.\"\n      },\n      {\n         \"explanation\": \"The method 'transitiveClosure' does not handle the case where the graph has a large number of nodes or edges, leading to performance issues.\",\n         \"suggested_fix\": \"Consider using a more efficient algorithm for computing the transitive closure, such as Floyd-Warshall or Johnson's algorithm.\"\n      },\n      {\n         \"explanation\": \"The method 'canTraverseWithoutReusingEdge' does not handle the case where the graph has a large number of parallel edges, leading to performance issues.\",\n         \"suggested_fix\": \"Consider using a more efficient data structure to store and query parallel edges.\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No critical bugs found in the provided code snippet.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The method 'subgraphHasCycle' does not handle the case where the graph has a self-loop.",
        "suggested_fix": "Add a check for self-loops before starting the traversal."
      },
      {
        "explanation": "The method 'transitiveClosure' does not handle the case where the graph has a large number of nodes or edges, leading to performance issues.",
        "suggested_fix": "Consider using a more efficient algorithm for computing the transitive closure, such as Floyd-Warshall or Johnson's algorithm."
      },
      {
        "explanation": "The method 'canTraverseWithoutReusingEdge' does not handle the case where the graph has a large number of parallel edges, leading to performance issues.",
        "suggested_fix": "Consider using a more efficient data structure to store and query parallel edges."
      }
    ],
    "no_bugs_reasoning": "No critical bugs found in the provided code snippet."
  },
  "error": null
}