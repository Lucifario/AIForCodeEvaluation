{"sample_id": "Chart_14", "model": "llama3-8b-groq", "code_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -----------------\n * CategoryPlot.java\n * -----------------\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Jeremy Bowman;\n *                   Arnaud Lelievre;\n *                   Richard West, Advanced Micro Devices, Inc.;\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 21-Aug-2001 : Added standard header. Fixed DOS encoding problem (DG);\n * 18-Sep-2001 : Updated header (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 23-Oct-2001 : Changed intro and trail gaps on bar plots to use percentage of \n *               available space rather than a fixed number of units (DG);\n * 12-Dec-2001 : Changed constructors to protected (DG);\n * 13-Dec-2001 : Added tooltips (DG);\n * 16-Jan-2002 : Increased maximum intro and trail gap percents, plus added \n *               some argument checking code.  Thanks to Taoufik Romdhane for \n *               suggesting this (DG);\n * 05-Feb-2002 : Added accessor methods for the tooltip generator, incorporated\n *               alpha-transparency for Plot and subclasses (DG);\n * 06-Mar-2002 : Updated import statements (DG);\n * 14-Mar-2002 : Renamed BarPlot.java --> CategoryPlot.java, and changed code \n *               to use the CategoryItemRenderer interface (DG);\n * 22-Mar-2002 : Dropped the getCategories() method (DG);\n * 23-Apr-2002 : Moved the dataset from the JFreeChart class to the Plot \n *               class (DG);\n * 29-Apr-2002 : New methods to support printing values at the end of bars, \n *               contributed by Jeremy Bowman (DG);\n * 11-May-2002 : New methods for label visibility and overlaid plot support, \n *               contributed by Jeremy Bowman (DG);\n * 06-Jun-2002 : Removed the tooltip generator, this is now stored with the \n *               renderer.  Moved constants into the CategoryPlotConstants \n *               interface.  Updated Javadoc comments (DG);\n * 10-Jun-2002 : Overridden datasetChanged() method to update the upper and \n *               lower bound on the range axis (if necessary), updated \n *               Javadocs (DG);\n * 25-Jun-2002 : Removed redundant imports (DG);\n * 20-Aug-2002 : Changed the constructor for Marker (DG);\n * 28-Aug-2002 : Added listener notification to setDomainAxis() and \n *               setRangeAxis() (DG);\n * 23-Sep-2002 : Added getLegendItems() method and fixed errors reported by \n *               Checkstyle (DG);\n * 28-Oct-2002 : Changes to the CategoryDataset interface (DG);\n * 05-Nov-2002 : Base dataset is now TableDataset not CategoryDataset (DG);\n * 07-Nov-2002 : Renamed labelXXX as valueLabelXXX (DG);\n * 18-Nov-2002 : Added grid settings for both domain and range axis (previously\n *               these were set in the axes) (DG);\n * 19-Nov-2002 : Added axis location parameters to constructor (DG);\n * 17-Jan-2003 : Moved to com.jrefinery.chart.plot package (DG);\n * 14-Feb-2003 : Fixed bug in auto-range calculation for secondary axis (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 02-May-2003 : Moved render() method up from subclasses. Added secondary \n *               range markers. Added an attribute to control the dataset \n *               rendering order.  Added a drawAnnotations() method.  Changed \n *               the axis location from an int to an AxisLocation (DG);\n * 07-May-2003 : Merged HorizontalCategoryPlot and VerticalCategoryPlot into \n *               this class (DG);\n * 02-Jun-2003 : Removed check for range axis compatibility (DG);\n * 04-Jul-2003 : Added a domain gridline position attribute (DG);\n * 21-Jul-2003 : Moved DrawingSupplier to Plot superclass (DG);\n * 19-Aug-2003 : Added equals() method and implemented Cloneable (DG);\n * 01-Sep-2003 : Fixed bug 797466 (no change event when secondary dataset \n *               changes) (DG);\n * 02-Sep-2003 : Fixed bug 795209 (wrong dataset checked in render2 method) and\n *               790407 (initialise method) (DG);\n * 08-Sep-2003 : Added internationalization via use of properties \n *               resourceBundle (RFE 690236) (AL); \n * 08-Sep-2003 : Fixed bug (wrong secondary range axis being used).  Changed \n *               ValueAxis API (DG);\n * 10-Sep-2003 : Fixed bug in setRangeAxis() method (DG);\n * 15-Sep-2003 : Fixed two bugs in serialization, implemented \n *               PublicCloneable (DG);\n * 23-Oct-2003 : Added event notification for changes to renderer (DG);\n * 26-Nov-2003 : Fixed bug (849645) in clearRangeMarkers() method (DG);\n * 03-Dec-2003 : Modified draw method to accept anchor (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 10-Mar-2004 : Fixed bug in axis range calculation when secondary renderer is\n *               stacked (DG);\n * 12-May-2004 : Added fixed legend items (DG);\n * 19-May-2004 : Added check for null legend item from renderer (DG);\n * 02-Jun-2004 : Updated the DatasetRenderingOrder class (DG);\n * 05-Nov-2004 : Renamed getDatasetsMappedToRangeAxis() \n *               --> datasetsMappedToRangeAxis(), and ensured that returned \n *               list doesn't contain null datasets (DG);\n * 12-Nov-2004 : Implemented new Zoomable interface (DG);\n * 07-Jan-2005 : Renamed getRangeExtent() --> findRangeBounds() in \n *               CategoryItemRenderer (DG);\n * 04-May-2005 : Fixed serialization of range markers (DG);\n * 05-May-2005 : Updated draw() method parameters (DG);\n * 20-May-2005 : Added setDomainAxes() and setRangeAxes() methods, as per\n *               RFE 1183100 (DG);\n * 01-Jun-2005 : Upon deserialization, register plot as a listener with its\n *               axes, dataset(s) and renderer(s) - see patch 1209475 (DG);\n * 02-Jun-2005 : Added support for domain markers (DG);\n * 06-Jun-2005 : Fixed equals() method for use with GradientPaint (DG);\n * 09-Jun-2005 : Added setRenderers(), as per RFE 1183100 (DG);\n * 16-Jun-2005 : Added getDomainAxisCount() and getRangeAxisCount() methods, to\n *               match XYPlot (see RFE 1220495) (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 11-Jan-2006 : Added configureRangeAxes() to rendererChanged(), since the\n *               renderer might influence the axis range (DG);\n * 27-Jan-2006 : Added various null argument checks (DG);\n * 18-Aug-2006 : Added getDatasetCount() method, plus a fix for bug drawing \n *               category labels, thanks to Adriaan Joubert (1277726) (DG);\n * 05-Sep-2006 : Added MarkerChangeEvent support (DG);\n * 30-Oct-2006 : Added getDomainAxisIndex(), datasetsMappedToDomainAxis() and \n *               getCategoriesForAxis() methods (DG);\n * 22-Nov-2006 : Fire PlotChangeEvent from setColumnRenderingOrder() and\n *               setRowRenderingOrder() (DG);\n * 29-Nov-2006 : Fix for bug 1605207 (IntervalMarker exceeds bounds of data \n *               area) (DG);\n * 26-Feb-2007 : Fix for bug 1669218 (setDomainAxisLocation() notify argument\n *               ignored) (DG);\n * 13-Mar-2007 : Added null argument checks for setRangeCrosshairPaint() and\n *               setRangeCrosshairStroke(), fixed clipping for \n *               annotations (DG);\n * 07-Jun-2007 : Override drawBackground() for new GradientPaint handling (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 06-Jul-2007 : Updated annotation handling (DG);\n * 10-Jul-2007 : Added getRangeAxisIndex(ValueAxis) method (DG);\n * 24-Sep-2007 : Implemented new zoom methods (DG);\n * 25-Oct-2007 : Added some argument checks (DG);\n * 05-Nov-2007 : Applied patch 1823697, by Richard West, for removal of domain\n *               and range markers (DG);\n * 14-Nov-2007 : Added missing event notifications (DG);\n * 25-Mar-2008 : Added new methods with optional notification - see patch\n *               1913751 (DG);\n * 07-Apr-2008 : Fixed NPE in removeDomainMarker() and \n *               removeRangeMarker() (DG);\n * \n *\n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.CategoryAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.CategoryAnchor;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.category.CategoryItemRenderer;\nimport org.jfree.chart.renderer.category.CategoryItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\n\n/**\n * A general plotting class that uses data from a {@link CategoryDataset} and \n * renders each data item using a {@link CategoryItemRenderer}.\n */\npublic class CategoryPlot extends Plot implements ValueAxisPlot, \n        Zoomable, RendererChangeListener, Cloneable, PublicCloneable, \n        Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -3537691700434728188L;\n    \n    /** \n     * The default visibility of the grid lines plotted against the domain \n     * axis. \n     */\n    public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false;\n\n    /** \n     * The default visibility of the grid lines plotted against the range \n     * axis. \n     */\n    public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true;\n\n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] \n            {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\n\n    /** The default value label font. */\n    public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10);\n\n    /** \n     * The default crosshair visibility. \n     * \n     * @since 1.0.5\n     */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\n\n    /** \n     * The default crosshair stroke. \n     * \n     * @since 1.0.5\n     */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            = DEFAULT_GRIDLINE_STROKE;\n\n    /** \n     * The default crosshair paint. \n     * \n     * @since 1.0.5\n     */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources \n            = ResourceBundle.getBundle(\n            \"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** Storage for the domain axes. */\n    private ObjectList domainAxes;\n\n    /** Storage for the domain axis locations. */\n    private ObjectList domainAxisLocations;\n\n    /**\n     * A flag that controls whether or not the shared domain axis is drawn \n     * (only relevant when the plot is being used as a subplot).\n     */\n    private boolean drawSharedDomainAxis;\n\n    /** Storage for the range axes. */\n    private ObjectList rangeAxes;\n\n    /** Storage for the range axis locations. */\n    private ObjectList rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private ObjectList datasets;\n\n    /** Storage for keys that map datasets to domain axes. */\n    private ObjectList datasetToDomainAxisMap;\n    \n    /** Storage for keys that map datasets to range axes. */\n    private ObjectList datasetToRangeAxisMap;\n\n    /** Storage for the renderers. */\n    private ObjectList renderers;\n\n    /** The dataset rendering order. */\n    private DatasetRenderingOrder renderingOrder \n            = DatasetRenderingOrder.REVERSE;\n\n    /** \n     * Controls the order in which the columns are traversed when rendering the \n     * data items. \n     */\n    private SortOrder columnRenderingOrder = SortOrder.ASCENDING;\n    \n    /** \n     * Controls the order in which the rows are traversed when rendering the \n     * data items. \n     */\n    private SortOrder rowRenderingOrder = SortOrder.ASCENDING;\n    \n    /** \n     * A flag that controls whether the grid-lines for the domain axis are \n     * visible. \n     */\n    private boolean domainGridlinesVisible;\n\n    /** The position of the domain gridlines relative to the category. */\n    private CategoryAnchor domainGridlinePosition;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain  grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /** \n     * A flag that controls whether the grid-lines for the range axis are \n     * visible. \n     */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range axis grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range axis grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /** The anchor value. */\n    private double anchorValue;\n\n    /** A flag that controls whether or not a range crosshair is drawn. */\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /** \n     * A flag that controls whether or not the crosshair locks onto actual \n     * data points. \n     */\n    private boolean rangeCrosshairLockedOnData = true;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map foregroundDomainMarkers;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map backgroundDomainMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map foregroundRangeMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map backgroundRangeMarkers;\n\n    /** \n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be \n     * <code>null</code>.\n     */\n    private List annotations;\n\n    /**\n     * The weight for the plot (only relevant when the plot is used as a subplot\n     * within a combined plot).\n     */\n    private int weight;\n\n    /** The fixed space for the domain axis. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed space for the range axis. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /** \n     * An optional collection of legend items that can be returned by the \n     * getLegendItems() method. \n     */\n    private LegendItemCollection fixedLegendItems;\n    \n    /**\n     * Default constructor.\n     */\n    public CategoryPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\n     * @param renderer  the item renderer (<code>null</code> permitted).\n     *\n     */\n    public CategoryPlot(CategoryDataset dataset,\n                        CategoryAxis domainAxis,\n                        ValueAxis rangeAxis,\n                        CategoryItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n\n        // allocate storage for dataset, axes and renderers\n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        \n        this.datasetToDomainAxisMap = new ObjectList();\n        this.datasetToRangeAxisMap = new ObjectList();\n\n        this.renderers = new ObjectList();\n\n        this.datasets = new ObjectList();\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false);\n        setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false);\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.drawSharedDomainAxis = false;\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\n        this.domainGridlinePosition = CategoryAnchor.MIDDLE;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        Marker baseline = new ValueMarker(0.0, new Color(0.8f, 0.8f, 0.8f, \n                0.5f), new BasicStroke(1.0f), new Color(0.85f, 0.85f, 0.95f, \n                0.5f), new BasicStroke(1.0f), 0.6f);\n        addRangeMarker(baseline, Layer.BACKGROUND);\n\n        this.anchorValue = 0.0;\n\n        this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n        \n        this.annotations = new java.util.ArrayList();\n\n    }\n    \n    /**\n     * Returns a string describing the type of plot.\n     *\n     * @return The type.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"Category_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation of the plot (never <code>null</code>).\n     * \n     * @see #setOrientation(PlotOrientation)\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation (<code>null</code> not permitted).\n     * \n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        this.orientation = orientation;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never <code>null</code>).\n     * \n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (<code>null</code> not permitted).\n     * \n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");   \n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain axis for the plot.  If the domain axis for this plot\n     * is <code>null</code>, then the method will return the parent plot's \n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis (<code>null</code> permitted).\n     * \n     * @see #setDomainAxis(CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     * \n     * @see #setDomainAxis(int, CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis(int index) {\n        CategoryAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (CategoryAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis()\n     */\n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n \n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     * \n     * @param axis  the axis (<code>null</code> not permitted).\n     * \n     * @return The axis index.\n     * \n     * @see #getDomainAxis(int)\n     * @see #getRangeAxisIndex(ValueAxis)\n     * \n     * @since 1.0.3\n     */\n    public int getDomainAxisIndex(CategoryAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        return this.domainAxes.indexOf(axis);\n    }\n    \n    /**\n     * Returns the domain axis location for the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #getRangeAxisLocation()\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     * \n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * \n     * @see #getDomainAxisLocation()\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * @param notify  a flag that controls whether listeners are notified.\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n    \n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     * \n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.5\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain axis edge.  This is derived from the axis location\n     * and the plot orientation.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        RectangleEdge result = null;\n        AxisLocation location = getDomainAxisLocation(index);\n        if (location != null) {\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\n        }\n        else {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     */\n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the domain axes.\n     */\n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * null, then the method will return the parent plot's range axis (if there\n     * is a parent plot).\n     *\n     * @return The range axis (possibly <code>null</code>).\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Returns a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     */\n    public void setRangeAxis(ValueAxis axis) {\n        setRangeAxis(0, axis);\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n        \n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setDomainAxes(CategoryAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     *\n     * @param axis  the axis (<code>null</code> not permitted).\n     *\n     * @return The axis index.\n     * \n     * @see #getRangeAxis(int)\n     * @see #getDomainAxisIndex(CategoryAxis)\n     * \n     * @since 1.0.7\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) { // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range axis location.\n     *\n     * @return The location (never <code>null</code>).\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return getRangeAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     * \n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxisLocation(AxisLocation, boolean)\n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // defer argument checking...\n        setRangeAxisLocation(location, true);\n    }\n\n    /**\n     * Sets the location of the range axis and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #setDomainAxisLocation(AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        setRangeAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location, \n                                     boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the edge where the primary range axis is located.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return getRangeAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     */\n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the range axes.\n     */\n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(CategoryDataset)\n     */\n    public CategoryDataset getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns the dataset at the given index.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(int, CategoryDataset)\n     */\n    public CategoryDataset getDataset(int index) {\n        CategoryDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (CategoryDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the dataset for the plot, replacing the existing dataset, if there \n     * is one.  This method also calls the \n     * {@link #datasetChanged(DatasetChangeEvent)} method, which adjusts the \n     * axis ranges if necessary and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset()\n     */\n    public void setDataset(CategoryDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot.\n     *\n     * @param index  the dataset index.\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, CategoryDataset dataset) {\n        \n        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        \n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n        \n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     * \n     * @since 1.0.2\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.\n     * \n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     * \n     * @see #getDomainAxisForDataset(int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.set(index, new Integer(axisIndex));  \n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    /**\n     * Returns the domain axis for a dataset.  You can change the axis for a \n     * dataset using the {@link #mapDatasetToDomainAxis(int, int)} method.\n     * \n     * @param index  the dataset index.\n     * \n     * @return The domain axis.\n     * \n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public CategoryAxis getDomainAxisForDataset(int index) {\n        CategoryAxis result = getDomainAxis();\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getDomainAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    /**\n     * Maps a dataset to a particular range axis.\n     * \n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     * \n     * @see #getRangeAxisForDataset(int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.set(index, new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    /**\n     * Returns the range axis for a dataset.  You can change the axis for a \n     * dataset using the {@link #mapDatasetToRangeAxis(int, int)} method.\n     * \n     * @param index  the dataset index.\n     * \n     * @return The range axis.\n     * \n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n        ValueAxis result = getRangeAxis();\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getRangeAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    /**\n     * Returns a reference to the renderer for the plot.\n     *\n     * @return The renderer.\n     * \n     * @see #setRenderer(CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer at the given index.\n     *\n     * @param index  the renderer index.\n     *\n     * @return The renderer (possibly <code>null</code>).\n     * \n     * @see #setRenderer(int, CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer(int index) {\n        CategoryItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (CategoryItemRenderer) this.renderers.get(index);\n        }\n        return result;\n    }\n    \n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\" \n     * renderer) and sends a {@link PlotChangeEvent} to all registered \n     * listeners.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted.\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer) {\n        setRenderer(0, renderer, true);\n    }\n\n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\" \n     * renderer) and, if requested, sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * <p>\n     * You can set the renderer to <code>null</code>, but this is not \n     * recommended because:\n     * <ul>\n     *   <li>no data will be displayed;</li>\n     *   <li>the plot background will not be painted;</li>\n     * </ul>\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer, boolean notify) {\n        setRenderer(0, renderer, notify);\n    }\n\n    /**\n     * Sets the renderer at the specified index and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @see #getRenderer(int)\n     * @see #setRenderer(int, CategoryItemRenderer, boolean)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer) {\n        setRenderer(index, renderer, true);   \n    }\n\n    /**\n     * Sets a renderer.  A {@link PlotChangeEvent} is sent to all registered \n     * listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer, \n                            boolean notify) {\n        \n        // stop listening to the existing renderer...\n        CategoryItemRenderer existing \n            = (CategoryItemRenderer) this.renderers.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        \n        // register the new renderer...\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n        \n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param renderers  the renderers.\n     */\n    public void setRenderers(CategoryItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the renderer for the specified dataset.  If the dataset doesn't\n     * belong to the plot, this method will return <code>null</code>.\n     * \n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @return The renderer (possibly <code>null</code>).\n     */\n    public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) {\n        CategoryItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (CategoryItemRenderer) this.renderers.get(i);   \n                break;\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the index of the specified renderer, or <code>-1</code> if the\n     * renderer is not assigned to this plot.\n     * \n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @return The renderer index.\n     */\n    public int getIndexOf(CategoryItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never <code>null</code>).\n     * \n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.renderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  By default, the plot renders the primary dataset \n     * last (so that the primary dataset overlays the secondary datasets).  You \n     * can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     * \n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");   \n        }\n        this.renderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the order in which the columns are rendered.  The default value\n     * is <code>SortOrder.ASCENDING</code>.\n     * \n     * @return The column rendering order (never <code>null</code).\n     * \n     * @see #setColumnRenderingOrder(SortOrder)\n     */    \n    public SortOrder getColumnRenderingOrder() {\n        return this.columnRenderingOrder;\n    }\n    \n    /**\n     * Sets the column order in which the items in each dataset should be \n     * rendered and sends a {@link PlotChangeEvent} to all registered \n     * listeners.  Note that this affects the order in which items are drawn, \n     * NOT their position in the chart.\n     * \n     * @param order  the order (<code>null</code> not permitted).\n     * \n     * @see #getColumnRenderingOrder()\n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public void setColumnRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.columnRenderingOrder = order;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the order in which the rows should be rendered.  The default \n     * value is <code>SortOrder.ASCENDING</code>.\n     * \n     * @return The order (never <code>null</code>).\n     * \n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public SortOrder getRowRenderingOrder() {\n        return this.rowRenderingOrder;\n    }\n\n    /**\n     * Sets the row order in which the items in each dataset should be \n     * rendered and sends a {@link PlotChangeEvent} to all registered \n     * listeners.  Note that this affects the order in which items are drawn, \n     * NOT their position in the chart.\n     * \n     * @param order  the order (<code>null</code> not permitted).\n     * \n     * @see #getRowRenderingOrder()\n     * @see #setColumnRenderingOrder(SortOrder)\n     */\n    public void setRowRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.rowRenderingOrder = order;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the flag that controls whether the domain grid-lines are visible.\n     *\n     * @return The <code>true</code> or <code>false</code>.\n     * \n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against \n     * the domain axis.\n     * <p>\n     * If the flag value changes, a {@link PlotChangeEvent} is sent to all \n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the position used for the domain gridlines.\n     * \n     * @return The gridline position (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePosition(CategoryAnchor)\n     */\n    public CategoryAnchor getDomainGridlinePosition() {\n        return this.domainGridlinePosition;\n    }\n\n    /**\n     * Sets the position used for the domain gridlines and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param position  the position (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlinePosition()\n     */\n    public void setDomainGridlinePosition(CategoryAnchor position) {\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");   \n        }\n        this.domainGridlinePosition = position;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used to draw grid-lines against the domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw grid-lines against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' not permitted.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw grid-lines against the domain axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid-lines (if any) against the domain \n     * axis and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the flag that controls whether the range grid-lines are visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against \n     * the range axis.  If the flag changes value, a {@link PlotChangeEvent} is \n     * sent to all registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the grid-lines against the range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the grid-lines against the range axis and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the grid-lines against the range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid lines against the range axis and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the fixed legend items, if any.\n     * \n     * @return The legend items (possibly <code>null</code>).\n     * \n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;   \n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to \n     * <code>null</code> if you prefer the legend items to be created \n     * automatically.\n     * \n     * @param items  the legend items (<code>null</code> permitted).\n     * \n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the legend items for the plot.  By default, this method creates \n     * a legend item for each series in each of the datasets.  You can change \n     * this behaviour by overriding this method.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = this.fixedLegendItems;\n        if (result == null) {\n            result = new LegendItemCollection();\n            // get the legend items for the datasets...\n            int count = this.datasets.size();\n            for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n                CategoryDataset dataset = getDataset(datasetIndex);\n                if (dataset != null) {\n                    CategoryItemRenderer renderer = getRenderer(datasetIndex);\n                    if (renderer != null) {\n                        int seriesCount = dataset.getRowCount();\n                        for (int i = 0; i < seriesCount; i++) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Handles a 'click' on the plot by updating the anchor value.\n     *\n     * @param x  x-coordinate of the click (in Java2D space).\n     * @param y  y-coordinate of the click (in Java2D space).\n     * @param info  information about the plot's dimensions.\n     *\n     */\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the range axis...\n            double java2D = 0.0;\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                java2D = x;\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                java2D = y;\n            }\n            RectangleEdge edge = Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), this.orientation);\n            double value = getRangeAxis().java2DToValue(\n                    java2D, info.getDataArea(), edge);\n            setAnchorValue(value);\n            setRangeCrosshairValue(value);\n        }\n\n    }\n\n    /**\n     * Zooms (in or out) on the plot's value axis.\n     * <p>\n     * If the value 0.0 is passed in as the zoom percent, the auto-range\n     * calculation for the axis is restored (which sets the range to include\n     * the minimum and maximum data values, thus displaying all the data).\n     *\n     * @param percent  the zoom amount.\n     */\n    public void zoom(double percent) {\n\n        if (percent > 0.0) {\n            double range = getRangeAxis().getRange().getLength();\n            double scaledRange = range * percent;\n            getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0,\n                    this.anchorValue + scaledRange / 2.0);\n        }\n        else {\n            getRangeAxis().setAutoRange(true);\n        }\n\n    }\n\n    /**\n     * Receives notification of a change to the plot's dataset.\n     * <P>\n     * The range axis bounds will be recalculated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void datasetChanged(DatasetChangeEvent event) {\n\n        int count = this.rangeAxes.size();\n        for (int axisIndex = 0; axisIndex < count; axisIndex++) {\n            ValueAxis yAxis = getRangeAxis(axisIndex);\n            if (yAxis != null) {\n                yAxis.configure();\n            }\n        }\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    public void rendererChanged(RendererChangeEvent event) {\n        Plot parent = getParent();\n        if (parent != null) {\n            if (parent instanceof RendererChangeListener) {\n                RendererChangeListener rcl = (RendererChangeListener) parent;\n                rcl.rendererChanged(event);\n            }\n            else {\n                // this should never happen with the existing code, but throw \n                // an exception in case future changes make it possible...\n                throw new RuntimeException(\n                    \"The renderer has changed and I don't know what to do!\");\n            }\n        }\n        else {\n            configureRangeAxes();\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n    \n    /**\n     * Adds a marker for display (in the foreground) against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a \n     * marker will be drawn by the renderer as a line perpendicular to the \n     * domain axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #removeDomainMarker(Marker)\n     */\n    public void addDomainMarker(CategoryMarker marker) {\n        addDomainMarker(marker, Layer.FOREGROUND); \n    }\n        \n    /**\n     * Adds a marker for display against the domain axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker \n     * will be drawn by the renderer as a line perpendicular to the domain \n     * axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background) (<code>null</code> \n     *               not permitted).\n     *               \n     * @see #removeDomainMarker(Marker, Layer)\n     */\n    public void addDomainMarker(CategoryMarker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a domain axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (<code>null</code> not permitted).\n     * \n     * @see #removeDomainMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer) {\n        addDomainMarker(index, marker, layer, true);\n    }\n    \t\n    /**\n     * Adds a marker for display by a particular renderer and, if requested,\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a domain axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     * \n     * @see #removeDomainMarker(int, Marker, Layer, boolean)\n     */\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears all the domain markers for the plot and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #clearRangeMarkers()\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     * \n     * @return The list of domain markers.\n     */\n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and \n     * layer.\n     * \n     * @param index  the renderer index.\n     * @param layer  the layer.\n     * \n     * @return A collection of markers (possibly <code>null</code>).\n     */\n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Clears all the domain markers for the specified renderer.\n     * \n     * @param index  the renderer index.\n     * \n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker  the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n    \treturn removeDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and, if requested, \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n    \n    /**\n     * Adds a marker for display (in the foreground) against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a \n     * marker will be drawn by the renderer as a line perpendicular to the \n     * range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #removeRangeMarker(Marker)\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND); \n    }\n        \n    /**\n     * Adds a marker for display against the range axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker \n     * will be drawn by the renderer as a line perpendicular to the range axis, \n     * however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background) (<code>null</code> \n     *               not permitted).\n     *               \n     * @see #removeRangeMarker(Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer.\n     * \n     * @see #removeRangeMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n    \taddRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer.\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     * \n     * @see #removeRangeMarker(int, Marker, Layer, boolean)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears all the range markers for the plot and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #clearDomainMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     * \n     * @return The list of range markers.\n     * \n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and \n     * layer.\n     * \n     * @param index  the renderer index.\n     * @param layer  the layer.\n     * \n     * @return A collection of markers (possibly <code>null</code>).\n     */\n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Clears all the range markers for the specified renderer.\n     * \n     * @param index  the renderer index.\n     * \n     * @see #clearDomainMarkers(int)\n     */\n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     * \n     * @see #addRangeMarker(Marker)\n     */\n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     * \n     * @see #addRangeMarker(Marker, Layer)\n     */\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     * \n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    \treturn removeRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     * \n     * @see #addRangeMarker(int, Marker, Layer, boolean)\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairVisible(boolean)\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     *\n     * @param flag  the new value of the flag.\n     * \n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should \n     * \"lock-on\" to actual data values.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     * \n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the domain crosshair value.\n     * <P>\n     * Registered listeners are notified that the plot has been modified, but\n     * only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners (but only if the \n     * crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are \n     *                notified.\n     *                \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the pen-style (<code>Stroke</code>) used to draw the crosshair \n     * (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the pen-style (<code>Stroke</code>) used to draw the range \n     * crosshair (if visible), and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not \n     *         permitted).\n     * \n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the range crosshair.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the range crosshair (if visible) and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations (never <code>null</code>).\n     */\n    public List getAnnotations() {\n        return this.annotations;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * \n     * @see #removeAnnotation(CategoryAnnotation)\n     */\n    public void addAnnotation(CategoryAnnotation annotation) {\n    \taddAnnotation(annotation, true);\n    }\n    \n    /**\n     * Adds an annotation to the plot and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addAnnotation(CategoryAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @see #addAnnotation(CategoryAnnotation)\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n    \treturn removeAnnotation(annotation, true);\n    }\n\n    /**\n     * Removes an annotation from the plot and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @since 1.0.10\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation, \n    \t\tboolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     */\n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     * \n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, \n                                                 Rectangle2D plotArea, \n                                                 AxisSpace space) {\n                                                     \n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(\n                    this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the primary domain axis...\n            RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(\n                    getDomainAxisLocation(), this.orientation);\n            if (this.drawSharedDomainAxis) {\n                space = getDomainAxis().reserveSpace(g2, this, plotArea, \n                        domainEdge, space);\n            }\n            \n            // reserve space for any domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis xAxis = (Axis) this.domainAxes.get(i);\n                if (xAxis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = xAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n                                                     \n    }\n    \n    /**\n     * Calculates the space required for the range axis/axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     * \n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, \n                                                Rectangle2D plotArea, \n                                                AxisSpace space) {\n                                                  \n        if (space == null) {\n            space = new AxisSpace(); \n        }\n        \n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes (if any)...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis yAxis = (Axis) this.rangeAxes.get(i);\n                if (yAxis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = yAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n                                                    \n    }\n\n    /**\n     * Calculates the space required for the axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The space required for the axes.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2, \n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }\n    \n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \n     * printer).\n     * <P>\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\n     * If you do, it will be populated with information about the drawing,\n     * including various plot dimensions and tooltip info.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot (including axes) should \n     *              be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param state  collects info as the chart is drawn (possibly \n     *               <code>null</code>).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, \n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo state) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (state == null) {\n            // if the incoming state is null, no information will be passed\n            // back to the caller - but we create a temporary state to record\n            // the plot area, since that is used later by the axes\n            state = new PlotRenderingInfo(null);\n        }\n        state.setPlotArea(area);\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        // calculate the data area...\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        state.setDataArea(dataArea);\n\n        // if there is a renderer, it draws the background, otherwise use the \n        // default background...\n        if (getRenderer() != null) {\n            getRenderer().drawBackground(g2, this, dataArea);\n        }\n        else {\n            drawBackground(g2, dataArea);\n        }\n       \n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\n\n        // don't let anyone draw outside the data area\n        Shape savedClip = g2.getClip();\n        g2.clip(dataArea);\n\n        drawDomainGridlines(g2, dataArea);\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n        }\n        \n        // draw the markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now render data items...\n        boolean foundData = false;\n\n        // set up the alpha-transparency...\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\n\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n\n            for (int i = 0; i < datasetCount; i++) {\n                foundData = render(g2, dataArea, i, state) || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        else {  // DatasetRenderingOrder.REVERSE\n            \n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n            \n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, state) || foundData;   \n            }\n\n            // draw foreground annotations\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        \n        // draw the foreground markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        // draw the plot's annotations (if any)...\n        drawAnnotations(g2, dataArea, state);\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        // draw range crosshair if required...\n        if (isRangeCrosshairVisible()) {\n            // FIXME: this doesn't handle multiple range axes\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \n                    getRangeCrosshairValue(), getRangeAxis(),\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\n        }\n\n        // draw an outline around the plot area...\n        if (getRenderer() != null) {\n            getRenderer().drawOutline(g2, this, dataArea);\n        }\n        else {\n            drawOutline(g2, dataArea);\n        }\n\n    }\n\n    /**\n     * Draws the plot background (the background color and/or image).\n     * <P>\n     * This method will be called during the chart drawing process and is \n     * declared public so that it can be accessed by the renderers used by \n     * certain subclasses.  You shouldn't need to call this method directly.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     */\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * A utility method for drawing the plot's axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the data area.\n     * @param plotState  collects information about the plot (<code>null</code>\n     *                   permitted).\n     * \n     * @return A map containing the axis states.\n     */\n    protected Map drawAxes(Graphics2D g2, \n                           Rectangle2D plotArea, \n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n            if (xAxis != null) {\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n        \n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.TOP, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY() \n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX() \n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX() \n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.RIGHT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n        \n        return axisStateMap;\n        \n    }\n\n    /**\n     * Draws a representation of a dataset within the dataArea region using the\n     * appropriate renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset and renderer index.\n     * @param info  an optional object for collection dimension information.\n     * \n     * @return A boolean that indicates whether or not real data was found.\n     */\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, \n                          PlotRenderingInfo info) {\n\n        boolean foundData = false;\n        CategoryDataset currentDataset = getDataset(index);\n        CategoryItemRenderer renderer = getRenderer(index);\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\n        if (hasData && renderer != null) {\n            \n            foundData = true;\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea,\n                    this, index, info);\n            int columnCount = currentDataset.getColumnCount();\n            int rowCount = currentDataset.getRowCount();\n            int passCount = renderer.getPassCount();\n            for (int pass = 0; pass < passCount; pass++) {            \n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\n                    for (int column = 0; column < columnCount; column++) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n                else {\n                    for (int column = columnCount - 1; column >= 0; column--) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n        \n    }\n\n    /**\n     * Draws the gridlines for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     * \n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible()) {\n            CategoryAnchor anchor = getDomainGridlinePosition();\n            RectangleEdge domainAxisEdge = getDomainAxisEdge();\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                // iterate over the categories\n                CategoryDataset data = getDataset();\n                if (data != null) {\n                    CategoryAxis axis = getDomainAxis();\n                    if (axis != null) {\n                        int columnCount = data.getColumnCount();\n                        for (int c = 0; c < columnCount; c++) {\n                            double xx = axis.getCategoryJava2DCoordinate(\n                                    anchor, c, columnCount, dataArea, \n                                    domainAxisEdge);\n                            CategoryItemRenderer renderer1 = getRenderer();\n                            if (renderer1 != null) {\n                                renderer1.drawDomainGridline(g2, this, \n                                        dataArea, xx);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n \n    /**\n     * Draws the gridlines for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     * @param ticks  the ticks.\n     * \n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, \n                                      List ticks) {\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                ValueAxis axis = getRangeAxis();\n                if (axis != null) {\n                    Iterator iterator = ticks.iterator();\n                    while (iterator.hasNext()) {\n                        ValueTick tick = (ValueTick) iterator.next();\n                        CategoryItemRenderer renderer1 = getRenderer();\n                        if (renderer1 != null) {\n                            renderer1.drawRangeGridline(g2, this, \n                                    getRangeAxis(), dataArea, tick.getValue());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the annotations.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param info  the plot rendering info (<code>null</code> permitted).\n     */\n    protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n            PlotRenderingInfo info) {\n\n        Iterator iterator = getAnnotations().iterator();\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation \n                    = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this, dataArea, getDomainAxis(), \n                    getRangeAxis(), 0, info);\n        }\n\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is \n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #drawRangeMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                     int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getDomainMarkers(index, layer);\n        CategoryAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                CategoryMarker marker = (CategoryMarker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    /**\n     * Draws the range markers (if any) for an axis and layer.  This method is \n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #drawDomainMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                    int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    /**\n     * Utility method for drawing a line perpendicular to the range axis (used\n     * for crosshairs).\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area defined by the axes.\n     * @param value  the data value.\n     * @param stroke  the line stroke (<code>null</code> not permitted).\n     * @param paint  the line paint (<code>null</code> not permitted).\n     */\n    protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea,\n            double value, Stroke stroke, Paint paint) {\n\n        double java2D = getRangeAxis().valueToJava2D(value, dataArea, \n                getRangeAxisEdge());\n        Line2D line = null;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(java2D, dataArea.getMinY(), java2D, \n                    dataArea.getMaxY());\n        }\n        else if (this.orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), java2D, \n                    dataArea.getMaxX(), java2D);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     * \n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     * \n     * @since 1.0.5\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, \n            PlotOrientation orientation, double value, ValueAxis axis, \n            Stroke stroke, Paint paint) {\n        \n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n        }\n        else {\n            double yy = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n       \n    }\n    \n    /**\n     * Returns the range of data values that will be plotted against the range \n     * axis.  If the dataset is <code>null</code>, this method returns \n     * <code>null</code>.\n     *\n     * @param axis  the axis.\n     *\n     * @return The data range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        \n        int rangeIndex = this.rangeAxes.indexOf(axis);\n        if (rangeIndex >= 0) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\n        }\n        else if (axis == getRangeAxis()) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\n        }\n\n        // iterate through the datasets that map to the axis and get the union \n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset d = (CategoryDataset) iterator.next();\n            CategoryItemRenderer r = getRendererForDataset(d);\n            if (r != null) {\n                result = Range.combine(result, r.findRangeBounds(d));\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns a list of the datasets that are mapped to the axis with the\n     * specified index.\n     * \n     * @param axisIndex  the axis index.\n     * \n     * @return The list (possibly empty, but never <code>null</code>).\n     * \n     * @since 1.0.3\n     */\n    private List datasetsMappedToDomainAxis(int axisIndex) {\n        List result = new ArrayList();\n        for (int datasetIndex = 0; datasetIndex < this.datasets.size(); \n                datasetIndex++) {\n            Object dataset = this.datasets.get(datasetIndex);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToDomainAxisMap.get(\n                        datasetIndex);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (axisIndex == 0) {\n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == axisIndex) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * A utility method that returns a list of datasets that are mapped to a \n     * given range axis.\n     * \n     * @param index  the axis index.\n     * \n     * @return A list of datasets.\n     */\n    private List datasetsMappedToRangeAxis(int index) {\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Object dataset = this.datasets.get(i);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToRangeAxisMap.get(i);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (index == 0) { \n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == index) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;    \n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a \n     * combined plot.\n     *\n     * @return The weight.\n     * \n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param weight  the weight.\n     * \n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedDomainAxisSpace()\n     * \n     * @since 1.0.7\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedRangeAxisSpace()\n     *\n     * @since 1.0.7\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a list of the categories in the plot's primary dataset.\n     * \n     * @return A list of the categories in the plot's primary dataset.\n     * \n     * @see #getCategoriesForAxis(CategoryAxis)\n     */\n    public List getCategories() {\n        List result = null;\n        if (getDataset() != null) {\n            result = Collections.unmodifiableList(getDataset().getColumnKeys());\n        }\n        return result;\n    }\n    \n    /**\n     * Returns a list of the categories that should be displayed for the\n     * specified axis.\n     * \n     * @param axis  the axis (<code>null</code> not permitted)\n     * \n     * @return The categories.\n     * \n     * @since 1.0.3\n     */\n    public List getCategoriesForAxis(CategoryAxis axis) {\n        List result = new ArrayList();\n        int axisIndex = this.domainAxes.indexOf(axis);\n        List datasets = datasetsMappedToDomainAxis(axisIndex);\n        Iterator iterator = datasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset dataset = (CategoryDataset) iterator.next();\n            // add the unique categories from this dataset\n            for (int i = 0; i < dataset.getColumnCount(); i++) {\n                Comparable category = dataset.getColumnKey(i);\n                if (!result.contains(category)) {\n                    result.add(category);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the flag that controls whether or not the shared domain axis is \n     * drawn for each subplot.\n     * \n     * @return A boolean.\n     * \n     * @see #setDrawSharedDomainAxis(boolean)\n     */\n    public boolean getDrawSharedDomainAxis() {\n        return this.drawSharedDomainAxis;\n    }\n    \n    /**\n     * Sets the flag that controls whether the shared domain axis is drawn when\n     * this plot is being used as a subplot.\n     * \n     * @param draw  a boolean.\n     * \n     * @see #getDrawSharedDomainAxis()\n     */\n    public void setDrawSharedDomainAxis(boolean draw) {\n        this.drawSharedDomainAxis = draw;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>false</code> to indicate that the domain axes are not\n     * zoomable.\n     * \n     * @return A boolean.\n     * \n     * @see #isRangeZoomable()\n     */\n    public boolean isDomainZoomable() {\n        return false;\n    }\n    \n    /**\n     * Returns <code>true</code> to indicate that the range axes are zoomable.\n     * \n     * @return A boolean.\n     * \n     * @see #isDomainZoomable()\n     */\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo state, \n                               Point2D source) {\n        // can't zoom domain axis\n    }\n\n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     * \n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomDomainAxes(double lowerPercent, double upperPercent, \n                               PlotRenderingInfo state, Point2D source) {\n        // can't zoom domain axis\n    }\n    \n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     * \n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n        // can't zoom domain axis\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo state, \n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, state, source, false);    \n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     * \n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n                \n        // perform the zoom on each range axis\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot \n                    // orientation\n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     * \n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomRangeAxes(double lowerPercent, double upperPercent, \n                              PlotRenderingInfo state, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n    \n    /**\n     * Returns the anchor value.\n     * \n     * @return The anchor value.\n     * \n     * @see #setAnchorValue(double)\n     */\n    public double getAnchorValue() {\n        return this.anchorValue;\n    }\n\n    /**\n     * Sets the anchor value and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param value  the anchor value.\n     * \n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value) {\n        setAnchorValue(value, true);\n    }\n\n    /**\n     * Sets the anchor value and, if requested, sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param value  the value.\n     * @param notify  notify listeners?\n     * \n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value, boolean notify) {\n        this.anchorValue = value;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n    \n    /** \n     * Tests the plot for equality with an arbitrary object.\n     * \n     * @param obj  the object to test against (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n    \n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n\n        CategoryPlot that = (CategoryPlot) obj;\n            \n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.drawSharedDomainAxis != that.drawSharedDomainAxis) {\n            return false;\n        }\n        if (!this.rangeAxes.equals(that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (this.renderingOrder != that.renderingOrder) {\n            return false;\n        }\n        if (this.columnRenderingOrder != that.columnRenderingOrder) {\n            return false;\n        }\n        if (this.rowRenderingOrder != that.rowRenderingOrder) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.domainGridlinePosition != that.domainGridlinePosition) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (this.anchorValue != that.anchorValue) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData \n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }      \n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedDomainAxisSpace, \n                that.fixedDomainAxisSpace)) {\n            return false;\n        }    \n        if (!ObjectUtilities.equal(this.fixedRangeAxisSpace, \n                that.fixedRangeAxisSpace)) {\n            return false;\n        }    \n        \n        return true;\n        \n    }\n    \n    /**\n     * Returns a clone of the plot.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  if the cloning is not supported.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        \n        CategoryPlot clone = (CategoryPlot) super.clone();\n        \n        clone.domainAxes = new ObjectList();\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\n                clone.setDomainAxis(i, clonedAxis);\n            }\n        }\n        clone.domainAxisLocations \n            = (ObjectList) this.domainAxisLocations.clone();\n\n        clone.rangeAxes = new ObjectList();\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\n                clone.setRangeAxis(i, clonedAxis);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\n\n        clone.datasets = (ObjectList) this.datasets.clone();\n        for (int i = 0; i < clone.datasets.size(); i++) {\n            CategoryDataset dataset = clone.getDataset(i);\n            if (dataset != null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxisMap \n            = (ObjectList) this.datasetToDomainAxisMap.clone();\n        clone.datasetToRangeAxisMap \n            = (ObjectList) this.datasetToRangeAxisMap.clone();\n        clone.renderers = (ObjectList) this.renderers.clone();\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        \n        return clone;\n            \n    }\n    \n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                xAxis.setPlot(this);\n                xAxis.addChangeListener(this);\n            }\n        } \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                yAxis.setPlot(this);   \n                yAxis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            CategoryItemRenderer renderer \n                = (CategoryItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"id\": 1,\n         \"description\": \"Redundant JFreeChart parameter removed from constructors\",\n         \"type\": \"Improvement\",\n         \"version\": \"1.0\"\n      },\n      {\n         \"id\": 2,\n         \"description\": \"DOS encoding problem fixed\",\n         \"type\": \"Bug Fix\",\n         \"version\": \"1.1\"\n      },\n      {\n         \"id\": 3,\n         \"description\": \"Data source classes moved to com.jrefinery.data.*\",\n         \"type\": \"Change\",\n         \"version\": \"1.2\"\n      },\n      {\n         \"id\": 4,\n         \"description\": \"DataSource.java renamed to Dataset.java\",\n         \"type\": \"Change\",\n         \"version\": \"1.3\"\n      },\n      {\n         \"id\": 5,\n         \"description\": \"Intro and trail gaps on bar plots changed to percentage of available space\",\n         \"type\": \"Improvement\",\n         \"version\": \"1.4\"\n      },\n      {\n         \"id\": 6,\n         \"description\": \"Constructors changed to protected\",\n         \"type\": \"Change\",\n         \"version\": \"1.5\"\n      },\n      {\n         \"id\": 7,\n         \"description\": \"Tooltips added\",\n         \"type\": \"Feature\",\n         \"version\": \"1.6\"\n      },\n      {\n         \"id\": 8,\n         \"description\": \"Maximum intro and trail gap percents increased\",\n         \"type\": \"Improvement\",\n         \"version\": \"1.7\"\n      },\n      {\n         \"id\": 9,\n         \"description\": \"Argument checking code added\",\n         \"type\": \"Improvement\",\n         \"version\": \"1.8\"\n      },\n      {\n         \"id\": 10,\n         \"description\": \"Alpha-transparency added for Plot and subclasses\",\n         \"type\": \"Feature\",\n         \"version\": \"1.9\"\n      },\n      {\n         \"id\": 11,\n         \"description\": \"BarPlot.java renamed to CategoryPlot.java\",\n         \"type\": \"Change\",\n         \"version\": \"2.0\"\n      },\n      {\n         \"id\": 12,\n         \"description\": \"CategoryItemRenderer interface used\",\n         \"type\": \"Change\",\n         \"version\": \"2.1\"\n      },\n      {\n         \"id\": 13,\n         \"description\": \"Dataset moved from JFreeChart to Plot class\",\n         \"type\": \"Change\",\n         \"version\": \"2.2\"\n      },\n      {\n         \"id\": 14,\n         \"description\": \"Methods for label visibility and overlaid plot support added\",\n         \"type\": \"Feature\",\n         \"version\": \"2.3\"\n      },\n      {\n         \"id\": 15,\n         \"description\": \"Methods for printing values at the end of bars added\",\n         \"type\": \"Feature\",\n         \"version\": \"2.4\"\n      },\n      {\n         \"id\": 16,\n         \"description\": \"Tooltip generator removed\",\n         \"type\": \"Change\",\n         \"version\": \"2.5\"\n      },\n      {\n         \"id\": 17,\n         \"description\": \"Constants moved to CategoryPlotConstants interface\",\n         \"type\": \"Change\",\n         \"version\": \"2.6\"\n      },\n      {\n         \"id\": 18,\n         \"description\": \"Overridden datasetChanged method added\",\n         \"type\": \"Change\",\n         \"version\": \"2.7\"\n      },\n      {\n         \"id\": 19,\n         \"description\": \"Redundant imports removed\",\n         \"type\": \"Improvement\",\n         \"version\": \"2.8\"\n      },\n      {\n         \"id\": 20,\n         \"description\": \"Marker constructor changed\",\n         \"type\": \"Change\",\n         \"version\": \"2.9\"\n      },\n      {\n         \"id\": 21,\n         \"description\": \"Listener notification added to setDomainAxis and setRangeAxis\",\n         \"type\": \"Change\",\n         \"version\": \"3.0\"\n      },\n      {\n         \"id\": 22,\n         \"description\": \"getLegendItems method added\",\n         \"type\": \"Feature\",\n         \"version\": \"3.1\"\n      },\n      {\n         \"id\": 23,\n         \"description\": \"Changes to CategoryDataset interface\",\n         \"type\": \"Change\",\n         \"version\": \"3.2\"\n      },\n      {\n         \"id\": 24,\n         \"description\": \"Base dataset changed to TableDataset\",\n         \"type\": \"Change\",\n         \"version\": \"3.3\"\n      },\n      {\n         \"id\": 25,\n         \"description\": \"labelXXX methods renamed to valueLabelXXX\",\n         \"type\": \"Change\",\n         \"version\": \"3.4\"\n      },\n      {\n         \"id\": 26,\n         \"description\": \"Grid settings added for both domain and range axis\",\n         \"type\": \"Feature\",\n         \"version\": \"3.5\"\n      },\n      {\n         \"id\": 27,\n         \"description\": \"Axis location parameters added to constructor\",\n         \"type\": \"Change\",\n         \"version\": \"3.6\"\n      },\n      {\n         \"id\": 28,\n         \"description\": \"auto-range calculation for secondary axis fixed\",\n         \"type\": \"Bug Fix\",\n         \"version\": \"3.7\"\n      },\n      {\n         \"id\": 29,\n         \"description\": \"Implemented Serializable\",\n         \"type\": \"Change\",\n         \"version\": \"3.8\"\n      },\n      {\n         \"id\": 30,\n         \"description\": \"render method moved up from subclasses\",\n         \"type\": \"Change\",\n         \"version\": \"3.9\"\n      },\n      {\n         \"id\": 31,\n         \"description\": \"Secondary range markers added\",\n         \"type\": \"Feature\",\n         \"version\": \"4.0\"\n      },\n      {\n         \"id\": 32,\n         \"description\": \"Dataset rendering order attribute added\",\n         \"type\": \"Feature\",\n         \"version\": \"4.1\"\n      },\n      {\n         \"id\": 33,\n         \"description\": \"drawAnnotations method added\",\n         \"type\": \"Feature\",\n         \"version\": \"4.2\"\n      },\n      {\n         \"id\": 34,\n         \"description\": \"Axis location changed to AxisLocation\",\n         \"type\": \"Change\",\n         \"version\": \"4.3\"\n      },\n      {\n         \"id\": 35,\n         \"description\": \"Merged HorizontalCategoryPlot and VerticalCategoryPlot into this class\",\n         \"type\": \"Change\",\n         \"version\": \"4.4\"\n      },\n      {\n         \"id\": 36,\n         \"description\": \"Removed check for range axis compatibility\",\n         \"type\": \"Change\",\n         \"version\": \"4.5\"\n      },\n      {\n         \"id\": 37,\n         \"description\": \"Domain gridline position attribute added\",\n         \"type\": \"Feature\",\n         \"version\": \"4.6\"\n      },\n      {\n         \"id\": 38,\n         \"description\": \"DrawingSupplier moved to Plot superclass\",\n         \"type\": \"Change\",\n         \"version\": \"4.7\"\n      },\n      {\n         \"id\": 39,\n         \"description\": \"equals method added and implemented Cloneable\",\n         \"type\": \"Change\",\n         \"version\": \"4.8\"\n      },\n      {\n         \"id\": 40,\n         \"description\": \"Bug 797466 fixed (no change event when secondary dataset changes)\",\n         \"type\": \"Bug Fix\",\n         \"version\": \"4.9\"\n      },\n      {\n         \"id\": 41,\n         \"description\": \"Bug 795209 fixed (wrong dataset checked in render2 method)\",\n         \"type\": \"Bug Fix\",\n         \"version\": \"5.0\"\n      },\n      {\n         \"id\": 42,\n         \"description\": \"Bug 790407 fixed (initialise method)\",\n         \"type\": \"Bug Fix\",\n         \"version\": \"5.1\"\n      },\n      {\n         \"id\": 43,\n         \"description\": \"Internationalization via use of properties resourceBundle added\",\n         \"type\": \"Feature\",\n         \"version\": \"5.2\"\n      },\n      {\n         \"id\": 44,\n         \"description\": \"Bug (wrong secondary range axis being used) fixed\",\n         \"type\": \"Bug Fix\",\n         \"version\": \"5.3\"\n      },\n      {\n         \"id\": 45,\n         \"description\": \"ValueAxis API changed\",\n         \"type\": \"Change\",\n         \"version\": \"5.4\"\n      },\n      {\n         \"id\": 46,\n         \"description\": \"Bug in setRangeAxis method fixed\",\n         \"type\": \"Bug Fix\",\n         \"version\": \"5.5\"\n      },\n      {\n         \"id\": 47,\n         \"description\": \"Bug in serialization fixed\",\n         \"type\": \"Bug Fix\",\n         \"version\": \"5.6\"\n      },\n      {\n         \"id\": 48,\n         \"description\": \"Implemented PublicCloneable\",\n         \"type\": \"Change\",\n         \"version\": \"5.7\"\n      },\n      {\n         \"id\": 49,\n         \"description\": \"Event notification for changes to renderer added\",\n         \"type\": \"Change\",\n         \"version\": \"5.8\"\n      },\n      {\n         \"id\": 50,\n         \"description\": \"Bug (849645) in clearRangeMarkers method fixed\",\n         \"type\": \"Bug Fix\",\n         \"version\": \"5.9\"\n      },\n      {\n         \"id\": 51,\n         \"description\": \"Modified draw method to accept anchor\",\n         \"type\": \"Change\",\n         \"version\": \"6.0\"\n      }\n   ]\n}"}}