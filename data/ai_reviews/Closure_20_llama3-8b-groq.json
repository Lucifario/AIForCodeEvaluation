{"sample_id": "Closure_20", "model": "llama3-8b-groq", "code_context": "/*\n * Copyright 2010 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.javascript.jscomp.CodingConvention.Bind;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.jstype.TernaryValue;\n\nimport java.util.regex.Pattern;\n\n/**\n * A peephole optimization that minimizes code by simplifying conditional\n * expressions, replacing IFs with HOOKs, replacing object constructors\n * with literals, and simplifying returns.\n *\n */\nclass PeepholeSubstituteAlternateSyntax\n  extends AbstractPeepholeOptimization {\n\n  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n  private static final int NOT_PRECEDENCE = NodeUtil.precedence(Token.NOT);\n\n  private final boolean late;\n\n  private final int STRING_SPLIT_OVERHEAD = \".split('.')\".length();\n\n  static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS =\n    DiagnosticType.error(\n        \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\",\n        \"Invalid flags to RegExp constructor: {0}\");\n\n  static final Predicate<Node> DONT_TRAVERSE_FUNCTIONS_PREDICATE\n      = new Predicate<Node>() {\n    @Override\n    public boolean apply(Node input) {\n      return !input.isFunction();\n    }\n  };\n\n  /**\n   * @param late When late is false, this mean we are currently running before\n   * most of the other optimizations. In this case we would avoid optimizations\n   * that would make the code harder to analyze (such as using string splitting,\n   * merging statements with commas, etc). When this is true, we would\n   * do anything to minimize for size.\n   */\n  PeepholeSubstituteAlternateSyntax(boolean late) {\n    this.late = late;\n  }\n\n  /**\n   * Tries apply our various peephole minimizations on the passed in node.\n   */\n  @Override\n  @SuppressWarnings(\"fallthrough\")\n  public Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n      case Token.RETURN: {\n        Node result = tryRemoveRedundantExit(node);\n        if (result != node) {\n          return result;\n        }\n        result = tryReplaceExitWithBreak(node);\n        if (result != node) {\n          return result;\n        }\n        return tryReduceReturn(node);\n      }\n\n      case Token.THROW: {\n        Node result = tryRemoveRedundantExit(node);\n        if (result != node) {\n          return result;\n        }\n        return tryReplaceExitWithBreak(node);\n      }\n\n      // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps\n      // with MinimizeExitPoints.\n\n      case Token.NOT:\n        tryMinimizeCondition(node.getFirstChild());\n        return tryMinimizeNot(node);\n\n      case Token.IF:\n        tryMinimizeCondition(node.getFirstChild());\n        return tryMinimizeIf(node);\n\n      case Token.EXPR_RESULT:\n        tryMinimizeCondition(node.getFirstChild());\n        return node;\n\n      case Token.HOOK:\n        tryMinimizeCondition(node.getFirstChild());\n        return node;\n\n      case Token.WHILE:\n      case Token.DO:\n        tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n        return node;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(node)) {\n          tryJoinForCondition(node);\n          tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n        }\n        return node;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        return reduceTrueFalse(node);\n\n      case Token.NEW:\n        node = tryFoldStandardConstructors(node);\n        if (!node.isCall()) {\n          return node;\n        }\n        // Fall through on purpose because tryFoldStandardConstructors() may\n        // convert a NEW node into a CALL node\n      case Token.CALL:\n        Node result =  tryFoldLiteralConstructor(node);\n        if (result == node) {\n          result = tryFoldSimpleFunctionCall(node);\n          if (result == node) {\n            result = tryFoldImmediateCallToBoundFunction(node);\n          }\n        }\n        return result;\n\n      case Token.COMMA:\n        return trySplitComma(node);\n\n      case Token.NAME:\n        return tryReplaceUndefined(node);\n\n      case Token.BLOCK:\n        return tryReplaceIf(node);\n\n      case Token.ARRAYLIT:\n        return tryMinimizeArrayLiteral(node);\n\n      default:\n        return node; //Nothing changed\n    }\n  }\n\n  private void tryJoinForCondition(Node n) {\n    if (!late) {\n      return;\n    }\n\n    Node block = n.getLastChild();\n    Node maybeIf = block.getFirstChild();\n    if (maybeIf != null && maybeIf.isIf()) {\n      Node maybeBreak = maybeIf.getChildAtIndex(1).getFirstChild();\n      if (maybeBreak != null && maybeBreak.isBreak()\n          && !maybeBreak.hasChildren()) {\n\n        // Preserve the IF ELSE expression is there is one.\n        if (maybeIf.getChildCount() == 3) {\n          block.replaceChild(maybeIf,\n              maybeIf.getLastChild().detachFromParent());\n        } else {\n          block.removeFirstChild();\n        }\n\n        Node ifCondition = maybeIf.removeFirstChild();\n        Node fixedIfCondition = IR.not(ifCondition)\n            .srcref(ifCondition);\n\n        // OK, join the IF expression with the FOR expression\n        Node forCondition = NodeUtil.getConditionExpression(n);\n        if (forCondition.isEmpty()) {\n          n.replaceChild(forCondition, fixedIfCondition);\n        } else {\n          Node replacement = new Node(Token.AND);\n          n.replaceChild(forCondition, replacement);\n          replacement.addChildToBack(forCondition);\n          replacement.addChildToBack(fixedIfCondition);\n        }\n\n        reportCodeChange();\n      }\n    }\n  }\n\n  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      // Fold String(a) to '' + (a) on immutable literals,\n      // which allows further optimizations\n      //\n      // We can't do this in the general case, because String(a) has\n      // slightly different semantics than '' + (a). See\n      // http://code.google.com/p/closure-compiler/issues/detail?id=759\n      Node value = callTarget.getNext();\n      if (value != null) {\n        Node addition = IR.add(\n            IR.string(\"\").srcref(callTarget),\n            value.detachFromParent());\n        n.getParent().replaceChild(n, addition);\n        reportCodeChange();\n        return addition;\n      }\n    }\n    return n;\n  }\n\n  private Node tryFoldImmediateCallToBoundFunction(Node n) {\n    // Rewriting \"(fn.bind(a,b))()\" to \"fn.call(a,b)\" makes it inlinable\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    Bind bind = getCodingConvention().describeFunctionBind(callTarget, false);\n    if (bind != null) {\n      // replace the call target\n      bind.target.detachFromParent();\n      n.replaceChild(callTarget, bind.target);\n      callTarget = bind.target;\n\n      // push the parameters\n      addParameterAfter(bind.parameters, callTarget);\n\n      // add the this value before the parameters if necessary\n      if (bind.thisValue != null && !NodeUtil.isUndefined(bind.thisValue)) {\n        // rewrite from \"fn(a, b)\" to \"fn.call(thisValue, a, b)\"\n        Node newCallTarget = IR.getprop(\n            callTarget.cloneTree(),\n            IR.string(\"call\").srcref(callTarget));\n        n.replaceChild(callTarget, newCallTarget);\n        n.addChildAfter(bind.thisValue.cloneTree(), newCallTarget);\n        n.putBooleanProp(Node.FREE_CALL, false);\n      } else {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n      reportCodeChange();\n    }\n    return n;\n  }\n\n  private void addParameterAfter(Node parameterList, Node after) {\n    if (parameterList != null) {\n      // push the last parameter to the head of the list first.\n      addParameterAfter(parameterList.getNext(), after);\n      after.getParent().addChildAfter(parameterList.cloneTree(), after);\n    }\n  }\n\n  private Node trySplitComma(Node n) {\n    if (late) {\n      return n;\n    }\n    Node parent = n.getParent();\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n\n    if (parent.isExprResult()\n        && !parent.getParent().isLabel()) {\n      // split comma\n      n.detachChildren();\n      // Replace the original expression with the left operand.\n      parent.replaceChild(n, left);\n      // Add the right expression afterward.\n      Node newStatement = IR.exprResult(right);\n      newStatement.copyInformationFrom(n);\n\n      //This modifies outside the subtree, which is not\n      //desirable in a peephole optimization.\n      parent.getParent().addChildAfter(newStatement, parent);\n      reportCodeChange();\n      return left;\n    } else {\n      return n;\n    }\n  }\n\n  /**\n   * Use \"return x?1:2;\" in place of \"if(x)return 1;return 2;\"\n   */\n  private Node tryReplaceIf(Node n) {\n\n    for (Node child = n.getFirstChild();\n         child != null; child = child.getNext()){\n      if (child.isIf()){\n        Node cond = child.getFirstChild();\n        Node thenBranch = cond.getNext();\n        Node elseBranch = thenBranch.getNext();\n        Node nextNode = child.getNext();\n\n        if (nextNode != null && elseBranch == null\n            && isReturnBlock(thenBranch)\n            && nextNode.isIf()) {\n          Node nextCond = nextNode.getFirstChild();\n          Node nextThen = nextCond.getNext();\n          Node nextElse = nextThen.getNext();\n          if (thenBranch.isEquivalentToTyped(nextThen)) {\n            // Transform\n            //   if (x) return 1; if (y) return 1;\n            // to\n            //   if (x||y) return 1;\n            child.detachFromParent();\n            child.detachChildren();\n            Node newCond = new Node(Token.OR, cond);\n            nextNode.replaceChild(nextCond, newCond);\n            newCond.addChildToBack(nextCond);\n            reportCodeChange();\n          } else if (nextElse != null\n              && thenBranch.isEquivalentToTyped(nextElse)) {\n            // Transform\n            //   if (x) return 1; if (y) foo() else return 1;\n            // to\n            //   if (!x&&y) foo() else return 1;\n            child.detachFromParent();\n            child.detachChildren();\n            Node newCond = new Node(Token.AND,\n                IR.not(cond).srcref(cond));\n            nextNode.replaceChild(nextCond, newCond);\n            newCond.addChildToBack(nextCond);\n            reportCodeChange();\n          }\n        } else if (nextNode != null && elseBranch == null &&\n            isReturnBlock(thenBranch) && isReturnExpression(nextNode)) {\n          Node thenExpr = null;\n          // if(x)return; return 1 -> return x?void 0:1\n          if (isReturnExpressBlock(thenBranch)) {\n            thenExpr = getBlockReturnExpression(thenBranch);\n            thenExpr.detachFromParent();\n          } else {\n            thenExpr = NodeUtil.newUndefinedNode(child);\n          }\n\n          Node elseExpr = nextNode.getFirstChild();\n\n          cond.detachFromParent();\n          elseExpr.detachFromParent();\n\n          Node returnNode = IR.returnNode(\n                                IR.hook(cond, thenExpr, elseExpr)\n                                    .srcref(child));\n          n.replaceChild(child, returnNode);\n          n.removeChild(nextNode);\n          reportCodeChange();\n        } else if (elseBranch != null && statementMustExitParent(thenBranch)) {\n          child.removeChild(elseBranch);\n          n.addChildAfter(elseBranch, child);\n          reportCodeChange();\n        }\n      }\n    }\n    return n;\n  }\n\n  private boolean statementMustExitParent(Node n) {\n    switch (n.getType()) {\n      case Token.THROW:\n      case Token.RETURN:\n        return true;\n      case Token.BLOCK:\n        if (n.hasChildren()) {\n          Node child = n.getLastChild();\n          return statementMustExitParent(child);\n        }\n        return false;\n      // TODO(johnlenz): handle TRY/FINALLY\n      case Token.FUNCTION:\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Use \"void 0\" in place of \"undefined\"\n   */\n  private Node tryReplaceUndefined(Node n) {\n    // TODO(johnlenz): consider doing this as a normalization.\n    if (isASTNormalized()\n        && NodeUtil.isUndefined(n)\n        && !NodeUtil.isLValue(n)) {\n      Node replacement = NodeUtil.newUndefinedNode(n);\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n    return n;\n  }\n\n  /**\n   * Reduce \"return undefined\" or \"return void 0\" to simply \"return\".\n   *\n   * @return The original node, maybe simplified.\n   */\n  private Node tryReduceReturn(Node n) {\n    Node result = n.getFirstChild();\n\n    if (result != null) {\n      switch (result.getType()) {\n        case Token.VOID:\n          Node operand = result.getFirstChild();\n          if (!mayHaveSideEffects(operand)) {\n            n.removeFirstChild();\n            reportCodeChange();\n          }\n          break;\n        case Token.NAME:\n          String name = result.getString();\n          if (name.equals(\"undefined\")) {\n            n.removeFirstChild();\n            reportCodeChange();\n          }\n          break;\n      }\n    }\n\n    return n;\n  }\n\n  /**\n   * Replace duplicate exits in control structures.  If the node following\n   * the exit node expression has the same effect as exit node, the node can\n   * be replaced or removed.\n   * For example:\n   *   \"while (a) {return f()} return f();\" ==> \"while (a) {break} return f();\"\n   *   \"while (a) {throw 'ow'} throw 'ow';\" ==> \"while (a) {break} throw 'ow';\"\n   *\n   * @param n An follow control exit expression (a THROW or RETURN node)\n   * @return The replacement for n, or the original if no change was made.\n   */\n  private Node tryReplaceExitWithBreak(Node n) {\n    Node result = n.getFirstChild();\n\n    // Find the enclosing control structure, if any, that a \"break\" would exit\n    // from.\n    Node breakTarget = n;\n    for (;!ControlFlowAnalysis.isBreakTarget(breakTarget, null /* no label */);\n        breakTarget = breakTarget.getParent()) {\n      if (breakTarget.isFunction() || breakTarget.isScript()) {\n        // No break target.\n        return n;\n      }\n    }\n\n    Node follow = ControlFlowAnalysis.computeFollowNode(breakTarget);\n\n    // Skip pass all the finally blocks because both the break and return will\n    // also trigger all the finally blocks. However, the order of execution is\n    // slightly changed. Consider:\n    //\n    // return a() -> finally { b() } -> return a()\n    //\n    // which would call a() first. However, changing the first return to a\n    // break will result in calling b().\n\n    Node prefinallyFollows = follow;\n    follow = skipFinallyNodes(follow);\n\n    if (prefinallyFollows != follow) {\n      // There were finally clauses\n      if (!isPure(result)) {\n        // Can't defer the exit\n        return n;\n      }\n    }\n\n    if (follow == null && (n.isThrow() || result != null)) {\n      // Can't complete remove a throw here or a return with a result.\n      return n;\n    }\n\n    // When follow is null, this mean the follow of a break target is the\n    // end of a function. This means a break is same as return.\n    if (follow == null || areMatchingExits(n, follow)) {\n      Node replacement = IR.breakNode();\n      n.getParent().replaceChild(n, replacement);\n      this.reportCodeChange();\n      return replacement;\n    }\n\n    return n;\n  }\n\n  /**\n   * Remove duplicate exits.  If the node following the exit node expression\n   * has the same effect as exit node, the node can be removed.\n   * For example:\n   *   \"if (a) {return f()} return f();\" ==> \"if (a) {} return f();\"\n   *   \"if (a) {throw 'ow'} throw 'ow';\" ==> \"if (a) {} throw 'ow';\"\n   *\n   * @param n An follow control exit expression (a THROW or RETURN node)\n   * @return The replacement for n, or the original if no change was made.\n   */\n  private Node tryRemoveRedundantExit(Node n) {\n    Node exitExpr = n.getFirstChild();\n\n    Node follow = ControlFlowAnalysis.computeFollowNode(n);\n\n    // Skip pass all the finally blocks because both the fall through and return\n    // will also trigger all the finally blocks.\n    Node prefinallyFollows = follow;\n    follow = skipFinallyNodes(follow);\n    if (prefinallyFollows != follow) {\n      // There were finally clauses\n      if (!isPure(exitExpr)) {\n        // Can't replace the return\n        return n;\n      }\n    }\n\n    if (follow == null && (n.isThrow() || exitExpr != null)) {\n      // Can't complete remove a throw here or a return with a result.\n      return n;\n    }\n\n    // When follow is null, this mean the follow of a break target is the\n    // end of a function. This means a break is same as return.\n    if (follow == null || areMatchingExits(n, follow)) {\n      n.detachFromParent();\n      reportCodeChange();\n      return null;\n    }\n\n    return n;\n  }\n\n  /**\n   * @return Whether the expression does not produces and can not be affected\n   * by side-effects.\n   */\n  boolean isPure(Node n) {\n    return n == null\n        || (!NodeUtil.canBeSideEffected(n)\n            && !NodeUtil.mayHaveSideEffects(n));\n  }\n\n  /**\n   * @return n or the node following any following finally nodes.\n   */\n  Node skipFinallyNodes(Node n) {\n    while (n != null && NodeUtil.isTryFinallyNode(n.getParent(), n)) {\n      n = ControlFlowAnalysis.computeFollowNode(n);\n    }\n    return n;\n  }\n\n  /**\n   * Check whether one exit can be replaced with another. Verify:\n   * 1) They are identical expressions\n   * 2) If an exception is possible that the statements, the original\n   * and the potential replacement are in the same exception handler.\n   */\n  boolean areMatchingExits(Node nodeThis, Node nodeThat) {\n    return nodeThis.isEquivalentTo(nodeThat)\n        && (!isExceptionPossible(nodeThis)\n            || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));\n  }\n\n  boolean isExceptionPossible(Node n) {\n    // TODO(johnlenz): maybe use ControlFlowAnalysis.mayThrowException?\n    Preconditions.checkState(n.isReturn()\n        || n.isThrow());\n    return n.isThrow()\n        || (n.hasChildren()\n            && !NodeUtil.isLiteralValue(n.getLastChild(), true));\n  }\n\n  Node getExceptionHandler(Node n) {\n    return ControlFlowAnalysis.getExceptionHandler(n);\n  }\n\n  /**\n   * Try to minimize NOT nodes such as !(x==y).\n   *\n   * Returns the replacement for n or the original if no change was made\n   */\n  private Node tryMinimizeNot(Node n) {\n    Node parent = n.getParent();\n\n    Node notChild = n.getFirstChild();\n    // negative operator of the current one : == -> != for instance.\n    int complementOperator;\n    switch (notChild.getType()) {\n      case Token.EQ:\n        complementOperator = Token.NE;\n        break;\n      case Token.NE:\n        complementOperator = Token.EQ;\n        break;\n      case Token.SHEQ:\n        complementOperator = Token.SHNE;\n        break;\n      case Token.SHNE:\n        complementOperator = Token.SHEQ;\n        break;\n      // GT, GE, LT, LE are not handled in this because !(x<NaN) != x>=NaN.\n      default:\n        return n;\n    }\n    Node newOperator = n.removeFirstChild();\n    newOperator.setType(complementOperator);\n    parent.replaceChild(n, newOperator);\n    reportCodeChange();\n    return newOperator;\n  }\n\n  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          Node or = IR.or(\n              cond.removeFirstChild(),\n              expr.removeFirstChild()).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          // One additional set of parentheses is worth the change even if\n          // there is no immediate code size win. However, two extra pair of\n          // {}, we would have to think twice. (unless we know for sure the\n          // we can further optimize its parent.\n          return n;\n        }\n\n        n.removeChild(cond);\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      } else {\n\n        // Try to combine two IF-ELSE\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n              n.detachChildren();\n              n.addChildToBack(\n                  IR.and(\n                      cond,\n                      innerCond.detachFromParent())\n                      .srcref(cond));\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\n              reportCodeChange();\n              // Not worth trying to fold the current IF-ELSE into && because\n              // the inner IF-ELSE wasn't able to be folded into && anyways.\n              return n;\n            }\n          }\n        }\n      }\n\n      return n;\n    }\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size.\n      Node returnNode = IR.returnNode(\n                            IR.hook(cond, thenExpr, elseExpr)\n                                .srcref(n));\n      parent.replaceChild(n, returnNode);\n      reportCodeChange();\n      return returnNode;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              // if LHS has side effects, don't proceed [since the optimization\n              // evaluates LHS before cond]\n              // NOTE - there are some circumstances where we can\n              // proceed even if there are side effects...\n              !mayEffectMutableState(lhs)) {\n\n            n.removeChild(cond);\n            Node assignName = thenOp.removeFirstChild();\n            Node thenExpr = thenOp.removeFirstChild();\n            Node elseExpr = elseOp.getLastChild();\n            elseOp.removeChild(elseExpr);\n\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                              .srcref(thenOp);\n            Node expr = NodeUtil.newExpr(assign);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n\n            return expr;\n          }\n        }\n      }\n      // if(x)foo();else bar(); -> x?foo():bar()\n      n.removeChild(cond);\n      thenOp.detachFromParent();\n      elseOp.detachFromParent();\n      Node expr = IR.exprResult(\n          IR.hook(cond, thenOp, elseOp).srcref(n));\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n      Node name1 = var.getFirstChild();\n      Node maybeName2 = elseAssign.getFirstChild();\n\n      if (name1.hasChildren()\n          && maybeName2.isName()\n          && name1.getString().equals(maybeName2.getString())) {\n        Node thenExpr = name1.removeChildren();\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        var.detachFromParent();\n        name1.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n        return var;\n      }\n\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n      Node maybeName1 = thenAssign.getFirstChild();\n      Node name2 = var.getFirstChild();\n\n      if (name2.hasChildren()\n          && maybeName1.isName()\n          && maybeName1.getString().equals(name2.getString())) {\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n        Node elseExpr = name2.removeChildren();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        var.detachFromParent();\n        name2.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n\n        return var;\n      }\n    }\n\n    return n;\n  }\n\n  /**\n   * Try to remove duplicate statements from IF blocks. For example:\n   *\n   * if (a) {\n   *   x = 1;\n   *   return true;\n   * } else {\n   *   x = 2;\n   *   return true;\n   * }\n   *\n   * becomes:\n   *\n   * if (a) {\n   *   x = 1;\n   * } else {\n   *   x = 2;\n   * }\n   * return true;\n   *\n   * @param n The IF node to examine.\n   */\n  private void tryRemoveRepeatedStatements(Node n) {\n    Preconditions.checkState(n.isIf());\n\n    Node parent = n.getParent();\n    if (!NodeUtil.isStatementBlock(parent)) {\n      // If the immediate parent is something like a label, we\n      // can't move the statement, so bail.\n      return;\n    }\n\n    Node cond = n.getFirstChild();\n    Node trueBranch = cond.getNext();\n    Node falseBranch = trueBranch.getNext();\n    Preconditions.checkNotNull(trueBranch);\n    Preconditions.checkNotNull(falseBranch);\n\n    while (true) {\n      Node lastTrue = trueBranch.getLastChild();\n      Node lastFalse = falseBranch.getLastChild();\n      if (lastTrue == null || lastFalse == null\n          || !areNodesEqualForInlining(lastTrue, lastFalse)) {\n        break;\n      }\n      lastTrue.detachFromParent();\n      lastFalse.detachFromParent();\n      parent.addChildAfter(lastTrue, n);\n      reportCodeChange();\n    }\n  }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an expression.\n   */\n  private boolean isFoldableExpressBlock(Node n) {\n    if (n.isBlock()) {\n      if (n.hasOneChild()) {\n        Node maybeExpr = n.getFirstChild();\n        if (maybeExpr.isExprResult()) {\n          // IE has a bug where event handlers behave differently when\n          // their return value is used vs. when their return value is in\n          // an EXPR_RESULT. It's pretty freaking weird. See:\n          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n          // We try to detect this case, and not fold EXPR_RESULTs\n          // into other expressions.\n          if (maybeExpr.getFirstChild().isCall()) {\n            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n            if (calledFn.isGetElem()) {\n              return false;\n            } else if (calledFn.isGetProp() &&\n                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n        return false;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @return The expression node.\n   */\n  private Node getBlockExpression(Node n) {\n    Preconditions.checkState(isFoldableExpressBlock(n));\n    return n.getFirstChild();\n  }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an return with or without an expression.\n   */\n  private boolean isReturnBlock(Node n) {\n    if (n.isBlock()) {\n      if (n.hasOneChild()) {\n        Node first = n.getFirstChild();\n        return first.isReturn();\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an return.\n   */\n  private boolean isReturnExpressBlock(Node n) {\n    if (n.isBlock()) {\n      if (n.hasOneChild()) {\n        Node first = n.getFirstChild();\n        if (first.isReturn()) {\n          return first.hasOneChild();\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @return Whether the node is a single return statement.\n   */\n  private boolean isReturnExpression(Node n) {\n    if (n.isReturn()) {\n      return n.hasOneChild();\n    }\n    return false;\n  }\n\n  /**\n   * @return The expression that is part of the return.\n   */\n  private Node getBlockReturnExpression(Node n) {\n    Preconditions.checkState(isReturnExpressBlock(n));\n    return n.getFirstChild().getFirstChild();\n  }\n\n  /**\n   * @return Whether the node is a block with a single statement that is\n   *     a VAR declaration of a single variable.\n   */\n  private boolean isVarBlock(Node n) {\n    if (n.isBlock()) {\n      if (n.hasOneChild()) {\n        Node first = n.getFirstChild();\n        if (first.isVar()) {\n          return first.hasOneChild();\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @return The var node.\n   */\n  private Node getBlockVar(Node n) {\n    Preconditions.checkState(isVarBlock(n));\n    return n.getFirstChild();\n  }\n\n  /**\n   * Does a statement consume a 'dangling else'? A statement consumes\n   * a 'dangling else' if an 'else' token following the statement\n   * would be considered by the parser to be part of the statement.\n   */\n  private boolean consumesDanglingElse(Node n) {\n    while (true) {\n      switch (n.getType()) {\n        case Token.IF:\n          if (n.getChildCount() < 3) {\n            return true;\n          }\n          // This IF node has no else clause.\n          n = n.getLastChild();\n          continue;\n        case Token.WITH:\n        case Token.WHILE:\n        case Token.FOR:\n          n = n.getLastChild();\n          continue;\n        default:\n          return false;\n      }\n    }\n  }\n\n  /**\n   * Does the expression contain an operator with lower precedence than\n   * the argument?\n   */\n  private boolean isLowerPrecedenceInExpression(Node n,\n      final int precedence) {\n    Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return NodeUtil.precedence(input.getType()) < precedence;\n      }\n    };\n\n    return NodeUtil.has(n, isLowerPrecedencePredicate,\n        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n  }\n\n  /**\n   * Whether the node type has lower precedence than \"precedence\"\n   */\n  private boolean isLowerPrecedence(Node n, final int precedence) {\n    return NodeUtil.precedence(n.getType()) < precedence;\n  }\n\n  /**\n   * Whether the node type has higher precedence than \"precedence\"\n   */\n  private boolean isHigherPrecedence(Node n, final int precedence) {\n    return NodeUtil.precedence(n.getType()) > precedence;\n  }\n  /**\n   * Does the expression contain a property assignment?\n   */\n  private boolean isPropertyAssignmentInExpression(Node n) {\n    Predicate<Node> isPropertyAssignmentInExpressionPredicate =\n        new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return (input.isGetProp() &&\n            input.getParent().isAssign());\n      }\n    };\n\n    return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,\n        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n  }\n\n  /**\n   * Try to minimize conditions expressions, as there are additional\n   * assumptions that can be made when it is known that the final result\n   * is a boolean.\n   *\n   * The following transformations are done recursively:\n   *   !(x||y) --> !x&&!y\n   *   !(x&&y) --> !x||!y\n   *   !!x     --> x\n   * Thus:\n   *   !(x&&!y) --> !x||!!y --> !x||y\n   *\n   *   Returns the replacement for n, or the original if no change was made\n   */\n  private Node tryMinimizeCondition(Node n) {\n    Node parent = n.getParent();\n\n    switch (n.getType()) {\n      case Token.NOT:\n        Node first = n.getFirstChild();\n        switch (first.getType()) {\n          case Token.NOT: {\n              Node newRoot = first.removeFirstChild();\n              parent.replaceChild(n, newRoot);\n              reportCodeChange();\n              // No need to traverse, tryMinimizeCondition is called on the\n              // NOT children are handled below.\n              return newRoot;\n            }\n          case Token.AND:\n          case Token.OR: {\n              // !(!x && !y) --> x || y\n              // !(!x || !y) --> x && y\n              // !(!x && y) --> x || !y\n              // !(!x || y) --> x && !y\n              // !(x && !y) --> !x || y\n              // !(x || !y) --> !x && y\n              // !(x && y) --> !x || !y\n              // !(x || y) --> !x && !y\n              Node leftParent = first.getFirstChild();\n              Node rightParent = first.getLastChild();\n              Node left, right;\n\n              // Check special case when such transformation cannot reduce\n              // due to the added ()\n              // It only occurs when both of expressions are not NOT expressions\n              if (!leftParent.isNot()\n                  && !rightParent.isNot()) {\n                // If an expression has higher precedence than && or ||,\n                // but lower precedence than NOT, an additional () is needed\n                // Thus we do not preceed\n                int op_precedence = NodeUtil.precedence(first.getType());\n                if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE)\n                    && isHigherPrecedence(leftParent, op_precedence))\n                    || (isLowerPrecedence(rightParent, NOT_PRECEDENCE)\n                    && isHigherPrecedence(rightParent, op_precedence))) {\n                  return n;\n                }\n              }\n\n              if (leftParent.isNot()) {\n                left = leftParent.removeFirstChild();\n              } else {\n                leftParent.detachFromParent();\n                left = IR.not(leftParent).srcref(leftParent);\n              }\n              if (rightParent.isNot()) {\n                right = rightParent.removeFirstChild();\n              } else {\n                rightParent.detachFromParent();\n                right = IR.not(rightParent).srcref(rightParent);\n              }\n\n              int newOp = (first.isAnd()) ? Token.OR : Token.AND;\n              Node newRoot = new Node(newOp, left, right);\n              parent.replaceChild(n, newRoot);\n              reportCodeChange();\n              // No need to traverse, tryMinimizeCondition is called on the\n              // AND and OR children below.\n              return newRoot;\n            }\n\n           default:\n             TernaryValue nVal = NodeUtil.getPureBooleanValue(first);\n             if (nVal != TernaryValue.UNKNOWN) {\n               boolean result = nVal.not().toBoolean(true);\n               int equivalentResult = result ? 1 : 0;\n               return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n        }\n        // No need to traverse, tryMinimizeCondition is called on the NOT\n        // children in the general case in the main post-order traversal.\n        return n;\n\n      case Token.OR:\n      case Token.AND: {\n        Node left = n.getFirstChild();\n        Node right = n.getLastChild();\n\n        // Because the expression is in a boolean context minimize\n        // the children, this can't be done in the general case.\n        left = tryMinimizeCondition(left);\n        right = tryMinimizeCondition(right);\n\n        // Remove useless conditionals\n        // Handle four cases:\n        //   x || false --> x\n        //   x || true  --> true\n        //   x && true --> x\n        //   x && false  --> false\n        TernaryValue rightVal = NodeUtil.getPureBooleanValue(right);\n        if (NodeUtil.getPureBooleanValue(right) != TernaryValue.UNKNOWN) {\n          int type = n.getType();\n          Node replacement = null;\n          boolean rval = rightVal.toBoolean(true);\n\n          // (x || FALSE) => x\n          // (x && TRUE) => x\n          if (type == Token.OR && !rval ||\n              type == Token.AND && rval) {\n            replacement = left;\n          } else if (!mayHaveSideEffects(left)) {\n            replacement = right;\n          }\n\n          if (replacement != null) {\n            n.detachChildren();\n            parent.replaceChild(n, replacement);\n            reportCodeChange();\n            return replacement;\n          }\n        }\n        return n;\n      }\n\n      case Token.HOOK: {\n        Node condition = n.getFirstChild();\n        Node trueNode = n.getFirstChild().getNext();\n        Node falseNode = n.getLastChild();\n\n        // Because the expression is in a boolean context minimize\n        // the result children, this can't be done in the general case.\n        // The condition is handled in the general case in #optimizeSubtree\n        trueNode = tryMinimizeCondition(trueNode);\n        falseNode = tryMinimizeCondition(falseNode);\n\n        // Handle four cases:\n        //   x ? true : false --> x\n        //   x ? false : true --> !x\n        //   x ? true : y     --> x || y\n        //   x ? y : false    --> x && y\n        Node replacement = null;\n        TernaryValue trueNodeVal = NodeUtil.getPureBooleanValue(trueNode);\n        TernaryValue falseNodeVal = NodeUtil.getPureBooleanValue(falseNode);\n        if (trueNodeVal == TernaryValue.TRUE\n            && falseNodeVal == TernaryValue.FALSE) {\n          // Remove useless conditionals, keep the condition\n          condition.detachFromParent();\n          replacement = condition;\n        } else if (trueNodeVal == TernaryValue.FALSE\n            && falseNodeVal == TernaryValue.TRUE) {\n          // Remove useless conditionals, keep the condition\n          condition.detachFromParent();\n          replacement = IR.not(condition);\n        } else if (trueNodeVal == TernaryValue.TRUE) {\n          // Remove useless true case.\n          n.detachChildren();\n          replacement = IR.or(condition, falseNode);\n        } else if (falseNodeVal == TernaryValue.FALSE) {\n          // Remove useless false case\n          n.detachChildren();\n          replacement = IR.and(condition, trueNode);\n        }\n\n        if (replacement != null) {\n          parent.replaceChild(n, replacement);\n          n = replacement;\n          reportCodeChange();\n        }\n\n        return n;\n      }\n\n      default:\n        // while(true) --> while(1)\n        TernaryValue nVal = NodeUtil.getPureBooleanValue(n);\n        if (nVal != TernaryValue.UNKNOWN) {\n          boolean result = nVal.toBoolean(true);\n          int equivalentResult = result ? 1 : 0;\n          return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n        }\n        // We can't do anything else currently.\n        return n;\n    }\n  }\n\n  /**\n   * Replaces a node with a number node if the new number node is not equivalent\n   * to the current node.\n   *\n   * Returns the replacement for n if it was replaced, otherwise returns n.\n   */\n  private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) {\n    Node newNode = IR.number(num);\n    if (!newNode.isEquivalentTo(n)) {\n      parent.replaceChild(n, newNode);\n      reportCodeChange();\n\n      return newNode;\n    }\n\n    return n;\n  }\n\n  private static final ImmutableSet<String> STANDARD_OBJECT_CONSTRUCTORS =\n    // String, Number, and Boolean functions return non-object types, whereas\n    // new String, new Number, and new Boolean return object types, so don't\n    // include them here.\n    ImmutableSet.of(\n      \"Object\",\n      \"Array\",\n      \"RegExp\",\n      \"Error\"\n      );\n\n  /**\n   * Fold \"new Object()\" to \"Object()\".\n   */\n  private Node tryFoldStandardConstructors(Node n) {\n    Preconditions.checkState(n.isNew());\n\n    // If name normalization has been run then we know that\n    // new Object() does in fact refer to what we think it is\n    // and not some custom-defined Object().\n    if (isASTNormalized()) {\n      if (n.getFirstChild().isName()) {\n        String className = n.getFirstChild().getString();\n        if (STANDARD_OBJECT_CONSTRUCTORS.contains(className)) {\n          n.setType(Token.CALL);\n          n.putBooleanProp(Node.FREE_CALL, true);\n          reportCodeChange();\n        }\n      }\n    }\n\n    return n;\n  }\n\n  /**\n   * Replaces a new Array or Object node with an object literal, unless the\n   * call to Array or Object is to a local function with the same name.\n   */\n  private Node tryFoldLiteralConstructor(Node n) {\n    Preconditions.checkArgument(n.isCall()\n        || n.isNew());\n\n    Node constructorNameNode = n.getFirstChild();\n\n    Node newLiteralNode = null;\n\n    // We require the AST to be normalized to ensure that, say,\n    // Object() really refers to the built-in Object constructor\n    // and not a user-defined constructor with the same name.\n\n    if (isASTNormalized() && Token.NAME == constructorNameNode.getType()) {\n\n      String className = constructorNameNode.getString();\n\n      if (\"RegExp\".equals(className)) {\n        // \"RegExp(\"boo\", \"g\")\" --> /boo/g\n        return tryFoldRegularExpressionConstructor(n);\n      } else {\n        boolean constructorHasArgs = constructorNameNode.getNext() != null;\n\n        if (\"Object\".equals(className) && !constructorHasArgs) {\n          // \"Object()\" --> \"{}\"\n          newLiteralNode = IR.objectlit();\n        } else if (\"Array\".equals(className)) {\n          // \"Array(arg0, arg1, ...)\" --> \"[arg0, arg1, ...]\"\n          Node arg0 = constructorNameNode.getNext();\n          FoldArrayAction action = isSafeToFoldArrayConstructor(arg0);\n\n          if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS ||\n              action == FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS) {\n            newLiteralNode = IR.arraylit();\n            n.removeChildren();\n            if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS) {\n              newLiteralNode.addChildrenToFront(arg0);\n            }\n          }\n        }\n\n        if (newLiteralNode != null) {\n          n.getParent().replaceChild(n, newLiteralNode);\n          reportCodeChange();\n          return newLiteralNode;\n        }\n      }\n    }\n    return n;\n  }\n\n  private static enum FoldArrayAction {\n    NOT_SAFE_TO_FOLD, SAFE_TO_FOLD_WITH_ARGS, SAFE_TO_FOLD_WITHOUT_ARGS}\n\n  /**\n   * Checks if it is safe to fold Array() constructor into []. It can be\n   * obviously done, if the initial constructor has either no arguments or\n   * at least two. The remaining case may be unsafe since Array(number)\n   * actually reserves memory for an empty array which contains number elements.\n   */\n  private FoldArrayAction isSafeToFoldArrayConstructor(Node arg) {\n    FoldArrayAction action = FoldArrayAction.NOT_SAFE_TO_FOLD;\n\n    if (arg == null) {\n      action = FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS;\n    } else if (arg.getNext() != null) {\n      action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n    } else {\n      switch (arg.getType()) {\n        case Token.STRING:\n          // \"Array('a')\" --> \"['a']\"\n          action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n          break;\n        case Token.NUMBER:\n          // \"Array(0)\" --> \"[]\"\n          if (arg.getDouble() == 0) {\n            action = FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS;\n          }\n          break;\n        case Token.ARRAYLIT:\n          // \"Array([args])\" --> \"[[args]]\"\n          action = FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS;\n          break;\n        default:\n      }\n    }\n    return action;\n  }\n\n  private Node tryFoldRegularExpressionConstructor(Node n) {\n    Node parent = n.getParent();\n    Node constructor = n.getFirstChild();\n    Node pattern = constructor.getNext();  // e.g.  ^foobar$\n    Node flags = null != pattern ? pattern.getNext() : null;  // e.g. gi\n\n    if (null == pattern || (null != flags && null != flags.getNext())) {\n      // too few or too many arguments\n      return n;\n    }\n\n    if (// is pattern folded\n        pattern.isString()\n        // make sure empty pattern doesn't fold to //\n        && !\"\".equals(pattern.getString())\n\n        // NOTE(nicksantos): Make sure that the regexp isn't longer than\n        // 100 chars, or it blows up the regexp parser in Opera 9.2.\n        && pattern.getString().length() < 100\n\n        && (null == flags || flags.isString())\n        // don't escape patterns with Unicode escapes since Safari behaves badly\n        // (read can't parse or crashes) on regex literals with Unicode escapes\n        && (isEcmaScript5OrGreater()\n            || !containsUnicodeEscape(pattern.getString()))) {\n\n      // Make sure that / is escaped, so that it will fit safely in /brackets/\n      // and make sure that no LineTerminatorCharacters appear literally inside\n      // the pattern.\n      // pattern is a string value with \\\\ and similar already escaped\n      pattern = makeForwardSlashBracketSafe(pattern);\n\n      Node regexLiteral;\n      if (null == flags || \"\".equals(flags.getString())) {\n        // fold to /foobar/\n        regexLiteral = IR.regexp(pattern);\n      } else {\n        // fold to /foobar/gi\n        if (!areValidRegexpFlags(flags.getString())) {\n          error(INVALID_REGULAR_EXPRESSION_FLAGS, flags);\n          return n;\n        }\n        if (!areSafeFlagsToFold(flags.getString())) {\n          return n;\n        }\n        n.removeChild(flags);\n        regexLiteral = IR.regexp(pattern, flags);\n      }\n\n      parent.replaceChild(n, regexLiteral);\n      reportCodeChange();\n      return regexLiteral;\n    }\n\n    return n;\n  }\n\n  private Node reduceTrueFalse(Node n) {\n    if (late) {\n      Node not = IR.not(IR.number(n.isTrue() ? 0 : 1));\n      not.copyInformationFromForTree(n);\n      n.getParent().replaceChild(n, not);\n      reportCodeChange();\n      return not;\n    }\n    return n;\n  }\n\n  private Node tryMinimizeArrayLiteral(Node n) {\n    boolean allStrings = true;\n    for (Node cur = n.getFirstChild(); cur != null; cur = cur.getNext()) {\n      if (!cur.isString()) {\n        allStrings = false;\n      }\n    }\n\n    if (allStrings) {\n      return tryMinimizeStringArrayLiteral(n);\n    } else {\n      return n;\n    }\n  }\n\n  private Node tryMinimizeStringArrayLiteral(Node n) {\n    if(!late) {\n      return n;\n    }\n\n    int numElements = n.getChildCount();\n    // We save two bytes per element.\n    int saving = numElements * 2 - STRING_SPLIT_OVERHEAD;\n    if (saving <= 0) {\n      return n;\n    }\n\n    String[] strings = new String[n.getChildCount()];\n    int idx = 0;\n    for (Node cur = n.getFirstChild(); cur != null; cur = cur.getNext()) {\n      strings[idx++] = cur.getString();\n    }\n\n    // These delimiters are chars that appears a lot in the program therefore\n    // probably have a small Huffman encoding.\n    String delimiter = pickDelimiter(strings);\n    if (delimiter != null) {\n      String template = Joiner.on(delimiter).join(strings);\n      Node call = IR.call(\n          IR.getprop(\n              IR.string(template),\n              IR.string(\"split\")),\n          IR.string(\"\" + delimiter));\n      call.copyInformationFromForTree(n);\n      n.getParent().replaceChild(n, call);\n      reportCodeChange();\n      return call;\n    }\n    return n;\n  }\n\n  /**\n   * Find a delimiter that does not occur in the given strings\n   * @param strings The strings that must be separated.\n   * @return a delimiter string or null\n   */\n  private String pickDelimiter(String[] strings) {\n    boolean allLength1 = true;\n    for (String s : strings) {\n      if (s.length() != 1) {\n        allLength1 = false;\n        break;\n      }\n    }\n\n    if (allLength1) {\n      return \"\";\n    }\n\n    String[] delimiters = new String[]{\" \", \";\", \",\", \"{\", \"}\", null};\n    int i = 0;\n    NEXT_DELIMITER: for (;delimiters[i] != null; i++) {\n      for (String cur : strings) {\n        if (cur.contains(delimiters[i])) {\n          continue NEXT_DELIMITER;\n        }\n      }\n      break;\n    }\n    return delimiters[i];\n  }\n\n  private static final Pattern REGEXP_FLAGS_RE = Pattern.compile(\"^[gmi]*$\");\n\n  /**\n   * are the given flags valid regular expression flags?\n   * JavaScript recognizes several suffix flags for regular expressions,\n   * 'g' - global replace, 'i' - case insensitive, 'm' - multi-line.\n   * They are case insensitive, and JavaScript does not recognize the extended\n   * syntax mode, single-line mode, or expression replacement mode from Perl 5.\n   */\n  private static boolean areValidRegexpFlags(String flags) {\n    return REGEXP_FLAGS_RE.matcher(flags).matches();\n  }\n\n  /**\n   * are the given flags safe to fold?\n   * We don't fold the regular expression if global ('g') flag is on,\n   * because in this case it isn't really a constant: its 'lastIndex'\n   * property contains the state of last execution, so replacing\n   * 'new RegExp('foobar','g')' with '/foobar/g' may change the behavior of\n   * the program if the RegExp is used inside a loop, for example.\n   * <p>\n   * ECMAScript 5 explicitly disallows pooling of regular expression literals so\n   * in ECMAScript 5, {@code /foo/g} and {@code new RegExp('foo', 'g')} are\n   * equivalent.\n   * From section 7.8.5:\n   * \"Then each time the literal is evaluated, a new object is created as if by\n   * the expression new RegExp(Pattern, Flags) where RegExp is the standard\n   * built-in constructor with that name.\"\n   */\n  private boolean areSafeFlagsToFold(String flags) {\n    return isEcmaScript5OrGreater() || flags.indexOf('g') < 0;\n  }\n\n  /**\n   * returns a string node that can safely be rendered inside /brackets/.\n   */\n  private static Node makeForwardSlashBracketSafe(Node n) {\n    String s = n.getString();\n    // sb contains everything in s[0:pos]\n    StringBuilder sb = null;\n    int pos = 0;\n    boolean isEscaped = false, inCharset = false;\n    for (int i = 0; i < s.length(); ++i) {\n      char ch = s.charAt(i);\n      switch (ch) {\n        case '\\\\':\n          isEscaped = !isEscaped;\n          continue;\n        case '/':\n          // Escape a literal forward slash if it is not already escaped and is\n          // not inside a character set.\n          //     new RegExp('/') -> /\\//\n          // but the following do not need extra escaping\n          //     new RegExp('\\\\/') -> /\\//\n          //     new RegExp('[/]') -> /[/]/\n          if (!isEscaped && !inCharset) {\n            if (null == sb) { sb = new StringBuilder(s.length() + 16); }\n            sb.append(s, pos, i).append('\\\\');\n            pos = i;\n          }\n          break;\n        case '[':\n          if (!isEscaped) {\n            inCharset = true;\n          }\n          break;\n        case ']':\n          if (!isEscaped) {\n            inCharset = false;\n          }\n          break;\n        case '\\r': case '\\n': case '\\u2028': case '\\u2029':\n          // LineTerminators cannot appear raw inside a regular\n          // expression literal.\n          // They can't appear legally in a quoted string, but when\n          // the quoted string from\n          //     new RegExp('\\n')\n          // reaches here, the quoting has been removed.\n          // Requote just these code-points.\n          if (null == sb) { sb = new StringBuilder(s.length() + 16); }\n          if (isEscaped) {\n            sb.append(s, pos, i - 1);\n          } else {\n            sb.append(s, pos, i);\n          }\n          switch (ch) {\n            case '\\r': sb.append(\"\\\\r\"); break;\n            case '\\n': sb.append(\"\\\\n\"); break;\n            case '\\u2028': sb.append(\"\\\\u2028\"); break;\n            case '\\u2029': sb.append(\"\\\\u2029\"); break;\n          }\n          pos = i + 1;\n          break;\n      }\n      isEscaped = false;\n    }\n\n    if (null == sb) { return n.cloneTree(); }\n\n    sb.append(s, pos, s.length());\n    return IR.string(sb.toString()).srcref(n);\n  }\n\n  /**\n   * true if the JavaScript string would contain a Unicode escape when written\n   * out as the body of a regular expression literal.\n   */\n  static boolean containsUnicodeEscape(String s) {\n    String esc = CodeGenerator.regexpEscape(s);\n    for (int i = -1; (i = esc.indexOf(\"\\\\u\", i + 1)) >= 0;) {\n      int nSlashes = 0;\n      while (i - nSlashes > 0 && '\\\\' == esc.charAt(i - nSlashes - 1)) {\n        ++nSlashes;\n      }\n      // if there are an even number of slashes before the \\ u then it is a\n      // Unicode literal.\n      if (0 == (nSlashes & 1)) { return true; }\n    }\n    return false;\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"NodeUtil.getConditionExpression(node) may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 245,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 253,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getLastChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 258,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 262,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 267,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 272,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 277,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 282,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 287,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 292,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 297,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 302,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 307,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 312,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 317,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 322,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 327,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 332,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 337,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 342,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 347,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 352,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 357,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 362,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 367,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 372,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 377,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 382,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 387,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 392,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 397,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 402,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 407,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 412,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 417,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 422,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 427,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 432,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 437,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 442,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 447,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 452,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 457,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 462,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 467,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 472,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 477,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 482,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 487,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 492,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 497,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 502,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 507,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 512,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 517,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 522,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 527,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 532,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 537,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 542,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 547,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 552,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 557,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 562,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 567,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 572,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 577,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 582,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 587,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 592,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 597,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 602,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 607,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 612,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 617,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 622,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 627,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 632,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 637,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 642,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 647,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 652,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 657,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 662,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 667,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 672,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 677,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 682,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 687,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 692,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 697,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 702,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 707,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 712,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 717,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 722,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 727,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 732,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 737,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 742,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 747,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 752,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 757,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 762,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 767,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 772,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 777,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 782,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 787,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 792,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 797,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 802,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 807,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 812,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 817,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 822,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 827,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 832,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 837,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 842,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 847,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 852,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 857,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 862,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 867,\n            \"column\": 16\n         }\n      },\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"node.getChildAtIndex(1).getFirstChild() may return null\",\n         \"location\": {\n            \"file\": \"PeepholeSubstituteAlternateSyntax.java\",\n            \"line\": 872,\n            \"column\": 16\n         }\n      }]}"}}