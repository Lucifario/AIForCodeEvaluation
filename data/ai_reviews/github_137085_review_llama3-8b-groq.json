{
  "source_item_id": 137085,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:28:52.713074",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.index.mapper;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.lucene.analysis.TokenStream;\nimport org.apache.lucene.analysis.tokenattributes.CharTermAttribute;\nimport org.apache.lucene.document.Field;\nimport org.apache.lucene.document.FieldType;\nimport org.apache.lucene.document.InvertableType;\nimport org.apache.lucene.document.SortedSetDocValuesField;\nimport org.apache.lucene.document.StoredField;\nimport org.apache.lucene.index.DocValuesSkipIndexType;\nimport org.apache.lucene.index.DocValuesType;\nimport org.apache.lucene.index.IndexOptions;\nimport org.apache.lucene.index.IndexReader;\nimport org.apache.lucene.index.LeafReaderContext;\nimport org.apache.lucene.index.MultiTerms;\nimport org.apache.lucene.index.Term;\nimport org.apache.lucene.index.Terms;\nimport org.apache.lucene.index.TermsEnum;\nimport org.apache.lucene.search.MultiTermQuery;\nimport org.apache.lucene.search.Query;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.automaton.Automata;\nimport org.apache.lucene.util.automaton.Automaton;\nimport org.apache.lucene.util.automaton.CharacterRunAutomaton;\nimport org.apache.lucene.util.automaton.CompiledAutomaton;\nimport org.apache.lucene.util.automaton.CompiledAutomaton.AUTOMATON_TYPE;\nimport org.apache.lucene.util.automaton.Operations;\nimport org.elasticsearch.common.lucene.BytesRefs;\nimport org.elasticsearch.common.lucene.Lucene;\nimport org.elasticsearch.common.lucene.search.AutomatonQueries;\nimport org.elasticsearch.common.unit.Fuzziness;\nimport org.elasticsearch.core.Nullable;\nimport org.elasticsearch.index.IndexMode;\nimport org.elasticsearch.index.IndexSettings;\nimport org.elasticsearch.index.IndexSortConfig;\nimport org.elasticsearch.index.IndexVersion;\nimport org.elasticsearch.index.IndexVersions;\nimport org.elasticsearch.index.analysis.IndexAnalyzers;\nimport org.elasticsearch.index.analysis.LowercaseNormalizer;\nimport org.elasticsearch.index.analysis.NamedAnalyzer;\nimport org.elasticsearch.index.fielddata.FieldData;\nimport org.elasticsearch.index.fielddata.FieldDataContext;\nimport org.elasticsearch.index.fielddata.IndexFieldData;\nimport org.elasticsearch.index.fielddata.SourceValueFetcherSortedBinaryIndexFieldData;\nimport org.elasticsearch.index.fielddata.StoredFieldSortedBinaryIndexFieldData;\nimport org.elasticsearch.index.fielddata.plain.SortedSetOrdinalsIndexFieldData;\nimport org.elasticsearch.index.mapper.blockloader.docvalues.BytesRefsFromOrdsBlockLoader;\nimport org.elasticsearch.index.query.AutomatonQueryWithDescription;\nimport org.elasticsearch.index.query.SearchExecutionContext;\nimport org.elasticsearch.index.similarity.SimilarityProvider;\nimport org.elasticsearch.script.Script;\nimport org.elasticsearch.script.ScriptCompiler;\nimport org.elasticsearch.script.SortedSetDocValuesStringFieldScript;\nimport org.elasticsearch.script.StringFieldScript;\nimport org.elasticsearch.script.field.KeywordDocValuesField;\nimport org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\nimport org.elasticsearch.search.lookup.FieldValues;\nimport org.elasticsearch.search.lookup.SearchLookup;\nimport org.elasticsearch.search.runtime.StringScriptFieldFuzzyQuery;\nimport org.elasticsearch.search.runtime.StringScriptFieldPrefixQuery;\nimport org.elasticsearch.search.runtime.StringScriptFieldRegexpQuery;\nimport org.elasticsearch.search.runtime.StringScriptFieldTermQuery;\nimport org.elasticsearch.search.runtime.StringScriptFieldWildcardQuery;\nimport org.elasticsearch.xcontent.Text;\nimport org.elasticsearch.xcontent.XContentBuilder;\nimport org.elasticsearch.xcontent.XContentParser;\nimport org.elasticsearch.xcontent.XContentString;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Supplier;\n\nimport static org.apache.lucene.index.IndexWriter.MAX_TERM_LENGTH;\nimport static org.elasticsearch.core.Strings.format;\nimport static org.elasticsearch.index.IndexSettings.IGNORE_ABOVE_SETTING;\nimport static org.elasticsearch.index.IndexSettings.USE_DOC_VALUES_SKIPPER;\nimport static org.elasticsearch.index.mapper.FieldArrayContext.getOffsetsFieldName;\nimport static org.elasticsearch.index.mapper.Mapper.IgnoreAbove.getIgnoreAboveDefaultValue;\n\n/**\n * A field mapper for keywords. This mapper accepts strings and indexes them as-is.\n */\npublic final class KeywordFieldMapper extends FieldMapper {\n\n    private static final Logger logger = LogManager.getLogger(KeywordFieldMapper.class);\n\n    public static final String CONTENT_TYPE = \"keyword\";\n    private static final String HOST_NAME = \"host.name\";\n\n    public static class Defaults {\n        public static final FieldType FIELD_TYPE;\n        public static final FieldType FIELD_TYPE_WITH_SKIP_DOC_VALUES;\n\n        static {\n            FieldType ft = new FieldType();\n            ft.setTokenized(false);\n            ft.setOmitNorms(true);\n            ft.setIndexOptions(IndexOptions.DOCS);\n            ft.setDocValuesType(DocValuesType.SORTED_SET);\n            FIELD_TYPE = freezeAndDeduplicateFieldType(ft);\n        }\n\n        static {\n            FieldType ft = new FieldType();\n            ft.setTokenized(false);\n            ft.setOmitNorms(true);\n            ft.setIndexOptions(IndexOptions.NONE);\n            ft.setDocValuesType(DocValuesType.SORTED_SET);\n            ft.setDocValuesSkipIndexType(DocValuesSkipIndexType.RANGE);\n            FIELD_TYPE_WITH_SKIP_DOC_VALUES = freezeAndDeduplicateFieldType(ft);\n        }\n\n        public static final TextSearchInfo TEXT_SEARCH_INFO = new TextSearchInfo(\n            FIELD_TYPE,\n            null,\n            Lucene.KEYWORD_ANALYZER,\n            Lucene.KEYWORD_ANALYZER\n        );\n    }\n\n    public static class KeywordField extends Field {\n\n        public KeywordField(String field, BytesRef term, FieldType ft) {\n            super(field, term, ft);\n        }\n\n        @Override\n        public InvertableType invertableType() {\n            return InvertableType.BINARY;\n        }\n    }\n\n    private static TextSearchInfo textSearchInfo(\n        FieldType fieldType,\n        @Nullable SimilarityProvider similarity,\n        NamedAnalyzer searchAnalyzer,\n        NamedAnalyzer searchQuoteAnalyzer\n    ) {\n        final TextSearchInfo textSearchInfo = new TextSearchInfo(fieldType, similarity, searchAnalyzer, searchQuoteAnalyzer);\n        if (textSearchInfo.equals(Defaults.TEXT_SEARCH_INFO)) {\n            return Defaults.TEXT_SEARCH_INFO;\n        }\n        return textSearchInfo;\n    }\n\n    private static KeywordFieldMapper toType(FieldMapper in) {\n        return (KeywordFieldMapper) in;\n    }\n\n    public static final class Builder extends FieldMapper.DimensionBuilder {\n\n        private final Parameter<Boolean> indexed = Parameter.indexParam(m -> toType(m).indexed, true);\n        private final Parameter<Boolean> hasDocValues = Parameter.docValuesParam(m -> toType(m).hasDocValues, true);\n        private final Parameter<Boolean> stored = Parameter.storeParam(m -> toType(m).fieldType.stored(), false);\n\n        private final Parameter<String> nullValue = Parameter.stringParam(\"null_value\", false, m -> toType(m).fieldType().nullValue, null)\n            .acceptsNull();\n\n        private final Parameter<Boolean> eagerGlobalOrdinals = Parameter.boolParam(\n            \"eager_global_ordinals\"",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The KeywordFieldMapper class has a potential null pointer exception in the constructor when the 'term' parameter is null.\",\n         \"suggested_fix\": \"KeywordField(String field, BytesRef term, FieldType ft) { if (term == null) { term = BytesRef.EMPTY_BYTES; } super(field, term, ft); }\"\n      },\n      {\n         \"explanation\": \"The Builder class has a potential issue with the 'eagerGlobalOrdinals' parameter being a boolean, but it should be a boolean that can be set to true or false, not a boolean that can be set to any value.\",\n         \"suggested_fix\": \"private final Parameter<Boolean> eagerGlobalOrdinals = Parameter.boolParam(\\\"eager_global_ordinals\\\", false, m -> toType(m).eagerGlobalOrdinals, false);\"\n      },\n      {\n         \"explanation\": \"The textSearchInfo method has a potential issue with the 'similarity' parameter being nullable, but it should not be nullable.\",\n         \"suggested_fix\": \"private static TextSearchInfo textSearchInfo(FieldType fieldType, SimilarityProvider similarity, NamedAnalyzer searchAnalyzer, NamedAnalyzer searchQuoteAnalyzer) { if (similarity == null) { similarity = SimilarityProvider.DEFAULT; } final TextSearchInfo textSearchInfo = new TextSearchInfo(fieldType, similarity, searchAnalyzer, searchQuoteAnalyzer);\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs found in the provided code snippet.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The KeywordFieldMapper class has a potential null pointer exception in the constructor when the 'term' parameter is null.",
        "suggested_fix": "KeywordField(String field, BytesRef term, FieldType ft) { if (term == null) { term = BytesRef.EMPTY_BYTES; } super(field, term, ft); }"
      },
      {
        "explanation": "The Builder class has a potential issue with the 'eagerGlobalOrdinals' parameter being a boolean, but it should be a boolean that can be set to true or false, not a boolean that can be set to any value.",
        "suggested_fix": "private final Parameter<Boolean> eagerGlobalOrdinals = Parameter.boolParam(\"eager_global_ordinals\", false, m -> toType(m).eagerGlobalOrdinals, false);"
      },
      {
        "explanation": "The textSearchInfo method has a potential issue with the 'similarity' parameter being nullable, but it should not be nullable.",
        "suggested_fix": "private static TextSearchInfo textSearchInfo(FieldType fieldType, SimilarityProvider similarity, NamedAnalyzer searchAnalyzer, NamedAnalyzer searchQuoteAnalyzer) { if (similarity == null) { similarity = SimilarityProvider.DEFAULT; } final TextSearchInfo textSearchInfo = new TextSearchInfo(fieldType, similarity, searchAnalyzer, searchQuoteAnalyzer);"
      }
    ],
    "no_bugs_reasoning": "No bugs found in the provided code snippet."
  },
  "error": null
}