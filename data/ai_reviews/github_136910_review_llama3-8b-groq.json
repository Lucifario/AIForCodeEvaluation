{
  "source_item_id": 136910,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:42:10.827905",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\npackage org.elasticsearch.index.mapper;\n\nimport org.apache.lucene.document.Field;\nimport org.apache.lucene.document.FieldType;\nimport org.apache.lucene.document.LatLonDocValuesField;\nimport org.apache.lucene.document.LatLonPoint;\nimport org.apache.lucene.document.ShapeField;\nimport org.apache.lucene.document.StoredField;\nimport org.apache.lucene.geo.GeoEncodingUtils;\nimport org.apache.lucene.geo.LatLonGeometry;\nimport org.apache.lucene.index.DocValuesType;\nimport org.apache.lucene.index.LeafReaderContext;\nimport org.apache.lucene.search.IndexOrDocValuesQuery;\nimport org.apache.lucene.search.Query;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.NumericUtils;\nimport org.elasticsearch.ElasticsearchParseException;\nimport org.elasticsearch.common.Explicit;\nimport org.elasticsearch.common.geo.GeoFormatterFactory;\nimport org.elasticsearch.common.geo.GeoPoint;\nimport org.elasticsearch.common.geo.GeoUtils;\nimport org.elasticsearch.common.geo.GeometryFormatterFactory;\nimport org.elasticsearch.common.geo.ShapeRelation;\nimport org.elasticsearch.common.geo.SimpleVectorTileFormatter;\nimport org.elasticsearch.common.unit.DistanceUnit;\nimport org.elasticsearch.core.CheckedConsumer;\nimport org.elasticsearch.core.CheckedFunction;\nimport org.elasticsearch.geometry.Point;\nimport org.elasticsearch.index.IndexMode;\nimport org.elasticsearch.index.IndexVersion;\nimport org.elasticsearch.index.fielddata.FieldDataContext;\nimport org.elasticsearch.index.fielddata.IndexFieldData;\nimport org.elasticsearch.index.fielddata.SourceValueFetcherMultiGeoPointIndexFieldData;\nimport org.elasticsearch.index.fielddata.plain.LatLonPointIndexFieldData;\nimport org.elasticsearch.index.query.SearchExecutionContext;\nimport org.elasticsearch.script.GeoPointFieldScript;\nimport org.elasticsearch.script.Script;\nimport org.elasticsearch.script.ScriptCompiler;\nimport org.elasticsearch.script.SortedNumericDocValuesLongFieldScript;\nimport org.elasticsearch.script.field.GeoPointDocValuesField;\nimport org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\nimport org.elasticsearch.search.aggregations.support.TimeSeriesValuesSourceType;\nimport org.elasticsearch.search.aggregations.support.ValuesSourceType;\nimport org.elasticsearch.search.lookup.FieldValues;\nimport org.elasticsearch.search.lookup.SearchLookup;\nimport org.elasticsearch.search.runtime.GeoPointScriptFieldDistanceFeatureQuery;\nimport org.elasticsearch.xcontent.CopyingXContentParser;\nimport org.elasticsearch.xcontent.FilterXContentParserWrapper;\nimport org.elasticsearch.xcontent.Text;\nimport org.elasticsearch.xcontent.ToXContent;\nimport org.elasticsearch.xcontent.XContentBuilder;\nimport org.elasticsearch.xcontent.XContentParser;\nimport org.elasticsearch.xcontent.XContentString;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport static org.elasticsearch.index.mapper.MappedFieldType.FieldExtractPreference.DOC_VALUES;\n\n/**\n * Field Mapper for geo_point types.\n *\n * Uses lucene 6 LatLonPoint encoding\n */\npublic class GeoPointFieldMapper extends AbstractPointGeometryFieldMapper<GeoPoint> {\n\n    public static final String CONTENT_TYPE = \"geo_point\";\n\n    private static Builder builder(FieldMapper in) {\n        return toType(in).builder;\n    }\n\n    private static GeoPointFieldMapper toType(FieldMapper in) {\n        return (GeoPointFieldMapper) in;\n    }\n\n    public static final class Builder extends FieldMapper.Builder {\n\n        final Parameter<Explicit<Boolean>> ignoreMalformed;\n        final Parameter<Explicit<Boolean>> ignoreZValue = ignoreZValueParam(m -> builder(m).ignoreZValue.get());\n        final Parameter<GeoPoint> nullValue;\n        final Parameter<Boolean> indexed;\n        final Parameter<Boolean> hasDocValues = Parameter.docValuesParam(m -> builder(m).hasDocValues.get(), true);\n        final Parameter<Boolean> stored = Parameter.storeParam(m -> builder(m).stored.get(), false);\n        private final Parameter<Script> script = Parameter.scriptParam(m -> builder(m).script.get());\n        private final Parameter<OnScriptError> onScriptErrorParam = Parameter.onScriptErrorParam(\n            m -> builder(m).onScriptErrorParam.get(),\n            script\n        );\n        final Parameter<Map<String, String>> meta = Parameter.metaParam();\n\n        private final ScriptCompiler scriptCompiler;\n        private final IndexVersion indexCreatedVersion;\n        private final Parameter<TimeSeriesParams.MetricType> metric;  // either null, or POSITION if this is a time series metric\n        private final Parameter<Boolean> dimension; // can only support time_series_dimension: false\n        private final IndexMode indexMode;  // either STANDARD or TIME_SERIES\n\n        public Builder(\n            String name,\n            ScriptCompiler scriptCompiler,\n            boolean ignoreMalformedByDefault,\n            IndexVersion indexCreatedVersion,\n            IndexMode mode\n        ) {\n            super(name);\n            this.ignoreMalformed = ignoreMalformedParam(m -> builder(m).ignoreMalformed.get(), ignoreMalformedByDefault);\n            this.nullValue = nullValueParam(\n                m -> builder(m).nullValue.get(),\n                (n, c, o) -> parseNullValue(o, ignoreZValue.get().value(), ignoreMalformed.get().value()),\n                () -> null,\n                XContentBuilder::field\n            ).acceptsNull();\n            this.scriptCompiler = Objects.requireNonNull(scriptCompiler);\n            this.indexCreatedVersion = Objects.requireNonNull(indexCreatedVersion);\n            this.script.precludesParameters(nullValue, ignoreMalformed, ignoreZValue);\n            this.indexMode = mode;\n            this.indexed = Parameter.indexParam(\n                m -> toType(m).indexed,\n                () -> indexMode != IndexMode.TIME_SERIES || getMetric().getValue() != TimeSeriesParams.MetricType.POSITION\n            );\n            addScriptValidation(script, indexed, hasDocValues);\n\n            this.metric = TimeSeriesParams.metricParam(m -> toType(m).metricType, TimeSeriesParams.MetricType.POSITION).addValidator(v -> {\n                if (v != null && hasDocValues.getValue() == false) {\n                    throw new IllegalArgumentException(\n                        \"Field [\" + TimeSeriesParams.TIME_SERIES_METRIC_PARAM + \"] requires that [\" + hasDocValues.name + \"] is true\"\n                    );\n                }\n            });\n            // We allow `time_series_dimension` parameter to be parsed, but only allow it to be `false`\n            this.dimension = TimeSeriesParams.dimensionParam(m -> false).addValidator(v -> {\n                if (v) {\n                    throw new IllegalArgumentException(\n                        \"Parameter [\" + TimeSeriesParams.TIME_SERIES_DIMENSION_PARAM + \"] cannot be set to geo_point\"\n                    );\n                }\n            });\n        }\n\n        private Parameter<TimeSeriesParams.MetricType> getMetric() {\n            return metric;\n        }\n\n        @Override\n        protected Parameter<?>[] getParameters() {\n            return new Parameter<?>[] {\n                hasDocValues,\n                indexed,\n                stored,\n                ignoreMalformed,\n                ignoreZValue,\n                nullValue,\n                script,\n                onScriptErrorParam,\n                meta,\n                dimension,\n                metric };",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"In the Builder class, the 'dimension' parameter is set to false by default, but it should be set to true to support time_series_dimension: false. This can cause issues with time series data.\",\n         \"suggested_fix\": \"this.dimension = Parameter.dimensionParam(m -> true);\"\n      },\n      {\n         \"explanation\": \"The 'metric' parameter is set to POSITION by default, but it should be set to null or POSITION based on the index mode. This can cause issues with time series data.\",\n         \"suggested_fix\": \"this.metric = TimeSeriesParams.metricParam(m -> indexMode == IndexMode.TIME_SERIES ? null : TimeSeriesParams.MetricType.POSITION);\"\n      },\n      {\n         \"explanation\": \"The 'hasDocValues' parameter is set to true by default, but it should be set to false if the 'dimension' parameter is true. This can cause issues with time series data.\",\n         \"suggested_fix\": \"this.hasDocValues = Parameter.docValuesParam(m -> dimension.getValue() == false);\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "In the Builder class, the 'dimension' parameter is set to false by default, but it should be set to true to support time_series_dimension: false. This can cause issues with time series data.",
        "suggested_fix": "this.dimension = Parameter.dimensionParam(m -> true);"
      },
      {
        "explanation": "The 'metric' parameter is set to POSITION by default, but it should be set to null or POSITION based on the index mode. This can cause issues with time series data.",
        "suggested_fix": "this.metric = TimeSeriesParams.metricParam(m -> indexMode == IndexMode.TIME_SERIES ? null : TimeSeriesParams.MetricType.POSITION);"
      },
      {
        "explanation": "The 'hasDocValues' parameter is set to true by default, but it should be set to false if the 'dimension' parameter is true. This can cause issues with time series data.",
        "suggested_fix": "this.hasDocValues = Parameter.docValuesParam(m -> dimension.getValue() == false);"
      }
    ],
    "no_bugs_reasoning": ""
  },
  "error": null
}