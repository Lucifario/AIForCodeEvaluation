{"sample_id": "Math_67", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.optimization;\n\nimport org.apache.commons.math.ConvergenceException;\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.random.RandomGenerator;\nimport org.apache.commons.math.util.LocalizedFormats;\n\n/**\n * Special implementation of the {@link UnivariateRealOptimizer} interface adding\n * multi-start features to an existing optimizer.\n * <p>\n * This class wraps a classical optimizer to use it several times in\n * turn with different starting points in order to avoid being trapped\n * into a local extremum when looking for a global one.\n * </p>\n * @version $Revision$ $Date$\n * @since 2.0\n */\npublic class MultiStartUnivariateRealOptimizer implements UnivariateRealOptimizer {\n\n    /** Serializable version identifier. */\n    private static final long serialVersionUID = 5983375963110961019L;\n\n    /** Underlying classical optimizer. */\n    private final UnivariateRealOptimizer optimizer;\n\n    /** Maximal number of iterations allowed. */\n    private int maxIterations;\n\n    /** Maximal number of evaluations allowed. */\n    private int maxEvaluations;\n\n    /** Number of iterations already performed for all starts. */\n    private int totalIterations;\n\n    /** Number of evaluations already performed for all starts. */\n    private int totalEvaluations;\n\n    /** Number of starts to go. */\n    private int starts;\n\n    /** Random generator for multi-start. */\n    private RandomGenerator generator;\n\n    /** Found optima. */\n    private double[] optima;\n\n    /** Found function values at optima. */\n    private double[] optimaValues;\n\n    /**\n     * Create a multi-start optimizer from a single-start optimizer\n     * @param optimizer single-start optimizer to wrap\n     * @param starts number of starts to perform (including the\n     * first one), multi-start is disabled if value is less than or\n     * equal to 1\n     * @param generator random generator to use for restarts\n     */\n    public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer,\n                                             final int starts,\n                                             final RandomGenerator generator) {\n        this.optimizer        = optimizer;\n        this.totalIterations  = 0;\n        this.starts           = starts;\n        this.generator        = generator;\n        this.optima           = null;\n        setMaximalIterationCount(Integer.MAX_VALUE);\n        setMaxEvaluations(Integer.MAX_VALUE);\n    }\n\n    /** {@inheritDoc} */\n    public double getFunctionValue() {\n        return optimizer.getFunctionValue();\n    }\n\n    /** {@inheritDoc} */\n    public double getResult() {\n        return optimizer.getResult();\n    }\n\n    /** {@inheritDoc} */\n    public double getAbsoluteAccuracy() {\n        return optimizer.getAbsoluteAccuracy();\n    }\n\n    /** {@inheritDoc} */\n    public int getIterationCount() {\n        return totalIterations;\n    }\n\n    /** {@inheritDoc} */\n    public int getMaximalIterationCount() {\n        return maxIterations;\n    }\n\n    /** {@inheritDoc} */\n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    /** {@inheritDoc} */\n    public int getEvaluations() {\n        return totalEvaluations;\n    }\n\n    /** {@inheritDoc} */\n    public double getRelativeAccuracy() {\n        return optimizer.getRelativeAccuracy();\n    }\n\n    /** {@inheritDoc} */\n    public void resetAbsoluteAccuracy() {\n        optimizer.resetAbsoluteAccuracy();\n    }\n\n    /** {@inheritDoc} */\n    public void resetMaximalIterationCount() {\n        optimizer.resetMaximalIterationCount();\n    }\n\n    /** {@inheritDoc} */\n    public void resetRelativeAccuracy() {\n        optimizer.resetRelativeAccuracy();\n    }\n\n    /** {@inheritDoc} */\n    public void setAbsoluteAccuracy(double accuracy) {\n        optimizer.setAbsoluteAccuracy(accuracy);\n    }\n\n    /** {@inheritDoc} */\n    public void setMaximalIterationCount(int count) {\n        this.maxIterations = count;\n    }\n\n    /** {@inheritDoc} */\n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n\n    /** {@inheritDoc} */\n    public void setRelativeAccuracy(double accuracy) {\n        optimizer.setRelativeAccuracy(accuracy);\n    }\n\n    /** Get all the optima found during the last call to {@link\n     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}.\n     * <p>The optimizer stores all the optima found during a set of\n     * restarts. The {@link #optimize(UnivariateRealFunction, GoalType,\n     * double, double) optimize} method returns the best point only. This\n     * method returns all the points found at the end of each starts,\n     * including the best one already returned by the {@link\n     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n     * method.\n     * </p>\n     * <p>\n     * The returned array as one element for each start as specified\n     * in the constructor. It is ordered with the results from the\n     * runs that did converge first, sorted from best to worst\n     * objective value (i.e in ascending order if minimizing and in\n     * descending order if maximizing), followed by Double.NaN elements\n     * corresponding to the runs that did not converge. This means all\n     * elements will be NaN if the {@link #optimize(UnivariateRealFunction,\n     * GoalType, double, double) optimize} method did throw a {@link\n     * ConvergenceException ConvergenceException}). This also means that\n     * if the first element is not NaN, it is the best point found across\n     * all starts.</p>\n     * @return array containing the optima\n     * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,\n     * GoalType, double, double) optimize} has not been called\n     * @see #getOptimaValues()\n     */\n    public double[] getOptima() throws IllegalStateException {\n        if (optima == null) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optima.clone();\n    }\n\n    /** Get all the function values at optima found during the last call to {@link\n     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}.\n     * <p>\n     * The returned array as one element for each start as specified\n     * in the constructor. It is ordered with the results from the\n     * runs that did converge first, sorted from best to worst\n     * objective value (i.e in ascending order if minimizing and in\n     * descending order if maximizing), followed by Double.NaN elements\n     * corresponding to the runs that did not converge. This means all\n     * elements will be NaN if the {@link #optimize(UnivariateRealFunction,\n     * GoalType, double, double) optimize} method did throw a {@link\n     * ConvergenceException ConvergenceException}). This also means that\n     * if the first element is not NaN, it is the best point found across\n     * all starts.</p>\n     * @return array containing the optima\n     * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,\n     * GoalType, double, double) optimize} has not been called\n     * @see #getOptima()\n     */\n    public double[] getOptimaValues() throws IllegalStateException {\n        if (optimaValues == null) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optimaValues.clone();\n    }\n\n    /** {@inheritDoc} */\n    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n                           final double min, final double max)\n        throws ConvergenceException,\n            FunctionEvaluationException {\n\n        optima           = new double[starts];\n        optimaValues     = new double[starts];\n        totalIterations  = 0;\n        totalEvaluations = 0;\n\n        // multi-start loop\n        for (int i = 0; i < starts; ++i) {\n\n            try {\n                optimizer.setMaximalIterationCount(maxIterations - totalIterations);\n                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n                optima[i]       = optimizer.optimize(f, goalType,\n                                                     Math.min(bound1, bound2),\n                                                     Math.max(bound1, bound2));\n                optimaValues[i] = optimizer.getFunctionValue();\n            } catch (FunctionEvaluationException fee) {\n                optima[i]       = Double.NaN;\n                optimaValues[i] = Double.NaN;\n            } catch (ConvergenceException ce) {\n                optima[i]       = Double.NaN;\n                optimaValues[i] = Double.NaN;\n            }\n\n            totalIterations  += optimizer.getIterationCount();\n            totalEvaluations += optimizer.getEvaluations();\n\n        }\n\n        // sort the optima from best to worst, followed by NaN elements\n        int lastNaN = optima.length;\n        for (int i = 0; i < lastNaN; ++i) {\n            if (Double.isNaN(optima[i])) {\n                optima[i] = optima[--lastNaN];\n                optima[lastNaN + 1] = Double.NaN;\n                optimaValues[i] = optimaValues[--lastNaN];\n                optimaValues[lastNaN + 1] = Double.NaN;\n            }\n        }\n\n        double currX = optima[0];\n        double currY = optimaValues[0];\n        for (int j = 1; j < lastNaN; ++j) {\n            final double prevY = currY;\n            currX = optima[j];\n            currY = optimaValues[j];\n            if ((goalType == GoalType.MAXIMIZE) ^ (currY < prevY)) {\n                // the current element should be inserted closer to the beginning\n                int i = j - 1;\n                double mIX = optima[i];\n                double mIY = optimaValues[i];\n                while ((i >= 0) && ((goalType == GoalType.MAXIMIZE) ^ (currY < mIY))) {\n                    optima[i + 1]       = mIX;\n                    optimaValues[i + 1] = mIY;\n                    if (i-- != 0) {\n                        mIX = optima[i];\n                        mIY = optimaValues[i];\n                    } else {\n                        mIX = Double.NaN;\n                        mIY = Double.NaN;\n                    }\n                }\n                optima[i + 1]       = currX;\n                optimaValues[i + 1] = currY;\n                currX = optima[j];\n                currY = optimaValues[j];\n            }\n        }\n\n        if (Double.isNaN(optima[0])) {\n            throw new OptimizationException(\n                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                    starts);\n        }\n\n        // return the found point given the best objective function value\n        return optima[0];\n\n    }\n\n    /** {@inheritDoc} */\n    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n                           final double min, final double max, final double startValue)\n            throws ConvergenceException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max);\n    }\n}\n", "review": {"response": "{ \"bugs\": [] }"}}