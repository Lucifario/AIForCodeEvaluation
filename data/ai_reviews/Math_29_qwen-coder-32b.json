{"sample_id": "Math_29", "model": "qwen-coder-32b", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math3.linear;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.OpenIntToDoubleHashMap;\nimport org.apache.commons.math3.util.OpenIntToDoubleHashMap.Iterator;\nimport org.apache.commons.math3.util.FastMath;\n\n/**\n * This class implements the {@link RealVector} interface with a\n * {@link OpenIntToDoubleHashMap} backing store.\n * @version $Id$\n * @since 2.0\n*/\npublic class OpenMapRealVector extends SparseRealVector\n    implements Serializable {\n    /** Default Tolerance for having a value considered zero. */\n    public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\n    /** Serializable version identifier. */\n    private static final long serialVersionUID = 8772222695580707260L;\n    /** Entries of the vector. */\n    private final OpenIntToDoubleHashMap entries;\n    /** Dimension of the vector. */\n    private final int virtualSize;\n    /** Tolerance for having a value considered zero. */\n    private final double epsilon;\n\n    /**\n     * Build a 0-length vector.\n     * Zero-length vectors may be used to initialized construction of vectors\n     * by data gathering. We start with zero-length and use either the {@link\n     * #OpenMapRealVector(OpenMapRealVector, int)} constructor\n     * or one of the {@code append} method ({@link #append(double)},\n     * {@link #append(RealVector)}) to gather data into this vector.\n     */\n    public OpenMapRealVector() {\n        this(0, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Construct a vector of zeroes.\n     *\n     * @param dimension Size of the vector.\n     */\n    public OpenMapRealVector(int dimension) {\n        this(dimension, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Construct a vector of zeroes, specifying zero tolerance.\n     *\n     * @param dimension Size of the vector.\n     * @param epsilon Tolerance below which a value considered zero.\n     */\n    public OpenMapRealVector(int dimension, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * Build a resized vector, for use with append.\n     *\n     * @param v Original vector.\n     * @param resize Amount to add.\n     */\n    protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n        virtualSize = v.getDimension() + resize;\n        entries = new OpenIntToDoubleHashMap(v.entries);\n        epsilon = v.epsilon;\n    }\n\n    /**\n     * Build a vector with known the sparseness (for advanced use only).\n     *\n     * @param dimension Size of the vector.\n     * @param expectedSize The expected number of non-zero entries.\n     */\n    public OpenMapRealVector(int dimension, int expectedSize) {\n        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Build a vector with known the sparseness and zero tolerance\n     * setting (for advanced use only).\n     *\n     * @param dimension Size of the vector.\n     * @param expectedSize Expected number of non-zero entries.\n     * @param epsilon Tolerance below which a value is considered zero.\n     */\n    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * Create from an array.\n     * Only non-zero entries will be stored.\n     *\n     * @param values Set of values to create from.\n     */\n    public OpenMapRealVector(double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Create from an array, specifying zero tolerance.\n     * Only non-zero entries will be stored.\n     *\n     * @param values Set of values to create from.\n     * @param epsilon Tolerance below which a value is considered zero.\n     */\n    public OpenMapRealVector(double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key];\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Create from an array.\n     * Only non-zero entries will be stored.\n     *\n     * @param values The set of values to create from\n     */\n    public OpenMapRealVector(Double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }\n\n    /**\n     * Create from an array.\n     * Only non-zero entries will be stored.\n     *\n     * @param values Set of values to create from.\n     * @param epsilon Tolerance below which a value is considered zero.\n     */\n    public OpenMapRealVector(Double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key].doubleValue();\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Copy constructor.\n     *\n     * @param v Instance to copy from.\n     */\n    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }\n\n    /**\n     * Generic copy constructor.\n     *\n     * @param v Instance to copy from.\n     */\n    public OpenMapRealVector(RealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(0.0);\n        epsilon = DEFAULT_ZERO_TOLERANCE;\n        for (int key = 0; key < virtualSize; key++) {\n            double value = v.getEntry(key);\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Get the entries of this instance.\n     *\n     * @return the entries of this instance.\n     */\n    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }\n\n    /**\n     * Determine if this value is within epsilon of zero.\n     *\n     * @param value Value to test\n     * @return {@code true} if this value is within epsilon to zero,\n     * {@code false} otherwise.\n     * @since 2.1\n     */\n    protected boolean isDefaultValue(double value) {\n        return FastMath.abs(value) < epsilon;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public RealVector add(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return add((OpenMapRealVector) v);\n        } else {\n            return super.add(v);\n        }\n    }\n\n    /**\n     * Optimized method to add two OpenMapRealVectors.\n     * It copies the larger vector, then iterates over the smaller.\n     *\n     * @param v Vector to add.\n     * @return the sum of {@code this} and {@code v}.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the dimensions do not match.\n     */\n    public OpenMapRealVector add(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        boolean copyThis = entries.size() > v.entries.size();\n        OpenMapRealVector res = copyThis ? this.copy() : v.copy();\n        Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();\n        OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (randomAccess.containsKey(key)) {\n                res.setEntry(key, randomAccess.get(key) + iter.value());\n            } else {\n                res.setEntry(key, iter.value());\n            }\n        }\n        return res;\n    }\n\n    /**\n     * Optimized method to append a OpenMapRealVector.\n     * @param v vector to append\n     * @return The result of appending {@code v} to self\n     */\n    public OpenMapRealVector append(OpenMapRealVector v) {\n        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n        Iterator iter = v.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key() + virtualSize, iter.value());\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector append(RealVector v) {\n        if (v instanceof OpenMapRealVector) {\n            return append((OpenMapRealVector) v);\n        } else {\n            final OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n            for (int i = 0; i < v.getDimension(); i++) {\n                res.setEntry(i + virtualSize, v.getEntry(i));\n            }\n            return res;\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector append(double d) {\n        OpenMapRealVector res = new OpenMapRealVector(this, 1);\n        res.setEntry(virtualSize, d);\n        return res;\n    }\n\n    /**\n     * {@inheritDoc}\n     * @since 2.1\n     */\n    @Override\n    public OpenMapRealVector copy() {\n        return new OpenMapRealVector(this);\n    }\n\n    /**\n     * Optimized method to compute the dot product with an OpenMapRealVector.\n     * It iterates over the smallest of the two.\n     *\n     * @param v Cector to compute the dot product with.\n     * @return the dot product of {@code this} and {@code v}.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the dimensions do not match.\n     */\n    public double dotProduct(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        boolean thisIsSmaller  = entries.size() < v.entries.size();\n        Iterator iter = thisIsSmaller  ? entries.iterator() : v.entries.iterator();\n        OpenIntToDoubleHashMap larger = thisIsSmaller  ? v.entries : entries;\n        double d = 0;\n        while(iter.hasNext()) {\n            iter.advance();\n            d += iter.value() * larger.get(iter.key());\n        }\n        return d;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double dotProduct(RealVector v) {\n        if(v instanceof OpenMapRealVector) {\n            return dotProduct((OpenMapRealVector)v);\n        } else {\n            return super.dotProduct(v);\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        /*\n         * MATH-803: it is not sufficient to loop through non zero entries of\n         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n         * this[i] / v[i] = NaN, and not 0d.\n         */\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        /*\n         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,\n         * which allows to consider only the non-zero entries of this. However,\n         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).\n         *\n         * These special cases are handled below.\n         */\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector getSubVector(int index, int n) {\n        checkIndex(index);\n        if (n < 0) {\n            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);\n        }\n        checkIndex(index + n - 1);\n        OpenMapRealVector res = new OpenMapRealVector(n);\n        int end = index + n;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (key >= index && key < end) {\n                res.setEntry(key - index, iter.value());\n            }\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int getDimension() {\n        return virtualSize;\n    }\n\n    /**\n     * Optimized method to compute distance.\n     *\n     * @param v Vector to compute distance to.\n     * @return the distance from {@code this} and {@code v}.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the dimensions do not match.\n     */\n    public double getDistance(OpenMapRealVector v) {\n        Iterator iter = entries.iterator();\n        double res = 0;\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            double delta;\n            delta = iter.value() - v.getEntry(key);\n            res += delta * delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                final double value = iter.value();\n                res += value * value;\n            }\n        }\n        return FastMath.sqrt(res);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double getDistance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getDistance((OpenMapRealVector) v);\n        } else {\n            return super.getDistance(v);\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double getEntry(int index) {\n        checkIndex(index);\n        return entries.get(index);\n    }\n\n    /**\n     * Distance between two vectors.\n     * This method computes the distance consistent with\n     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n     * elements differences.\n     *\n     * @param v Vector to which distance is requested.\n     * @return distance between this vector and {@code v}.\n     */\n    public double getL1Distance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n            max += delta;\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                double delta = FastMath.abs(iter.value());\n                max +=  FastMath.abs(delta);\n            }\n        }\n        return max;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double getL1Distance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getL1Distance((OpenMapRealVector) v);\n        } else {\n            return super.getL1Distance(v);\n        }\n    }\n\n    /**\n     * Optimized method to compute LInfDistance.\n     *\n     * @param v Vector to compute distance from.\n     * @return the LInfDistance.\n     */\n    private double getLInfDistance(OpenMapRealVector v) {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));\n            if (delta > max) {\n                max = delta;\n            }\n        }\n        iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (!entries.containsKey(key)) {\n                if (iter.value() > max) {\n                    max = iter.value();\n                }\n            }\n        }\n        return max;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double getLInfDistance(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return getLInfDistance((OpenMapRealVector) v);\n        } else {\n            return super.getLInfDistance(v);\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isInfinite() {\n        boolean infiniteFound = false;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            final double value = iter.value();\n            if (Double.isNaN(value)) {\n                return false;\n            }\n            if (Double.isInfinite(value)) {\n                infiniteFound = true;\n            }\n        }\n        return infiniteFound;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean isNaN() {\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            if (Double.isNaN(iter.value())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector mapAdd(double d) {\n        return copy().mapAddToSelf(d);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector mapAddToSelf(double d) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, getEntry(i) + d);\n        }\n        return this;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public RealVector projection(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setEntry(int index, double value) {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void setSubVector(int index, RealVector v) {\n        checkIndex(index);\n        checkIndex(index + v.getDimension() - 1);\n        for (int i = 0; i < v.getDimension(); i++) {\n            setEntry(i + index, v.getEntry(i));\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void set(double value) {\n        for (int i = 0; i < virtualSize; i++) {\n            setEntry(i, value);\n        }\n    }\n\n    /**\n     * Optimized method to subtract OpenMapRealVectors.\n     *\n     * @param v Vector to subtract from {@code this}.\n     * @return the difference of {@code this} and {@code v}.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the dimensions do not match.\n     */\n    public OpenMapRealVector subtract(OpenMapRealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = copy();\n        Iterator iter = v.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            int key = iter.key();\n            if (entries.containsKey(key)) {\n                res.setEntry(key, entries.get(key) - iter.value());\n            } else {\n                res.setEntry(key, -iter.value());\n            }\n        }\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public RealVector subtract(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        if (v instanceof OpenMapRealVector) {\n            return subtract((OpenMapRealVector) v);\n        } else {\n            return super.subtract(v);\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector unitVector() {\n        OpenMapRealVector res = copy();\n        res.unitize();\n        return res;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void unitize() {\n        double norm = getNorm();\n        if (isDefaultValue(norm)) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            entries.put(iter.key(), iter.value() / norm);\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public double[] toArray() {\n        double[] res = new double[virtualSize];\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res[iter.key()] = iter.value();\n        }\n        return res;\n    }\n\n    /**\n     * {@inheritDoc}\n     * Implementation Note: This works on exact values, and as a result\n     * it is possible for {@code a.subtract(b)} to be the zero vector, while\n     * {@code a.hashCode() != b.hashCode()}.\n     */\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(epsilon);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        result = prime * result + virtualSize;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            temp = Double.doubleToLongBits(iter.value());\n            result = prime * result + (int) (temp ^ (temp >>32));\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     * Implementation Note: This performs an exact comparison, and as a result\n     * it is possible for {@code a.subtract(b}} to be the zero vector, while\n     * {@code  a.equals(b) == false}.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof OpenMapRealVector)) {\n            return false;\n        }\n        OpenMapRealVector other = (OpenMapRealVector) obj;\n        if (virtualSize != other.virtualSize) {\n            return false;\n        }\n        if (Double.doubleToLongBits(epsilon) !=\n            Double.doubleToLongBits(other.epsilon)) {\n            return false;\n        }\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = other.getEntry(iter.key());\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {\n                return false;\n            }\n        }\n        iter = other.getEntries().iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            double test = iter.value();\n            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     *\n     * @return the percentage of none zero elements as a decimal percent.\n     * @since 2.2\n     */\n    public double getSparsity() {\n        return (double)entries.size()/(double)getDimension();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public java.util.Iterator<Entry> sparseIterator() {\n        return new OpenMapSparseIterator();\n    }\n\n    /**\n     * Implementation of {@code Entry} optimized for OpenMap.\n     * This implementation does not allow arbitrary calls to {@code setIndex}\n     * since the order in which entries are returned is undefined.\n     */\n    protected class OpenMapEntry extends Entry {\n        /** Iterator pointing to the entry. */\n        private final Iterator iter;\n\n        /**\n         * Build an entry from an iterator point to an element.\n         *\n         * @param iter Iterator pointing to the entry.\n         */\n        protected OpenMapEntry(Iterator iter) {\n            this.iter = iter;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public double getValue() {\n            return iter.value();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void setValue(double value) {\n            entries.put(iter.key(), value);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int getIndex() {\n            return iter.key();\n        }\n\n    }\n\n    /**\n     * Iterator class to do iteration over just the non-zero elements.\n     * This implementation is fail-fast, so cannot be used to modify\n     * any zero element.\n     */\n    protected class OpenMapSparseIterator implements java.util.Iterator<Entry> {\n        /** Underlying iterator. */\n        private final Iterator iter;\n        /** Current entry. */\n        private final Entry current;\n\n        /** Simple constructor. */\n        protected OpenMapSparseIterator() {\n            iter = entries.iterator();\n            current = new OpenMapEntry(iter);\n        }\n\n        /** {@inheritDoc} */\n        public boolean hasNext() {\n            return iter.hasNext();\n        }\n\n        /** {@inheritDoc} */\n        public Entry next() {\n            iter.advance();\n            return current;\n        }\n\n        /** {@inheritDoc} */\n        public void remove() {\n            throw new UnsupportedOperationException(\"Not supported\");\n        }\n    }\n}\n", "review": {"response": "<think>\nOkay, let me look through this Java code for possible bugs. First, I'll start by reading through the code carefully.\n\nI notice that the class is called OpenMapRealVector, which extends SparseRealVector and implements Serializable. The code uses an OpenIntToDoubleHashMap to store entries. There are several constructors, and methods for creating vectors from arrays. \n\nLooking at the last constructor, the one that takes a Double[] array and a double epsilon. The loop is iterating over the elements, but in the code snippet provided, it ends abruptly with entries```. That looks like a syntax error. The line should be entries.put(key, value); but it's cut off. That's definitely a bug here. The code as written would not compile because the line is incomplete.\n\nAnother thing I notice is that in the method isDefaultValue, which is referenced in the constructors. The method checks if the value is considered default (zero within the tolerance). However, the method isn't shown here, but assuming it's part of the class. But in the code provided, the method isDefaultValue is not present. Wait, looking back at the code, there's no isDefaultValue method shown here. Oh, but maybe it's in the parent class? Since this class extends SparseRealVector, perhaps that method is inherited. However, if it's not present in the code provided, then this would be a bug. But since the code is incomplete, maybe the user didn't include all the code. But in the given code, there's no isDefaultValue method. So if that's missing, that's a problem. However, since the user provided this code, perhaps the method exists elsewhere. But since the code here is cut off in the last constructor, that's a definite issue.\n\nWait, in the last constructor, the code is:\n\nfor (int key = 0; key < values.length; key++) {\n    double value = values[key].doubleValue();\n    if (!isDefaultValue(value)) {\n        entries``` \n\nSo the line ends there. That's a syntax error. The entries.put is missing. So the correct line should be entries.put(key, value);. That's a clear bug.\n\nAnother thing to check is the handling of nulls in the Double[] array. If any element in the Double array is null, then values[key].doubleValue() would throw a NullPointerException. The code doesn't check for null elements. So if the input array has a null, this would cause an NPE at runtime. So that's another potential bug.\n\nLooking at the constructor that takes a double[] array, it uses values[key], which is a primitive double, so no NPE there, but for the Double[] version, there's a risk of NPE if the array contains nulls.\n\nSo, in the OpenMapRealVector(Double[] values, double epsilon) constructor, the code should check if any element is null. For example, if the input array has a null, then values[key].doubleValue() would throw an NPE. To prevent that, the code should handle nulls by treating them as zero or throwing an exception. Since the documentation says \"create from an array\" and the code is supposed to store non-zero entries, perhaps the presence of nulls is considered invalid input. However, the code as written does not check for nulls, leading to a possible NPE.\n\nAnother possible issue is in the constructor where the expectedSize is passed. The OpenIntToDoubleHashMap is initialized with expectedSize and 0.0. But the OpenIntToDoubleHashMap's constructor may require a different parameter. For example, the OpenIntToDoubleHashMap has a constructor that takes an initial capacity and a default value. So if the expectedSize is, say, 5, then the code is passing 5 as the initial capacity, which is correct. But maybe the code is using the wrong parameters. However, without knowing the exact constructor signature of OpenIntToDoubleHashMap, this is hard to say. But given that the code uses new OpenIntToDoubleHashMap(expectedSize, 0.0), perhaps that's correct if the constructor takes (initialCapacity, defaultValue). So that's probably okay.\n\nAnother thing: in the constructor that takes a double[] values, the code initializes entries as new OpenIntToDoubleHashMap(0.0). The OpenIntToDoubleHashMap constructor with a default value of 0.0. That's correct.\n\nNow, looking at the method where the code is cut off. The last constructor's loop is incomplete. That's a syntax error. So the first bug is there.\n\nAnother possible issue: in the protected constructor that takes an OpenMapRealVector and an int resize, it initializes entries with new OpenIntToDoubleHashMap(v.entries). The OpenIntToDoubleHashMap's copy constructor is used here. Assuming that's correct, but if the copy constructor is not properly implemented, that could be an issue. However, that's more of a problem with the OpenIntToDoubleHashMap class itself, not this code.\n\nAlso, in the case of virtualSize being final, but when the vector is resized via the append methods, perhaps the virtualSize is updated correctly. But since the code for append methods isn't shown here, it's hard to say. However, the user is only asking for the provided code, so maybe that's beyond the scope here.\n\nAnother thing: in the constructor that takes a Double[] values, if the array is null, then values.length would throw a NullPointerException. The code doesn't check if the input array is null. Similarly for the double[] constructor. So if the input array is null, the code would throw an NPE. However, the constructor's contract may assume that the input is non-null. If the code is supposed to handle null inputs, then perhaps it should check for null and throw an IllegalArgumentException. But again, the documentation says \"create from an array\", so if the input is null, that's invalid. The current code does not check for null arrays, leading to a possible NPE. However, this might be considered a bug if the code is supposed to handle null inputs gracefully.\n\nBut given that the user is asking for bugs in the provided code, perhaps the main issues are:\n\n1. The last constructor's incomplete line (entries```) causing a syntax error.\n\n2. The Double[] constructor not handling null elements in the array, leading to possible NPE.\n\n3. The Double[] constructor not handling a null input array, leading to NPE.\n\nSo, the bugs would be:\n\n- In the constructor public OpenMapRealVector(Double[] values, double epsilon), the loop ends with entries``` which is a syntax error. The line should be entries.put(key, value);.\n\n- In the same constructor, if any element in the values array is null, then values[key].doubleValue() will throw a NullPointerException. The code should check for null elements.\n\n- Also, if the values array is null, then the code will throw a NullPointerException when accessing values.length. The code should check if the input array is null and handle it.\n\nSo, the JSON response should list these bugs.\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"line_number\": 205,\n      \"description\": \"Incomplete line in the constructor for Double[] values. The line 'entries```' is missing the method call and parameters. It should be 'entries.put(key, value);'. This causes a syntax error.\"\n    },\n    {\n      \"line_number\": 207,\n      \"description\": \"Potential NullPointerException if the input Double[] array contains null elements. The code does not check for null values before calling doubleValue() on elements of the array.\"\n    },\n    {\n      \"line_number\": 194,\n      \"description\": \"Potential NullPointerException if the input Double[] array is null. The code accesses 'values.length' without checking if 'values' is null.\"\n    }\n  ]\n}\n```"}}