{"sample_id": "Closure_10", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Maps;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.InputId;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.TokenStream;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.rhino.jstype.StaticSourceFile;\nimport com.google.javascript.rhino.jstype.TernaryValue;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.annotation.Nullable;\n\n/**\n * NodeUtil contains generally useful AST utilities.\n *\n */\npublic final class NodeUtil {\n\n  static final long MAX_POSITIVE_INTEGER_NUMBER = (long) Math.pow(2, 53);\n\n  static final String JSC_PROPERTY_NAME_FN = \"JSCompiler_renameProperty\";\n\n  static final char LARGEST_BASIC_LATIN = 0x7f;\n\n  /** the set of builtin constructors that don't have side effects. */\n  private static final Set<String> CONSTRUCTORS_WITHOUT_SIDE_EFFECTS =\n      new HashSet<String>(Arrays.asList(\n        \"Array\",\n        \"Date\",\n        \"Error\",\n        \"Object\",\n        \"RegExp\",\n        \"XMLHttpRequest\"));\n\n  // Utility class; do not instantiate.\n  private NodeUtil() {}\n\n  /**\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   */\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        // For ASSIGN and COMMA the value is the value of the RHS.\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR:  {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK:  {\n        TernaryValue trueValue = getImpureBooleanValue(\n            n.getFirstChild().getNext());\n        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n        if (trueValue.equals(falseValue)) {\n          return trueValue;\n        } else {\n          return TernaryValue.UNKNOWN;\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // ignoring side-effects\n        return TernaryValue.TRUE;\n\n      case Token.VOID:\n        return TernaryValue.FALSE;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function\n   * except it return UNKNOWN for known values with side-effects, use\n   * getExpressionBooleanValue if you don't care about side-effects.\n   */\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n.getFirstChild())) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          // We assume here that programs don't change the value of the keyword\n          // undefined to something other than the value undefined.\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n\n  /**\n   * Gets the value of a node as a String, or null if it cannot be converted.\n   * When it returns a non-null String, this method effectively emulates the\n   * <code>String()</code> JavaScript cast function.\n   */\n  static String getStringValue(Node n) {\n    // TODO(user): regex literals as well.\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.STRING_KEY:\n        return n.getString();\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name)) {\n          return name;\n        }\n        break;\n\n      case Token.NUMBER:\n        return getStringValue(n.getDouble());\n\n      case Token.FALSE:\n        return \"false\";\n\n      case Token.TRUE:\n        return \"true\";\n\n      case Token.NULL:\n        return \"null\";\n\n      case Token.VOID:\n        return \"undefined\";\n\n      case Token.NOT:\n        TernaryValue child = getPureBooleanValue(n.getFirstChild());\n        if (child != TernaryValue.UNKNOWN) {\n          return child.toBoolean(true) ? \"false\" : \"true\"; // reversed.\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        return arrayToString(n);\n\n      case Token.OBJECTLIT:\n        return \"[object Object]\";\n    }\n    return null;\n  }\n\n  static String getStringValue(double value) {\n    long longValue = (long) value;\n\n    // Return \"1\" instead of \"1.0\"\n    if (longValue == value) {\n      return Long.toString(longValue);\n    } else {\n      return Double.toString(value);\n    }\n  }\n\n  /**\n   * When converting arrays to string using Array.prototype.toString or\n   * Array.prototype.join, the rules for conversion to String are different\n   * than converting each element individually.  Specifically, \"null\" and\n   * \"undefined\" are converted to an empty string.\n   * @param n A node that is a member of an Array.\n   * @return The string representation.\n   */\n  static String getArrayElementStringValue(Node n) {\n    return (NodeUtil.isNullOrUndefined(n) || n.isEmpty())\n        ? \"\" : getStringValue(n);\n  }\n\n  static String arrayToString(Node literal) {\n    Node first = literal.getFirstChild();\n    StringBuilder result = new StringBuilder();\n    int nextSlot = 0;\n    int nextSkipSlot = 0;\n    for (Node n = first; n != null; n = n.getNext()) {\n      String childValue = getArrayElementStringValue(n);\n      if (childValue == null) {\n        return null;\n      }\n      if (n != first) {\n        result.append(',');\n      }\n      result.append(childValue);\n\n      nextSlot++;\n    }\n    return result.toString();\n  }\n\n  /**\n   * Gets the value of a node as a Number, or null if it cannot be converted.\n   * When it returns a non-null Double, this method effectively emulates the\n   * <code>Number()</code> JavaScript cast function.\n   */\n  static Double getNumberValue(Node n) {\n    switch (n.getType()) {\n      case Token.TRUE:\n        return 1.0;\n\n      case Token.FALSE:\n      case Token.NULL:\n        return 0.0;\n\n      case Token.NUMBER:\n        return n.getDouble();\n\n      case Token.VOID:\n        if (mayHaveSideEffects(n.getFirstChild())) {\n          return null;\n        } else {\n          return Double.NaN;\n        }\n\n      case Token.NAME:\n        // Check for known constants\n        String name = n.getString();\n        if (name.equals(\"undefined\")) {\n          return Double.NaN;\n        }\n        if (name.equals(\"NaN\")) {\n          return Double.NaN;\n        }\n        if (name.equals(\"Infinity\")) {\n          return Double.POSITIVE_INFINITY;\n        }\n        return null;\n\n      case Token.NEG:\n        if (n.getChildCount() == 1 && n.getFirstChild().isName()\n            && n.getFirstChild().getString().equals(\"Infinity\")) {\n          return Double.NEGATIVE_INFINITY;\n        }\n        return null;\n\n      case Token.NOT:\n        TernaryValue child = getPureBooleanValue(n.getFirstChild());\n        if (child != TernaryValue.UNKNOWN) {\n          return child.toBoolean(true) ? 0.0 : 1.0; // reversed.\n        }\n        break;\n\n      case Token.STRING:\n        return getStringNumberValue(n.getString());\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        String value = getStringValue(n);\n        return value != null ? getStringNumberValue(value) : null;\n    }\n\n    return null;\n  }\n\n  static Double getStringNumberValue(String rawJsString) {\n    if (rawJsString.contains(\"\\u000b\")) {\n      // vertical tab is not always whitespace\n      return null;\n    }\n\n    String s = trimJsWhiteSpace(rawJsString);\n    // return ScriptRuntime.toNumber(s);\n    if (s.length() == 0) {\n      return 0.0;\n    }\n\n    if (s.length() > 2\n        && s.charAt(0) == '0'\n        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n      // Attempt to convert hex numbers.\n      try {\n        return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n      } catch (NumberFormatException e) {\n        return Double.NaN;\n      }\n    }\n\n    if (s.length() > 3\n        && (s.charAt(0) == '-' || s.charAt(0) == '+')\n        && s.charAt(1) == '0'\n        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n      // hex numbers with explicit signs vary between browsers.\n      return null;\n    }\n\n    // Firefox and IE treat the \"Infinity\" differently. Firefox is case\n    // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n    if (s.equals(\"infinity\")\n        || s.equals(\"-infinity\")\n        || s.equals(\"+infinity\")) {\n      return null;\n    }\n\n    try {\n      return Double.parseDouble(s);\n    } catch (NumberFormatException e) {\n      return Double.NaN;\n    }\n  }\n\n  static String trimJsWhiteSpace(String s) {\n    int start = 0;\n    int end = s.length();\n    while (end > 0\n        && isStrWhiteSpaceChar(s.charAt(end - 1)) == TernaryValue.TRUE) {\n      end--;\n    }\n    while (start < end\n        && isStrWhiteSpaceChar(s.charAt(start)) == TernaryValue.TRUE) {\n      start++;\n    }\n    return s.substring(start, end);\n  }\n\n  /**\n   * Copied from Rhino's ScriptRuntime\n   */\n  public static TernaryValue isStrWhiteSpaceChar(int c) {\n    switch (c) {\n      case '\\u000B': // <VT>\n        return TernaryValue.UNKNOWN;  // IE says \"no\", ECMAScript says \"yes\"\n      case ' ': // <SP>\n      case '\\n': // <LF>\n      case '\\r': // <CR>\n      case '\\t': // <TAB>\n      case '\\u00A0': // <NBSP>\n      case '\\u000C': // <FF>\n      case '\\u2028': // <LS>\n      case '\\u2029': // <PS>\n      case '\\uFEFF': // <BOM>\n        return TernaryValue.TRUE;\n      default:\n        return (Character.getType(c) == Character.SPACE_SEPARATOR)\n            ? TernaryValue.TRUE : TernaryValue.FALSE;\n    }\n  }\n\n  /**\n   * Gets the function's name. This method recognizes five forms:\n   * <ul>\n   * <li>{@code function name() ...}</li>\n   * <li>{@code var name = function() ...}</li>\n   * <li>{@code qualified.name = function() ...}</li>\n   * <li>{@code var name2 = function name1() ...}</li>\n   * <li>{@code qualified.name2 = function name1() ...}</li>\n   * </ul>\n   * In two last cases with named function expressions, the second name is\n   * returned (the variable of qualified name).\n   *\n   * @param n a node whose type is {@link Token#FUNCTION}\n   * @return the function's name, or {@code null} if it has no name\n   */\n  static String getFunctionName(Node n) {\n    Preconditions.checkState(n.isFunction());\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.NAME:\n        // var name = function() ...\n        // var name2 = function name1() ...\n        return parent.getQualifiedName();\n\n      case Token.ASSIGN:\n        // qualified.name = function() ...\n        // qualified.name2 = function name1() ...\n        return parent.getFirstChild().getQualifiedName();\n\n      default:\n        // function name() ...\n        String name = n.getFirstChild().getQualifiedName();\n        return name;\n    }\n  }\n\n  /**\n   * Gets the function's name. This method recognizes the forms:\n   * <ul>\n   * <li>{@code &#123;'name': function() ...&#125;}</li>\n   * <li>{@code &#123;name: function() ...&#125;}</li>\n   * <li>{@code function name() ...}</li>\n   * <li>{@code var name = function() ...}</li>\n   * <li>{@code qualified.name = function() ...}</li>\n   * <li>{@code var name2 = function name1() ...}</li>\n   * <li>{@code qualified.name2 = function name1() ...}</li>\n   * </ul>\n   *\n   * @param n a node whose type is {@link Token#FUNCTION}\n   * @return the function's name, or {@code null} if it has no name\n   */\n  public static String getNearestFunctionName(Node n) {\n    if (!n.isFunction()) {\n      return null;\n    }\n\n    String name = getFunctionName(n);\n    if (name != null) {\n      return name;\n    }\n\n    // Check for the form { 'x' : function() { } }\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.SETTER_DEF:\n      case Token.GETTER_DEF:\n      case Token.STRING_KEY:\n        // Return the name of the literal's key.\n        return parent.getString();\n      case Token.NUMBER:\n        return getStringValue(parent);\n    }\n\n    return null;\n  }\n\n\n  /**\n   * Returns true if this is an immutable value.\n   */\n  static boolean isImmutableValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n      case Token.NOT:\n        return isImmutableValue(n.getFirstChild());\n      case Token.VOID:\n      case Token.NEG:\n        return isImmutableValue(n.getFirstChild());\n      case Token.NAME:\n        String name = n.getString();\n        // We assume here that programs don't change the value of the keyword\n        // undefined to something other than the value undefined.\n        return \"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name);\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns true if the operator on this node is symmetric\n   */\n  static boolean isSymmetricOperation(Node n) {\n    switch (n.getType()) {\n      case Token.EQ: // equal\n      case Token.NE: // not equal\n      case Token.SHEQ: // exactly equal\n      case Token.SHNE: // exactly not equal\n      case Token.MUL: // multiply, unlike add it only works on numbers\n                      // or results NaN if any of the operators is not a number\n        return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if the operator on this node is relational.\n   * the returned set does not include the equalities.\n   */\n  static boolean isRelationalOperation(Node n) {\n    switch (n.getType()) {\n      case Token.GT: // equal\n      case Token.GE: // not equal\n      case Token.LT: // exactly equal\n      case Token.LE: // exactly not equal\n        return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns the inverse of an operator if it is invertible.\n   * ex. '>' ==> '<'\n   */\n  static int getInverseOperator(int type) {\n    switch (type) {\n      case Token.GT:\n        return Token.LT;\n      case Token.LT:\n        return Token.GT;\n      case Token.GE:\n        return Token.LE;\n      case Token.LE:\n        return Token.GE;\n    }\n    return Token.ERROR;\n  }\n\n  /**\n   * Returns true if this is a literal value. We define a literal value\n   * as any node that evaluates to the same thing regardless of when or\n   * where it is evaluated. So /xyz/ and [3, 5] are literals, but\n   * the name a is not.\n   *\n   * Function literals do not meet this definition, because they\n   * lexically capture variables. For example, if you have\n   * <code>\n   * function() { return a; }\n   * </code>\n   * If it is evaluated in a different scope, then it\n   * captures a different variable. Even if the function did not read\n   * any captured variables directly, it would still fail this definition,\n   * because it affects the lifecycle of variables in the enclosing scope.\n   *\n   * However, a function literal with respect to a particular scope is\n   * a literal.\n   *\n   * @param includeFunctions If true, all function expressions will be\n   *     treated as literals.\n   */\n  static boolean isLiteralValue(Node n, boolean includeFunctions) {\n    switch (n.getType()) {\n      case Token.ARRAYLIT:\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if ((!child.isEmpty()) && !isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.REGEXP:\n        // Return true only if all children are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.OBJECTLIT:\n        // Return true only if all values are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.FUNCTION:\n        return includeFunctions && !NodeUtil.isFunctionDeclaration(n);\n\n      default:\n        return isImmutableValue(n);\n    }\n  }\n\n  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Binary operators are only valid if both children are valid.\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return isValidDefineValue(val.getFirstChild(), defines)\n            && isValidDefineValue(val.getLastChild(), defines);\n\n      // Unary operators are valid if the child is valid.\n      case Token.NOT:\n      case Token.NEG:\n      case Token.POS:\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Names are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n    }\n    return false;\n  }\n\n  /**\n   * Returns whether this a BLOCK node with no children.\n   *\n   * @param block The node.\n   */\n  static boolean isEmptyBlock(Node block) {\n    if (!block.isBlock()) {\n      return false;\n    }\n\n    for (Node n = block.getFirstChild(); n != null; n = n.getNext()) {\n      if (!n.isEmpty()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  static boolean isSimpleOperator(Node n) {\n    return isSimpleOperatorType(n.getType());\n  }\n\n  /**\n   * A \"simple\" operator is one whose children are expressions,\n   * has no direct side-effects (unlike '+='), and has no\n   * conditional aspects (unlike '||').\n   */\n  static boolean isSimpleOperatorType(int type) {\n    switch (type) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Creates an EXPR_RESULT.\n   *\n   * @param child The expression itself.\n   * @return Newly created EXPR node with the child as subexpression.\n   */\n  static Node newExpr(Node child) {\n    return IR.exprResult(child).srcref(child);\n  }\n\n  /**\n   * Returns true if the node may create new mutable state, or change existing\n   * state.\n   *\n   * @see <a href=\"http://www.xkcd.org/326/\">XKCD Cartoon</a>\n   */\n  static boolean mayEffectMutableState(Node n) {\n    return mayEffectMutableState(n, null);\n  }\n\n  static boolean mayEffectMutableState(Node n, AbstractCompiler compiler) {\n    return checkForStateChangeHelper(n, true, compiler);\n  }\n\n  /**\n   * Returns true if the node which may have side effects when executed.\n   */\n  static boolean mayHaveSideEffects(Node n) {\n    return mayHaveSideEffects(n, null);\n  }\n\n  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) {\n    return checkForStateChangeHelper(n, false, compiler);\n  }\n\n  /**\n   * Returns true if some node in n's subtree changes application state.\n   * If {@code checkForNewObjects} is true, we assume that newly created\n   * mutable objects (like object literals) change state. Otherwise, we assume\n   * that they have no side effects.\n   */\n  private static boolean checkForStateChangeHelper(\n      Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n    // Rather than id which ops may have side effects, id the ones\n    // that we know to be safe\n    switch (n.getType()) {\n      // other side-effect free statements and expressions\n      case Token.AND:\n      case Token.BLOCK:\n      case Token.EXPR_RESULT:\n      case Token.HOOK:\n      case Token.IF:\n      case Token.IN:\n      case Token.PARAM_LIST:\n      case Token.NUMBER:\n      case Token.OR:\n      case Token.THIS:\n      case Token.TRUE:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.STRING:\n      case Token.STRING_KEY:\n      case Token.SWITCH:\n      case Token.TRY:\n      case Token.EMPTY:\n        break;\n\n      // Throws are by definition side effects\n      case Token.THROW:\n        return true;\n\n      case Token.OBJECTLIT:\n        if (checkForNewObjects) {\n          return true;\n        }\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (checkForStateChangeHelper(\n                  c.getFirstChild(), checkForNewObjects, compiler)) {\n            return true;\n          }\n        }\n        return false;\n\n      case Token.ARRAYLIT:\n      case Token.REGEXP:\n        if (checkForNewObjects) {\n          return true;\n        }\n        break;\n\n      case Token.VAR:    // empty var statement (no declaration)\n      case Token.NAME:   // variable by itself\n        if (n.getFirstChild() != null) {\n          return true;\n        }\n        break;\n\n      case Token.FUNCTION:\n        // Function expressions don't have side-effects, but function\n        // declarations change the namespace. Either way, we don't need to\n        // check the children, since they aren't executed at declaration time.\n        return checkForNewObjects || !isFunctionExpression(n);\n\n      case Token.NEW:\n        if (checkForNewObjects) {\n          return true;\n        }\n\n        if (!constructorCallHasSideEffects(n)) {\n          // loop below will see if the constructor parameters have\n          // side-effects\n          break;\n        }\n        return true;\n\n      case Token.CALL:\n        // calls to functions that have no side effects have the no\n        // side effect property set.\n        if (!functionCallHasSideEffects(n, compiler)) {\n          // loop below will see if the function parameters have\n          // side-effects\n          break;\n        }\n        return true;\n\n      default:\n        if (isSimpleOperator(n)) {\n          break;\n        }\n\n        if (isAssignmentOp(n)) {\n          Node assignTarget = n.getFirstChild();\n          if (assignTarget.isName()) {\n            return true;\n          }\n\n          // Assignments will have side effects if\n          // a) The RHS has side effects, or\n          // b) The LHS has side effects, or\n          // c) A name on the LHS will exist beyond the life of this statement.\n          if (checkForStateChangeHelper(\n                  n.getFirstChild(), checkForNewObjects, compiler) ||\n              checkForStateChangeHelper(\n                  n.getLastChild(), checkForNewObjects, compiler)) {\n            return true;\n          }\n\n          if (isGet(assignTarget)) {\n            // If the object being assigned to is a local object, don't\n            // consider this a side-effect as it can't be referenced\n            // elsewhere.  Don't do this recursively as the property might\n            // be an alias of another object, unlike a literal below.\n            Node current = assignTarget.getFirstChild();\n            if (evaluatesToLocalValue(current)) {\n              return false;\n            }\n\n            // A literal value as defined by \"isLiteralValue\" is guaranteed\n            // not to be an alias, or any components which are aliases of\n            // other objects.\n            // If the root object is a literal don't consider this a\n            // side-effect.\n            while (isGet(current)) {\n              current = current.getFirstChild();\n            }\n\n            return !isLiteralValue(current, true);\n          } else {\n            // TODO(johnlenz): remove this code and make this an exception. This\n            // is here only for legacy reasons, the AST is not valid but\n            // preserve existing behavior.\n            return !isLiteralValue(assignTarget, true);\n          }\n        }\n\n        return true;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Do calls to this constructor have side effects?\n   *\n   * @param callNode - constructor call node\n   */\n  static boolean constructorCallHasSideEffects(Node callNode) {\n    return constructorCallHasSideEffects(callNode, null);\n  }\n\n  static boolean constructorCallHasSideEffects(\n      Node callNode, AbstractCompiler compiler) {\n    if (!callNode.isNew()) {\n      throw new IllegalStateException(\n          \"Expected NEW node, got \" + Token.name(callNode.getType()));\n    }\n\n    if (callNode.isNoSideEffectsCall()) {\n      return false;\n    }\n\n    Node nameNode = callNode.getFirstChild();\n    if (nameNode.isName() &&\n        CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) {\n      return false;\n    }\n\n    return true;\n  }\n\n  // A list of built-in object creation or primitive type cast functions that\n  // can also be called as constructors but lack side-effects.\n  // TODO(johnlenz): consider adding an extern annotation for this.\n  private static final Set<String> BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS =\n      ImmutableSet.of(\n          \"Object\", \"Array\", \"String\", \"Number\", \"Boolean\", \"RegExp\", \"Error\");\n  private static final Set<String> OBJECT_METHODS_WITHOUT_SIDEEFFECTS =\n      ImmutableSet.of(\"toString\", \"valueOf\");\n  private static final Set<String> REGEXP_METHODS =\n      ImmutableSet.of(\"test\", \"exec\");\n  private static final Set<String> STRING_REGEXP_METHODS =\n      ImmutableSet.of(\"match\", \"replace\", \"search\", \"split\");\n\n  /**\n   * Returns true if calls to this function have side effects.\n   *\n   * @param callNode - function call node\n   */\n  static boolean functionCallHasSideEffects(Node callNode) {\n    return functionCallHasSideEffects(callNode, null);\n  }\n\n  /**\n   * Returns true if calls to this function have side effects.\n   *\n   * @param callNode The call node to inspected.\n   * @param compiler A compiler object to provide program state changing\n   *     context information. Can be null.\n   */\n  static boolean functionCallHasSideEffects(\n      Node callNode, @Nullable AbstractCompiler compiler) {\n    if (!callNode.isCall()) {\n      throw new IllegalStateException(\n          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n\n    if (callNode.isNoSideEffectsCall()) {\n      return false;\n    }\n\n    Node nameNode = callNode.getFirstChild();\n\n    // Built-in functions with no side effects.\n    if (nameNode.isName()) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.isGetProp()) {\n      if (callNode.hasOneChild()\n          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                nameNode.getLastChild().getString())) {\n        return false;\n      }\n\n      if (callNode.isOnlyModifiesThisCall()\n          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n\n      // Math.floor has no side-effects.\n      // TODO(nicksantos): This is a terrible terrible hack, until\n      // I create a definitionProvider that understands namespacing.\n      if (nameNode.getFirstChild().isName()) {\n        if (\"Math.floor\".equals(nameNode.getQualifiedName())) {\n          return false;\n        }\n      }\n\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().isRegExp()\n            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().isString()\n            && STRING_REGEXP_METHODS.contains(\n                nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null &&\n              (param.isString() || param.isRegExp())) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @return Whether the call has a local result.\n   */\n  static boolean callHasLocalResult(Node n) {\n    Preconditions.checkState(n.isCall());\n    return (n.getSideEffectFlags() & Node.FLAG_LOCAL_RESULTS) > 0;\n  }\n\n  /**\n   * @return Whether the new has a local result.\n   */\n  static boolean newHasLocalResult(Node n) {\n    Preconditions.checkState(n.isNew());\n    return n.isOnlyModifiesThisCall();\n  }\n\n  /**\n   * Returns true if the current node's type implies side effects.\n   *\n   * This is a non-recursive version of the may have side effects\n   * check; used to check wherever the current node's type is one of\n   * the reason's why a subtree has side effects.\n   */\n  static boolean nodeTypeMayHaveSideEffects(Node n) {\n    return nodeTypeMayHaveSideEffects(n, null);\n  }\n\n  static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) {\n    if (isAssignmentOp(n)) {\n      return true;\n    }\n\n    switch(n.getType()) {\n      case Token.DELPROP:\n      case Token.DEC:\n      case Token.INC:\n      case Token.THROW:\n        return true;\n      case Token.CALL:\n        return NodeUtil.functionCallHasSideEffects(n, compiler);\n      case Token.NEW:\n        return NodeUtil.constructorCallHasSideEffects(n, compiler);\n      case Token.NAME:\n        // A variable definition.\n        return n.hasChildren();\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * @return Whether the tree can be affected by side-effects or\n   * has side-effects.\n   */\n  static boolean canBeSideEffected(Node n) {\n    Set<String> emptySet = Collections.emptySet();\n    return canBeSideEffected(n, emptySet);\n  }\n\n  /**\n   * @param knownConstants A set of names known to be constant value at\n   * node 'n' (such as locals that are last written before n can execute).\n   * @return Whether the tree can be affected by side-effects or\n   * has side-effects.\n   */\n  static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.NEW:\n        // Function calls or constructor can reference changed values.\n        // TODO(johnlenz): Add some mechanism for determining that functions\n        // are unaffected by side effects.\n        return true;\n      case Token.NAME:\n        // Non-constant names values may have been changed.\n        return !isConstantName(n)\n            && !knownConstants.contains(n.getString());\n\n      // Properties on constant NAMEs can still be side-effected.\n      case Token.GETPROP:\n      case Token.GETELEM:\n        return true;\n\n      case Token.FUNCTION:\n        // Function expression are not changed by side-effects,\n        // and function declarations are not part of expressions.\n        Preconditions.checkState(isFunctionExpression(n));\n        return false;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (canBeSideEffected(c, knownConstants)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /*\n   *  0 comma ,\n   *  1 assignment = += -= *= /= %= <<= >>= >>>= &= ^= |=\n   *  2 conditional ?:\n   *  3 logical-or ||\n   *  4 logical-and &&\n   *  5 bitwise-or |\n   *  6 bitwise-xor ^\n   *  7 bitwise-and &\n   *  8 equality == !=\n   *  9 relational < <= > >=\n   * 10 bitwise shift << >> >>>\n   * 11 addition/subtraction + -\n   * 12 multiply/divide * / %\n   * 13 negation/increment ! ~ - ++ --\n   * 14 call, member () [] .\n   */\n  static int precedence(int type) {\n    switch (type) {\n      case Token.COMMA:  return 0;\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN: return 1;\n      case Token.HOOK:   return 2;  // ?: operator\n      case Token.OR:     return 3;\n      case Token.AND:    return 4;\n      case Token.BITOR:  return 5;\n      case Token.BITXOR: return 6;\n      case Token.BITAND: return 7;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:   return 8;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:     return 9;\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:   return 10;\n      case Token.SUB:\n      case Token.ADD:    return 11;\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:    return 12;\n      case Token.INC:\n      case Token.DEC:\n      case Token.NEW:\n      case Token.DELPROP:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS:\n      case Token.NEG:    return 13;\n\n      case Token.CALL:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      // Data values\n      case Token.ARRAYLIT:\n      case Token.EMPTY:  // TODO(johnlenz): remove this.\n      case Token.FALSE:\n      case Token.FUNCTION:\n      case Token.NAME:\n      case Token.NULL:\n      case Token.NUMBER:\n      case Token.OBJECTLIT:\n      case Token.REGEXP:\n      case Token.STRING:\n      case Token.STRING_KEY:\n      case Token.THIS:\n      case Token.TRUE:\n        return 15;\n\n      default: throw new Error(\"Unknown precedence for \" +\n                               Token.name(type) +\n                               \" (type \" + type + \")\");\n    }\n  }\n\n  static boolean isUndefined(Node n) {\n    switch (n.getType()) {\n      case Token.VOID:\n        return true;\n      case Token.NAME:\n        return n.getString().equals(\"undefined\");\n    }\n    return false;\n  }\n\n  static boolean isNullOrUndefined(Node n) {\n    return n.isNull() || isUndefined(n);\n  }\n\n  /**\n   * Apply the supplied predicate against\n   * all possible result Nodes of the expression.\n   */\n  static boolean allResultsMatch(Node n, Predicate<Node> p) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return allResultsMatch(n.getLastChild(), p);\n      case Token.AND:\n      case Token.OR:\n        return allResultsMatch(n.getFirstChild(), p)\n            && allResultsMatch(n.getLastChild(), p);\n      case Token.HOOK:\n        return allResultsMatch(n.getFirstChild().getNext(), p)\n            && allResultsMatch(n.getLastChild(), p);\n      default:\n        return p.apply(n);\n    }\n  }\n\n  /**\n   * Apply the supplied predicate against\n   * all possible result Nodes of the expression.\n   */\n  static boolean anyResultsMatch(Node n, Predicate<Node> p) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return anyResultsMatch(n.getLastChild(), p);\n      case Token.AND:\n      case Token.OR:\n        return anyResultsMatch(n.getFirstChild(), p)\n            || anyResultsMatch(n.getLastChild(), p);\n      case Token.HOOK:\n        return anyResultsMatch(n.getFirstChild().getNext(), p)\n            || anyResultsMatch(n.getLastChild(), p);\n      default:\n        return p.apply(n);\n    }\n  }\n\n  static class NumbericResultPredicate implements Predicate<Node> {\n    @Override\n    public boolean apply(Node n) {\n      return isNumericResultHelper(n);\n    }\n  }\n\n  static final NumbericResultPredicate NUMBERIC_RESULT_PREDICATE =\n      new NumbericResultPredicate();\n\n  /**\n   * Returns true if the result of node evaluation is always a number\n   */\n  static boolean isNumericResult(Node n) {\n    return allResultsMatch(n, NUMBERIC_RESULT_PREDICATE);\n  }\n\n  static boolean isNumericResultHelper(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n        return !mayBeString(n.getFirstChild())\n            && !mayBeString(n.getLastChild());\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:\n      case Token.INC:\n      case Token.DEC:\n      case Token.POS:\n      case Token.NEG:\n      case Token.NUMBER:\n        return true;\n      case Token.NAME:\n        String name = n.getString();\n        if (name.equals(\"NaN\")) {\n          return true;\n        }\n        if (name.equals(\"Infinity\")) {\n          return true;\n        }\n        return false;\n      default:\n        return false;\n    }\n  }\n\n  static class BooleanResultPredicate implements Predicate<Node> {\n    @Override\n    public boolean apply(Node n) {\n      return isBooleanResultHelper(n);\n    }\n  }\n\n  static final BooleanResultPredicate BOOLEAN_RESULT_PREDICATE =\n      new BooleanResultPredicate();\n\n  /**\n   * @return Whether the result of node evaluation is always a boolean\n   */\n  static boolean isBooleanResult(Node n) {\n    return allResultsMatch(n, BOOLEAN_RESULT_PREDICATE);\n  }\n\n  static boolean isBooleanResultHelper(Node n) {\n    switch (n.getType()) {\n      // Primitives\n      case Token.TRUE:\n      case Token.FALSE:\n      // Comparisons\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      // Queries\n      case Token.IN:\n      case Token.INSTANCEOF:\n      // Inversion\n      case Token.NOT:\n      // delete operator returns a boolean.\n      case Token.DELPROP:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n\n\n  static class MayBeStringResultPredicate implements Predicate<Node> {\n    @Override\n    public boolean apply(Node n) {\n      return mayBeStringHelper(n);\n    }\n  }\n\n  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =\n      new MayBeStringResultPredicate();\n\n  /**\n   * @returns Whether the results is possibly a string.\n   */\n  static boolean mayBeString(Node n) {\n    return mayBeString(n, true);\n  }\n\n  static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    } else {\n      return mayBeStringHelper(n);\n    }\n  }\n\n  static boolean mayBeStringHelper(Node n) {\n    return !isNumericResult(n) && !isBooleanResult(n)\n        && !isUndefined(n) && !n.isNull();\n  }\n\n  /**\n   * Returns true if the operator is associative.\n   * e.g. (a * b) * c = a * (b * c)\n   * Note: \"+\" is not associative because it is also the concatenation\n   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n   */\n  static boolean isAssociative(int type) {\n    switch (type) {\n      case Token.MUL:\n      case Token.AND:\n      case Token.OR:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Returns true if the operator is commutative.\n   * e.g. (a * b) * c = c * (b * a)\n   * Note 1: \"+\" is not commutative because it is also the concatenation\n   * for strings. e.g. \"a\" + (1 + 2) is not \"a\" + 1 + 2\n   * Note 2: only operations on literals and pure functions are commutative.\n   */\n  static boolean isCommutative(int type) {\n    switch (type) {\n      case Token.MUL:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  static boolean isAssignmentOp(Node n) {\n    switch (n.getType()){\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        return true;\n    }\n    return false;\n  }\n\n  static int getOpFromAssignmentOp(Node n) {\n    switch (n.getType()){\n      case Token.ASSIGN_BITOR:\n        return Token.BITOR;\n      case Token.ASSIGN_BITXOR:\n        return Token.BITXOR;\n      case Token.ASSIGN_BITAND:\n        return Token.BITAND;\n      case Token.ASSIGN_LSH:\n        return Token.LSH;\n      case Token.ASSIGN_RSH:\n        return Token.RSH;\n      case Token.ASSIGN_URSH:\n        return Token.URSH;\n      case Token.ASSIGN_ADD:\n        return Token.ADD;\n      case Token.ASSIGN_SUB:\n        return Token.SUB;\n      case Token.ASSIGN_MUL:\n        return Token.MUL;\n      case Token.ASSIGN_DIV:\n        return Token.DIV;\n      case Token.ASSIGN_MOD:\n        return Token.MOD;\n    }\n    throw new IllegalArgumentException(\"Not an assignment op:\" + n);\n  }\n\n  /**\n   * Determines if the given node contains a function statement or function\n   * expression.\n   */\n  static boolean containsFunction(Node n) {\n    return containsType(n, Token.FUNCTION);\n  }\n\n  /**\n   * Returns true if the shallow scope contains references to 'this' keyword\n   */\n  static boolean referencesThis(Node n) {\n    Node start = (n.isFunction()) ? n.getLastChild() : n;\n    return containsType(start, Token.THIS, MATCH_NOT_FUNCTION);\n  }\n\n  /**\n   * Is this a GETPROP or GETELEM node?\n   */\n  static boolean isGet(Node n) {\n    return n.isGetProp() || n.isGetElem();\n  }\n\n  /**\n   * Is this node the name of a variable being declared?\n   *\n   * @param n The node\n   * @return True if {@code n} is NAME and {@code parent} is VAR\n   */\n  static boolean isVarDeclaration(Node n) {\n    // There is no need to verify that parent != null because a NAME node\n    // always has a parent in a valid parse tree.\n    return n.isName() && n.getParent().isVar();\n  }\n\n  /**\n   * For an assignment or variable declaration get the assigned value.\n   * @return The value node representing the new value.\n   */\n  static Node getAssignedValue(Node n) {\n    Preconditions.checkState(n.isName());\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      return n.getFirstChild();\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      return n.getNext();\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Is this node an assignment expression statement?\n   *\n   * @param n The node\n   * @return True if {@code n} is EXPR_RESULT and {@code n}'s\n   *     first child is ASSIGN\n   */\n  static boolean isExprAssign(Node n) {\n    return n.isExprResult()\n        && n.getFirstChild().isAssign();\n  }\n\n  /**\n   * Is this node a call expression statement?\n   *\n   * @param n The node\n   * @return True if {@code n} is EXPR_RESULT and {@code n}'s\n   *     first child is CALL\n   */\n  static boolean isExprCall(Node n) {\n    return n.isExprResult()\n        && n.getFirstChild().isCall();\n  }\n\n  /**\n   * @return Whether the node represents a FOR-IN loop.\n   */\n  static boolean isForIn(Node n) {\n    return n.isFor()\n        && n.getChildCount() == 3;\n  }\n\n  /**\n   * Determines whether the given node is a FOR, DO, or WHILE node.\n   */\n  static boolean isLoopStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * @param n The node to inspect.\n   * @return If the node, is a FOR, WHILE, or DO, it returns the node for\n   * the code BLOCK, null otherwise.\n   */\n  static Node getLoopCodeBlock(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.WHILE:\n        return n.getLastChild();\n      case Token.DO:\n        return n.getFirstChild();\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * @return Whether the specified node has a loop parent that\n   * is within the current scope.\n   */\n  static boolean isWithinLoop(Node n) {\n    for (Node parent : n.getAncestors()) {\n      if (NodeUtil.isLoopStructure(parent)) {\n        return true;\n      }\n\n      if (parent.isFunction()) {\n        break;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node.\n   */\n  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Determines whether the given node is code node for FOR, DO,\n   * WHILE, WITH, or IF node.\n   */\n  static boolean isControlStructureCodeBlock(Node parent, Node n) {\n    switch (parent.getType()) {\n      case Token.FOR:\n      case Token.WHILE:\n      case Token.LABEL:\n      case Token.WITH:\n        return parent.getLastChild() == n;\n      case Token.DO:\n        return parent.getFirstChild() == n;\n      case Token.IF:\n        return parent.getFirstChild() != n;\n      case Token.TRY:\n        return parent.getFirstChild() == n || parent.getLastChild() == n;\n      case Token.CATCH:\n        return parent.getLastChild() == n;\n      case Token.SWITCH:\n      case Token.CASE:\n        return parent.getFirstChild() != n;\n      case Token.DEFAULT_CASE:\n        return true;\n      default:\n        Preconditions.checkState(isControlStructure(parent));\n        return false;\n    }\n  }\n\n  /**\n   * Gets the condition of an ON_TRUE / ON_FALSE CFG edge.\n   * @param n a node with an outgoing conditional CFG edge\n   * @return the condition node or null if the condition is not obviously a node\n   */\n  static Node getConditionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.IF:\n      case Token.WHILE:\n        return n.getFirstChild();\n      case Token.DO:\n        return n.getLastChild();\n      case Token.FOR:\n        switch (n.getChildCount()) {\n          case 3:\n            return null;\n          case 4:\n            return n.getFirstChild().getNext();\n        }\n        throw new IllegalArgumentException(\"malformed 'for' statement \" + n);\n      case Token.CASE:\n        return null;\n    }\n    throw new IllegalArgumentException(n + \" does not have a condition.\");\n  }\n\n  /**\n   * @return Whether the node is of a type that contain other statements.\n   */\n  static boolean isStatementBlock(Node n) {\n    return n.isScript() || n.isBlock();\n  }\n\n  /**\n   * @return Whether the node is used as a statement.\n   */\n  static boolean isStatement(Node n) {\n    return isStatementParent(n.getParent());\n  }\n\n  static boolean isStatementParent(Node parent) {\n    // It is not possible to determine definitely if a node is a statement\n    // or not if it is not part of the AST.  A FUNCTION node can be\n    // either part of an expression or a statement.\n    Preconditions.checkState(parent != null);\n    switch (parent.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.LABEL:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /** Whether the node is part of a switch statement. */\n  static boolean isSwitchCase(Node n) {\n    return n.isCase() || n.isDefaultCase();\n  }\n\n  /**\n   * @return Whether the name is a reference to a variable, function or\n   *       function parameter (not a label or a empty function expression name).\n   */\n  static boolean isReferenceName(Node n) {\n    return n.isName() && !n.getString().isEmpty();\n  }\n\n  /** Whether the child node is the FINALLY block of a try. */\n  static boolean isTryFinallyNode(Node parent, Node child) {\n    return parent.isTry() && parent.getChildCount() == 3\n        && child == parent.getLastChild();\n  }\n\n  /** Whether the node is a CATCH container BLOCK. */\n  static boolean isTryCatchNodeContainer(Node n) {\n    Node parent = n.getParent();\n    return parent.isTry()\n        && parent.getFirstChild().getNext() == n;\n  }\n\n  /** Safely remove children while maintaining a valid node structure. */\n  static void removeChild(Node parent, Node node) {\n    if (isTryFinallyNode(parent, node)) {\n      if (NodeUtil.hasCatchHandler(getCatchBlock(parent))) {\n        // A finally can only be removed if there is a catch.\n        parent.removeChild(node);\n      } else {\n        // Otherwise, only its children can be removed.\n        node.detachChildren();\n      }\n    } else if (node.isCatch()) {\n      // The CATCH can can only be removed if there is a finally clause.\n      Node tryNode = node.getParent().getParent();\n      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n      node.detachFromParent();\n    } else if (isTryCatchNodeContainer(node)) {\n      // The container node itself can't be removed, but the contained CATCH\n      // can if there is a 'finally' clause\n      Node tryNode = node.getParent();\n      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n      node.detachChildren();\n    } else if (node.isBlock()) {\n      // Simply empty the block.  This maintains source location and\n      // \"synthetic\"-ness.\n      node.detachChildren();\n    } else if (isStatementBlock(parent)\n        || isSwitchCase(node)) {\n      // A statement in a block can simply be removed.\n      parent.removeChild(node);\n    } else if (parent.isVar()) {\n      if (parent.hasMoreThanOneChild()) {\n        parent.removeChild(node);\n      } else {\n        // Remove the node from the parent, so it can be reused.\n        parent.removeChild(node);\n        // This would leave an empty VAR, remove the VAR itself.\n        removeChild(parent.getParent(), parent);\n      }\n    } else if (parent.isLabel()\n        && node == parent.getLastChild()) {\n      // Remove the node from the parent, so it can be reused.\n      parent.removeChild(node);\n      // A LABEL without children can not be referred to, remove it.\n      removeChild(parent.getParent(), parent);\n    } else if (parent.isFor()\n        && parent.getChildCount() == 4) {\n      // Only Token.FOR can have an Token.EMPTY other control structure\n      // need something for the condition. Others need to be replaced\n      // or the structure removed.\n      parent.replaceChild(node, IR.empty());\n    } else {\n      throw new IllegalStateException(\"Invalid attempt to remove node: \" +\n          node.toString() + \" of \" + parent.toString());\n    }\n  }\n\n  /**\n   * Add a finally block if one does not exist.\n   */\n  static void maybeAddFinally(Node tryNode) {\n    Preconditions.checkState(tryNode.isTry());\n    if (!NodeUtil.hasFinally(tryNode)) {\n      tryNode.addChildrenToBack(IR.block().srcref(tryNode));\n    }\n  }\n\n  /**\n   * Merge a block with its parent block.\n   * @return Whether the block was removed.\n   */\n  static boolean tryMergeBlock(Node block) {\n    Preconditions.checkState(block.isBlock());\n    Node parent = block.getParent();\n    // Try to remove the block if its parent is a block/script or if its\n    // parent is label and it has exactly one child.\n    if (isStatementBlock(parent)) {\n      Node previous = block;\n      while (block.hasChildren()) {\n        Node child = block.removeFirstChild();\n        parent.addChildAfter(child, previous);\n        previous = child;\n      }\n      parent.removeChild(block);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @param node A node\n   * @return Whether the call is a NEW or CALL node.\n   */\n  static boolean isCallOrNew(Node node) {\n    return node.isCall() || node.isNew();\n  }\n\n  /**\n   * Return a BLOCK node for the given FUNCTION node.\n   */\n  static Node getFunctionBody(Node fn) {\n    Preconditions.checkArgument(fn.isFunction());\n    return fn.getLastChild();\n  }\n\n  /**\n   * Is this node a function declaration? A function declaration is a function\n   * that has a name that is added to the current scope (i.e. a function that\n   * is not part of a expression; see {@link #isFunctionExpression}).\n   */\n  static boolean isFunctionDeclaration(Node n) {\n    return n.isFunction() && isStatement(n);\n  }\n\n  /**\n   * Is this node a hoisted function declaration? A function declaration in the\n   * scope root is hoisted to the top of the scope.\n   * See {@link #isFunctionDeclaration}).\n   */\n  static boolean isHoistedFunctionDeclaration(Node n) {\n    return isFunctionDeclaration(n)\n        && (n.getParent().isScript()\n            || n.getParent().getParent().isFunction());\n  }\n\n  /**\n   * Is a FUNCTION node an function expression? An function expression is one\n   * that has either no name or a name that is not added to the current scope.\n   *\n   * <p>Some examples of function expressions:\n   * <pre>\n   * (function () {})\n   * (function f() {})()\n   * [ function f() {} ]\n   * var f = function f() {};\n   * for (function f() {};;) {}\n   * </pre>\n   *\n   * <p>Some examples of functions that are <em>not</em> expressions:\n   * <pre>\n   * function f() {}\n   * if (x); else function f() {}\n   * for (;;) { function f() {} }\n   * </pre>\n   *\n   * @param n A node\n   * @return Whether n is an function used within an expression.\n   */\n  static boolean isFunctionExpression(Node n) {\n    return n.isFunction() && !isStatement(n);\n  }\n\n  /**\n   * Returns whether this is a bleeding function (an anonymous named function\n   * that bleeds into the inner scope).\n   */\n  static boolean isBleedingFunctionName(Node n) {\n    return n.isName() && !n.getString().isEmpty() &&\n        isFunctionExpression(n.getParent());\n  }\n\n  /**\n   * Determines if a node is a function expression that has an empty body.\n   *\n   * @param node a node\n   * @return whether the given node is a function expression that is empty\n   */\n  static boolean isEmptyFunctionExpression(Node node) {\n    return isFunctionExpression(node) && isEmptyBlock(node.getLastChild());\n  }\n\n  /**\n   * Determines if a function takes a variable number of arguments by\n   * looking for references to the \"arguments\" var_args object.\n   */\n  static boolean isVarArgsFunction(Node function) {\n    // TODO(johnlenz): rename this function\n    Preconditions.checkArgument(function.isFunction());\n    return isNameReferenced(\n        function.getLastChild(),\n        \"arguments\",\n        MATCH_NOT_FUNCTION);\n  }\n\n  /**\n   * @return Whether node is a call to methodName.\n   *    a.f(...)\n   *    a['f'](...)\n   */\n  static boolean isObjectCallMethod(Node callNode, String methodName) {\n    if (callNode.isCall()) {\n      Node functionIndentifyingExpression = callNode.getFirstChild();\n      if (isGet(functionIndentifyingExpression)) {\n        Node last = functionIndentifyingExpression.getLastChild();\n        if (last != null && last.isString()) {\n          String propName = last.getString();\n          return (propName.equals(methodName));\n        }\n      }\n    }\n    return false;\n  }\n\n\n  /**\n   * @return Whether the callNode represents an expression in the form of:\n   *    x.call(...)\n   *    x['call'](...)\n   */\n  static boolean isFunctionObjectCall(Node callNode) {\n    return isObjectCallMethod(callNode, \"call\");\n  }\n\n  /**\n   * @return Whether the callNode represents an expression in the form of:\n   *    x.apply(...)\n   *    x['apply'](...)\n   */\n  static boolean isFunctionObjectApply(Node callNode) {\n    return isObjectCallMethod(callNode, \"apply\");\n  }\n\n  /**\n   * Determines whether this node is strictly on the left hand side of an assign\n   * or var initialization. Notably, this does not include all L-values, only\n   * statements where the node is used only as an L-value.\n   *\n   * @param n The node\n   * @param parent Parent of the node\n   * @return True if n is the left hand of an assign\n   */\n  static boolean isVarOrSimpleAssignLhs(Node n, Node parent) {\n    return (parent.isAssign() && parent.getFirstChild() == n) ||\n           parent.isVar();\n  }\n\n  /**\n   * Determines whether this node is used as an L-value. Notice that sometimes\n   * names are used as both L-values and R-values.\n   *\n   * We treat \"var x;\" as a pseudo-L-value, which kind of makes sense if you\n   * treat it as \"assignment to 'undefined' at the top of the scope\". But if\n   * we're honest with ourselves, it doesn't make sense, and we only do this\n   * because it makes sense to treat this as syntactically similar to\n   * \"var x = 0;\".\n   *\n   * @param n The node\n   * @return True if n is an L-value.\n   */\n  public static boolean isLValue(Node n) {\n    Preconditions.checkArgument(n.isName() || n.isGetProp() ||\n        n.isGetElem());\n    Node parent = n.getParent();\n    if (parent == null) {\n      return false;\n    }\n    return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n        || (NodeUtil.isForIn(parent) && parent.getFirstChild() == n)\n        || parent.isVar()\n        || (parent.isFunction() && parent.getFirstChild() == n)\n        || parent.isDec()\n        || parent.isInc()\n        || parent.isParamList()\n        || parent.isCatch();\n  }\n\n  /**\n   * Determines whether a node represents an object literal key\n   * (e.g. key1 in {key1: value1, key2: value2}).\n   *\n   * @param node A node\n   * @param parent The node's parent\n   */\n  static boolean isObjectLitKey(Node node, Node parent) {\n    switch (node.getType()) {\n      case Token.STRING_KEY:\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get the name of an object literal key.\n   *\n   * @param key A node\n   */\n  static String getObjectLitKeyName(Node key) {\n    switch (key.getType()) {\n      case Token.STRING_KEY:\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        return key.getString();\n    }\n    throw new IllegalStateException(\"Unexpected node type: \" + key);\n  }\n\n  /**\n   * @param key A OBJECTLIT key node.\n   * @return The type expected when using the key.\n   */\n  static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) {\n    if (valueType != null) {\n      switch (key.getType()) {\n        case Token.GETTER_DEF:\n          // GET must always return a function type.\n          if (valueType.isFunctionType()) {\n            FunctionType fntype = valueType.toMaybeFunctionType();\n            valueType = fntype.getReturnType();\n          } else {\n            return null;\n          }\n          break;\n        case Token.SETTER_DEF:\n          if (valueType.isFunctionType()) {\n            // SET must always return a function type.\n            FunctionType fntype = valueType.toMaybeFunctionType();\n            Node param = fntype.getParametersNode().getFirstChild();\n            // SET function must always have one parameter.\n            valueType = param.getJSType();\n          } else {\n            return null;\n          }\n          break;\n      }\n    }\n    return valueType;\n  }\n\n  /**\n   * Determines whether a node represents an object literal get or set key\n   * (e.g. key1 in {get key1() {}, set key2(a){}).\n   *\n   * @param node A node\n   */\n  static boolean isGetOrSetKey(Node node) {\n    switch (node.getType()) {\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        return true;\n    }\n    return false;\n  }\n\n  /**\n   * Converts an operator's token value (see {@link Token}) to a string\n   * representation.\n   *\n   * @param operator the operator's token value to convert\n   * @return the string representation or {@code null} if the token value is\n   * not an operator\n   */\n  static String opToStr(int operator) {\n    switch (operator) {\n      case Token.BITOR: return \"|\";\n      case Token.OR: return \"||\";\n      case Token.BITXOR: return \"^\";\n      case Token.AND: return \"&&\";\n      case Token.BITAND: return \"&\";\n      case Token.SHEQ: return \"===\";\n      case Token.EQ: return \"==\";\n      case Token.NOT: return \"!\";\n      case Token.NE: return \"!=\";\n      case Token.SHNE: return \"!==\";\n      case Token.LSH: return \"<<\";\n      case Token.IN: return \"in\";\n      case Token.LE: return \"<=\";\n      case Token.LT: return \"<\";\n      case Token.URSH: return \">>>\";\n      case Token.RSH: return \">>\";\n      case Token.GE: return \">=\";\n      case Token.GT: return \">\";\n      case Token.MUL: return \"*\";\n      case Token.DIV: return \"/\";\n      case Token.MOD: return \"%\";\n      case Token.BITNOT: return \"~\";\n      case Token.ADD: return \"+\";\n      case Token.SUB: return \"-\";\n      case Token.POS: return \"+\";\n      case Token.NEG: return \"-\";\n      case Token.ASSIGN: return \"=\";\n      case Token.ASSIGN_BITOR: return \"|=\";\n      case Token.ASSIGN_BITXOR: return \"^=\";\n      case Token.ASSIGN_BITAND: return \"&=\";\n      case Token.ASSIGN_LSH: return \"<<=\";\n      case Token.ASSIGN_RSH: return \">>=\";\n      case Token.ASSIGN_URSH: return \">>>=\";\n      case Token.ASSIGN_ADD: return \"+=\";\n      case Token.ASSIGN_SUB: return \"-=\";\n      case Token.ASSIGN_MUL: return \"*=\";\n      case Token.ASSIGN_DIV: return \"/=\";\n      case Token.ASSIGN_MOD: return \"%=\";\n      case Token.VOID: return \"void\";\n      case Token.TYPEOF: return \"typeof\";\n      case Token.INSTANCEOF: return \"instanceof\";\n      default: return null;\n    }\n  }\n\n  /**\n   * Converts an operator's token value (see {@link Token}) to a string\n   * representation or fails.\n   *\n   * @param operator the operator's token value to convert\n   * @return the string representation\n   * @throws Error if the token value is not an operator\n   */\n  static String opToStrNoFail(int operator) {\n    String res = opToStr(operator);\n    if (res == null) {\n      throw new Error(\"Unknown op \" + operator + \": \" +\n                      Token.name(operator));\n    }\n    return res;\n  }\n\n  /**\n   * @return true if n or any of its children are of the specified type\n   */\n  static boolean containsType(Node node,\n                              int type,\n                              Predicate<Node> traverseChildrenPred) {\n    return has(node, new MatchNodeType(type), traverseChildrenPred);\n  }\n\n  /**\n   * @return true if n or any of its children are of the specified type\n   */\n  static boolean containsType(Node node, int type) {\n    return containsType(node, type, Predicates.<Node>alwaysTrue());\n  }\n\n\n  /**\n   * Given a node tree, finds all the VAR declarations in that tree that are\n   * not in an inner scope. Then adds a new VAR node at the top of the current\n   * scope that redeclares them, if necessary.\n   */\n  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n              .srcref(nameNode))\n          .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToFront(var);\n    }\n  }\n\n  /**\n   * Copy any annotations that follow a named value.\n   * @param source\n   * @param destination\n   */\n  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }\n\n  /**\n   * Gets a Node at the top of the current scope where we can add new var\n   * declarations as children.\n   */\n  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n    while (null != (ancestor = ancestor.getParent())) {\n      int type = ancestor.getType();\n      if (type == Token.SCRIPT) {\n        addingRoot = ancestor;\n        break;\n      } else if (type == Token.FUNCTION) {\n        addingRoot = ancestor.getLastChild();\n        break;\n      }\n    }\n\n    // make sure that the adding root looks ok\n    Preconditions.checkState(addingRoot.isBlock() ||\n        addingRoot.isScript());\n    Preconditions.checkState(addingRoot.getFirstChild() == null ||\n        !addingRoot.getFirstChild().isScript());\n    return addingRoot;\n  }\n\n  /**\n   * Creates a node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  public static Node newQualifiedNameNode(\n      CodingConvention convention, String name) {\n    int endPos = name.indexOf('.');\n    if (endPos == -1) {\n      return newName(convention, name);\n    }\n    Node node = newName(convention, name.substring(0, endPos));\n    int startPos;\n    do {\n      startPos = endPos + 1;\n      endPos = name.indexOf('.', startPos);\n      String part = (endPos == -1\n                     ? name.substring(startPos)\n                     : name.substring(startPos, endPos));\n      Node propNode = IR.string(part);\n      if (convention.isConstantKey(part)) {\n        propNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n      }\n      node = IR.getprop(node, propNode);\n    } while (endPos != -1);\n\n    return node;\n  }\n\n  /**\n   * Creates a node representing a qualified name, copying over the source\n   * location information from the basis node and assigning the given original\n   * name to the node.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @param basisNode The node that represents the name as currently found in\n   *     the AST.\n   * @param originalName The original name of the item being represented by the\n   *     NAME node. Used for debugging information.\n   *\n   * @return A NAME or GETPROP node\n   */\n  static Node newQualifiedNameNode(\n      CodingConvention convention, String name, Node basisNode,\n      String originalName) {\n    Node node = newQualifiedNameNode(convention, name);\n    setDebugInformation(node, basisNode, originalName);\n    return node;\n  }\n\n  /**\n   * Gets the root node of a qualified name. Must be either NAME or THIS.\n   */\n  static Node getRootOfQualifiedName(Node qName) {\n    for (Node current = qName; true;\n         current = current.getFirstChild()) {\n      if (current.isName() || current.isThis()) {\n        return current;\n      }\n      Preconditions.checkState(current.isGetProp());\n    }\n  }\n\n  /**\n   * Sets the debug information (source file info and original name)\n   * on the given node.\n   *\n   * @param node The node on which to set the debug information.\n   * @param basisNode The basis node from which to copy the source file info.\n   * @param originalName The original name of the node.\n   */\n  static void setDebugInformation(Node node, Node basisNode,\n                                  String originalName) {\n    node.copyInformationFromForTree(basisNode);\n    node.putProp(Node.ORIGINALNAME_PROP, originalName);\n  }\n\n  private static Node newName(\n      CodingConvention convention, String name) {\n    Node nameNode = IR.name(name);\n    if (convention.isConstant(name)) {\n      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    return nameNode;\n  }\n\n  /**\n   * Creates a new node representing an *existing* name, copying over the source\n   * location information from the basis node.\n   *\n   * @param name The name for the new NAME node.\n   * @param srcref The node that represents the name as currently found in\n   *     the AST.\n   *\n   * @return The node created.\n   */\n  static Node newName(CodingConvention convention, String name, Node srcref) {\n    return newName(convention, name).srcref(srcref);\n  }\n\n  /**\n   * Creates a new node representing an *existing* name, copying over the source\n   * location information from the basis node and assigning the given original\n   * name to the node.\n   *\n   * @param name The name for the new NAME node.\n   * @param basisNode The node that represents the name as currently found in\n   *     the AST.\n   * @param originalName The original name of the item being represented by the\n   *     NAME node. Used for debugging information.\n   *\n   * @return The node created.\n   */\n  static Node newName(\n      CodingConvention convention, String name,\n      Node basisNode, String originalName) {\n    Node nameNode = newName(convention, name, basisNode);\n    nameNode.putProp(Node.ORIGINALNAME_PROP, originalName);\n    return nameNode;\n  }\n\n  /** Test if all characters in the string are in the Basic Latin (aka ASCII)\n   * character set - that they have UTF-16 values equal to or below 0x7f.\n   * This check can find which identifiers with Unicode characters need to be\n   * escaped in order to allow resulting files to be processed by non-Unicode\n   * aware UNIX tools and editors.\n   * *\n   * See http://en.wikipedia.org/wiki/Latin_characters_in_Unicode\n   * for more on Basic Latin.\n   *\n   * @param s The string to be checked for ASCII-goodness.\n   *\n   * @return True if all characters in the string are in Basic Latin set.\n   */\n  static boolean isLatin(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c > LARGEST_BASIC_LATIN) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the given name is a valid variable name.\n   */\n  static boolean isValidSimpleName(String name) {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }\n\n  /**\n   * Determines whether the given name is a valid qualified name.\n   */\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  public static boolean isValidQualifiedName(String name) {\n    if (name.endsWith(\".\") || name.startsWith(\".\")) {\n      return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the given name can appear on the right side of\n   * the dot operator. Many properties (like reserved words) cannot.\n   */\n  static boolean isValidPropertyName(String name) {\n    return isValidSimpleName(name);\n  }\n\n  private static class VarCollector implements Visitor {\n    final Map<String, Node> vars = Maps.newLinkedHashMap();\n\n    @Override\n    public void visit(Node n) {\n      if (n.isName()) {\n        Node parent = n.getParent();\n        if (parent != null && parent.isVar()) {\n          String name = n.getString();\n          if (!vars.containsKey(name)) {\n            vars.put(name, n);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Retrieves vars declared in the current node tree, excluding descent scopes.\n   */\n  static Collection<Node> getVarsDeclaredInBranch(Node root) {\n    VarCollector collector = new VarCollector();\n    visitPreOrder(\n        root,\n        collector,\n        MATCH_NOT_FUNCTION);\n    return collector.vars.values();\n  }\n\n  /**\n   * @return {@code true} if the node an assignment to a prototype property of\n   *     some constructor.\n   */\n  static boolean isPrototypePropertyDeclaration(Node n) {\n    if (!isExprAssign(n)) {\n      return false;\n    }\n    return isPrototypeProperty(n.getFirstChild().getFirstChild());\n  }\n\n  /**\n   * @return Whether the node represents a qualified prototype property.\n   */\n  static boolean isPrototypeProperty(Node n) {\n    String lhsString = n.getQualifiedName();\n    if (lhsString == null) {\n      return false;\n    }\n    int prototypeIdx = lhsString.indexOf(\".prototype.\");\n    return prototypeIdx != -1;\n  }\n\n  /**\n   * @return The class name part of a qualified prototype name.\n   */\n  static Node getPrototypeClassName(Node qName) {\n    Node cur = qName;\n    while (cur.isGetProp()) {\n      if (cur.getLastChild().getString().equals(\"prototype\")) {\n        return cur.getFirstChild();\n      } else {\n        cur = cur.getFirstChild();\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @return The string property name part of a qualified prototype name.\n   */\n  static String getPrototypePropertyName(Node qName) {\n    String qNameStr = qName.getQualifiedName();\n    int prototypeIdx = qNameStr.lastIndexOf(\".prototype.\");\n    int memberIndex = prototypeIdx + \".prototype\".length() + 1;\n    return qNameStr.substring(memberIndex);\n  }\n\n  /**\n   * Create a node for an empty result expression:\n   *   \"void 0\"\n   */\n  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode != null) {\n        node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }\n\n  /**\n   * Create a VAR node containing the given name and initial value expression.\n   */\n  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value != null) {\n      Preconditions.checkState(value.getNext() == null);\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }\n\n  /**\n   * A predicate for matching name nodes with the specified node.\n   */\n  private static class MatchNameNode implements Predicate<Node>{\n    final String name;\n\n    MatchNameNode(String name){\n      this.name = name;\n    }\n\n    @Override\n    public boolean apply(Node n) {\n      return n.isName() && n.getString().equals(name);\n    }\n  }\n\n  /**\n   * A predicate for matching nodes with the specified type.\n   */\n  static class MatchNodeType implements Predicate<Node>{\n    final int type;\n\n    MatchNodeType(int type){\n      this.type = type;\n    }\n\n    @Override\n    public boolean apply(Node n) {\n      return n.getType() == type;\n    }\n  }\n\n\n  /**\n   * A predicate for matching var or function declarations.\n   */\n  static class MatchDeclaration implements Predicate<Node> {\n    @Override\n    public boolean apply(Node n) {\n      return isFunctionDeclaration(n) || n.isVar();\n    }\n  }\n\n  /**\n   * A predicate for matching anything except function nodes.\n   */\n  private static class MatchNotFunction implements Predicate<Node>{\n    @Override\n    public boolean apply(Node n) {\n      return !n.isFunction();\n    }\n  }\n\n  static final Predicate<Node> MATCH_NOT_FUNCTION = new MatchNotFunction();\n\n  /**\n   * A predicate for matching statements without exiting the current scope.\n   */\n  static class MatchShallowStatement implements Predicate<Node>{\n    @Override\n    public boolean apply(Node n) {\n      Node parent = n.getParent();\n      return n.isBlock()\n          || (!n.isFunction() && (parent == null\n              || isControlStructure(parent)\n              || isStatementBlock(parent)));\n    }\n  }\n\n  /**\n   * Finds the number of times a type is referenced within the node tree.\n   */\n  static int getNodeTypeReferenceCount(\n      Node node, int type, Predicate<Node> traverseChildrenPred) {\n    return getCount(node, new MatchNodeType(type), traverseChildrenPred);\n  }\n\n  /**\n   * Whether a simple name is referenced within the node tree.\n   */\n  static boolean isNameReferenced(Node node,\n                                  String name,\n                                  Predicate<Node> traverseChildrenPred) {\n    return has(node, new MatchNameNode(name), traverseChildrenPred);\n  }\n\n  /**\n   * Whether a simple name is referenced within the node tree.\n   */\n  static boolean isNameReferenced(Node node, String name) {\n    return isNameReferenced(node, name, Predicates.<Node>alwaysTrue());\n  }\n\n  /**\n   * Finds the number of times a simple name is referenced within the node tree.\n   */\n  static int getNameReferenceCount(Node node, String name) {\n    return getCount(\n        node, new MatchNameNode(name), Predicates.<Node>alwaysTrue());\n  }\n\n  /**\n   * @return Whether the predicate is true for the node or any of its children.\n   */\n  static boolean has(Node node,\n                     Predicate<Node> pred,\n                     Predicate<Node> traverseChildrenPred) {\n    if (pred.apply(node)) {\n      return true;\n    }\n\n    if (!traverseChildrenPred.apply(node)) {\n      return false;\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (has(c, pred, traverseChildrenPred)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @return The number of times the the predicate is true for the node\n   * or any of its children.\n   */\n  static int getCount(\n      Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) {\n    int total = 0;\n\n    if (pred.apply(n)) {\n      total++;\n    }\n\n    if (traverseChildrenPred.apply(n)) {\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        total += getCount(c, pred, traverseChildrenPred);\n      }\n    }\n\n    return total;\n  }\n\n  /**\n   * Interface for use with the visit method.\n   * @see #visit\n   */\n  static interface Visitor {\n    void visit(Node node);\n  }\n\n  /**\n   * A pre-order traversal, calling Visitor.visit for each child matching\n   * the predicate.\n   */\n  static void visitPreOrder(Node node,\n                     Visitor visitor,\n                     Predicate<Node> traverseChildrenPred) {\n    visitor.visit(node);\n\n    if (traverseChildrenPred.apply(node)) {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        visitPreOrder(c, visitor, traverseChildrenPred);\n      }\n    }\n  }\n\n  /**\n   * A post-order traversal, calling Visitor.visit for each child matching\n   * the predicate.\n   */\n  static void visitPostOrder(Node node,\n                     Visitor visitor,\n                     Predicate<Node> traverseChildrenPred) {\n    if (traverseChildrenPred.apply(node)) {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        visitPostOrder(c, visitor, traverseChildrenPred);\n      }\n    }\n\n    visitor.visit(node);\n  }\n\n  /**\n   * @return Whether a TRY node has a finally block.\n   */\n  static boolean hasFinally(Node n) {\n    Preconditions.checkArgument(n.isTry());\n    return n.getChildCount() == 3;\n  }\n\n  /**\n   * @return The BLOCK node containing the CATCH node (if any)\n   * of a TRY.\n   */\n  static Node getCatchBlock(Node n) {\n    Preconditions.checkArgument(n.isTry());\n    return n.getFirstChild().getNext();\n  }\n\n  /**\n   * @return Whether BLOCK (from a TRY node) contains a CATCH.\n   * @see NodeUtil#getCatchBlock\n   */\n  static boolean hasCatchHandler(Node n) {\n    Preconditions.checkArgument(n.isBlock());\n    return n.hasChildren() && n.getFirstChild().isCatch();\n  }\n\n  /**\n    * @param fnNode The function.\n    * @return The Node containing the Function parameters.\n    */\n  public static Node getFunctionParameters(Node fnNode) {\n    // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]\n    Preconditions.checkArgument(fnNode.isFunction());\n    return fnNode.getFirstChild().getNext();\n  }\n\n  /**\n   * Returns true if a name node represents a constant variable.\n   *\n   * <p>Determining whether a variable is constant has three steps:\n   * <ol>\n   * <li>In CodingConventionAnnotator, any name that matches the\n   *     {@link CodingConvention#isConstant(String)} is annotated with an\n   *     IS_CONSTANT_NAME property.\n   * <li>The normalize pass renames any variable with the IS_CONSTANT_NAME\n   *     annotation and that is initialized to a constant value with\n   *     a variable name including $$constant.\n   * <li>Return true here if the variable includes $$constant in its name.\n   * </ol>\n   *\n   * @param node A NAME or STRING node\n   * @return True if the variable is constant\n   */\n  static boolean isConstantName(Node node) {\n    return node.getBooleanProp(Node.IS_CONSTANT_NAME);\n  }\n\n  /** Whether the given name is constant by coding convention. */\n  static boolean isConstantByConvention(\n      CodingConvention convention, Node node, Node parent) {\n    String name = node.getString();\n    if (parent.isGetProp() &&\n        node == parent.getLastChild()) {\n      return convention.isConstantKey(name);\n    } else if (isObjectLitKey(node, parent)) {\n      return convention.isConstantKey(name);\n    } else {\n      return convention.isConstant(name);\n    }\n  }\n\n  /**\n   * Get the JSDocInfo for a function.\n   */\n  public static JSDocInfo getFunctionJSDocInfo(Node n) {\n    Preconditions.checkState(n.isFunction());\n    JSDocInfo fnInfo = n.getJSDocInfo();\n    if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {\n      // Look for the info on other nodes.\n      Node parent = n.getParent();\n      if (parent.isAssign()) {\n        // on ASSIGNs\n        fnInfo = parent.getJSDocInfo();\n      } else if (parent.isName()) {\n        // on var NAME = function() { ... };\n        fnInfo = parent.getParent().getJSDocInfo();\n      }\n    }\n    return fnInfo;\n  }\n\n  /**\n   * @param n The node.\n   * @return The source name property on the node or its ancestors.\n   */\n  public static String getSourceName(Node n) {\n    String sourceName = null;\n    while (sourceName == null && n != null) {\n      sourceName = n.getSourceFileName();\n      n = n.getParent();\n    }\n    return sourceName;\n  }\n\n  /**\n   * @param n The node.\n   * @return The source name property on the node or its ancestors.\n   */\n  public static StaticSourceFile getSourceFile(Node n) {\n    StaticSourceFile sourceName = null;\n    while (sourceName == null && n != null) {\n      sourceName = n.getStaticSourceFile();\n      n = n.getParent();\n    }\n    return sourceName;\n  }\n\n  /**\n   * @param n The node.\n   * @return The InputId property on the node or its ancestors.\n   */\n  public static InputId getInputId(Node n) {\n    while (n != null && !n.isScript()) {\n      n = n.getParent();\n    }\n\n    return (n != null && n.isScript()) ? n.getInputId() : null;\n  }\n\n  /**\n   * A new CALL node with the \"FREE_CALL\" set based on call target.\n   */\n  static Node newCallNode(Node callTarget, Node... parameters) {\n    boolean isFreeCall = !isGet(callTarget);\n    Node call = IR.call(callTarget);\n    call.putBooleanProp(Node.FREE_CALL, isFreeCall);\n    for (Node parameter : parameters) {\n      call.addChildToBack(parameter);\n    }\n    return call;\n  }\n\n  /**\n   * @return Whether the node is known to be a value that is not referenced\n   * elsewhere.\n   */\n  static boolean evaluatesToLocalValue(Node value) {\n    return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse());\n  }\n\n  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        return newHasLocalResult(value)\n               || locals.apply(value);\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.DELPROP:\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }\n\n  /**\n   * Given the first sibling, this returns the nth\n   * sibling or null if no such sibling exists.\n   * This is like \"getChildAtIndex\" but returns null for non-existent indexes.\n   */\n  private static Node getNthSibling(Node first, int index) {\n    Node sibling = first;\n    while (index != 0 && sibling != null) {\n      sibling = sibling.getNext();\n      index--;\n    }\n    return sibling;\n  }\n\n  /**\n   * Given the function, this returns the nth\n   * argument or null if no such parameter exists.\n   */\n  static Node getArgumentForFunction(Node function, int index) {\n    Preconditions.checkState(function.isFunction());\n    return getNthSibling(\n        function.getFirstChild().getNext().getFirstChild(), index);\n  }\n\n  /**\n   * Given the new or call, this returns the nth\n   * argument of the call or null if no such argument exists.\n   */\n  static Node getArgumentForCallOrNew(Node call, int index) {\n    Preconditions.checkState(isCallOrNew(call));\n    return getNthSibling(\n      call.getFirstChild().getNext(), index);\n  }\n\n  private static boolean isToStringMethodCall(Node call) {\n    Node getNode = call.getFirstChild();\n    if (isGet(getNode)) {\n      Node propNode = getNode.getLastChild();\n      return propNode.isString() && \"toString\".equals(propNode.getString());\n    }\n    return false;\n  }\n\n  /** Find the best JSDoc for the given node. */\n  static JSDocInfo getBestJSDocInfo(Node n) {\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      Node parent = n.getParent();\n      if (parent == null) {\n        return null;\n      }\n\n      if (parent.isName()) {\n        return getBestJSDocInfo(parent);\n      } else if (parent.isAssign()) {\n        return parent.getJSDocInfo();\n      } else if (isObjectLitKey(parent, parent.getParent())) {\n        return parent.getJSDocInfo();\n      } else if (parent.isFunction()) {\n        return parent.getJSDocInfo();\n      } else if (parent.isVar() && parent.hasOneChild()) {\n        return parent.getJSDocInfo();\n      } else if ((parent.isHook() && parent.getFirstChild() != n) ||\n                 parent.isOr() ||\n                 parent.isAnd() ||\n                 (parent.isComma() && parent.getFirstChild() != n)) {\n        return getBestJSDocInfo(parent);\n      }\n    }\n    return info;\n  }\n\n  /** Find the l-value that the given r-value is being assigned to. */\n  static Node getBestLValue(Node n) {\n    Node parent = n.getParent();\n    boolean isFunctionDeclaration = isFunctionDeclaration(n);\n    if (isFunctionDeclaration) {\n      return n.getFirstChild();\n    } else if (parent.isName()) {\n      return parent;\n    } else if (parent.isAssign()) {\n      return parent.getFirstChild();\n    } else if (isObjectLitKey(parent, parent.getParent())) {\n      return parent;\n    } else if (\n        (parent.isHook() && parent.getFirstChild() != n) ||\n        parent.isOr() ||\n        parent.isAnd() ||\n        (parent.isComma() && parent.getFirstChild() != n)) {\n      return getBestLValue(parent);\n    }\n    return null;\n  }\n\n  /** Gets the r-value of a node returned by getBestLValue. */\n  static Node getRValueOfLValue(Node n) {\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.ASSIGN:\n        return n.getNext();\n      case Token.VAR:\n        return n.getFirstChild();\n      case Token.FUNCTION:\n        return parent;\n    }\n    return null;\n  }\n\n  /** Get the owner of the given l-value node. */\n  static Node getBestLValueOwner(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (isObjectLitKey(lValue, lValue.getParent())) {\n      return getBestLValue(lValue.getParent());\n    } else if (isGet(lValue)) {\n      return lValue.getFirstChild();\n    }\n\n    return null;\n  }\n\n  /** Get the name of the given l-value node. */\n  static String getBestLValueName(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (isObjectLitKey(lValue, lValue.getParent())) {\n      Node owner = getBestLValue(lValue.getParent());\n      if (owner != null) {\n        String ownerName = getBestLValueName(owner);\n        if (ownerName != null) {\n          return ownerName + \".\" + getObjectLitKeyName(lValue);\n        }\n      }\n      return null;\n    }\n    return lValue.getQualifiedName();\n  }\n\n  /**\n   * @returns false iff the result of the expression is not consumed.\n   */\n  static boolean isExpressionResultUsed(Node expr) {\n    // TODO(johnlenz): consider sharing some code with trySimpleUnusedResult.\n    Node parent = expr.getParent();\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.EXPR_RESULT:\n        return false;\n      case Token.HOOK:\n      case Token.AND:\n      case Token.OR:\n        return (expr == parent.getFirstChild())\n            ? true : isExpressionResultUsed(parent);\n      case Token.COMMA:\n        Node gramps = parent.getParent();\n        if (gramps.isCall() &&\n            parent == gramps.getFirstChild()) {\n          // Semantically, a direct call to eval is different from an indirect\n          // call to an eval. See ECMA-262 S15.1.2.1. So it's OK for the first\n          // expression to a comma to be a no-op if it's used to indirect\n          // an eval. This we pretend that this is \"used\".\n          if (expr == parent.getFirstChild() &&\n              parent.getChildCount() == 2 &&\n              expr.getNext().isName() &&\n              \"eval\".equals(expr.getNext().getString())) {\n            return true;\n          }\n        }\n\n        return (expr == parent.getFirstChild())\n            ? false : isExpressionResultUsed(parent);\n      case Token.FOR:\n        if (!NodeUtil.isForIn(parent)) {\n          // Only an expression whose result is in the condition part of the\n          // expression is used.\n          return (parent.getChildAtIndex(1) == expr);\n        }\n        break;\n    }\n    return true;\n  }\n\n  /**\n   * @param n The expression to check.\n   * @return Whether the expression is unconditionally executed only once in the\n   *     containing execution scope.\n   */\n  static boolean isExecutedExactlyOnce(Node n) {\n    inspect: do {\n      Node parent = n.getParent();\n      switch (parent.getType()) {\n        case Token.IF:\n        case Token.HOOK:\n        case Token.AND:\n        case Token.OR:\n          if (parent.getFirstChild() != n) {\n            return false;\n          }\n          // other ancestors may be conditional\n          continue inspect;\n        case Token.FOR:\n          if (NodeUtil.isForIn(parent)) {\n            if (parent.getChildAtIndex(1) != n) {\n              return false;\n            }\n          } else {\n            if (parent.getFirstChild() != n) {\n              return false;\n            }\n          }\n          // other ancestors may be conditional\n          continue inspect;\n        case Token.WHILE:\n        case Token.DO:\n          return false;\n        case Token.TRY:\n          // Consider all code under a try/catch to be conditionally executed.\n          if (!hasFinally(parent) || parent.getLastChild() != n) {\n            return false;\n          }\n          continue inspect;\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n          return false;\n        case Token.SCRIPT:\n        case Token.FUNCTION:\n          // Done, we've reached the scope root.\n          break inspect;\n      }\n    } while ((n = n.getParent()) != null);\n    return true;\n  }\n\n  /**\n   * @return An appropriate AST node for the boolean value.\n   */\n  static Node booleanNode(boolean value) {\n    return value ? IR.trueNode() : IR.falseNode();\n  }\n\n  /**\n   * @return An appropriate AST node for the double value.\n   */\n  static Node numberNode(double value, Node srcref) {\n    Node result;\n    if (Double.isNaN(value)) {\n      result = IR.name(\"NaN\");\n    } else if (value == Double.POSITIVE_INFINITY) {\n      result = IR.name(\"Infinity\");\n    } else if (value == Double.NEGATIVE_INFINITY) {\n      result = IR.neg(IR.name(\"Infinity\"));\n    } else {\n      result = IR.number(value);\n    }\n    if (srcref != null) {\n      result.srcrefTree(srcref);\n    }\n    return result;\n  }\n}\n", "review": {"response": "{ \"bugs\": [\n\n  {\n    \"description\": \"Infinite recursion in getImpureBooleanValue for Token.HOOK\",\n    \"code\": \"case Token.HOOK:  {\\n  TernaryValue trueValue = getImpureBooleanValue(\\n      n.getFirstChild().getNext());\\n  TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\\n  if (trueValue.equals(falseValue)) {\\n    return trueValue;\\n  } else {\\n    return TernaryValue.UNKNOWN;\\n  }\\n}\",\n    \"reason\": \"The function calls itself recursively without any base case or termination condition. This will lead to a stack overflow error.\"\n  },\n\n  {\n    \"description\": \"Incorrect handling of Token.VOID in getPureBooleanValue\",\n    \"code\": \"case Token.VOID:\\n  if (!mayHaveSideEffects(n.getFirstChild())) {\\n    return TernaryValue.FALSE;\\n  }\\n  break;\",\n    \"reason\": \"The function should return TernaryValue.UNKNOWN for Token.VOID as it may have side effects, but it currently returns TernaryValue.FALSE if the first child doesn't have side effects.\"\n  },\n\n  {\n    \"description\": \"Incomplete handling of Token.NAME in getPureBooleanValue\",\n    \"code\": \"case Token.NAME:\\n  String name = n.getString();\\n  if (\\\"undefined\\\".equals(name)\\n      || \\\"NaN\\\".equals(name)) {\\n    return TernaryValue.FALSE;\\n  } else if (\\\"Infinity\\\".equals(name)) {\\n    return TernaryValue.TRUE;\\n  }\\n  break;\",\n    \"reason\": \"The function doesn't handle other reserved words like 'null', 'true', and 'false'. It should return TernaryValue.FALSE for 'null' and 'false', and TernaryValue.TRUE for 'true'.\"\n  },\n\n  {\n    \"description\": \"Incorrect handling of Token.REGEXP in getPureBooleanValue\",\n    \"code\": \"case Token.REGEXP:\\n  return TernaryValue.TRUE;\\n\",\n    \"reason\": \"The function should return TernaryValue.UNKNOWN for Token.REGEXP as it may have side effects.\"\n  },\n\n  {\n    \"description\": \"Incorrect handling of Token.ARRAYLIT and Token.OBJECTLIT in getPureBooleanValue\",\n    \"code\": \"case Token.ARRAYLIT:\\ncase Token.OBJECTLIT:\\n  if (!mayHaveSideEffects(n)) {\\n    return TernaryValue.TRUE;\\n  }\\n  break;\",\n    \"reason\": \"The function should return TernaryValue.UNKNOWN for Token.ARRAYLIT and Token.OBJECTLIT as they may have side effects.\"\n  }\n\n] }"}}