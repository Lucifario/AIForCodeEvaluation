{"sample_id": "Closure_30", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.graph.GraphNode;\nimport com.google.javascript.jscomp.graph.LatticeElement;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport javax.annotation.Nullable;\n\n/**\n * Computes reaching definition for all use of each variables.\n *\n * A definition of {@code A} in {@code A = foo()} is a reaching definition of\n * the use of {@code A} in {@code alert(A)} if all paths from entry node must\n * reaches that definition and it is the last definition before the use.\n *\n */\nfinal class MustBeReachingVariableDef extends\n    DataFlowAnalysis<Node, MustBeReachingVariableDef.MustDef> {\n\n  // The scope of the function that we are analyzing.\n  private final Scope jsScope;\n  private final AbstractCompiler compiler;\n  private final Set<Var> escaped;\n\n  MustBeReachingVariableDef(\n      ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) {\n    super(cfg, new MustDefJoin());\n    this.jsScope = jsScope;\n    this.compiler = compiler;\n    this.escaped = Sets.newHashSet();\n    computeEscaped(jsScope, escaped, compiler);\n  }\n\n  /**\n   * Abstraction of a local variable definition. It represents the node which\n   * a local variable is defined as well as a set of other local variables that\n   * this definition reads from. For example N: a = b + foo.bar(c). The\n   * definition node will be N, the depending set would be {b,c}.\n   */\n  private static class Definition {\n    final Node node;\n    final Set<Var> depends = Sets.newHashSet();\n\n    Definition(Node node) {\n      this.node = node;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n      if (!(other instanceof Definition)) {\n        return false;\n      }\n      Definition otherDef = (Definition) other;\n      // If the var has the same definition node we can assume they have the\n      // same depends set.\n      return otherDef.node == node;\n    }\n  }\n\n  /**\n   * Must reaching definition lattice representation. It captures a product\n   * lattice for each local (non-escaped) variable. The sub-lattice is\n   * a n + 2 element lattice with all the {@link Definition} in the program,\n   * TOP and BOTTOM.\n   *\n   * <p>Since this is a Must-Define analysis, BOTTOM represents the case where\n   * there might be more than one reaching definition for the variable.\n   *\n   *\n   *           (TOP)\n   *       /   |   |      \\\n   *     N1    N2  N3 ....Nn\n   *      \\    |   |      /\n   *          (BOTTOM)\n   *\n   */\n  static final class MustDef implements LatticeElement {\n\n    // TODO(user): Use bit vector instead of maps might get better\n    // performance. Change it after this is tested to be fully functional.\n\n    // When a Var \"A\" = \"TOP\", \"A\" does not exist in reachingDef's keySet.\n    // When a Var \"A\" = Node N, \"A\" maps to that node.\n    // When a Var \"A\" = \"BOTTOM\", \"A\" maps to null.\n    final Map<Var, Definition> reachingDef;\n\n    public MustDef() {\n      reachingDef = Maps.newHashMap();\n    }\n\n    public MustDef(Iterator<Var> vars) {\n      this();\n      while(vars.hasNext()) {\n        Var var = vars.next();\n        // Every variable in the scope is defined once in the beginning of the\n        // function: all the declared variables are undefined, all functions\n        // have been assigned and all arguments has its value from the caller.\n        reachingDef.put(var, new Definition(var.scope.getRootNode()));\n      }\n    }\n\n    /**\n     * Copy constructor.\n     *\n     * @param other The constructed object is a replicated copy of this element.\n     */\n    public MustDef(MustDef other) {\n      reachingDef = Maps.newHashMap(other.reachingDef);\n    }\n\n    @Override\n    public boolean equals(Object other) {\n      return (other instanceof MustDef) &&\n          ((MustDef) other).reachingDef.equals(this.reachingDef);\n    }\n  }\n\n  private static class MustDefJoin extends JoinOp.BinaryJoinOp<MustDef> {\n    @Override\n    public MustDef apply(MustDef a, MustDef b) {\n      MustDef result = new MustDef();\n      Map<Var, Definition> resultMap = result.reachingDef;\n\n      // Take the join of all variables that are not TOP in this.\n      for (Map.Entry<Var, Definition> varEntry : a.reachingDef.entrySet()) {\n        Var var = varEntry.getKey();\n        Definition aDef = varEntry.getValue();\n\n        if (aDef == null) {\n          // \"a\" is BOTTOM implies that the variable has more than one possible\n          // definition. We set the join of this to be BOTTOM regardless of what\n          // \"b\" might be.\n          resultMap.put(var, null);\n          continue;\n        }\n\n        Node aNode = aDef.node;\n\n        if (b.reachingDef.containsKey(var)) {\n          Definition bDef = b.reachingDef.get(var);\n\n          if (aDef.equals(bDef)) {\n            resultMap.put(var, aDef);\n          } else {\n            resultMap.put(var, null);\n          }\n        } else {\n          resultMap.put(var, aDef);\n        }\n      }\n\n      // Take the join of all variables that are not TOP in other but it is TOP\n      // in this.\n      for (Map.Entry<Var, Definition> entry : b.reachingDef.entrySet()) {\n        Var var = entry.getKey();\n        if (!a.reachingDef.containsKey(var)) {\n          resultMap.put(var, entry.getValue());\n        }\n      }\n      return result;\n    }\n  }\n\n  @Override\n  boolean isForward() {\n    return true;\n  }\n\n  @Override\n  MustDef createEntryLattice() {\n    return new MustDef(jsScope.getVars());\n  }\n\n  @Override\n  MustDef createInitialEstimateLattice() {\n    return new MustDef();\n  }\n\n  @Override\n  MustDef flowThrough(Node n, MustDef input) {\n    // TODO(user): We are doing a straight copy from input to output. There\n    // might be some opportunities to cut down overhead.\n    MustDef output = new MustDef(input);\n    // TODO(user): This must know about ON_EX edges but it should handle\n    // it better than what we did in liveness. Because we are in a forward mode,\n    // we can used the branched forward analysis.\n    computeMustDef(n, n, output, false);\n    return output;\n  }\n\n  /**\n   * @param n The node in question.\n   * @param cfgNode The node to add\n   * @param conditional true if the definition is not always executed.\n   */\n  private void computeMustDef(\n      Node n, Node cfgNode, MustDef output, boolean conditional) {\n    switch (n.getType()) {\n\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeMustDef(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeMustDef(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (lhs.isVar()) {\n            lhs = lhs.getLastChild(); // for(var x in y) {...}\n          }\n          if (lhs.isName()) {\n            addToDefIfLocal(lhs.getString(), cfgNode, rhs, output);\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeMustDef(n.getFirstChild(), cfgNode, output, conditional);\n        computeMustDef(n.getLastChild(), cfgNode, output, true);\n        return;\n\n      case Token.HOOK:\n        computeMustDef(n.getFirstChild(), cfgNode, output, conditional);\n        computeMustDef(n.getFirstChild().getNext(), cfgNode, output, true);\n        computeMustDef(n.getLastChild(), cfgNode, output, true);\n        return;\n\n      case Token.VAR:\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (c.hasChildren()) {\n            computeMustDef(c.getFirstChild(), cfgNode, output, conditional);\n            addToDefIfLocal(c.getString(), conditional ? null : cfgNode,\n                c.getFirstChild(), output);\n          }\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n)) {\n          if (n.getFirstChild().isName()) {\n            Node name = n.getFirstChild();\n            computeMustDef(name.getNext(), cfgNode, output, conditional);\n            addToDefIfLocal(name.getString(), conditional ? null : cfgNode,\n              n.getLastChild(), output);\n            return;\n          } else if (NodeUtil.isGet(n.getFirstChild())) {\n            // Treat all assignments to arguments as redefining the\n            // parameters itself.\n            Node obj = n.getFirstChild().getFirstChild();\n            if (obj.isName() && \"arguments\".equals(obj.getString())) {\n              // TODO(user): More accuracy can be introduced\n              // ie: We know exactly what arguments[x] is if x is a constant\n              // number.\n              escapeParameters(output);\n            }\n          }\n        }\n\n        if (n.isName() && \"arguments\".equals(n.getString())) {\n          escapeParameters(output);\n        }\n\n        // DEC and INC actually defines the variable.\n        if (n.isDec() || n.isInc()) {\n          Node target = n.getFirstChild();\n          if (target.isName()) {\n            addToDefIfLocal(target.getString(),\n                conditional ? null : cfgNode, null, output);\n            return;\n          }\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          computeMustDef(c, cfgNode, output, conditional);\n        }\n    }\n  }\n\n  /**\n   * Set the variable lattice for the given name to the node value in the def\n   * lattice. Do nothing if the variable name is one of the escaped variable.\n   *\n   * @param node The CFG node where the definition should be record to.\n   *     {@code null} if this is a conditional define.\n   */\n  private void addToDefIfLocal( String name, @Nullable Node node,\n      @Nullable Node rValue, MustDef def) {\n    Var var = jsScope.getVar(name);\n\n    // var might be null because the variable might be defined in the extern\n    // that we might not traverse.\n    if (var == null || var.scope != jsScope) {\n      return;\n    }\n\n    for (Var other : def.reachingDef.keySet()) {\n      Definition otherDef = def.reachingDef.get(other);\n      if (otherDef == null) {\n        continue;\n      }\n      if (otherDef.depends.contains(var)) {\n        def.reachingDef.put(other, null);\n      }\n    }\n\n    if (!escaped.contains(var)) {\n      if (node == null) {\n        def.reachingDef.put(var, null);\n      } else {\n        Definition definition = new Definition(node);\n        if (rValue != null) {\n          computeDependence(definition, rValue);\n        }\n        def.reachingDef.put(var, definition);\n      }\n    }\n  }\n\n  private void escapeParameters(MustDef output) {\n    for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) {\n      Var v = i.next();\n      if (isParameter(v)) {\n        // Assume we no longer know where the parameter comes from\n        // anymore.\n        output.reachingDef.put(v, null);\n      }\n    }\n\n    // Also, assume we no longer know anything that depends on a parameter.\n    for (Entry<Var, Definition> pair: output.reachingDef.entrySet()) {\n      Definition value = pair.getValue();\n      if (value == null) {\n        continue;\n      }\n      for (Var dep : value.depends) {\n        if (isParameter(dep)) {\n          output.reachingDef.put(pair.getKey(), null);\n        }\n      }\n    }\n  }\n\n  private boolean isParameter(Var v) {\n    return v.getParentNode().isParamList();\n  }\n\n  /**\n   * Computes all the local variables that rValue reads from and store that\n   * in the def's depends set.\n   */\n  private void computeDependence(final Definition def, Node rValue) {\n    NodeTraversal.traverse(compiler, rValue,\n        new AbstractCfgNodeTraversalCallback() {\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\n          Var dep = jsScope.getVar(n.getString());\n            def.depends.add(dep);\n        }\n      }\n    });\n  }\n\n  /**\n   * Gets the must reaching definition of a given node. The node must be one of\n   * the control flow graph nodes.\n   *\n   * @param name name of the variable. It can only be names of local variable\n   *     that are not function parameters, escaped variables or variables\n   *     declared in catch.\n   * @param useNode the location of the use where the definition reaches.\n   */\n  Node getDef(String name, Node useNode) {\n    Preconditions.checkArgument(getCfg().hasNode(useNode));\n    GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n    FlowState<MustDef> state = n.getAnnotation();\n    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n    if (def == null) {\n      return null;\n    } else {\n      return def.node;\n    }\n  }\n\n  boolean dependsOnOuterScopeVars(String name, Node useNode) {\n    Preconditions.checkArgument(getCfg().hasNode(useNode));\n    GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n    FlowState<MustDef> state = n.getAnnotation();\n    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n\n    for (Var s : def.depends) {\n      if (s.scope != jsScope) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n", "review": {"response": "{\n  \"bugs\": []\n}"}}