{"sample_id": "Math_64", "model": "qwen-coder-32b", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math.optimization.general;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.optimization.OptimizationException;\nimport org.apache.commons.math.optimization.VectorialPointValuePair;\nimport org.apache.commons.math.util.MathUtils;\n\n\n/**\n * This class solves a least squares problem using the Levenberg-Marquardt algorithm.\n *\n * <p>This implementation <em>should</em> work even for over-determined systems\n * (i.e. systems having more point than equations). Over-determined systems\n * are solved by ignoring the point which have the smallest impact according\n * to their jacobian column norm. Only the rank of the matrix and some loop bounds\n * are changed to implement this.</p>\n *\n * <p>The resolution engine is a simple translation of the MINPACK <a\n * href=\"http://www.netlib.org/minpack/lmder.f\">lmder</a> routine with minor\n * changes. The changes include the over-determined resolution, the use of\n * inherited convergence checker and the Q.R. decomposition which has been\n * rewritten following the algorithm described in the\n * P. Lascaux and R. Theodor book <i>Analyse num&eacute;rique matricielle\n * appliqu&eacute;e &agrave; l'art de l'ing&eacute;nieur</i>, Masson 1986.</p>\n * <p>The authors of the original fortran version are:\n * <ul>\n * <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n * <li>Burton S. Garbow</li>\n * <li>Kenneth E. Hillstrom</li>\n * <li>Jorge J. More</li>\n * </ul>\n * The redistribution policy for MINPACK is available <a\n * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for convenience, it\n * is reproduced below.</p>\n *\n * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n * <tr><td>\n *    Minpack Copyright Notice (1999) University of Chicago.\n *    All rights reserved\n * </td></tr>\n * <tr><td>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * <ol>\n *  <li>Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.</li>\n * <li>Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.</li>\n * <li>The end-user documentation included with the redistribution, if any,\n *     must include the following acknowledgment:\n *     <code>This product includes software developed by the University of\n *           Chicago, as Operator of Argonne National Laboratory.</code>\n *     Alternately, this acknowledgment may appear in the software itself,\n *     if and wherever such third-party acknowledgments normally appear.</li>\n * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n *     BE CORRECTED.</strong></li>\n * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n * <ol></td></tr>\n * </table>\n * @version $Revision$ $Date$\n * @since 2.0\n *\n */\npublic class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n\n    /** Number of solved point. */\n    private int solvedCols;\n\n    /** Diagonal elements of the R matrix in the Q.R. decomposition. */\n    private double[] diagR;\n\n    /** Norms of the columns of the jacobian matrix. */\n    private double[] jacNorm;\n\n    /** Coefficients of the Householder transforms vectors. */\n    private double[] beta;\n\n    /** Columns permutation array. */\n    private int[] permutation;\n\n    /** Rank of the jacobian matrix. */\n    private int rank;\n\n    /** Levenberg-Marquardt parameter. */\n    private double lmPar;\n\n    /** Parameters evolution direction associated with lmPar. */\n    private double[] lmDir;\n\n    /** Positive input variable used in determining the initial step bound. */\n    private double initialStepBoundFactor;\n\n    /** Desired relative error in the sum of squares. */\n    private double costRelativeTolerance;\n\n    /**  Desired relative error in the approximate solution parameters. */\n    private double parRelativeTolerance;\n\n    /** Desired max cosine on the orthogonality between the function vector\n     * and the columns of the jacobian. */\n    private double orthoTolerance;\n\n    /** Threshold for QR ranking. */\n    private double qrRankingThreshold;\n\n    /**\n     * Build an optimizer for least squares problems.\n     * <p>The default values for the algorithm settings are:\n     *   <ul>\n     *    <li>{@link #setConvergenceChecker(VectorialConvergenceChecker) vectorial convergence checker}: null</li>\n     *    <li>{@link #setInitialStepBoundFactor(double) initial step bound factor}: 100.0</li>\n     *    <li>{@link #setMaxIterations(int) maximal iterations}: 1000</li>\n     *    <li>{@link #setCostRelativeTolerance(double) cost relative tolerance}: 1.0e-10</li>\n     *    <li>{@link #setParRelativeTolerance(double) parameters relative tolerance}: 1.0e-10</li>\n     *    <li>{@link #setOrthoTolerance(double) orthogonality tolerance}: 1.0e-10</li>\n     *    <li>{@link #setQRRankingThreshold(double) QR ranking threshold}: {@link MathUtils#SAFE_MIN}</li>\n     *   </ul>\n     * </p>\n     * <p>These default values may be overridden after construction. If the {@link\n     * #setConvergenceChecker vectorial convergence checker} is set to a non-null value, it\n     * will be used instead of the {@link #setCostRelativeTolerance cost relative tolerance}\n     * and {@link #setParRelativeTolerance parameters relative tolerance} settings.\n     */\n    public LevenbergMarquardtOptimizer() {\n\n        // set up the superclass with a default  max cost evaluations setting\n        setMaxIterations(1000);\n\n        // default values for the tuning parameters\n        setConvergenceChecker(null);\n        setInitialStepBoundFactor(100.0);\n        setCostRelativeTolerance(1.0e-10);\n        setParRelativeTolerance(1.0e-10);\n        setOrthoTolerance(1.0e-10);\n        setQRRankingThreshold(MathUtils.SAFE_MIN);\n\n    }\n\n    /**\n     * Set the positive input variable used in determining the initial step bound.\n     * This bound is set to the product of initialStepBoundFactor and the euclidean\n     * norm of diag*x if nonzero, or else to initialStepBoundFactor itself. In most\n     * cases factor should lie in the interval (0.1, 100.0). 100.0 is a generally\n     * recommended value.\n     *\n     * @param initialStepBoundFactor initial step bound factor\n     */\n    public void setInitialStepBoundFactor(double initialStepBoundFactor) {\n        this.initialStepBoundFactor = initialStepBoundFactor;\n    }\n\n    /**\n     * Set the desired relative error in the sum of squares.\n     * <p>This setting is used only if the {@link #setConvergenceChecker vectorial\n     * convergence checker} is set to null.</p>\n     * @param costRelativeTolerance desired relative error in the sum of squares\n     */\n    public void setCostRelativeTolerance(double costRelativeTolerance) {\n        this.costRelativeTolerance = costRelativeTolerance;\n    }\n\n    /**\n     * Set the desired relative error in the approximate solution parameters.\n     * <p>This setting is used only if the {@link #setConvergenceChecker vectorial\n     * convergence checker} is set to null.</p>\n     * @param parRelativeTolerance desired relative error\n     * in the approximate solution parameters\n     */\n    public void setParRelativeTolerance(double parRelativeTolerance) {\n        this.parRelativeTolerance = parRelativeTolerance;\n    }\n\n    /**\n     * Set the desired max cosine on the orthogonality.\n     * <p>This setting is always used, regardless of the {@link #setConvergenceChecker\n     * vectorial convergence checker} being null or non-null.</p>\n     * @param orthoTolerance desired max cosine on the orthogonality\n     * between the function vector and the columns of the jacobian\n     */\n    public void setOrthoTolerance(double orthoTolerance) {\n        this.orthoTolerance = orthoTolerance;\n    }\n\n    /**\n     * Set the desired threshold for QR ranking.\n     * <p>\n     * If the squared norm of a column vector is smaller or equal to this threshold\n     * during QR decomposition, it is considered to be a zero vector and hence the\n     * rank of the matrix is reduced.\n     * </p>\n     * @param threshold threshold for QR ranking\n     */\n    public void setQRRankingThreshold(final double threshold) {\n        this.qrRankingThreshold = threshold;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // arrays shared with the other private methods\n        solvedCols  = Math.min(rows, cols);\n        diagR       = new double[cols];\n        jacNorm     = new double[cols];\n        beta        = new double[cols];\n        permutation = new int[cols];\n        lmDir       = new double[cols];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[cols];\n        double[] oldX    = new double[cols];\n        double[] oldRes  = new double[rows];\n        double[] work1   = new double[cols];\n        double[] work2   = new double[cols];\n        double[] work3   = new double[cols];\n\n        // evaluate the function at the starting point and calculate its norm\n        updateResidualsAndCost();\n\n        // outer loop\n        lmPar = 0;\n        boolean firstIteration = true;\n        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n        while (true) {\n            incrementIterationsCounter();\n\n            // compute the Q.R. decomposition of the jacobian matrix\n            VectorialPointValuePair previous = current;\n            updateJacobian();\n            qrDecomposition();\n\n            // compute Qt.res\n            qTy(residuals);\n            // now we don't need Q anymore,\n            // so let jacobian contain the R matrix with its diagonal elements\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                jacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n\n                // scale the point according to the norms of the columns\n                // of the initial jacobian\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * point[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // initialize the step bound delta\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n            }\n\n            // check orthogonality between function vector and jacobian columns\n            double maxCosine = 0;\n            if (cost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += jacobian[i][pj] * residuals[i];\n                        }\n                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                // convergence has been reached\n                return current;\n            }\n\n            // rescale if necessary\n            for (int j = 0; j < cols; ++j) {\n                diag[j] = Math.max(diag[j], jacNorm[j]);\n            }\n\n            // inner loop\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = point[pj];\n                }\n                double previousCost = cost;\n                double[] tmpVec = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n\n                // determine the Levenberg-Marquardt parameter\n                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n                // compute the new point and the norm of the evolution direction\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    point[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = Math.sqrt(lmNorm);\n                // on the first iteration, adjust the initial step bound.\n                if (firstIteration) {\n                    delta = Math.min(delta, lmNorm);\n                }\n\n                // evaluate the function at x + p and calculate its norm\n                updateResidualsAndCost();\n                current = new VectorialPointValuePair(point, objective);\n\n                // compute the scaled actual reduction\n                double actRed = -1.0;\n                if (0.1 * cost < previousCost) {\n                    double r = cost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                // compute the scaled predicted reduction\n                // and the scaled directional derivative\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += jacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                // ratio of the actual to the predicted reduction\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                // update the step bound\n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                // test for successful iteration.\n                if (ratio >= 1.0e-4) {\n                    // successful iteration, update the norm\n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < cols; ++k) {\n                        double xK = diag[k] * point[k];\n                        xNorm    += xK * xK;\n                    }\n                    xNorm = Math.sqrt(xNorm);\n\n                    // tests for convergence.\n                    // we use the vectorial convergence checker\n                } else {\n                    // failed iteration, reset the previous values\n                    cost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        point[pj] = oldX[pj];\n                    }\n                    tmpVec    = residuals;\n                    residuals = oldRes;\n                    oldRes    = tmpVec;\n                }\n                if (checker==null) {\n                \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                        (preRed <= costRelativeTolerance) &&\n                        (ratio <= 2.0)) ||\n                       (delta <= parRelativeTolerance * xNorm)) {\n                       return current;\n                   }\n                } else {\n                    if (checker.converged(getIterations(), previous, current)) {\n                        return current;\n                    }\n                }\n                // tests for termination and stringent tolerances\n                // (2.2204e-16 is the machine epsilon for IEEE754)\n                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                            costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                            parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                            orthoTolerance);\n                }\n\n            }\n\n        }\n\n    }\n\n    /**\n     * Determine the Levenberg-Marquardt parameter.\n     * <p>This implementation is a translation in Java of the MINPACK\n     * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n     * routine.</p>\n     * <p>This method sets the lmPar and lmDir attributes.</p>\n     * <p>The authors of the original fortran function are:</p>\n     * <ul>\n     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n     *   <li>Burton  S. Garbow</li>\n     *   <li>Kenneth E. Hillstrom</li>\n     *   <li>Jorge   J. More</li>\n     * </ul>\n     * <p>Luc Maisonobe did the Java translation.</p>\n     *\n     * @param qy array containing qTy\n     * @param delta upper bound on the euclidean norm of diagR * lmDir\n     * @param diag diagonal matrix\n     * @param work1 work array\n     * @param work2 work array\n     * @param work3 work array\n     */\n    private void determineLMParameter(double[] qy, double delta, double[] diag,\n            double[] work1, double[] work2, double[] work3) {\n\n        // compute and store in x the gauss-newton direction, if the\n        // jacobian is rank-deficient, obtain a least squares solution\n        for (int j = 0; j < rank; ++j) {\n            lmDir[permutation[j]] = qy[j];\n        }\n        for (int j = rank; j < cols; ++j) {\n            lmDir[permutation[j]] = 0;\n        }\n        for (int k = rank - 1; k >= 0; --k) {\n            int pk = permutation[k];\n            double ypk = lmDir[pk] / diagR[pk];\n            for (int i = 0; i < k; ++i) {\n                lmDir[permutation[i]] -= ypk * jacobian[i][pk];\n            }\n            lmDir[pk] = ypk;\n        }\n\n        // evaluate the function at the origin, and test\n        // for acceptance of the Gauss-Newton direction\n        double dxNorm = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double s = diag[pj] * lmDir[pj];\n            work1[pj] = s;\n            dxNorm += s * s;\n        }\n        dxNorm = Math.sqrt(dxNorm);\n        double fp = dxNorm - delta;\n        if (fp <= 0.1 * delta) {\n            lmPar = 0;\n            return;\n        }\n\n        // if the jacobian is not rank deficient, the Newton step provides\n        // a lower bound, parl, for the zero of the function,\n        // otherwise set this bound to zero\n        double sum2;\n        double parl = 0;\n        if (rank == solvedCols) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] *= diag[pj] / dxNorm;\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = 0; i < j; ++i) {\n                    sum += jacobian[i][pj] * work1[permutation[i]];\n                }\n                double s = (work1[pj] - sum) / diagR[pj];\n                work1[pj] = s;\n                sum2 += s * s;\n            }\n            parl = fp / (delta * sum2);\n        }\n\n        // calculate an upper bound, paru, for the zero of the function\n        sum2 = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double sum = 0;\n            for (int i = 0; i <= j; ++i) {\n                sum += jacobian[i][pj] * qy[i];\n            }\n            sum /= diag[pj];\n            sum2 += sum * sum;\n        }\n        double gNorm = Math.sqrt(sum2);\n        double paru = gNorm / delta;\n        if (paru == 0) {\n            // 2.2251e-308 is the smallest positive real for IEE754\n            paru = 2.2251e-308 / Math.min(delta, 0.1);\n        }\n\n        // if the input par lies outside of the interval (parl,paru),\n        // set par to the closer endpoint\n        lmPar = Math.min(paru, Math.max(lmPar, parl));\n        if (lmPar == 0) {\n            lmPar = gNorm / dxNorm;\n        }\n\n        for (int countdown = 10; countdown >= 0; --countdown) {\n\n            // evaluate the function at the current value of lmPar\n            if (lmPar == 0) {\n                lmPar = Math.max(2.2251e-308, 0.001 * paru);\n            }\n            double sPar = Math.sqrt(lmPar);\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = sPar * diag[pj];\n            }\n            determineLMDirection(qy, work1, work2, work3);\n\n            dxNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = diag[pj] * lmDir[pj];\n                work3[pj] = s;\n                dxNorm += s * s;\n            }\n            dxNorm = Math.sqrt(dxNorm);\n            double previousFP = fp;\n            fp = dxNorm - delta;\n\n            // if the function is small enough, accept the current value\n            // of lmPar, also test for the exceptional cases where parl is zero\n            if ((Math.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n                return;\n            }\n\n            // compute the Newton correction\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n            }\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] /= work2[j];\n                double tmp = work1[pj];\n                for (int i = j + 1; i < solvedCols; ++i) {\n                    work1[permutation[i]] -= jacobian[i][pj] * tmp;\n                }\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                double s = work1[permutation[j]];\n                sum2 += s * s;\n            }\n            double correction = fp / (delta * sum2);\n\n            // depending on the sign of the function, update parl or paru.\n            if (fp > 0) {\n                parl = Math.max(parl, lmPar);\n            } else if (fp < 0) {\n                paru = Math.min(paru, lmPar);\n            }\n\n            // compute an improved estimate for lmPar\n            lmPar = Math.max(parl, lmPar + correction);\n\n        }\n    }\n\n    /**\n     * Solve a*x = b and d*x = 0 in the least squares sense.\n     * <p>This implementation is a translation in Java of the MINPACK\n     * <a href=\"http://www.netlib.org/minpack/qrsolv.f\">qrsolv</a>\n     * routine.</p>\n     * <p>This method sets the lmDir and lmDiag attributes.</p>\n     * <p>The authors of the original fortran function are:</p>\n     * <ul>\n     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n     *   <li>Burton  S. Garbow</li>\n     *   <li>Kenneth E. Hillstrom</li>\n     *   <li>Jorge   J. More</li>\n     * </ul>\n     * <p>Luc Maisonobe did the Java translation.</p>\n     *\n     * @param qy array containing qTy\n     * @param diag diagonal matrix\n     * @param lmDiag diagonal elements associated with lmDir\n     * @param work work array\n     */\n    private void determineLMDirection(double[] qy, double[] diag,\n            double[] lmDiag, double[] work) {\n\n        // copy R and Qty to preserve input and initialize s\n        //  in particular, save the diagonal elements of R in lmDir\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            for (int i = j + 1; i < solvedCols; ++i) {\n                jacobian[i][pj] = jacobian[j][permutation[i]];\n            }\n            lmDir[j] = diagR[pj];\n            work[j]  = qy[j];\n        }\n\n        // eliminate the diagonal matrix d using a Givens rotation\n        for (int j = 0; j < solvedCols; ++j) {\n\n            // prepare the row of d to be eliminated, locating the\n            // diagonal element using p from the Q.R. factorization\n            int pj = permutation[j];\n            double dpj = diag[pj];\n            if (dpj != 0) {\n                Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);\n            }\n            lmDiag[j] = dpj;\n\n            //  the transformations to eliminate the row of d\n            // modify only a single element of Qty\n            // beyond the first n, which is initially zero.\n            double qtbpj = 0;\n            for (int k = j; k < solvedCols; ++k) {\n                int pk = permutation[k];\n\n                // determine a Givens rotation which eliminates the\n                // appropriate element in the current row of d\n                if (lmDiag[k] != 0) {\n\n                    final double sin;\n                    final double cos;\n                    double rkk = jacobian[k][pk];\n                    if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n                        final double cotan = rkk / lmDiag[k];\n                        sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n                        cos   = sin * cotan;\n                    } else {\n                        final double tan = lmDiag[k] / rkk;\n                        cos = 1.0 / Math.sqrt(1.0 + tan * tan);\n                        sin = cos * tan;\n                    }\n\n                    // compute the modified diagonal element of R and\n                    // the modified element of (Qty,0)\n                    jacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n                    final double temp = cos * work[k] + sin * qtbpj;\n                    qtbpj = -sin * work[k] + cos * qtbpj;\n                    work[k] = temp;\n\n                    // accumulate the tranformation in the row of s\n                    for (int i = k + 1; i < solvedCols; ++i) {\n                        double rik = jacobian[i][pk];\n                        final double temp2 = cos * rik + sin * lmDiag[i];\n                        lmDiag[i] = -sin * rik + cos * lmDiag[i];\n                        jacobian[i][pk] = temp2;\n                    }\n\n                }\n            }\n\n            // store the diagonal element of s and restore\n            // the corresponding diagonal element of R\n            lmDiag[j] = jacobian[j][permutation[j]];\n            jacobian[j][permutation[j]] = lmDir[j];\n\n        }\n\n        // solve the triangular system for z, if the system is\n        // singular, then obtain a least squares solution\n        int nSing = solvedCols;\n        for (int j = 0; j < solvedCols; ++j) {\n            if ((lmDiag[j] == 0) && (nSing == solvedCols)) {\n                nSing = j;\n            }\n            if (nSing < solvedCols) {\n                work[j] = 0;\n            }\n        }\n        if (nSing > 0) {\n            for (int j = nSing - 1; j >= 0; --j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = j + 1; i < nSing; ++i) {\n                    sum += jacobian[i][pj] * work[i];\n                }\n                work[j] = (work[j] - sum) / lmDiag[j];\n            }\n        }\n\n        // permute the components of z back to components of lmDir\n        for (int j = 0; j < lmDir.length; ++j) {\n            lmDir[permutation[j]] = work[j];\n        }\n\n    }\n\n    /**\n     * Decompose a matrix A as A.P = Q.R using Householder transforms.\n     * <p>As suggested in the P. Lascaux and R. Theodor book\n     * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;\n     * l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing\n     * the Householder transforms with u<sub>k</sub> unit vectors such that:\n     * <pre>\n     * H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup>\n     * </pre>\n     * we use <sub>k</sub> non-unit vectors such that:\n     * <pre>\n     * H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup>\n     * </pre>\n     * where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>.\n     * The beta<sub>k</sub> coefficients are provided upon exit as recomputing\n     * them from the v<sub>k</sub> vectors would be costly.</p>\n     * <p>This decomposition handles rank deficient cases since the tranformations\n     * are performed in non-increasing columns norms order thanks to columns\n     * pivoting. The diagonal elements of the R matrix are therefore also in\n     * non-increasing absolute values order.</p>\n     * @exception OptimizationException if the decomposition cannot be performed\n     */\n    private void qrDecomposition() throws OptimizationException {\n\n        // initializations\n        for (int k = 0; k < cols; ++k) {\n            permutation[k] = k;\n            double norm2 = 0;\n            for (int i = 0; i < jacobian.length; ++i) {\n                double akk = jacobian[i][k];\n                norm2 += akk * akk;\n            }\n            jacNorm[k] = Math.sqrt(norm2);\n        }\n\n        // transform the matrix column after column\n        for (int k = 0; k < cols; ++k) {\n\n            // select the column with the greatest norm on active components\n            int nextColumn = -1;\n            double ak2 = Double.NEGATIVE_INFINITY;\n            for (int i = k; i < cols; ++i) {\n                double norm2 = 0;\n                for (int j = k; j < jacobian.length; ++j) {\n                    double aki = jacobian[j][permutation[i]];\n                    norm2 += aki * aki;\n                }\n                if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                    throw new OptimizationException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\n                            rows, cols);\n                }\n                if (norm2 > ak2) {\n                    nextColumn = i;\n                    ak2        = norm2;\n                }\n            }\n            if (ak2 <= qrRankingThreshold) {\n                rank = k;\n                return;\n            }\n            int pk                  = permutation[nextColumn];\n            permutation[nextColumn] = permutation[k];\n            permutation[k]          = pk;\n\n            // choose alpha such that Hk.u = alpha ek\n            double akk   = jacobian[k][pk];\n            double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n            double betak = 1.0 / (ak2 - akk * alpha);\n            beta[pk]     = betak;\n\n            // transform the current column\n            diagR[pk]        = alpha;\n            jacobian[k][pk] -= alpha;\n\n            // transform the remaining columns\n            for (int dk = cols - 1 - k; dk > 0; --dk) {\n                double gamma = 0;\n                for (int j = k; j < jacobian.length; ++j) {\n                    gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n                }\n                gamma *= betak;\n                for (int j = k; j < jacobian.length; ++j) {\n                    jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];\n                }\n            }\n\n        }\n\n        rank = solvedCols;\n\n    }\n\n    /**\n     * Compute the product Qt.y for some Q.R. decomposition.\n     *\n     * @param y vector to multiply (will be overwritten with the result)\n     */\n    private void qTy(double[] y) {\n        for (int k = 0; k < cols; ++k) {\n            int pk = permutation[k];\n            double gamma = 0;\n            for (int i = k; i < rows; ++i) {\n                gamma += jacobian[i][pk] * y[i];\n            }\n            gamma *= beta[pk];\n            for (int i = k; i < rows; ++i) {\n                y[i] -= gamma * jacobian[i][pk];\n            }\n        }\n    }\n\n}\n", "review": {"response": "<think>\nOkay, let's take a look at this Java code. The user wants me to review it for bugs and return a JSON list of any bugs I find. The code is part of the Apache Commons Math library, specifically the LevenbergMarquardtOptimizer class. The code seems to be a Java port of the MINPACK lmder routine.\n\nFirst, I'll start by scanning through the code for any obvious syntax errors. The code starts with package declarations and imports. The class declaration looks correct. The fields are declared with appropriate types. \n\nLooking at the class body, I notice that there's a comment block that's quite long, but that's probably okay. The methods might be in another file or maybe this is a snippet. Wait, the code ends abruptly with \"private double[] lmDir;\" and then \"Positive i```\u2014 it seems like the code is cut off here. That's a problem. If the code is incomplete, that's a bug in the sense that it won't compile. The user might have pasted only a portion of the code, but the actual code in the repository might be complete. However, based on what's provided, the code is missing parts, which would be a critical bug.\n\nAnother thing to check is for proper semicolons. For example, in the line \"private double[] beta;\" there's a semicolon. That's correct. The class fields are properly declared.\n\nLooking for possible null pointer issues. The fields like diagR, jacNorm, beta, permutation are initialized? Well, in the code provided, they're just declared but not initialized. However, in a real implementation, these would be initialized in the constructor or methods. Since the code is cut off, I can't see if that's done properly. But given that this is part of an optimization algorithm, it's likely that these are initialized elsewhere. However, if there's a method that uses these fields without initializing them, that would be a bug.\n\nLooking for array index out of bounds. For example, if the code uses permutation array without checking its length. But again, without the full code, it's hard to tell. The code snippet provided is incomplete.\n\nAnother thing: the code has a comment about handling over-determined systems by ignoring points with the smallest Jacobian column norm. The code mentions that the rank is adjusted and loop bounds are changed. However, if the code that computes the rank or adjusts the loops has a bug, that could lead to incorrect handling of over-determined systems. But again, without the full code, it's hard to assess.\n\nWait, the code as presented is missing the rest of the class. The line \"private double[] lmDir;\" is followed by \"Positive i``` which seems like a typo or incomplete text. This is likely a copy-paste error when the user provided the code. So, the code as given is incomplete and would not compile. That's a definite bug.\n\nAnother possible issue: in Java, if a class extends another class, the constructor should properly call the superclass constructor. If the LevenbergMarquardtOptimizer class doesn't have a constructor that calls super(), that could be a problem. However, in the code provided, there's no constructor shown. The AbstractLeastSquaresOptimizer might have a no-arg constructor, or maybe the constructor is in the part of the code that's missing. Since the code is incomplete, this is hard to evaluate.\n\nAlso, looking at the imports: org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.exception.util.LocalizedFormats, etc. Are these correct? For example, in older versions of Apache Commons Math, some packages might have changed. If the code is using deprecated classes or incorrect package names, that could be an issue. For example, FunctionEvaluationException was part of older versions, but in more recent versions, exceptions might have been reorganized. However, the user is asking about bugs in the provided code, not compatibility with other versions. Unless there's an obvious incorrect import, but the code seems to have correct imports for the time this class was written.\n\nAnother thing to check is for proper handling of exceptions. For example, if the code is supposed to throw OptimizationException or FunctionEvaluationException but doesn't, that could be a bug. But again, without the full code, it's hard to tell.\n\nIn the code provided, there's a reference to \"solvedCols\" which is an int. If this variable is not properly updated during the algorithm steps, that could lead to incorrect calculations. However, again, without the full code, it's hard to assess.\n\nThe most critical bug here is that the code is incomplete. The line \"Positive i``` is obviously incomplete, and the code is cut off. This would prevent the code from compiling. So, the first bug is that the code is incomplete, leading to a compilation error.\n\nAnother possible bug: in the comments, it's mentioned that the code handles over-determined systems by ignoring points with the smallest Jacobian column norm. If the code doesn't correctly compute the norms or apply the permutation, that could lead to incorrect results. For example, if the permutation array is not properly maintained or used during the QR decomposition, the algorithm might not solve the correct subset of equations. However, without seeing the implementation of the QR decomposition and how the permutation is applied, it's hard to confirm this.\n\nAnother possible issue is the use of the rank variable. If the rank is not correctly computed (e.g., based on the Jacobian's column norms), then the algorithm might not properly handle the matrix inversion or solve steps, leading to incorrect solutions.\n\nAlso, the Levenberg-Marquardt parameter (lmPar) is a critical part of the algorithm. If the code that updates lmPar during iterations is incorrect, the algorithm might not converge properly. But again, without the full code, this is speculative.\n\nIn summary, the most obvious bug is the incomplete code, which would cause a compilation error. The rest of the potential issues are speculative without seeing the full code. So, the JSON response should list the compilation error as a bug.\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"line\": \"private double[] lmDir;\",\n      \"description\": \"The code is incomplete and cuts off abruptly, leading to a compilation error. The line 'Positive i```...' suggests a copy-paste error or missing code, which prevents the class from being properly defined.\"\n    }\n  ]\n}\n```"}}