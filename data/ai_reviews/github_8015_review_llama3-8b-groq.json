{
  "source_item_id": 8015,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:48:51.378050",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Predicates.compose;\nimport static com.google.common.collect.CollectPreconditions.checkEntryNotNull;\nimport static com.google.common.collect.CollectPreconditions.checkNonnegative;\nimport static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;\nimport static java.lang.Math.ceil;\nimport static java.util.Collections.singletonMap;\nimport static java.util.Objects.requireNonNull;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.J2ktIncompatible;\nimport com.google.common.base.Converter;\nimport com.google.common.base.Equivalence;\nimport com.google.common.base.Function;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.collect.MapDifference.ValueDifference;\nimport com.google.common.primitives.Ints;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.concurrent.LazyInit;\nimport com.google.j2objc.annotations.RetainedWith;\nimport com.google.j2objc.annotations.Weak;\nimport com.google.j2objc.annotations.WeakOuter;\nimport java.io.Serializable;\nimport java.util.AbstractCollection;\nimport java.util.AbstractMap;\nimport java.util.AbstractMap.SimpleImmutableEntry;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumMap;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NavigableMap;\nimport java.util.NavigableSet;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.function.BinaryOperator;\nimport java.util.stream.Collector;\nimport org.jspecify.annotations.NonNull;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Static utility methods pertaining to {@link Map} instances (including instances of {@link\n * SortedMap}, {@link BiMap}, etc.). Also see this class's counterparts {@link Lists}, {@link Sets}\n * and {@link Queues}.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/CollectionUtilitiesExplained#maps\">{@code Maps}</a>.\n *\n * @author Kevin Bourrillion\n * @author Mike Bostock\n * @author Isaac Shum\n * @author Louis Wasserman\n * @since 2.0\n */\n@GwtCompatible\npublic final class Maps {\n  private Maps() {}\n\n  private enum EntryFunction implements Function<Entry<?, ?>, @Nullable Object> {\n    KEY {\n      @Override\n      public @Nullable Object apply(Entry<?, ?> entry) {\n        return entry.getKey();\n      }\n    },\n    VALUE {\n      @Override\n      public @Nullable Object apply(Entry<?, ?> entry) {\n        return entry.getValue();\n      }\n    };\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static <K extends @Nullable Object> Function<Entry<K, ?>, K> keyFunction() {\n    return (Function) EntryFunction.KEY;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static <V extends @Nullable Object> Function<Entry<?, V>, V> valueFunction() {\n    return (Function) EntryFunction.VALUE;\n  }\n\n  static <K extends @Nullable Object, V extends @Nullable Object> Iterator<K> keyIterator(\n      Iterator<Entry<K, V>> entryIterator) {\n    return new TransformedIterator<Entry<K, V>, K>(entryIterator) {\n      @Override\n      @ParametricNullness\n      K transform(Entry<K, V> entry) {\n        return entry.getKey();\n      }\n    };\n  }\n\n  static <K extends @Nullable Object, V extends @Nullable Object> Iterator<V> valueIterator(\n      Iterator<Entry<K, V>> entryIterator) {\n    return new TransformedIterator<Entry<K, V>, V>(entryIterator) {\n      @Override\n      @ParametricNullness\n      V transform(Entry<K, V> entry) {\n        return entry.getValue();\n      }\n    };\n  }\n\n  /**\n   * Returns an immutable map instance containing the given entries. Internally, the returned map\n   * will be backed by an {@link EnumMap}.\n   *\n   * <p>The iteration order of the returned map follows the enum's iteration order, not the order in\n   * which the elements appear in the given map.\n   *\n   * @param map the map to make an immutable copy of\n   * @return an immutable map containing those entries\n   * @since 14.0\n   */\n  public static <K extends Enum<K>, V> ImmutableMap<K, V> immutableEnumMap(\n      Map<K, ? extends V> map) {\n    if (map instanceof ImmutableEnumMap) {\n      @SuppressWarnings(\"unchecked\") // safe covariant cast\n      ImmutableEnumMap<K, V> result = (ImmutableEnumMap<K, V>) map;\n      return result;\n    }\n    Iterator<? extends Entry<K, ? extends V>> entryItr = map.entrySet().iterator();\n    if (!entryItr.hasNext()) {\n      return ImmutableMap.of();\n    }\n    Entry<K, ? extends V> entry1 = entryItr.next();\n    K key1 = entry1.getKey();\n    V value1 = entry1.getValue();\n    checkEntryNotNull(key1, value1);\n    // Do something that works for j2cl, where we can't call getDeclaredClass():\n    EnumMap<K, V> enumMap = new EnumMap<>(singletonMap(key1, value1));\n    while (entryItr.hasNext()) {\n      Entry<K, ? extends V> entry = entryItr.next();\n      K key = entry.getKey();\n      V value = entry.getValue();\n      checkEntryNotNull(key, value);\n      enumMap.put(key, value);\n    }\n    return ImmutableEnumMap.asImmutable(enumMap);\n  }\n\n  /**\n   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys\n   * and values are the result of applying the provided mapping functions to the input elements. The\n   * resulting implementation is specialized for enum key types. The returned map and its views will\n   * iterate over keys in their enum definition order, not encounter order.\n   *\n   * <p>If the mapped keys contain duplicates, an {@code IllegalArgumentException} is thrown when\n   * the collection operation is performed. (This differs from the {@code Collector} returned by\n   * {@link java.util.stream.Collectors#toMap(java.util.function.Function,\n   * java.util.function.Function) Collectors.toMap(Function, Function)}, which throws an {@code\n   * IllegalStateException}.)\n   *\n   * @since 33.2.0 (available since 21.0 in guava-jre)\n   */\n  @IgnoreJRERequirement // Users will use this only if they're already using streams.\n  public static <T extends @Nullable Object, K extends Enum<K>, V>\n      Collector<T, ?, ImmutableMap<K, V>> toImmutableEnumMap(\n          java.util.function.Function<? super T, ? extends K> keyFunction,\n          java.util.function.Function<? super T, ? extends V> valueFunction) {\n    return CollectCollectors.toImmutableEnumMap(keyFunction, valueFunction);\n  }\n\n  /**\n   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableMap} whose keys\n   * and values are the result of applying the provided mapping functions to the input elements. The\n   * resulting implementation is specialized for enum key types. The returned map and its views will\n   * iterate over keys in their enum definition order, not encounter",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The method immutableEnumMap does not handle the case where the input map is not an instance of ImmutableEnumMap correctly. It should return an empty map instead of throwing a ClassCastException.\",\n         \"suggested_fix\": \"if (!(map instanceof ImmutableEnumMap)) { return ImmutableMap.of(); }\"\n      },\n      {\n         \"explanation\": \"The method toImmutableEnumMap does not handle the case where the mapped keys contain duplicates correctly. It should throw an IllegalArgumentException instead of an IllegalStateException.\",\n         \"suggested_fix\": \"if (map.containsKey(key)) { throw new IllegalArgumentException(\\\"Duplicate key found\\\"); }\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No critical bugs found in the given Java code snippet.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The method immutableEnumMap does not handle the case where the input map is not an instance of ImmutableEnumMap correctly. It should return an empty map instead of throwing a ClassCastException.",
        "suggested_fix": "if (!(map instanceof ImmutableEnumMap)) { return ImmutableMap.of(); }"
      },
      {
        "explanation": "The method toImmutableEnumMap does not handle the case where the mapped keys contain duplicates correctly. It should throw an IllegalArgumentException instead of an IllegalStateException.",
        "suggested_fix": "if (map.containsKey(key)) { throw new IllegalArgumentException(\"Duplicate key found\"); }"
      }
    ],
    "no_bugs_reasoning": "No critical bugs found in the given Java code snippet."
  },
  "error": null
}