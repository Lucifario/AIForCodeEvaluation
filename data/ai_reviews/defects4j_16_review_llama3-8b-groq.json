{
  "source_item_id": 16,
  "source_type": "defects4j",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:28:00.024726",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math3.util;\n\nimport java.io.PrintStream;\n\n/**\n * Faster, more accurate, portable alternative to {@link Math} and\n * {@link StrictMath} for large scale computation.\n * <p>\n * FastMath is a drop-in replacement for both Math and StrictMath. This\n * means that for any method in Math (say {@code Math.sin(x)} or\n * {@code Math.cbrt(y)}), user can directly change the class and use the\n * methods as is (using {@code FastMath.sin(x)} or {@code FastMath.cbrt(y)}\n * in the previous example).\n * </p>\n * <p>\n * FastMath speed is achieved by relying heavily on optimizing compilers\n * to native code present in many JVMs today and use of large tables.\n * The larger tables are lazily initialised on first use, so that the setup\n * time does not penalise methods that don't need them.\n * </p>\n * <p>\n * Note that FastMath is\n * extensively used inside Apache Commons Math, so by calling some algorithms,\n * the overhead when the the tables need to be intialised will occur\n * regardless of the end-user calling FastMath methods directly or not.\n * Performance figures for a specific JVM and hardware can be evaluated by\n * running the FastMathTestPerformance tests in the test directory of the source\n * distribution.\n * </p>\n * <p>\n * FastMath accuracy should be mostly independent of the JVM as it relies only\n * on IEEE-754 basic operations and on embedded tables. Almost all operations\n * are accurate to about 0.5 ulp throughout the domain range. This statement,\n * of course is only a rough global observed behavior, it is <em>not</em> a\n * guarantee for <em>every</em> double numbers input (see William Kahan's <a\n * href=\"http://en.wikipedia.org/wiki/Rounding#The_table-maker.27s_dilemma\">Table\n * Maker's Dilemma</a>).\n * </p>\n * <p>\n * FastMath additionally implements the following methods not found in Math/StrictMath:\n * <ul>\n * <li>{@link #asinh(double)}</li>\n * <li>{@link #acosh(double)}</li>\n * <li>{@link #atanh(double)}</li>\n * </ul>\n * The following methods are found in Math/StrictMath since 1.6 only, they are provided\n * by FastMath even in 1.5 Java virtual machines\n * <ul>\n * <li>{@link #copySign(double, double)}</li>\n * <li>{@link #getExponent(double)}</li>\n * <li>{@link #nextAfter(double,double)}</li>\n * <li>{@link #nextUp(double)}</li>\n * <li>{@link #scalb(double, int)}</li>\n * <li>{@link #copySign(float, float)}</li>\n * <li>{@link #getExponent(float)}</li>\n * <li>{@link #nextAfter(float,double)}</li>\n * <li>{@link #nextUp(float)}</li>\n * <li>{@link #scalb(float, int)}</li>\n * </ul>\n * </p>\n * @version $Id$\n * @since 2.2\n */\npublic class FastMath {\n    /** StrictMath.log(Double.MAX_VALUE): {@value} */\n\n    /** Archimede's constant PI, ratio of circle circumference to diameter. */\n    public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;\n\n    /** Napier's constant e, base of the natural logarithm. */\n    public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;\n\n    /** Index of exp(0) in the array of integer exponentials. */\n    static final int EXP_INT_TABLE_MAX_INDEX = 750;\n    /** Length of the array of integer exponentials. */\n    static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;\n    /** Logarithm table length. */\n    static final int LN_MANT_LEN = 1024;\n    /** Exponential fractions table length. */\n    static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024\n\n    /** Indicator for tables initialization.\n     * <p>\n     * This compile-time constant should be set to true only if one explicitly\n     * wants to compute the tables at class loading time instead of using the\n     * already computed ones provided as literal arrays below.\n     * </p>\n     */\n    private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false;\n\n    /** log(2) (high bits). */\n    private static final double LN_2_A = 0.693147063255310059;\n\n    /** log(2) (low bits). */\n    private static final double LN_2_B = 1.17304635250823482e-7;\n\n    /** Coefficients for log, when input 0.99 < x < 1.01. */\n    private static final double LN_QUICK_COEF[][] = {\n        {1.0, 5.669184079525E-24},\n        {-0.25, -0.25},\n        {0.3333333134651184, 1.986821492305628E-8},\n        {-0.25, -6.663542893624021E-14},\n        {0.19999998807907104, 1.1921056801463227E-8},\n        {-0.1666666567325592, -7.800414592973399E-9},\n        {0.1428571343421936, 5.650007086920087E-9},\n        {-0.12502530217170715, -7.44321345601866E-11},\n        {0.11113807559013367, 9.219544613762692E-9},\n    };\n\n    /** Coefficients for log in the range of 1.0 < x < 1.0 + 2^-10. */\n    private static final double LN_HI_PREC_COEF[][] = {\n        {1.0, -6.032174644509064E-23},\n        {-0.25, -0.25},\n        {0.3333333134651184, 1.9868161777724352E-8},\n        {-0.2499999701976776, -2.957007209750105E-8},\n        {0.19999954104423523, 1.5830993332061267E-10},\n        {-0.16624879837036133, -2.6033824355191673E-8}\n    };\n\n    /** Sine, Cosine, Tangent tables are for 0, 1/8, 2/8, ... 13/8 = PI/2 approx. */\n    private static final int SINE_TABLE_LEN = 14;\n\n    /** Sine table (high bits). */\n    private static final double SINE_TABLE_A[] =\n        {\n        +0.0d,\n        +0.1246747374534607d,\n        +0.24740394949913025d,\n        +0.366272509098053d,\n        +0.4794255495071411d,\n        +0.5850973129272461d,\n        +0.6816387176513672d,\n        +0.7675435543060303d,\n        +0.8414709568023682d,\n        +0.902267575263977d,\n        +0.9489846229553223d,\n        +0.9808930158615112d,\n        +0.9974949359893799d,\n        +0.9985313415527344d,\n    };\n\n    /** Sine table (low bits). */\n    private static final double SINE_TABLE_B[] =\n        {\n        +0.0d,\n        -4.068233003401932E-9d,\n        +9.755392680573412E-9d,\n        +1.9987994582857286E-8d,\n        -1.0902938113007961E-8d,\n        -3.9986783938944604E-8d,\n        +4.23719669792332E-8d,\n        -5.207000323380292E-8d,\n        +2.800552834259E-8d,\n        +1.883511811213715E-8d,\n        -3.5997360512765566E-9d,\n        +4.116164446561962E-8d,\n        +5.0614674548127384E-8d,\n        -1.0129027912496858E-9d,\n    };\n\n    /** Cosine table (high bits). */\n    private static final double COSINE_TABLE_A[] =\n        {\n        +1.0d,\n        +0.9921976327896118d,\n        +0.9689123630523682d,\n        +0.9305076599121094d,\n        +0.8775825500488281d,\n        +0.8109631538391113d,\n        +0.7316888570785522d,\n        +0.6409968137741089d,\n        +0.5403022766113281d,\n        +0.4311765432357788d,\n        +0.3153223395347595d,\n        +0.19454771280288696d,\n        +0.07073719799518585d,\n        -0.05417713522911072d,\n    };\n\n    /** Cosine table (low bits). */\n    private static final double COSINE_TABLE_B[] =\n        {\n        +0.0d,\n        +3.4439717236742845E-8d,\n        +5.865827662008209E-8d,\n        -3.7999795083850525E-8d,\n        +1.184154459111628E-8d,\n        -3.43338934259355E-8d,\n        +1.1795268640216787E-8d,\n        +4.438921624363781E-8d,\n        +2.925681159240093E-8d,\n        -2.6437112632041807E-8d,\n        +2.2860509143963117E-8d,\n        -4.813899778443457E-9d,\n        +3.6725170580355583E-9d,\n        +2.0217439756338078E-10d,\n    };\n\n\n    /** Tangent table, used b",
  "raw_llm_output": null,
  "parsed_llm_output": null,
  "error": "No response from LLM llama3-8b-groq"
}