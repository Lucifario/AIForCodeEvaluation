{
  "source_item_id": 137063,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:37:55.327479",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\npackage org.elasticsearch.index.mapper.extras;\n\nimport org.apache.lucene.index.LeafReaderContext;\nimport org.apache.lucene.search.LongValues;\nimport org.apache.lucene.search.Query;\nimport org.elasticsearch.common.Explicit;\nimport org.elasticsearch.common.settings.Setting;\nimport org.elasticsearch.common.settings.Settings;\nimport org.elasticsearch.common.xcontent.support.XContentMapValues;\nimport org.elasticsearch.index.IndexMode;\nimport org.elasticsearch.index.IndexSettings;\nimport org.elasticsearch.index.IndexVersion;\nimport org.elasticsearch.index.IndexVersions;\nimport org.elasticsearch.index.fielddata.FieldData;\nimport org.elasticsearch.index.fielddata.FieldDataContext;\nimport org.elasticsearch.index.fielddata.IndexFieldData;\nimport org.elasticsearch.index.fielddata.IndexNumericFieldData;\nimport org.elasticsearch.index.fielddata.LeafNumericFieldData;\nimport org.elasticsearch.index.fielddata.NumericDoubleValues;\nimport org.elasticsearch.index.fielddata.SortedNumericDoubleValues;\nimport org.elasticsearch.index.fielddata.SortedNumericLongValues;\nimport org.elasticsearch.index.fielddata.SourceValueFetcherSortedDoubleIndexFieldData;\nimport org.elasticsearch.index.fielddata.plain.LeafDoubleFieldData;\nimport org.elasticsearch.index.fielddata.plain.SortedNumericIndexFieldData;\nimport org.elasticsearch.index.mapper.BlockDocValuesReader;\nimport org.elasticsearch.index.mapper.BlockLoader;\nimport org.elasticsearch.index.mapper.BlockSourceReader;\nimport org.elasticsearch.index.mapper.CompositeSyntheticFieldLoader;\nimport org.elasticsearch.index.mapper.DocumentParserContext;\nimport org.elasticsearch.index.mapper.FallbackSyntheticSourceBlockLoader;\nimport org.elasticsearch.index.mapper.FieldMapper;\nimport org.elasticsearch.index.mapper.IgnoreMalformedStoredValues;\nimport org.elasticsearch.index.mapper.IgnoredSourceFieldMapper;\nimport org.elasticsearch.index.mapper.IndexType;\nimport org.elasticsearch.index.mapper.MapperBuilderContext;\nimport org.elasticsearch.index.mapper.NumberFieldMapper;\nimport org.elasticsearch.index.mapper.SimpleMappedFieldType;\nimport org.elasticsearch.index.mapper.SortedNumericDocValuesSyntheticFieldLoader;\nimport org.elasticsearch.index.mapper.SortedNumericWithOffsetsDocValuesSyntheticFieldLoaderLayer;\nimport org.elasticsearch.index.mapper.SourceLoader;\nimport org.elasticsearch.index.mapper.SourceValueFetcher;\nimport org.elasticsearch.index.mapper.TextSearchInfo;\nimport org.elasticsearch.index.mapper.TimeSeriesParams;\nimport org.elasticsearch.index.mapper.ValueFetcher;\nimport org.elasticsearch.index.query.SearchExecutionContext;\nimport org.elasticsearch.script.field.DocValuesScriptFieldFactory;\nimport org.elasticsearch.script.field.ScaledFloatDocValuesField;\nimport org.elasticsearch.script.field.ToScriptFieldFactory;\nimport org.elasticsearch.search.DocValueFormat;\nimport org.elasticsearch.search.aggregations.support.TimeSeriesValuesSourceType;\nimport org.elasticsearch.search.aggregations.support.ValuesSourceType;\nimport org.elasticsearch.search.lookup.SearchLookup;\nimport org.elasticsearch.xcontent.XContentBuilder;\nimport org.elasticsearch.xcontent.XContentParser;\nimport org.elasticsearch.xcontent.XContentParser.Token;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.time.ZoneId;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport static org.elasticsearch.index.mapper.FieldArrayContext.getOffsetsFieldName;\n\n/** A {@link FieldMapper} for scaled floats. Values are internally multiplied\n *  by a scaling factor and rounded to the closest long. */\npublic class ScaledFloatFieldMapper extends FieldMapper {\n\n    public static final String CONTENT_TYPE = \"scaled_float\";\n\n    // use the same default as numbers\n    private static final Setting<Boolean> COERCE_SETTING = NumberFieldMapper.COERCE_SETTING;\n\n    private static ScaledFloatFieldMapper toType(FieldMapper in) {\n        return (ScaledFloatFieldMapper) in;\n    }\n\n    public static class Builder extends FieldMapper.Builder {\n\n        private final Parameter<Boolean> indexed;\n        private final Parameter<Boolean> hasDocValues = Parameter.docValuesParam(m -> toType(m).hasDocValues, true);\n        private final Parameter<Boolean> stored = Parameter.storeParam(m -> toType(m).stored, false);\n\n        private final Parameter<Explicit<Boolean>> ignoreMalformed;\n        private final Parameter<Explicit<Boolean>> coerce;\n\n        private final Parameter<Double> scalingFactor = new Parameter<>(\n            \"scaling_factor\",\n            false,\n            () -> null,\n            (n, c, o) -> XContentMapValues.nodeDoubleValue(o),\n            m -> toType(m).scalingFactor,\n            XContentBuilder::field,\n            Objects::toString\n        ).addValidator(v -> {\n            if (v == null) {\n                throw new IllegalArgumentException(\"Field [scaling_factor] is required\");\n            }\n            if (Double.isFinite(v) == false || v <= 0) {\n                throw new IllegalArgumentException(\"[scaling_factor] must be a positive number, got [\" + v + \"]\");\n            }\n        });\n        private final Parameter<Double> nullValue = new Parameter<>(\n            \"null_value\",\n            false,\n            () -> null,\n            (n, c, o) -> o == null ? null : XContentMapValues.nodeDoubleValue(o),\n            m -> toType(m).nullValue,\n            XContentBuilder::field,\n            Objects::toString\n        ).acceptsNull();\n\n        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n\n        /**\n         * Parameter that marks this field as a time series metric defining its time series metric type.\n         * For the numeric fields gauge and counter metric types are\n         * supported\n         */\n        private final Parameter<TimeSeriesParams.MetricType> metric;\n\n        private final IndexMode indexMode;\n        private final IndexVersion indexCreatedVersion;\n        private final SourceKeepMode indexSourceKeepMode;\n\n        public Builder(\n            String name,\n            Settings settings,\n            IndexMode indexMode,\n            IndexVersion indexCreatedVersion,\n            SourceKeepMode indexSourceKeepMode\n        ) {\n            this(\n                name,\n                IGNORE_MALFORMED_SETTING.get(settings),\n                COERCE_SETTING.get(settings),\n                indexMode,\n                indexCreatedVersion,\n                indexSourceKeepMode\n            );\n        }\n\n        public Builder(\n            String name,\n            boolean ignoreMalformedByDefault,\n            boolean coerceByDefault,\n            IndexMode indexMode,\n            IndexVersion indexCreatedVersion,\n            SourceKeepMode indexSourceKeepMode\n        ) {\n            super(name);\n            this.ignoreMalformed = Parameter.explicitBoolParam(\n                \"ignore_malformed\",\n                true,\n                m -> toType(m).ignoreMalformed,\n                ignoreMalformedByDefault\n            );\n            this.coerce = Parameter.explicitBoolParam(\"coerce\", true, m -> toType(m).coerce, coerceByDefault);\n            this.indexMode = indexMode;\n            this.indexed = Parameter.indexParam(m -> toType(m).indexed, () -> {\n                if (indexMode == IndexMode.TIME_SERIES) {\n                    var metricType = getMetric().getValue();\n                    return metricType != TimeSeriesParams.MetricType.COUNTER && metricType != TimeSeriesP",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The method `getMetric()` is called without checking if the `metric` parameter is null. This can lead to a NullPointerException.\",\n         \"suggested_fix\": \"Add a null check before calling `getMetric()`: `if (metric != null) { ... }`\"\n      },\n      {\n         \"explanation\": \"The `scalingFactor` parameter is not validated to be a finite number. This can lead to unexpected behavior when scaling values.\",\n         \"suggested_fix\": \"Add a validation check to ensure the `scalingFactor` is a finite number: `if (Double.isFinite(v) == false || v <= 0) { ... }`\"\n      },\n      {\n         \"explanation\": \"The `nullValue` parameter is not validated to be a valid double value. This can lead to unexpected behavior when setting the null value.\",\n         \"suggested_fix\": \"Add a validation check to ensure the `nullValue` is a valid double value: `if (v == null) { ... }`\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The method `getMetric()` is called without checking if the `metric` parameter is null. This can lead to a NullPointerException.",
        "suggested_fix": "Add a null check before calling `getMetric()`: `if (metric != null) { ... }`"
      },
      {
        "explanation": "The `scalingFactor` parameter is not validated to be a finite number. This can lead to unexpected behavior when scaling values.",
        "suggested_fix": "Add a validation check to ensure the `scalingFactor` is a finite number: `if (Double.isFinite(v) == false || v <= 0) { ... }`"
      },
      {
        "explanation": "The `nullValue` parameter is not validated to be a valid double value. This can lead to unexpected behavior when setting the null value.",
        "suggested_fix": "Add a validation check to ensure the `nullValue` is a valid double value: `if (v == null) { ... }`"
      }
    ],
    "no_bugs_reasoning": ""
  },
  "error": null
}