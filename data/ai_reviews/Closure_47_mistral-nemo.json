{"sample_id": "Closure_47", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2009 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.collect.Maps;\nimport com.google.debugging.sourcemap.FilePosition;\nimport com.google.debugging.sourcemap.SourceMapFormat;\nimport com.google.debugging.sourcemap.SourceMapGenerator;\nimport com.google.debugging.sourcemap.SourceMapGeneratorFactory;\nimport com.google.debugging.sourcemap.SourceMapGeneratorV1;\nimport com.google.debugging.sourcemap.SourceMapGeneratorV2;\nimport com.google.javascript.rhino.Node;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Collects information mapping the generated (compiled) source back to\n * its original source for debugging purposes.\n *\n * @see CodeConsumer\n * @see CodeGenerator\n * @see CodePrinter\n *\n */\npublic class SourceMap {\n\n  public static enum Format {\n     V1 {\n       @Override SourceMap getInstance() {\n         return new SourceMap(\n           SourceMapGeneratorFactory.getInstance(SourceMapFormat.V1));\n       }\n     },\n     DEFAULT {\n       @Override SourceMap getInstance() {\n         return new SourceMap(\n           SourceMapGeneratorFactory.getInstance(SourceMapFormat.DEFAULT));\n       }\n     },\n     V2 {\n       @Override SourceMap getInstance() {\n         return new SourceMap(\n           SourceMapGeneratorFactory.getInstance(SourceMapFormat.V2));\n        }\n     },\n     V3 {\n       @Override SourceMap getInstance() {\n         return new SourceMap(\n           SourceMapGeneratorFactory.getInstance(SourceMapFormat.V3));\n        }\n     };\n     abstract SourceMap getInstance();\n  }\n\n  /**\n   * Source maps can be very large different levels of detail can be specified.\n   */\n  public static enum DetailLevel implements Predicate<Node> {\n    // ALL is best when the fullest details are needed for debugging or for\n    // code-origin analysis.\n    ALL {\n      @Override public boolean apply(Node node) {\n        return true;\n      }\n    },\n    // SYMBOLS is intended to be used for stack trace deobfuscation when full\n    // detail is not needed.\n    SYMBOLS {\n      @Override public boolean apply(Node node) {\n        return node.isCall()\n            || node.isNew()\n            || node.isFunction()\n            || node.isName()\n            || NodeUtil.isGet(node)\n            || NodeUtil.isObjectLitKey(node, node.getParent())\n            || (node.isString() && NodeUtil.isGet(node.getParent()));\n      }\n    };\n  }\n\n  public static class LocationMapping {\n    final String prefix;\n    final String replacement;\n    public LocationMapping(String prefix, String replacement) {\n      this.prefix = prefix;\n      this.replacement = replacement;\n    }\n  }\n\n  private final SourceMapGenerator generator;\n  private List<LocationMapping> prefixMappings = Collections.emptyList();\n  private final Map<String, String> sourceLocationFixupCache =\n      Maps.newHashMap();\n\n  private SourceMap(SourceMapGenerator generator) {\n    this.generator = generator;\n  }\n\n  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }\n\n  /**\n   * @param sourceFile The source file location to fixup.\n   * @return a remapped source file.\n   */\n  private String fixupSourceLocation(String sourceFile) {\n    if (prefixMappings.isEmpty()) {\n      return sourceFile;\n    }\n\n    String fixed = sourceLocationFixupCache.get(sourceFile);\n    if (fixed != null) {\n      return fixed;\n    }\n\n    // Replace the first prefix found with its replacement\n    for (LocationMapping mapping : prefixMappings) {\n      if (sourceFile.startsWith(mapping.prefix)) {\n        fixed = mapping.replacement + sourceFile.substring(\n          mapping.prefix.length());\n        break;\n      }\n    }\n\n    // If none of the mappings match then use the original file path.\n    if (fixed == null) {\n      fixed = sourceFile;\n    }\n\n    sourceLocationFixupCache.put(sourceFile, fixed);\n    return fixed;\n  }\n\n  public void appendTo(Appendable out, String name) throws IOException {\n    generator.appendTo(out, name);\n  }\n\n  public void reset() {\n    generator.reset();\n    sourceLocationFixupCache.clear();\n  }\n\n  public void setStartingPosition(int offsetLine, int offsetIndex) {\n    generator.setStartingPosition(offsetLine, offsetIndex);\n  }\n\n  public void setWrapperPrefix(String prefix) {\n    generator.setWrapperPrefix(prefix);\n  }\n\n  public void validate(boolean validate) {\n    generator.validate(validate);\n  }\n\n  /**\n   * @param sourceMapLocationMappings\n   */\n  public void setPrefixMappings(List<LocationMapping> sourceMapLocationMappings) {\n     this.prefixMappings = sourceMapLocationMappings;\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"description\": \"The `Format` enum has a missing case for `V3`. In the `V3` case, the `getInstance()` method is not implemented and will throw an `AbstractMethodError`.\",\n      \"code\": \"Format.V3.getInstance();\"\n    },\n    {\n      \"description\": \"In the `addMapping()` method, the `outputEndPosition` parameter is not used in the call to `generator.addMapping()`. This could lead to incorrect mapping information being generated.\",\n      \"code\": \"generator.addMapping(sourceFile, originalName, new FilePosition(node.getLineno(), node.getCharno()), outputStartPosition, outputEndPosition);\"\n    },\n    {\n      \"description\": \"In the `fixupSourceLocation()` method, the `prefixMappings` list is not checked for null before being iterated over. If the list is null, this will throw a `NullPointerException`.\",\n      \"code\": \"for (LocationMapping mapping : prefixMappings) { ... }\"\n    },\n    {\n      \"description\": \"The `LocationMapping` class does not have any validation for the `prefix` and `replacement` fields. It is possible to create a `LocationMapping` object with invalid or null values, which could lead to unexpected behavior or errors.\",\n      \"code\": \"new LocationMapping(prefix, replacement);\"\n    }\n  ]\n}"}}