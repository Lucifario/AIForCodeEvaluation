{"sample_id": "Math_90", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math.stat;\n\nimport java.io.Serializable;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Comparator;\nimport java.util.TreeMap;\n\n/** \n * Maintains a frequency distribution.\n * <p>\n * Accepts int, long, char or Object values.  New values added must be \n * comparable to those that have been added, otherwise the add method will \n * throw an IllegalArgumentException.</p>\n * <p>\n * Integer values (int, long, Integer, Long) are not distinguished by type -- \n * i.e. <code>addValue(Long.valueOf(2)), addValue(2), addValue(2l)</code> all have\n * the same effect (similarly for arguments to <code>getCount,</code> etc.).</p>\n * <p>\n * char values are converted by <code>addValue</code> to Character instances.\n * As such, these values are not comparable to integral values, so attempts\n * to combine integral types with chars in a frequency distribution will fail.\n * </p>\n * <p>\n * The values are ordered using the default (natural order), unless a  \n * <code>Comparator</code> is supplied in the constructor.</p>\n *\n * @version $Revision$ $Date$\n */\npublic class Frequency implements Serializable {\n    \n    /** Serializable version identifier */\n    private static final long serialVersionUID = -3845586908418844111L;\n\n    /** underlying collection */\n    private final TreeMap freqTable;\n\n    /**\n     * Default constructor.\n     */\n    public Frequency() {\n        freqTable = new TreeMap();\n    }\n    \n    /**\n     * Constructor allowing values Comparator to be specified.\n     * \n     * @param comparator Comparator used to order values\n     */\n    public Frequency(Comparator comparator) {\n        freqTable = new TreeMap(comparator);\n    }\n\n    /**\n     * Return a string representation of this frequency\n     * distribution.\n     * \n     * @return a string representation.\n     */\n    @Override\n    public String toString() {\n        NumberFormat nf = NumberFormat.getPercentInstance();\n        StringBuffer outBuffer = new StringBuffer();\n        outBuffer.append(\"Value \\t Freq. \\t Pct. \\t Cum Pct. \\n\");\n        Iterator iter = freqTable.keySet().iterator();\n        while (iter.hasNext()) {\n            Object value = iter.next();\n            outBuffer.append(value);\n            outBuffer.append('\\t');\n            outBuffer.append(getCount(value));\n            outBuffer.append('\\t');\n            outBuffer.append(nf.format(getPct(value)));\n            outBuffer.append('\\t');\n            outBuffer.append(nf.format(getCumPct(value)));\n            outBuffer.append('\\n');\n        }\n        return outBuffer.toString();\n    }\n\n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     * @throws ClassCastException if <code>v</code> is not Comparable\n     * @deprecated use {@link #addValue(Comparable)} instead\n     */\n    @Deprecated\n    public void addValue(Object v) {\n    \n    /**\n     * Adds 1 to the frequency count for v.\n     * <p>\n     * If other objects have already been added to this Frequency, v must\n     * be comparable to those that have already been added.\n     * </p>\n     * \n     * @param v the value to add.\n     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n     */\n        Object obj = v;\n        if (v instanceof Integer) {\n           obj = Long.valueOf(((Integer) v).longValue());\n        }\n        try {\n            Long count = (Long) freqTable.get(obj);\n            if (count == null) {\n                freqTable.put(obj, Long.valueOf(1));\n            } else {\n                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n            }\n        } catch (ClassCastException ex) {   \n            //TreeMap will throw ClassCastException if v is not comparable\n            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n        }\n    }\n\n    /**\n     * Adds 1 to the frequency count for v.\n     * \n     * @param v the value to add.\n     */\n    public void addValue(int v) {\n        addValue(Long.valueOf(v));\n    }\n    \n    /**\n     * Adds 1 to the frequency count for v.\n     * \n     * @param v the value to add.\n     */\n    public void addValue(Integer v) {\n        addValue(Long.valueOf(v.longValue()));\n    }\n\n    /**\n     * Adds 1 to the frequency count for v.\n     * \n     * @param v the value to add.\n     */\n    public void addValue(long v) {\n        addValue(Long.valueOf(v));\n    }\n    \n    /**\n     * Adds 1 to the frequency count for v.\n     * \n     * @param v the value to add.\n     */\n    public void addValue(char v) {\n        addValue(Character.valueOf(v));\n    }\n    \n    /** Clears the frequency table */\n    public void clear() {\n        freqTable.clear();\n    }\n    \n    /**\n     * Returns an Iterator over the set of values that have been added.\n     * <p>\n     * If added values are integral (i.e., integers, longs, Integers, or Longs), \n     * they are converted to Longs when they are added, so the objects returned\n     * by the Iterator will in this case be Longs.</p>\n     * \n     * @return values Iterator\n     */\n    public Iterator valuesIterator() {\n        return freqTable.keySet().iterator();\n    }\n    \n    //-------------------------------------------------------------------------\n    \n    /**\n     * Returns the sum of all frequencies.\n     * \n     * @return the total frequency count.\n     */\n    public long getSumFreq() {\n        long result = 0;\n        Iterator iterator = freqTable.values().iterator();\n        while (iterator.hasNext())  {\n            result += ((Long) iterator.next()).longValue();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of values = v.\n     * Returns 0 if the value is not comparable.\n     * \n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(Object v) {\n        if (v instanceof Integer) {\n            return getCount(((Integer) v).longValue());\n        }\n        long result = 0;\n        try { \n            Long count =  (Long) freqTable.get(v);\n            if (count != null) {\n                result = count.longValue();\n            }\n        } catch (ClassCastException ex) {\n            // ignore and return 0 -- ClassCastException will be thrown if value is not comparable\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of values = v.\n     * \n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(int v) {\n        return getCount(Long.valueOf(v));\n    }\n    \n    /**\n     * Returns the number of values = v.\n     * \n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(long v) {\n        return getCount(Long.valueOf(v));\n    }\n    \n    /**\n     * Returns the number of values = v.\n     * \n     * @param v the value to lookup.\n     * @return the frequency of v.\n     */\n    public long getCount(char v) {\n        return getCount(Character.valueOf(v));\n    }\n    \n    //-------------------------------------------------------------\n\n    /**\n      * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(Object v) {\n        final long sumFreq = getSumFreq();\n        if (sumFreq == 0) {\n            return Double.NaN;\n        }\n        return (double) getCount(v) / (double) sumFreq;        \n    }\n    \n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(int v) {\n        return getPct(Long.valueOf(v));       \n    }\n    \n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(long v) {\n        return getPct(Long.valueOf(v));         \n    }\n    \n    /**\n     * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public double getPct(char v) {\n        return getPct(Character.valueOf(v));         \n    }\n    \n    //-----------------------------------------------------------------------------------------\n    \n    /**\n     * Returns the cumulative frequency of values less than or equal to v.\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup.\n     * @return the proportion of values equal to v\n     */\n    public long getCumFreq(Object v) {\n        if (getSumFreq() == 0) {\n            return 0;\n        }\n        if (v instanceof Integer) {\n            return getCumFreq(((Integer) v).longValue());\n        }\n        Comparator c = freqTable.comparator();\n        if (c == null) {\n            c = new NaturalComparator();\n        }\n        long result = 0;\n        \n        try {\n            Long value = (Long) freqTable.get(v);\n            if (value != null) {\n                result = value.longValue();\n            }\n        } catch (ClassCastException ex) {\n            return result;   // v is not comparable\n        }\n        \n        if (c.compare(v, freqTable.firstKey()) < 0) {\n            return 0;  // v is comparable, but less than first value\n        }\n        \n        if (c.compare(v, freqTable.lastKey()) >= 0) {\n            return getSumFreq();    // v is comparable, but greater than the last value\n        }\n        \n        Iterator values = valuesIterator();\n        while (values.hasNext()) {\n            Object nextValue = values.next();\n            if (c.compare(v, nextValue) > 0) {\n                result += getCount(nextValue);\n            } else {\n                return result;\n            }\n        }\n        return result;\n    }\n    \n     /**\n     * Returns the cumulative frequency of values less than or equal to v.\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public long getCumFreq(int v) {\n        return getCumFreq(Long.valueOf(v));       \n    }\n    \n     /**\n     * Returns the cumulative frequency of values less than or equal to v.\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public long getCumFreq(long v) {\n        return getCumFreq(Long.valueOf(v));         \n    }\n    \n    /**\n     * Returns the cumulative frequency of values less than or equal to v.\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     */\n    public long getCumFreq(char v) {\n        return getCumFreq(Character.valueOf(v));         \n    }\n    \n    //----------------------------------------------------------------------------------------------\n    \n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.\n     * Returns 0 if at least one value has been added, but v is not comparable\n     * to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     */\n    public double getCumPct(Object v) {\n        final long sumFreq = getSumFreq();\n        if (sumFreq == 0) {\n            return Double.NaN;\n        }\n        return (double) getCumFreq(v) / (double) sumFreq;        \n    }\n    \n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     */\n    public double getCumPct(int v) {\n        return getCumPct(Long.valueOf(v));       \n    }\n    \n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     */\n    public double getCumPct(long v) {\n        return getCumPct(Long.valueOf(v));         \n    }\n    \n    /**\n     * Returns the cumulative percentage of values less than or equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns 0 if v is not comparable to the values set.</p>\n     * \n     * @param v the value to lookup\n     * @return the proportion of values less than or equal to v\n     */\n    public double getCumPct(char v) {\n        return getCumPct(Character.valueOf(v));         \n    }\n    \n    /**\n     * A Comparator that compares comparable objects using the\n     * natural order.  Copied from Commons Collections ComparableComparator.\n     */\n    private static class NaturalComparator implements Comparator, Serializable {\n\n        /** Serializable version identifier */\n        private static final long serialVersionUID = -3852193713161395148L;\n\n        /**\n         * Compare the two {@link Comparable Comparable} arguments.\n         * This method is equivalent to:\n         * <pre>(({@link Comparable Comparable})o1).{@link Comparable#compareTo compareTo}(o2)</pre>\n         * \n         * @param  o1 the first object \n         * @param  o2 the second object\n         * @return  result of comparison\n         * @throws NullPointerException when <i>o1</i> is <code>null</code>, \n         *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n         * @throws ClassCastException when <i>o1</i> is not a {@link Comparable Comparable}, \n         *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n         */\n        public int compare(Object o1, Object o2) {\n            return ((Comparable)o1).compareTo(o2);\n        }\n    }\n}\n", "review": {"response": "{ \"bugs\": [\n\n  \"The `addValue(Object v)` method is deprecated but still throws `IllegalArgumentException` if the value is not comparable to previous entries. It should either be removed or its behavior should be updated to match the deprecation notice.\",\n\n  \"The `addValue(Object v)` method converts `Integer` values to `Long` but does not handle `Character` values. If a `Character` value is added before any other values, it will throw a `ClassCastException` when trying to compare it with subsequent values.\",\n\n  \"The `toString()` method appends the value, frequency, percentage, and cumulative percentage to a `StringBuffer`, but it does not check if the value is a number. If a non-number value is added to the frequency table, the `toString()` method will throw a `NumberFormatException` when trying to format the percentage and cumulative percentage.\",\n\n  \"The `Frequency` class does not have a method to remove a value from the frequency table. If a value needs to be removed, the entire table needs to be cleared and rebuilt.\",\n\n  \"The `Frequency` class does not have a method to get the total number of values in the frequency table. The total can be calculated by summing the frequencies of all values, but this requires iterating over the entire table.\",\n\n  \"The `Frequency` class does not have a method to get the frequency of a specific value. The frequency can be obtained by getting the value from the frequency table, but this requires knowing the key used to store the value in the table.\",\n\n  \"The `Frequency` class does not have a method to get the cumulative frequency of a specific value. The cumulative frequency can be calculated by summing the frequencies of all values up to and including the specific value, but this requires iterating over the entire table up to the specific value.\"\n\n]}"}}