{"sample_id": "Math_76", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.linear;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.util.MathUtils;\n\n/**\n * Calculates the compact or truncated Singular Value Decomposition of a matrix.\n * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n * Let A be a m &times; n matrix, then U is a m &times; p orthogonal matrix,\n * &Sigma; is a p &times; p diagonal matrix with positive diagonal elements,\n * V is a n &times; p orthogonal matrix (hence V<sup>T</sup> is a p &times; n\n * orthogonal matrix). The size p depends on the chosen algorithm:\n * <ul>\n *   <li>for full SVD, p would be n, but this is not supported by this implementation,</li>\n *   <li>for compact SVD, p is the rank r of the matrix\n *       (i. e. the number of positive singular values),</li>\n *   <li>for truncated SVD p is min(r, t) where t is user-specified.</li>\n * </ul>\n * </p>\n * <p>\n * Note that since this class computes only the compact or truncated SVD and not\n * the full SVD, the singular values computed are always positive.\n * </p>\n *\n * @version $Revision$ $Date$\n * @since 2.0\n */\npublic class SingularValueDecompositionImpl implements SingularValueDecomposition {\n\n    /** Number of rows of the initial matrix. */\n    private int m;\n\n    /** Number of columns of the initial matrix. */\n    private int n;\n\n    /** Transformer to bidiagonal. */\n    private BiDiagonalTransformer transformer;\n\n    /** Main diagonal of the bidiagonal matrix. */\n    private double[] mainBidiagonal;\n\n    /** Secondary diagonal of the bidiagonal matrix. */\n    private double[] secondaryBidiagonal;\n\n    /** Main diagonal of the tridiagonal matrix. */\n    private double[] mainTridiagonal;\n\n    /** Secondary diagonal of the tridiagonal matrix. */\n    private double[] secondaryTridiagonal;\n\n    /** Eigen decomposition of the tridiagonal matrix. */\n    private EigenDecomposition eigenDecomposition;\n\n    /** Singular values. */\n    private double[] singularValues;\n\n    /** Cached value of U. */\n    private RealMatrix cachedU;\n\n    /** Cached value of U<sup>T</sup>. */\n    private RealMatrix cachedUt;\n\n    /** Cached value of S. */\n    private RealMatrix cachedS;\n\n    /** Cached value of V. */\n    private RealMatrix cachedV;\n\n    /** Cached value of V<sup>T</sup>. */\n    private RealMatrix cachedVt;\n\n    /**\n     * Calculates the compact Singular Value Decomposition of the given matrix.\n     * @param matrix The matrix to decompose.\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    public SingularValueDecompositionImpl(final RealMatrix matrix)\n        throws InvalidMatrixException {\n        this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));\n    }\n\n    /**\n     * Calculates the Singular Value Decomposition of the given matrix.\n     * @param matrix The matrix to decompose.\n     * @param max maximal number of singular values to compute\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    public SingularValueDecompositionImpl(final RealMatrix matrix, final int max)\n        throws InvalidMatrixException {\n\n        m = matrix.getRowDimension();\n        n = matrix.getColumnDimension();\n\n        cachedU  = null;\n        cachedS  = null;\n        cachedV  = null;\n        cachedVt = null;\n\n        // transform the matrix to bidiagonal\n        transformer         = new BiDiagonalTransformer(matrix);\n        mainBidiagonal      = transformer.getMainDiagonalRef();\n        secondaryBidiagonal = transformer.getSecondaryDiagonalRef();\n\n        // compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)\n        mainTridiagonal      = new double[mainBidiagonal.length];\n        secondaryTridiagonal = new double[mainBidiagonal.length - 1];\n        double a = mainBidiagonal[0];\n        mainTridiagonal[0] = a * a;\n        for (int i = 1; i < mainBidiagonal.length; ++i) {\n            final double b  = secondaryBidiagonal[i - 1];\n            secondaryTridiagonal[i - 1] = a * b;\n            a = mainBidiagonal[i];\n            mainTridiagonal[i] = a * a + b * b;\n        }\n\n        // compute singular values\n        eigenDecomposition =\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal,\n                                       MathUtils.SAFE_MIN);\n        final double[] eigenValues = eigenDecomposition.getRealEigenvalues();\n        int p = Math.min(max, eigenValues.length);\n        while ((p > 0) && (eigenValues[p - 1] <= 0)) {\n            --p;\n        }\n        singularValues = new double[p];\n        for (int i = 0; i < p; ++i) {\n            singularValues[i] = Math.sqrt(eigenValues[i]);\n        }\n\n    }\n\n    /** {@inheritDoc} */\n    public RealMatrix getU()\n        throws InvalidMatrixException {\n\n        if (cachedU == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[m][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n\n                for (int i = p; i < m; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedU =\n                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n            } else {\n                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                cachedU = transformer.getU().multiply(e);\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedU;\n\n    }\n\n    /** {@inheritDoc} */\n    public RealMatrix getUT()\n        throws InvalidMatrixException {\n\n        if (cachedUt == null) {\n            cachedUt = getU().transpose();\n        }\n\n        // return the cached matrix\n        return cachedUt;\n\n    }\n\n    /** {@inheritDoc} */\n    public RealMatrix getS()\n        throws InvalidMatrixException {\n\n        if (cachedS == null) {\n\n            // cache the matrix for subsequent calls\n            cachedS = MatrixUtils.createRealDiagonalMatrix(singularValues);\n\n        }\n        return cachedS;\n    }\n\n    /** {@inheritDoc} */\n    public double[] getSingularValues()\n        throws InvalidMatrixException {\n        return singularValues.clone();\n    }\n\n    /** {@inheritDoc} */\n    public RealMatrix getV()\n        throws InvalidMatrixException {\n\n        if (cachedV == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                cachedV = transformer.getV().multiply(e);\n            } else {\n                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[n][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n                for (int i = p; i < n; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedV =\n                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedV;\n\n    }\n\n    /** {@inheritDoc} */\n    public RealMatrix getVT()\n        throws InvalidMatrixException {\n\n        if (cachedVt == null) {\n            cachedVt = getV().transpose();\n        }\n\n        // return the cached matrix\n        return cachedVt;\n\n    }\n\n    /** {@inheritDoc} */\n    public RealMatrix getCovariance(final double minSingularValue) {\n\n        // get the number of singular values to consider\n        final int p = singularValues.length;\n        int dimension = 0;\n        while ((dimension < p) && (singularValues[dimension] >= minSingularValue)) {\n            ++dimension;\n        }\n\n        if (dimension == 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"cutoff singular value is {0}, should be at most {1}\",\n                  minSingularValue, singularValues[0]);\n        }\n\n        final double[][] data = new double[dimension][p];\n        getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final double value) {\n                data[row][column] = value / singularValues[row];\n            }\n        }, 0, dimension - 1, 0, p - 1);\n\n        RealMatrix jv = new Array2DRowRealMatrix(data, false);\n        return jv.transpose().multiply(jv);\n\n    }\n\n    /** {@inheritDoc} */\n    public double getNorm()\n        throws InvalidMatrixException {\n        return singularValues[0];\n    }\n\n    /** {@inheritDoc} */\n    public double getConditionNumber()\n        throws InvalidMatrixException {\n        return singularValues[0] / singularValues[singularValues.length - 1];\n    }\n\n    /** {@inheritDoc} */\n    public int getRank()\n        throws IllegalStateException {\n\n        final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);\n\n        for (int i = singularValues.length - 1; i >= 0; --i) {\n           if (singularValues[i] > threshold) {\n              return i + 1;\n           }\n        }\n        return 0;\n\n    }\n\n    /** {@inheritDoc} */\n    public DecompositionSolver getSolver() {\n        return new Solver(singularValues, getUT(), getV(),\n                          getRank() == Math.max(m, n));\n    }\n\n    /** Specialized solver. */\n    private static class Solver implements DecompositionSolver {\n\n        /** Pseudo-inverse of the initial matrix. */\n        private final RealMatrix pseudoInverse;\n\n        /** Singularity indicator. */\n        private boolean nonSingular;\n\n        /**\n         * Build a solver from decomposed matrix.\n         * @param singularValues singularValues\n         * @param uT U<sup>T</sup> matrix of the decomposition\n         * @param v V matrix of the decomposition\n         * @param nonSingular singularity indicator\n         */\n        private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v,\n                       final boolean nonSingular) {\n            double[][] suT      = uT.getData();\n            for (int i = 0; i < singularValues.length; ++i) {\n                final double a      = 1.0 / singularValues[i];\n                final double[] suTi = suT[i];\n                for (int j = 0; j < suTi.length; ++j) {\n                    suTi[j] *= a;\n                }\n            }\n            pseudoInverse    = v.multiply(new Array2DRowRealMatrix(suT, false));\n            this.nonSingular = nonSingular;\n        }\n\n        /** Solve the linear equation A &times; X = B in least square sense.\n         * <p>The m&times;n matrix A may not be square, the solution X is\n         * such that ||A &times; X - B|| is minimal.</p>\n         * @param b right-hand side of the equation A &times; X = B\n         * @return a vector X that minimizes the two norm of A &times; X - B\n         * @exception IllegalArgumentException if matrices dimensions don't match\n         */\n        public double[] solve(final double[] b)\n            throws IllegalArgumentException {\n            return pseudoInverse.operate(b);\n        }\n\n        /** Solve the linear equation A &times; X = B in least square sense.\n         * <p>The m&times;n matrix A may not be square, the solution X is\n         * such that ||A &times; X - B|| is minimal.</p>\n         * @param b right-hand side of the equation A &times; X = B\n         * @return a vector X that minimizes the two norm of A &times; X - B\n         * @exception IllegalArgumentException if matrices dimensions don't match\n         */\n        public RealVector solve(final RealVector b)\n            throws IllegalArgumentException {\n            return pseudoInverse.operate(b);\n        }\n\n        /** Solve the linear equation A &times; X = B in least square sense.\n         * <p>The m&times;n matrix A may not be square, the solution X is\n         * such that ||A &times; X - B|| is minimal.</p>\n         * @param b right-hand side of the equation A &times; X = B\n         * @return a matrix X that minimizes the two norm of A &times; X - B\n         * @exception IllegalArgumentException if matrices dimensions don't match\n         */\n        public RealMatrix solve(final RealMatrix b)\n            throws IllegalArgumentException {\n            return pseudoInverse.multiply(b);\n        }\n\n        /**\n         * Check if the decomposed matrix is non-singular.\n         * @return true if the decomposed matrix is non-singular\n         */\n        public boolean isNonSingular() {\n            return nonSingular;\n        }\n\n        /** Get the pseudo-inverse of the decomposed matrix.\n         * @return inverse matrix\n         */\n        public RealMatrix getInverse() {\n            return pseudoInverse;\n        }\n\n    }\n\n}\n", "review": {"response": "{\"bugs\": []}"}}