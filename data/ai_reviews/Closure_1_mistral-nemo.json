{"sample_id": "Closure_1", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\nimport com.google.javascript.jscomp.DefinitionsRemover.Definition;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.*;\n\n/**\n * Garbage collection for variable and function definitions. Basically performs\n * a mark-and-sweep type algorithm over the JavaScript parse tree.\n *\n * For each scope:\n * (1) Scan the variable/function declarations at that scope.\n * (2) Traverse the scope for references, marking all referenced variables.\n *     Unlike other compiler passes, this is a pre-order traversal, not a\n *     post-order traversal.\n * (3) If the traversal encounters an assign without other side-effects,\n *     create a continuation. Continue the continuation iff the assigned\n *     variable is referenced.\n * (4) When the traversal completes, remove all unreferenced variables.\n *\n * If it makes it easier, you can think of the continuations of the traversal\n * as a reference graph. Each continuation represents a set of edges, where the\n * source node is a known variable, and the destination nodes are lazily\n * evaluated when the continuation is executed.\n *\n * This algorithm is similar to the algorithm used by {@code SmartNameRemoval}.\n * {@code SmartNameRemoval} maintains an explicit graph of dependencies\n * between global symbols. However, {@code SmartNameRemoval} cannot handle\n * non-trivial edges in the reference graph (\"A is referenced iff both B and C\n * are referenced\"), or local variables. {@code SmartNameRemoval} is also\n * substantially more complicated because it tries to handle namespaces\n * (which is largely unnecessary in the presence of {@code CollapseProperties}.\n *\n * This pass also uses a more complex analysis of assignments, where\n * an assignment to a variable or a property of that variable does not\n * necessarily count as a reference to that variable, unless we can prove\n * that it modifies external state. This is similar to\n * {@code FlowSensitiveInlineVariables}, except that it works for variables\n * used across scopes.\n *\n */\nclass RemoveUnusedVars\n    implements CompilerPass, OptimizeCalls.CallGraphCompilerPass {\n\n  private final AbstractCompiler compiler;\n\n  private final CodingConvention codingConvention;\n\n  private final boolean removeGlobals;\n\n  private boolean preserveFunctionExpressionNames;\n\n  /**\n   * Keep track of variables that we've referenced.\n   */\n  private final Set<Var> referenced = Sets.newHashSet();\n\n  /**\n   * Keep track of variables that might be unreferenced.\n   */\n  private final List<Var> maybeUnreferenced = Lists.newArrayList();\n\n  /**\n   * Keep track of scopes that we've traversed.\n   */\n  private final List<Scope> allFunctionScopes = Lists.newArrayList();\n\n  /**\n   * Keep track of assigns to variables that we haven't referenced.\n   */\n  private final Multimap<Var, Assign> assignsByVar =\n      ArrayListMultimap.create();\n\n  /**\n   * The assigns, indexed by the NAME node that they assign to.\n   */\n  private final Map<Node, Assign> assignsByNode = Maps.newHashMap();\n\n  /**\n   * Subclass name -> class-defining call EXPR node. (like inherits)\n   */\n  private final Multimap<Var, Node> classDefiningCalls =\n      ArrayListMultimap.create();\n\n  /**\n   * Keep track of continuations that are finished iff the variable they're\n   * indexed by is referenced.\n   */\n  private final Multimap<Var, Continuation> continuations =\n      ArrayListMultimap.create();\n\n  private boolean modifyCallSites;\n\n  private CallSiteOptimizer callSiteOptimizer;\n\n  RemoveUnusedVars(\n      AbstractCompiler compiler,\n      boolean removeGlobals,\n      boolean preserveFunctionExpressionNames,\n      boolean modifyCallSites) {\n    this.compiler = compiler;\n    this.codingConvention = compiler.getCodingConvention();\n    this.removeGlobals = removeGlobals;\n    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n    this.modifyCallSites = modifyCallSites;\n  }\n\n  /**\n   * Traverses the root, removing all unused variables. Multiple traversals\n   * may occur to ensure all unused variables are removed.\n   */\n  @Override\n  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n    SimpleDefinitionFinder defFinder = null;\n\n    if (modifyCallSites) {\n      // For testing, allow the SimpleDefinitionFinder to be build now.\n      defFinder = new SimpleDefinitionFinder(compiler);\n      defFinder.process(externs, root);\n    }\n    process(externs, root, defFinder);\n  }\n\n  @Override\n  public void process(\n      Node externs, Node root, SimpleDefinitionFinder defFinder) {\n    if (modifyCallSites) {\n      Preconditions.checkNotNull(defFinder);\n      callSiteOptimizer = new CallSiteOptimizer(compiler, defFinder);\n    }\n    traverseAndRemoveUnusedReferences(root);\n    if (callSiteOptimizer != null) {\n      callSiteOptimizer.applyChanges();\n    }\n  }\n\n  /**\n   * Traverses a node recursively. Call this once per pass.\n   */\n  private void traverseAndRemoveUnusedReferences(Node root) {\n    Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null);\n    traverseNode(root, null, scope);\n\n    if (removeGlobals) {\n      collectMaybeUnreferencedVars(scope);\n    }\n\n    interpretAssigns();\n    removeUnreferencedVars();\n    for (Scope fnScope : allFunctionScopes) {\n      removeUnreferencedFunctionArgs(fnScope);\n    }\n  }\n\n  /**\n   * Traverses everything in the current scope and marks variables that\n   * are referenced.\n   *\n   * During traversal, we identify subtrees that will only be\n   * referenced if their enclosing variables are referenced. Instead of\n   * traversing those subtrees, we create a continuation for them,\n   * and traverse them lazily.\n   */\n  private void traverseNode(Node n, Node parent, Scope scope) {\n    int type = n.getType();\n    Var var = null;\n    switch (type) {\n      case Token.FUNCTION:\n        // If this function is a removable var, then create a continuation\n        // for it instead of traversing immediately.\n        if (NodeUtil.isFunctionDeclaration(n)) {\n          var = scope.getVar(n.getFirstChild().getString());\n        }\n\n        if (var != null && isRemovableVar(var)) {\n          continuations.put(var, new Continuation(n, scope));\n        } else {\n          traverseFunction(n, scope);\n        }\n        return;\n\n      case Token.ASSIGN:\n        Assign maybeAssign = Assign.maybeCreateAssign(n);\n        if (maybeAssign != null) {\n          // Put this in the assign map. It might count as a reference,\n          // but we won't know that until we have an index of all assigns.\n          var = scope.getVar(maybeAssign.nameNode.getString());\n          if (var != null) {\n            assignsByVar.put(var, maybeAssign);\n            assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n\n            if (isRemovableVar(var) &&\n                !maybeAssign.mayHaveSecondarySideEffects) {\n              // If the var is unreferenced and performing this assign has\n              // no secondary side effects, then we can create a continuation\n              // for it instead of traversing immediately.\n              continuations.put(var, new Continuation(n, scope));\n              return;\n            }\n          }\n        }\n        break;\n\n      case Token.CALL:\n        Var modifiedVar = null;\n\n        // Look for calls to inheritance-defining calls (such as goog.inherits).\n        SubclassRelationship subclassRelationship =\n            codingConvention.getClassesDefinedByCall(n);\n        if (subclassRelationship != null) {\n          modifiedVar = scope.getVar(subclassRelationship.subclassName);\n        } else {\n          // Look for calls to addSingletonGetter calls.\n          String className = codingConvention.getSingletonGetterClassName(n);\n          if (className != null) {\n            modifiedVar = scope.getVar(className);\n          }\n        }\n\n        // Don't try to track the inheritance calls for non-globals. It would\n        // be more correct to only not track when the subclass does not\n        // reference a constructor, but checking that it is a global is\n        // easier and mostly the same.\n        if (modifiedVar != null && modifiedVar.isGlobal()\n            && !referenced.contains(modifiedVar)) {\n          // Save a reference to the EXPR node.\n          classDefiningCalls.put(modifiedVar, parent);\n          continuations.put(modifiedVar, new Continuation(n, scope));\n          return;\n        }\n        break;\n\n      case Token.NAME:\n        var = scope.getVar(n.getString());\n        if (parent.isVar()) {\n          Node value = n.getFirstChild();\n          if (value != null && var != null && isRemovableVar(var) &&\n              !NodeUtil.mayHaveSideEffects(value, compiler)) {\n            // If the var is unreferenced and creating its value has no side\n            // effects, then we can create a continuation for it instead\n            // of traversing immediately.\n            continuations.put(var, new Continuation(n, scope));\n            return;\n          }\n        } else {\n\n          // If arguments is escaped, we just assume the worst and continue\n          // on all the parameters.\n          if (\"arguments\".equals(n.getString()) && scope.isLocal()) {\n            Node lp = scope.getRootNode().getFirstChild().getNext();\n            for (Node a = lp.getFirstChild(); a != null; a = a.getNext()) {\n              markReferencedVar(scope.getVar(a.getString()));\n            }\n          }\n\n          // All name references that aren't declarations or assigns\n          // are references to other vars.\n          if (var != null) {\n            // If that var hasn't already been marked referenced, then\n            // start tracking it.  If this is an assign, do nothing\n            // for now.\n            if (isRemovableVar(var)) {\n              if (!assignsByNode.containsKey(n)) {\n                markReferencedVar(var);\n              }\n            } else {\n              markReferencedVar(var);\n            }\n          }\n        }\n        break;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      traverseNode(c, n, scope);\n    }\n  }\n\n  private boolean isRemovableVar(Var var) {\n    // Global variables are off-limits if the user might be using them.\n    if (!removeGlobals && var.isGlobal()) {\n      return false;\n    }\n\n    // Referenced variables are off-limits.\n    if (referenced.contains(var)) {\n      return false;\n    }\n\n    // Exported variables are off-limits.\n    if (codingConvention.isExported(var.getName())) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Traverses a function, which creates a new scope in JavaScript.\n   *\n   * Note that CATCH blocks also create a new scope, but only for the\n   * catch variable. Declarations within the block actually belong to the\n   * enclosing scope. Because we don't remove catch variables, there's\n   * no need to treat CATCH blocks differently like we do functions.\n   */\n  private void traverseFunction(Node n, Scope parentScope) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node body = n.getLastChild();\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());\n\n    Scope fnScope =\n        new SyntacticScopeCreator(compiler).createScope(n, parentScope);\n    traverseNode(body, n, fnScope);\n\n    collectMaybeUnreferencedVars(fnScope);\n    allFunctionScopes.add(fnScope);\n  }\n\n  /**\n   * For each variable in this scope that we haven't found a reference\n   * for yet, add it to the list of variables to check later.\n   */\n  private void collectMaybeUnreferencedVars(Scope scope) {\n    for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n      Var var = it.next();\n      if (isRemovableVar(var)) {\n        maybeUnreferenced.add(var);\n      }\n    }\n  }\n\n  /**\n   * Removes unreferenced arguments from a function declaration and when\n   * possible the function's callSites.\n   *\n   * @param fnScope The scope inside the function\n   */\n  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }\n\n\n  /**\n   * @return the LP node containing the function parameters.\n   */\n  private static Node getFunctionArgList(Node function) {\n    return function.getFirstChild().getNext();\n  }\n\n  private static class CallSiteOptimizer {\n    private final AbstractCompiler compiler;\n    private final SimpleDefinitionFinder defFinder;\n    private final List<Node> toRemove = Lists.newArrayList();\n    private final List<Node> toReplaceWithZero = Lists.newArrayList();\n\n    CallSiteOptimizer(\n        AbstractCompiler compiler,\n        SimpleDefinitionFinder defFinder) {\n      this.compiler = compiler;\n      this.defFinder = defFinder;\n    }\n\n    public void optimize(Scope fnScope, Set<Var> referenced) {\n      Node function = fnScope.getRootNode();\n      Preconditions.checkState(function.isFunction());\n      Node argList = getFunctionArgList(function);\n\n      // In this path we try to modify all the call sites to remove unused\n      // function parameters.\n      boolean changeCallSignature = canChangeSignature(function);\n      markUnreferencedFunctionArgs(\n          fnScope, function, referenced,\n          argList.getFirstChild(), 0, changeCallSignature);\n    }\n\n    /**\n     * Applies optimizations to all previously marked nodes.\n     */\n    public void applyChanges() {\n      for (Node n : toRemove) {\n        n.getParent().removeChild(n);\n        compiler.reportCodeChange();\n      }\n      for (Node n : toReplaceWithZero) {\n        n.getParent().replaceChild(n, IR.number(0).srcref(n));\n        compiler.reportCodeChange();\n      }\n    }\n\n    /**\n     * For each unused function parameter, determine if it can be removed\n     * from all the call sites, if so, remove it from the function signature\n     * and the call sites otherwise replace the unused value where possible\n     * with a constant (0).\n     *\n     * @param scope The function scope\n     * @param function The function\n     * @param param The current parameter node in the parameter list.\n     * @param paramIndex The index of the current parameter\n     * @param canChangeSignature Whether function signature can be change.\n     * @return Whether there is a following function parameter.\n     */\n    private boolean markUnreferencedFunctionArgs(\n        Scope scope, Node function, Set<Var> referenced,\n        Node param, int paramIndex,\n        boolean canChangeSignature) {\n      if (param != null) {\n        // Take care of the following siblings first.\n        boolean hasFollowing = markUnreferencedFunctionArgs(\n            scope, function, referenced, param.getNext(), paramIndex+1,\n            canChangeSignature);\n\n        Var var = scope.getVar(param.getString());\n        if (!referenced.contains(var)) {\n          Preconditions.checkNotNull(var);\n\n          // Remove call parameter if we can generally change the signature\n          // or if it is the last parameter in the parameter list.\n          boolean modifyAllCallSites = canChangeSignature || !hasFollowing;\n          if (modifyAllCallSites) {\n            modifyAllCallSites = canRemoveArgFromCallSites(\n                function, paramIndex);\n          }\n\n          tryRemoveArgFromCallSites(function, paramIndex, modifyAllCallSites);\n\n          // Remove an unused function parameter if all the call sites can\n          // be modified to remove it, or if it is the last parameter.\n          if (modifyAllCallSites || !hasFollowing) {\n            toRemove.add(param);\n            return hasFollowing;\n          }\n        }\n        return true;\n      } else {\n        // Anything past the last formal parameter can be removed from the call\n        // sites.\n        tryRemoveAllFollowingArgs(function, paramIndex-1);\n        return false;\n      }\n    }\n\n    /**\n     * Remove all references to a parameter, otherwise simplify the known\n     * references.\n     * @return Whether all the references were removed.\n     */\n    private boolean canRemoveArgFromCallSites(Node function, int argIndex) {\n      Definition definition = getFunctionDefinition(function);\n\n      // Check all the call sites.\n      for (UseSite site : defFinder.getUseSites(definition)) {\n        if (isModifiableCallSite(site)) {\n          Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n          // TODO(johnlenz): try to remove parameters with side-effects by\n          // decomposing the call expression.\n          if (arg != null && NodeUtil.mayHaveSideEffects(arg, compiler)) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    /**\n     * Remove all references to a parameter if possible otherwise simplify the\n     * side-effect free parameters.\n     */\n    private void tryRemoveArgFromCallSites(\n        Node function, int argIndex, boolean canModifyAllSites) {\n      Definition definition = getFunctionDefinition(function);\n\n      for (UseSite site : defFinder.getUseSites(definition)) {\n        if (isModifiableCallSite(site)) {\n          Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n          if (arg != null) {\n            Node argParent = arg.getParent();\n            // Even if we can't change the signature in general we can always\n            // remove an unused value off the end of the parameter list.\n            if (canModifyAllSites\n                || (arg.getNext() == null\n                    && !NodeUtil.mayHaveSideEffects(arg, compiler))) {\n              toRemove.add(arg);\n            } else {\n              // replace the node in the arg with 0\n              if (!NodeUtil.mayHaveSideEffects(arg, compiler)\n                  && (!arg.isNumber() || arg.getDouble() != 0)) {\n                toReplaceWithZero.add(arg);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Remove all the following parameters without side-effects\n     */\n    private void tryRemoveAllFollowingArgs(Node function, final int argIndex) {\n      Definition definition = getFunctionDefinition(function);\n      for (UseSite site : defFinder.getUseSites(definition)) {\n        if (!isModifiableCallSite(site)) {\n          continue;\n        }\n        Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex + 1);\n        while (arg != null) {\n          if (!NodeUtil.mayHaveSideEffects(arg)) {\n            toRemove.add(arg);\n          }\n          arg = arg.getNext();\n        }\n      }\n    }\n\n    /**\n     * Returns the nth argument node given a usage site for a direct function\n     * call or for a func.call() node.\n     */\n    private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex) {\n      int adjustedArgIndex = argIndex;\n      Node parent = site.node.getParent();\n      if (NodeUtil.isFunctionObjectCall(parent)) {\n        adjustedArgIndex++;\n      }\n      return NodeUtil.getArgumentForCallOrNew(parent, adjustedArgIndex);\n    }\n\n    /**\n     * @param function\n     * @return Whether the callers to this function can be modified in any way.\n     */\n    boolean canModifyCallers(Node function) {\n      if (NodeUtil.isVarArgsFunction(function)) {\n        return false;\n      }\n\n      DefinitionSite defSite = defFinder.getDefinitionForFunction(function);\n      if (defSite == null) {\n        return false;\n      }\n\n      Definition definition = defSite.definition;\n\n      // Be conservative, don't try to optimize any declaration that isn't as\n      // simple function declaration or assignment.\n      if (!SimpleDefinitionFinder.isSimpleFunctionDeclaration(function)) {\n        return false;\n      }\n\n      return defFinder.canModifyDefinition(definition);\n    }\n\n    /**\n     * @param site The site to inspect\n     * @return Whether the call site is suitable for modification\n     */\n    private static boolean isModifiableCallSite(UseSite site) {\n      return SimpleDefinitionFinder.isCallOrNewSite(site)\n          && !NodeUtil.isFunctionObjectApply(site.node.getParent());\n    }\n\n    /**\n     * @return Whether the definitionSite represents a function whose call\n     *      signature can be modified.\n     */\n    private boolean canChangeSignature(Node function) {\n      Definition definition = getFunctionDefinition(function);\n      CodingConvention convention = compiler.getCodingConvention();\n\n      Preconditions.checkState(!definition.isExtern());\n\n      Collection<UseSite> useSites = defFinder.getUseSites(definition);\n      for (UseSite site : useSites) {\n        Node parent = site.node.getParent();\n\n        // This was a use site removed by something else before we run.\n        // 1. By another pass before us which means the definition graph is\n        //    no updated properly.\n        // 2. By the continuations algorithm above.\n        if (parent == null) {\n          continue; // Ignore it.\n        }\n\n        // Ignore references within goog.inherits calls.\n        if (parent.isCall() &&\n            convention.getClassesDefinedByCall(parent) != null) {\n          continue;\n        }\n\n        // Accessing the property directly prevents rewrite.\n        if (!SimpleDefinitionFinder.isCallOrNewSite(site)) {\n          if (!(parent.isGetProp() &&\n              NodeUtil.isFunctionObjectCall(parent.getParent()))) {\n            return false;\n          }\n        }\n\n        if (NodeUtil.isFunctionObjectApply(parent)) {\n          return false;\n        }\n\n        // TODO(johnlenz): support specialization\n\n        // Multiple definitions prevent rewrite.\n        // Attempt to validate the state of the simple definition finder.\n        Node nameNode = site.node;\n        Collection<Definition> singleSiteDefinitions =\n            defFinder.getDefinitionsReferencedAt(nameNode);\n        Preconditions.checkState(singleSiteDefinitions.size() == 1);\n        Preconditions.checkState(singleSiteDefinitions.contains(definition));\n      }\n\n      return true;\n    }\n\n    /**\n     * @param function\n     * @return the Definition object for the function.\n     */\n    private Definition getFunctionDefinition(Node function) {\n      DefinitionSite definitionSite = defFinder.getDefinitionForFunction(\n          function);\n      Preconditions.checkNotNull(definitionSite);\n      Definition definition = definitionSite.definition;\n      Preconditions.checkState(!definitionSite.inExterns);\n      Preconditions.checkState(definition.getRValue() == function);\n      return definition;\n    }\n  }\n\n\n  /**\n   * Look at all the property assigns to all variables.\n   * These may or may not count as references. For example,\n   *\n   * <code>\n   * var x = {};\n   * x.foo = 3; // not a reference.\n   * var y = foo();\n   * y.foo = 3; // is a reference.\n   * </code>\n   *\n   * Interpreting assignments could mark a variable as referenced that\n   * wasn't referenced before, in order to keep it alive. Because we find\n   * references by lazily traversing subtrees, marking a variable as\n   * referenced could trigger new traversals of new subtrees, which could\n   * find new references.\n   *\n   * Therefore, this interpretation needs to be run to a fixed point.\n   */\n  private void interpretAssigns() {\n    boolean changes = false;\n    do {\n      changes = false;\n\n      // We can't use traditional iterators and iterables for this list,\n      // because our lazily-evaluated continuations will modify it while\n      // we traverse it.\n      for (int current = 0; current < maybeUnreferenced.size(); current++) {\n        Var var = maybeUnreferenced.get(current);\n        if (referenced.contains(var)) {\n          maybeUnreferenced.remove(current);\n          current--;\n        } else {\n          boolean assignedToUnknownValue = false;\n          boolean hasPropertyAssign = false;\n\n          if (var.getParentNode().isVar() &&\n              !NodeUtil.isForIn(var.getParentNode().getParent())) {\n            Node value = var.getInitialValue();\n            assignedToUnknownValue = value != null &&\n                !NodeUtil.isLiteralValue(value, true);\n          } else {\n            // This was initialized to a function arg or a catch param\n            // or a for...in variable.\n            assignedToUnknownValue = true;\n          }\n\n          boolean maybeEscaped = false;\n          for (Assign assign : assignsByVar.get(var)) {\n            if (assign.isPropertyAssign) {\n              hasPropertyAssign = true;\n            } else if (!NodeUtil.isLiteralValue(\n                assign.assignNode.getLastChild(), true)) {\n              assignedToUnknownValue = true;\n            }\n            if (assign.maybeAliased) {\n              maybeEscaped = true;\n            }\n          }\n\n          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {\n            changes = markReferencedVar(var) || changes;\n            maybeUnreferenced.remove(current);\n            current--;\n          }\n        }\n      }\n    } while (changes);\n  }\n\n  /**\n   * Remove all assigns to a var.\n   */\n  private void removeAllAssigns(Var var) {\n    for (Assign assign : assignsByVar.get(var)) {\n      assign.remove();\n      compiler.reportCodeChange();\n    }\n  }\n\n  /**\n   * Marks a var as referenced, recursing into any values of this var\n   * that we skipped.\n   * @return True if this variable had not been referenced before.\n   */\n  private boolean markReferencedVar(Var var) {\n    if (referenced.add(var)) {\n      for (Continuation c : continuations.get(var)) {\n        c.apply();\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes any vars in the scope that were not referenced. Removes any\n   * assignments to those variables as well.\n   */\n  private void removeUnreferencedVars() {\n    CodingConvention convention = codingConvention;\n\n    for (Iterator<Var> it = maybeUnreferenced.iterator(); it.hasNext(); ) {\n      Var var = it.next();\n\n      // Remove calls to inheritance-defining functions where the unreferenced\n      // class is the subclass.\n      for (Node exprCallNode : classDefiningCalls.get(var)) {\n        NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n        compiler.reportCodeChange();\n      }\n\n      // Regardless of what happens to the original declaration,\n      // we need to remove all assigns, because they may contain references\n      // to other unreferenced variables.\n      removeAllAssigns(var);\n\n      compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n      Node nameNode = var.nameNode;\n      Node toRemove = nameNode.getParent();\n      Node parent = toRemove.getParent();\n\n      Preconditions.checkState(\n          toRemove.isVar() ||\n          toRemove.isFunction() ||\n          toRemove.isParamList() &&\n          parent.isFunction(),\n          \"We should only declare vars and functions and function args\");\n\n      if (toRemove.isParamList() &&\n          parent.isFunction()) {\n        // Don't remove function arguments here. That's a special case\n        // that's taken care of in removeUnreferencedFunctionArgs.\n      } else if (NodeUtil.isFunctionExpression(toRemove)) {\n        if (!preserveFunctionExpressionNames) {\n          toRemove.getFirstChild().setString(\"\");\n          compiler.reportCodeChange();\n        }\n        // Don't remove bleeding functions.\n      } else if (parent != null &&\n          parent.isFor() &&\n          parent.getChildCount() < 4) {\n        // foreach iterations have 3 children. Leave them alone.\n      } else if (toRemove.isVar() &&\n          nameNode.hasChildren() &&\n          NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) {\n        // If this is a single var declaration, we can at least remove the\n        // declaration itself and just leave the value, e.g.,\n        // var a = foo(); => foo();\n        if (toRemove.getChildCount() == 1) {\n          parent.replaceChild(toRemove,\n              IR.exprResult(nameNode.removeFirstChild()));\n          compiler.reportCodeChange();\n        }\n      } else if (toRemove.isVar() &&\n          toRemove.getChildCount() > 1) {\n        // For var declarations with multiple names (i.e. var a, b, c),\n        // only remove the unreferenced name\n        toRemove.removeChild(nameNode);\n        compiler.reportCodeChange();\n      } else if (parent != null) {\n        NodeUtil.removeChild(parent, toRemove);\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  /**\n   * Our progress in a traversal can be expressed completely as the\n   * current node and scope. The continuation lets us save that\n   * information so that we can continue the traversal later.\n   */\n  private class Continuation {\n    private final Node node;\n    private final Scope scope;\n\n    Continuation(Node node, Scope scope) {\n      this.node = node;\n      this.scope = scope;\n    }\n\n    void apply() {\n      if (NodeUtil.isFunctionDeclaration(node)) {\n        traverseFunction(node, scope);\n      } else {\n        for (Node child = node.getFirstChild();\n             child != null; child = child.getNext()) {\n          traverseNode(child, node, scope);\n        }\n      }\n    }\n  }\n\n  private static class Assign {\n\n    final Node assignNode;\n\n    final Node nameNode;\n\n    // If false, then this is an assign to the normal variable. Otherwise,\n    // this is an assign to a property of that variable.\n    final boolean isPropertyAssign;\n\n    // Secondary side effects are any side effects in this assign statement\n    // that aren't caused by the assignment operation itself. For example,\n    // a().b = 3;\n    // a = b();\n    // var foo = (a = b);\n    // In the first two cases, the sides of the assignment have side-effects.\n    // In the last one, the result of the assignment is used, so we\n    // are conservative and assume that it may be used in a side-effecting\n    // way.\n    final boolean mayHaveSecondarySideEffects;\n\n    // If true, the value may have escaped and any modification is a use.\n    final boolean maybeAliased;\n\n    Assign(Node assignNode, Node nameNode, boolean isPropertyAssign) {\n      Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n      this.assignNode = assignNode;\n      this.nameNode = nameNode;\n      this.isPropertyAssign = isPropertyAssign;\n\n      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);\n      this.mayHaveSecondarySideEffects =\n          maybeAliased ||\n          NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||\n          NodeUtil.mayHaveSideEffects(assignNode.getLastChild());\n    }\n\n    /**\n     * If this is an assign to a variable or its property, return it.\n     * Otherwise, return null.\n     */\n    static Assign maybeCreateAssign(Node assignNode) {\n      Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n\n      // Skip one level of GETPROPs or GETELEMs.\n      //\n      // Don't skip more than one level, because then we get into\n      // situations where assigns to properties of properties will always\n      // trigger side-effects, and the variable they're on cannot be removed.\n      boolean isPropAssign = false;\n      Node current = assignNode.getFirstChild();\n      if (NodeUtil.isGet(current)) {\n        current = current.getFirstChild();\n        isPropAssign = true;\n\n        if (current.isGetProp() &&\n            current.getLastChild().getString().equals(\"prototype\")) {\n          // Prototype properties sets should be considered like normal\n          // property sets.\n          current = current.getFirstChild();\n        }\n      }\n\n      if (current.isName()) {\n        return new Assign(assignNode, current, isPropAssign);\n      }\n      return null;\n    }\n\n    /**\n     * Replace the current assign with its right hand side.\n     */\n    void remove() {\n      Node parent = assignNode.getParent();\n      if (mayHaveSecondarySideEffects) {\n        Node replacement = assignNode.getLastChild().detachFromParent();\n\n        // Aggregate any expressions in GETELEMs.\n        for (Node current = assignNode.getFirstChild();\n             !current.isName();\n             current = current.getFirstChild()) {\n          if (current.isGetElem()) {\n            replacement = IR.comma(\n                current.getLastChild().detachFromParent(), replacement);\n            replacement.copyInformationFrom(current);\n          }\n        }\n\n        parent.replaceChild(assignNode, replacement);\n      } else {\n        Node gramps = parent.getParent();\n        if (parent.isExprResult()) {\n          gramps.removeChild(parent);\n        } else {\n          parent.replaceChild(assignNode,\n              assignNode.getLastChild().detachFromParent());\n        }\n      }\n    }\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"description\": \"The `process` method is called twice in the `process` method of the `RemoveUnusedVars` class. This could lead to unexpected behavior or performance issues.\",\n      \"location\": \"Line 133 in the `RemoveUnusedVars` class\"\n    },\n    {\n      \"description\": \"The `modifyCallSites` variable is declared as `private`, but it is accessed directly in the `process` method without any access modifier. This could lead to unexpected behavior or security issues if the variable is accessed from outside the class.\",\n      \"location\": \"Line 128 in the `RemoveUnusedVars` class\"\n    },\n    {\n      \"description\": \"The `callSiteOptimizer` variable is declared as `private`, but it is accessed directly in the `process` method without any access modifier. This could lead to unexpected behavior or security issues if the variable is accessed from outside the class.\",\n      \"location\": \"Line 136 in the `RemoveUnusedVars` class\"\n    },\n    {\n      \"description\": \"The `defFinder` parameter in the `process` method is not used in the method body. This could indicate a bug or unused code.\",\n      \"location\": \"Line 131 in the `RemoveUnusedVars` class\"\n    },\n    {\n      \"description\": \"The `compiler` field is not initialized in the constructor of the `RemoveUnusedVars` class. This could lead to a `NullPointerException` if the field is accessed before it is initialized.\",\n      \"location\": \"Line 29 in the `RemoveUnusedVars` class\"\n    },\n    {\n      \"description\": \"The `codingConvention` field is not initialized in the constructor of the `RemoveUnusedVars` class. This could lead to a `NullPointerException` if the field is accessed before it is initialized.\",\n      \"location\": \"Line 30 in the `RemoveUnusedVars` class\"\n    },\n    {\n      \"description\": \"The `removeGlobals` parameter in the constructor of the `RemoveUnusedVars` class is not used in the constructor body. This could indicate a bug or unused code.\",\n      \"location\": \"Line 31 in the `RemoveUnusedVars` class\"\n    },\n    {\n      \"description\": \"The `preserveFunctionExpressionNames` parameter in the constructor of the `RemoveUnusedVars` class is not used in the constructor body. This could indicate a bug or unused code.\",\n      \"location\": \"Line 32 in the `RemoveUnusedVars` class\"\n    }\n  ]\n}"}}