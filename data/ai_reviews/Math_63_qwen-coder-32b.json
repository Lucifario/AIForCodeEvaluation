{"sample_id": "Math_63", "model": "qwen-coder-32b", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.util;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\nimport org.apache.commons.math.MathRuntimeException;\nimport org.apache.commons.math.exception.util.Localizable;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.exception.NonMonotonousSequenceException;\n\n/**\n * Some useful additions to the built-in functions in {@link Math}.\n * @version $Revision$ $Date$\n */\npublic final class MathUtils {\n\n    /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */\n    public static final double EPSILON = 0x1.0p-53;\n\n    /** Safe minimum, such that 1 / SAFE_MIN does not overflow.\n     * <p>In IEEE 754 arithmetic, this is also the smallest normalized\n     * number 2<sup>-1022</sup>.</p>\n     */\n    public static final double SAFE_MIN = 0x1.0p-1022;\n\n    /**\n     * 2 &pi;.\n     * @since 2.1\n     */\n    public static final double TWO_PI = 2 * FastMath.PI;\n\n    /** -1.0 cast as a byte. */\n    private static final byte  NB = (byte)-1;\n\n    /** -1.0 cast as a short. */\n    private static final short NS = (short)-1;\n\n    /** 1.0 cast as a byte. */\n    private static final byte  PB = (byte)1;\n\n    /** 1.0 cast as a short. */\n    private static final short PS = (short)1;\n\n    /** 0.0 cast as a byte. */\n    private static final byte  ZB = (byte)0;\n\n    /** 0.0 cast as a short. */\n    private static final short ZS = (short)0;\n\n    /** Gap between NaN and regular numbers. */\n    private static final int NAN_GAP = 4 * 1024 * 1024;\n\n    /** Offset to order signed double numbers lexicographically. */\n    private static final long SGN_MASK = 0x8000000000000000L;\n\n    /** All long-representable factorials */\n    private static final long[] FACTORIALS = new long[] {\n                       1l,                  1l,                   2l,\n                       6l,                 24l,                 120l,\n                     720l,               5040l,               40320l,\n                  362880l,            3628800l,            39916800l,\n               479001600l,         6227020800l,         87178291200l,\n           1307674368000l,     20922789888000l,     355687428096000l,\n        6402373705728000l, 121645100408832000l, 2432902008176640000l };\n\n    /**\n     * Private Constructor\n     */\n    private MathUtils() {\n        super();\n    }\n\n    /**\n     * Add two integers, checking for overflow.\n     *\n     * @param x an addend\n     * @param y an addend\n     * @return the sum <code>x+y</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         int\n     * @since 1.1\n     */\n    public static int addAndCheck(int x, int y) {\n        long s = (long)x + (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n        }\n        return (int)s;\n    }\n\n    /**\n     * Add two long integers, checking for overflow.\n     *\n     * @param a an addend\n     * @param b an addend\n     * @return the sum <code>a+b</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         long\n     * @since 1.2\n     */\n    public static long addAndCheck(long a, long b) {\n        return addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n    }\n\n    /**\n     * Add two long integers, checking for overflow.\n     *\n     * @param a an addend\n     * @param b an addend\n     * @param pattern the pattern to use for any thrown exception.\n     * @return the sum <code>a+b</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         long\n     * @since 1.2\n     */\n    private static long addAndCheck(long a, long b, Localizable pattern) {\n        long ret;\n        if (a > b) {\n            // use symmetry to reduce boundary cases\n            ret = addAndCheck(b, a, pattern);\n        } else {\n            // assert a <= b\n\n            if (a < 0) {\n                if (b < 0) {\n                    // check for negative overflow\n                    if (Long.MIN_VALUE - b <= a) {\n                        ret = a + b;\n                    } else {\n                        throw MathRuntimeException.createArithmeticException(pattern, a, b);\n                    }\n                } else {\n                    // opposite sign addition is always safe\n                    ret = a + b;\n                }\n            } else {\n                // assert a >= 0\n                // assert b >= 0\n\n                // check for positive overflow\n                if (a <= Long.MAX_VALUE - b) {\n                    ret = a + b;\n                } else {\n                    throw MathRuntimeException.createArithmeticException(pattern, a, b);\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Returns an exact representation of the <a\n     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n     * <code>k</code>-element subsets that can be selected from an\n     * <code>n</code>-element set.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>0 <= k <= n </code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * <li> The result is small enough to fit into a <code>long</code>. The\n     * largest value of <code>n</code> for which all coefficients are\n     * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds\n     * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is\n     * thrown.</li>\n     * </ul></p>\n     *\n     * @param n the size of the set\n     * @param k the size of the subsets to be counted\n     * @return <code>n choose k</code>\n     * @throws IllegalArgumentException if preconditions are not met.\n     * @throws ArithmeticException if the result is too large to be represented\n     *         by a long integer.\n     */\n    public static long binomialCoefficient(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        // Use symmetry for large k\n        if (k > n / 2)\n            return binomialCoefficient(n, n - k);\n\n        // We use the formula\n        // (n choose k) = n! / (n-k)! / k!\n        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n        // which could be written\n        // (n choose k) == (n-1 choose k-1) * n / k\n        long result = 1;\n        if (n <= 61) {\n            // For n <= 61, the naive implementation cannot overflow.\n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                result = result * i / j;\n                i++;\n            }\n        } else if (n <= 66) {\n            // For n > 61 but n <= 66, the result cannot overflow,\n            // but we must take care not to overflow intermediate values.\n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                // We know that (result * i) is divisible by j,\n                // but (result * i) may overflow, so we split j:\n                // Filter out the gcd, d, so j/d and i/d are integer.\n                // result is divisible by (j/d) because (j/d)\n                // is relative prime to (i/d) and is a divisor of\n                // result * (i/d).\n                final long d = gcd(i, j);\n                result = (result / (j / d)) * (i / d);\n                i++;\n            }\n        } else {\n            // For n > 66, a result overflow might occur, so we check\n            // the multiplication, taking care to not overflow\n            // unnecessary.\n            int i = n - k + 1;\n            for (int j = 1; j <= k; j++) {\n                final long d = gcd(i, j);\n                result = mulAndCheck(result / (j / d), i / d);\n                i++;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a <code>double</code> representation of the <a\n     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n     * <code>k</code>-element subsets that can be selected from an\n     * <code>n</code>-element set.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>0 <= k <= n </code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * <li> The result is small enough to fit into a <code>double</code>. The\n     * largest value of <code>n</code> for which all coefficients are <\n     * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n     * Double.POSITIVE_INFINITY is returned</li>\n     * </ul></p>\n     *\n     * @param n the size of the set\n     * @param k the size of the subsets to be counted\n     * @return <code>n choose k</code>\n     * @throws IllegalArgumentException if preconditions are not met.\n     */\n    public static double binomialCoefficientDouble(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 1d;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        if (k > n/2) {\n            return binomialCoefficientDouble(n, n - k);\n        }\n        if (n < 67) {\n            return binomialCoefficient(n,k);\n        }\n\n        double result = 1d;\n        for (int i = 1; i <= k; i++) {\n             result *= (double)(n - k + i) / (double)i;\n        }\n\n        return FastMath.floor(result + 0.5);\n    }\n\n    /**\n     * Returns the natural <code>log</code> of the <a\n     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n     * <code>k</code>-element subsets that can be selected from an\n     * <code>n</code>-element set.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>0 <= k <= n </code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * </ul></p>\n     *\n     * @param n the size of the set\n     * @param k the size of the subsets to be counted\n     * @return <code>n choose k</code>\n     * @throws IllegalArgumentException if preconditions are not met.\n     */\n    public static double binomialCoefficientLog(final int n, final int k) {\n        checkBinomial(n, k);\n        if ((n == k) || (k == 0)) {\n            return 0;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return FastMath.log(n);\n        }\n\n        /*\n         * For values small enough to do exact integer computation,\n         * return the log of the exact value\n         */\n        if (n < 67) {\n            return FastMath.log(binomialCoefficient(n,k));\n        }\n\n        /*\n         * Return the log of binomialCoefficientDouble for values that will not\n         * overflow binomialCoefficientDouble\n         */\n        if (n < 1030) {\n            return FastMath.log(binomialCoefficientDouble(n, k));\n        }\n\n        if (k > n / 2) {\n            return binomialCoefficientLog(n, n - k);\n        }\n\n        /*\n         * Sum logs for values that could overflow\n         */\n        double logSum = 0;\n\n        // n!/(n-k)!\n        for (int i = n - k + 1; i <= n; i++) {\n            logSum += FastMath.log(i);\n        }\n\n        // divide by k!\n        for (int i = 2; i <= k; i++) {\n            logSum -= FastMath.log(i);\n        }\n\n        return logSum;\n    }\n\n    /**\n     * Check binomial preconditions.\n     * @param n the size of the set\n     * @param k the size of the subsets to be counted\n     * @exception IllegalArgumentException if preconditions are not met.\n     */\n    private static void checkBinomial(final int n, final int k)\n        throws IllegalArgumentException {\n        if (n < k) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,\n                n, k);\n        }\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER,\n                  n);\n        }\n    }\n\n    /**\n     * Compares two numbers given some amount of allowed error.\n     *\n     * @param x the first number\n     * @param y the second number\n     * @param eps the amount of error to allow when checking for equality\n     * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>\n     *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>\n     *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul>\n     */\n    public static int compareTo(double x, double y, double eps) {\n        if (equals(x, y, eps)) {\n            return 0;\n        } else if (x < y) {\n          return -1;\n        }\n        return 1;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n     * hyperbolic cosine</a> of x.\n     *\n     * @param x double value for which to find the hyperbolic cosine\n     * @return hyperbolic cosine of x\n     */\n    public static double cosh(double x) {\n        return (FastMath.exp(x) + FastMath.exp(-x)) / 2.0;\n    }\n\n    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n    }\n\n    /**\n     * Returns true if both arguments are NaN or neither is NaN and they are\n     * equal as defined by {@link #equals(double,double) this method}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal or both are NaN.\n     */\n    public static boolean equalsIncludingNaN(double x, double y) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);\n    }\n\n    /**\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     *\n     * @param x first value\n     * @param y second value\n     * @param eps the amount of absolute error to allow.\n     * @return {@code true} if the values are equal or within range of each other.\n     */\n    public static boolean equals(double x, double y, double eps) {\n        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n    }\n\n    /**\n     * Returns true if both arguments are NaN or are equal or within the range\n     * of allowed error (inclusive).\n     *\n     * @param x first value\n     * @param y second value\n     * @param eps the amount of absolute error to allow.\n     * @return {@code true} if the values are equal or within range of each other,\n     * or both are NaN.\n     */\n    public static boolean equalsIncludingNaN(double x, double y, double eps) {\n        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n    }\n\n    /**\n     * Returns true if both arguments are equal or within the range of allowed\n     * error (inclusive).\n     * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n     * (or less) floating point numbers between them (i.e. two adjacent floating\n     * point numbers are considered equal.\n     * Adapted from <a\n     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n     * Bruce Dawson</a>\n     *\n     * @param x first value\n     * @param y second value\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between {@code x} and {@code y}.\n     * @return {@code true} if there are less than {@code maxUlps} floating\n     * point values between {@code x} and {@code y}.\n     */\n    public static boolean equals(double x, double y, int maxUlps) {\n        // Check that \"maxUlps\" is non-negative and small enough so that\n        // NaN won't compare as equal to anything (except another NaN).\n        assert maxUlps > 0 && maxUlps < NAN_GAP;\n\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }\n\n    /**\n     * Returns true if both arguments are NaN or if they are equal as defined\n     * by {@link #equals(double,double,int) this method}.\n     *\n     * @param x first value\n     * @param y second value\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between {@code x} and {@code y}.\n     * @return {@code true} if both arguments are NaN or if there are less than\n     * {@code maxUlps} floating point values between {@code x} and {@code y}.\n     */\n    public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps);\n    }\n\n    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link #equals(double,double) this method}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension\n     * and equal elements.\n     */\n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link #equalsIncludingNaN(double,double) this method}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension and\n     * equal elements\n     */\n    public static boolean equalsIncludingNaN(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns n!. Shorthand for <code>n</code> <a\n     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n     * product of the numbers <code>1,...,n</code>.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>n >= 0</code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * <li> The result is small enough to fit into a <code>long</code>. The\n     * largest value of <code>n</code> for which <code>n!</code> <\n     * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>\n     * an <code>ArithMeticException </code> is thrown.</li>\n     * </ul>\n     * </p>\n     *\n     * @param n argument\n     * @return <code>n!</code>\n     * @throws ArithmeticException if the result is too large to be represented\n     *         by a long integer.\n     * @throws IllegalArgumentException if n < 0\n     */\n    public static long factorial(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                  n);\n        }\n        if (n > 20) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return FACTORIALS[n];\n    }\n\n    /**\n     * Returns n!. Shorthand for <code>n</code> <a\n     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n     * product of the numbers <code>1,...,n</code> as a <code>double</code>.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>n >= 0</code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * <li> The result is small enough to fit into a <code>double</code>. The\n     * largest value of <code>n</code> for which <code>n!</code> <\n     * Double.MAX_VALUE</code> is 170. If the computed value exceeds\n     * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n     * </ul>\n     * </p>\n     *\n     * @param n argument\n     * @return <code>n!</code>\n     * @throws IllegalArgumentException if n < 0\n     */\n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                  n);\n        }\n        if (n < 21) {\n            return factorial(n);\n        }\n        return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5);\n    }\n\n    /**\n     * Returns the natural logarithm of n!.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>n >= 0</code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * </ul></p>\n     *\n     * @param n argument\n     * @return <code>n!</code>\n     * @throws IllegalArgumentException if preconditions are not met.\n     */\n    public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n                  n);\n        }\n        if (n < 21) {\n            return FastMath.log(factorial(n));\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += FastMath.log(i);\n        }\n        return logSum;\n    }\n\n    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * Special cases:\n     * <ul>\n     * <li>The invocations\n     * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,\n     * <code>gcd(Integer.MIN_VALUE, 0)</code> and\n     * <code>gcd(0, Integer.MIN_VALUE)</code> throw an\n     * <code>ArithmeticException</code>, because the result would be 2^31, which\n     * is too large for an int value.</li>\n     * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and\n     * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except\n     * for the special cases above.\n     * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns\n     * <code>0</code>.</li>\n     * </ul>\n     *\n     * @param p any number\n     * @param q any number\n     * @return the greatest common divisor, never negative\n     * @throws ArithmeticException if the result cannot be represented as a\n     * nonnegative int value\n     * @since 1.1\n     */\n    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw MathRuntimeException.createArithmeticException(\n                        LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                        p, q);\n            }\n            return FastMath.abs(u) + FastMath.abs(v);\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                    p, q);\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }\n\n    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * Special cases:\n     * <ul>\n     * <li>The invocations\n     * <code>gcd(Long.MIN_VALUE, Long.MIN_VALUE)</code>,\n     * <code>gcd(Long.MIN_VALUE, 0L)</code> and\n     * <code>gcd(0L, Long.MIN_VALUE)</code> throw an\n     * <code>ArithmeticException</code>, because the result would be 2^63, which\n     * is too large for a long value.</li>\n     * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0L, x)</code> and\n     * <code>gcd(x, 0L)</code> is the absolute value of <code>x</code>, except\n     * for the special cases above.\n     * <li>The invocation <code>gcd(0L, 0L)</code> is the only one which returns\n     * <code>0L</code>.</li>\n     * </ul>\n     *\n     * @param p any number\n     * @param q any number\n     * @return the greatest common divisor, never negative\n     * @throws ArithmeticException if the result cannot be represented as a nonnegative long\n     * value\n     * @since 2.1\n     */\n    public static long gcd(final long p, final long q) {\n        long u = p;\n        long v = q;\n        if ((u == 0) || (v == 0)) {\n            if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)){\n                throw MathRuntimeException.createArithmeticException(\n                        LocalizedFormats.GCD_OVERFLOW_64_BITS,\n                        p, q);\n            }\n            return FastMath.abs(u) + FastMath.abs(v);\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^63, while positive numbers can only be as large as 2^63-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 63) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 63) {\n            throw MathRuntimeException.createArithmeticException(\n                    LocalizedFormats.GCD_OVERFLOW_64_BITS,\n                    p, q);\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        long t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1L << k); // gcd is u*2^k\n    }\n\n    /**\n     * Returns an integer hash code representing the given double value.\n     *\n     * @param value the value to be hashed\n     * @return the hash code\n     */\n    public static int hash(double value) {\n        return new Double(value).hashCode();\n    }\n\n    /**\n     * Returns an integer hash code representing the given double array.\n     *\n     * @param value the value to be hashed (may be null)\n     * @return the hash code\n     * @since 1.2\n     */\n    public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }\n\n    /**\n     * For a byte value x, this method returns (byte)(+1) if x >= 0 and\n     * (byte)(-1) if x < 0.\n     *\n     * @param x the value, a byte\n     * @return (byte)(+1) or (byte)(-1), depending on the sign of x\n     */\n    public static byte indicator(final byte x) {\n        return (x >= ZB) ? PB : NB;\n    }\n\n    /**\n     * For a double precision value x, this method returns +1.0 if x >= 0 and\n     * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is\n     * <code>NaN</code>.\n     *\n     * @param x the value, a double\n     * @return +1.0 or -1.0, depending on the sign of x\n     */\n    public static double indicator(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x >= 0.0) ? 1.0 : -1.0;\n    }\n\n    /**\n     * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <\n     * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.\n     *\n     * @param x the value, a float\n     * @return +1.0F or -1.0F, depending on the sign of x\n     */\n    public static float indicator(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x >= 0.0F) ? 1.0F : -1.0F;\n    }\n\n    /**\n     * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.\n     *\n     * @param x the value, an int\n     * @return +1 or -1, depending on the sign of x\n     */\n    public static int indicator(final int x) {\n        return (x >= 0) ? 1 : -1;\n    }\n\n    /**\n     * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.\n     *\n     * @param x the value, a long\n     * @return +1L or -1L, depending on the sign of x\n     */\n    public static long indicator(final long x) {\n        return (x >= 0L) ? 1L : -1L;\n    }\n\n    /**\n     * For a short value x, this method returns (short)(+1) if x >= 0 and\n     * (short)(-1) if x < 0.\n     *\n     * @param x the value, a short\n     * @return (short)(+1) or (short)(-1), depending on the sign of x\n     */\n    public static short indicator(final short x) {\n        return (x >= ZS) ? PS : NS;\n    }\n\n    /**\n     * <p>\n     * Returns the least common multiple of the absolute value of two numbers,\n     * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.\n     * </p>\n     * Special cases:\n     * <ul>\n     * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and\n     * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a\n     * power of 2, throw an <code>ArithmeticException</code>, because the result\n     * would be 2^31, which is too large for an int value.</li>\n     * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is\n     * <code>0</code> for any <code>x</code>.\n     * </ul>\n     *\n     * @param a any number\n     * @param b any number\n     * @return the least common multiple, never negative\n     * @throws ArithmeticException\n     *             if the result cannot be represented as a nonnegative int\n     *             value\n     * @since 1.1\n     */\n    public static int lcm(int a, int b) {\n        if (a==0 || b==0){\n            return 0;\n        }\n        int lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm == Integer.MIN_VALUE) {\n            throw MathRuntimeException.createArithmeticException(\n                LocalizedFormats.LCM_OVERFLOW_32_BITS,\n                a, b);\n        }\n        return lcm;\n    }\n\n    /**\n     * <p>\n     * Returns the least common multiple of the absolute value of two numbers,\n     * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.\n     * </p>\n     * Special cases:\n     * <ul>\n     * <li>The invocations <code>lcm(Long.MIN_VALUE, n)</code> and\n     * <code>lcm(n, Long.MIN_VALUE)</code>, where <code>abs(n)</code> is a\n     * power of 2, throw an <code>ArithmeticException</code>, because the result\n     * would be 2^63, which is too large for an int value.</li>\n     * <li>The result of <code>lcm(0L, x)</code> and <code>lcm(x, 0L)</code> is\n     * <code>0L</code> for any <code>x</code>.\n     * </ul>\n     *\n     * @param a any number\n     * @param b any number\n     * @return the least common multiple, never negative\n     * @throws ArithmeticException if the result cannot be represented as a nonnegative long\n     * value\n     * @since 2.1\n     */\n    public static long lcm(long a, long b) {\n        if (a==0 || b==0){\n            return 0;\n        }\n        long lcm = FastMath.abs(mulAndCheck(a / gcd(a, b), b));\n        if (lcm == Long.MIN_VALUE){\n            throw MathRuntimeException.createArithmeticException(\n                LocalizedFormats.LCM_OVERFLOW_64_BITS,\n                a, b);\n        }\n        return lcm;\n    }\n\n    /**\n     * <p>Returns the\n     * <a href=\"http://mathworld.wolfram.com/Logarithm.html\">logarithm</a>\n     * for base <code>b</code> of <code>x</code>.\n     * </p>\n     * <p>Returns <code>NaN<code> if either argument is negative.  If\n     * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.\n     * If <code>base</code> is positive and <code>x</code> is 0,\n     * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments\n     * are 0, the result is <code>NaN</code>.</p>\n     *\n     * @param base the base of the logarithm, must be greater than 0\n     * @param x argument, must be greater than 0\n     * @return the value of the logarithm - the number y such that base^y = x.\n     * @since 1.2\n     */\n    public static double log(double base, double x) {\n        return FastMath.log(x)/FastMath.log(base);\n    }\n\n    /**\n     * Multiply two integers, checking for overflow.\n     *\n     * @param x a factor\n     * @param y a factor\n     * @return the product <code>x*y</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         int\n     * @since 1.1\n     */\n    public static int mulAndCheck(int x, int y) {\n        long m = ((long)x) * ((long)y);\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n\n    /**\n     * Multiply two long integers, checking for overflow.\n     *\n     * @param a first value\n     * @param b second value\n     * @return the product <code>a * b</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         long\n     * @since 1.2\n     */\n    public static long mulAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: multiply\";\n        if (a > b) {\n            // use symmetry to reduce boundary cases\n            ret = mulAndCheck(b, a);\n        } else {\n            if (a < 0) {\n                if (b < 0) {\n                    // check for positive overflow with negative a, negative b\n                    if (a >= Long.MAX_VALUE / b) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else if (b > 0) {\n                    // check for negative overflow with negative a, positive b\n                    if (Long.MIN_VALUE / b <= a) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n\n                    }\n                } else {\n                    // assert b == 0\n                    ret = 0;\n                }\n            } else if (a > 0) {\n                // assert a > 0\n                // assert b > 0\n\n                // check for positive overflow with positive a, positive b\n                if (a <= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            } else {\n                // assert a == 0\n                ret = 0;\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Scale a number by 2<sup>scaleFactor</sup>.\n     * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>\n     *\n     * @param d base number\n     * @param scaleFactor power of two by which d sould be multiplied\n     * @return d &times; 2<sup>scaleFactor</sup>\n     * @since 2.0\n     */\n    public static double scalb(final double d, final int scaleFactor) {\n\n        // handling of some important special cases\n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        // split the double in raw components\n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        // shift the exponent\n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }\n\n    /**\n     * Normalize an angle in a 2&pi wide interval around a center value.\n     * <p>This method has three main uses:</p>\n     * <ul>\n     *   <li>normalize an angle between 0 and 2&pi;:<br/>\n     *       <code>a = MathUtils.normalizeAngle(a, FastMath.PI);</code></li>\n     *   <li>normalize an angle between -&pi; and +&pi;<br/>\n     *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>\n     *   <li>compute the angle between two defining angular positions:<br>\n     *       <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>\n     * </ul>\n     * <p>Note that due to numerical accuracy and since &pi; cannot be represented\n     * exactly, the result interval is <em>closed</em>, it cannot be half-closed\n     * as would be more satisfactory in a purely mathematical view.</p>\n     * @param a angle to normalize\n     * @param center center of the desired 2&pi; interval for the result\n     * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;\n     * @since 1.2\n     */\n     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);\n     }\n\n     /**\n      * <p>Normalizes an array to make it sum to a specified value.\n      * Returns the result of the transformation <pre>\n      *    x |-> x * normalizedSum / sum\n      * </pre>\n      * applied to each non-NaN element x of the input array, where sum is the\n      * sum of the non-NaN entries in the input array.</p>\n      *\n      * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite\n      * or NaN and ArithmeticException if the input array contains any infinite elements\n      * or sums to 0</p>\n      *\n      * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>\n      *\n      * @param values input array to be normalized\n      * @param normalizedSum target sum for the normalized array\n      * @return normalized array\n      * @throws ArithmeticException if the input array contains infinite elements or sums to zero\n      * @throws IllegalArgumentException if the target sum is infinite or NaN\n      * @since 2.1\n      */\n     public static double[] normalizeArray(double[] values, double normalizedSum)\n       throws ArithmeticException, IllegalArgumentException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     LocalizedFormats.NORMALIZE_INFINITE);\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     LocalizedFormats.NORMALIZE_NAN);\n         }\n         double sum = 0d;\n         final int len = values.length;\n         double[] out = new double[len];\n         for (int i = 0; i < len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw MathRuntimeException.createArithmeticException(\n                         LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum += values[i];\n             }\n         }\n         if (sum == 0) {\n             throw MathRuntimeException.createArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n         }\n         for (int i = 0; i < len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] = Double.NaN;\n             } else {\n                 out[i] = values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }\n\n    /**\n     * Round the given value to the specified number of decimal places. The\n     * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n     *\n     * @param x the value to round.\n     * @param scale the number of digits to the right of the decimal point.\n     * @return the rounded value.\n     * @since 1.1\n     */\n    public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    /**\n     * Round the given value to the specified number of decimal places. The\n     * value is rounded using the given method which is any method defined in\n     * {@link BigDecimal}.\n     *\n     * @param x the value to round.\n     * @param scale the number of digits to the right of the decimal point.\n     * @param roundingMethod the rounding method as defined in\n     *        {@link BigDecimal}.\n     * @return the rounded value.\n     * @since 1.1\n     */\n    public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;\n            } else {\n                return Double.NaN;\n            }\n        }\n    }\n\n    /**\n     * Round the given value to the specified number of decimal places. The\n     * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.\n     *\n     * @param x the value to round.\n     * @param scale the number of digits to the right of the decimal point.\n     * @return the rounded value.\n     * @since 1.1\n     */\n    public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    /**\n     * Round the given value to the specified number of decimal places. The\n     * value is rounded using the given method which is any method defined in\n     * {@link BigDecimal}.\n     *\n     * @param x the value to round.\n     * @param scale the number of digits to the right of the decimal point.\n     * @param roundingMethod the rounding method as defined in\n     *        {@link BigDecimal}.\n     * @return the rounded value.\n     * @since 1.1\n     */\n    public static float round(float x, int scale, int roundingMethod) {\n        float sign = indicator(x);\n        float factor = (float)FastMath.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }\n\n    /**\n     * Round the given non-negative, value to the \"nearest\" integer. Nearest is\n     * determined by the rounding method specified. Rounding methods are defined\n     * in {@link BigDecimal}.\n     *\n     * @param unscaled the value to round.\n     * @param sign the sign of the original, scaled value.\n     * @param roundingMethod the rounding method as defined in\n     *        {@link BigDecimal}.\n     * @return the rounded value.\n     * @since 1.1\n     */\n    private static double roundUnscaled(double unscaled, double sign,\n        int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign == -1) {\n                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign == -1) {\n                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled = FastMath.floor(FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled = FastMath.nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction = unscaled - FastMath.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = FastMath.ceil(unscaled);\n            } else {\n                unscaled = FastMath.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction = unscaled - FastMath.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = FastMath.ceil(unscaled);\n            } else if (fraction < 0.5) {\n                unscaled = FastMath.floor(unscaled);\n            } else {\n                // The following equality test is intentional and needed for rounding purposes\n                if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(Math\n                    .floor(unscaled) / 2.0)) { // even\n                    unscaled = FastMath.floor(unscaled);\n                } else { // odd\n                    unscaled = FastMath.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled = FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction = unscaled - FastMath.floor(unscaled);\n            if (fraction >= 0.5) {\n                unscaled = FastMath.ceil(unscaled);\n            } else {\n                unscaled = FastMath.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled != FastMath.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw MathRuntimeException.createIllegalArgumentException(\n                  LocalizedFormats.INVALID_ROUNDING_METHOD,\n                  roundingMethod,\n                  \"ROUND_CEILING\",     BigDecimal.ROUND_CEILING,\n                  \"ROUND_DOWN\",        BigDecimal.ROUND_DOWN,\n                  \"ROUND_FLOOR\",       BigDecimal.ROUND_FLOOR,\n                  \"ROUND_HALF_DOWN\",   BigDecimal.ROUND_HALF_DOWN,\n                  \"ROUND_HALF_EVEN\",   BigDecimal.ROUND_HALF_EVEN,\n                  \"ROUND_HALF_UP\",     BigDecimal.ROUND_HALF_UP,\n                  \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n                  \"ROUND_UP\",          BigDecimal.ROUND_UP);\n        }\n        return unscaled;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n     * for byte value <code>x</code>.\n     * <p>\n     * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if\n     * x = 0, and (byte)(-1) if x < 0.</p>\n     *\n     * @param x the value, a byte\n     * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x\n     */\n    public static byte sign(final byte x) {\n        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n     * for double precision <code>x</code>.\n     * <p>\n     * For a double value <code>x</code>, this method returns\n     * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if\n     * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.\n     * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>\n     *\n     * @param x the value, a double\n     * @return +1.0, 0.0, or -1.0, depending on the sign of x\n     */\n    public static double sign(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n     * for float value <code>x</code>.\n     * <p>\n     * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =\n     * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>\n     * is <code>NaN</code>.</p>\n     *\n     * @param x the value, a float\n     * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x\n     */\n    public static float sign(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n     * for int value <code>x</code>.\n     * <p>\n     * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1\n     * if x < 0.</p>\n     *\n     * @param x the value, an int\n     * @return +1, 0, or -1, depending on the sign of x\n     */\n    public static int sign(final int x) {\n        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n     * for long value <code>x</code>.\n     * <p>\n     * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and\n     * -1L if x < 0.</p>\n     *\n     * @param x the value, a long\n     * @return +1L, 0L, or -1L, depending on the sign of x\n     */\n    public static long sign(final long x) {\n        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n     * for short value <code>x</code>.\n     * <p>\n     * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)\n     * if x = 0, and (short)(-1) if x < 0.</p>\n     *\n     * @param x the value, a short\n     * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of\n     *         x\n     */\n    public static short sign(final short x) {\n        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\">\n     * hyperbolic sine</a> of x.\n     *\n     * @param x double value for which to find the hyperbolic sine\n     * @return hyperbolic sine of x\n     */\n    public static double sinh(double x) {\n        return (FastMath.exp(x) - FastMath.exp(-x)) / 2.0;\n    }\n\n    /**\n     * Subtract two integers, checking for overflow.\n     *\n     * @param x the minuend\n     * @param y the subtrahend\n     * @return the difference <code>x-y</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         int\n     * @since 1.1\n     */\n    public static int subAndCheck(int x, int y) {\n        long s = (long)x - (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw MathRuntimeException.createArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n        }\n        return (int)s;\n    }\n\n    /**\n     * Subtract two long integers, checking for overflow.\n     *\n     * @param a first value\n     * @param b second value\n     * @return the difference <code>a-b</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         long\n     * @since 1.2\n     */\n    public static long subAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: subtract\";\n        if (b == Long.MIN_VALUE) {\n            if (a < 0) {\n                ret = a - b;\n            } else {\n                throw new ArithmeticException(msg);\n            }\n        } else {\n            // use additive inverse\n            ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n        }\n        return ret;\n    }\n\n    /**\n     * Raise an int to an int power.\n     * @param k number to raise\n     * @param e exponent (must be positive or null)\n     * @return k<sup>e</sup>\n     * @exception IllegalArgumentException if e is negative\n     */\n    public static int pow(final int k, int e)\n        throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                k, e);\n        }\n\n        int result = 1;\n        int k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Raise an int to a long power.\n     * @param k number to raise\n     * @param e exponent (must be positive or null)\n     * @return k<sup>e</sup>\n     * @exception IllegalArgumentException if e is negative\n     */\n    public static int pow(final int k, long e)\n        throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                k, e);\n        }\n\n        int result = 1;\n        int k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Raise a long to an int power.\n     * @param k number to raise\n     * @param e exponent (must be positive or null)\n     * @return k<sup>e</sup>\n     * @exception IllegalArgumentException if e is negative\n     */\n    public static long pow(final long k, int e)\n        throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                k, e);\n        }\n\n        long result = 1l;\n        long k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Raise a long to a long power.\n     * @param k number to raise\n     * @param e exponent (must be positive or null)\n     * @return k<sup>e</sup>\n     * @exception IllegalArgumentException if e is negative\n     */\n    public static long pow(final long k, long e)\n        throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                k, e);\n        }\n\n        long result = 1l;\n        long k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result *= k2p;\n            }\n            k2p *= k2p;\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Raise a BigInteger to an int power.\n     * @param k number to raise\n     * @param e exponent (must be positive or null)\n     * @return k<sup>e</sup>\n     * @exception IllegalArgumentException if e is negative\n     */\n    public static BigInteger pow(final BigInteger k, int e)\n        throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                k, e);\n        }\n\n        return k.pow(e);\n\n    }\n\n    /**\n     * Raise a BigInteger to a long power.\n     * @param k number to raise\n     * @param e exponent (must be positive or null)\n     * @return k<sup>e</sup>\n     * @exception IllegalArgumentException if e is negative\n     */\n    public static BigInteger pow(final BigInteger k, long e)\n        throws IllegalArgumentException {\n\n        if (e < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                k, e);\n        }\n\n        BigInteger result = BigInteger.ONE;\n        BigInteger k2p    = k;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                result = result.multiply(k2p);\n            }\n            k2p = k2p.multiply(k2p);\n            e = e >> 1;\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Raise a BigInteger to a BigInteger power.\n     * @param k number to raise\n     * @param e exponent (must be positive or null)\n     * @return k<sup>e</sup>\n     * @exception IllegalArgumentException if e is negative\n     */\n    public static BigInteger pow(final BigInteger k, BigInteger e)\n        throws IllegalArgumentException {\n\n        if (e.compareTo(BigInteger.ZERO) < 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.POWER_NEGATIVE_PARAMETERS,\n                k, e);\n        }\n\n        BigInteger result = BigInteger.ONE;\n        BigInteger k2p    = k;\n        while (!BigInteger.ZERO.equals(e)) {\n            if (e.testBit(0)) {\n                result = result.multiply(k2p);\n            }\n            k2p = k2p.multiply(k2p);\n            e = e.shiftRight(1);\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>1</sub> distance between the two points\n     */\n    public static double distance1(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += FastMath.abs(p1[i] - p2[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>1</sub> distance between the two points\n     */\n    public static int distance1(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          sum += FastMath.abs(p1[i] - p2[i]);\n      }\n      return sum;\n    }\n\n    /**\n     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>2</sub> distance between the two points\n     */\n    public static double distance(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            final double dp = p1[i] - p2[i];\n            sum += dp * dp;\n        }\n        return FastMath.sqrt(sum);\n    }\n\n    /**\n     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>2</sub> distance between the two points\n     */\n    public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return FastMath.sqrt(sum);\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static int distanceInf(int[] p1, int[] p2) {\n        int max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    /**\n     * Specification of ordering direction.\n     */\n    public static enum OrderDirection {\n        /** Constant for increasing direction. */\n        INCREASING,\n        /** Constant for decreasing direction. */\n        DECREASING\n    }\n\n    /**\n     * Checks that the given array is sorted.\n     *\n     * @param val Values.\n     * @param dir Ordering direction.\n     * @param strict Whether the order should be strict.\n     * @throws NonMonotonousSequenceException if the array is not sorted.\n     */\n    public static void checkOrder(double[] val, OrderDirection dir, boolean strict) {\n        double previous = val[0];\n        boolean ok = true;\n\n        int max = val.length;\n        for (int i = 1; i < max; i++) {\n            switch (dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[i] <= previous) {\n                        ok = false;\n                    }\n                } else {\n                    if (val[i] < previous) {\n                        ok = false;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[i] >= previous) {\n                        ok = false;\n                    }\n                } else {\n                    if (val[i] > previous) {\n                        ok = false;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new IllegalArgumentException();\n            }\n\n            if (!ok) {\n                throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);\n            }\n            previous = val[i];\n        }\n    }\n\n    /**\n     * Checks that the given array is sorted in strictly increasing order.\n     *\n     * @param val Values.\n     * @throws NonMonotonousSequenceException if the array is not sorted.\n     */\n    public static void checkOrder(double[] val) {\n        checkOrder(val, OrderDirection.INCREASING, true);\n    }\n\n    /**\n     * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\n     * Translation of the minpack enorm subroutine.\n     *\n     * The redistribution policy for MINPACK is available <a\n     * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for convenience, it\n     * is reproduced below.</p>\n     *\n     * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n     * <tr><td>\n     *    Minpack Copyright Notice (1999) University of Chicago.\n     *    All rights reserved\n     * </td></tr>\n     * <tr><td>\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions\n     * are met:\n     * <ol>\n     *  <li>Redistributions of source code must retain the above copyright\n     *      notice, this list of conditions and the following disclaimer.</li>\n     * <li>Redistributions in binary form must reproduce the above\n     *     copyright notice, this list of conditions and the following\n     *     disclaimer in the documentation and/or other materials provided\n     *     with the distribution.</li>\n     * <li>The end-user documentation included with the redistribution, if any,\n     *     must include the following acknowledgment:\n     *     <code>This product includes software developed by the University of\n     *           Chicago, as Operator of Argonne National Laboratory.</code>\n     *     Alternately, this acknowledgment may appear in the software itself,\n     *     if and wherever such third-party acknowledgments normally appear.</li>\n     * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n     *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n     *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n     *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n     *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n     *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n     *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n     *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n     *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n     *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n     *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n     *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n     *     BE CORRECTED.</strong></li>\n     * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n     *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n     *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n     *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n     *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n     *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n     *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n     *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n     *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n     *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n     * <ol></td></tr>\n     * </table>\n     *\n     * @param v vector of doubles\n     * @return the 2-norm of the vector\n     */\n    public static double safeNorm(double[] v) {\n    double rdwarf = 3.834e-20;\n    double rgiant = 1.304e+19;\n    double s1=0.0;\n    double s2=0.0;\n    double s3=0.0;\n    double x1max = 0.0;\n    double x3max = 0.0;\n    double floatn = (double)v.length;\n    double agiant = rgiant/floatn;\n    for (int i=0;i<v.length;i++) {\n        double xabs = Math.abs(v[i]);\n        if (xabs<rdwarf || xabs>agiant) {\n            if (xabs>rdwarf) {\n                if (xabs>x1max) {\n                    double r=x1max/xabs;\n                    s1=1.0+s1*r*r;\n                    x1max=xabs;\n                } else {\n                    double r=xabs/x1max;\n                    s1+=r*r;\n                }\n            } else {\n                if (xabs>x3max) {\n                 double r=x3max/xabs;\n                 s3=1.0+s3*r*r;\n                 x3max=xabs;\n                } else {\n                    if (xabs!=0.0) {\n                        double r=xabs/x3max;\n                        s3+=r*r;\n                    }\n                }\n            }\n        } else {\n         s2+=xabs*xabs;\n        }\n    }\n    double norm;\n    if (s1!=0.0) {\n        norm = x1max*Math.sqrt(s1+(s2/x1max)/x1max);\n    } else {\n        if (s2==0.0) {\n            norm = x3max*Math.sqrt(s3);\n        } else {\n            if (s2>=x3max) {\n                norm = Math.sqrt(s2*(1.0+(x3max/s2)*(x3max*s3)));\n            } else {\n                norm = Math.sqrt(x3max*((s2/x3max)+(x3max*s3)));\n            }\n        }\n    }\n    return norm;\n}\n\n}\n", "review": {"response": "<think>\nOkay, let's take a look at this Java code. The user wants me to review it for bugs and return a JSON list of bugs. The code is from the Apache Commons Math library's MathUtils class. Hmm, I need to go through each method and check for possible issues.\n\nFirst, I'll start with the public methods. The addAndCheck methods for int and long. Let's see the int version. It casts both x and y to long, adds them, then checks if the sum is within Integer min and max. If not, throws an exception. That seems correct. The long version calls a private method. The private addAndCheck for longs has some logic. It uses symmetry by swapping a and b if a > b. Then checks for negative or positive overflow.\n\nWait, in the private addAndCheck method, when a > b, it calls the same method again with b and a. But what if b is larger than a? Let's see. Suppose a is 5 and b is 10. Then it swaps them, so the method is called with b=5 and a=10. But since the method is private and called from the public method, maybe this is okay. The idea is to reduce the number of cases by ensuring a <= b. That seems logical.\n\nNow, the case when a < 0. If both a and b are negative, they check if a is greater than or equal to Long.MIN_VALUE - b. Wait, the condition is if (Long.MIN_VALUE - b <= a). Let's think. Adding two negative numbers can overflow to a positive number. For example, adding two large negative numbers. How does the check work here? Let me take an example. Suppose a = Long.MIN_VALUE + 1 and b = -1. Then Long.MIN_VALUE - b is Long.MIN_VALUE + 1. So if a is -9223372036854775807 (Long.MIN_VALUE is -9223372036854775808), then adding with b=-1 would be -9223372036854775807 + (-1) = -9223372036854775808, which is Long.MIN_VALUE. But if a is smaller than Long.MIN_VALUE - b, which would be Long.MIN_VALUE - (-1) = -9223372036854775808 +1 = -9223372036854775807. So if a is <= that, then adding would not overflow. Wait, maybe I need to think about the condition again.\n\nThe condition for negative overflow is when adding two negative numbers results in a value less than Long.MIN_VALUE. But since Long.MIN_VALUE is the smallest possible value, adding two negative numbers can't be less than that. Wait, but adding two numbers can't go below Long.MIN_VALUE. So the only possible overflow is when the sum is larger than Long.MAX_VALUE or smaller than Long.MIN_VALUE. For two negative numbers, their sum can't be larger than Long.MAX_VALUE. So the only possible overflow is when the sum is smaller than Long.MIN_VALUE. But how?\n\nLet me think: For example, adding two Long.MIN_VALUE / 2 (but negative). Wait, Long.MIN_VALUE is -2^63, which is not symmetric with Long.MAX_VALUE (2^63 - 1). So adding two numbers like -2^62 each would sum to -2^63, which is Long.MIN_VALUE. That's okay. But if you add two numbers that are smaller than that, like adding -2^63 - 1 and -1, but Long.MIN_VALUE is the smallest, so you can't have numbers smaller than that. So for two negative numbers, the sum can't be less than Long.MIN_VALUE. Wait, that's right. Because the most negative number is Long.MIN_VALUE. So adding two negative numbers can't go below that. Therefore, the only possible overflow when adding two negative numbers is if the sum is greater than Long.MAX_VALUE? No, because adding two negative numbers would give a more negative number. So the sum is less than or equal to either of the addends. So the sum can't overflow upwards. The only possible overflow is if the sum is less than Long.MIN_VALUE, but that's impossible. Therefore, the code's check for negative overflow might be incorrect.\n\nWait, the code for the case where a and b are both negative is:\n\nif (Long.MIN_VALUE - b <= a) {\n    ret = a + b;\n} else {\n    throw ...\n}\n\nBut if a and b are both negative, adding them can't be less than Long.MIN_VALUE. So the check here is perhaps trying to prevent overflow when the sum is greater than Long.MAX_VALUE? But that's impossible because adding two negative numbers gives a negative number, which is less than or equal to Long.MAX_VALUE (since Long.MAX_VALUE is positive). Therefore, this check is unnecessary. Wait, but maybe the code is trying to handle the case where adding two negative numbers results in a positive number. Wait, no, that's impossible. Adding two negative numbers can't be positive. So the only possible overflow in adding two negative numbers is when their sum is less than Long.MIN_VALUE, which is impossible. Therefore, the code here is incorrect. The check for negative overflow is not needed. But how?\n\nWait, maybe the code is trying to handle the case where adding two negative numbers overflows to a positive value. For example, adding -Long.MAX_VALUE and -Long.MAX_VALUE. Let's compute that. Long.MAX_VALUE is 2^63 - 1. So -Long.MAX_VALUE is -9223372036854775807. Adding two of them gives -18446744073709551614. But Long.MIN_VALUE is -9223372036854775808. So the sum is -18446744073709551614, which is less than Long.MIN_VALUE. But since Long can't hold that value, adding them would result in an overflow. Wait, but in Java, adding two negative numbers can overflow to a positive value. For example, adding Integer.MIN_VALUE twice would result in zero (for int). So in that case, the code should check for overflow when adding two negative numbers.\n\nWait, in Java, adding two negative numbers can overflow to a positive number. For example:\n\nint a = Integer.MIN_VALUE;\nint b = Integer.MIN_VALUE;\nint sum = a + b; // This would be 0, which is positive. So the code should detect that as an overflow.\n\nBut in the code for the long case, when a and b are both negative, the code is checking if Long.MIN_VALUE - b <= a. Let's see what that means. Let's take a and b as two negative numbers. For example, a = -x, b = -y, where x and y are positive. Then the sum is -x + (-y) = -(x + y). The sum would be a negative number. But if x + y exceeds 2^63, then the sum would be a negative number that can't be represented as a long. Wait, but long can represent any sum of two negative numbers as long as their absolute values don't sum to more than 2^63. Because the minimum long is -2^63. So if x + y > 2^63, then -(x + y) < -2^63, which is not representable as a long. So adding two negative numbers can overflow to a value that's less than Long.MIN_VALUE, which is impossible. Therefore, that scenario can't happen. Wait, but how can x + y exceed 2^63? Because each of a and b are negative. Let's take a = Long.MIN_VALUE, which is -2^63. Adding another negative number would require that the sum is less than Long.MIN_VALUE, which is impossible. So the only possible overflow when adding two negative numbers is when the sum is greater than Long.MAX_VALUE, which is impossible because the sum is negative. Therefore, there's no possible overflow when adding two negative numbers. Therefore, the code's check for negative overflow is incorrect and unnecessary. The code is trying to prevent a case that can't happen. Therefore, the code is wrong here.\n\nWait, but in Java, adding two negative numbers can overflow to a positive number. For example, in int:\n\nint a = Integer.MIN_VALUE;\nint b = -1;\nint sum = a + b; // sum is Integer.MAX_VALUE?\n\nWait, let me compute. Integer.MIN_VALUE is -2^31. Adding -1 would be -2^31 -1. But that's less than Integer.MIN_VALUE, which is impossible. So in Java, adding two negative numbers can't overflow to a positive number. Wait, but in Java, adding two negative numbers can overflow to a positive number if the sum overflows. For example, adding -1 and -1 gives -2, which is correct. But adding Integer.MIN_VALUE and -1 would be -2147483648 -1 = -2147483649, which is less than Integer.MIN_VALUE. But since int is 32 bits, it wraps around. So in Java, the addition would actually result in Integer.MAX_VALUE. Wait, no. Let me check. Let's compute:\n\nInteger.MIN_VALUE is -2147483648. Adding -1 would be -2147483648 -1 = -2147483649. Since int is 32 bits, this wraps around. The binary representation of Integer.MIN_VALUE is 10000000 00000000 00000000 00000000. Adding -1 (which is 11111111 11111111 11111111 11111111 in two's complement) would result in:\n\nBut adding two negative numbers in two's complement would result in a correct sum if there's no overflow. However, if the sum overflows, the result would be positive. For example, adding -2147483648 and -1 would cause an overflow because the sum is less than Integer.MIN_VALUE. In Java, this would result in a positive number. For example, adding -2147483648 and -1 would be -2147483649, which wraps to 2147483647 (Integer.MAX_VALUE). So in Java, adding two negative numbers can result in a positive number if the sum overflows. Therefore, the code's check for negative overflow is necessary to detect this scenario.\n\nBut how does the code's condition work? The code checks if Long.MIN_VALUE - b <= a. Let me take an example where adding two negative numbers would overflow. Let's take a = Long.MIN_VALUE and b = -1. Then Long.MIN_VALUE - b is Long.MIN_VALUE - (-1) = Long.MIN_VALUE + 1. Since Long.MIN_VALUE is -9223372036854775808, adding 1 gives -9223372036854775807. Now, a is Long.MIN_VALUE (-9223372036854775808), which is less than -9223372036854775807. So the condition (Long.MIN_VALUE - b <= a) would be (-9223372036854775807 <= -9223372036854775808)? No, because -9223372036854775807 is greater than -9223372036854775808. So the condition is false. Therefore, the code would throw an exception. Which is correct, because adding Long.MIN_VALUE and -1 would overflow. But wait, in reality, adding them would result in a value that is less than Long.MIN_VALUE, which can't be represented. But Java's addition would wrap around to a positive number. Therefore, the code's check here is correct in detecting that the addition would overflow.\n\nSo the code's logic for the negative case is correct. The condition (Long.MIN_VALUE - b <= a) is equivalent to checking if adding a and b would not underflow. But how?\n\nLet me think algebraically. For two negative numbers a and b (both <= 0), we want to check if their sum a + b >= Long.MIN_VALUE. Because if their sum is >= Long.MIN_VALUE, adding them is safe. Otherwise, it would underflow. But since a and b are negative, their sum is also negative. So the sum can't be less than Long.MIN_VALUE. Wait, but earlier example with a = Long.MIN_VALUE and b = -1 would have sum = Long.MIN_VALUE + (-1) = -9223372036854775808 -1 = -9223372036854775809, which is less than Long.MIN_VALUE. But Long.MIN_VALUE is the smallest possible value. So how can this be?\n\nAh, here's the problem. Long.MIN_VALUE is -2^63. Adding two numbers that are both negative can result in a sum that is less than Long.MIN_VALUE, but since Long.MIN_VALUE is the minimum, that's not possible. However, in Java, when you add two numbers that underflow, the result wraps around. For example, adding Long.MIN_VALUE and -1 would result in Long.MAX_VALUE. Wait, no. Let me compute:\n\nLong.MIN_VALUE is -9223372036854775808.\n\nAdding -1 would be -9223372036854775808 -1 = -9223372036854775809. But since this is beyond the minimum, in Java, the result would be Long.MAX_VALUE + 1 - 1? No, I think it wraps around. Let me check in Java:\n\npublic class Test {\n    public static void main(String[] args) {\n        long a = Long.MIN_VALUE;\n        long b = -1;\n        long sum = a + b;\n        System.out.println(sum); // What is this?\n    }\n}\n\nIn Java, adding Long.MIN_VALUE and -1 would result in a value that is one less than Long.MIN_VALUE, which is not representable. So the actual result would be Long.MAX_VALUE + 1 - 1? Wait, no. Let's see. The binary representation of Long.MIN_VALUE is 10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000. Adding -1 (which is all 1s in two's complement) would result in:\n\nBut adding 1000...0000 (Long.MIN_VALUE) and 1111...1111 (which is -1) would result in 0111...1111, which is Long.MAX_VALUE. So the sum would be Long.MAX_VALUE. Which is positive. So the code's check is correct in throwing an exception here because the actual sum in Java would be positive (overflow), but the mathematical sum is less than Long.MIN_VALUE, which is not representable. Therefore, the code's check is correct.\n\nSo the condition (Long.MIN_VALUE - b <= a) is equivalent to checking if a >= (Long.MIN_VALUE - b). Let me rearrange this:\n\nLong.MIN_VALUE - b <= a\n=> a + b >= Long.MIN_VALUE\n\nWhich is the condition we want. Because if a + b >= Long.MIN_VALUE, then adding them is safe. Otherwise, it would underflow and wrap around. So the code's check is correct.\n\nAnother example: a = -5, b = -6. Long.MIN_VALUE is -9223372036854775808. Long.MIN_VALUE - b is -9223372036854775808 - (-6) = -9223372036854775802. a is -5, which is greater than -9223372036854775802. So the condition is true, so adding them is safe. The sum is -11, which is correct.\n\nAnother example where adding two negative numbers would underflow. Let's say a = Long.MIN_VALUE and b = -1. Then Long.MIN_VALUE - b = -9223372036854775808 - (-1) = -9223372036854775807. a is -9223372036854775808, which is less than -9223372036854775807. So the condition is false, so the code throws an exception. Which is correct because the sum would underflow.\n\nSo the code's logic here is correct.\n\nNow, looking at the positive case. The code checks if a <= Long.MAX_VALUE - b. Which is equivalent to a + b <= Long.MAX_VALUE. That's correct. So adding them is safe.\n\nSo the addAndCheck methods seem correct.\n\nNow, looking at the binomialCoefficient method. Wait, the code provided is cut off. The user's code ends with the start of the binomialCoefficient method. The code provided is:\n\n/**\n     * Returns an exact representation of the <a\n     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n     * <code>k</code>-element subsets that can be selected from an\n     * <code>n</code>-element set.\n     * <p>\n     * <Stron```\n\nSo the binomialCoefficient method is not fully provided. Therefore, I can't check for bugs in that method. However, perhaps there are other methods in the provided code that I can check.\n\nLooking at the other methods, there's also the multiplyAndCheck method, but it's not in the provided code. The user's code includes addAndCheck and the constructor. The rest of the code includes constants and the addAndCheck methods.\n\nAnother thing to check: the public addAndCheck for long calls the private addAndCheck with the same parameters. The private method uses recursion when a > b. But in the case where a and b are both very large positive numbers, adding them would cause overflow. The code seems to handle that.\n\nAnother potential issue: in the private addAndCheck method, when a <= b, and a is negative, but b is positive. For example, a = -5, b = 10. Then since a is negative and b is positive, the code adds them directly. But adding a negative and a positive can't overflow, because the result is between -Long.MAX_VALUE and Long.MAX_VALUE. So the code is correct in not checking for overflow here.\n\nAnother case: a is positive, b is positive. The code checks if a <= Long.MAX_VALUE - b. Which is correct. For example, if a is 5 and b is 10, Long.MAX_VALUE - b is a very large number, so the condition is true, and the sum is 15.\n\nWhat if a is Long.MAX_VALUE and b is 1? Then Long.MAX_VALUE - 1 is Long.MAX_VALUE - 1, and a is Long.MAX_VALUE which is larger than that. So the code would throw an exception. Which is correct because Long.MAX_VALUE + 1 would overflow.\n\nSo the code seems correct.\n\nAnother thing to check: the exception message in the addAndCheck methods. For example, in the int addAndCheck method, it throws an exception with the message \"OVERFLOW_IN_ADDITION\" and parameters x and y. The same for the long methods. That's correct.\n\nAnother possible issue: the code uses MathRuntimeException.createArithmeticException with the pattern and parameters. But if the parameters are not in the correct order or type, that could be a problem. However, the code passes x and y as parameters, which are the addends. Assuming the LocalizedFormats.OVERFLOW_IN_ADDITION is correctly formatted to accept two numbers, that's okay.\n\nAnother thing: the code for the long addAndCheck method is called recursively when a > b. But since the method is private and called from the public method, which passes a and b in any order, the recursion could lead to stack overflow if there's an infinite loop. But since the code swaps a and b when a > b, and in the swapped case, the code proceeds with b and a. But since in the first call, if a > b, it swaps and calls the method again. Then, in the next call, a is the smaller one. So the code should not recurse more than once. For example, if a is 5 and b is 3, the code swaps them to 3 and 5, then proceeds. Since in the next call, a is 3 and b is 5, and since a <= b, it proceeds. So no infinite recursion. Therefore, the recursion is safe.\n\nNow, looking at the constants. The FACTORIALS array has entries up to 20! (since 20! is 2432902008176640000). The code may use this array in other methods, but since those methods are not provided, I can't check for bugs there.\n\nAnother thing to check: the code uses FastMath.PI. Is FastMath a valid class in the Apache Commons Math library? Yes, it's part of the library. So that's correct.\n\nNow, looking for possible bugs in the provided code. The code seems correct in the addAndCheck methods. Are there any other issues?\n\nWait, in the private addAndCheck method, when a <= b and a is negative, but b is positive, the code returns a + b directly. But in Java, adding a negative and a positive number can't overflow. Because the result is between -Long.MAX_VALUE and Long.MAX_VALUE. For example, adding -Long.MAX_VALUE and Long.MAX_VALUE gives 0. Adding -Long.MAX_VALUE and 1 gives -Long.MAX_VALUE +1, which is within the range. So the code is correct in not checking for overflow in this case.\n\nAnother possible issue: the code uses the pattern parameter in the private method. For example, when a is negative and b is positive, the code doesn't check for overflow, but if somehow there was an overflow (which is impossible), it would not throw an exception. But since it's impossible, the code is correct.\n\nAnother thing: in the private addAndCheck method, the code has a return ret; after the if-else blocks. But in all code paths, ret is assigned. So no issues there.\n\nAnother possible issue: the code uses Integer.MIN_VALUE and Integer.MAX_VALUE for the int addAndCheck method, which is correct.\n\nNow, considering all the above, the code for the addAndCheck methods seems correct. Are there any other bugs?\n\nLooking at the code for the addAndCheck methods, perhaps there's an issue with the order of parameters in the exception message. For example, in the int addAndCheck method, it throws an exception with x and y. But if the method is called with x=5 and y=10, the message would say \"Overflow in addition: 5 and 10\". Which is correct. Similarly for the long method.\n\nAnother possible issue: the code in the long addAndCheck method uses the pattern parameter, which is passed from the public method. The public method passes LocalizedFormats.OVERFLOW_IN_ADDITION. That's correct.\n\nSo, after reviewing the provided code, I don't see any bugs in the addAndCheck methods. However, there's the binomialCoefficient method which is cut off. If that method has bugs, they can't be detected here. Also, other methods in the class (like multiplyAndCheck, which is not shown) could have bugs, but they are not part of the provided code.\n\nTherefore, the JSON response should indicate that there are no bugs found in the provided code. However, since the user might have expected some issues, perhaps I missed something. Let me double-check.\n\nWait, in the private addAndCheck method, when a <= b and a is negative, and b is positive, the code returns a + b. But in Java, adding a negative and a positive number can't overflow. So that's correct. Another case: when a is positive and b is positive. The code checks if a <= Long.MAX_VALUE - b. Which is the correct condition to prevent overflow.\n\nAnother possible edge case: when a is Long.MAX_VALUE and b is 0. Then Long.MAX_VALUE - 0 is Long.MAX_VALUE. So a <= Long.MAX_VALUE - b is true. Adding them gives Long.MAX_VALUE, which is correct.\n\nAnother case: a is Long.MAX_VALUE - 1 and b is 1. Then Long.MAX_VALUE - b is Long.MAX_VALUE - 1. So a is equal to that, so the condition is true. Sum is Long.MAX_VALUE, correct.\n\nAnother case: a is Long.MAX_VALUE and b is 1. Then Long.MAX_VALUE - b is Long.MAX_VALUE -1. a is Long.MAX_VALUE, which is larger than that. So the code throws an exception. Correct.\n\nThus, the code seems correct. Therefore, the answer is that there are no bugs in the provided code.\n</think>\n\n```json\n{\n  \"bugs\": []\n}\n```"}}