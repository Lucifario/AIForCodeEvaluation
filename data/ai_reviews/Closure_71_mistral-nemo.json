{"sample_id": "Closure_71", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.JSDocInfo.Visibility;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.rhino.jstype.FunctionPrototypeType;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport com.google.javascript.rhino.jstype.ObjectType;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.HashMultimap;\n\n/**\n * A compiler pass that checks that the programmer has obeyed all the access\n * control restrictions indicated by JSDoc annotations, like\n * {@code @private} and {@code @deprecated}.\n *\n * Because access control restrictions are attached to type information,\n * it's important that TypedScopeCreator, TypeInference, and InferJSDocInfo\n * all run before this pass. TypedScopeCreator creates and resolves types,\n * TypeInference propagates those types across the AST, and InferJSDocInfo\n * propagates JSDoc across the types.\n *\n * @author nicksantos@google.com (Nick Santos)\n */\nclass CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n\n  static final DiagnosticType DEPRECATED_NAME = DiagnosticType.disabled(\n      \"JSC_DEPRECATED_VAR\",\n      \"Variable {0} has been deprecated.\");\n\n  static final DiagnosticType DEPRECATED_NAME_REASON = DiagnosticType.disabled(\n      \"JSC_DEPRECATED_VAR_REASON\",\n      \"Variable {0} has been deprecated: {1}\");\n\n  static final DiagnosticType DEPRECATED_PROP = DiagnosticType.disabled(\n      \"JSC_DEPRECATED_PROP\",\n      \"Property {0} of type {1} has been deprecated.\");\n\n  static final DiagnosticType DEPRECATED_PROP_REASON = DiagnosticType.disabled(\n      \"JSC_DEPRECATED_PROP_REASON\",\n      \"Property {0} of type {1} has been deprecated: {2}\");\n\n  static final DiagnosticType DEPRECATED_CLASS = DiagnosticType.disabled(\n      \"JSC_DEPRECATED_CLASS\",\n      \"Class {0} has been deprecated.\");\n\n  static final DiagnosticType DEPRECATED_CLASS_REASON = DiagnosticType.disabled(\n      \"JSC_DEPRECATED_CLASS_REASON\",\n      \"Class {0} has been deprecated: {1}\");\n\n  static final DiagnosticType BAD_PRIVATE_GLOBAL_ACCESS =\n      DiagnosticType.disabled(\n          \"JSC_BAD_PRIVATE_GLOBAL_ACCESS\",\n          \"Access to private variable {0} not allowed outside file {1}.\");\n\n  static final DiagnosticType BAD_PRIVATE_PROPERTY_ACCESS =\n      DiagnosticType.disabled(\n          \"JSC_BAD_PRIVATE_PROPERTY_ACCESS\",\n          \"Access to private property {0} of {1} not allowed here.\");\n\n  static final DiagnosticType BAD_PROTECTED_PROPERTY_ACCESS =\n      DiagnosticType.disabled(\n          \"JSC_BAD_PROTECTED_PROPERTY_ACCESS\",\n          \"Access to protected property {0} of {1} not allowed here.\");\n\n  static final DiagnosticType PRIVATE_OVERRIDE =\n      DiagnosticType.disabled(\n          \"JSC_PRIVATE_OVERRIDE\",\n          \"Overriding private property of {0}.\");\n\n  static final DiagnosticType VISIBILITY_MISMATCH =\n      DiagnosticType.disabled(\n          \"JSC_VISIBILITY_MISMATCH\",\n          \"Overriding {0} property of {1} with {2} property.\");\n\n  static final DiagnosticType CONST_PROPERTY_REASSIGNED_VALUE =\n      DiagnosticType.warning(\n        \"JSC_CONSTANT_PROPERTY_REASSIGNED_VALUE\",\n        \"constant property {0} assigned a value more than once\");\n\n  private final AbstractCompiler compiler;\n  private final TypeValidator validator;\n\n  // State about the current traversal.\n  private int deprecatedDepth = 0;\n  private int methodDepth = 0;\n  private JSType currentClass = null;\n\n  private final Multimap<String, String> initializedConstantProperties;\n\n  CheckAccessControls(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.initializedConstantProperties = HashMultimap.create();\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }\n\n  @Override\n  public void hotSwapScript(Node scriptRoot) {\n    NodeTraversal.traverse(compiler, scriptRoot, this);\n  }\n\n  public void enterScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      Node n = t.getScopeRoot();\n      Node parent = n.getParent();\n      if (isDeprecatedFunction(n, parent)) {\n        deprecatedDepth++;\n      }\n\n      if (methodDepth == 0) {\n        currentClass = getClassOfMethod(n, parent);\n      }\n      methodDepth++;\n    }\n  }\n\n  public void exitScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      Node n = t.getScopeRoot();\n      Node parent = n.getParent();\n      if (isDeprecatedFunction(n, parent)) {\n        deprecatedDepth--;\n      }\n\n      methodDepth--;\n      if (methodDepth == 0) {\n        currentClass = null;\n      }\n    }\n  }\n\n  /**\n   * Gets the type of the class that \"owns\" a method, or null if\n   * we know that its un-owned.\n   */\n  private JSType getClassOfMethod(Node n, Node parent) {\n    if (parent.getType() == Token.ASSIGN) {\n      Node lValue = parent.getFirstChild();\n      if (lValue.isQualifiedName()) {\n        if (lValue.getType() == Token.GETPROP) {\n          // We have an assignment of the form \"a.b = ...\".\n          JSType lValueType = lValue.getJSType();\n          if (lValueType != null && lValueType.isConstructor()) {\n            // If a.b is a constructor, then everything in this function\n            // belongs to the \"a.b\" type.\n            return ((FunctionType) lValueType).getInstanceType();\n          } else {\n            // If a.b is not a constructor, then treat this as a method\n            // of whatever type is on \"a\".\n            return normalizeClassType(lValue.getFirstChild().getJSType());\n          }\n        } else {\n          // We have an assignment of the form \"a = ...\", so pull the\n          // type off the \"a\".\n          return normalizeClassType(lValue.getJSType());\n        }\n      }\n    } else if (NodeUtil.isFunctionDeclaration(n) ||\n               parent.getType() == Token.NAME) {\n      return normalizeClassType(n.getJSType());\n    }\n\n    return null;\n  }\n\n  /**\n   * Normalize the type of a constructor, its instance, and its prototype\n   * all down to the same type (the instance type).\n   */\n  private JSType normalizeClassType(JSType type) {\n    if (type == null || type.isUnknownType()) {\n      return type;\n    } else if (type.isConstructor()) {\n      return ((FunctionType) type).getInstanceType();\n    } else if (type.isFunctionPrototypeType()) {\n      FunctionType owner = ((FunctionPrototypeType) type).getOwnerFunction();\n      if (owner.isConstructor()) {\n        return owner.getInstanceType();\n      }\n    }\n    return type;\n  }\n\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    return true;\n  }\n\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        checkNameDeprecation(t, n, parent);\n        checkNameVisibility(t, n, parent);\n        break;\n      case Token.GETPROP:\n        checkPropertyDeprecation(t, n, parent);\n        checkPropertyVisibility(t, n, parent);\n        checkConstantProperty(t, n);\n        break;\n      case Token.NEW:\n        checkConstructorDeprecation(t, n, parent);\n        break;\n    }\n  }\n\n  /**\n   * Checks the given NEW node to ensure that access restrictions are obeyed.\n   */\n  private void checkConstructorDeprecation(NodeTraversal t, Node n,\n      Node parent) {\n    JSType type = n.getJSType();\n\n    if (type != null) {\n      String deprecationInfo = getTypeDeprecationInfo(type);\n\n      if (deprecationInfo != null &&\n          shouldEmitDeprecationWarning(t, n, parent)) {\n\n        if (!deprecationInfo.isEmpty()) {\n            compiler.report(\n                t.makeError(n, DEPRECATED_CLASS_REASON,\n                    type.toString(), deprecationInfo));\n        } else {\n          compiler.report(\n              t.makeError(n, DEPRECATED_CLASS, type.toString()));\n        }\n      }\n    }\n  }\n\n  /**\n   * Checks the given NAME node to ensure that access restrictions are obeyed.\n   */\n  private void checkNameDeprecation(NodeTraversal t, Node n, Node parent) {\n    // Don't bother checking definitions or constructors.\n    if (parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR ||\n        parent.getType() == Token.NEW) {\n      return;\n    }\n\n    Scope.Var var = t.getScope().getVar(n.getString());\n    JSDocInfo docInfo = var == null ? null : var.getJSDocInfo();\n\n    if (docInfo != null && docInfo.isDeprecated() &&\n        shouldEmitDeprecationWarning(t, n, parent)) {\n\n      if (docInfo.getDeprecationReason() != null) {\n        compiler.report(\n            t.makeError(n, DEPRECATED_NAME_REASON, n.getString(),\n                docInfo.getDeprecationReason()));\n      } else {\n        compiler.report(\n            t.makeError(n, DEPRECATED_NAME, n.getString()));\n      }\n    }\n  }\n\n  /**\n   * Checks the given GETPROP node to ensure that access restrictions are\n   * obeyed.\n   */\n  private void checkPropertyDeprecation(NodeTraversal t, Node n, Node parent) {\n    // Don't bother checking constructors.\n    if (parent.getType() == Token.NEW) {\n      return;\n    }\n\n    ObjectType objectType =\n        ObjectType.cast(dereference(n.getFirstChild().getJSType()));\n    String propertyName = n.getLastChild().getString();\n\n    if (objectType != null) {\n      String deprecationInfo\n          = getPropertyDeprecationInfo(objectType, propertyName);\n\n      if (deprecationInfo != null &&\n          shouldEmitDeprecationWarning(t, n, parent)) {\n\n        if (!deprecationInfo.isEmpty()) {\n          compiler.report(\n              t.makeError(n, DEPRECATED_PROP_REASON, propertyName,\n                  validator.getReadableJSTypeName(n.getFirstChild(), true),\n                  deprecationInfo));\n        } else {\n          compiler.report(\n              t.makeError(n, DEPRECATED_PROP, propertyName,\n                  validator.getReadableJSTypeName(n.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n\n  /**\n   * Determines whether the given name is visible in the current context.\n   * @param t The current traversal.\n   * @param name The name node.\n   */\n  private void checkNameVisibility(NodeTraversal t, Node name, Node parent) {\n    Var var = t.getScope().getVar(name.getString());\n    if (var != null) {\n      JSDocInfo docInfo = var.getJSDocInfo();\n      if (docInfo != null) {\n        // If a name is private, make sure that we're in the same file.\n        Visibility visibility = docInfo.getVisibility();\n        if (visibility == Visibility.PRIVATE &&\n            !t.getInput().getName().equals(docInfo.getSourceName())) {\n          if (docInfo.isConstructor() &&\n              isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n\n          compiler.report(\n              t.makeError(name, BAD_PRIVATE_GLOBAL_ACCESS,\n                  name.getString(), docInfo.getSourceName()));\n        }\n      }\n    }\n  }\n\n  /**\n   * Determines whether the given property with @const tag got reassigned\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkConstantProperty(NodeTraversal t,\n      Node getprop) {\n    // Check whether the property is modified\n    Node parent = getprop.getParent();\n    if (!(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == getprop)\n        && (parent.getType() != Token.INC) && (parent.getType() != Token.DEC)) {\n      return;\n    }\n\n    ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    // Check whether constant properties are reassigned\n    if (objectType != null) {\n      ObjectType oType = objectType;\n      while (oType != null) {\n        if (oType.hasReferenceName()) {\n          if (initializedConstantProperties.containsEntry(\n                  oType.getReferenceName(), propertyName)) {\n            compiler.report(\n                t.makeError(getprop, CONST_PROPERTY_REASSIGNED_VALUE,\n                    propertyName));\n            break;\n          }\n        }\n        oType = oType.getImplicitPrototype();\n      }\n\n      JSDocInfo info = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (info != null && info.isConstant()\n          && objectType.hasReferenceName()) {\n        initializedConstantProperties.put(objectType.getReferenceName(),\n            propertyName);\n      }\n\n      // Add the prototype when we're looking at an instance object\n      if (objectType.isInstanceType()) {\n        ObjectType prototype = objectType.getImplicitPrototype();\n        if (prototype != null) {\n          JSDocInfo prototypeInfo\n            = prototype.getOwnPropertyJSDocInfo(propertyName);\n          if (prototypeInfo != null && prototypeInfo.isConstant()\n              && prototype.hasReferenceName()) {\n            initializedConstantProperties.put(prototype.getReferenceName(),\n                propertyName);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      // Is this a normal property access, or are we trying to override\n      // an existing property?\n      boolean isOverride = t.inGlobalScope() &&\n          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n\n      // Find the lowest property defined on a class with visibility\n      // information.\n      if (isOverride) {\n        objectType = objectType.getImplicitPrototype();\n      }\n      JSDocInfo docInfo = null;\n      for (; objectType != null;\n           objectType = objectType.getImplicitPrototype()) {\n        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        if (docInfo != null &&\n            docInfo.getVisibility() != Visibility.INHERITED) {\n          break;\n        }\n      }\n\n      if (objectType == null) {\n        // We couldn't find a visibility modifier; assume it's public.\n        return;\n      }\n\n      boolean sameInput =\n          t.getInput().getName().equals(docInfo.getSourceName());\n      Visibility visibility = docInfo.getVisibility();\n      JSType ownerType = normalizeClassType(objectType);\n      if (isOverride) {\n        // Check an ASSIGN statement that's trying to override a property\n        // on a superclass.\n        JSDocInfo overridingInfo = parent.getJSDocInfo();\n        Visibility overridingVisibility = overridingInfo == null ?\n            Visibility.INHERITED : overridingInfo.getVisibility();\n\n        // Check that (a) the property *can* be overridden, and\n        // (b) that the visibility of the override is the same as the\n        // visibility of the original property.\n        if (visibility == Visibility.PRIVATE && !sameInput) {\n          compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE,\n                  objectType.toString()));\n        } else if (overridingVisibility != Visibility.INHERITED &&\n            overridingVisibility != visibility) {\n          compiler.report(\n              t.makeError(getprop, VISIBILITY_MISMATCH,\n                  visibility.name(), objectType.toString(),\n                  overridingVisibility.name()));\n        }\n      } else {\n        if (sameInput) {\n          // private access is always allowed in the same file.\n          return;\n        } else if (visibility == Visibility.PRIVATE &&\n            (currentClass == null || ownerType.differsFrom(currentClass))) {\n          if (docInfo.isConstructor() &&\n              isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n\n          // private access is not allowed outside the file from a different\n          // enclosing class.\n          compiler.report(\n              t.makeError(getprop,\n                  BAD_PRIVATE_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        } else if (visibility == Visibility.PROTECTED) {\n          // There are 3 types of legal accesses of a protected property:\n          // 1) Accesses in the same file\n          // 2) Overriding the property in a subclass\n          // 3) Accessing the property from inside a subclass\n          // The first two have already been checked for.\n          if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n            compiler.report(\n                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                    propertyName,\n                    validator.getReadableJSTypeName(\n                        getprop.getFirstChild(), true)));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Whether the given access of a private constructor is legal.\n   *\n   * For example,\n   * new PrivateCtor_(); // not legal\n   * PrivateCtor_.newInstance(); // legal\n   * x instanceof PrivateCtor_ // legal\n   *\n   * This is a weird special case, because our visibility system is inherited\n   * from Java, and JavaScript has no distinction between classes and\n   * constructors like Java does.\n   *\n   * We may want to revisit this if we decide to make the restrictions tighter.\n   */\n  private static boolean isValidPrivateConstructorAccess(Node parent) {\n    return parent.getType() != Token.NEW;\n  }\n\n  /**\n   * Determines whether a deprecation warning should be emitted.\n   * @param t The current traversal.\n   * @param n The node which we are checking.\n   * @param parent The parent of the node which we are checking.\n   */\n  private boolean shouldEmitDeprecationWarning(\n      NodeTraversal t, Node n, Node parent) {\n    // In the global scope, there are only two kinds of accesses that should\n    // be flagged for warnings:\n    // 1) Calls of deprecated functions and methods.\n    // 2) Instantiations of deprecated classes.\n    // For now, we just let everything else by.\n    if (t.inGlobalScope()) {\n      if (!((parent.getType() == Token.CALL && parent.getFirstChild() == n) ||\n              n.getType() == Token.NEW)) {\n        return false;\n      }\n    }\n\n    // We can always assign to a deprecated property, to keep it up to date.\n    if (n.getType() == Token.GETPROP && n == parent.getFirstChild() &&\n        NodeUtil.isAssignmentOp(parent)) {\n      return false;\n    }\n\n    return !canAccessDeprecatedTypes(t);\n  }\n\n  /**\n   * Returns whether it's currently ok to access deprecated names and\n   * properties.\n   *\n   * There are 3 exceptions when we're allowed to use a deprecated\n   * type or property:\n   * 1) When we're in a deprecated function.\n   * 2) When we're in a deprecated class.\n   * 3) When we're in a static method of a deprecated class.\n   */\n  private boolean canAccessDeprecatedTypes(NodeTraversal t) {\n    Node scopeRoot = t.getScopeRoot();\n    Node scopeRootParent = scopeRoot.getParent();\n    return\n      // Case #1\n      (deprecatedDepth > 0) ||\n      // Case #2\n      (getTypeDeprecationInfo(t.getScope().getTypeOfThis()) != null) ||\n        // Case #3\n      (scopeRootParent != null && scopeRootParent.getType() == Token.ASSIGN &&\n       getTypeDeprecationInfo(\n           getClassOfMethod(scopeRoot, scopeRootParent)) != null);\n  }\n\n  /**\n   * Returns whether this is a function node annotated as deprecated.\n   */\n  private static boolean isDeprecatedFunction(Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n      JSType type = n.getJSType();\n      if (type != null) {\n        return getTypeDeprecationInfo(type) != null;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the deprecation reason for the type if it is marked\n   * as being deprecated. Returns empty string if the type is deprecated\n   * but no reason was given. Returns null if the type is not deprecated.\n   */\n  private static String getTypeDeprecationInfo(JSType type) {\n    if (type == null) {\n      return null;\n    }\n\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n    ObjectType objType = ObjectType.cast(type);\n    if (objType != null) {\n      ObjectType implicitProto = objType.getImplicitPrototype();\n      if (implicitProto != null) {\n        return getTypeDeprecationInfo(implicitProto);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns the deprecation reason for the property if it is marked\n   * as being deprecated. Returns empty string if the property is deprecated\n   * but no reason was given. Returns null if the property is not deprecated.\n   */\n  private static String getPropertyDeprecationInfo(ObjectType type,\n                                                   String prop) {\n    JSDocInfo info = type.getOwnPropertyJSDocInfo(prop);\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    ObjectType implicitProto = type.getImplicitPrototype();\n    if (implicitProto != null) {\n      return getPropertyDeprecationInfo(implicitProto, prop);\n    }\n    return null;\n  }\n\n  /**\n   * Dereference a type, autoboxing it and filtering out null.\n   */\n  private static JSType dereference(JSType type) {\n    return type == null ? null : type.dereference();\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"type\": \"NullPointerException\",\n      \"description\": \"The 'compiler' object or its methods might be null, leading to a NullPointerException. Check if the 'compiler' object is initialized before calling its methods.\"\n    },\n    {\n      \"type\": \"ArrayIndexOutOfBoundsException\",\n      \"description\": \"The loop in the 'process' and 'hotSwapScript' methods might cause an ArrayIndexOutOfBoundsException if the length of the 'compiler' array is less than the loop index. Ensure the array has enough elements.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"The 't.getScopeRoot()' method might throw an IllegalArgumentException if the root node is not a scope. Handle this exception to prevent the compiler from crashing.\"\n    },\n    {\n      \"type\": \"UnsupportedOperationException\",\n      \"description\": \"The 'HashMultimap.create()' method might throw an UnsupportedOperationException if the Multimap implementation does not support the create method. Use a different Multimap implementation or handle this exception.\"\n    },\n    {\n      \"type\": \"ClassCastException\",\n      \"description\": \"The 'getClassOfMethod' method might throw a ClassCastException if the type of the left-hand side of the assignment is not a constructor. Add a check to ensure the type is a constructor before casting.\"\n    },\n    {\n      \"type\": \"NoClassDefFoundError\",\n      \"description\": \"The 'com.google.javascript.jscomp.NodeTraversal' and 'com.google.javascript.jscomp.Scope' classes might not be found in the classpath, leading to a NoClassDefFoundError. Ensure the necessary dependencies are included in the classpath.\"\n    }\n  ]\n}"}}