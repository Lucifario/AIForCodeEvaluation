{"sample_id": "Closure_89", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2006 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.TokenStream;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\n/**\n * Builds a global namespace of all the objects and their properties in\n * the global scope. Also builds an index of all the references to those names.\n *\n */\nclass GlobalNamespace {\n\n  private AbstractCompiler compiler;\n  private final Node root;\n  private final Node externsRoot;\n  private boolean inExterns;\n  private Scope externsScope;\n  private boolean generated = false;\n\n  /** Global namespace tree */\n  private List<Name> globalNames = new ArrayList<Name>();\n\n  /** Maps names (e.g. \"a.b.c\") to nodes in the global namespace tree */\n  private Map<String, Name> nameMap = new HashMap<String, Name>();\n\n  /**\n   * Creates an instance that may emit warnings when building the namespace.\n   *\n   * @param compiler The AbstractCompiler, for reporting code changes\n   * @param root The root of the rest of the code to build a namespace for.\n   */\n  GlobalNamespace(AbstractCompiler compiler, Node root) {\n    this(compiler, null, root);\n  }\n\n  /**\n   * Creates an instance that may emit warnings when building the namespace.\n   *\n   * @param compiler The AbstractCompiler, for reporting code changes\n   * @param externsRoot The root of the externs to build a namespace for. If\n   *     this is null, externs and properties defined on extern types will not\n   *     be included in the global namespace.  If non-null, it allows\n   *     user-defined function on extern types to be included in the global\n   *     namespace.  E.g. String.foo.\n   * @param root The root of the rest of the code to build a namespace for.\n   */\n  GlobalNamespace(AbstractCompiler compiler, Node externsRoot, Node root) {\n    this.compiler = compiler;\n    this.externsRoot = externsRoot;\n    this.root = root;\n  }\n\n  /**\n   * Gets a list of the roots of the forest of the global names, where the\n   * roots are the top-level names.\n   */\n  List<Name> getNameForest() {\n    if (!generated) {\n      process();\n    }\n    return globalNames;\n  }\n\n  /**\n   * Gets an index of all the global names, indexed by full qualified name\n   * (as in \"a\", \"a.b.c\", etc.).\n   */\n  Map<String, Name> getNameIndex() {\n    if (!generated) {\n      process();\n    }\n    return nameMap;\n  }\n\n  /**\n   * If the client adds new nodes to the AST, scan these new nodes\n   * to see if they've added any references to the global namespace.\n   * @param scope The scope to scan.\n   * @param newNodes New nodes to check.\n   */\n  void scanNewNodes(Scope scope, Set<Node> newNodes) {\n    NodeTraversal t = new NodeTraversal(compiler,\n        new BuildGlobalNamespace(new NodeFilter(newNodes)));\n    t.traverseAtScope(scope);\n  }\n\n  /**\n   * A filter that looks for qualified names that contain one of the nodes\n   * in the given set.\n   */\n  private static class NodeFilter implements Predicate<Node> {\n    private final Set<Node> newNodes;\n\n    NodeFilter(Set<Node> newNodes) {\n      this.newNodes = newNodes;\n    }\n\n    public boolean apply(Node n) {\n      if (!n.isQualifiedName()) {\n        return false;\n      }\n\n      Node current;\n      for (current = n;\n           current.getType() == Token.GETPROP;\n           current = current.getFirstChild()) {\n        if (newNodes.contains(current)) {\n          return true;\n        }\n      }\n\n      return current.getType() == Token.NAME && newNodes.contains(current);\n    }\n  }\n\n  /**\n   * Builds the namespace lazily.\n   */\n  private void process() {\n    if (externsRoot != null) {\n      inExterns = true;\n      NodeTraversal.traverse(compiler, externsRoot, new BuildGlobalNamespace());\n    }\n    inExterns = false;\n\n    NodeTraversal.traverse(compiler, root, new BuildGlobalNamespace());\n    generated = true;\n  }\n\n  /**\n   * Determines whether a name reference in a particular scope is a global name\n   * reference.\n   *\n   * @param name A variable or property name (e.g. \"a\" or \"a.b.c.d\")\n   * @param s The scope in which the name is referenced\n   * @return Whether the name reference is a global name reference\n   */\n  private boolean isGlobalNameReference(String name, Scope s) {\n    String topVarName = getTopVarName(name);\n    return isGlobalVarReference(topVarName, s);\n  }\n\n  /**\n   * Gets the top variable name from a possibly namespaced name.\n   *\n   * @param name A variable or qualified property name (e.g. \"a\" or \"a.b.c.d\")\n   * @return The top variable name (e.g. \"a\")\n   */\n  private String getTopVarName(String name) {\n    int firstDotIndex = name.indexOf('.');\n    return firstDotIndex == -1 ? name : name.substring(0, firstDotIndex);\n  }\n\n  /**\n   * Determines whether a variable name reference in a particular scope is a\n   * global variable reference.\n   *\n   * @param name A variable name (e.g. \"a\")\n   * @param s The scope in which the name is referenced\n   * @return Whether the name reference is a global variable reference\n   */\n  private boolean isGlobalVarReference(String name, Scope s) {\n    Scope.Var v = s.getVar(name);\n    if (v == null && externsScope != null) {\n      v = externsScope.getVar(name);\n    }\n    return v != null && !v.isLocal();\n  }\n\n  /**\n   * Gets whether a scope is the global scope.\n   *\n   * @param s A scope\n   * @return Whether the scope is the global scope\n   */\n  private boolean isGlobalScope(Scope s) {\n    return s.getParent() == null;\n  }\n\n  // -------------------------------------------------------------------------\n\n  /**\n   * Builds a tree representation of the global namespace. Omits prototypes.\n   */\n  private class BuildGlobalNamespace extends AbstractPostOrderCallback {\n\n    private final Predicate<Node> nodeFilter;\n\n    BuildGlobalNamespace() {\n      this(null);\n    }\n\n    /**\n     * Builds a global namepsace, but only visits nodes that match the\n     * given filter.\n     */\n    BuildGlobalNamespace(Predicate<Node> nodeFilter) {\n      this.nodeFilter = nodeFilter;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (nodeFilter != null && !nodeFilter.apply(n)) {\n        return;\n      }\n\n      // If we are traversing the externs, then we save a pointer to the scope\n      // generated by them, so that we can do lookups in it later.\n      if (externsRoot != null && n == externsRoot) {\n        externsScope = t.getScope();\n      }\n\n      String name;\n      boolean isSet = false;\n      Name.Type type = Name.Type.OTHER;\n      boolean isPropAssign = false;\n\n      switch (n.getType()) {\n        case Token.STRING:\n          // This may be a key in an object literal declaration.\n          name = null;\n          if (parent != null && parent.getType() == Token.OBJECTLIT) {\n            name = getNameForObjLitKey(n);\n          }\n          if (name == null) return;\n          isSet = true;\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.NAME:\n          // This may be a variable get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.VAR:\n                isSet = true;\n                Node rvalue = n.getFirstChild();\n                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n                break;\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                }\n                break;\n              case Token.GETPROP:\n                return;\n              case Token.FUNCTION:\n                Node gramps = parent.getParent();\n                if (gramps == null ||\n                    NodeUtil.isFunctionExpression(parent)) return;\n                isSet = true;\n                type = Name.Type.FUNCTION;\n                break;\n            }\n          }\n          name = n.getString();\n          break;\n        case Token.GETPROP:\n          // This may be a namespaced name get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                  isPropAssign = true;\n                }\n                break;\n              case Token.GETPROP:\n                return;\n            }\n          }\n          name = n.getQualifiedName();\n          if (name == null) return;\n          break;\n        default:\n          return;\n      }\n\n      // We are only interested in global names.\n      Scope scope = t.getScope();\n      if (!isGlobalNameReference(name, scope)) {\n        return;\n      }\n\n      if (isSet) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n        } else {\n          handleSetFromLocal(t, n, parent, name);\n        }\n      } else {\n        handleGet(t, n, parent, name);\n      }\n    }\n\n    /**\n     * Gets the fully qualified name corresponding to an object literal key,\n     * as long as it and its prefix property names are valid JavaScript\n     * identifiers. The object literal may be nested inside of other object\n     * literals.\n     *\n     * For example, if called with node {@code n} representing \"z\" in any of\n     * the following expressions, the result would be \"w.x.y.z\":\n     * <code> var w = {x: {y: {z: 0}}}; </code>\n     * <code> w.x = {y: {z: 0}}; </code>\n     * <code> w.x.y = {'a': 0, 'z': 0}; </code>\n     *\n     * @param n A child of an OBJLIT node\n     * @return The global name, or null if {@code n} doesn't correspond to the\n     *   key of an object literal that can be named\n     */\n    String getNameForObjLitKey(Node n) {\n      Node parent = n.getParent();\n      Preconditions.checkState(parent.getType() == Token.OBJECTLIT);\n\n      Node gramps = parent.getParent();\n      if (gramps == null) {\n        return null;\n      }\n\n      Node greatGramps = gramps.getParent();\n      String name;\n      switch (gramps.getType()) {\n        case Token.NAME:\n          // VAR\n          //   NAME (gramps)\n          //     OBJLIT (parent)\n          //       STRING (n)\n          if (greatGramps == null ||\n              greatGramps.getType() != Token.VAR) {\n            return null;\n          }\n          name = gramps.getString();\n          break;\n        case Token.ASSIGN:\n          // ASSIGN (gramps)\n          //   NAME|GETPROP\n          //   OBJLIT (parent)\n          //     STRING (n)\n          Node lvalue = gramps.getFirstChild();\n          name = lvalue.getQualifiedName();\n          break;\n        case Token.STRING:\n          // OBJLIT\n          //   STRING (gramps)\n          //     OBJLIT (parent)\n          //       STRING (n)\n          if (greatGramps != null &&\n              greatGramps.getType() == Token.OBJECTLIT) {\n            name = getNameForObjLitKey(gramps);\n          } else {\n            return null;\n          }\n          break;\n        default:\n          return null;\n      }\n      if (name != null) {\n        String key = n.getString();\n        if (TokenStream.isJSIdentifier(key)) {\n          return name + '.' + key;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * Gets the type of a value or simple expression.\n     *\n     * @param n An rvalue in an assignment or variable declaration (not null)\n     * @return A {@link Name.Type}\n     */\n    Name.Type getValueType(Node n) {\n      switch (n.getType()) {\n        case Token.OBJECTLIT:\n          return Name.Type.OBJECTLIT;\n        case Token.FUNCTION:\n          return Name.Type.FUNCTION;\n        case Token.OR:\n          // Recurse on the second value. If the first value were an object\n          // literal or function, then the OR would be meaningless and the\n          // second value would be dead code. Assume that if the second value\n          // is an object literal or function, then the first value will also\n          // evaluate to one when it doesn't evaluate to false.\n          return getValueType(n.getLastChild());\n        case Token.HOOK:\n          // The same line of reasoning used for the OR case applies here.\n          Node second = n.getFirstChild().getNext();\n          Name.Type t = getValueType(second);\n          if (t != Name.Type.OTHER) return t;\n          Node third = second.getNext();\n          return getValueType(third);\n      }\n      return Name.Type.OTHER;\n    }\n\n    /**\n     * Updates our respresentation of the global namespace to reflect an\n     * assignment to a global name in global scope.\n     *\n     * @param t The traversal\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     * @param isPropAssign Whether this set corresponds to a property\n     *     assignment of the form <code>a.b.c = ...;</code>\n     * @param type The type of the value that the name is being assigned\n     */\n    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\n      if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, Ref.Type.SET_FROM_GLOBAL);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, Ref.Type.ALIASING_GET);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isConstructorOrEnumDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setIsClassOrEnum();\n      }\n    }\n\n    /**\n     * Determines whether a set operation is a constructor or enumeration\n     * declaration. The set operation may either be an assignment to a name,\n     * a variable declaration, or an object literal key mapping.\n     *\n     * @param n The node that represents the name being set\n     * @param parent Parent node of {@code n} (an ASSIGN, VAR, or OBJLIT node)\n     * @return Whether the set operation is either a constructor or enum\n     *     declaration\n     */\n    private boolean isConstructorOrEnumDeclaration(Node n, Node parent) {\n      // NOTE(nicksantos): This does not handle named constructors\n      // function a() {}\n      // For legacy reasons, we should not fix this, because we do not\n      // know who's depending on the current behavior.\n\n      JSDocInfo info;\n      int valueNodeType;\n      switch (parent.getType()) {\n        case Token.ASSIGN:\n          info = parent.getJSDocInfo();\n          valueNodeType = n.getNext().getType();\n          break;\n        case Token.VAR:\n          info = n.getJSDocInfo();\n          if (info == null) {\n            info = parent.getJSDocInfo();\n          }\n          Node valueNode = n.getFirstChild();\n          valueNodeType = valueNode != null ? valueNode.getType() : Token.VOID;\n          break;\n        default:\n          return false;\n      }\n      // Heed the annotations only if they're sensibly used.\n      return info != null &&\n             (info.isConstructor() && valueNodeType == Token.FUNCTION ||\n              info.hasEnumParameterType() && valueNodeType == Token.OBJECTLIT);\n    }\n\n    /**\n     * Updates our respresentation of the global namespace to reflect an\n     * assignment to a global name in a local scope.\n     *\n     * @param t The traversal\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     */\n    void handleSetFromLocal(NodeTraversal t, Node n, Node parent,\n                            String name) {\n      if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n\n      Name node = getOrCreateName(name);\n      Ref set = new Ref(t, n, Ref.Type.SET_FROM_LOCAL);\n      node.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, Ref.Type.ALIASING_GET);\n        node.addRef(get);\n        Ref.markTwins(set, get);\n      }\n    }\n\n    /**\n     * Updates our respresentation of the global namespace to reflect a read\n     * of a global name.\n     *\n     * @param t The traversal\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     */\n    void handleGet(NodeTraversal t, Node n, Node parent, String name) {\n      if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n\n      Ref.Type type = Ref.Type.DIRECT_GET;\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.IF:\n          case Token.TYPEOF:\n          case Token.VOID:\n          case Token.NOT:\n          case Token.BITNOT:\n          case Token.POS:\n          case Token.NEG:\n            break;\n          case Token.CALL:\n            type = n == parent.getFirstChild()\n                   ? Ref.Type.CALL_GET\n                   : Ref.Type.ALIASING_GET;\n            break;\n          case Token.NEW:\n            type = n == parent.getFirstChild()\n                   ? Ref.Type.DIRECT_GET\n                   : Ref.Type.ALIASING_GET;\n            break;\n          case Token.OR:\n          case Token.AND:\n            // This node is x or y in (x||y) or (x&&y). We only know that an\n            // alias is not getting created for this name if the result is used\n            // in a boolean context or assigned to the same name\n            // (e.g. var a = a || {}).\n            type = determineGetTypeForHookOrBooleanExpr(t, parent, name);\n            break;\n          case Token.HOOK:\n            if (n != parent.getFirstChild()) {\n              // This node is y or z in (x?y:z). We only know that an alias is\n              // not getting created for this name if the result is assigned to\n              // the same name (e.g. var a = a ? a : {}).\n              type = determineGetTypeForHookOrBooleanExpr(t, parent, name);\n            }\n            break;\n          default:\n            type = Ref.Type.ALIASING_GET;\n            break;\n        }\n      }\n\n      handleGet(t, n, parent, name, type);\n    }\n\n    /**\n     * Determines whether the result of a hook (x?y:z) or boolean expression\n     * (x||y) or (x&&y) is assigned to a specific global name.\n     *\n     * @param t The traversal\n     * @param parent The parent of the current node in the traversal. This node\n     *     should already be known to be a HOOK, AND, or OR node.\n     * @param name A name that is already known to be global in the current\n     *     scope (e.g. \"a\" or \"a.b.c.d\")\n     * @return The expression's get type, either {@link Ref.Type#DIRECT_GET} or\n     *     {@link Ref.Type#ALIASING_GET}\n     */\n    Ref.Type determineGetTypeForHookOrBooleanExpr(\n        NodeTraversal t, Node parent, String name) {\n      Node prev = parent;\n      for (Node anc : parent.getAncestors()) {\n        switch (anc.getType()) {\n          case Token.EXPR_RESULT:\n          case Token.VAR:\n          case Token.IF:\n          case Token.WHILE:\n          case Token.FOR:\n          case Token.TYPEOF:\n          case Token.VOID:\n          case Token.NOT:\n          case Token.BITNOT:\n          case Token.POS:\n          case Token.NEG:\n            return Ref.Type.DIRECT_GET;\n          case Token.HOOK:\n            if (anc.getFirstChild() == prev) {\n              return Ref.Type.DIRECT_GET;\n            }\n            break;\n          case Token.ASSIGN:\n            if (!name.equals(anc.getFirstChild().getQualifiedName())) {\n              return Ref.Type.ALIASING_GET;\n            }\n            break;\n          case Token.NAME:  // a variable declaration\n            if (!name.equals(anc.getString())) {\n              return Ref.Type.ALIASING_GET;\n            }\n            break;\n          case Token.CALL:\n            if (anc.getFirstChild() != prev) {\n              return Ref.Type.ALIASING_GET;\n            }\n            break;\n        }\n        prev = anc;\n      }\n      return Ref.Type.ALIASING_GET;\n    }\n\n    /**\n     * Updates our respresentation of the global namespace to reflect a read\n     * of a global name.\n     *\n     * @param t The current node traversal\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     * @param type The reference type\n     */\n    void handleGet(NodeTraversal t, Node n, Node parent,\n        String name, Ref.Type type) {\n      Name node = getOrCreateName(name);\n\n      // No need to look up additional ancestors, since they won't be used.\n      node.addRef(new Ref(t, n, type));\n    }\n\n    /**\n     * Updates our respresentation of the global namespace to reflect a read\n     * of a global name's longest prefix before the \"prototype\" property if the\n     * name includes the \"prototype\" property. Does nothing otherwise.\n     *\n     * @param t The current node traversal\n     * @param n The node currently being visited\n     * @param parent {@code n}'s parent\n     * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n     * @return Whether the name was handled\n     */\n    boolean maybeHandlePrototypePrefix(NodeTraversal t, Node n, Node parent,\n        String name) {\n      // We use a string-based approach instead of inspecting the parse tree\n      // to avoid complexities with object literals, possibly nested, beneath\n      // assignments.\n\n      int numLevelsToRemove;\n      String prefix;\n      if (name.endsWith(\".prototype\")) {\n        numLevelsToRemove = 1;\n        prefix = name.substring(0, name.length() - 10);\n      } else {\n        int i = name.indexOf(\".prototype.\");\n        if (i == -1) {\n          return false;\n        }\n        prefix = name.substring(0, i);\n        numLevelsToRemove = 2;\n        i = name.indexOf('.', i + 11);\n        while (i >= 0) {\n          numLevelsToRemove++;\n          i = name.indexOf('.', i + 1);\n        }\n      }\n\n      if (parent != null && NodeUtil.isObjectLitKey(n, parent)) {\n        // Object literal keys have no prefix that's referenced directly per\n        // key, so we're done.\n        return true;\n      }\n\n      for (int i = 0; i < numLevelsToRemove; i++) {\n        parent = n;\n        n = n.getFirstChild();\n      }\n\n      handleGet(t, n, parent, prefix, Ref.Type.PROTOTYPE_GET);\n      return true;\n    }\n\n    /**\n     * Determines whether an assignment is nested (i.e. whether its return\n     * value is used).\n     *\n     * @param parent The parent of the current traversal node (not null)\n     * @return Whether it appears that the return value of the assignment is\n     *     used\n     */\n    boolean isNestedAssign(Node parent) {\n      return parent.getType() == Token.ASSIGN &&\n             !NodeUtil.isExpressionNode(parent.getParent());\n    }\n\n    /**\n     * Gets a {@link Name} instance for a global name. Creates it if necessary,\n     * as well as instances for any of its prefixes that are not yet defined.\n     *\n     * @param name A global name (e.g. \"a\", \"a.b.c.d\")\n     * @return The {@link Name} instance for {@code name}\n     */\n    Name getOrCreateName(String name) {\n      Name node = nameMap.get(name);\n      if (node == null) {\n        int i = name.lastIndexOf('.');\n        if (i >= 0) {\n          String parentName = name.substring(0, i);\n          Name parent = getOrCreateName(parentName);\n          node = parent.addProperty(name.substring(i + 1), inExterns);\n        } else {\n          node = new Name(name, null, inExterns);\n          globalNames.add(node);\n        }\n        nameMap.put(name, node);\n      }\n      return node;\n    }\n  }\n\n  // -------------------------------------------------------------------------\n\n  /**\n   * A name defined in global scope (e.g. \"a\" or \"a.b.c.d\"). These form a tree.\n   * As the parse tree traversal proceeds, we'll discover that some names\n   * correspond to JavaScript objects whose properties we should consider\n   * collapsing.\n   */\n  static class Name {\n    enum Type {\n      OBJECTLIT,\n      FUNCTION,\n      OTHER,\n    }\n\n    final String name;\n    final Name parent;\n    List<Name> props;\n    Ref declaration;\n    List<Ref> refs;\n    Type type;\n    private boolean isClassOrEnum = false;\n    private boolean hasClassOrEnumDescendant = false;\n    int globalSets = 0;\n    int localSets = 0;\n    int aliasingGets = 0;\n    int totalGets = 0;\n    int callGets = 0;\n    boolean inExterns;\n\n    JSDocInfo docInfo = null;\n\n    Name(String name, Name parent, boolean inExterns) {\n      this.name = name;\n      this.parent = parent;\n      this.type = Type.OTHER;\n      this.inExterns = inExterns;\n    }\n\n    Name addProperty(String name, boolean inExterns) {\n      if (props == null) {\n        props = new ArrayList<Name>();\n      }\n      Name node = new Name(name, this, inExterns);\n      props.add(node);\n      return node;\n    }\n\n    void addRef(Ref ref) {\n      switch (ref.type) {\n        case SET_FROM_GLOBAL:\n          if (declaration == null) {\n            declaration = ref;\n            docInfo = getDocInfoForDeclaration(ref);\n          } else {\n            addRefInternal(ref);\n          }\n          globalSets++;\n          break;\n        case SET_FROM_LOCAL:\n          addRefInternal(ref);\n          localSets++;\n          break;\n        case PROTOTYPE_GET:\n        case DIRECT_GET:\n          addRefInternal(ref);\n          totalGets++;\n          break;\n        case ALIASING_GET:\n          addRefInternal(ref);\n          aliasingGets++;\n          totalGets++;\n          break;\n        case CALL_GET:\n          addRefInternal(ref);\n          callGets++;\n          totalGets++;\n          break;\n        default:\n          throw new IllegalStateException();\n      }\n    }\n\n    void removeRef(Ref ref) {\n      if (ref == declaration ||\n          (refs != null && refs.remove(ref))) {\n        if (ref == declaration) {\n          declaration = null;\n          if (refs != null) {\n            for (Ref maybeNewDecl : refs) {\n              if (maybeNewDecl.type == Ref.Type.SET_FROM_GLOBAL) {\n                declaration = maybeNewDecl;\n                refs.remove(declaration);\n                break;\n              }\n            }\n          }\n        }\n\n        switch (ref.type) {\n          case SET_FROM_GLOBAL:\n            globalSets--;\n            break;\n          case SET_FROM_LOCAL:\n            localSets--;\n            break;\n          case PROTOTYPE_GET:\n          case DIRECT_GET:\n            totalGets--;\n            break;\n          case ALIASING_GET:\n            aliasingGets--;\n            totalGets--;\n            break;\n          case CALL_GET:\n            callGets--;\n            totalGets--;\n            break;\n          default:\n            throw new IllegalStateException();\n        }\n      }\n    }\n\n    void addRefInternal(Ref ref) {\n      if (refs == null) {\n        refs = new LinkedList<Ref>();\n      }\n      refs.add(ref);\n    }\n\n    boolean canEliminate() {\n      if (!canCollapseUnannotatedChildNames() || totalGets > 0) {\n        return false;\n      }\n\n      if (props != null) {\n        for (Name n : props) {\n          if (!n.canCollapse()) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    boolean canCollapse() {\n      return !inExterns && (isClassOrEnum ||\n          (parent == null || parent.canCollapseUnannotatedChildNames()) &&\n          (globalSets > 0 || localSets > 0));\n    }\n\n    boolean canCollapseUnannotatedChildNames() {\n      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n      }\n\n      // Don't try to collapse if the one global set is a twin reference.\n      // We could theoretically handle this case in CollapseProperties, but\n      // it's probably not worth the effort.\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n\n      if (isClassOrEnum) {\n        return true;\n      }\n\n      // If this is a key of an aliased object literal, then it will be aliased\n      // later. So we won't be able to collapse its properties.\n      if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n      }\n\n      // If this is aliased, then its properties can't be collapsed either.\n      if (type != Type.FUNCTION && aliasingGets > 0) {\n        return false;\n      }\n\n      return (parent == null || parent.canCollapseUnannotatedChildNames());\n    }\n\n    /** Whether this is an object literal that needs to keep its keys. */\n    boolean shouldKeepKeys() {\n      return type == Type.OBJECTLIT && aliasingGets > 0;\n    }\n\n    boolean needsToBeStubbed() {\n      return globalSets == 0 && localSets > 0;\n    }\n\n    void setIsClassOrEnum() {\n      isClassOrEnum = true;\n      for (Name ancestor = parent; ancestor != null;\n           ancestor = ancestor.parent) {\n        ancestor.hasClassOrEnumDescendant = true;\n      }\n    }\n\n    /**\n     * Determines whether this name is a prefix of at least one class or enum\n     * name. Because classes and enums are always collapsed, the namespace will\n     * have different properties in compiled code than in uncompiled code.\n     *\n     * For example, if foo.bar.DomHelper is a class, then foo and foo.bar are\n     * considered namespaces.\n     */\n    boolean isNamespace() {\n      return hasClassOrEnumDescendant && type == Type.OBJECTLIT;\n    }\n\n    /**\n     * Determines whether this is a simple name (as opposed to a qualified\n     * name).\n     */\n    boolean isSimpleName() {\n      return parent == null;\n    }\n\n    @Override public String toString() {\n      return fullName() + \" (\" + type + \"): globalSets=\" + globalSets +\n          \", localSets=\" + localSets + \", totalGets=\" + totalGets +\n          \", aliasingGets=\" + aliasingGets + \", callGets=\" + callGets;\n    }\n\n    String fullName() {\n      return parent == null ? name : parent.fullName() + '.' + name;\n    }\n\n    /**\n     * Tries to get the doc info for a given declaration ref.\n     */\n    private static JSDocInfo getDocInfoForDeclaration(Ref ref) {\n      if (ref.node != null) {\n        Node refParent = ref.node.getParent();\n        switch (refParent.getType()) {\n          case Token.FUNCTION:\n          case Token.ASSIGN:\n            return refParent.getJSDocInfo();\n          case Token.VAR:\n            return ref.node == refParent.getFirstChild() ?\n                refParent.getJSDocInfo() : ref.node.getJSDocInfo();\n        }\n      }\n\n      return null;\n    }\n  }\n\n  // -------------------------------------------------------------------------\n\n  /**\n   * A global name reference. Contains references to the relevant parse tree\n   * node and its ancestors that may be affected.\n   */\n  static class Ref {\n    enum Type {\n      SET_FROM_GLOBAL,\n      SET_FROM_LOCAL,\n      PROTOTYPE_GET,\n      ALIASING_GET,     // Prevents a name's properties from being collapsed\n      DIRECT_GET,       // Prevents a name from being completely eliminated\n      CALL_GET,         // Prevents a name from being collapsed if never set\n    }\n\n    Node node;\n    final Type type;\n    final String sourceName;\n    final Scope scope;\n    final JSModule module;\n\n    /**\n     * Certain types of references are actually double-refs. For example,\n     * var a = b = 0;\n     * counts as both a \"set\" of b and an \"alias\" of b.\n     *\n     * We create two Refs for this node, and mark them as twins of each other.\n     */\n    private Ref twin = null;\n\n    /**\n     * Creates a reference at the current node.\n     */\n    Ref(NodeTraversal t, Node name, Type type) {\n      this.node = name;\n      this.sourceName = t.getSourceName();\n      this.type = type;\n      this.scope = t.getScope();\n      this.module = t.getModule();\n    }\n\n    private Ref(Ref original, Type type) {\n      this.node = original.node;\n      this.sourceName = original.sourceName;\n      this.type = type;\n      this.scope = original.scope;\n      this.module = original.module;\n    }\n\n    private Ref(Type type) {\n      this.type = type;\n      this.sourceName = \"source\";\n      this.scope = null;\n      this.module = null;\n    }\n\n    Ref getTwin() {\n      return twin;\n    }\n\n    boolean isSet() {\n      return type == Type.SET_FROM_GLOBAL || type == Type.SET_FROM_LOCAL;\n    }\n\n    static void markTwins(Ref a, Ref b) {\n      Preconditions.checkArgument(\n          (a.type == Type.ALIASING_GET || b.type == Type.ALIASING_GET) &&\n          (a.type == Type.SET_FROM_GLOBAL || a.type == Type.SET_FROM_LOCAL ||\n           b.type == Type.SET_FROM_GLOBAL || b.type == Type.SET_FROM_LOCAL));\n      a.twin = b;\n      b.twin = a;\n    }\n\n    /**\n     * Create a new ref that is the same as this one, but of\n     * a different class.\n     */\n    Ref cloneAndReclassify(Type type) {\n      return new Ref(this, type);\n    }\n\n    static Ref createRefForTesting(Type type) {\n      return new Ref(type);\n    }\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"description\": \"Infinite loop in isGlobalVarReference method\",\n      \"location\": \"GlobalNamespace.java:143\",\n      \"reason\": \"The method isGlobalVarReference(String name, Scope s) does not have a return statement and will cause an infinite loop.\"\n    },\n    {\n      \"description\": \"Null Pointer Exception in getTopVarName method\",\n      \"location\": \"GlobalNamespace.java:131\",\n      \"reason\": \"The method getTopVarName(String name) does not handle the case where name is null, which can lead to a Null Pointer Exception.\"\n    },\n    {\n      \"description\": \"Potential Null Pointer Exception in getNameForest method\",\n      \"location\": \"GlobalNamespace.java:63\",\n      \"reason\": \"The method getNameForest() does not check if the globalNames list is null before returning it, which can lead to a Null Pointer Exception.\"\n    },\n    {\n      \"description\": \"Potential Null Pointer Exception in getNameIndex method\",\n      \"location\": \"GlobalNamespace.java:69\",\n      \"reason\": \"The method getNameIndex() does not check if the nameMap map is null before returning it, which can lead to a Null Pointer Exception.\"\n    }\n  ]\n}"}}