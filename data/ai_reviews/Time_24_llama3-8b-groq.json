{"sample_id": "Time_24", "model": "llama3-8b-groq", "code_context": "/*\n *  Copyright 2001-2011 Stephen Colebourne\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.joda.time.format;\n\nimport java.util.Arrays;\nimport java.util.Locale;\n\nimport org.joda.time.Chronology;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DateTimeZone;\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.IllegalFieldValueException;\n\n/**\n * DateTimeParserBucket is an advanced class, intended mainly for parser\n * implementations. It can also be used during normal parsing operations to\n * capture more information about the parse.\n * <p>\n * This class allows fields to be saved in any order, but be physically set in\n * a consistent order. This is useful for parsing against formats that allow\n * field values to contradict each other.\n * <p>\n * Field values are applied in an order where the \"larger\" fields are set\n * first, making their value less likely to stick.  A field is larger than\n * another when it's range duration is longer. If both ranges are the same,\n * then the larger field has the longer duration. If it cannot be determined\n * which field is larger, then the fields are set in the order they were saved.\n * <p>\n * For example, these fields were saved in this order: dayOfWeek, monthOfYear,\n * dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in\n * this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek.\n * <p>\n * DateTimeParserBucket is mutable and not thread-safe.\n *\n * @author Brian S O'Neill\n * @author Fredrik Borgh\n * @since 1.0\n */\npublic class DateTimeParserBucket {\n\n    /** The chronology to use for parsing. */\n    private final Chronology iChrono;\n    private final long iMillis;\n    \n    // TimeZone to switch to in computeMillis. If null, use offset.\n    private DateTimeZone iZone;\n    private int iOffset;\n    /** The locale to use for parsing. */\n    private Locale iLocale;\n    /** Used for parsing two-digit years. */\n    private Integer iPivotYear;\n    /** Used for parsing month/day without year. */\n    private int iDefaultYear;\n\n    private SavedField[] iSavedFields = new SavedField[8];\n    private int iSavedFieldsCount;\n    private boolean iSavedFieldsShared;\n    \n    private Object iSavedState;\n\n    /**\n     * Constructs a bucket.\n     * \n     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n     * @param chrono  the chronology to use\n     * @param locale  the locale to use\n     * @deprecated Use longer constructor\n     */\n    @Deprecated\n    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale) {\n        this(instantLocal, chrono, locale, null, 2000);\n    }\n\n    /**\n     * Constructs a bucket, with the option of specifying the pivot year for\n     * two-digit year parsing.\n     *\n     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n     * @param chrono  the chronology to use\n     * @param locale  the locale to use\n     * @param pivotYear  the pivot year to use when parsing two-digit years\n     * @since 1.1\n     * @deprecated Use longer constructor\n     */\n    @Deprecated\n    public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear) {\n        this(instantLocal, chrono, locale, pivotYear, 2000);\n    }\n\n    /**\n     * Constructs a bucket, with the option of specifying the pivot year for\n     * two-digit year parsing.\n     *\n     * @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time\n     * @param chrono  the chronology to use\n     * @param locale  the locale to use\n     * @param pivotYear  the pivot year to use when parsing two-digit years\n     * @since 2.0\n     */\n    public DateTimeParserBucket(long instantLocal, Chronology chrono,\n            Locale locale, Integer pivotYear, int defaultYear) {\n        super();\n        chrono = DateTimeUtils.getChronology(chrono);\n        iMillis = instantLocal;\n        iChrono = chrono.withUTC();\n        iLocale = (locale == null ? Locale.getDefault() : locale);\n        setZone(chrono.getZone());\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the chronology of the bucket, which will be a local (UTC) chronology.\n     */\n    public Chronology getChronology() {\n        return iChrono;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the locale to be used during parsing.\n     * \n     * @return the locale to use\n     */\n    public Locale getLocale() {\n        return iLocale;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the time zone used by computeMillis, or null if an offset is\n     * used instead.\n     */\n    public DateTimeZone getZone() {\n        return iZone;\n    }\n    \n    /**\n     * Set a time zone to be used when computeMillis is called, which\n     * overrides any set time zone offset.\n     *\n     * @param zone the date time zone to operate in, or null if UTC\n     */\n    public void setZone(DateTimeZone zone) {\n        iSavedState = null;\n        iZone = zone == DateTimeZone.UTC ? null : zone;\n        iOffset = 0;\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * Returns the time zone offset in milliseconds used by computeMillis,\n     * unless getZone doesn't return null.\n     */\n    public int getOffset() {\n        return iOffset;\n    }\n    \n    /**\n     * Set a time zone offset to be used when computeMillis is called, which\n     * overrides the time zone.\n     */\n    public void setOffset(int offset) {\n        iSavedState = null;\n        iOffset = offset;\n        iZone = null;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the default year used when information is incomplete.\n     * <p>\n     * This is used for two-digit years and when the largest parsed field is\n     * months or days.\n     * <p>\n     * A null value for two-digit years means to use the value from DateTimeFormatterBuilder.\n     * A null value for month/day only parsing will cause the default of 2000 to be used.\n     *\n     * @return Integer value of the pivot year, null if not set\n     * @since 1.1\n     */\n    public Integer getPivotYear() {\n        return iPivotYear;\n    }\n\n    /**\n     * Sets the pivot year to use when parsing two digit years.\n     * <p>\n     * If the value is set to null, this will indicate that default\n     * behaviour should be used.\n     *\n     * @param pivotYear  the pivot year to use\n     * @since 1.1\n     */\n    public void setPivotYear(Integer pivotYear) {\n        iPivotYear = pivotYear;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Saves a datetime field value.\n     * \n     * @param field  the field, whose chronology must match that of this bucket\n     * @param value  the value\n     */\n    public void saveField(DateTimeField field, int value) {\n        saveField(new SavedField(field, value));\n    }\n    \n    /**\n     * Saves a datetime field value.\n     * \n     * @param fieldType  the field type\n     * @param value  the value\n     */\n    public void saveField(DateTimeFieldType fieldType, int value) {\n        saveField(new SavedField(fieldType.getField(iChrono), value));\n    }\n    \n    /**\n     * Saves a datetime field text value.\n     * \n     * @param fieldType  the field type\n     * @param text  the text value\n     * @param locale  the locale to use\n     */\n    public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {\n        saveField(new SavedField(fieldType.getField(iChrono), text, locale));\n    }\n    \n    private void saveField(SavedField field) {\n        SavedField[] savedFields = iSavedFields;\n        int savedFieldsCount = iSavedFieldsCount;\n        \n        if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n            // Expand capacity or merely copy if saved fields are shared.\n            SavedField[] newArray = new SavedField\n                [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\n            System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n            iSavedFields = savedFields = newArray;\n            iSavedFieldsShared = false;\n        }\n        \n        iSavedState = null;\n        savedFields[savedFieldsCount] = field;\n        iSavedFieldsCount = savedFieldsCount + 1;\n    }\n    \n    /**\n     * Saves the state of this bucket, returning it in an opaque object. Call\n     * restoreState to undo any changes that were made since the state was\n     * saved. Calls to saveState may be nested.\n     *\n     * @return opaque saved state, which may be passed to restoreState\n     */\n    public Object saveState() {\n        if (iSavedState == null) {\n            iSavedState = new SavedState();\n        }\n        return iSavedState;\n    }\n    \n    /**\n     * Restores the state of this bucket from a previously saved state. The\n     * state object passed into this method is not consumed, and it can be used\n     * later to restore to that state again.\n     *\n     * @param savedState opaque saved state, returned from saveState\n     * @return true state object is valid and state restored\n     */\n    public boolean restoreState(Object savedState) {\n        if (savedState instanceof SavedState) {\n            if (((SavedState) savedState).restoreState(this)) {\n                iSavedState = savedState;\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public long computeMillis() {\n        return computeMillis(false, null);\n    }\n    \n    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public long computeMillis(boolean resetFields) {\n        return computeMillis(resetFields, null);\n    }\n\n    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @param text optional text being parsed, to be included in any error message\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     * @since 1.3\n     */\n    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }\n    \n    /**\n     * Sorts elements [0,high). Calling java.util.Arrays isn't always the right\n     * choice since it always creates an internal copy of the array, even if it\n     * doesn't need to. If the array slice is small enough, an insertion sort\n     * is chosen instead, but it doesn't need a copy!\n     * <p>\n     * This method has a modified version of that insertion sort, except it\n     * doesn't create an unnecessary array copy. If high is over 10, then\n     * java.util.Arrays is called, which will perform a merge sort, which is\n     * faster than insertion sort on large lists.\n     * <p>\n     * The end result is much greater performance when computeMillis is called.\n     * Since the amount of saved fields is small, the insertion sort is a\n     * better choice. Additional performance is gained since there is no extra\n     * array allocation and copying. Also, the insertion sort here does not\n     * perform any casting operations. The version in java.util.Arrays performs\n     * casts within the insertion sort loop.\n     */\n    private static void sort(SavedField[] array, int high) {\n        if (high > 10) {\n            Arrays.sort(array, 0, high);\n        } else {\n            for (int i=0; i<high; i++) {\n                for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n                    SavedField t = array[j];\n                    array[j] = array[j-1];\n                    array[j-1] = t;\n                }\n            }\n        }\n    }\n\n    class SavedState {\n        final DateTimeZone iZone;\n        final int iOffset;\n        final SavedField[] iSavedFields;\n        final int iSavedFieldsCount;\n        \n        SavedState() {\n            this.iZone = DateTimeParserBucket.this.iZone;\n            this.iOffset = DateTimeParserBucket.this.iOffset;\n            this.iSavedFields = DateTimeParserBucket.this.iSavedFields;\n            this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;\n        }\n        \n        boolean restoreState(DateTimeParserBucket enclosing) {\n            if (enclosing != DateTimeParserBucket.this) {\n                return false;\n            }\n            enclosing.iZone = this.iZone;\n            enclosing.iOffset = this.iOffset;\n            enclosing.iSavedFields = this.iSavedFields;\n            if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {\n                // Since count is being restored to a lower count, the\n                // potential exists for new saved fields to destroy data being\n                // shared by another state. Set this flag such that the array\n                // of saved fields is cloned prior to modification.\n                enclosing.iSavedFieldsShared = true;\n            }\n            enclosing.iSavedFieldsCount = this.iSavedFieldsCount;\n            return true;\n        }\n    }\n    \n    static class SavedField implements Comparable<SavedField> {\n        final DateTimeField iField;\n        final int iValue;\n        final String iText;\n        final Locale iLocale;\n        \n        SavedField(DateTimeField field, int value) {\n            iField = field;\n            iValue = value;\n            iText = null;\n            iLocale = null;\n        }\n        \n        SavedField(DateTimeField field, String text, Locale locale) {\n            iField = field;\n            iValue = 0;\n            iText = text;\n            iLocale = locale;\n        }\n        \n        long set(long millis, boolean reset) {\n            if (iText == null) {\n                millis = iField.set(millis, iValue);\n            } else {\n                millis = iField.set(millis, iText, iLocale);\n            }\n            if (reset) {\n                millis = iField.roundFloor(millis);\n            }\n            return millis;\n        }\n        \n        /**\n         * The field with the longer range duration is ordered first, where\n         * null is considered infinite. If the ranges match, then the field\n         * with the longer duration is ordered first.\n         */\n        public int compareTo(SavedField obj) {\n            DateTimeField other = obj.iField;\n            int result = compareReverse\n                (iField.getRangeDurationField(), other.getRangeDurationField());\n            if (result != 0) {\n                return result;\n            }\n            return compareReverse\n                (iField.getDurationField(), other.getDurationField());\n        }\n    }\n\n    static int compareReverse(DurationField a, DurationField b) {\n        if (a == null || !a.isSupported()) {\n            if (b == null || !b.isSupported()) {\n                return 0;\n            }\n            return -1;\n        }\n        if (b == null || !b.isSupported()) {\n            return 1;\n        }\n        return -a.compareTo(b);\n    }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"id\": 1,\n         \"description\": \"The constructor DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale) is deprecated and should not be used.\",\n         \"severity\": \"INFO\"\n      },\n      {\n         \"id\": 2,\n         \"description\": \"The constructor DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear) is deprecated and should not be used.\",\n         \"severity\": \"INFO\"\n      },\n      {\n         \"id\": 3,\n         \"description\": \"The constructor DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale, Integer pivotYear, int defaultYear) does not check if the defaultYear is valid.\",\n         \"severity\": \"WARNING\"\n      },\n      {\n         \"id\": 4,\n         \"description\": \"The field iSavedFields is not properly synchronized, which can lead to thread-safety issues.\",\n         \"severity\": \"CRITICAL\"\n      },\n      {\n         \"id\": 5,\n         \"description\": \"The method setZone(DateTimeZone zone) does not check if the zone is null, which can lead to a NullPointerException.\",\n         \"severity\": \"WARNING\"\n      }\n   ]\n}"}}