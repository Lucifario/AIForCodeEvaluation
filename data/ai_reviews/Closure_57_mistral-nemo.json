{"sample_id": "Closure_57", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2007 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport com.google.javascript.rhino.jstype.JSTypeNative;\nimport com.google.javascript.rhino.jstype.ObjectType;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\n\n\n/**\n * This describes the Closure-specific JavaScript coding conventions.\n *\n */\npublic class ClosureCodingConvention extends DefaultCodingConvention {\n\n  private static final long serialVersionUID = 1L;\n\n  static final DiagnosticType OBJECTLIT_EXPECTED = DiagnosticType.warning(\n      \"JSC_REFLECT_OBJECTLIT_EXPECTED\",\n      \"Object literal expected as second argument\");\n\n  /**\n   * Closure's goog.inherits adds a {@code superClass_} property to the\n   * subclass, and a {@code constructor} property.\n   */\n  @Override\n  public void applySubclassRelationship(FunctionType parentCtor,\n      FunctionType childCtor, SubclassType type) {\n    if (type == SubclassType.INHERITS) {\n      childCtor.defineDeclaredProperty(\"superClass_\",\n          parentCtor.getPrototype(), parentCtor.getSource());\n      childCtor.getPrototype().defineDeclaredProperty(\"constructor\",\n          childCtor, parentCtor.getSource());\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * <p>Understands several different inheritance patterns that occur in\n   * Google code (various uses of {@code inherits} and {@code mixin}).\n   */\n  @Override\n  public SubclassRelationship getClassesDefinedByCall(Node callNode) {\n    Node callName = callNode.getFirstChild();\n    SubclassType type = typeofClassDefiningName(callName);\n    if (type != null) {\n      Node subclass = null;\n      Node superclass = callNode.getLastChild();\n\n      // There are six possible syntaxes for a class-defining method:\n      // SubClass.inherits(SuperClass)\n      // goog.inherits(SubClass, SuperClass)\n      // goog$inherits(SubClass, SuperClass)\n      // SubClass.mixin(SuperClass.prototype)\n      // goog.mixin(SubClass.prototype, SuperClass.prototype)\n      // goog$mixin(SubClass.prototype, SuperClass.prototype)\n      boolean isDeprecatedCall = callNode.getChildCount() == 2 &&\n          callName.getType() == Token.GETPROP;\n      if (isDeprecatedCall) {\n        // SubClass.inherits(SuperClass)\n        subclass = callName.getFirstChild();\n      } else if (callNode.getChildCount() == 3) {\n        // goog.inherits(SubClass, SuperClass)\n        subclass = callName.getNext();\n      } else {\n        return null;\n      }\n\n      if (type == SubclassType.MIXIN) {\n        // Only consider mixins that mix two prototypes as related to\n        // inheritance.\n        if (!endsWithPrototype(superclass)) {\n          return null;\n        }\n        if (!isDeprecatedCall) {\n          if (!endsWithPrototype(subclass)) {\n            return null;\n          }\n          // Strip off the prototype from the name.\n          subclass = subclass.getFirstChild();\n        }\n        superclass = superclass.getFirstChild();\n      }\n\n      // bail out if either of the side of the \"inherits\"\n      // isn't a real class name. This prevents us from\n      // doing something weird in cases like:\n      // goog.inherits(MySubClass, cond ? SuperClass1 : BaseClass2)\n      if (subclass != null &&\n          subclass.isUnscopedQualifiedName() &&\n          superclass.isUnscopedQualifiedName()) {\n        return new SubclassRelationship(type, subclass, superclass);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Determines whether the given node is a class-defining name, like\n   * \"inherits\" or \"mixin.\"\n   * @return The type of class-defining name, or null.\n   */\n  private SubclassType typeofClassDefiningName(Node callName) {\n    // Check if the method name matches one of the class-defining methods.\n    String methodName = null;\n    if (callName.getType() == Token.GETPROP) {\n      methodName = callName.getLastChild().getString();\n    } else if (callName.getType() == Token.NAME) {\n      String name = callName.getString();\n      int dollarIndex = name.lastIndexOf('$');\n      if (dollarIndex != -1) {\n        methodName = name.substring(dollarIndex + 1);\n      }\n    }\n\n    if (methodName != null) {\n      if (methodName.equals(\"inherits\")) {\n        return SubclassType.INHERITS;\n      } else if (methodName.equals(\"mixin\")) {\n        return SubclassType.MIXIN;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public boolean isSuperClassReference(String propertyName) {\n    return \"superClass_\".equals(propertyName);\n  }\n\n  /**\n   * Given a qualified name node, returns whether \"prototype\" is at the end.\n   * For example:\n   * a.b.c => false\n   * a.b.c.prototype => true\n   */\n  private boolean endsWithPrototype(Node qualifiedName) {\n    return qualifiedName.getType() == Token.GETPROP &&\n        qualifiedName.getLastChild().getString().equals(\"prototype\");\n  }\n\n  /**\n   * Exctracts X from goog.provide('X'), if the applied Node is goog.\n   *\n   * @return The extracted class name, or null.\n   */\n  @Override\n  public String extractClassNameIfProvide(Node node, Node parent){\n    return extractClassNameIfGoog(node, parent, \"goog.provide\");\n  }\n\n  /**\n   * Exctracts X from goog.require('X'), if the applied Node is goog.\n   *\n   * @return The extracted class name, or null.\n   */\n  @Override\n  public String extractClassNameIfRequire(Node node, Node parent){\n    return extractClassNameIfGoog(node, parent, \"goog.require\");\n  }\n\n  private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName){\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n      Node callee = node.getFirstChild();\n      if (callee != null && callee.getType() == Token.GETPROP) {\n        String qualifiedName = callee.getQualifiedName();\n        if (functionName.equals(qualifiedName)) {\n          Node target = callee.getNext();\n          if (target != null) {\n            className = target.getString();\n          }\n        }\n      }\n    }\n    return className;\n  }\n\n  /**\n   * Use closure's implementation.\n   * @return closure's function name for exporting properties.\n   */\n  @Override\n  public String getExportPropertyFunction() {\n    return \"goog.exportProperty\";\n  }\n\n  /**\n   * Use closure's implementation.\n   * @return closure's function name for exporting symbols.\n   */\n  @Override\n  public String getExportSymbolFunction() {\n    return \"goog.exportSymbol\";\n  }\n\n  @Override\n  public List<String> identifyTypeDeclarationCall(Node n) {\n    Node callName = n.getFirstChild();\n    if (\"goog.addDependency\".equals(callName.getQualifiedName()) &&\n        n.getChildCount() >= 3) {\n      Node typeArray = callName.getNext().getNext();\n      if (typeArray.getType() == Token.ARRAYLIT) {\n        List<String> typeNames = Lists.newArrayList();\n        for (Node name = typeArray.getFirstChild(); name != null;\n             name = name.getNext()) {\n          if (name.getType() == Token.STRING) {\n            typeNames.add(name.getString());\n          }\n        }\n        return typeNames;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public String getAbstractMethodName() {\n    return \"goog.abstractMethod\";\n  }\n\n  @Override\n  public String getSingletonGetterClassName(Node callNode) {\n    Node callArg = callNode.getFirstChild();\n    String callName = callArg.getQualifiedName();\n\n    // Use both the original name and the post-CollapseProperties name.\n    if (!(\"goog.addSingletonGetter\".equals(callName) ||\n          \"goog$addSingletonGetter\".equals(callName)) ||\n        callNode.getChildCount() != 2) {\n      return null;\n    }\n\n    return callArg.getNext().getQualifiedName();\n  }\n\n  @Override\n  public void applySingletonGetter(FunctionType functionType,\n      FunctionType getterType, ObjectType objectType) {\n    functionType.defineDeclaredProperty(\"getInstance\", getterType,\n        functionType.getSource());\n    functionType.defineDeclaredProperty(\"instance_\", objectType,\n        functionType.getSource());\n  }\n\n  @Override\n  public String getGlobalObject() {\n    return \"goog.global\";\n  }\n\n  private final Set<String> propertyTestFunctions = ImmutableSet.of(\n      \"goog.isDef\", \"goog.isNull\", \"goog.isDefAndNotNull\",\n      \"goog.isString\", \"goog.isNumber\", \"goog.isBoolean\",\n      \"goog.isFunction\", \"goog.isArray\", \"goog.isObject\");\n\n  @Override\n  public boolean isPropertyTestFunction(Node call) {\n    Preconditions.checkArgument(call.getType() == Token.CALL);\n    return propertyTestFunctions.contains(\n        call.getFirstChild().getQualifiedName());\n  }\n\n  @Override\n  public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n      Node callNode) {\n    Preconditions.checkArgument(callNode.getType() == Token.CALL);\n    Node callName = callNode.getFirstChild();\n    if (!\"goog.reflect.object\".equals(callName.getQualifiedName()) ||\n        callNode.getChildCount() != 3) {\n      return null;\n    }\n\n    Node typeNode = callName.getNext();\n    if (!typeNode.isQualifiedName()) {\n      return null;\n    }\n\n    Node objectNode = typeNode.getNext();\n    if (objectNode.getType() != Token.OBJECTLIT) {\n      // TODO(johnlenz): The coding convention should not be performing checks.\n      t.getCompiler().report(JSError.make(t.getSourceName(), callNode,\n                                          OBJECTLIT_EXPECTED));\n      return null;\n    }\n\n    return new ObjectLiteralCast(typeNode.getQualifiedName(),\n                                 typeNode.getNext());\n  }\n\n  @Override\n  public boolean isOptionalParameter(Node parameter) {\n    return false;\n  }\n\n  @Override\n  public boolean isVarArgsParameter(Node parameter) {\n    return false;\n  }\n\n  @Override\n  public boolean isPrivate(String name) {\n    return false;\n  }\n\n  @Override\n  public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n    return ImmutableList.<AssertionFunctionSpec>of(\n        new AssertionFunctionSpec(\"goog.asserts.assert\"),\n        new AssertionFunctionSpec(\"goog.asserts.assertNumber\",\n            JSTypeNative.NUMBER_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertString\",\n            JSTypeNative.STRING_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertFunction\",\n            JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertObject\",\n            JSTypeNative.OBJECT_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertArray\",\n            JSTypeNative.ARRAY_TYPE),\n        // TODO(agrieve): It would be better if this could make the first\n        // parameter the type of the second parameter.\n        new AssertionFunctionSpec(\"goog.asserts.assertInstanceof\",\n            JSTypeNative.OBJECT_TYPE)\n    );\n  }\n\n  @Override\n  public Bind describeFunctionBind(Node n) {\n    Bind result = super.describeFunctionBind(n);\n    if (result != null) {\n      return result;\n    }\n\n    // It would be nice to be able to identify a fn.bind call\n    // but that requires knowing the type of \"fn\".\n\n    if (n.getType() != Token.CALL) {\n      return null;\n    }\n\n    Node callTarget = n.getFirstChild();\n    String name = callTarget.getQualifiedName();\n    if (name != null) {\n      if (name.equals(\"goog.bind\")\n          || name.equals(\"goog$bind\")) {\n        // goog.bind(fn, self, args...);\n        Node fn = callTarget.getNext();\n        if (fn == null) {\n          return null;\n        }\n        Node thisValue = safeNext(fn);\n        Node parameters = safeNext(thisValue);\n        return new Bind(fn, thisValue, parameters);\n      }\n\n      if (name.equals(\"goog.partial\") || name.equals(\"goog$partial\")) {\n        // goog.partial(fn, args...);\n        Node fn = callTarget.getNext();\n        if (fn == null) {\n          return null;\n        }\n        Node thisValue = null;\n        Node parameters = safeNext(fn);\n        return new Bind(fn, thisValue, parameters);\n      }\n    }\n\n    return null;\n  }\n\n  private Node safeNext(Node n) {\n    if (n != null) {\n      return n.getNext();\n    }\n    return null;\n  }\n}\n", "review": {"response": "{ \"bugs\": [] }"}}