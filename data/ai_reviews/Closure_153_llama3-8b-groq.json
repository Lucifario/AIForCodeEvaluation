{"sample_id": "Closure_153", "model": "llama3-8b-groq", "code_context": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.MakeDeclaredNamesUnique.BoilerplateRenamer;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Simplifies the AST by splitting var statements, moving initializiers\n *    out of for loops, and converting whiles to fors.\n * 2) Moves hoisted functions to the top of function scopes.\n * 3) Rewrites unhoisted named function declarations to be var declarations.\n * 4) Makes all variable names globally unique (extern or otherwise) so that\n *    no value is ever shadowed (note: \"arguments\" may require special\n *    handling).\n * 5) Removes duplicate variable declarations.\n * 6) Marks constants with the IS_CONSTANT_NAME annotation.\n *\n * @author johnlenz@google.com (johnlenz)\n */\n// public for ReplaceDebugStringsTest\nclass Normalize implements CompilerPass {\n\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  static final boolean MAKE_LOCAL_NAMES_UNIQUE = true;\n\n  public static final DiagnosticType CATCH_BLOCK_VAR_ERROR =\n    DiagnosticType.error(\n        \"JSC_CATCH_BLOCK_VAR_ERROR\",\n        \"The use of scope variable {0} is not allowed within a catch block \" +\n        \"with a catch exception of the same name.\");\n\n\n  Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n    this.compiler = compiler;\n    this.assertOnChange = assertOnChange;\n\n    // TODO(nicksantos): assertOnChange should only be true if the tree\n    // is normalized.\n  }\n\n  static Node parseAndNormalizeSyntheticCode(\n      AbstractCompiler compiler, String code, String prefix) {\n    Node js = compiler.parseSyntheticCode(code);\n    NodeTraversal.traverse(compiler, js,\n        new Normalize.NormalizeStatements(compiler, false));\n    NodeTraversal.traverse(\n        compiler, js,\n        new MakeDeclaredNamesUnique(\n            new BoilerplateRenamer(\n                compiler.getUniqueNameIdSupplier(),\n                prefix)));\n    return js;\n  }\n\n  static Node parseAndNormalizeTestCode(\n      AbstractCompiler compiler, String code, String prefix) {\n    Node js = compiler.parseTestCode(code);\n    NodeTraversal.traverse(compiler, js,\n        new Normalize.NormalizeStatements(compiler, false));\n    NodeTraversal.traverse(\n        compiler, js,\n        new MakeDeclaredNamesUnique());\n    return js;\n  }\n\n  private void reportCodeChange(String changeDescription) {\n    if (assertOnChange) {\n      throw new IllegalStateException(\n          \"Normalize constraints violated:\\n\" + changeDescription);\n    }\n    compiler.reportCodeChange();\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root,\n        new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n        .process(externs, root);\n\n    compiler.setNormalized();\n  }\n\n  /**\n   * Propagate constant annotations over the Var graph.\n   */\n  static class PropagateConstantAnnotationsOverVars\n      extends AbstractPostOrderCallback\n      implements CompilerPass {\n    private final AbstractCompiler compiler;\n    private final boolean assertOnChange;\n\n    PropagateConstantAnnotationsOverVars(\n        AbstractCompiler compiler, boolean forbidChanges) {\n      this.compiler = compiler;\n      this.assertOnChange = forbidChanges;\n    }\n\n    @Override\n    public void process(Node externs, Node root) {\n      new NodeTraversal(compiler, this).traverseRoots(externs, root);\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Note: Constant properties annotations are not propagated.\n      if (n.getType() == Token.NAME) {\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        JSDocInfo info = null;\n        // Find the JSDocInfo for a top level variable.\n        Var var = t.getScope().getVar(n.getString());\n        if (var != null) {\n          info = var.getJSDocInfo();\n        }\n\n        boolean shouldBeConstant =\n            (info != null && info.isConstant()) ||\n            NodeUtil.isConstantByConvention(\n                compiler.getCodingConvention(), n, parent);\n        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (shouldBeConstant && !isMarkedConstant) {\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  parent:\" + n.getParent().toStringTree());\n          }\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n      }\n    }\n  }\n\n  /**\n   * Walk the AST tree and verify that constant names are used consistently.\n   */\n  static class VerifyConstants extends AbstractPostOrderCallback\n      implements CompilerPass {\n\n    final private AbstractCompiler compiler;\n    final private boolean checkUserDeclarations;\n\n    VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) {\n      this.compiler = compiler;\n      this.checkUserDeclarations = checkUserDeclarations;\n    }\n\n    @Override\n    public void process(Node externs, Node root) {\n      Node externsAndJs = root.getParent();\n      Preconditions.checkState(externsAndJs != null);\n      Preconditions.checkState(externsAndJs.hasChild(externs));\n\n      NodeTraversal.traverseRoots(\n          compiler, Lists.newArrayList(externs, root), this);\n    }\n\n    private Map<String, Boolean> constantMap = Maps.newHashMap();\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.NAME) {\n        String name = n.getString();\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (checkUserDeclarations) {\n          boolean expectedConst = false;\n          CodingConvention convention = compiler.getCodingConvention();\n          if (NodeUtil.isConstantName(n)\n              || NodeUtil.isConstantByConvention(convention, n, parent)) {\n            expectedConst = true;\n          } else {\n            expectedConst = false;\n\n            JSDocInfo info = null;\n            Var var = t.getScope().getVar(n.getString());\n            if (var != null) {\n              info = var.getJSDocInfo();\n            }\n\n            if (info != null && info.isConstant()) {\n              expectedConst = true;\n            } else {\n              expectedConst = false;\n            }\n          }\n\n          if (expectedConst) {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name \" + name + \" is not annotated as constant.\");\n          } else {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name \" + name + \" should not be annotated as constant.\");\n          }\n        }\n\n        Boolean value = constantMap.get(name);\n        if (value == null) {\n          constantMap.put(name, isConst);\n        } else {\n          Preconditions.checkState(value.booleanValue() == isConst,\n              \"The name \" + name + \" is not consistently annotated as \" +\n              \"constant.\");\n        }\n      }\n    }\n  }\n\n  /**\n   * Simplify the AST:\n   *   - VAR declarations split, so they represent exactly one child\n   *     declaration.\n   *   - WHILEs are converted to FORs\n   *   - FOR loop are initializers are moved out of the FOR structure\n   *   - LABEL node of children other than LABEL, BLOCK, WHILE, FOR, or DO are\n   *     moved into a block.\n   *   - Add constant annotations based on coding convention.\n   */\n  static class NormalizeStatements implements Callback {\n    private final AbstractCompiler compiler;\n    private final boolean assertOnChange;\n\n    NormalizeStatements(AbstractCompiler compiler, boolean assertOnChange) {\n      this.compiler = compiler;\n      this.assertOnChange = assertOnChange;\n    }\n\n    private void reportCodeChange(String changeDescription) {\n      if (assertOnChange) {\n        throw new IllegalStateException(\n            \"Normalize constraints violated:\\n\" + changeDescription);\n      }\n      compiler.reportCodeChange();\n    }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      doStatementNormalizations(t, n, parent);\n\n      return true;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.WHILE:\n          if (CONVERT_WHILE_TO_FOR) {\n            Node expr = n.getFirstChild();\n            n.setType(Token.FOR);\n            Node empty = new Node(Token.EMPTY);\n            empty.copyInformationFrom(n);\n            n.addChildBefore(empty, expr);\n            n.addChildAfter(empty.cloneNode(), expr);\n            reportCodeChange(\"WHILE node\");\n          }\n          break;\n\n        case Token.FUNCTION:\n          normalizeFunctionDeclaration(n);\n          break;\n\n        case Token.NAME:\n        case Token.STRING:\n          annotateConstantsByConvention(n, parent);\n          break;\n      }\n    }\n\n    /**\n     * Mark names and properties that are constants by convention.\n     */\n    private void annotateConstantsByConvention(Node n, Node parent) {\n      Preconditions.checkState(\n          n.getType() == Token.NAME || n.getType() == Token.STRING);\n\n      // There are only two cases where a string token\n      // may be a variable reference: The right side of a GETPROP\n      // or an OBJECTLIT key.\n      boolean isObjLitKey = NodeUtil.isObjectLitKey(n, parent);\n      boolean isProperty = isObjLitKey ||\n          (parent.getType() == Token.GETPROP &&\n           parent.getLastChild() == n);\n      if (n.getType() == Token.NAME || isProperty) {\n        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (!isMarkedConstant &&\n            NodeUtil.isConstantByConvention(\n                compiler.getCodingConvention(), n, parent)) {\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  parent:\" + n.getParent().toStringTree());\n          }\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n      }\n    }\n\n    /**\n     * Rewrite named unhoisted functions declarations to a known\n     * consistent behavior so we don't to different logic paths for the same\n     * code. From:\n     *    function f() {}\n     * to:\n     *    var f = function () {};\n     */\n    private void normalizeFunctionDeclaration(Node n) {\n      Preconditions.checkState(n.getType() == Token.FUNCTION);\n      if (!NodeUtil.isFunctionExpression(n)\n          && !NodeUtil.isHoistedFunctionDeclaration(n)) {\n        rewriteFunctionDeclaration(n);\n      }\n    }\n\n    /**\n     * Rewrite the function declaration from:\n     *   function x() {}\n     *   FUNCTION\n     *     NAME\n     *     LP\n     *     BLOCK\n     * to:\n     *   var x = function() {};\n     *   VAR\n     *     NAME\n     *       FUNCTION\n     *         NAME (w/ empty string)\n     *         LP\n     *         BLOCK\n     */\n    private void rewriteFunctionDeclaration(Node n) {\n      // Prepare a spot for the function.\n      Node oldNameNode = n.getFirstChild();\n      Node fnNameNode = oldNameNode.cloneNode();\n      Node var = new Node(Token.VAR, fnNameNode, n.getLineno(), n.getCharno());\n      var.copyInformationFrom(n);\n\n      // Prepare the function\n      oldNameNode.setString(\"\");\n\n      // Move the function\n      Node parent = n.getParent();\n      parent.replaceChild(n, var);\n      fnNameNode.addChildToFront(n);\n\n      reportCodeChange(\"Function declaration\");\n    }\n\n    /**\n     * Do normalizations that introduce new siblings or parents.\n     */\n    private void doStatementNormalizations(\n        NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.LABEL) {\n        normalizeLabels(n);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n      // are the only legal place for VARs and FOR statements.\n      if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n        extractForInitializer(n, null, null);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs, as all these\n      // are the only legal place for VARs.\n      if (NodeUtil.isStatementBlock(n)) {\n        splitVarDeclarations(n);\n      }\n\n      if (n.getType() == Token.FUNCTION) {\n        moveNamedFunctions(n.getLastChild());\n      }\n    }\n\n    // TODO(johnlenz): Move this to NodeTypeNormalizer once the unit tests are\n    // fixed.\n    /**\n     * Limit the number of special cases where LABELs need to be handled. Only\n     * BLOCK and loops are allowed to be labeled.  Loop labels must remain in\n     * place as the named continues are not allowed for labeled blocks.\n     */\n    private void normalizeLabels(Node n) {\n      Preconditions.checkArgument(n.getType() == Token.LABEL);\n\n      Node last = n.getLastChild();\n      switch (last.getType()) {\n        case Token.LABEL:\n        case Token.BLOCK:\n        case Token.FOR:\n        case Token.WHILE:\n        case Token.DO:\n          return;\n        default:\n          Node block = new Node(Token.BLOCK);\n          block.copyInformationFrom(last);\n          n.replaceChild(last, block);\n          block.addChildToFront(last);\n          reportCodeChange(\"LABEL normalization\");\n          return;\n      }\n    }\n\n    /**\n     * Bring the initializers out of FOR loops.  These need to be placed\n     * before any associated LABEL nodes. This needs to be done from the top\n     * level label first so this is called as a pre-order callback (from\n     * shouldTraverse).\n     *\n     * @param n The node to inspect.\n     * @param before The node to insert the initializer before.\n     * @param beforeParent The parent of the node before which the initializer\n     *     will be inserted.\n     */\n    private void extractForInitializer(\n        Node n, Node before, Node beforeParent) {\n\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        Node insertBefore = (before == null) ? c : before;\n        Node insertBeforeParent = (before == null) ? n : beforeParent;\n        switch (c.getType()) {\n          case Token.LABEL:\n            extractForInitializer(c, insertBefore, insertBeforeParent);\n            break;\n          case Token.FOR:\n            if (NodeUtil.isForIn(c)) {\n              Node first = c.getFirstChild();\n              if (first.getType() == Token.VAR) {\n                // Transform:\n                //    for (var a in b) {}\n                // to:\n                //    var a; for (a in b) {};\n                Node newStatement = first.cloneTree();\n                Node name = first.removeFirstChild();\n                first.getParent().replaceChild(first, name);\n                insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                reportCodeChange(\"FOR-IN var declaration\");\n              }\n            } else if (c.getFirstChild().getType() != Token.EMPTY) {\n              Node init = c.getFirstChild();\n              Node empty = new Node(Token.EMPTY);\n              empty.copyInformationFrom(c);\n              c.replaceChild(init, empty);\n\n              Node newStatement;\n              // Only VAR statements, and expressions are allowed,\n              // but are handled differently.\n              if (init.getType() == Token.VAR) {\n                newStatement = init;\n              } else {\n                newStatement = NodeUtil.newExpr(init);\n              }\n\n              insertBeforeParent.addChildBefore(newStatement, insertBefore);\n              reportCodeChange(\"FOR initializer\");\n            }\n            break;\n        }\n      }\n    }\n\n    /**\n     * Split a var node such as:\n     *   var a, b;\n     * into individual statements:\n     *   var a;\n     *   var b;\n     * @param n The whose children we should inspect.\n     */\n    private void splitVarDeclarations(Node n) {\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        if (c.getType() == Token.VAR) {\n          if (assertOnChange && !c.hasChildren()) {\n            throw new IllegalStateException(\"Empty VAR node.\");\n          }\n\n          while (c.getFirstChild() != c.getLastChild()) {\n            Node name = c.getFirstChild();\n            c.removeChild(name);\n            Node newVar = new Node(\n                Token.VAR, name, n.getLineno(), n.getCharno());\n            n.addChildBefore(newVar, c);\n            reportCodeChange(\"VAR with multiple children\");\n          }\n        }\n      }\n    }\n\n    /**\n     * Move all the functions that are valid at the execution of the first\n     * statement of the function to the beginning of the function definition.\n     */\n    private void moveNamedFunctions(Node functionBody) {\n      Preconditions.checkState(\n          functionBody.getParent().getType() == Token.FUNCTION);\n      Node previous = null;\n      Node current = functionBody.getFirstChild();\n      // Skip any declarations at the beginning of the function body, they\n      // are already in the right place.\n      while (current != null && NodeUtil.isFunctionDeclaration(current)) {\n        previous = current;\n        current = current.getNext();\n      }\n\n      // Find any remaining declarations and move them.\n      Node insertAfter = previous;\n      while (current != null) {\n        // Save off the next node as the current node maybe removed.\n        Node next = current.getNext();\n        if (NodeUtil.isFunctionDeclaration(current)) {\n          // Remove the declaration from the body.\n          Preconditions.checkNotNull(previous);\n          functionBody.removeChildAfter(previous);\n\n          // Readd the function at the top of the function body (after any\n          // previous declarations).\n          insertAfter = addToFront(functionBody, current, insertAfter);\n          reportCodeChange(\"Move function declaration not at top of function\");\n        } else {\n          // Update the previous only if the current node hasn't been moved.\n          previous = current;\n        }\n        current = next;\n      }\n    }\n\n    /**\n     * @param after The child node to insert the newChild after, or null if\n     *     newChild should be added to the front of parent's child list.\n     * @return The inserted child node.\n     */\n    private Node addToFront(Node parent, Node newChild, Node after) {\n      if (after == null) {\n        parent.addChildToFront(newChild);\n      } else {\n        parent.addChildAfter(newChild, after);\n      }\n      return newChild;\n    }\n  }\n\n  /**\n   * Remove duplicate VAR declarations.\n   */\n  private void removeDuplicateDeclarations(Node externs, Node root) {\n    Callback tickler = new ScopeTicklingCallback();\n    ScopeCreator scopeCreator =  new SyntacticScopeCreator(\n        compiler, new DuplicateDeclarationHandler());\n    NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);\n    t.traverseRoots(externs, root);\n  }\n\n  /**\n   * ScopeCreator duplicate declaration handler.\n   */\n  private final class DuplicateDeclarationHandler implements\n      SyntacticScopeCreator.RedeclarationHandler {\n\n\n    /**\n     * Remove duplicate VAR declarations encountered discovered during\n     * scope creation.\n     */\n    @Override\n    public void onRedeclaration(\n        Scope s, String name, Node n, Node parent, Node gramps,\n        Node nodeWithLineNumber) {\n      Preconditions.checkState(n.getType() == Token.NAME);\n      Var v = s.getVar(name);\n\n        // We allow variables to be duplicate declared if one\n        // declaration appears in source and the other in externs.\n        // This deals with issues where a browser built-in is declared\n        // in one browser but not in another.\n\n      // If name is \"arguments\", Var maybe null.\n      if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n            name);\n        compiler.report(\n            JSError.make(\n                NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,\n                CATCH_BLOCK_VAR_ERROR, name));\n      } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n          s.undeclare(v);\n          s.declare(name, n, n.getJSType(), v.input);\n          replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n              v.getParentNode().getParent());\n        }\n      } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n\n        replaceVarWithAssignment(n, parent, gramps);\n      }\n    }\n\n    /**\n     * Remove the parent VAR. There are three cases that need to be handled:\n     *   1) \"var a = b;\" which is replaced with \"a = b\"\n     *   2) \"label:var a;\" which is replaced with \"label:;\". Ideally, the\n     *      label itself would be removed but that is not possible in the\n     *      context in which \"onRedeclaration\" is called.\n     *   3) \"for (var a in b) ...\" which is replaced with \"for (a in b)...\"\n     *      Cases we don't need to handle are VARs with multiple children,\n     *      which have already been split into separate declarations, so there\n     *      is no need to handle that here, and \"for (var a;;);\", which has\n     *      been moved out of the loop.\n     *      The result of this is that in each case the parent node is replaced\n     *      which is generally dangerous in a traversal but is fine here with\n     *      the scope creator, as the next node of interest is the parent's\n     *      next sibling.\n     */\n    private void replaceVarWithAssignment(Node n, Node parent, Node gramps) {\n      if (n.hasChildren()) {\n        // The  *  is being initialize, preserve the new value.\n        parent.removeChild(n);\n        // Convert \"var name = value\" to \"name = value\"\n        Node value = n.getFirstChild();\n        n.removeChild(value);\n        Node replacement = new Node(Token.ASSIGN, n, value);\n        replacement.copyInformationFrom(parent);\n        gramps.replaceChild(parent, NodeUtil.newExpr(replacement));\n      } else {\n        // It is an empty reference remove it.\n        if (NodeUtil.isStatementBlock(gramps)) {\n          gramps.removeChild(parent);\n        } else if (gramps.getType() == Token.FOR) {\n          // This is the \"for (var a in b)...\" case.  We don't need to worry\n          // about initializers in \"for (var a;;)...\" as those are moved out\n          // as part of the other normalizations.\n          parent.removeChild(n);\n          gramps.replaceChild(parent, n);\n        } else {\n          Preconditions.checkState(gramps.getType() == Token.LABEL);\n          // We should never get here. LABELs with a single VAR statement should\n          // already have been normalized to have a BLOCK.\n          throw new IllegalStateException(\"Unexpected LABEL\");\n        }\n      }\n      reportCodeChange(\"Duplicate VAR declaration\");\n    }\n  }\n\n  /**\n   * A simple class that causes scope to be created.\n   */\n  private final class ScopeTicklingCallback\n      implements NodeTraversal.ScopedCallback {\n    @Override\n    public void enterScope(NodeTraversal t) {\n      // Cause the scope to be created, which will cause duplicate\n      // to be found.\n      t.getScope();\n    }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n      // Nothing to do.\n    }\n\n    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      return true;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Nothing to do.\n    }\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"bug\": \"Missing import for classes and interfaces in the Normalize class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for NodeTraversal class in the Normalize class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for Node class in the Normalize class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for Token class in the Normalize class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for Map class in the Normalize class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for Set class in the Normalize class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for Var class in the Normalize class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for JSDocInfo class in the Normalize class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"TODO(nicksantos): assertOnChange should only be true if the tree is normalized.\",\n         \"line\": 44,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for AbstractPostOrderCallback class in the PropagateConstantAnnotationsOverVars class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for CompilerPass class in the PropagateConstantAnnotationsOverVars class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for NodeTraversal class in the PropagateConstantAnnotationsOverVars class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for Node class in the PropagateConstantAnnotationsOverVars class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for Token class in the PropagateConstantAnnotationsOverVars class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for Map class in the PropagateConstantAnnotationsOverVars class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for Set class in the PropagateConstantAnnotationsOverVars class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for Var class in the PropagateConstantAnnotationsOverVars class\",\n         \"line\": 1,\n         \"column\": 1\n      },\n      {\n         \"bug\": \"Missing import for JSDocInfo class in the PropagateConstantAnnotationsOverVars class\",\n         \"line\": 1,\n         \"column\": 1\n      }\n   ]\n}"}}