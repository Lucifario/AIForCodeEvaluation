{"sample_id": "Closure_35", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.CHECKED_UNKNOWN_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.jstype.BooleanLiteralSet;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.rhino.jstype.JSTypeNative;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\nimport com.google.javascript.rhino.jstype.ObjectType;\nimport com.google.javascript.rhino.jstype.StaticSlot;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Type inference within a script node or a function body, using the data-flow\n * analysis framework.\n *\n */\nclass TypeInference\n    extends DataFlowAnalysis.BranchedForwardDataFlowAnalysis<Node, FlowScope> {\n  static final DiagnosticType TEMPLATE_TYPE_NOT_OBJECT_TYPE =\n      DiagnosticType.warning(\n      \"JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE\",\n      \"The template type must be an object type.\\nActual: {0}\");\n\n  static final DiagnosticType TEMPLATE_TYPE_OF_THIS_EXPECTED =\n      DiagnosticType.warning(\n      \"JSC_TEMPLATE_TYPE_OF_THIS_EXPECTED\",\n      \"A function type with the template type as the type of this must be a \" +\n      \"parameter type\");\n\n  static final DiagnosticType FUNCTION_LITERAL_UNDEFINED_THIS =\n    DiagnosticType.warning(\n        \"JSC_FUNCTION_LITERAL_UNDEFINED_THIS\",\n        \"Function literal argument refers to undefined this argument\");\n\n  private final AbstractCompiler compiler;\n  private final JSTypeRegistry registry;\n  private final ReverseAbstractInterpreter reverseInterpreter;\n  private final Scope syntacticScope;\n  private final FlowScope functionScope;\n  private final FlowScope bottomScope;\n  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n\n  TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                ReverseAbstractInterpreter reverseInterpreter,\n                Scope functionScope,\n                Map<String, AssertionFunctionSpec> assertionFunctionsMap) {\n    super(cfg, new LinkedFlowScope.FlowScopeJoinOp());\n    this.compiler = compiler;\n    this.registry = compiler.getTypeRegistry();\n    this.reverseInterpreter = reverseInterpreter;\n    this.syntacticScope = functionScope;\n    this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);\n    this.assertionFunctionsMap = assertionFunctionsMap;\n\n    // For each local variable declared with the VAR keyword, the entry\n    // type is VOID.\n    Iterator<Var> varIt =\n        functionScope.getDeclarativelyUnboundVarsWithoutTypes();\n    while (varIt.hasNext()) {\n      Var var = varIt.next();\n      if (isUnflowable(var)) {\n        continue;\n      }\n\n      this.functionScope.inferSlotType(\n          var.getName(), getNativeType(VOID_TYPE));\n    }\n\n    this.bottomScope = LinkedFlowScope.createEntryLattice(\n        new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis()));\n  }\n\n  @Override\n  FlowScope createInitialEstimateLattice() {\n    return bottomScope;\n  }\n\n  @Override\n  FlowScope createEntryLattice() {\n    return functionScope;\n  }\n\n  @Override\n  FlowScope flowThrough(Node n, FlowScope input) {\n    // If we have not walked a path from <entry> to <n>, then we don't\n    // want to infer anything about this scope.\n    if (input == bottomScope) {\n      return input;\n    }\n\n    FlowScope output = input.createChildFlowScope();\n    output = traverse(n, output);\n    return output;\n  }\n\n  @Override\n  @SuppressWarnings(\"fallthrough\")\n  List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {\n    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND\n    // edges. If we wanted to be perfect, we'd actually JOIN all the out\n    // lattices of this flow with the in lattice, and then make that the out\n    // lattice for the ON_EX edge. But it's probably to expensive to be\n    // worthwhile.\n    FlowScope output = flowThrough(source, input);\n    Node condition = null;\n    FlowScope conditionFlowScope = null;\n    BooleanOutcomePair conditionOutcomes = null;\n\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);\n    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());\n    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {\n      Branch branch = branchEdge.getValue();\n      FlowScope newScope = output;\n\n      switch (branch) {\n        case ON_TRUE:\n          if (NodeUtil.isForIn(source)) {\n            // item is assigned a property name, so its type should be string.\n            Node item = source.getFirstChild();\n            Node obj = item.getNext();\n\n            FlowScope informed = traverse(obj, output.createChildFlowScope());\n\n            if (item.isVar()) {\n              item = item.getFirstChild();\n            }\n            if (item.isName()) {\n              JSType iterKeyType = getNativeType(STRING_TYPE);\n              ObjectType objType = getJSType(obj).dereference();\n              JSType objIndexType = objType == null ?\n                  null : objType.getIndexType();\n              if (objIndexType != null && !objIndexType.isUnknownType()) {\n                JSType narrowedKeyType =\n                    iterKeyType.getGreatestSubtype(objIndexType);\n                if (!narrowedKeyType.isEmptyType()) {\n                  iterKeyType = narrowedKeyType;\n                }\n              }\n              redeclareSimpleVar(informed, item, iterKeyType);\n            }\n            newScope = informed;\n            break;\n          }\n\n          // FALL THROUGH\n\n        case ON_FALSE:\n          if (condition == null) {\n            condition = NodeUtil.getConditionExpression(source);\n            if (condition == null && source.isCase()) {\n              condition = source;\n\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope = traverse(\n                    condition.getFirstChild(), output.createChildFlowScope());\n              }\n            }\n          }\n\n          if (condition != null) {\n            if (condition.isAnd() ||\n                condition.isOr()) {\n              // When handling the short-circuiting binary operators,\n              // the outcome scope on true can be different than the outcome\n              // scope on false.\n              //\n              // TODO(nicksantos): The \"right\" way to do this is to\n              // carry the known outcome all the way through the\n              // recursive traversal, so that we can construct a\n              // different flow scope based on the outcome. However,\n              // this would require a bunch of code and a bunch of\n              // extra computation for an edge case. This seems to be\n              // a \"good enough\" approximation.\n\n              // conditionOutcomes is cached from previous iterations\n              // of the loop.\n              if (conditionOutcomes == null) {\n                conditionOutcomes = condition.isAnd() ?\n                    traverseAnd(condition, output.createChildFlowScope()) :\n                    traverseOr(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition,\n                      conditionOutcomes.getOutcomeFlowScope(\n                          condition.getType(), branch == Branch.ON_TRUE),\n                      branch == Branch.ON_TRUE);\n            } else {\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope =\n                    traverse(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition, conditionFlowScope, branch == Branch.ON_TRUE);\n            }\n          }\n          break;\n      }\n\n      result.add(newScope.optimize());\n    }\n    return result;\n  }\n\n  private FlowScope traverse(Node n, FlowScope scope) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n        scope = traverseAssign(n, scope);\n        break;\n\n      case Token.NAME:\n        scope = traverseName(n, scope);\n        break;\n\n      case Token.GETPROP:\n        scope = traverseGetProp(n, scope);\n        break;\n\n      case Token.AND:\n        scope = traverseAnd(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.OR:\n        scope = traverseOr(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.HOOK:\n        scope = traverseHook(n, scope);\n        break;\n\n      case Token.OBJECTLIT:\n        scope = traverseObjectLiteral(n, scope);\n        break;\n\n      case Token.CALL:\n        scope = traverseCall(n, scope);\n        break;\n\n      case Token.NEW:\n        scope = traverseNew(n, scope);\n        break;\n\n      case Token.ASSIGN_ADD:\n      case Token.ADD:\n        scope = traverseAdd(n, scope);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        scope = traverse(n.getFirstChild(), scope);  // Find types.\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.ARRAYLIT:\n        scope = traverseArrayLiteral(n, scope);\n        break;\n\n      case Token.THIS:\n        n.setJSType(scope.getTypeOfThis());\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.ASSIGN_URSH:\n      case Token.URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_SUB:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITAND:\n      case Token.BITXOR:\n      case Token.BITOR:\n      case Token.MUL:\n      case Token.SUB:\n      case Token.DEC:\n      case Token.INC:\n      case Token.BITNOT:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.PARAM_LIST:\n        scope = traverse(n.getFirstChild(), scope);\n        n.setJSType(getJSType(n.getFirstChild()));\n        break;\n\n      case Token.COMMA:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getJSType(n.getLastChild()));\n        break;\n\n      case Token.TYPEOF:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(STRING_TYPE));\n        break;\n\n      case Token.DELPROP:\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.NOT:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\n        break;\n\n      case Token.GETELEM:\n        scope = traverseGetElem(n, scope);\n        break;\n\n      case Token.EXPR_RESULT:\n        scope = traverseChildren(n, scope);\n        if (n.getFirstChild().isGetProp()) {\n          ensurePropertyDeclared(n.getFirstChild());\n        }\n        break;\n\n      case Token.SWITCH:\n        scope = traverse(n.getFirstChild(), scope);\n        break;\n\n      case Token.RETURN:\n        scope = traverseReturn(n, scope);\n        break;\n\n      case Token.VAR:\n      case Token.THROW:\n        scope = traverseChildren(n, scope);\n        break;\n\n      case Token.CATCH:\n        scope = traverseCatch(n, scope);\n        break;\n    }\n    if (!n.isFunction()) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info != null && info.hasType()) {\n        JSType castType = info.getType().evaluate(syntacticScope, registry);\n\n        // A stubbed type cast on a qualified name should take\n        // effect for all subsequent accesses of that name,\n        // so treat it the same as an assign to that name.\n        if (n.isQualifiedName() &&\n            n.getParent().isExprResult()) {\n          updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n        }\n\n        n.setJSType(castType);\n      }\n    }\n\n    return scope;\n  }\n\n  /**\n   * Traverse a return value.\n   */\n  private FlowScope traverseReturn(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n\n    Node retValue = n.getFirstChild();\n    if (retValue != null) {\n      JSType type = functionScope.getRootNode().getJSType();\n      if (type != null) {\n        FunctionType fnType = type.toMaybeFunctionType();\n        if (fnType != null) {\n          inferPropertyTypesToMatchConstraint(\n              retValue.getJSType(), fnType.getReturnType());\n        }\n      }\n    }\n    return scope;\n  }\n\n  /**\n   * Any value can be thrown, so it's really impossible to determine the type\n   * of a CATCH param. Treat it as the UNKNOWN type.\n   */\n  private FlowScope traverseCatch(Node n, FlowScope scope) {\n    Node name = n.getFirstChild();\n    JSType type = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    name.setJSType(type);\n    redeclareSimpleVar(scope, name, type);\n    return scope;\n  }\n\n  private FlowScope traverseAssign(Node n, FlowScope scope) {\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n    scope = traverseChildren(n, scope);\n\n    JSType leftType = left.getJSType();\n    JSType rightType = getJSType(right);\n    n.setJSType(rightType);\n\n    updateScopeForTypeChange(scope, left, leftType, rightType);\n    return scope;\n  }\n\n  /**\n   * Updates the scope according to the result of a type change, like\n   * an assignment or a type cast.\n   */\n  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n\n        // When looking at VAR initializers for declared VARs, we trust\n        // the declared type over the type it's being initialized to.\n        // This has two purposes:\n        // 1) We avoid re-declaring declared variables so that built-in\n        //    types defined in externs are not redeclared.\n        // 2) When there's a lexical closure like\n        //    /** @type {?string} */ var x = null;\n        //    function f() { x = 'xyz'; }\n        //    the inference will ignore the lexical closure,\n        //    which is just wrong. This bug needs to be fixed eventually.\n        boolean isVarDeclaration = left.hasChildren();\n        if (!isVarDeclaration || var == null || var.isTypeInferred()) {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? getNativeType(UNKNOWN_TYPE) : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }\n\n  /**\n   * Defines a property if the property has not been defined yet.\n   */\n  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    JSType nodeType = getJSType(getprop.getFirstChild());\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else {\n      if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n        return;\n      }\n\n      if (!objectType.isPropertyTypeDeclared(propName)) {\n        // We do not want a \"stray\" assign to define an inferred property\n        // for every object of this type in the program. So we use a heuristic\n        // approach to determine whether to infer the propery.\n        //\n        // 1) If the property is already defined, join it with the previously\n        //    inferred type.\n        // 2) If this isn't an instance object, define it.\n        // 3) If the property of an object is being assigned in the constructor,\n        //    define it.\n        // 4) If this is a stub, define it.\n        // 5) Otherwise, do not define the type, but declare it in the registry\n        //    so that we can use it for missing property checks.\n        if (objectType.hasProperty(propName) ||\n            !objectType.isInstanceType()) {\n          if (\"prototype\".equals(propName)) {\n            objectType.defineDeclaredProperty(\n                propName, rightType, getprop);\n          } else {\n            objectType.defineInferredProperty(\n                propName, rightType, getprop);\n          }\n        } else {\n          if (getprop.getFirstChild().isThis() &&\n              getJSType(syntacticScope.getRootNode()).isConstructor()) {\n            objectType.defineInferredProperty(\n                propName, rightType, getprop);\n          } else {\n            registry.registerPropertyOnType(propName, objectType);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Defines a declared property if it has not been defined yet.\n   *\n   * This handles the case where a property is declared on an object where\n   * the object type is inferred, and so the object type will not\n   * be known in {@code TypedScopeCreator}.\n   */\n  private void ensurePropertyDeclared(Node getprop) {\n    ObjectType ownerType = ObjectType.cast(\n        getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined());\n    if (ownerType != null) {\n      ensurePropertyDeclaredHelper(getprop, ownerType);\n    }\n  }\n\n  /**\n   * Declares a property on its owner, if necessary.\n   * @return True if a property was declared.\n   */\n  private boolean ensurePropertyDeclaredHelper(\n      Node getprop, ObjectType objectType) {\n    String propName = getprop.getLastChild().getString();\n    String qName = getprop.getQualifiedName();\n    if (qName != null) {\n      Var var = syntacticScope.getVar(qName);\n      if (var != null && !var.isTypeInferred()) {\n        // Handle normal declarations that could not be addressed earlier.\n        if (propName.equals(\"prototype\") ||\n        // Handle prototype declarations that could not be addressed earlier.\n            (!objectType.hasOwnProperty(propName) &&\n             (!objectType.isInstanceType() ||\n                 (var.isExtern() && !objectType.isNativeObjectType())))) {\n          return objectType.defineDeclaredProperty(\n              propName, var.getType(), getprop);\n        }\n      }\n    }\n    return false;\n  }\n\n  private FlowScope traverseName(Node n, FlowScope scope) {\n    String varName = n.getString();\n    Node value = n.getFirstChild();\n    JSType type = n.getJSType();\n    if (value != null) {\n      scope = traverse(value, scope);\n      updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,\n          getJSType(value));\n      return scope;\n    } else {\n      StaticSlot<JSType> var = scope.getSlot(varName);\n      if (var != null) {\n        // There are two situations where we don't want to use type information\n        // from the scope, even if we have it.\n\n        // 1) The var is escaped in a weird way, e.g.,\n        // function f() { var x = 3; function g() { x = null } (x); }\n        boolean isInferred = var.isTypeInferred();\n        boolean unflowable = isInferred &&\n            isUnflowable(syntacticScope.getVar(varName));\n\n        // 2) We're reading type information from another scope for an\n        // inferred variable.\n        // var t = null; function f() { (t); }\n        boolean nonLocalInferredSlot =\n            isInferred &&\n            syntacticScope.getParent() != null &&\n            var == syntacticScope.getParent().getSlot(varName);\n\n        if (!unflowable && !nonLocalInferredSlot) {\n          type = var.getType();\n          if (type == null) {\n            type = getNativeType(UNKNOWN_TYPE);\n          }\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }\n\n  /** Traverse each element of the array. */\n  private FlowScope traverseArrayLiteral(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n    n.setJSType(getNativeType(ARRAY_TYPE));\n    return scope;\n  }\n\n  private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n      scope = traverse(name.getFirstChild(), scope);\n    }\n\n    // Object literals can be reflected on other types, or changed with\n    // type casts.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    // TODO(nicksantos): There should be an \"anonymous object\" type that\n    // we can check for here.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n      return scope;\n    }\n\n    boolean hasLendsName = n.getJSDocInfo() != null &&\n        n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n      return scope;\n    }\n\n    String qObjName = NodeUtil.getBestLValueName(\n        NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null;\n         name = name.getNext()) {\n      Node value = name.getFirstChild();\n      String memberName = NodeUtil.getObjectLitKeyName(name);\n      if (memberName != null) {\n        JSType rawValueType =  name.getFirstChild().getJSType();\n        JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(\n            name, rawValueType);\n        if (valueType == null) {\n          valueType = getNativeType(UNKNOWN_TYPE);\n        }\n        objectType.defineInferredProperty(memberName, valueType, name);\n\n        // Do normal flow inference if this is a direct property assignment.\n        if (qObjName != null && name.isString()) {\n          String qKeyName = qObjName + \".\" + memberName;\n          Var var = syntacticScope.getVar(qKeyName);\n          JSType oldType = var == null ? null : var.getType();\n          if (var != null && var.isTypeInferred()) {\n            var.setType(oldType == null ?\n                valueType : oldType.getLeastSupertype(oldType));\n          }\n\n          scope.inferQualifiedSlot(name, qKeyName,\n              oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType,\n              valueType);\n        }\n      } else {\n        n.setJSType(getNativeType(UNKNOWN_TYPE));\n      }\n    }\n    return scope;\n  }\n\n  private FlowScope traverseAdd(Node n, FlowScope scope) {\n    Node left = n.getFirstChild();\n    Node right = left.getNext();\n    scope = traverseChildren(n, scope);\n\n    JSType leftType = left.getJSType();\n    JSType rightType = right.getJSType();\n\n    JSType type = getNativeType(UNKNOWN_TYPE);\n    if (leftType != null && rightType != null) {\n      boolean leftIsUnknown = leftType.isUnknownType();\n      boolean rightIsUnknown = rightType.isUnknownType();\n      if (leftIsUnknown && rightIsUnknown) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else if ((!leftIsUnknown && leftType.isString()) ||\n                 (!rightIsUnknown && rightType.isString())) {\n        type = getNativeType(STRING_TYPE);\n      } else if (leftIsUnknown || rightIsUnknown) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else if (isAddedAsNumber(leftType) && isAddedAsNumber(rightType)) {\n        type = getNativeType(NUMBER_TYPE);\n      } else {\n        type = registry.createUnionType(STRING_TYPE, NUMBER_TYPE);\n      }\n    }\n    n.setJSType(type);\n\n    if (n.isAssignAdd()) {\n      updateScopeForTypeChange(scope, left, leftType, type);\n    }\n\n    return scope;\n  }\n\n  private boolean isAddedAsNumber(JSType type) {\n    return type.isSubtype(registry.createUnionType(VOID_TYPE, NULL_TYPE,\n        NUMBER_VALUE_OR_OBJECT_TYPE, BOOLEAN_TYPE, BOOLEAN_OBJECT_TYPE));\n  }\n\n  private FlowScope traverseHook(Node n, FlowScope scope) {\n    Node condition = n.getFirstChild();\n    Node trueNode = condition.getNext();\n    Node falseNode = n.getLastChild();\n\n    // verify the condition\n    scope = traverse(condition, scope);\n\n    // reverse abstract interpret the condition to produce two new scopes\n    FlowScope trueScope = reverseInterpreter.\n        getPreciserScopeKnowingConditionOutcome(\n            condition, scope, true);\n    FlowScope falseScope = reverseInterpreter.\n        getPreciserScopeKnowingConditionOutcome(\n            condition, scope, false);\n\n    // traverse the true node with the trueScope\n    traverse(trueNode, trueScope.createChildFlowScope());\n\n    // traverse the false node with the falseScope\n    traverse(falseNode, falseScope.createChildFlowScope());\n\n    // meet true and false nodes' types and assign\n    JSType trueType = trueNode.getJSType();\n    JSType falseType = falseNode.getJSType();\n    if (trueType != null && falseType != null) {\n      n.setJSType(trueType.getLeastSupertype(falseType));\n    } else {\n      n.setJSType(null);\n    }\n\n    return scope.createChildFlowScope();\n  }\n\n  private FlowScope traverseCall(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n\n    Node left = n.getFirstChild();\n    JSType functionType = getJSType(left).restrictByNotNullOrUndefined();\n    if (functionType != null) {\n      if (functionType.isFunctionType()) {\n        FunctionType fnType = functionType.toMaybeFunctionType();\n        n.setJSType(fnType.getReturnType());\n        backwardsInferenceFromCallSite(n, fnType);\n      } else if (functionType.equals(getNativeType(CHECKED_UNKNOWN_TYPE))) {\n        n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE));\n      }\n    }\n\n    scope = tightenTypesAfterAssertions(scope, n);\n    return scope;\n  }\n\n  private FlowScope tightenTypesAfterAssertions(FlowScope scope,\n      Node callNode) {\n    Node left = callNode.getFirstChild();\n    Node firstParam = left.getNext();\n    AssertionFunctionSpec assertionFunctionSpec =\n        assertionFunctionsMap.get(left.getQualifiedName());\n    if (assertionFunctionSpec == null || firstParam == null) {\n      return scope;\n    }\n    Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam);\n    if (assertedNode == null) {\n      return scope;\n    }\n    JSTypeNative assertedType = assertionFunctionSpec.getAssertedType();\n    String assertedNodeName = assertedNode.getQualifiedName();\n    // Handle assertions that enforce expressions evaluate to true.\n    if (assertedType == null) {\n      if (assertedNodeName != null) {\n        JSType type = getJSType(assertedNode);\n        JSType narrowed = type.restrictByNotNullOrUndefined();\n        if (type != narrowed) {\n          scope = narrowScope(scope, assertedNode, narrowed);\n          callNode.setJSType(narrowed);\n        }\n      } else if (assertedNode.isAnd() ||\n                 assertedNode.isOr()) {\n        BooleanOutcomePair conditionOutcomes =\n            traverseWithinShortCircuitingBinOp(assertedNode, scope);\n        scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n            assertedNode, conditionOutcomes.getOutcomeFlowScope(\n                assertedNode.getType(), true), true);\n      }\n    } else if (assertedNodeName != null) {\n      // Handle assertions that enforce expressions are of a certain type.\n      JSType type = getJSType(assertedNode);\n      JSType narrowed = type.getGreatestSubtype(getNativeType(assertedType));\n      if (type != narrowed) {\n        scope = narrowScope(scope, assertedNode, narrowed);\n        callNode.setJSType(narrowed);\n      }\n    }\n    return scope;\n  }\n\n  private FlowScope narrowScope(FlowScope scope, Node node, JSType narrowed) {\n    scope = scope.createChildFlowScope();\n    if (node.isGetProp()) {\n      scope.inferQualifiedSlot(\n          node, node.getQualifiedName(), getJSType(node), narrowed);\n    } else {\n      redeclareSimpleVar(scope, node, narrowed);\n    }\n    return scope;\n  }\n\n  /**\n   * We only do forward type inference. We do not do full backwards\n   * type inference.\n   *\n   * In other words, if we have,\n   * <code>\n   * var x = f();\n   * g(x);\n   * </code>\n   * a forward type-inference engine would try to figure out the type\n   * of \"x\" from the return type of \"f\". A backwards type-inference engine\n   * would try to figure out the type of \"x\" from the parameter type of \"g\".\n   *\n   * However, there are a few special syntactic forms where we do some\n   * some half-assed backwards type-inference, because programmers\n   * expect it in this day and age. To take an example from java,\n   * <code>\n   * List<String> x = Lists.newArrayList();\n   * </code>\n   * The Java compiler will be able to infer the generic type of the List\n   * returned by newArrayList().\n   *\n   * In much the same way, we do some special-case backwards inference for\n   * JS. Those cases are enumerated here.\n   */\n  private void backwardsInferenceFromCallSite(Node n, FunctionType fnType) {\n    updateTypeOfParameters(n, fnType);\n    updateTypeOfThisOnClosure(n, fnType);\n    updateBind(n, fnType);\n  }\n\n  /**\n   * When \"bind\" is called on a function, we infer the type of the returned\n   * \"bound\" function by looking at the number of parameters in the call site.\n   */\n  private void updateBind(Node n, FunctionType fnType) {\n    // TODO(nicksantos): Use the coding convention, so that we get goog.bind\n    // for free.\n    Node calledFn = n.getFirstChild();\n    boolean looksLikeBind = calledFn.isGetProp()\n        && calledFn.getLastChild().getString().equals(\"bind\");\n    if (!looksLikeBind) {\n      return;\n    }\n\n    Node callTarget = calledFn.getFirstChild();\n    FunctionType callTargetFn = getJSType(callTarget)\n        .restrictByNotNullOrUndefined().toMaybeFunctionType();\n    if (callTargetFn == null) {\n      return;\n    }\n\n    n.setJSType(callTargetFn.getBindReturnType(n.getChildCount() - 1));\n  }\n\n  /**\n   * For functions with function parameters, type inference will set the type of\n   * a function literal argument from the function parameter type.\n   */\n  private void updateTypeOfParameters(Node n, FunctionType fnType) {\n    int i = 0;\n    int childCount = n.getChildCount();\n    for (Node iParameter : fnType.getParameters()) {\n      if (i + 1 >= childCount) {\n        // TypeCheck#visitParametersList will warn so we bail.\n        return;\n      }\n\n      JSType iParameterType = getJSType(iParameter);\n      Node iArgument = n.getChildAtIndex(i + 1);\n      JSType iArgumentType = getJSType(iArgument);\n      inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType);\n\n      if (iParameterType.isFunctionType()) {\n        FunctionType iParameterFnType = iParameterType.toMaybeFunctionType();\n\n        if (iArgument.isFunction() &&\n            iArgumentType.isFunctionType() &&\n            iArgument.getJSDocInfo() == null) {\n          iArgument.setJSType(iParameterFnType);\n        }\n      }\n      i++;\n    }\n  }\n\n  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   */\n  private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n    // TODO(user): Make the template logic more general.\n\n    if (fnType.getTemplateTypeName() == null) {\n      return;\n    }\n\n    int i = 0;\n    int childCount = n.getChildCount();\n    // Find the parameter whose type is the template type.\n    for (Node iParameter : fnType.getParameters()) {\n      JSType iParameterType =\n          getJSType(iParameter).restrictByNotNullOrUndefined();\n      if (iParameterType.isTemplateType()) {\n        // Find the actual type of this argument.\n        ObjectType iArgumentType = null;\n        if (i + 1 < childCount) {\n          Node iArgument = n.getChildAtIndex(i + 1);\n          iArgumentType = getJSType(iArgument)\n              .restrictByNotNullOrUndefined()\n              .collapseUnion()\n              .toObjectType();\n          if (iArgumentType == null) {\n            compiler.report(\n                JSError.make(NodeUtil.getSourceName(iArgument), iArgument,\n                    TEMPLATE_TYPE_NOT_OBJECT_TYPE,\n                    getJSType(iArgument).toString()));\n            return;\n          }\n        }\n\n        // Find the parameter whose type is function(this: T, ...)\n        boolean foundTemplateTypeOfThisParameter = false;\n        int j = 0;\n        for (Node jParameter : fnType.getParameters()) {\n          JSType jParameterType =\n              getJSType(jParameter).restrictByNotNullOrUndefined();\n          if (jParameterType.isFunctionType()) {\n            FunctionType jParameterFnType = jParameterType.toMaybeFunctionType();\n            if (jParameterFnType.getTypeOfThis().equals(iParameterType)) {\n              foundTemplateTypeOfThisParameter = true;\n              // Find the actual type of the this argument.\n              if (j + 1 >= childCount) {\n                // TypeCheck#visitParameterList will warn so we bail.\n                return;\n              }\n              Node jArgument = n.getChildAtIndex(j + 1);\n              JSType jArgumentType = getJSType(jArgument);\n              if (jArgument.isFunction() &&\n                  jArgumentType.isFunctionType()) {\n                if (iArgumentType != null &&\n                    // null and undefined get filtered out above.\n                    !iArgumentType.isNoType()) {\n                  // If it's an function expression, update the type of this\n                  // using the actual type of T.\n                  FunctionType jArgumentFnType = jArgumentType.toMaybeFunctionType();\n                  if (jArgumentFnType.getTypeOfThis().isUnknownType()) {\n                    // The new type will be picked up when we traverse the inner\n                    // function.\n                    jArgument.setJSType(\n                        registry.createFunctionTypeWithNewThisType(\n                            jArgumentFnType, iArgumentType));\n                  }\n                } else {\n                  // Warn if the anonymous function literal references this.\n                  if (NodeUtil.referencesThis(\n                          NodeUtil.getFunctionBody(jArgument))) {\n                    compiler.report(JSError.make(NodeUtil.getSourceName(n), n,\n                        FUNCTION_LITERAL_UNDEFINED_THIS));\n                  }\n                }\n              }\n              // TODO(user): Add code to TypeCheck to check that the\n              // types of the arguments match.\n            }\n          }\n          j++;\n        }\n\n        if (!foundTemplateTypeOfThisParameter) {\n          compiler.report(JSError.make(NodeUtil.getSourceName(n), n,\n              TEMPLATE_TYPE_OF_THIS_EXPECTED));\n          return;\n        }\n      }\n      i++;\n    }\n  }\n\n  private FlowScope traverseNew(Node n, FlowScope scope) {\n    Node constructor = n.getFirstChild();\n    scope = traverse(constructor, scope);\n\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n        }\n      }\n    }\n    n.setJSType(type);\n\n    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }\n    return scope;\n  }\n\n  private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) {\n    return traverseShortCircuitingBinOp(n, scope, true);\n  }\n\n  private FlowScope traverseChildren(Node n, FlowScope scope) {\n    for (Node el = n.getFirstChild(); el != null; el = el.getNext()) {\n      scope = traverse(el, scope);\n    }\n    return scope;\n  }\n\n  private FlowScope traverseGetElem(Node n, FlowScope scope) {\n    scope = traverseChildren(n, scope);\n    ObjectType objType = ObjectType.cast(\n        getJSType(n.getFirstChild()).restrictByNotNullOrUndefined());\n    if (objType != null) {\n      JSType type = objType.getParameterType();\n      if (type != null) {\n        n.setJSType(type);\n      }\n    }\n    return dereferencePointer(n.getFirstChild(), scope);\n  }\n\n  private FlowScope traverseGetProp(Node n, FlowScope scope) {\n    Node objNode = n.getFirstChild();\n    Node property = n.getLastChild();\n    scope = traverseChildren(n, scope);\n    n.setJSType(\n        getPropertyType(\n            objNode.getJSType(), property.getString(), n, scope));\n    return dereferencePointer(n.getFirstChild(), scope);\n  }\n\n  /**\n   * Suppose X is an object with inferred properties.\n   * Suppose also that X is used in a way where it would only type-check\n   * correctly if some of those properties are widened.\n   * Then we should be polite and automatically widen X's properties for him.\n   *\n   * For a concrete example, consider:\n   * param x {{prop: (number|undefined)}}\n   * function f(x) {}\n   * f({});\n   *\n   * If we give the anonymous object an inferred property of (number|undefined),\n   * then this code will type-check appropriately.\n   */\n  private void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (constraintObj != null && constraintObj.isRecordType()) {\n      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n      if (objType != null) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n          JSType propType = constraintObj.getPropertyType(prop);\n          if (!objType.isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!objType.hasProperty(prop)) {\n              typeToInfer =\n                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n            }\n            objType.defineInferredProperty(prop, typeToInfer, null);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * If we access a property of a symbol, then that symbol is not\n   * null or undefined.\n   */\n  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n    if (n.isQualifiedName()) {\n      JSType type = getJSType(n);\n      JSType narrowed = type.restrictByNotNullOrUndefined();\n      if (type != narrowed) {\n        scope = narrowScope(scope, n, narrowed);\n      }\n    }\n    return scope;\n  }\n\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope) {\n    // Scopes sometimes contain inferred type info about qualified names.\n    String qualifiedName = n.getQualifiedName();\n    StaticSlot<JSType> var = scope.getSlot(qualifiedName);\n    if (var != null) {\n      JSType varType = var.getType();\n      if (varType != null) {\n        if (varType.equals(getNativeType(UNKNOWN_TYPE)) &&\n            var != syntacticScope.getSlot(qualifiedName)) {\n          // If the type of this qualified name has been checked in this scope,\n          // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n          return getNativeType(CHECKED_UNKNOWN_TYPE);\n        } else {\n          return varType;\n        }\n      }\n    }\n\n    JSType propertyType = null;\n    if (objType != null) {\n      propertyType = objType.findPropertyType(propName);\n    }\n\n    if ((propertyType == null || propertyType.isUnknownType()) &&\n        qualifiedName != null) {\n      // If we find this node in the registry, then we can infer its type.\n      ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));\n      if (regType != null) {\n        propertyType = regType.getConstructor();\n      }\n    }\n\n    return propertyType;\n  }\n\n  private BooleanOutcomePair traverseOr(Node n, FlowScope scope) {\n    return traverseShortCircuitingBinOp(n, scope, false);\n  }\n\n  private BooleanOutcomePair traverseShortCircuitingBinOp(\n      Node n, FlowScope scope, boolean condition) {\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n\n    // type the left node\n    BooleanOutcomePair leftLiterals =\n        traverseWithinShortCircuitingBinOp(left,\n            scope.createChildFlowScope());\n    JSType leftType = left.getJSType();\n\n    // reverse abstract interpret the left node to produce the correct\n    // scope in which to verify the right node\n    FlowScope rightScope = reverseInterpreter.\n        getPreciserScopeKnowingConditionOutcome(\n            left, leftLiterals.getOutcomeFlowScope(left.getType(), condition),\n            condition);\n\n    // type the right node\n    BooleanOutcomePair rightLiterals =\n        traverseWithinShortCircuitingBinOp(\n            right, rightScope.createChildFlowScope());\n    JSType rightType = right.getJSType();\n\n    JSType type;\n    BooleanOutcomePair literals;\n    if (leftType != null && rightType != null) {\n      leftType = leftType.getRestrictedTypeGivenToBooleanOutcome(!condition);\n      if (leftLiterals.toBooleanOutcomes ==\n          BooleanLiteralSet.get(!condition)) {\n        // Use the restricted left type, since the right side never gets\n        // evaluated.\n        type = leftType;\n        literals = leftLiterals;\n      } else {\n        // Use the join of the restricted left type knowing the outcome of the\n        // ToBoolean predicate and of the right type.\n        type = leftType.getLeastSupertype(rightType);\n        literals =\n            getBooleanOutcomePair(leftLiterals, rightLiterals, condition);\n      }\n\n      // Exclude the boolean type if the literal set is empty because a boolean\n      // can never actually be returned.\n      if (literals.booleanValues == BooleanLiteralSet.EMPTY &&\n          getNativeType(BOOLEAN_TYPE).isSubtype(type)) {\n        // Exclusion only make sense for a union type.\n        if (type.isUnionType()) {\n          type = type.toMaybeUnionType().getRestrictedUnion(\n              getNativeType(BOOLEAN_TYPE));\n        }\n      }\n    } else {\n      type = null;\n      literals = new BooleanOutcomePair(\n          BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH,\n          leftLiterals.getJoinedFlowScope(),\n          rightLiterals.getJoinedFlowScope());\n    }\n    n.setJSType(type);\n\n    return literals;\n  }\n\n  private BooleanOutcomePair traverseWithinShortCircuitingBinOp(Node n,\n      FlowScope scope) {\n    switch (n.getType()) {\n      case Token.AND:\n        return traverseAnd(n, scope);\n\n      case Token.OR:\n        return traverseOr(n, scope);\n\n      default:\n        scope = traverse(n, scope);\n        return newBooleanOutcomePair(n.getJSType(), scope);\n    }\n  }\n\n  /**\n   * Infers the boolean outcome pair that can be taken by a\n   * short-circuiting binary operation ({@code &&} or {@code ||}).\n   * @see #getBooleanOutcomes(BooleanLiteralSet, BooleanLiteralSet, boolean)\n   */\n  BooleanOutcomePair getBooleanOutcomePair(BooleanOutcomePair left,\n      BooleanOutcomePair right, boolean condition) {\n    return new BooleanOutcomePair(\n        getBooleanOutcomes(left.toBooleanOutcomes, right.toBooleanOutcomes,\n                           condition),\n        getBooleanOutcomes(left.booleanValues, right.booleanValues, condition),\n        left.getJoinedFlowScope(), right.getJoinedFlowScope());\n  }\n\n  /**\n   * Infers the boolean literal set that can be taken by a\n   * short-circuiting binary operation ({@code &&} or {@code ||}).\n   * @param left the set of possible {@code ToBoolean} predicate results for\n   *    the expression on the left side of the operator\n   * @param right the set of possible {@code ToBoolean} predicate results for\n   *    the expression on the right side of the operator\n   * @param condition the left side {@code ToBoolean} predicate result that\n   *    causes the right side to get evaluated (i.e. not short-circuited)\n   * @return a set of possible {@code ToBoolean} predicate results for the\n   *    entire expression\n   */\n  static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left,\n      BooleanLiteralSet right, boolean condition) {\n    return right.union(left.intersection(BooleanLiteralSet.get(!condition)));\n  }\n\n  /**\n   * When traversing short-circuiting binary operations, we need to keep track\n   * of two sets of boolean literals:\n   * 1. {@code toBooleanOutcomes}: boolean literals as converted from any types,\n   * 2. {@code booleanValues}: boolean literals from just boolean types.\n   */\n  private final class BooleanOutcomePair {\n    final BooleanLiteralSet toBooleanOutcomes;\n    final BooleanLiteralSet booleanValues;\n\n    // The scope if only half of the expression executed, when applicable.\n    final FlowScope leftScope;\n\n    // The scope when the whole expression executed.\n    final FlowScope rightScope;\n\n    // The scope when we don't know how much of the expression is executed.\n    FlowScope joinedScope = null;\n\n    BooleanOutcomePair(\n        BooleanLiteralSet toBooleanOutcomes, BooleanLiteralSet booleanValues,\n        FlowScope leftScope, FlowScope rightScope) {\n      this.toBooleanOutcomes = toBooleanOutcomes;\n      this.booleanValues = booleanValues;\n      this.leftScope = leftScope;\n      this.rightScope = rightScope;\n    }\n\n    /**\n     * Gets the safe estimated scope without knowing if all of the\n     * subexpressions will be evaluated.\n     */\n    FlowScope getJoinedFlowScope() {\n      if (joinedScope == null) {\n        if (leftScope == rightScope) {\n          joinedScope = rightScope;\n        } else {\n          joinedScope = join(leftScope, rightScope);\n        }\n      }\n      return joinedScope;\n    }\n\n    /**\n     * Gets the outcome scope if we do know the outcome of the entire\n     * expression.\n     */\n    FlowScope getOutcomeFlowScope(int nodeType, boolean outcome) {\n      if (nodeType == Token.AND && outcome ||\n          nodeType == Token.OR && !outcome) {\n        // We know that the whole expression must have executed.\n        return rightScope;\n      } else {\n        return getJoinedFlowScope();\n      }\n    }\n  }\n\n  private BooleanOutcomePair newBooleanOutcomePair(\n      JSType jsType, FlowScope flowScope) {\n    if (jsType == null) {\n      return new BooleanOutcomePair(\n          BooleanLiteralSet.BOTH, BooleanLiteralSet.BOTH, flowScope, flowScope);\n    }\n    return new BooleanOutcomePair(jsType.getPossibleToBooleanOutcomes(),\n        registry.getNativeType(BOOLEAN_TYPE).isSubtype(jsType) ?\n            BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY,\n        flowScope, flowScope);\n  }\n\n  private void redeclareSimpleVar(\n      FlowScope scope, Node nameNode, JSType varType) {\n    Preconditions.checkState(nameNode.isName());\n    String varName = nameNode.getString();\n    if (varType == null) {\n      varType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    if (isUnflowable(syntacticScope.getVar(varName))) {\n      return;\n    }\n    scope.inferSlotType(varName, varType);\n  }\n\n  private boolean isUnflowable(Var v) {\n    return v != null && v.isLocal() && v.isMarkedEscaped() &&\n        // It's OK to flow a variable in the scope where it's escaped.\n        v.getScope() == syntacticScope;\n  }\n\n  /**\n   * This method gets the JSType from the Node argument and verifies that it is\n   * present.\n   */\n  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }\n\n  private JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"type\": \"NullPointerException\",\n      \"description\": \"The 'compiler' field is not null-checked before being used. If it's null, this could lead to a NullPointerException.\",\n      \"location\": \"TypeInference constructor\"\n    },\n    {\n      \"type\": \"UncheckedReturnValue\",\n      \"description\": \"The method 'traverse' is not checking the return value of 'reverseInterpreter.interpret'. This could lead to unchecked exceptions being thrown.\",\n      \"location\": \"traverse method\"\n    },\n    {\n      \"type\": \"PotentialNullDereference\",\n      \"description\": \"The 'assertionFunctionsMap' field is not null-checked before being used. If it's null, this could lead to a NullPointerException when trying to access 'assertionFunctionsMap.get'.\",\n      \"location\": \"TypeInference constructor\"\n    },\n    {\n      \"type\": \"UnreachableCode\",\n      \"description\": \"The 'fallthrough' case in the 'branchedFlowThrough' method is not handled. This could lead to unexpected behavior or exceptions.\",\n      \"location\": \"branchedFlowThrough method\"\n    }\n  ]\n}"}}