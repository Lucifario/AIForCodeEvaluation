{"sample_id": "Math_25", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.optimization.fitting;\n\nimport org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer;\nimport org.apache.commons.math3.analysis.function.HarmonicOscillator;\nimport org.apache.commons.math3.exception.ZeroException;\nimport org.apache.commons.math3.exception.NumberIsTooSmallException;\nimport org.apache.commons.math3.exception.MathIllegalStateException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\n\n/**\n * Class that implements a curve fitting specialized for sinusoids.\n *\n * Harmonic fitting is a very simple case of curve fitting. The\n * estimated coefficients are the amplitude a, the pulsation &omega; and\n * the phase &phi;: <code>f (t) = a cos (&omega; t + &phi;)</code>. They are\n * searched by a least square estimator initialized with a rough guess\n * based on integrals.\n *\n * @version $Id$\n * @since 2.0\n */\npublic class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> {\n    /**\n     * Simple constructor.\n     * @param optimizer Optimizer to use for the fitting.\n     */\n    public HarmonicFitter(final DifferentiableMultivariateVectorOptimizer optimizer) {\n        super(optimizer);\n    }\n\n    /**\n     * Fit an harmonic function to the observed points.\n     *\n     * @param initialGuess First guess values in the following order:\n     * <ul>\n     *  <li>Amplitude</li>\n     *  <li>Angular frequency</li>\n     *  <li>Phase</li>\n     * </ul>\n     * @return the parameters of the harmonic function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit(double[] initialGuess) {\n        return fit(new HarmonicOscillator.Parametric(), initialGuess);\n    }\n\n    /**\n     * Fit an harmonic function to the observed points.\n     * An initial guess will be automatically computed.\n     *\n     * @return the parameters of the harmonic function that best fits the\n     * observed points (see the other {@link #fit(double[]) fit} method.\n     * @throws NumberIsTooSmallException if the sample is too short for the\n     * the first guess to be computed.\n     * @throws ZeroException if the first guess cannot be computed because\n     * the abscissa range is zero.\n     */\n    public double[] fit() {\n        return fit((new ParameterGuesser(getObservations())).guess());\n    }\n\n    /**\n     * This class guesses harmonic coefficients from a sample.\n     * <p>The algorithm used to guess the coefficients is as follows:</p>\n     *\n     * <p>We know f (t) at some sampling points t<sub>i</sub> and want to find a,\n     * &omega; and &phi; such that f (t) = a cos (&omega; t + &phi;).\n     * </p>\n     *\n     * <p>From the analytical expression, we can compute two primitives :\n     * <pre>\n     *     If2  (t) = &int; f<sup>2</sup>  = a<sup>2</sup> &times; [t + S (t)] / 2\n     *     If'2 (t) = &int; f'<sup>2</sup> = a<sup>2</sup> &omega;<sup>2</sup> &times; [t - S (t)] / 2\n     *     where S (t) = sin (2 (&omega; t + &phi;)) / (2 &omega;)\n     * </pre>\n     * </p>\n     *\n     * <p>We can remove S between these expressions :\n     * <pre>\n     *     If'2 (t) = a<sup>2</sup> &omega;<sup>2</sup> t - &omega;<sup>2</sup> If2 (t)\n     * </pre>\n     * </p>\n     *\n     * <p>The preceding expression shows that If'2 (t) is a linear\n     * combination of both t and If2 (t): If'2 (t) = A &times; t + B &times; If2 (t)\n     * </p>\n     *\n     * <p>From the primitive, we can deduce the same form for definite\n     * integrals between t<sub>1</sub> and t<sub>i</sub> for each t<sub>i</sub> :\n     * <pre>\n     *   If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>) = A &times; (t<sub>i</sub> - t<sub>1</sub>) + B &times; (If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>))\n     * </pre>\n     * </p>\n     *\n     * <p>We can find the coefficients A and B that best fit the sample\n     * to this linear expression by computing the definite integrals for\n     * each sample points.\n     * </p>\n     *\n     * <p>For a bilinear expression z (x<sub>i</sub>, y<sub>i</sub>) = A &times; x<sub>i</sub> + B &times; y<sub>i</sub>, the\n     * coefficients A and B that minimize a least square criterion\n     * &sum; (z<sub>i</sub> - z (x<sub>i</sub>, y<sub>i</sub>))<sup>2</sup> are given by these expressions:</p>\n     * <pre>\n     *\n     *         &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n     *     A = ------------------------\n     *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n     *\n     *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub>\n     *     B = ------------------------\n     *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n     * </pre>\n     * </p>\n     *\n     *\n     * <p>In fact, we can assume both a and &omega; are positive and\n     * compute them directly, knowing that A = a<sup>2</sup> &omega;<sup>2</sup> and that\n     * B = - &omega;<sup>2</sup>. The complete algorithm is therefore:</p>\n     * <pre>\n     *\n     * for each t<sub>i</sub> from t<sub>1</sub> to t<sub>n-1</sub>, compute:\n     *   f  (t<sub>i</sub>)\n     *   f' (t<sub>i</sub>) = (f (t<sub>i+1</sub>) - f(t<sub>i-1</sub>)) / (t<sub>i+1</sub> - t<sub>i-1</sub>)\n     *   x<sub>i</sub> = t<sub>i</sub> - t<sub>1</sub>\n     *   y<sub>i</sub> = &int; f<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>\n     *   z<sub>i</sub> = &int; f'<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>\n     *   update the sums &sum;x<sub>i</sub>x<sub>i</sub>, &sum;y<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>z<sub>i</sub> and &sum;y<sub>i</sub>z<sub>i</sub>\n     * end for\n     *\n     *            |--------------------------\n     *         \\  | &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n     * a     =  \\ | ------------------------\n     *           \\| &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n     *\n     *\n     *            |--------------------------\n     *         \\  | &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n     * &omega;     =  \\ | ------------------------\n     *           \\| &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n     *\n     * </pre>\n     * </p>\n     *\n     * <p>Once we know &omega;, we can compute:\n     * <pre>\n     *    fc = &omega; f (t) cos (&omega; t) - f' (t) sin (&omega; t)\n     *    fs = &omega; f (t) sin (&omega; t) + f' (t) cos (&omega; t)\n     * </pre>\n     * </p>\n     *\n     * <p>It appears that <code>fc = a &omega; cos (&phi;)</code> and\n     * <code>fs = -a &omega; sin (&phi;)</code>, so we can use these\n     * expressions to compute &phi;. The best estimate over the sample is\n     * given by averaging these expressions.\n     * </p>\n     *\n     * <p>Since integrals and means are involved in the preceding\n     * estimations, these operations run in O(n) time, where n is the\n     * number of measurements.</p>\n     */\n    public static class ParameterGuesser {\n        /** Sampled observations. */\n        private final WeightedObservedPoint[] observations;\n        /** Amplitude. */\n        private double a;\n        /** Angular frequency. */\n        private double omega;\n        /** Phase. */\n        private double phi;\n\n        /**\n         * Simple constructor.\n         * @param observations sampled observations\n         * @throws NumberIsTooSmallException if the sample is too short or if\n         * the first guess cannot be computed.\n         */\n        public ParameterGuesser(WeightedObservedPoint[] observations) {\n            if (observations.length < 4) {\n                throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n                                                    observations.length, 4, true);\n            }\n\n            this.observations = observations.clone();\n        }\n\n        /**\n         * Estimate a first guess of the coefficients.\n         *\n         * @return the guessed coefficients, in the following order:\n         * <ul>\n         *  <li>Amplitude</li>\n         *  <li>Angular frequency</li>\n         *  <li>Phase</li>\n         * </ul>\n         */\n        public double[] guess() {\n            sortObservations();\n            guessAOmega();\n            guessPhi();\n            return new double[] { a, omega, phi };\n        }\n\n        /**\n         * Sort the observations with respect to the abscissa.\n         */\n        private void sortObservations() {\n            // Since the samples are almost always already sorted, this\n            // method is implemented as an insertion sort that reorders the\n            // elements in place. Insertion sort is very efficient in this case.\n            WeightedObservedPoint curr = observations[0];\n            for (int j = 1; j < observations.length; ++j) {\n                WeightedObservedPoint prec = curr;\n                curr = observations[j];\n                if (curr.getX() < prec.getX()) {\n                    // the current element should be inserted closer to the beginning\n                    int i = j - 1;\n                    WeightedObservedPoint mI = observations[i];\n                    while ((i >= 0) && (curr.getX() < mI.getX())) {\n                        observations[i + 1] = mI;\n                        if (i-- != 0) {\n                            mI = observations[i];\n                        }\n                    }\n                    observations[i + 1] = curr;\n                    curr = observations[j];\n                }\n            }\n        }\n\n        /**\n         * Estimate a first guess of the amplitude and angular frequency.\n         * This method assumes that the {@link #sortObservations()} method\n         * has been called previously.\n         *\n         * @throws ZeroException if the abscissa range is zero.\n         * @throws MathIllegalStateException when the guessing procedure cannot\n         * produce sensible results.\n         */\n        private void guessAOmega() {\n            // initialize the sums for the linear model between the two integrals\n            double sx2 = 0;\n            double sy2 = 0;\n            double sxy = 0;\n            double sxz = 0;\n            double syz = 0;\n\n            double currentX = observations[0].getX();\n            double currentY = observations[0].getY();\n            double f2Integral = 0;\n            double fPrime2Integral = 0;\n            final double startX = currentX;\n            for (int i = 1; i < observations.length; ++i) {\n                // one step forward\n                final double previousX = currentX;\n                final double previousY = currentY;\n                currentX = observations[i].getX();\n                currentY = observations[i].getY();\n\n                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n                // considering a linear model for f (and therefore constant f')\n                final double dx = currentX - previousX;\n                final double dy = currentY - previousY;\n                final double f2StepIntegral =\n                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n                final double fPrime2StepIntegral = dy * dy / dx;\n\n                final double x = currentX - startX;\n                f2Integral += f2StepIntegral;\n                fPrime2Integral += fPrime2StepIntegral;\n\n                sx2 += x * x;\n                sy2 += f2Integral * f2Integral;\n                sxy += x * f2Integral;\n                sxz += x * fPrime2Integral;\n                syz += f2Integral * fPrime2Integral;\n            }\n\n            // compute the amplitude and pulsation coefficients\n            double c1 = sy2 * sxz - sxy * syz;\n            double c2 = sxy * sxz - sx2 * syz;\n            double c3 = sx2 * sy2 - sxy * sxy;\n            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n                final int last = observations.length - 1;\n                // Range of the observations, assuming that the\n                // observations are sorted.\n                final double xRange = observations[last].getX() - observations[0].getX();\n                if (xRange == 0) {\n                    throw new ZeroException();\n                }\n                omega = 2 * Math.PI / xRange;\n\n                double yMin = Double.POSITIVE_INFINITY;\n                double yMax = Double.NEGATIVE_INFINITY;\n                for (int i = 1; i < observations.length; ++i) {\n                    final double y = observations[i].getY();\n                    if (y < yMin) {\n                        yMin = y;\n                    }\n                    if (y > yMax) {\n                        yMax = y;\n                    }\n                }\n                a = 0.5 * (yMax - yMin);\n            } else {\n                    // In some ill-conditioned cases (cf. MATH-844), the guesser\n                    // procedure cannot produce sensible results.\n\n                a = FastMath.sqrt(c1 / c2);\n                omega = FastMath.sqrt(c2 / c3);\n            }\n        }\n\n        /**\n         * Estimate a first guess of the phase.\n         */\n        private void guessPhi() {\n            // initialize the means\n            double fcMean = 0;\n            double fsMean = 0;\n\n            double currentX = observations[0].getX();\n            double currentY = observations[0].getY();\n            for (int i = 1; i < observations.length; ++i) {\n                // one step forward\n                final double previousX = currentX;\n                final double previousY = currentY;\n                currentX = observations[i].getX();\n                currentY = observations[i].getY();\n                final double currentYPrime = (currentY - previousY) / (currentX - previousX);\n\n                double omegaX = omega * currentX;\n                double cosine = FastMath.cos(omegaX);\n                double sine = FastMath.sin(omegaX);\n                fcMean += omega * currentY * cosine - currentYPrime * sine;\n                fsMean += omega * currentY * sine + currentYPrime * cosine;\n            }\n\n            phi = FastMath.atan2(-fsMean, fcMean);\n        }\n    }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"message\": \"The 'getObservations()' method may return null, which would cause a NullPointerException when calling the 'guess()' method.\",\n         \"location\": \"HarmonicFitter.java:74\"\n      },\n      {\n         \"type\": \"Potential ArithmeticException\",\n         \"message\": \"The 'guess()' method may throw an ArithmeticException when the sample is too short for the first guess to be computed.\",\n         \"location\": \"HarmonicFitter.java:83\"\n      },\n      {\n         \"type\": \"Potential ZeroException\",\n         \"message\": \"The 'guess()' method may throw a ZeroException when the abscissa range is zero.\",\n         \"location\": \"HarmonicFitter.java:84\"\n      },\n      {\n         \"type\": \"Potential NumberIsTooSmallException\",\n         \"message\": \"The 'fit()' method may throw a NumberIsTooSmallException when the sample is too short for the first guess to be computed.\",\n         \"location\": \"HarmonicFitter.java:96\"\n      },\n      {\n         \"type\": \"Potential ZeroException\",\n         \"message\": \"The 'fit()' method may throw a ZeroException when the first guess cannot be computed because the abscissa range is zero.\",\n         \"location\": \"HarmonicFitter.java:97\"\n      }\n   ]\n}"}}