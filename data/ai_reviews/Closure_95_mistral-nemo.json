{"sample_id": "Closure_95", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2004 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport static com.google.javascript.jscomp.TypeCheck.ENUM_DUP;\nimport static com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT;\nimport static com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.DATE_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.EVAL_ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NO_OBJECT_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NO_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.RANGE_ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.REGEXP_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.STRING_OBJECT_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.URI_ERROR_FUNCTION_TYPE;\nimport static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.CodingConvention.DelegateRelationship;\nimport com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;\nimport com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\nimport com.google.javascript.jscomp.CodingConvention.SubclassType;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractShallowStatementCallback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.ErrorReporter;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.jstype.EnumType;\nimport com.google.javascript.rhino.jstype.FunctionParamBuilder;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.rhino.jstype.JSTypeNative;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\nimport com.google.javascript.rhino.jstype.ObjectType;\n\nimport java.util.Iterator;\nimport java.util.List;\n\nimport javax.annotation.Nullable;\n\n/**\n * Creates the symbol table of variables available in the current scope and\n * their types.\n *\n * Scopes created by this class are very different from scopes created\n * by the syntactic scope creator. These scopes have type information, and\n * include some qualified names in addition to variables\n * (like Class.staticMethod).\n *\n * When building scope information, also declares relevant information\n * about types in the type registry.\n */\nfinal class TypedScopeCreator implements ScopeCreator {\n  /**\n   * A suffix for naming delegate proxies differently from their base.\n   */\n  static final String DELEGATE_PROXY_SUFFIX = \"(Proxy)\";\n\n  static final DiagnosticType MALFORMED_TYPEDEF =\n      DiagnosticType.warning(\n          \"JSC_MALFORMED_TYPEDEF\",\n          \"Typedef for {0} does not have any type information\");\n\n  static final DiagnosticType ENUM_INITIALIZER =\n      DiagnosticType.warning(\n          \"JSC_ENUM_INITIALIZER_NOT_ENUM\",\n          \"enum initializer must be an object literal or an enum\");\n\n  static final DiagnosticType CONSTRUCTOR_EXPECTED =\n      DiagnosticType.warning(\n          \"JSC_REFLECT_CONSTRUCTOR_EXPECTED\",\n          \"Constructor expected as first argument\");\n\n  private final AbstractCompiler compiler;\n  private final ErrorReporter typeParsingErrorReporter;\n  private final TypeValidator validator;\n  private final CodingConvention codingConvention;\n  private final JSTypeRegistry typeRegistry;\n  private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n\n  /**\n   * Defer attachment of types to nodes until all type names\n   * have been resolved. Then, we can resolve the type and attach it.\n   */\n  private class DeferredSetType {\n    final Node node;\n    final JSType type;\n\n    DeferredSetType(Node node, JSType type) {\n      Preconditions.checkNotNull(node);\n      Preconditions.checkNotNull(type);\n      this.node = node;\n      this.type = type;\n\n      // Other parts of this pass may read off the node.\n      // (like when we set the LHS of an assign with a typed RHS function.)\n      node.setJSType(type);\n    }\n\n    void resolve(Scope scope) {\n      node.setJSType(type.resolve(typeParsingErrorReporter, scope));\n    }\n  }\n\n  TypedScopeCreator(AbstractCompiler compiler) {\n    this(compiler, compiler.getCodingConvention());\n  }\n\n  TypedScopeCreator(AbstractCompiler compiler,\n      CodingConvention codingConvention) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.codingConvention = codingConvention;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.typeParsingErrorReporter = typeRegistry.getErrorReporter();\n  }\n\n  /**\n   * Creates a scope with all types declared. Declares newly discovered types\n   * and type properties in the type registry.\n   */\n  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    AbstractScopeBuilder scopeBuilder = null;\n    if (parent == null) {\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n      scopeBuilder = globalScopeBuilder;\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n    } else {\n      newScope = new Scope(parent, root);\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n      scopeBuilder = localScopeBuilder;\n      localScopeBuilder.build();\n    }\n\n    scopeBuilder.resolveStubDeclarations();\n    scopeBuilder.resolveTypes();\n\n    // Gather the properties in each function that we found in the\n    // global scope, if that function has a @this type that we can\n    // build properties on.\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n      JSType type = functionNode.getJSType();\n      if (type != null && type instanceof FunctionType) {\n        FunctionType fnType = (FunctionType) type;\n        ObjectType fnThisType = fnType.getTypeOfThis();\n        if (!fnThisType.isUnknownType()) {\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n              scopeBuilder.new CollectProperties(fnThisType));\n        }\n      }\n    }\n\n    if (parent == null) {\n      codingConvention.defineDelegateProxyPrototypeProperties(\n          typeRegistry, newScope, delegateProxyPrototypes);\n    }\n    return newScope;\n  }\n\n  /**\n   * Create the outermost scope. This scope contains native binding such as\n   * {@code Object}, {@code Date}, etc.\n   */\n  @VisibleForTesting\n  Scope createInitialScope(Node root) {\n\n    NodeTraversal.traverse(compiler, root, new DiscoverEnums(typeRegistry));\n\n    Scope s = new Scope(root, compiler);\n    declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n    declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, DATE_FUNCTION_TYPE);\n    declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE);\n    declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE);\n    declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);\n    declareNativeValueType(s, \"undefined\", VOID_TYPE);\n\n    // The typedef construct needs the any type, so that it can be assigned\n    // to anything. This is kind of a hack, and an artifact of the typedef\n    // syntax we've chosen.\n    declareNativeValueType(s, \"goog.typedef\", NO_TYPE);\n\n    // ActiveXObject is unqiuely special, because it can be used to construct\n    // any type (the type that it creates is related to the arguments you\n    // pass to it).\n    declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE);\n\n    return s;\n  }\n\n  private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n    FunctionType t = typeRegistry.getNativeFunctionType(tId);\n    declareNativeType(scope, t.getInstanceType().getReferenceName(), t);\n    declareNativeType(\n        scope, t.getPrototype().getReferenceName(), t.getPrototype());\n  }\n\n  private void declareNativeValueType(Scope scope, String name,\n      JSTypeNative tId) {\n    declareNativeType(scope, name, typeRegistry.getNativeType(tId));\n  }\n\n  private void declareNativeType(Scope scope, String name, JSType t) {\n    scope.declare(name, null, t, null, false);\n  }\n\n  private static class DiscoverEnums extends AbstractShallowStatementCallback {\n    private final JSTypeRegistry registry;\n\n    DiscoverEnums(JSTypeRegistry registry) {\n      this.registry = registry;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      Node nameNode = null;\n      switch (node.getType()) {\n        case Token.VAR:\n          for (Node child = node.getFirstChild();\n               child != null; child = child.getNext()) {\n            identifyEnumInNameNode(\n                child, NodeUtil.getInfoForNameNode(child));\n          }\n          break;\n        case Token.EXPR_RESULT:\n          Node maybeAssign = node.getFirstChild();\n          if (maybeAssign.getType() == Token.ASSIGN) {\n            identifyEnumInNameNode(\n                maybeAssign.getFirstChild(), maybeAssign.getJSDocInfo());\n          }\n          break;\n      }\n    }\n\n    private void identifyEnumInNameNode(Node nameNode, JSDocInfo info) {\n      if (info != null && info.hasEnumParameterType()) {\n        registry.identifyEnumName(nameNode.getQualifiedName());\n      }\n    }\n  }\n\n  /**\n   * Given a node, determines whether that node names a prototype\n   * property, and if so, returns the qualfied name node representing\n   * the owner of that property. Otherwise, returns null.\n   */\n  private static Node getPrototypePropertyOwner(Node n) {\n    if (n.getType() == Token.GETPROP) {\n      Node firstChild = n.getFirstChild();\n      if (firstChild.getType() == Token.GETPROP &&\n          firstChild.getLastChild().getString().equals(\"prototype\")) {\n        Node maybeOwner = firstChild.getFirstChild();\n        if (maybeOwner.isQualifiedName()) {\n          return maybeOwner;\n        }\n      }\n    }\n    return null;\n  }\n\n  private void attachLiteralTypes(Node n) {\n    switch (n.getType()) {\n      case Token.NULL:\n        n.setJSType(getNativeType(NULL_TYPE));\n        break;\n\n      case Token.VOID:\n        n.setJSType(getNativeType(VOID_TYPE));\n        break;\n\n      case Token.STRING:\n        n.setJSType(getNativeType(STRING_TYPE));\n        break;\n\n      case Token.NUMBER:\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\n        break;\n\n      case Token.REGEXP:\n        n.setJSType(getNativeType(REGEXP_TYPE));\n        break;\n\n      case Token.REF_SPECIAL:\n        n.setJSType(getNativeType(UNKNOWN_TYPE));\n        break;\n\n      case Token.OBJECTLIT:\n        if (n.getJSType() == null) {\n          n.setJSType(typeRegistry.createAnonymousObjectType());\n        }\n        break;\n\n      // NOTE(nicksantos): If we ever support Array tuples,\n      // we will need to put ARRAYLIT here as well.\n    }\n  }\n\n  private JSType getNativeType(JSTypeNative nativeType) {\n    return typeRegistry.getNativeType(nativeType);\n  }\n\n  private abstract class AbstractScopeBuilder\n      implements NodeTraversal.Callback {\n\n    /**\n     * The scope that we're builidng.\n     */\n    final Scope scope;\n\n    private final List<DeferredSetType> deferredSetTypes =\n        Lists.newArrayList();\n\n    /**\n     * Functions that we found in the global scope and not in externs.\n     */\n    private final List<Node> nonExternFunctions = Lists.newArrayList();\n\n    /**\n     * Type-less stubs.\n     *\n     * If at the end of traversal, we still don't have types for these\n     * stubs, then we should declare UNKNOWN types.\n     */\n    private final List<StubDeclaration> stubDeclarations =\n        Lists.newArrayList();\n\n    /**\n     * The current source file that we're in.\n     */\n    private String sourceName = null;\n\n    private AbstractScopeBuilder(Scope scope) {\n      this.scope = scope;\n    }\n\n    void setDeferredType(Node node, JSType type) {\n      deferredSetTypes.add(new DeferredSetType(node, type));\n    }\n\n    void resolveTypes() {\n      // Resolve types and attach them to nodes.\n      for (DeferredSetType deferred : deferredSetTypes) {\n        deferred.resolve(scope);\n      }\n\n      // Resolve types and attach them to scope slots.\n      Iterator<Var> vars = scope.getVars();\n      while (vars.hasNext()) {\n        vars.next().resolveType(typeParsingErrorReporter);\n      }\n\n      // Tell the type registry that any remaining types\n      // are unknown.\n      typeRegistry.resolveTypesInScope(scope);\n    }\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      if (n.getType() == Token.FUNCTION ||\n          n.getType() == Token.SCRIPT) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n      }\n\n      // We do want to traverse the name of a named function, but we don't\n      // want to traverse the arguments or body.\n      return parent == null || parent.getType() != Token.FUNCTION ||\n          n == parent.getFirstChild() || parent == scope.getRootNode();\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      attachLiteralTypes(n);\n\n      switch (n.getType()) {\n        case Token.CALL:\n          checkForClassDefiningCalls(t, n, parent);\n          break;\n\n        case Token.FUNCTION:\n          if (t.getInput() == null || !t.getInput().isExtern()) {\n            nonExternFunctions.add(n);\n          }\n\n          // VARs and ASSIGNs are handled in different branches of this\n          // switch statement.\n          if (parent.getType() != Token.ASSIGN &&\n              parent.getType() != Token.NAME) {\n            defineDeclaredFunction(n, parent);\n          }\n\n          break;\n\n        case Token.ASSIGN:\n          // Handle constructor and enum definitions.\n          defineNamedTypeAssign(n, parent);\n\n          // Handle initialization of properties.\n          Node firstChild = n.getFirstChild();\n          if (firstChild.getType() == Token.GETPROP &&\n              firstChild.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n                firstChild, n, firstChild.getNext());\n          }\n          break;\n\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n\n        case Token.VAR:\n          defineVar(n, parent);\n          break;\n\n        case Token.GETPROP:\n          // Handle stubbed properties.\n          if (parent.getType() == Token.EXPR_RESULT &&\n              n.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n          }\n          break;\n      }\n    }\n\n    /**\n     * Returns the type specified in a JSDoc annotation near a GETPROP or NAME.\n     *\n     * Extracts type information from either the {@code @type} tag or from\n     * the {@code @return} and {@code @param} tags.\n     */\n    JSType getDeclaredTypeInAnnotation(\n        NodeTraversal t, Node node, JSDocInfo info) {\n      return getDeclaredTypeInAnnotation(t.getSourceName(), node, info);\n    }\n\n    JSType getDeclaredTypeInAnnotation(String sourceName,\n        Node node, JSDocInfo info) {\n      JSType jsType = null;\n      Node objNode = node.getType() == Token.GETPROP ?\n          node.getFirstChild() : null;\n      if (info != null) {\n        if (info.hasType()) {\n          jsType = info.getType().evaluate(scope, typeRegistry);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          String fnName = node.getQualifiedName();\n\n          // constructors are often handled separately.\n          if (info.isConstructor() && typeRegistry.getType(fnName) != null) {\n            return null;\n          }\n\n          FunctionTypeBuilder builder =\n              new FunctionTypeBuilder(\n                  fnName, compiler, node, sourceName, scope)\n              .inferTemplateTypeName(info)\n              .inferReturnType(info)\n              .inferParameterTypes(info)\n              .inferInheritance(info);\n\n          // Infer the context type.\n          boolean searchedForThisType = false;\n          if (objNode != null) {\n            if (objNode.getType() == Token.GETPROP &&\n                objNode.getLastChild().getString().equals(\"prototype\")) {\n              builder.inferThisType(info, objNode.getFirstChild());\n              searchedForThisType = true;\n            } else if (objNode.getType() == Token.THIS) {\n              builder.inferThisType(info, objNode.getJSType());\n              searchedForThisType = true;\n            }\n          }\n\n          if (!searchedForThisType) {\n            builder.inferThisType(info, (Node) null);\n          }\n\n          jsType = builder.buildAndRegister();\n        }\n      }\n      return jsType;\n    }\n\n    /**\n     * Asserts that it's ok to define this node's name.\n     * The node should have a source name and be of the specified type.\n     */\n    void assertDefinitionNode(Node n, int type) {\n      Preconditions.checkState(sourceName != null);\n      Preconditions.checkState(n.getType() == type);\n    }\n\n    /**\n     * Defines a catch parameter.\n     */\n    void defineCatch(Node n, Node parent) {\n      assertDefinitionNode(n, Token.CATCH);\n      Node catchName = n.getFirstChild();\n      defineSlot(catchName, n, null);\n    }\n\n    /**\n     * Defines a VAR initialization.\n     */\n    void defineVar(Node n, Node parent) {\n      assertDefinitionNode(n, Token.VAR);\n      JSDocInfo info = n.getJSDocInfo();\n      if (n.hasMoreThanOneChild()) {\n        if (info != null) {\n          // multiple children\n          compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n        }\n        for (Node name : n.children()) {\n          defineName(name, n, parent, name.getJSDocInfo());\n        }\n      } else {\n        Node name = n.getFirstChild();\n        defineName(name, n, parent,\n            (info != null) ? info : name.getJSDocInfo());\n      }\n    }\n\n    /**\n     * Defines a declared function.\n     */\n    void defineDeclaredFunction(Node n, Node parent) {\n      assertDefinitionNode(n, Token.FUNCTION);\n\n      JSDocInfo info = n.getJSDocInfo();\n      int parentType = parent.getType();\n      Preconditions.checkState(\n          (scope.isLocal() || parentType != Token.ASSIGN) &&\n          parentType != Token.NAME,\n          \"function defined as standalone function when it is being \" +\n          \"assigned\");\n      String functionName = n.getFirstChild().getString();\n      FunctionType functionType = getFunctionType(functionName, n, info,\n          null);\n      if (NodeUtil.isFunctionDeclaration(n)) {\n        defineSlot(n.getFirstChild(), n, functionType);\n      }\n    }\n\n    /**\n     * Defines a qualified name assign to an enum or constructor.\n     */\n    void defineNamedTypeAssign(Node n, Node parent) {\n      assertDefinitionNode(n, Token.ASSIGN);\n      JSDocInfo info = n.getJSDocInfo();\n\n      // TODO(nicksantos): We should support direct assignment to a\n      // prototype, as in:\n      // Foo.prototype = {\n      //   a: function() { ... },\n      //   b: function() { ... }\n      // };\n      // Right now (6/23/08), we understand most of this syntax, but we\n      // don't tie the \"a\" and \"b\" methods to the context of Foo.\n\n      Node rvalue = n.getLastChild();\n      Node lvalue = n.getFirstChild();\n      info = (info != null) ? info : rvalue.getJSDocInfo();\n      if (rvalue.getType() == Token.FUNCTION ||\n          info != null && info.isConstructor()) {\n        getFunctionType(lvalue.getQualifiedName(), rvalue, info,\n            lvalue);\n      } else if (info != null && info.hasEnumParameterType()) {\n        JSType type = getEnumType(lvalue.getQualifiedName(), n, rvalue,\n            info.getEnumParameterType().evaluate(scope, typeRegistry));\n        if (type != null) {\n          setDeferredType(lvalue, type);\n        }\n      }\n    }\n\n    /**\n     * Defines a variable based on the {@link Token#NAME} node passed.\n     * @param name The {@link Token#NAME} node.\n     * @param var The parent of the {@code name} node, which must be a\n     *     {@link Token#VAR} node.\n     * @param parent {@code var}'s parent.\n     * @param info the {@link JSDocInfo} information relating to this\n     *     {@code name} node.\n     */\n    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n      Node value = name.getFirstChild();\n\n      if (value != null && value.getType() == Token.FUNCTION) {\n        // function\n        String functionName = name.getString();\n        FunctionType functionType =\n            getFunctionType(functionName, value, info, null);\n        if (functionType.isReturnTypeInferred() &&\n            scope.isLocal()) {\n          defineSlot(name, var, null);\n        } else {\n          defineSlot(name, var, functionType);\n        }\n      } else {\n        // variable's type\n        JSType type = null;\n        if (info == null) {\n          // the variable's type will be inferred\n          CompilerInput input = compiler.getInput(sourceName);\n          Preconditions.checkNotNull(input, sourceName);\n          type = input.isExtern() ?\n              getNativeType(UNKNOWN_TYPE) : null;\n        } else if (info.hasEnumParameterType()) {\n          type = getEnumType(name.getString(), var, value,\n              info.getEnumParameterType().evaluate(scope, typeRegistry));\n        } else if (info.isConstructor()) {\n          type = getFunctionType(name.getString(), value, info, name);\n        } else {\n          type = getDeclaredTypeInAnnotation(sourceName, name, info);\n        }\n\n        defineSlot(name, var, type);\n      }\n    }\n\n    /**\n     * Gets the function type from the function node and its attached\n     * {@link JSDocInfo}.\n     * @param name the function's name\n     * @param rValue the function node. It must be a {@link Token#FUNCTION}.\n     * @param info the {@link JSDocInfo} attached to the function definition\n     * @param lvalueNode The node where this function is being\n     *     assigned. For example, {@code A.prototype.foo = ...} would be used to\n     *     determine that this function is a method of A.prototype. May be\n     *     null to indicate that this is not being assigned to a qualified name.\n     */\n    private FunctionType getFunctionType(String name,\n        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n      FunctionType functionType = null;\n\n      // Global function aliases should be registered with the type registry.\n      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n          functionType = (FunctionType) var.getType();\n          if (functionType != null && functionType.isConstructor()) {\n            typeRegistry.declareType(name, functionType.getInstanceType());\n          }\n        }\n        return functionType;\n      }\n\n      Node owner = null;\n      if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n      }\n\n      Node errorRoot = rValue == null ? lvalueNode : rValue;\n      boolean isFnLiteral =\n          rValue != null && rValue.getType() == Token.FUNCTION;\n      Node fnRoot = isFnLiteral ? rValue : null;\n      Node parametersNode = isFnLiteral ?\n          rValue.getFirstChild().getNext() : null;\n      Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n\n      if (functionType == null && info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n          functionType = (FunctionType) type;\n          functionType.setJSDocInfo(info);\n        }\n      }\n\n      if (functionType == null) {\n        // Find the type of any overridden function.\n        FunctionType overriddenPropType = null;\n        if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&\n            lvalueNode.isQualifiedName()) {\n          Var var = scope.getVar(\n              lvalueNode.getFirstChild().getQualifiedName());\n          if (var != null) {\n            ObjectType ownerType = ObjectType.cast(var.getType());\n            if (ownerType != null) {\n              String propName = lvalueNode.getLastChild().getString();\n              overriddenPropType = findOverriddenFunction(ownerType, propName);\n            }\n          }\n        }\n\n        functionType =\n            new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                scope)\n            .setSourceNode(fnRoot)\n            .inferFromOverriddenFunction(overriddenPropType, parametersNode)\n            .inferTemplateTypeName(info)\n            .inferReturnType(info)\n            .inferInheritance(info)\n            .inferThisType(info, owner)\n            .inferParameterTypes(parametersNode, info)\n            .inferReturnStatementsAsLastResort(fnBlock)\n            .buildAndRegister();\n      }\n\n      // assigning the function type to the function node\n      if (rValue != null) {\n        setDeferredType(rValue, functionType);\n      }\n\n      // all done\n      return functionType;\n    }\n\n    /**\n     * Find the function that's being overridden on this type, if any.\n     */\n    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName) {\n      // First, check to see if the property is implemented\n      // on a superclass.\n      JSType propType = ownerType.getPropertyType(propName);\n      if (propType instanceof FunctionType) {\n        return (FunctionType) propType;\n      } else {\n        // If it's not, then check to see if it's implemented\n        // on an implemented interface.\n        for (ObjectType iface :\n                 ownerType.getCtorImplementedInterfaces()) {\n          propType = iface.getPropertyType(propName);\n          if (propType instanceof FunctionType) {\n            return (FunctionType) propType;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    /**\n     * Gets an enum type. If the definition is correct, the object literal used\n     * to define the enum is traversed to gather the elements name, and this\n     * method checks for duplicates. This method also enforces that all\n     * elements' name be syntactic constants according to the\n     * {@link CodingConvention} used.\n     *\n     * @param name the enum's name such as {@code HELLO} or {@code goog.foo.BAR}\n     * @param value the enum's original value. This value may be {@code null}.\n     * @param parent the value's parent\n     * @param elementsType the type of the elements of this enum\n     * @return the enum type\n     */\n    private EnumType getEnumType(String name, Node parent,\n        Node value, JSType elementsType) {\n      EnumType enumType = null;\n\n      // no value with @enum\n      if (value != null) {\n        if (value.getType() == Token.OBJECTLIT) {\n          // collect enum elements\n          enumType = typeRegistry.createEnumType(name, elementsType);\n\n          // populate the enum type.\n          Node key = value.getFirstChild();\n          while (key != null) {\n            String keyName = NodeUtil.getStringValue(key);\n\n            if (enumType.hasOwnProperty(keyName)) {\n              compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n            } else if (!codingConvention.isValidEnumKey(keyName)) {\n              compiler.report(\n                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n            } else {\n              enumType.defineElement(keyName);\n            }\n            key = key.getNext();\n            key = (key == null) ? null : key.getNext();\n          }\n        } else if (value.isQualifiedName()) {\n          Var var = scope.getVar(value.getQualifiedName());\n          if (var != null && var.getType() instanceof EnumType) {\n            enumType = (EnumType) var.getType();\n          }\n        }\n      }\n\n      if (enumType == null) {\n        compiler.report(JSError.make(sourceName, parent, ENUM_INITIALIZER));\n      } else if (scope.isGlobal()) {\n        if (name != null && !name.isEmpty()) {\n          typeRegistry.declareType(name, enumType.getElementsType());\n        }\n      }\n\n      return enumType;\n    }\n\n    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type or {@code null} if its type is inferred.\n     * @param name the defining node. It must be a {@link Token#NAME}.\n     * @param parent the {@code name}'s parent.\n     * @param type the variable's type. It may be {@code null}, in which case\n     *     the variable's type will be inferred.\n     */\n    private void defineSlot(Node name, Node parent, JSType type) {\n      defineSlot(name, parent, type, type == null);\n    }\n\n    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name in the global scope.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     */\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualfied names.\n      boolean shouldDeclareOnGlobalThis = false;\n      if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(\n            parent.getType() == Token.FUNCTION ||\n            parent.getType() == Token.VAR ||\n            parent.getType() == Token.LP ||\n            parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() &&\n            (parent.getType() == Token.VAR ||\n             parent.getType() == Token.FUNCTION);\n      } else {\n        Preconditions.checkArgument(\n            n.getType() == Token.GETPROP &&\n            (parent.getType() == Token.ASSIGN ||\n             parent.getType() == Token.EXPR_RESULT));\n      }\n      String variableName = n.getQualifiedName();\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      // If n is a property, then we should really declare it in the\n      // scope where the root object appears. This helps out people\n      // who declare \"global\" names in an anonymous namespace.\n      Scope scopeToDeclareIn = scope;\n\n        // don't try to declare in the global scope if there's\n        // already a symbol there with this name.\n\n      // declared in closest scope?\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(\n            sourceName, n, parent, oldVar, variableName, type);\n      } else {\n        if (!inferred) {\n          setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        if (shouldDeclareOnGlobalThis) {\n          ObjectType globalThis =\n              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n          boolean isExtern = input.isExtern();\n          if (inferred) {\n            globalThis.defineInferredProperty(variableName,\n                type == null ?\n                    getNativeType(JSTypeNative.NO_TYPE) :\n                    type,\n                isExtern);\n          } else {\n            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n          }\n        }\n\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n          FunctionType fnType = (FunctionType) type;\n          if (fnType.isConstructor() || fnType.isInterface()) {\n            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n                fnType.getPrototype(), compiler.getInput(sourceName),\n                /* declared iff there's an explicit supertype */\n                superClassCtor == null ||\n                superClassCtor.getInstanceType().equals(\n                    getNativeType(OBJECT_TYPE)));\n          }\n        }\n      }\n    }\n\n    /**\n     * Check if the given node is a property of a name in the global scope.\n     */\n    private boolean isQnameRootedInGlobalScope(Node n) {\n      Node root = NodeUtil.getRootOfQualifiedName(n);\n      if (root.getType() == Token.NAME) {\n        Var var = scope.getVar(root.getString());\n        if (var != null) {\n          return var.isGlobal();\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Look for a type declaration on a GETPROP node.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n        Node n, Node rhsValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(t, n, info);\n      } else if (info != null && info.hasEnumParameterType()) {\n        return n.getJSType();\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.FUNCTION) {\n        return rhsValue.getJSType();\n      } else {\n        return getDeclaredTypeInAnnotation(t, n, info);\n      }\n    }\n\n    /**\n     * Look for class-defining calls.\n     * Because JS has no 'native' syntax for defining classes,\n     * this is often very coding-convention dependent and business-logic heavy.\n     */\n    private void checkForClassDefiningCalls(\n        NodeTraversal t, Node n, Node parent) {\n      SubclassRelationship relationship =\n          codingConvention.getClassesDefinedByCall(n);\n      if (relationship != null) {\n        ObjectType superClass = ObjectType.cast(\n            typeRegistry.getType(relationship.superclassName));\n        ObjectType subClass = ObjectType.cast(\n            typeRegistry.getType(relationship.subclassName));\n        if (superClass != null && subClass != null) {\n          FunctionType superCtor = superClass.getConstructor();\n          FunctionType subCtor = subClass.getConstructor();\n\n          if (relationship.type == SubclassType.INHERITS) {\n            validator.expectSuperType(t, n, superClass, subClass);\n          }\n\n          if (superCtor != null && subCtor != null) {\n            codingConvention.applySubclassRelationship(\n                superCtor, subCtor, relationship.type);\n          }\n        }\n      }\n\n      String singletonGetterClassName =\n          codingConvention.getSingletonGetterClassName(n);\n      if (singletonGetterClassName != null) {\n        ObjectType objectType = ObjectType.cast(\n            typeRegistry.getType(singletonGetterClassName));\n        if (objectType != null) {\n          FunctionType functionType = objectType.getConstructor();\n\n          if (functionType != null) {\n            FunctionType getterType =\n                typeRegistry.createFunctionType(objectType);\n            codingConvention.applySingletonGetter(functionType, getterType,\n                objectType);\n          }\n        }\n      }\n\n      DelegateRelationship delegateRelationship =\n          codingConvention.getDelegateRelationship(n);\n      if (delegateRelationship != null) {\n        applyDelegateRelationship(delegateRelationship);\n      }\n\n      ObjectLiteralCast objectLiteralCast =\n          codingConvention.getObjectLiteralCast(t, n);\n      if (objectLiteralCast != null) {\n        ObjectType type = ObjectType.cast(\n            typeRegistry.getType(objectLiteralCast.typeName));\n        if (type != null && type.getConstructor() != null) {\n          setDeferredType(objectLiteralCast.objectNode, type);\n        } else {\n          compiler.report(JSError.make(t.getSourceName(), n,\n                  CONSTRUCTOR_EXPECTED));\n        }\n      }\n    }\n\n    /**\n     * Apply special properties that only apply to delegates.\n     */\n    private void applyDelegateRelationship(\n        DelegateRelationship delegateRelationship) {\n      ObjectType delegatorObject = ObjectType.cast(\n          typeRegistry.getType(delegateRelationship.delegator));\n      ObjectType delegateBaseObject = ObjectType.cast(\n          typeRegistry.getType(delegateRelationship.delegateBase));\n      ObjectType delegateSuperObject = ObjectType.cast(\n          typeRegistry.getType(codingConvention.getDelegateSuperclassName()));\n      if (delegatorObject != null &&\n          delegateBaseObject != null &&\n          delegateSuperObject != null) {\n        FunctionType delegatorCtor = delegatorObject.getConstructor();\n        FunctionType delegateBaseCtor = delegateBaseObject.getConstructor();\n        FunctionType delegateSuperCtor = delegateSuperObject.getConstructor();\n\n        if (delegatorCtor != null && delegateBaseCtor != null &&\n            delegateSuperCtor != null) {\n          FunctionParamBuilder functionParamBuilder =\n              new FunctionParamBuilder(typeRegistry);\n          functionParamBuilder.addRequiredParams(\n              getNativeType(U2U_CONSTRUCTOR_TYPE));\n          FunctionType findDelegate = typeRegistry.createFunctionType(\n              typeRegistry.createDefaultObjectUnion(delegateBaseObject),\n              functionParamBuilder.build());\n\n          FunctionType delegateProxy = typeRegistry.createConstructorType(\n              delegateBaseObject.getReferenceName() + DELEGATE_PROXY_SUFFIX,\n              null, null, null);\n          delegateProxy.setPrototypeBasedOn(delegateBaseObject);\n\n          codingConvention.applyDelegateRelationship(\n              delegateSuperObject, delegateBaseObject, delegatorObject,\n              delegateProxy, findDelegate);\n          delegateProxyPrototypes.add(delegateProxy.getPrototype());\n        }\n      }\n    }\n\n    /**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          if (!qVar.isTypeInferred()) {\n            // Just ignore assigns to declared prototypes.\n            return;\n          }\n          scope.undeclare(qVar);\n        }\n      }\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to anything else\n      //\n      // 1 and 3 are declarations, 4 is inferred, and 2 is a declaration iff\n      // the function has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3\n      JSType valueType = getDeclaredGetPropType(t, info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #4\n        valueType = rhsValue.getJSType();\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3\n        inferred = !(info.hasType() || info.hasEnumParameterType() ||\n            FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            !scope.isDeclared(qName, false));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType instanceof FunctionType) {\n          JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),\n                true);\n          }\n        }\n      }\n    }\n\n    /**\n     * Find the ObjectType associated with the given slot.\n     * @param slotName The name of the slot to find the type in.\n     * @return An object type, or null if this slot does not contain an object.\n     */\n    private ObjectType getObjectSlot(String slotName) {\n      Var ownerVar = scope.getVar(slotName);\n      if (ownerVar != null) {\n        JSType ownerVarType = ownerVar.getType();\n        return ObjectType.cast(ownerVarType == null ?\n            null : ownerVarType.restrictByNotNullOrUndefined());\n      }\n      return null;\n    }\n\n    /**\n     * Resolve any stub delcarations to unknown types if we could not\n     * find types for them during traversal.\n     */\n    void resolveStubDeclarations() {\n      for (StubDeclaration stub : stubDeclarations) {\n        Node n = stub.node;\n        Node parent = n.getParent();\n        String qName = n.getQualifiedName();\n        String propName = n.getLastChild().getString();\n        String ownerName = stub.ownerName;\n        boolean isExtern = stub.isExtern;\n\n        if (scope.isDeclared(qName, false)) {\n          continue;\n        }\n\n        // If we see a stub property, make sure to register this property\n        // in the type registry.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n        defineSlot(n, parent, unknownType, true);\n\n        if (ownerType != null &&\n            (isExtern || ownerType.isFunctionPrototypeType())) {\n          // If this is a stub for a prototype, just declare it\n          // as an unknown type. These are seen often in externs.\n          ownerType.defineInferredProperty(\n              propName, unknownType, isExtern);\n        } else {\n          typeRegistry.registerPropertyOnType(\n              propName, ownerType == null ? unknownType : ownerType);\n        }\n      }\n    }\n\n    /**\n     * Collects all declared properties in a function, and\n     * resolves them relative to the global scope.\n     */\n    private final class CollectProperties\n        extends AbstractShallowStatementCallback {\n      private final ObjectType thisType;\n\n      CollectProperties(ObjectType thisType) {\n        this.thisType = thisType;\n      }\n\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.getType() == Token.EXPR_RESULT) {\n          Node child = n.getFirstChild();\n          switch (child.getType()) {\n            case Token.ASSIGN:\n              maybeCollectMember(t, child.getFirstChild(), child);\n              break;\n            case Token.GETPROP:\n              maybeCollectMember(t, child, child);\n              break;\n          }\n        }\n      }\n\n      private void maybeCollectMember(NodeTraversal t,\n          Node member, Node nodeWithJsDocInfo) {\n        JSDocInfo info = nodeWithJsDocInfo.getJSDocInfo();\n\n        // Do nothing if there is no JSDoc type info, or\n        // if the node is not a member expression, or\n        // if the member expression is not of the form: this.someProperty.\n        if (info == null ||\n            member.getType() != Token.GETPROP ||\n            member.getFirstChild().getType() != Token.THIS) {\n          return;\n        }\n\n        member.getFirstChild().setJSType(thisType);\n        JSType jsType = getDeclaredTypeInAnnotation(t, member, info);\n        Node name = member.getLastChild();\n        if (jsType != null &&\n            (name.getType() == Token.NAME || name.getType() == Token.STRING)) {\n          thisType.defineDeclaredProperty(\n              name.getString(),\n              jsType,\n              false /* functions with implementations are not in externs */);\n        }\n      }\n    } // end CollectProperties\n  }\n\n  /**\n   * A stub declaration without any type information.\n   */\n  private static final class StubDeclaration {\n    private final Node node;\n    private final boolean isExtern;\n    private final String ownerName;\n\n    private StubDeclaration(Node node, boolean isExtern, String ownerName) {\n      this.node = node;\n      this.isExtern = isExtern;\n      this.ownerName = ownerName;\n    }\n  }\n\n  /**\n   * A shallow traversal of the global scope to build up all classes,\n   * functions, and methods.\n   */\n  private final class GlobalScopeBuilder extends AbstractScopeBuilder {\n\n    private GlobalScopeBuilder(Scope scope) {\n      super(scope);\n    }\n\n    /**\n     * Visit a node in the global scope, and add anything it declares to the\n     * global symbol table.\n     *\n     * @param t The current traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      super.visit(t, n, parent);\n\n      switch (n.getType()) {\n\n        case Token.ASSIGN:\n          // Handle typedefs.\n          checkForOldStyleTypedef(t, n);\n          break;\n\n        case Token.VAR:\n          // Handle typedefs.\n          if (n.hasOneChild()) {\n            checkForOldStyleTypedef(t, n);\n            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n          }\n          break;\n      }\n    }\n\n    @Override\n    void maybeDeclareQualifiedName(\n        NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      checkForTypedef(t, n, info);\n      super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n    }\n\n    /**\n     * Handle typedefs.\n     * @param t The current traversal.\n     * @param candidate A qualified name node.\n     * @param info JSDoc comments.\n     */\n    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n      if (info == null || !info.hasTypedefType()) {\n        return;\n      }\n\n      String typedef = candidate.getQualifiedName();\n      if (typedef == null) {\n        return;\n      }\n\n      // TODO(nicksantos|user): This is a terrible, terrible hack\n      // to bail out on recusive typedefs. We'll eventually need\n      // to handle these properly.\n      typeRegistry.forwardDeclareType(typedef);\n\n      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n      if (realType == null) {\n        compiler.report(\n            JSError.make(\n                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n      }\n\n      typeRegistry.declareType(typedef, realType);\n      if (candidate.getType() == Token.GETPROP) {\n        defineSlot(candidate, candidate.getParent(),\n            getNativeType(NO_TYPE), false);\n      }\n    }\n\n    /**\n     * Handle typedefs.\n     * @param t The current traversal.\n     * @param candidate An ASSIGN or VAR node.\n     */\n    // TODO(nicksantos): Kill this.\n    private void checkForOldStyleTypedef(NodeTraversal t, Node candidate) {\n      // old-style typedefs\n      String typedef = codingConvention.identifyTypeDefAssign(candidate);\n      if (typedef != null) {\n        // TODO(nicksantos|user): This is a terrible, terrible hack\n        // to bail out on recusive typedefs. We'll eventually need\n        // to handle these properly.\n        typeRegistry.forwardDeclareType(typedef);\n\n        JSDocInfo info = candidate.getJSDocInfo();\n        JSType realType = null;\n        if (info != null && info.getType() != null) {\n          realType = info.getType().evaluate(scope, typeRegistry);\n        }\n\n        if (realType == null) {\n          compiler.report(\n              JSError.make(\n                  t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n        }\n\n        typeRegistry.declareType(typedef, realType);\n\n        // Duplicate typedefs get handled when we try to register\n        // this typedef in the scope.\n      }\n    }\n  } // end GlobalScopeBuilder\n\n  /**\n   * A shallow traversal of a local scope to find all arguments and\n   * local variables.\n   */\n  private final class LocalScopeBuilder extends AbstractScopeBuilder {\n    /**\n     * @param scope The scope that we're builidng.\n     */\n    private LocalScopeBuilder(Scope scope) {\n      super(scope);\n    }\n\n    /**\n     * Traverse the scope root and build it.\n     */\n    void build() {\n      NodeTraversal.traverse(compiler, scope.getRootNode(), this);\n    }\n\n    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      super.visit(t, n, parent);\n    }\n\n    /** Handle bleeding functions and function parameters. */\n    private void handleFunctionInputs(Node fnNode) {\n      // Handle bleeding functions.\n      Node fnNameNode = fnNode.getFirstChild();\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty()) {\n        Scope.Var fnVar = scope.getVar(fnName);\n        if (fnVar == null ||\n            // Make sure we're not touching a native function. Native\n            // functions aren't bleeding, but may not have a declaration\n            // node.\n            (fnVar.getNameNode() != null &&\n                // Make sure that the function is actually bleeding by checking\n                // if has already been declared.\n                fnVar.getInitialValue() != fnNode)) {\n          defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n        }\n      }\n\n      declareArguments(fnNode);\n    }\n\n    /**\n     * Declares all of a function's arguments.\n     */\n    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      FunctionType functionType = (FunctionType) functionNode.getJSType();\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } // end declareArguments\n  } // end LocalScopeBuilder\n}\n", "review": {"response": "{\n  \"bugs\": [\n    {\n      \"type\": \"NullPointerException\",\n      \"description\": \"The `typeParsingErrorReporter` is not initialized in the constructor of `TypedScopeCreator`. This could lead to a NullPointerException when it's used.\"\n    },\n    {\n      \"type\": \"TypeCheckException\",\n      \"description\": \"The `validator` is not initialized in the constructor of `TypedScopeCreator`. If it's used without being initialized, it could throw a `TypeCheckException`.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"In the `createScope` method, the `node` parameter is not checked for null. Passing null could lead to an `IllegalArgumentException` when trying to call `node.getFirstChild()`.\"\n    },\n    {\n      \"type\": \"IllegalArgumentException\",\n      \"description\": \"In the `createScope` method, the `node` parameter is not checked for null. Passing null could lead to an `IllegalArgumentException` when trying to call `node.getLastChild()`.\"\n    },\n    {\n      \"type\": \"IllegalStateException\",\n      \"description\": \"In the `createScope` method, the `scope` is not checked for null before calling `scope.setParentScope(parentScope)`. If `scope` is null, this could lead to an `IllegalStateException`.\"\n    },\n    {\n      \"type\": \"UnsupportedOperationException\",\n      \"description\": \"The `deferAttachmentOfTypes` method is not implemented. If this method is called, it will throw an `UnsupportedOperationException`.\"\n    },\n    {\n      \"type\": \"UnsupportedOperationException\",\n      \"description\": \"The `addDelegateProxyPrototype` method is not implemented. If this method is called, it will throw an `UnsupportedOperationException`.\"\n    }\n  ]\n}"}}