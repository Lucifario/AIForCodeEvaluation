{"sample_id": "Lang_5", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * <p>Operations to assist when working with a {@link Locale}.</p>\n *\n * <p>This class tries to handle {@code null} input gracefully.\n * An exception will not be thrown for a {@code null} input.\n * Each method documents its behaviour in more detail.</p>\n *\n * @since 2.2\n * @version $Id$\n */\npublic class LocaleUtils {\n\n    /** Concurrent map of language locales by country. */\n    private static final ConcurrentMap<String, List<Locale>> cLanguagesByCountry = \n        new ConcurrentHashMap<String, List<Locale>>();\n\n    /** Concurrent map of country locales by language. */\n    private static final ConcurrentMap<String, List<Locale>> cCountriesByLanguage = \n        new ConcurrentHashMap<String, List<Locale>>();\n\n    /**\n     * <p>{@code LocaleUtils} instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as {@code LocaleUtils.toLocale(\"en_GB\");}.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public LocaleUtils() {\n      super();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Converts a String to a Locale.</p>\n     *\n     * <p>This method takes the string format of a locale and creates the\n     * locale object from it.</p>\n     *\n     * <pre>\n     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n     * </pre>\n     *\n     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n     *\n     * <p>This method validates the input strictly.\n     * The language code must be lowercase.\n     * The country code must be uppercase.\n     * The separator must be an underscore.\n     * The length must be correct.\n     * </p>\n     *\n     * @param str  the locale String to convert, null returns null\n     * @return a Locale, null if null input\n     * @throws IllegalArgumentException if the string is an invalid format\n     */\n    public static Locale toLocale(final String str) {\n        if (str == null) {\n            return null;\n        }\n        final int len = str.length();\n        if (len < 2) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 2) {\n                return new Locale(str);\n            }\n            if (len < 5) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(2) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            final char ch3 = str.charAt(3);\n            if (ch3 == '_') {\n                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n            }\n            final char ch4 = str.charAt(4);\n            if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 5) {\n                return new Locale(str.substring(0, 2), str.substring(3, 5));\n            }\n            if (len < 7) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (str.charAt(5) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\",\"CA\",\"xxx\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\")]\n     * </pre>\n     *\n     * @param locale  the locale to start from\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale) {\n        return localeLookupList(locale, locale);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains the list of locales to search through when performing\n     * a locale search.</p>\n     *\n     * <pre>\n     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\"]\n     * </pre>\n     *\n     * <p>The result list begins with the most specific locale, then the\n     * next more general and so on, finishing with the default locale.\n     * The list will never contain the same locale twice.</p>\n     *\n     * @param locale  the locale to start from, null returns empty list\n     * @param defaultLocale  the default locale to use if no other is found\n     * @return the unmodifiable list of Locale objects, 0 being locale, not null\n     */\n    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n        List<Locale> list = new ArrayList<Locale>(4);\n        if (locale != null) {\n            list.add(locale);\n            if (locale.getVariant().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n            }\n            if (locale.getCountry().length() > 0) {\n                list.add(new Locale(locale.getLanguage(), \"\"));\n            }\n            if (list.contains(defaultLocale) == false) {\n                list.add(defaultLocale);\n            }\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains an unmodifiable list of installed locales.</p>\n     * \n     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n     * It is more efficient, as the JDK method must create a new array each\n     * time it is called.</p>\n     *\n     * @return the unmodifiable list of available locales\n     */\n    public static List<Locale> availableLocaleList() {\n        return SyncAvoid.AVAILABLE_LOCALE_LIST;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains an unmodifiable set of installed locales.</p>\n     * \n     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n     * It is more efficient, as the JDK method must create a new array each\n     * time it is called.</p>\n     *\n     * @return the unmodifiable set of available locales\n     */\n    public static Set<Locale> availableLocaleSet() {\n        return SyncAvoid.AVAILABLE_LOCALE_SET;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks if the locale specified is in the list of available locales.</p>\n     *\n     * @param locale the Locale object to check if it is available\n     * @return true if the locale is a known locale\n     */\n    public static boolean isAvailableLocale(Locale locale) {\n        return availableLocaleList().contains(locale);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains the list of languages supported for a given country.</p>\n     *\n     * <p>This method takes a country code and searches to find the\n     * languages available for that country. Variant locales are removed.</p>\n     *\n     * @param countryCode  the 2 letter country code, null returns empty\n     * @return an unmodifiable List of Locale objects, not null\n     */\n    public static List<Locale> languagesByCountry(String countryCode) {\n        if (countryCode == null) {\n            return Collections.emptyList();\n        }\n        List<Locale> langs = cLanguagesByCountry.get(countryCode);\n        if (langs == null) {\n            langs = new ArrayList<Locale>();\n            List<Locale> locales = availableLocaleList();\n            for (int i = 0; i < locales.size(); i++) {\n                Locale locale = locales.get(i);\n                if (countryCode.equals(locale.getCountry()) &&\n                        locale.getVariant().isEmpty()) {\n                    langs.add(locale);\n                }\n            }\n            langs = Collections.unmodifiableList(langs);\n            cLanguagesByCountry.putIfAbsent(countryCode, langs);\n            langs = cLanguagesByCountry.get(countryCode);\n        }\n        return langs;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Obtains the list of countries supported for a given language.</p>\n     * \n     * <p>This method takes a language code and searches to find the\n     * countries available for that language. Variant locales are removed.</p>\n     *\n     * @param languageCode  the 2 letter language code, null returns empty\n     * @return an unmodifiable List of Locale objects, not null\n     */\n    public static List<Locale> countriesByLanguage(String languageCode) {\n        if (languageCode == null) {\n            return Collections.emptyList();\n        }\n        List<Locale> countries = cCountriesByLanguage.get(languageCode);\n        if (countries == null) {\n            countries = new ArrayList<Locale>();\n            List<Locale> locales = availableLocaleList();\n            for (int i = 0; i < locales.size(); i++) {\n                Locale locale = locales.get(i);\n                if (languageCode.equals(locale.getLanguage()) &&\n                        locale.getCountry().length() != 0 &&\n                        locale.getVariant().isEmpty()) {\n                    countries.add(locale);\n                }\n            }\n            countries = Collections.unmodifiableList(countries);\n            cCountriesByLanguage.putIfAbsent(languageCode, countries);\n            countries = cCountriesByLanguage.get(languageCode);\n        }\n        return countries;\n    }\n\n    //-----------------------------------------------------------------------\n    // class to avoid synchronization (Init on demand)\n    static class SyncAvoid {\n        /** Unmodifiable list of available locales. */\n        private static final List<Locale> AVAILABLE_LOCALE_LIST;\n        /** Unmodifiable set of available locales. */\n        private static final Set<Locale> AVAILABLE_LOCALE_SET;\n        \n        static {\n            List<Locale> list = new ArrayList<Locale>(Arrays.asList(Locale.getAvailableLocales()));  // extra safe\n            AVAILABLE_LOCALE_LIST = Collections.unmodifiableList(list);\n            AVAILABLE_LOCALE_SET = Collections.unmodifiableSet(new HashSet<Locale>(list));\n        }\n    }\n\n}\n", "review": {"response": "{\"bugs\": []}"}}