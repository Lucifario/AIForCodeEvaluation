{"sample_id": "Math_86", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.linear;\n\nimport org.apache.commons.math.MathRuntimeException;\n\n\n/**\n * Calculates the Cholesky decomposition of a matrix.\n * <p>The Cholesky decomposition of a real symmetric positive-definite\n * matrix A consists of a lower triangular matrix L with same size that\n * satisfy: A = LL<sup>T</sup>Q = I). In a sense, this is the square root of A.</p>\n *\n * @see <a href=\"http://mathworld.wolfram.com/CholeskyDecomposition.html\">MathWorld</a>\n * @see <a href=\"http://en.wikipedia.org/wiki/Cholesky_decomposition\">Wikipedia</a>\n * @version $Revision$ $Date$\n * @since 2.0\n */\npublic class CholeskyDecompositionImpl implements CholeskyDecomposition {\n\n    /** Default threshold above which off-diagonal elements are considered too different\n     * and matrix not symmetric. */\n    public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;\n\n    /** Default threshold below which diagonal elements are considered null\n     * and matrix not positive definite. */\n    public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;\n\n    /** Row-oriented storage for L<sup>T</sup> matrix data. */\n    private double[][] lTData;\n\n    /** Cached value of L. */\n    private RealMatrix cachedL;\n\n    /** Cached value of LT. */\n    private RealMatrix cachedLT;\n\n    /**\n     * Calculates the Cholesky decomposition of the given matrix.\n     * <p>\n     * Calling this constructor is equivalent to call {@link\n     * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the\n     * thresholds set to the default values {@link\n     * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link\n     * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}\n     * </p>\n     * @param matrix the matrix to decompose\n     * @exception NonSquareMatrixException if matrix is not square\n     * @exception NotSymmetricMatrixException if matrix is not symmetric\n     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n     * strictly positive definite\n     * @see #CholeskyDecompositionImpl(RealMatrix, double, double)\n     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n     */\n    public CholeskyDecompositionImpl(final RealMatrix matrix)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n        this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n             DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);\n    }\n\n    /**\n     * Calculates the Cholesky decomposition of the given matrix.\n     * @param matrix the matrix to decompose\n     * @param relativeSymmetryThreshold threshold above which off-diagonal\n     * elements are considered too different and matrix not symmetric\n     * @param absolutePositivityThreshold threshold below which diagonal\n     * elements are considered null and matrix not positive definite\n     * @exception NonSquareMatrixException if matrix is not square\n     * @exception NotSymmetricMatrixException if matrix is not symmetric\n     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n     * strictly positive definite\n     * @see #CholeskyDecompositionImpl(RealMatrix)\n     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n     */\n    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        // check the matrix before transformation\n        for (int i = 0; i < order; ++i) {\n\n            final double[] lI = lTData[i];\n\n            if (lTData[i][i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n            // check off-diagonal elements (and reset them to 0)\n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j];\n                final double lIJ = lI[j];\n                final double lJI = lJ[i];\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                lJ[i] = 0;\n           }\n        }\n\n        // transform the matrix\n        for (int i = 0; i < order; ++i) {\n\n            final double[] ltI = lTData[i];\n\n            // check diagonal element\n\n            ltI[i] = Math.sqrt(ltI[i]);\n            final double inverse = 1.0 / ltI[i];\n\n            for (int q = order - 1; q > i; --q) {\n                ltI[q] *= inverse;\n                final double[] ltQ = lTData[q];\n                for (int p = q; p < order; ++p) {\n                    ltQ[p] -= ltI[q] * ltI[p];\n                }\n            }\n\n        }\n\n    }\n\n    /** {@inheritDoc} */\n    public RealMatrix getL() {\n        if (cachedL == null) {\n            cachedL = getLT().transpose();\n        }\n        return cachedL;\n    }\n\n    /** {@inheritDoc} */\n    public RealMatrix getLT() {\n\n        if (cachedLT == null) {\n            cachedLT = MatrixUtils.createRealMatrix(lTData);\n        }\n\n        // return the cached matrix\n        return cachedLT;\n\n    }\n\n    /** {@inheritDoc} */\n    public double getDeterminant() {\n        double determinant = 1.0;\n        for (int i = 0; i < lTData.length; ++i) {\n            double lTii = lTData[i][i];\n            determinant *= lTii * lTii;\n        }\n        return determinant;\n    }\n\n    /** {@inheritDoc} */\n    public DecompositionSolver getSolver() {\n        return new Solver(lTData);\n    }\n\n    /** Specialized solver. */\n    private static class Solver implements DecompositionSolver {\n    \n        /** Row-oriented storage for L<sup>T</sup> matrix data. */\n        private final double[][] lTData;\n\n        /**\n         * Build a solver from decomposed matrix.\n         * @param lTData row-oriented storage for L<sup>T</sup> matrix data\n         */\n        private Solver(final double[][] lTData) {\n            this.lTData = lTData;\n        }\n\n        /** {@inheritDoc} */\n        public boolean isNonSingular() {\n            // if we get this far, the matrix was positive definite, hence non-singular\n            return true;\n        }\n\n        /** {@inheritDoc} */\n        public double[] solve(double[] b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = lTData.length;\n            if (b.length != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"vector length mismatch: got {0} but expected {1}\",\n                        b.length, m);\n            }\n\n            final double[] x = b.clone();\n\n            // Solve LY = b\n            for (int j = 0; j < m; j++) {\n                final double[] lJ = lTData[j];\n                x[j] /= lJ[j];\n                final double xJ = x[j];\n                for (int i = j + 1; i < m; i++) {\n                    x[i] -= xJ * lJ[i];\n                }\n            }\n\n            // Solve LTX = Y\n            for (int j = m - 1; j >= 0; j--) {\n                x[j] /= lTData[j][j];\n                final double xJ = x[j];\n                for (int i = 0; i < j; i++) {\n                    x[i] -= xJ * lTData[i][j];\n                }\n            }\n\n            return x;\n\n        }\n\n        /** {@inheritDoc} */\n        public RealVector solve(RealVector b)\n            throws IllegalArgumentException, InvalidMatrixException {\n            try {\n                return solve((RealVectorImpl) b);\n            } catch (ClassCastException cce) {\n\n                final int m = lTData.length;\n                if (b.getDimension() != m) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                            \"vector length mismatch: got {0} but expected {1}\",\n                            b.getDimension(), m);\n                }\n\n                final double[] x = b.getData();\n\n                // Solve LY = b\n                for (int j = 0; j < m; j++) {\n                    final double[] lJ = lTData[j];\n                    x[j] /= lJ[j];\n                    final double xJ = x[j];\n                    for (int i = j + 1; i < m; i++) {\n                        x[i] -= xJ * lJ[i];\n                    }\n                }\n\n                // Solve LTX = Y\n                for (int j = m - 1; j >= 0; j--) {\n                    x[j] /= lTData[j][j];\n                    final double xJ = x[j];\n                    for (int i = 0; i < j; i++) {\n                        x[i] -= xJ * lTData[i][j];\n                    }\n                }\n\n                return new RealVectorImpl(x, false);\n\n            }\n        }\n\n        /** Solve the linear equation A &times; X = B.\n         * <p>The A matrix is implicit here. It is </p>\n         * @param b right-hand side of the equation A &times; X = B\n         * @return a vector X such that A &times; X = B\n         * @exception IllegalArgumentException if matrices dimensions don't match\n         * @exception InvalidMatrixException if decomposed matrix is singular\n         */\n        public RealVectorImpl solve(RealVectorImpl b)\n            throws IllegalArgumentException, InvalidMatrixException {\n            return new RealVectorImpl(solve(b.getDataRef()), false);\n        }\n\n        /** {@inheritDoc} */\n        public RealMatrix solve(RealMatrix b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = lTData.length;\n            if (b.getRowDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n\n            final int nColB = b.getColumnDimension();\n            double[][] x = b.getData();\n\n            // Solve LY = b\n            for (int j = 0; j < m; j++) {\n                final double[] lJ = lTData[j];\n                final double lJJ = lJ[j];\n                final double[] xJ = x[j];\n                for (int k = 0; k < nColB; ++k) {\n                    xJ[k] /= lJJ;\n                }\n                for (int i = j + 1; i < m; i++) {\n                    final double[] xI = x[i];\n                    final double lJI = lJ[i];\n                    for (int k = 0; k < nColB; ++k) {\n                        xI[k] -= xJ[k] * lJI;\n                    }\n                }\n            }\n\n            // Solve LTX = Y\n            for (int j = m - 1; j >= 0; j--) {\n                final double lJJ = lTData[j][j];\n                final double[] xJ = x[j];\n                for (int k = 0; k < nColB; ++k) {\n                    xJ[k] /= lJJ;\n                }\n                for (int i = 0; i < j; i++) {\n                    final double[] xI = x[i];\n                    final double lIJ = lTData[i][j];\n                    for (int k = 0; k < nColB; ++k) {\n                        xI[k] -= xJ[k] * lIJ;\n                    }\n                }\n            }\n\n            return new RealMatrixImpl(x, false);\n\n        }\n\n        /** {@inheritDoc} */\n        public RealMatrix getInverse() throws InvalidMatrixException {\n            return solve(MatrixUtils.createRealIdentityMatrix(lTData.length));\n        }\n\n    }\n\n}\n", "review": {"response": "{ \"bugs\": [\n\n    {\n        \"description\": \"Infinite loop in the for loop that iterates over 'q' in the transformation of the matrix. The loop condition 'q > i' will always be true, leading to an infinite loop.\",\n        \"line\": \"for (int q = order - 1; q > i; --q) {\"\n    },\n\n    {\n        \"description\": \"Null Pointer Exception. The 'cachedL' and 'cachedLT' fields are never initialized and are used in the 'getL()' and 'getLT()' methods respectively. If these methods are called before the decomposition is performed, a Null Pointer Exception will occur.\",\n        \"line\": \"public RealMatrix getL() { return cachedL; }\",\n        \"line2\": \"public RealMatrix getLT() { return cachedLT; }\"\n    },\n\n    {\n        \"description\": \"Division by zero in the 'getSolver()' method. The 'solve(RealVector b)' method calls 'getSolver()' which divides 1.0 by the diagonal element of the 'lTData' matrix. If the matrix is not positive definite, this could lead to a division by zero.\",\n        \"line\": \"return new CholeskySolver(this) {\"\n    },\n\n    {\n        \"description\": \"Incorrect use of the 'Math.abs()' method in the check for symmetry. The 'Math.abs()' method should be used on the difference of the elements, not on the elements themselves.\",\n        \"line\": \"final double maxDelta = relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\"\n    },\n\n    {\n        \"description\": \"Potential precision loss in the calculation of the Cholesky decomposition. The 'lTData[i][i]' is squared and then taken the square root of, which could lead to a loss of precision.\",\n        \"line\": \"ltI[i] = Math.sqrt(ltI[i]);\"\n    }\n\n] }"}}