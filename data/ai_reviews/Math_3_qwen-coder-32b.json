{"sample_id": "Math_3", "model": "qwen-coder-32b", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.util;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport org.apache.commons.math3.Field;\nimport org.apache.commons.math3.exception.DimensionMismatchException;\nimport org.apache.commons.math3.exception.MathArithmeticException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.MathInternalError;\nimport org.apache.commons.math3.exception.NoDataException;\nimport org.apache.commons.math3.exception.NonMonotonicSequenceException;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\n\n/**\n * Arrays utilities.\n *\n * @since 3.0\n * @version $Id$\n */\npublic class MathArrays {\n    /** Factor used for splitting double numbers: n = 2^27 + 1 (i.e. {@value}). */\n    private static final int SPLIT_FACTOR = 0x8000001;\n\n    /**\n     * Private constructor.\n     */\n    private MathArrays() {}\n\n    /**\n     * Real-valued function that operate on an array or a part of it.\n     * @since 3.1\n     */\n    public interface Function {\n        /**\n         * Operates on an entire array.\n         *\n         * @param array Array to operate on.\n         * @return the result of the operation.\n         */\n        double evaluate(double[] array);\n        /**\n         * @param array Array to operate on.\n         * @param startIndex Index of the first element to take into account.\n         * @param numElements Number of elements to take into account.\n         * @return the result of the operation.\n         */\n        double evaluate(double[] array,\n                        int startIndex,\n                        int numElements);\n    }\n\n    /**\n     * Create a copy of an array scaled by a value.\n     *\n     * @param arr Array to scale.\n     * @param val Scalar.\n     * @return scaled copy of array with each entry multiplied by val.\n     * @since 3.2\n     */\n    public static double[] scale(double val, final double[] arr) {\n        double[] newArr = new double[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            newArr[i] = arr[i] * val;\n        }\n        return newArr;\n    }\n\n    /**\n     * <p>Multiply each element of an array by a value.</p>\n     *\n     * <p>The array is modified in place (no copy is created).</p>\n     *\n     * @param arr Array to scale\n     * @param val Scalar\n     * @since 3.2\n     */\n    public static void scaleInPlace(double val, final double[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] *= val;\n        }\n    }\n\n    /**\n     * Creates an array whose contents will be the element-by-element\n     * addition of the arguments.\n     *\n     * @param a First term of the addition.\n     * @param b Second term of the addition.\n     * @return a new array {@code r} where {@code r[i] = a[i] + b[i]}.\n     * @throws DimensionMismatchException if the array lengths differ.\n     * @since 3.1\n     */\n    public static double[] ebeAdd(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] += b[i];\n        }\n        return result;\n    }\n    /**\n     * Creates an array whose contents will be the element-by-element\n     * subtraction of the second argument from the first.\n     *\n     * @param a First term.\n     * @param b Element to be subtracted.\n     * @return a new array {@code r} where {@code r[i] = a[i] - b[i]}.\n     * @throws DimensionMismatchException if the array lengths differ.\n     * @since 3.1\n     */\n    public static double[] ebeSubtract(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] -= b[i];\n        }\n        return result;\n    }\n    /**\n     * Creates an array whose contents will be the element-by-element\n     * multiplication of the arguments.\n     *\n     * @param a First factor of the multiplication.\n     * @param b Second factor of the multiplication.\n     * @return a new array {@code r} where {@code r[i] = a[i] * b[i]}.\n     * @throws DimensionMismatchException if the array lengths differ.\n     * @since 3.1\n     */\n    public static double[] ebeMultiply(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] *= b[i];\n        }\n        return result;\n    }\n    /**\n     * Creates an array whose contents will be the element-by-element\n     * division of the first argument by the second.\n     *\n     * @param a Numerator of the division.\n     * @param b Denominator of the division.\n     * @return a new array {@code r} where {@code r[i] = a[i] / b[i]}.\n     * @throws DimensionMismatchException if the array lengths differ.\n     * @since 3.1\n     */\n    public static double[] ebeDivide(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] /= b[i];\n        }\n        return result;\n    }\n\n    /**\n     * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>1</sub> distance between the two points\n     */\n    public static double distance1(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += FastMath.abs(p1[i] - p2[i]);\n        }\n        return sum;\n    }\n\n    /**\n     * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>1</sub> distance between the two points\n     */\n    public static int distance1(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          sum += FastMath.abs(p1[i] - p2[i]);\n      }\n      return sum;\n    }\n\n    /**\n     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>2</sub> distance between the two points\n     */\n    public static double distance(double[] p1, double[] p2) {\n        double sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            final double dp = p1[i] - p2[i];\n            sum += dp * dp;\n        }\n        return FastMath.sqrt(sum);\n    }\n\n    /**\n     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>2</sub> distance between the two points\n     */\n    public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return FastMath.sqrt(sum);\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static int distanceInf(int[] p1, int[] p2) {\n        int max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    /**\n     * Specification of ordering direction.\n     */\n    public static enum OrderDirection {\n        /** Constant for increasing direction. */\n        INCREASING,\n        /** Constant for decreasing direction. */\n        DECREASING\n    }\n\n    /**\n     * Check that an array is monotonically increasing or decreasing.\n     *\n     * @param <T> the type of the elements in the specified array\n     * @param val Values.\n     * @param dir Ordering direction.\n     * @param strict Whether the order should be strict.\n     * @return {@code true} if sorted, {@code false} otherwise.\n     */\n    public static  <T extends Comparable<? super T>> boolean isMonotonic(T[] val,\n                                      OrderDirection dir,\n                                      boolean strict) {\n        T previous = val[0];\n        final int max = val.length;\n        for (int i = 1; i < max; i++) {\n            final int comp;\n            switch (dir) {\n            case INCREASING:\n                comp = previous.compareTo(val[i]);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            case DECREASING:\n                comp = val[i].compareTo(previous);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                       return false;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n\n            previous = val[i];\n        }\n        return true;\n    }\n\n    /**\n     * Check that an array is monotonically increasing or decreasing.\n     *\n     * @param val Values.\n     * @param dir Ordering direction.\n     * @param strict Whether the order should be strict.\n     * @return {@code true} if sorted, {@code false} otherwise.\n     */\n    public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {\n        return checkOrder(val, dir, strict, false);\n    }\n\n    /**\n     * Check that the given array is sorted.\n     *\n     * @param val Values.\n     * @param dir Ordering direction.\n     * @param strict Whether the order should be strict.\n     * @param abort Whether to throw an exception if the check fails.\n     * @return {@code true} if the array is sorted.\n     * @throws NonMonotonicSequenceException if the array is not sorted\n     * and {@code abort} is {@code true}.\n     */\n    public static boolean checkOrder(double[] val, OrderDirection dir,\n                                     boolean strict, boolean abort)\n        throws NonMonotonicSequenceException {\n        double previous = val[0];\n        final int max = val.length;\n\n        int index;\n        ITEM:\n        for (index = 1; index < max; index++) {\n            switch (dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[index] <= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] < previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[index] >= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] > previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n\n            previous = val[index];\n        }\n\n        if (index == max) {\n            // Loop completed.\n            return true;\n        }\n\n        // Loop early exit means wrong ordering.\n        if (abort) {\n            throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Check that the given array is sorted.\n     *\n     * @param val Values.\n     * @param dir Ordering direction.\n     * @param strict Whether the order should be strict.\n     * @throws NonMonotonicSequenceException if the array is not sorted.\n     * @since 2.2\n     */\n    public static void checkOrder(double[] val, OrderDirection dir,\n                                  boolean strict) throws NonMonotonicSequenceException {\n        checkOrder(val, dir, strict, true);\n    }\n\n    /**\n     * Check that the given array is sorted in strictly increasing order.\n     *\n     * @param val Values.\n     * @throws NonMonotonicSequenceException if the array is not sorted.\n     * @since 2.2\n     */\n    public static void checkOrder(double[] val) throws NonMonotonicSequenceException {\n        checkOrder(val, OrderDirection.INCREASING, true);\n    }\n\n    /**\n     * Throws DimensionMismatchException if the input array is not rectangular.\n     *\n     * @param in array to be tested\n     * @throws NullArgumentException if input array is null\n     * @throws DimensionMismatchException if input array is not rectangular\n     * @since 3.1\n     */\n    public static void checkRectangular(final long[][] in)\n        throws NullArgumentException, DimensionMismatchException {\n        MathUtils.checkNotNull(in);\n        for (int i = 1; i < in.length; i++) {\n            if (in[i].length != in[0].length) {\n                throw new DimensionMismatchException(\n                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n                        in[i].length, in[0].length);\n            }\n        }\n    }\n\n    /**\n     * Check that all entries of the input array are strictly positive.\n     *\n     * @param in Array to be tested\n     * @throws NotStrictlyPositiveException if any entries of the array are not\n     * strictly positive.\n     * @since 3.1\n     */\n    public static void checkPositive(final double[] in)\n        throws NotStrictlyPositiveException {\n        for (int i = 0; i < in.length; i++) {\n            if (in[i] <= 0) {\n                throw new NotStrictlyPositiveException(in[i]);\n            }\n        }\n    }\n\n    /**\n     * Check that all entries of the input array are >= 0.\n     *\n     * @param in Array to be tested\n     * @throws NotPositiveException if any array entries are less than 0.\n     * @since 3.1\n     */\n    public static void checkNonNegative(final long[] in)\n        throws NotPositiveException {\n        for (int i = 0; i < in.length; i++) {\n            if (in[i] < 0) {\n                throw new NotPositiveException(in[i]);\n            }\n        }\n    }\n\n    /**\n     * Check all entries of the input array are >= 0.\n     *\n     * @param in Array to be tested\n     * @throws NotPositiveException if any array entries are less than 0.\n     * @since 3.1\n     */\n    public static void checkNonNegative(final long[][] in)\n        throws NotPositiveException {\n        for (int i = 0; i < in.length; i ++) {\n            for (int j = 0; j < in[i].length; j++) {\n                if (in[i][j] < 0) {\n                    throw new NotPositiveException(in[i][j]);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\n     * Translation of the minpack enorm subroutine.\n     *\n     * The redistribution policy for MINPACK is available\n     * <a href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n     * convenience, it is reproduced below.</p>\n     *\n     * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n     * <tr><td>\n     *    Minpack Copyright Notice (1999) University of Chicago.\n     *    All rights reserved\n     * </td></tr>\n     * <tr><td>\n     * Redistribution and use in source and binary forms, with or without\n     * modification, are permitted provided that the following conditions\n     * are met:\n     * <ol>\n     *  <li>Redistributions of source code must retain the above copyright\n     *      notice, this list of conditions and the following disclaimer.</li>\n     * <li>Redistributions in binary form must reproduce the above\n     *     copyright notice, this list of conditions and the following\n     *     disclaimer in the documentation and/or other materials provided\n     *     with the distribution.</li>\n     * <li>The end-user documentation included with the redistribution, if any,\n     *     must include the following acknowledgment:\n     *     {@code This product includes software developed by the University of\n     *           Chicago, as Operator of Argonne National Laboratory.}\n     *     Alternately, this acknowledgment may appear in the software itself,\n     *     if and wherever such third-party acknowledgments normally appear.</li>\n     * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n     *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n     *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n     *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n     *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n     *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n     *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n     *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n     *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n     *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n     *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n     *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n     *     BE CORRECTED.</strong></li>\n     * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n     *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n     *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n     *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n     *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n     *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n     *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n     *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n     *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n     *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n     * <ol></td></tr>\n     * </table>\n     *\n     * @param v Vector of doubles.\n     * @return the 2-norm of the vector.\n     * @since 2.2\n     */\n    public static double safeNorm(double[] v) {\n        double rdwarf = 3.834e-20;\n        double rgiant = 1.304e+19;\n        double s1 = 0;\n        double s2 = 0;\n        double s3 = 0;\n        double x1max = 0;\n        double x3max = 0;\n        double floatn = v.length;\n        double agiant = rgiant / floatn;\n        for (int i = 0; i < v.length; i++) {\n            double xabs = Math.abs(v[i]);\n            if (xabs < rdwarf || xabs > agiant) {\n                if (xabs > rdwarf) {\n                    if (xabs > x1max) {\n                        double r = x1max / xabs;\n                        s1= 1 + s1 * r * r;\n                        x1max = xabs;\n                    } else {\n                        double r = xabs / x1max;\n                        s1 += r * r;\n                    }\n                } else {\n                    if (xabs > x3max) {\n                        double r = x3max / xabs;\n                        s3= 1 + s3 * r * r;\n                        x3max = xabs;\n                    } else {\n                        if (xabs != 0) {\n                            double r = xabs / x3max;\n                            s3 += r * r;\n                        }\n                    }\n                }\n            } else {\n                s2 += xabs * xabs;\n            }\n        }\n        double norm;\n        if (s1 != 0) {\n            norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n        } else {\n            if (s2 == 0) {\n                norm = x3max * Math.sqrt(s3);\n            } else {\n                if (s2 >= x3max) {\n                    norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n                } else {\n                    norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n                }\n            }\n        }\n        return norm;\n    }\n\n    /**\n     * Sort an array in ascending order in place and perform the same reordering\n     * of entries on other arrays. For example, if\n     * {@code x = [3, 1, 2], y = [1, 2, 3]} and {@code z = [0, 5, 7]}, then\n     * {@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]},\n     * {@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.\n     *\n     * @param x Array to be sorted and used as a pattern for permutation\n     * of the other arrays.\n     * @param yList Set of arrays whose permutations of entries will follow\n     * those performed on {@code x}.\n     * @throws DimensionMismatchException if any {@code y} is not the same\n     * size as {@code x}.\n     * @throws NullArgumentException if {@code x} or any {@code y} is null.\n     * @since 3.0\n     */\n    public static void sortInPlace(double[] x, double[] ... yList)\n        throws DimensionMismatchException, NullArgumentException {\n        sortInPlace(x, OrderDirection.INCREASING, yList);\n    }\n\n    /**\n     * Sort an array in place and perform the same reordering of entries on\n     * other arrays.  This method works the same as the other\n     * {@link #sortInPlace(double[], double[][]) sortInPlace} method, but\n     * allows the order of the sort to be provided in the {@code dir}\n     * parameter.\n     *\n     * @param x Array to be sorted and used as a pattern for permutation\n     * of the other arrays.\n     * @param dir Order direction.\n     * @param yList Set of arrays whose permutations of entries will follow\n     * those performed on {@code x}.\n     * @throws DimensionMismatchException if any {@code y} is not the same\n     * size as {@code x}.\n     * @throws NullArgumentException if {@code x} or any {@code y} is null\n     * @since 3.0\n     */\n    public static void sortInPlace(double[] x,\n                                   final OrderDirection dir,\n                                   double[] ... yList)\n        throws NullArgumentException,\n               DimensionMismatchException {\n\n        // Consistency checks.\n        if (x == null) {\n            throw new NullArgumentException();\n        }\n\n        final int yListLen = yList.length;\n        final int len = x.length;\n\n        for (int j = 0; j < yListLen; j++) {\n            final double[] y = yList[j];\n            if (y == null) {\n                throw new NullArgumentException();\n            }\n            if (y.length != len) {\n                throw new DimensionMismatchException(y.length, len);\n            }\n        }\n\n        // Associate each abscissa \"x[i]\" with its index \"i\".\n        final List<Pair<Double, Integer>> list\n            = new ArrayList<Pair<Double, Integer>>(len);\n        for (int i = 0; i < len; i++) {\n            list.add(new Pair<Double, Integer>(x[i], i));\n        }\n\n        // Create comparators for increasing and decreasing orders.\n        final Comparator<Pair<Double, Integer>> comp\n            = dir == MathArrays.OrderDirection.INCREASING ?\n            new Comparator<Pair<Double, Integer>>() {\n            public int compare(Pair<Double, Integer> o1,\n                               Pair<Double, Integer> o2) {\n                return o1.getKey().compareTo(o2.getKey());\n            }\n        } : new Comparator<Pair<Double,Integer>>() {\n            public int compare(Pair<Double, Integer> o1,\n                               Pair<Double, Integer> o2) {\n                return o2.getKey().compareTo(o1.getKey());\n            }\n        };\n\n        // Sort.\n        Collections.sort(list, comp);\n\n        // Modify the original array so that its elements are in\n        // the prescribed order.\n        // Retrieve indices of original locations.\n        final int[] indices = new int[len];\n        for (int i = 0; i < len; i++) {\n            final Pair<Double, Integer> e = list.get(i);\n            x[i] = e.getKey();\n            indices[i] = e.getValue();\n        }\n\n        // In each of the associated arrays, move the\n        // elements to their new location.\n        for (int j = 0; j < yListLen; j++) {\n            // Input array will be modified in place.\n            final double[] yInPlace = yList[j];\n            final double[] yOrig = yInPlace.clone();\n\n            for (int i = 0; i < len; i++) {\n                yInPlace[i] = yOrig[indices[i]];\n            }\n        }\n    }\n\n    /**\n     * Creates a copy of the {@code source} array.\n     *\n     * @param source Array to be copied.\n     * @return the copied array.\n     */\n     public static int[] copyOf(int[] source) {\n         return copyOf(source, source.length);\n     }\n\n    /**\n     * Creates a copy of the {@code source} array.\n     *\n     * @param source Array to be copied.\n     * @return the copied array.\n     */\n     public static double[] copyOf(double[] source) {\n         return copyOf(source, source.length);\n     }\n\n    /**\n     * Creates a copy of the {@code source} array.\n     *\n     * @param source Array to be copied.\n     * @param len Number of entries to copy. If smaller then the source\n     * length, the copy will be truncated, if larger it will padded with\n     * zeroes.\n     * @return the copied array.\n     */\n    public static int[] copyOf(int[] source, int len) {\n         final int[] output = new int[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }\n\n    /**\n     * Creates a copy of the {@code source} array.\n     *\n     * @param source Array to be copied.\n     * @param len Number of entries to copy. If smaller then the source\n     * length, the copy will be truncated, if larger it will padded with\n     * zeroes.\n     * @return the copied array.\n     */\n    public static double[] copyOf(double[] source, int len) {\n         final double[] output = new double[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }\n\n    /**\n     * Compute a linear combination accurately.\n     * This method computes the sum of the products\n     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n     * It does so by using specific multiplication and addition algorithms to\n     * preserve accuracy and reduce cancellation effects.\n     * <br/>\n     * It is based on the 2005 paper\n     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     *\n     * @param a Factors.\n     * @param b Factors.\n     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n     * @throws DimensionMismatchException if arrays dimensions don't match\n     */\n    public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n            // Revert to scalar multiplication.\n\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n\n\n        final double prodHighCur = prodHigh[0];\n        double prodHighNext = prodHigh[1];\n        double sHighPrev = prodHighCur + prodHighNext;\n        double sPrime = sHighPrev - prodHighNext;\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            prodHighNext = prodHigh[i + 1];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Compute a linear combination accurately.\n     * <p>\n     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does\n     * so by using specific multiplication and addition algorithms to\n     * preserve accuracy and reduce cancellation effects. It is based\n     * on the 2005 paper <a\n     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     * </p>\n     * @param a1 first factor of the first term\n     * @param b1 second factor of the first term\n     * @param a2 first factor of the second term\n     * @param b2 second factor of the second term\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub>\n     * @see #linearCombination(double, double, double, double, double, double)\n     * @see #linearCombination(double, double, double, double, double, double, double, double)\n     */\n    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variable naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // final rounding, s12 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result = s12High + (prod1Low + prod2Low + s12Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = a1 * b1 + a2 * b2;\n        }\n\n        return result;\n    }\n\n    /**\n     * Compute a linear combination accurately.\n     * <p>\n     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n     * to high accuracy. It does so by using specific multiplication and\n     * addition algorithms to preserve accuracy and reduce cancellation effects.\n     * It is based on the 2005 paper <a\n     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     * </p>\n     * @param a1 first factor of the first term\n     * @param b1 second factor of the first term\n     * @param a2 first factor of the second term\n     * @param b2 second factor of the second term\n     * @param a3 first factor of the third term\n     * @param b3 second factor of the third term\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n     * @see #linearCombination(double, double, double, double)\n     * @see #linearCombination(double, double, double, double, double, double, double, double)\n     */\n    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2,\n                                           final double a3, final double b3) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // do use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variables naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // split a3 and b3 as two 26 bits numbers\n        final double ca3        = SPLIT_FACTOR * a3;\n        final double a3High     = ca3 - (ca3 - a3);\n        final double a3Low      = a3 - a3High;\n        final double cb3        = SPLIT_FACTOR * b3;\n        final double b3High     = cb3 - (cb3 - b3);\n        final double b3Low      = b3 - b3High;\n\n        // accurate multiplication a3 * b3\n        final double prod3High  = a3 * b3;\n        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n        final double s123High   = s12High + prod3High;\n        final double s123Prime  = s123High - prod3High;\n        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        // final rounding, s123 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = a1 * b1 + a2 * b2 + a3 * b3;\n        }\n\n        return result;\n    }\n\n    /**\n     * Compute a linear combination accurately.\n     * <p>\n     * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n     * a<sub>4</sub>&times;b<sub>4</sub>\n     * to high accuracy. It does so by using specific multiplication and\n     * addition algorithms to preserve accuracy and reduce cancellation effects.\n     * It is based on the 2005 paper <a\n     * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n     * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     * </p>\n     * @param a1 first factor of the first term\n     * @param b1 second factor of the first term\n     * @param a2 first factor of the second term\n     * @param b2 second factor of the second term\n     * @param a3 first factor of the third term\n     * @param b3 second factor of the third term\n     * @param a4 first factor of the third term\n     * @param b4 second factor of the third term\n     * @return a<sub>1</sub>&times;b<sub>1</sub> +\n     * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n     * a<sub>4</sub>&times;b<sub>4</sub>\n     * @see #linearCombination(double, double, double, double)\n     * @see #linearCombination(double, double, double, double, double, double)\n     */\n    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2,\n                                           final double a3, final double b3,\n                                           final double a4, final double b4) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // do use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variables naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // split a3 and b3 as two 26 bits numbers\n        final double ca3        = SPLIT_FACTOR * a3;\n        final double a3High     = ca3 - (ca3 - a3);\n        final double a3Low      = a3 - a3High;\n        final double cb3        = SPLIT_FACTOR * b3;\n        final double b3High     = cb3 - (cb3 - b3);\n        final double b3Low      = b3 - b3High;\n\n        // accurate multiplication a3 * b3\n        final double prod3High  = a3 * b3;\n        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        // split a4 and b4 as two 26 bits numbers\n        final double ca4        = SPLIT_FACTOR * a4;\n        final double a4High     = ca4 - (ca4 - a4);\n        final double a4Low      = a4 - a4High;\n        final double cb4        = SPLIT_FACTOR * b4;\n        final double b4High     = cb4 - (cb4 - b4);\n        final double b4Low      = b4 - b4High;\n\n        // accurate multiplication a4 * b4\n        final double prod4High  = a4 * b4;\n        final double prod4Low   = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n        final double s123High   = s12High + prod3High;\n        final double s123Prime  = s123High - prod3High;\n        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4\n        final double s1234High  = s123High + prod4High;\n        final double s1234Prime = s1234High - prod4High;\n        final double s1234Low   = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n\n        // final rounding, s1234 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link Precision#equals(float,float)}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension\n     * and equal elements.\n     */\n    public static boolean equals(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns true iff both arguments are null or have same dimensions and all\n     * their elements are equal as defined by\n     * {@link Precision#equalsIncludingNaN(double,double) this method}.\n     *\n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension and\n     * equal elements\n     * @since 2.2\n     */\n    public static boolean equalsIncludingNaN(float[] x, float[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} iff both arguments are {@code null} or have same\n     * dimensions and all their elements are equal as defined by\n     * {@link Precision#equals(double,double)}.\n     *\n     * @param x First array.\n     * @param y Second array.\n     * @return {@code true} if the values are both {@code null} or have same\n     * dimension and equal elements.\n     */\n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} iff both arguments are {@code null} or have same\n     * dimensions and all their elements are equal as defined by\n     * {@link Precision#equalsIncludingNaN(double,double) this method}.\n     *\n     * @param x First array.\n     * @param y Second array.\n     * @return {@code true} if the values are both {@code null} or have same\n     * dimension and equal elements.\n     * @since 2.2\n     */\n    public static boolean equalsIncludingNaN(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n     /**\n      * Normalizes an array to make it sum to a specified value.\n      * Returns the result of the transformation <pre>\n      *    x |-> x * normalizedSum / sum\n      * </pre>\n      * applied to each non-NaN element x of the input array, where sum is the\n      * sum of the non-NaN entries in the input array.</p>\n      *\n      * <p>Throws IllegalArgumentException if {@code normalizedSum} is infinite\n      * or NaN and ArithmeticException if the input array contains any infinite elements\n      * or sums to 0.</p>\n      *\n      * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>\n      *\n      * @param values Input array to be normalized\n      * @param normalizedSum Target sum for the normalized array\n      * @return the normalized array.\n      * @throws MathArithmeticException if the input array contains infinite\n      * elements or sums to zero.\n      * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.\n      * @since 2.1\n      */\n     public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException {\n         if (Double.isInfinite(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n         }\n         if (Double.isNaN(normalizedSum)) {\n             throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n         }\n         double sum = 0d;\n         final int len = values.length;\n         double[] out = new double[len];\n         for (int i = 0; i < len; i++) {\n             if (Double.isInfinite(values[i])) {\n                 throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n             }\n             if (!Double.isNaN(values[i])) {\n                 sum += values[i];\n             }\n         }\n         if (sum == 0) {\n             throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n         }\n         for (int i = 0; i < len; i++) {\n             if (Double.isNaN(values[i])) {\n                 out[i] = Double.NaN;\n             } else {\n                 out[i] = values[i] * normalizedSum / sum;\n             }\n         }\n         return out;\n     }\n\n     /** Build an array of elements.\n      * <p>\n      * Arrays are filled with field.getZero()\n      * </p>\n      * @param <T> the type of the field elements\n      * @param field field to which array elements belong\n      * @param length of the array\n      * @return a new array\n      * @since 3.2\n      */\n     public static <T> T[] buildArray(final Field<T> field, final int length) {\n         @SuppressWarnings(\"unchecked\") // OK because field must be correct class\n         T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);\n         Arrays.fill(array, field.getZero());\n         return array;\n     }\n\n     /** Build a double dimension  array of elements.\n      * <p>\n      * Arrays are filled with field.getZero()\n      * </p>\n      * @param <T> the type of the field elements\n      * @param field field to which array elements belong\n      * @param rows number of rows in the array\n      * @param columns number of columns (may be negative to build partial\n      * arrays in the same way <code>new Field[rows][]</code> works)\n      * @return a new array\n      * @since 3.2\n      */\n     @SuppressWarnings(\"unchecked\")\n    public static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n         final T[][] array;\n         if (columns < 0) {\n             T[] dummyRow = buildArray(field, 0);\n             array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n         } else {\n             array = (T[][]) Array.newInstance(field.getRuntimeClass(),\n                                               new int[] {\n                                                   rows, columns\n                                               });\n             for (int i = 0; i < rows; ++i) {\n                 Arrays.fill(array[i], field.getZero());\n             }\n         }\n         return array;\n     }\n\n     /**\n      * Calculates the <a href=\"http://en.wikipedia.org/wiki/Convolution\">\n      * convolution</a> between two sequences.\n      * The solution is obtained via straightforward computation of the\n      * convolution sum (and not via FFT).\n      * Whenever the computation needs an element that would be located\n      * at an index outside the input arrays, the value is assumed to be\n      * zero.\n      *\n      * @param x First sequence.\n      * Typically, this sequence will represent an input signal to a system.\n      * @param h Second sequence.\n      * Typically, this sequence will represent the impulse response of the\n      * system.\n      * @return the convolution of {@code x} and {@code h}.\n      * This array's length will be {@code x.length + h.length - 1}.\n      * @throws NullArgumentException if either {@code x} or {@code h} is\n      * {@code null}.\n      * @throws NoDataException if either {@code x} or {@code h} is empty.\n      *\n      * @since 3.3\n      */\n     public static double[] convolve(double[] x, double[] h)\n         throws NullArgumentException,\n                NoDataException {\n         MathUtils.checkNotNull(x);\n         MathUtils.checkNotNull(h);\n\n         final int xLen = x.length;\n         final int hLen = h.length;\n\n         if (xLen == 0 || hLen == 0) {\n             throw new NoDataException();\n         }\n\n         // initialize the output array\n         final int totalLength = xLen + hLen - 1;\n         final double[] y = new double[totalLength];\n\n         // straightforward implementation of the convolution sum\n         for (int n = 0; n < totalLength; n++) {\n             double yn = 0;\n             int k = FastMath.max(0, n + 1 - xLen);\n             int j = n - k;\n             while (k < hLen && j >= 0) {\n                 yn += x[j--] * h[k++];\n             }\n             y[n] = yn;\n         }\n\n         return y;\n     }\n}\n", "review": {"response": "<think>\nOkay, let's take a look at this Java code for possible bugs. The user wants me to review the provided code and return a JSON list of bugs. The code is part of the Apache Commons Math library, specifically the MathArrays class. \n\nFirst, I'll start by scanning through the code for any obvious issues. Let's go method by method.\n\nStarting with the `scale` method. It creates a new array and multiplies each element by the given value. That seems straightforward. No obvious issues here.\n\nNext is `scaleInPlace`, which modifies the array in place. Again, looks correct. The loop is correct, and it's modifying the original array, which is the intended behavior according to the Javadoc.\n\nLooking at `ebeAdd`, `ebeSubtract`, and `ebeMultiply`. Let's check `ebeAdd` first. It clones array 'a' and then adds each element of 'b' to the cloned array. That should work. But wait, if 'a' is modified elsewhere after this method is called, it shouldn't affect the result because we're cloning it. So that's correct.\n\nSame for `ebeSubtract` and `ebeMultiply`. Cloning 'a' and then modifying the clone. That's correct. The dimension check is also there, which is necessary to prevent IndexOutOfBoundsException. So those methods seem okay.\n\nWait, but looking at the code for `ebeMultiply`, the method is cut off. The user provided code ends in the middle of the method. The original code probably continues, but in the given snippet, it's incomplete. However, since the user provided this code, maybe that's a typo or a cut-off. But since the user is asking to review the code as given, perhaps that's a bug? Or maybe it's just an error in the user's input when pasting the code. Let me check.\n\nThe code for `ebeMultiply` ends with:\n\n        for (int i = 0; i < a.length; i++) {\n            result[i] *= b[i];\n        }\n        return result;\n    }\n\nBut in the user's provided code, the last method is cut off with a ``` mark. Wait, looking back at the user's input:\n\nThe code ends with:\n\n    /**\n     * Creates an array whose contents will be the element-by-element\n     ``` \n\nWait, no. Wait, the user's code input is:\n\nThe code given by the user is:\n\nThe code ends with:\n\n    /**\n     * Creates an array whose contents will be the element-by-element\n     * multiplication of the arguments.\n     *\n     * @param a First factor of the multiplication.\n     * @param b Second factor of the multiplication.\n     * @return a new array {@code r} where {@code r[i] = a[i] * b[i]}.\n     * @throws DimensionMismatchException if the array lengths differ.\n     * @since 3.1\n     */\n    public static double[] ebeMultiply(double[] a, double[] b)\n        throws DimensionMismatchException {\n        if (a.length != b.length) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n\n        final double[] result = a.clone();\n        for (int i = 0; i < a.length; i++) {\n            result[i] *= b[i];\n        }\n        return result;\n    }\n    /**\n     * Creates an array whose contents will be the element-by-element\n     ```\n\nWait, the last line is incomplete. The user's code input ends with a line that starts with \"* Creates an array whose contents will be the element-by-element\" but is cut off. That suggests that the code is incomplete. However, perhaps the user made a mistake when pasting the code. But in the code provided, the ebeMultiply method is complete. The next method after that is cut off. Wait, perhaps the user's code has a typo in the last method. Let me check again.\n\nLooking at the code given by the user:\n\nThe last method is ebeMultiply, which is properly closed with a }, and then there's a /** which starts a new Javadoc comment, but the code is cut off. So the actual code as provided by the user is incomplete. But since the user is asking to review the code as given, perhaps this is a bug? Like, a missing method or a syntax error.\n\nWait, but in the code provided, the ebeMultiply method is properly closed. The next line is a Javadoc comment for another method, but the method itself is not present. So that's an incomplete code. However, the user is providing this code, so maybe it's a typo or a mistake in their input. But when reviewing the code for bugs, this would be an issue. However, since the user is providing the code, perhaps they intended to include all methods. Alternatively, maybe this is a formatting error when they pasted the code.\n\nBut in the code provided, the ebeMultiply method is correctly written. The code after that is a Javadoc comment for a method that's not implemented. But that's not part of the code that's supposed to be reviewed. So perhaps that's a red herring.\n\nNow, looking for other possible bugs. Let's check the methods again.\n\nIn ebeAdd, the code clones array 'a' and then adds elements of 'b'. What if 'a' is null? Well, the method's parameters are double[], so if a is null, then a.clone() would throw a NullPointerException. But according to the Javadoc, does the method check for null arguments? Let's check the exceptions listed. The Javadoc for ebeAdd says it throws DimensionMismatchException. But if either a or b is null, then a.length would cause a NullPointerException. So the code doesn't handle null inputs. But in the Javadoc, there's no mention of NullArgumentException. So this is a potential bug. The code should check for null inputs and throw a NullArgumentException.\n\nLooking at the imports, the class does import org.apache.commons.math3.exception.NullArgumentException, so it's possible that the code should include checks for null arguments.\n\nFor example, in ebeAdd:\n\npublic static double[] ebeAdd(double[] a, double[] b)\n    throws DimensionMismatchException {\n    if (a.length != b.length) {\n        throw new DimensionMismatchException(a.length, b.length);\n    }\n\nBut if a or b is null, then accessing a.length would throw NPE. So the code should first check if a and b are null. For example:\n\nif (a == null) {\n    throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n}\nif (b == null) {\n    throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n}\n\nBut the current code does not do that. So this is a bug. The same applies to ebeSubtract and ebeMultiply. All these methods don't check for null inputs, which can lead to NPEs. Therefore, this is a bug.\n\nAnother possible issue: in the ebeAdd method, the code clones array 'a', then adds elements of 'b' to the clone. However, if the user intended to create a new array where each element is a[i] + b[i], then cloning 'a' and modifying it is correct. However, what if the user wants to add the two arrays without modifying the original 'a'? Well, the code is correct in that it clones 'a' first. So that's okay.\n\nAnother possible issue: in the ebeMultiply method, the code is correct. The loop runs from 0 to a.length (which is same as b.length due to the check), and multiplies each element. So that's correct.\n\nAnother thing to check: the methods ebeAdd, subtract, multiply return a new array. The Javadoc says that ebeAdd returns a new array where each element is a[i] + b[i]. The code does that. So that's correct.\n\nAnother possible bug: in the scale method, if the input array is null, then new double[arr.length] would throw NPE. So the code doesn't check for null. Similarly, in scaleInPlace, if arr is null, then the loop would throw NPE. The Javadocs for these methods don't mention checking for null, so this could be a bug. Let's check the Javadocs.\n\nFor the scale method: the Javadoc says \"Array to scale.\" but doesn't mention handling null. So if arr is null, the code would throw NPE. Similarly for scaleInPlace. So these methods should check if the input array is null and throw NullArgumentException. But they don't. That's another bug.\n\nSame applies to the ebeAdd, subtract, multiply methods. All of them don't check for null inputs, leading to potential NPEs.\n\nSo the main bugs here are:\n\n1. Missing null checks in scale, scaleInPlace, ebeAdd, ebeSubtract, ebeMultiply. These methods can throw NullPointerException if the input arrays are null, instead of throwing a NullArgumentException.\n\n2. The code provided ends with an incomplete Javadoc comment and method, but that's likely a user error when pasting the code, not a bug in the actual code. However, since the user is asking to review the code as given, perhaps that's a bug. But since the user's code is cut off, maybe it's not part of the actual code. Let me check again.\n\nLooking at the user's code:\n\nThe last line is:\n\n    /**\n     * Creates an array whose contents will be the element-by-element\n     ```\n\nWhich is a Javadoc comment that's cut off. The rest of the code is properly closed. So perhaps this is a typo or formatting error when the user pasted the code. But in the actual code that's supposed to be reviewed, this is not part of it. So maybe that's not a bug in the code but an error in the user's input. However, since the user included it, perhaps they intended to include all code. But since the code is incomplete here, it's hard to say. However, since the rest of the code is correct, perhaps this is not a bug in the code but a mistake in the user's input. So I'll focus on the actual code that's present.\n\nSo the main bugs are the missing null checks.\n\nAnother possible issue: in the ebeMultiply method, the code uses a.clone(). For arrays of primitives, the clone method creates a copy. So that's correct. So no problem here.\n\nAnother thing to check: the parameters for the ebeAdd method. The code says final double[] result = a.clone(); then loops through and adds b[i] to result[i]. That's correct. Similarly for subtract and multiply.\n\nAnother possible issue: in the scale method, if the input array is empty (length 0), it returns an empty array. That's acceptable, as per the Javadoc. The Javadoc doesn't mention handling empty arrays, but it's allowed.\n\nSo the main bugs are the missing null checks. Let's list them.\n\nEach of the methods (scale, scaleInPlace, ebeAdd, ebeSubtract, ebeMultiply) does not check if their input arrays are null. For example, in scale:\n\npublic static double[] scale(double val, final double[] arr) {\n    double[] newArr = new double[arr.length]; // if arr is null, this line throws NPE\n    ...\n}\n\nSo the code should check if arr is null and throw a NullArgumentException. Similarly for the other methods.\n\nSo each of these methods is missing null checks for their array parameters. That's a bug.\n\nAnother possible issue: in the ebeAdd method, the code clones array 'a' but not 'b'. However, since the method is supposed to create a new array, and 'b' is not modified, it's okay. The code is correct in that aspect.\n\nSo the bugs are:\n\n1. In the scale method, no check for null arr. If arr is null, NPE is thrown instead of NullArgumentException.\n\n2. In scaleInPlace, same issue.\n\n3. In ebeAdd, ebeSubtract, ebeMultiply, no checks for null a or b. So if either is null, NPE is thrown.\n\nSo each of these methods should add checks for null inputs.\n\nAnother possible bug: in the ebeMultiply method, the code is correct, but if the arrays are of zero length, it returns an empty array. The Javadoc doesn't mention handling empty arrays, but that's acceptable.\n\nAnother thing to check: the code uses a.clone() which for a double array creates a shallow copy. Since it's a primitive array, it's a deep copy. So that's correct.\n\nAnother possible issue: in the ebeAdd method, the code clones 'a' and then modifies the clone. So the original 'a' is not modified. That's correct.\n\nSo the main bugs are the missing null checks.\n\nNow, to summarize the bugs:\n\n- scale method doesn't check if arr is null.\n- scaleInPlace doesn't check if arr is null.\n- ebeAdd doesn't check if a or b is null.\n- ebeSubtract doesn't check if a or b is null.\n- ebeMultiply doesn't check if a or b is null.\n\nEach of these would throw a NullPointerException if the array parameters are null, instead of throwing a NullArgumentException as per the library's conventions.\n\nTherefore, these are bugs that should be fixed by adding null checks and throwing appropriate exceptions.\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"lineNumber\": 116,\n      \"description\": \"The 'scale' method does not check if the input array 'arr' is null. This can lead to a NullPointerException instead of throwing a NullArgumentException.\",\n      \"severity\": \"High\"\n    },\n    {\n      \"lineNumber\": 126,\n      \"description\": \"The 'scaleInPlace' method does not check if the input array 'arr' is null. This can lead to a NullPointerException instead of throwing a NullArgumentException.\",\n      \"severity\": \"High\"\n    },\n    {\n      \"lineNumber\": 144,\n      \"description\": \"The 'ebeAdd' method does not check if the input arrays 'a' or 'b' are null. This can lead to a NullPointerException instead of throwing a NullArgumentException.\",\n      \"severity\": \"High\"\n    },\n    {\n      \"lineNumber\": 175,\n      \"description\": \"The 'ebeSubtract' method does not check if the input arrays 'a' or 'b' are null. This can lead to a NullPointerException instead of throwing a NullArgumentException.\",\n      \"severity\": \"High\"\n    },\n    {\n      \"lineNumber\": 206,\n      \"description\": \"The 'ebeMultiply' method does not check if the input arrays 'a' or 'b' are null. This can lead to a NullPointerException instead of throwing a NullArgumentException.\",\n      \"severity\": \"High\"\n    }\n  ]\n}\n```"}}