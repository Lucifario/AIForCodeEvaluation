{"sample_id": "Lang_32", "model": "qwen-coder-32b", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.lang3.builder;\n\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\n/**\n * <p>\n * Assists in implementing {@link Object#hashCode()} methods.\n * </p>\n * \n * <p>\n * This class enables a good <code>hashCode</code> method to be built for any class. It follows the rules laid out in\n * the book <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a> by Joshua Bloch. Writing a\n * good <code>hashCode</code> method is actually quite difficult. This class aims to simplify the process.\n * </p>\n * \n * <p>\n * All relevant fields from the object should be included in the <code>hashCode</code> method. Derived fields may be\n * excluded. In general, any field used in the <code>equals</code> method must be used in the <code>hashCode</code>\n * method.\n * </p>\n * \n * <p>\n * To use this class write code as follows:\n * </p>\n * \n * <pre>\n * public class Person {\n *   String name;\n *   int age;\n *   boolean smoker;\n *   ...\n *\n *   public int hashCode() {\n *     // you pick a hard-coded, randomly chosen, non-zero, odd number\n *     // ideally different for each class\n *     return new HashCodeBuilder(17, 37).\n *       append(name).\n *       append(age).\n *       append(smoker).\n *       toHashCode();\n *   }\n * }\n * </pre>\n * \n * <p>\n * If required, the superclass <code>hashCode()</code> can be added using {@link #appendSuper}.\n * </p>\n * \n * <p>\n * Alternatively, there is a method that uses reflection to determine the fields to test. Because these fields are\n * usually private, the method, <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code>\n * to change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions\n * are set up correctly. It is also slower than testing explicitly.\n * </p>\n * \n * <p>\n * A typical invocation for this method would look like:\n * </p>\n * \n * <pre>\n * public int hashCode() {\n *   return HashCodeBuilder.reflectionHashCode(this);\n * }\n * </pre>\n * \n * @author Apache Software Foundation\n * @author Gary Gregory\n * @author Pete Gieser\n * @since 1.0\n * @version $Id$\n */\npublic class HashCodeBuilder {\n    /**\n     * <p>\n     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n     * </p>\n     * \n     * @since 2.3\n     */\n    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {\n        @Override\n        protected Set<IDKey> initialValue() {\n            return new HashSet<IDKey>();\n        }\n    };\n\n    /*\n     * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n     * we are in the process of calculating.\n     * \n     * So we generate a one-to-one mapping from the original object to a new object.\n     * \n     * Now HashSet uses equals() to determine if two elements with the same hashcode really\n     * are equal, so we also need to ensure that the replacement objects are only equal\n     * if the original objects are identical.\n     * \n     * The original implementation (2.4 and before) used the System.indentityHashCode()\n     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\n     *  \n     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\n     * to disambiguate the duplicate ids.\n     */\n    \n    /**\n     * <p>\n     * Returns the registry of objects being traversed by the reflection methods in the current thread.\n     * </p>\n     * \n     * @return Set the registry of objects being traversed\n     * @since 2.3\n     */\n    static Set<IDKey> getRegistry() {\n        return REGISTRY.get();\n    }\n\n    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n     * infinite loops.\n     * </p>\n     * \n     * @param value\n     *            The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given object.\n     * @since 2.3\n     */\n    static boolean isRegistered(Object value) {\n        return getRegistry().contains(new IDKey(value));\n    }\n\n    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given <code>Class</code>.\n     * </p>\n     * \n     * @param object\n     *            the object to append details of\n     * @param clazz\n     *            the class to append details of\n     * @param builder\n     *            the builder to append to\n     * @param useTransients\n     *            whether to use transient fields\n     * @param excludeFields\n     *            Collection of String field names to exclude from use in calculation of hash code\n     */\n    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\n            String[] excludeFields) {\n        if (isRegistered(object)) {\n            return;\n        }\n        try {\n            register(object);\n            Field[] fields = clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (Field field : fields) {\n                if (!ArrayUtils.contains(excludeFields, field.getName())\n                    && (field.getName().indexOf('$') == -1)\n                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\n                    && (!Modifier.isStatic(field.getModifiers()))) {\n                    try {\n                        Object fieldValue = field.get(object);\n                        builder.append(fieldValue);\n                    } catch (IllegalAccessException e) {\n                        // this can't happen. Would get a Security exception instead\n                        // throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(object);\n        }\n    }\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n     * <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * <p>\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n     * </p>\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the number is zero or even\n     */\n    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null, null);\n    }\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * <p>\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n     * </p>\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param testTransients\n     *            whether to include transient fields\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the number is zero or even\n     */\n    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n            boolean testTransients) {\n        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null,\n                null);\n    }\n\n    /**\n     * Calls {@link #reflectionHashCode(int, int, Object, boolean, Class, String[])} with excludeFields set to\n     * <code>null</code>.\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param testTransients\n     *            whether to include transient fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return int hash code\n     */\n    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n            boolean testTransients, Class<? super T> reflectUpToClass) {\n        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients,\n                reflectUpToClass, null);\n    }\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be included. Superclass fields will be included up to and including the specified\n     * superclass. A null superclass is treated as java.lang.Object.\n     * </p>\n     * \n     * <p>\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n     * </p>\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param testTransients\n     *            whether to include transient fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @param excludeFields\n     *            array of field names to exclude from use in calculation of hash code\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the number is zero or even\n     * @since 2.0\n     */\n    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n            boolean testTransients, Class<? super T> reflectUpToClass, String[] excludeFields) {\n\n        if (object == null) {\n            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n        }\n        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n        Class<?> clazz = object.getClass();\n        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n            clazz = clazz.getSuperclass();\n            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        }\n        return builder.toHashCode();\n    }\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n     * <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the object is <code>null</code>\n     */\n    public static int reflectionHashCode(Object object) {\n        return reflectionHashCode(17, 37, object, false, null, null);\n    }\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <P>\n     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param testTransients\n     *            whether to include transient fields\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the object is <code>null</code>\n     */\n    public static int reflectionHashCode(Object object, boolean testTransients) {\n        return reflectionHashCode(17, 37, object, testTransients, null, null);\n    }\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n     * <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param excludeFields\n     *            Collection of String field names to exclude from use in calculation of hash code\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the object is <code>null</code>\n     */\n    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\n        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n    }\n\n    // -------------------------------------------------------------------------\n\n    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n     * <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param excludeFields\n     *            array of field names to exclude from use in calculation of hash code\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the object is <code>null</code>\n     */\n    public static int reflectionHashCode(Object object, String[] excludeFields) {\n        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n    }\n\n    /**\n     * <p>\n     * Registers the given object. Used by the reflection methods to avoid infinite loops.\n     * </p>\n     * \n     * @param value\n     *            The object to register.\n     */\n    static void register(Object value) {\n        getRegistry().add(new IDKey(value));\n    }\n\n    /**\n     * <p>\n     * Unregisters the given object.\n     * </p>\n     * \n     * <p>\n     * Used by the reflection methods to avoid infinite loops.\n     * \n     * @param value\n     *            The object to unregister.\n     * @since 2.3\n     */\n    static void unregister(Object value) {\n        getRegistry().remove(new IDKey(value));\n    }\n\n    /**\n     * Constant to use in building the hashCode.\n     */\n    private final int iConstant;\n\n    /**\n     * Running total of the hashCode.\n     */\n    private int iTotal = 0;\n\n    /**\n     * <p>\n     * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\n     * </p>\n     */\n    public HashCodeBuilder() {\n        iConstant = 37;\n        iTotal = 17;\n    }\n\n    /**\n     * <p>\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n     * however this is not vital.\n     * </p>\n     * \n     * <p>\n     * Prime numbers are preferred, especially for the multiplier.\n     * </p>\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @throws IllegalArgumentException\n     *             if the number is zero or even\n     */\n    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n        if (initialNonZeroOddNumber == 0) {\n            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n        }\n        if (initialNonZeroOddNumber % 2 == 0) {\n            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n        }\n        if (multiplierNonZeroOddNumber == 0) {\n            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n        }\n        if (multiplierNonZeroOddNumber % 2 == 0) {\n            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n        }\n        iConstant = multiplierNonZeroOddNumber;\n        iTotal = initialNonZeroOddNumber;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>boolean</code>.\n     * </p>\n     * <p>\n     * This adds <code>iConstant * 1</code> to the <code>hashCode</code> and not a <code>1231</code> or\n     * <code>1237</code> as done in java.lang.Boolean. This is in accordance with the <quote>Effective Java</quote>\n     * design.\n     * </p>\n     * \n     * @param value\n     *            the boolean to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(boolean value) {\n        iTotal = iTotal * iConstant + (value ? 0 : 1);\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>boolean</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(boolean[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>byte</code>.\n     * </p>\n     * \n     * @param value\n     *            the byte to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(byte value) {\n        iTotal = iTotal * iConstant + value;\n        return this;\n    }\n\n    // -------------------------------------------------------------------------\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>byte</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(byte[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>char</code>.\n     * </p>\n     * \n     * @param value\n     *            the char to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(char value) {\n        iTotal = iTotal * iConstant + value;\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>char</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(char[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>double</code>.\n     * </p>\n     * \n     * @param value\n     *            the double to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(double value) {\n        return append(Double.doubleToLongBits(value));\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>double</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(double[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>float</code>.\n     * </p>\n     * \n     * @param value\n     *            the float to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(float value) {\n        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>float</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(float[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for an <code>int</code>.\n     * </p>\n     * \n     * @param value\n     *            the int to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(int value) {\n        iTotal = iTotal * iConstant + value;\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for an <code>int</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(int[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>long</code>.\n     * </p>\n     * \n     * @param value\n     *            the long to add to the <code>hashCode</code>\n     * @return this\n     */\n    // NOTE: This method uses >> and not >>> as Effective Java and \n    //       Long.hashCode do. Ideally we should switch to >>> at \n    //       some stage. There are backwards compat issues, so \n    //       that will have to wait for the time being. cf LANG-342.\n    public HashCodeBuilder append(long value) {\n        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>long</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(long[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for an <code>Object</code>.\n     * </p>\n     * \n     * @param object\n     *            the Object to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(Object object) {\n        if (object == null) {\n            iTotal = iTotal * iConstant;\n\n        } else {\n            if(object.getClass().isArray()) {\n                // 'Switch' on type of array, to dispatch to the correct handler\n                // This handles multi dimensional arrays\n                if (object instanceof long[]) {\n                    append((long[]) object);\n                } else if (object instanceof int[]) {\n                    append((int[]) object);\n                } else if (object instanceof short[]) {\n                    append((short[]) object);\n                } else if (object instanceof char[]) {\n                    append((char[]) object);\n                } else if (object instanceof byte[]) {\n                    append((byte[]) object);\n                } else if (object instanceof double[]) {\n                    append((double[]) object);\n                } else if (object instanceof float[]) {\n                    append((float[]) object);\n                } else if (object instanceof boolean[]) {\n                    append((boolean[]) object);\n                } else {\n                    // Not an array of primitives\n                    append((Object[]) object);\n                }\n            } else {\n                iTotal = iTotal * iConstant + object.hashCode();\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(Object[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>short</code>.\n     * </p>\n     * \n     * @param value\n     *            the short to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(short value) {\n        iTotal = iTotal * iConstant + value;\n        return this;\n    }\n\n    /**\n     * <p>\n     * Append a <code>hashCode</code> for a <code>short</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>hashCode</code>\n     * @return this\n     */\n    public HashCodeBuilder append(short[] array) {\n        if (array == null) {\n            iTotal = iTotal * iConstant;\n        } else {\n            for (int i = 0; i < array.length; i++) {\n                append(array[i]);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * <p>\n     * Adds the result of super.hashCode() to this builder.\n     * </p>\n     * \n     * @param superHashCode\n     *            the result of calling <code>super.hashCode()</code>\n     * @return this HashCodeBuilder, used to chain calls.\n     * @since 2.0\n     */\n    public HashCodeBuilder appendSuper(int superHashCode) {\n        iTotal = iTotal * iConstant + superHashCode;\n        return this;\n    }\n\n    /**\n     * <p>\n     * Return the computed <code>hashCode</code>.\n     * </p>\n     * \n     * @return <code>hashCode</code> based on the fields appended\n     */\n    public int toHashCode() {\n        return iTotal;\n    }\n\n    /**\n     * <p>\n     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelyhood \n     * of bugs in mis-calling toHashCode() and the unlikelyness of it mattering what the hashCode for \n     * HashCodeBuilder itself is.\n     * \n     * @return <code>hashCode</code> based on the fields appended\n     */\n    @Override\n    public int hashCode() {\n        return toHashCode();\n    }\n\n}\n", "review": {"response": "<think>\nOkay, let's take a look at this Java code. The user wants me to review it for bugs and return a JSON list of bugs. The code provided is for the HashCodeBuilder class from Apache Commons Lang. The code seems to be cut off at the end, specifically in the reflectionAppend method where it says \"clazz.getDecla```\" \u2014 probably a typo or incomplete line.\n\nFirst, I'll start by checking for syntax errors. The incomplete line in reflectionAppend is a problem. The method is supposed to get the declared fields of the class, so it should probably be clazz.getDeclaredFields(). That's a syntax bug.\n\nNext, I'll look for other potential issues. The code uses ThreadLocal for the registry, which is correct for thread safety. The isRegistered method creates a new IDKey each time and checks containment. Since IDKey's equals and hashCode are properly implemented (assuming they are), this should work. But if the registry isn't cleared properly, there could be memory leaks. However, the code doesn't show how the registry is managed during reflection operations, so maybe that's a missing part.\n\nLooking at the reflectionAppend method, when they call register(object), they add the object to the registry. But the register method isn't shown here. I need to check if that method properly adds the object to the registry. If the register method is missing or incorrect, that's a bug.\n\nAnother thing: the code uses ArrayUtils, but I don't see where it's used in the provided snippet. Maybe in the excludeFields handling. If excludeFields is not properly checked for null or empty, that could be an issue. The method parameters include a String[] excludeFields, but if that's null, using it in a loop or check could cause a NullPointerException. However, the code might handle that elsewhere.\n\nIn the reflectionAppend method, the code checks if the object is registered before processing. If it is, it returns early to prevent cycles. That's good for avoiding infinite loops. But if the register call is after that check, there's a possible race condition. Wait, no, the check is before registering. So that's okay.\n\nAnother possible bug: when using reflection to get fields, the code might not process superclass fields. The reflectionHashCode method (not shown here) probably loops through superclasses, but if reflectionAppend is called recursively without handling superclasses, that could miss fields. However, the code's structure might handle that in a loop over superclasses.\n\nLooking at the code's handling of modifiers: the method checks for transient fields based on the useTransients parameter. If useTransients is false, it skips transient fields. That's correct according to the method's parameters.\n\nAnother thing to check: the code uses Field.get() which can throw IllegalAccessException. The code wraps the field with AccessibleObject, so it should setAccessible(true). But if there's a security manager, that might throw a SecurityException. The code might need to handle that, but in the provided snippet, I don't see try-catch blocks for that. However, the code might be handling it elsewhere.\n\nWait, in the reflectionAppend method, there's a try block. Let me check: yes, after the if (isRegistered(object)) check, there's a try block. Inside, they call register(object), then get the fields. Then loop through each field. For each field, they check modifiers, then if it's not excluded, append it. But when they call field.get(object), that could throw exceptions. The current code has a try block, but does it catch those exceptions? The code as shown doesn't have a catch block for the Field.get() call. That's a problem. If an exception is thrown, it would propagate up and possibly crash the method. The code should handle IllegalAccessException, perhaps by logging or ignoring, but the current code doesn't do that. So that's a bug.\n\nAlso, when the code appends the field's value, if the value is an array, it might need to handle it specially. The HashCodeBuilder's append method might have overloads for arrays, but if the code is passing an array without using ArrayUtils or similar, it could lead to incorrect hash codes. However, the code might be using the append method that handles arrays, so that's probably okay.\n\nAnother possible issue: the excludeFields are checked using ArrayUtils.contains, but if excludeFields is null, that would cause a NullPointerException. Wait, in the code, excludeFields is a String[] passed as a parameter. The code uses ArrayUtils to check if the field name is in excludeFields. But if excludeFields is null, ArrayUtils.contains would return false, right? Because ArrayUtils handles null arrays. Wait, no. Let me think: ArrayUtils.contains checks if the array contains the element. If the array is null, it returns false. So if excludeFields is null, then all fields would be included. But maybe the code expects that excludeFields is a non-null array. If the method is called with a null excludeFields, that's a problem. However, the code might be handling that, but in the provided code, it's not clear. So if the excludeFields is null, and the code uses ArrayUtils.contains(excludeFields, fieldName), that would return false, so the field is not excluded. That's probably intended. So maybe that's okay.\n\nAnother thing: the code uses the IDKey class. The isRegistered method creates a new IDKey each time and checks if it's in the registry. The equals method of IDKey must compare the objects' identities, not their equals. If IDKey is implemented correctly, this works. But if there's a bug in IDKey, that could cause issues. However, the code for IDKey isn't provided, so I can't check that.\n\nLooking back at the code, the main bugs I can identify are:\n\n1. The incomplete line in reflectionAppend: \"clazz.getDecla```\" which is missing the rest of the method call. It should be clazz.getDeclaredFields().\n\n2. The code does not handle exceptions thrown by Field.get(), which can cause unchecked exceptions to propagate.\n\n3. If the excludeFields array is null, the code may not handle it correctly. However, ArrayUtils.contains handles null arrays by returning false, so that's probably okay.\n\n4. The register method is called after checking isRegistered, which is correct to prevent missing the current object during the check. But if the register method is not properly adding the object to the registry, that's a problem. However, the code for register is not provided here, so I can't confirm.\n\n5. The code may not handle circular references correctly if the register method is not correctly adding the object. But again, without seeing the register method, it's hard to say.\n\nSo the main bugs are the syntax error in the line and the exception handling in Field.get().\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"line_number\": 163,\n      \"description\": \"Incomplete method call 'clazz.getDecla...' which should be 'clazz.getDeclaredFields()'. This will cause a compilation error.\",\n      \"severity\": \"critical\"\n    },\n    {\n      \"line_number\": 168,\n      \"description\": \"The code does not handle exceptions that may be thrown by Field.get(). This can lead to uncaught exceptions during reflection-based hash code calculation.\",\n      \"severity\": \"major\"\n    },\n    {\n      \"line_number\": 165,\n      \"description\": \"The 'register(object)' call is placed after the 'isRegistered(object)' check. If an exception occurs during registration, the object might not be properly unregistered, leading to potential memory leaks or inconsistent state.\",\n      \"severity\": \"major\"\n    },\n    {\n      \"line_number\": 170,\n      \"description\": \"The code does not handle the case where 'excludeFields' is null. While ArrayUtils.contains handles null arrays by returning false, this behavior may not be explicitly documented or intended.\",\n      \"severity\": \"minor\"\n    }\n  ]\n}\n```"}}