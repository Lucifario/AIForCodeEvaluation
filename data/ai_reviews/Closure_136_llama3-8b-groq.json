{"sample_id": "Closure_136", "model": "llama3-8b-groq", "code_context": "/*\n * Copyright 2007 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Finds all method declarations and pulls them into data structures\n * for use during cleanups such as arity checks or inlining.\n *\n*\n*\n */\nabstract class MethodCompilerPass implements CompilerPass {\n  /** List of methods defined in externs */\n  final Set<String> externMethods = Sets.newHashSet();\n\n  /** List of extern methods without signatures that we can't warn about */\n  final Set<String> externMethodsWithoutSignatures = Sets.newHashSet();\n\n  /** List of property names that may not be methods */\n  final Set<String> nonMethodProperties = Sets.newHashSet();\n\n  final Multimap<String, Node> methodDefinitions =\n      HashMultimap.create();\n\n  final AbstractCompiler compiler;\n\n  /**\n   * The signature storage is provided by the implementing class.\n   */\n  interface SignatureStore {\n    public void reset();\n    public void addSignature(\n        String functionName, Node functionNode, String sourceFile);\n    public void removeSignature(String functionName);\n  }\n\n  MethodCompilerPass(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  public void process(Node externs, Node root) {\n    externMethods.clear();\n    externMethodsWithoutSignatures.clear();\n    getSignatureStore().reset();\n    methodDefinitions.clear();\n\n    if (externs != null) {\n      NodeTraversal.traverse(compiler, externs, new GetExternMethods());\n    }\n\n\n    List<Node> externsAndJs = Lists.newArrayList(externs, root);\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), new GatherSignatures());\n    NodeTraversal.traverseRoots(\n        compiler, externsAndJs, getActingCallback());\n  }\n\n  /**\n   * Subclasses should return a callback that does the actual work they\n   * want to perform given the computed list of method signatures\n   */\n  abstract Callback getActingCallback();\n\n  /**\n   * Subclasses should return a SignatureStore for storing discovered\n   * signatures.\n   */\n  abstract SignatureStore getSignatureStore();\n\n  /**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode()) {\n          return;\n        } else {\n          throw new IllegalStateException(\n              \"VarCheck should have caught this undefined function\");\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n\n  private void addSignature(String name, Node function, String fnSourceName) {\n    if (externMethodsWithoutSignatures.contains(name)) {\n      return;\n    }\n\n    getSignatureStore().addSignature(name, function, fnSourceName);\n    methodDefinitions.put(name, function);\n  }\n\n  /**\n   * Gathers methods from the externs file. Methods that are listed there but\n   * do not have a signature are flagged to be ignored when doing arity checks.\n   * Methods that do include signatures will be checked.\n   */\n  private class GetExternMethods extends AbstractPostOrderCallback {\n\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.GETPROP:\n        case Token.GETELEM: {\n          Node dest = n.getFirstChild().getNext();\n\n          if (dest.getType() != Token.STRING) {\n            return;\n          }\n\n          String name = dest.getString();\n\n          // We have a signature. Parse tree of the form:\n          // assign                       <- parent\n          //      getprop                 <- n\n          //          name methods\n          //          string setTimeout\n          //      function\n          if (parent.getType() == Token.ASSIGN &&\n              parent.getFirstChild() == n &&\n              n.getNext().getType() == Token.FUNCTION) {\n            addSignature(name, n.getNext(), t.getSourceName());\n          } else {\n            getSignatureStore().removeSignature(name);\n            externMethodsWithoutSignatures.add(name);\n          }\n\n          externMethods.add(name);\n        } break;\n\n        case Token.OBJECTLIT: {\n          // assumes the object literal is well formed\n          // (has an even number of children)\n          for (Node key = n.getFirstChild();\n               key != null; key = key.getNext().getNext()) {\n            if (key.getType() == Token.STRING) {\n              Node value = key.getNext();\n              String name = key.getString();\n              if (value.getType() == Token.FUNCTION) {\n                addSignature(name, value, t.getSourceName());\n              } else {\n                getSignatureStore().removeSignature(name);\n                externMethodsWithoutSignatures.add(name);\n              }\n              externMethods.add(name);\n            }\n          }\n        } break;\n      }\n    }\n  }\n\n  /**\n   * Gather signatures from the source to be compiled.\n   */\n  private class GatherSignatures extends AbstractPostOrderCallback {\n\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.GETPROP:\n        case Token.GETELEM:\n          Node dest = n.getFirstChild().getNext();\n\n          if (dest.getType() == Token.STRING) {\n            if (dest.getString().equals(\"prototype\")) {\n              processPrototypeParent(t, parent);\n            } else {\n              // Static methods of the form Foo.bar = function() {} or\n              // Static methods of the form Foo.bar = baz (where baz is a\n              // function name). Parse tree looks like:\n              // assign                 <- parent\n              //      getprop           <- n\n              //          name Foo\n              //          string bar\n              //      function or name  <- n.getNext()\n              if (parent.getType() == Token.ASSIGN &&\n                  parent.getFirstChild() == n) {\n                addPossibleSignature(dest.getString(), n.getNext(), t);\n              }\n            }\n          }\n          break;\n\n        case Token.OBJECTLIT:\n          // assumes the object literal is well formed\n          // (has an even number of children)\n          for (Node key = n.getFirstChild();\n               key != null; key = key.getNext().getNext()) {\n            if (key.getType() == Token.STRING) {\n              Node value = key.getNext();\n              addPossibleSignature(key.getString(), value, t);\n            }\n          }\n          break;\n      }\n    }\n\n    /**\n     * Processes the parent of a GETPROP prototype, which can either be\n     * another GETPROP (in the case of Foo.prototype.bar), or can be\n     * an assignment (in the case of Foo.prototype = ...).\n     */\n    private void processPrototypeParent(NodeTraversal t, Node n) {\n      switch (n.getType()) {\n        // Foo.prototype.getBar = function() { ... } or\n        // Foo.prototype.getBar = getBaz (where getBaz is a function)\n        // parse tree looks like:\n        // assign                          <- parent\n        //     getprop                     <- n\n        //         getprop\n        //             name Foo\n        //             string prototype\n        //         string getBar\n        //     function or name            <- assignee\n        case Token.GETPROP:\n        case Token.GETELEM:\n          Node dest = n.getFirstChild().getNext();\n          Node parent = n.getParent().getParent();\n\n          if (dest.getType() == Token.STRING &&\n              parent.getType() == Token.ASSIGN) {\n            Node assignee = parent.getFirstChild().getNext();\n\n            addPossibleSignature(dest.getString(), assignee, t);\n          }\n          break;\n      }\n    }\n  }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"message\": \"The code does not handle the case where the object literal in Token.OBJECTLIT has an odd number of children.\",\n         \"line\": 276,\n         \"column\": 11\n      },\n      {\n         \"message\": \"The code does not handle the case where the object literal in Token.OBJECTLIT has a key that is not a string.\",\n         \"line\": 279,\n         \"column\": 17\n      },\n      {\n         \"message\": \"The code does not handle the case where the object literal in Token.OBJECTLIT has a key that is null.\",\n         \"line\": 279,\n         \"column\": 17\n      },\n      {\n         \"message\": \"The code does not handle the case where the function in Token.FUNCTION is null.\",\n         \"line\": 123,\n         \"column\": 11\n      },\n      {\n         \"message\": \"The code does not handle the case where the function in Token.FUNCTION is not a function.\",\n         \"line\": 123,\n         \"column\": 11\n      },\n      {\n         \"message\": \"The code does not handle the case where the node in Token.NAME is null.\",\n         \"line\": 135,\n         \"column\": 11\n      },\n      {\n         \"message\": \"The code does not handle the case where the node in Token.NAME is not a name.\",\n         \"line\": 135,\n         \"column\": 11\n      },\n      {\n         \"message\": \"The code does not handle the case where the variable in Scope.Var is null.\",\n         \"line\": 140,\n         \"column\": 13\n      },\n      {\n         \"message\": \"The code does not handle the case where the variable in Scope.Var is not a variable.\",\n         \"line\": 140,\n         \"column\": 13\n      },\n      {\n         \"message\": \"The code does not handle the case where the initial value in Scope.Var is null.\",\n         \"line\": 141,\n         \"column\": 17\n      },\n      {\n         \"message\": \"The code does not handle the case where the initial value in Scope.Var is not a function.\",\n         \"line\": 141,\n         \"column\": 17\n      }\n   ]\n}"}}