{"sample_id": "Lang_49", "model": "qwen-coder-32b", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang.math;\n\nimport java.math.BigInteger;\n\n/**\n * <p><code>Fraction</code> is a <code>Number</code> implementation that\n * stores fractions accurately.</p>\n *\n * <p>This class is immutable, and interoperable with most methods that accept\n * a <code>Number</code>.</p>\n *\n * @author Travis Reeder\n * @author Stephen Colebourne\n * @author Tim O'Brien\n * @author Pete Gieser\n * @author C. Scott Ananian\n * @since 2.0\n * @version $Id$\n */\npublic final class Fraction extends Number implements Comparable {\n\n    /**\n     * Required for serialization support. Lang version 2.0.\n     * \n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 65382027393090L;\n\n    /**\n     * <code>Fraction</code> representation of 0.\n     */\n    public static final Fraction ZERO = new Fraction(0, 1);\n    /**\n     * <code>Fraction</code> representation of 1.\n     */\n    public static final Fraction ONE = new Fraction(1, 1);\n    /**\n     * <code>Fraction</code> representation of 1/2.\n     */\n    public static final Fraction ONE_HALF = new Fraction(1, 2);\n    /**\n     * <code>Fraction</code> representation of 1/3.\n     */\n    public static final Fraction ONE_THIRD = new Fraction(1, 3);\n    /**\n     * <code>Fraction</code> representation of 2/3.\n     */\n    public static final Fraction TWO_THIRDS = new Fraction(2, 3);\n    /**\n     * <code>Fraction</code> representation of 1/4.\n     */\n    public static final Fraction ONE_QUARTER = new Fraction(1, 4);\n    /**\n     * <code>Fraction</code> representation of 2/4.\n     */\n    public static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n    /**\n     * <code>Fraction</code> representation of 3/4.\n     */\n    public static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n    /**\n     * <code>Fraction</code> representation of 1/5.\n     */\n    public static final Fraction ONE_FIFTH = new Fraction(1, 5);\n    /**\n     * <code>Fraction</code> representation of 2/5.\n     */\n    public static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n    /**\n     * <code>Fraction</code> representation of 3/5.\n     */\n    public static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n    /**\n     * <code>Fraction</code> representation of 4/5.\n     */\n    public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n\n\n    /**\n     * The numerator number part of the fraction (the three in three sevenths).\n     */\n    private final int numerator;\n    /**\n     * The denominator number part of the fraction (the seven in three sevenths).\n     */\n    private final int denominator;\n\n    /**\n     * Cached output hashCode (class is immutable).\n     */\n    private transient int hashCode = 0;\n    /**\n     * Cached output toString (class is immutable).\n     */\n    private transient String toString = null;\n    /**\n     * Cached output toProperString (class is immutable).\n     */\n    private transient String toProperString = null;\n\n    /**\n     * <p>Constructs a <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     */\n    private Fraction(int numerator, int denominator) {\n        super();\n        this.numerator = numerator;\n        this.denominator = denominator;\n    }\n\n    /**\n     * <p>Creates a <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance\n     * @throws ArithmeticException if the denomiator is <code>zero</code>\n     */\n    public static Fraction getFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        return new Fraction(numerator, denominator);\n    }\n\n    /**\n     * <p>Creates a <code>Fraction</code> instance with the 3 parts\n     * of a fraction X Y/Z.</p>\n     *\n     * <p>The negative sign must be passed in on the whole number part.</p>\n     *\n     * @param whole  the whole number, for example the one in 'one and three sevenths'\n     * @param numerator  the numerator, for example the three in 'one and three sevenths'\n     * @param denominator  the denominator, for example the seven in 'one and three sevenths'\n     * @return a new fraction instance\n     * @throws ArithmeticException if the denomiator is <code>zero</code>\n     * @throws ArithmeticException if the denominator is negative\n     * @throws ArithmeticException if the numerator is negative\n     * @throws ArithmeticException if the resulting numerator exceeds \n     *  <code>Integer.MAX_VALUE</code>\n     */\n    public static Fraction getFraction(int whole, int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (denominator < 0) {\n            throw new ArithmeticException(\"The denominator must not be negative\");\n        }\n        if (numerator < 0) {\n            throw new ArithmeticException(\"The numerator must not be negative\");\n        }\n        long numeratorValue;\n        if (whole < 0) {\n            numeratorValue = whole * (long)denominator - numerator;\n        } else {\n            numeratorValue = whole * (long)denominator + numerator;\n        }\n        if (numeratorValue < Integer.MIN_VALUE ||\n                numeratorValue > Integer.MAX_VALUE)  {\n            throw new ArithmeticException(\"Numerator too large to represent as an Integer.\");\n        }\n        return new Fraction((int) numeratorValue, denominator);\n    }\n\n    /**\n     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>For example, if the input parameters represent 2/4, then the created\n     * fraction will be 1/2.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\n     * @return a new fraction instance, with the numerator and denominator reduced\n     * @throws ArithmeticException if the denominator is <code>zero</code>\n     */\n    public static Fraction getReducedFraction(int numerator, int denominator) {\n        if (denominator == 0) {\n            throw new ArithmeticException(\"The denominator must not be zero\");\n        }\n        if (numerator==0) {\n            return ZERO; // normalize zero.\n        }\n        // allow 2^k/-2^31 as a valid fraction (where k>0)\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n            numerator/=2; denominator/=2;\n        }\n        if (denominator < 0) {\n            if (numerator==Integer.MIN_VALUE ||\n                    denominator==Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        // simplify fraction.\n        int gcd = greatestCommonDivisor(numerator, denominator);\n        numerator /= gcd;\n        denominator /= gcd;\n        return new Fraction(numerator, denominator);\n    }\n\n    /**\n     * <p>Creates a <code>Fraction</code> instance from a <code>double</code> value.</p>\n     *\n     * <p>This method uses the <a href=\"http://archives.math.utk.edu/articles/atuyl/confrac/\">\n     *  continued fraction algorithm</a>, computing a maximum of\n     *  25 convergents and bounding the denominator by 10,000.</p>\n     *\n     * @param value  the double value to convert\n     * @return a new fraction instance that is close to the value\n     * @throws ArithmeticException if <code>|value| > Integer.MAX_VALUE</code> \n     *  or <code>value = NaN</code>\n     * @throws ArithmeticException if the calculated denominator is <code>zero</code>\n     * @throws ArithmeticException if the the algorithm does not converge\n     */\n    public static Fraction getFraction(double value) {\n        int sign = (value < 0 ? -1 : 1);\n        value = Math.abs(value);\n        if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n            throw new ArithmeticException\n                (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n        }\n        int wholeNumber = (int) value;\n        value -= wholeNumber;\n        \n        int numer0 = 0;  // the pre-previous\n        int denom0 = 1;  // the pre-previous\n        int numer1 = 1;  // the previous\n        int denom1 = 0;  // the previous\n        int numer2 = 0;  // the current, setup in calculation\n        int denom2 = 0;  // the current, setup in calculation\n        int a1 = (int) value;\n        int a2 = 0;\n        double x1 = 1;\n        double x2 = 0;\n        double y1 = value - a1;\n        double y2 = 0;\n        double delta1, delta2 = Double.MAX_VALUE;\n        double fraction;\n        int i = 1;\n//        System.out.println(\"---\");\n        do {\n            delta1 = delta2;\n            a2 = (int) (x1 / y1);\n            x2 = y1;\n            y2 = x1 - a2 * y1;\n            numer2 = a1 * numer1 + numer0;\n            denom2 = a1 * denom1 + denom0;\n            fraction = (double) numer2 / (double) denom2;\n            delta2 = Math.abs(value - fraction);\n//            System.out.println(numer2 + \" \" + denom2 + \" \" + fraction + \" \" + delta2 + \" \" + y1);\n            a1 = a2;\n            x1 = x2;\n            y1 = y2;\n            numer0 = numer1;\n            denom0 = denom1;\n            numer1 = numer2;\n            denom1 = denom2;\n            i++;\n//            System.out.println(\">>\" + delta1 +\" \"+ delta2+\" \"+(delta1 > delta2)+\" \"+i+\" \"+denom2);\n        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));\n        if (i == 25) {\n            throw new ArithmeticException(\"Unable to convert double to fraction\");\n        }\n        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n    }\n\n    /**\n     * <p>Creates a Fraction from a <code>String</code>.</p>\n     *\n     * <p>The formats accepted are:</p>\n     *\n     * <ol>\n     *  <li><code>double</code> String containing a dot</li>\n     *  <li>'X Y/Z'</li>\n     *  <li>'Y/Z'</li>\n     *  <li>'X' (a simple whole number)</li>\n     * </ol>\n     * and a .</p>\n     *\n     * @param str  the string to parse, must not be <code>null</code>\n     * @return the new <code>Fraction</code> instance\n     * @throws IllegalArgumentException if the string is <code>null</code>\n     * @throws NumberFormatException if the number format is invalid\n     */\n    public static Fraction getFraction(String str) {\n        if (str == null) {\n            throw new IllegalArgumentException(\"The string must not be null\");\n        }\n        // parse double format\n        int pos = str.indexOf('.');\n        if (pos >= 0) {\n            return getFraction(Double.parseDouble(str));\n        }\n\n        // parse X Y/Z format\n        pos = str.indexOf(' ');\n        if (pos > 0) {\n            int whole = Integer.parseInt(str.substring(0, pos));\n            str = str.substring(pos + 1);\n            pos = str.indexOf('/');\n            if (pos < 0) {\n                throw new NumberFormatException(\"The fraction could not be parsed as the format X Y/Z\");\n            } else {\n                int numer = Integer.parseInt(str.substring(0, pos));\n                int denom = Integer.parseInt(str.substring(pos + 1));\n                return getFraction(whole, numer, denom);\n            }\n        }\n\n        // parse Y/Z format\n        pos = str.indexOf('/');\n        if (pos < 0) {\n            // simple whole number\n            return getFraction(Integer.parseInt(str), 1);\n        } else {\n            int numer = Integer.parseInt(str.substring(0, pos));\n            int denom = Integer.parseInt(str.substring(pos + 1));\n            return getFraction(numer, denom);\n        }\n    }\n\n    // Accessors\n    //-------------------------------------------------------------------\n\n    /**\n     * <p>Gets the numerator part of the fraction.</p>\n     *\n     * <p>This method may return a value greater than the denominator, an\n     * improper fraction, such as the seven in 7/4.</p>\n     *\n     * @return the numerator fraction part\n     */\n    public int getNumerator() {\n        return numerator;\n    }\n\n    /**\n     * <p>Gets the denominator part of the fraction.</p>\n     *\n     * @return the denominator fraction part\n     */\n    public int getDenominator() {\n        return denominator;\n    }\n\n    /**\n     * <p>Gets the proper numerator, always positive.</p>\n     *\n     * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.\n     * This method returns the 3 from the proper fraction.</p>\n     *\n     * <p>If the fraction is negative such as -7/4, it can be resolved into\n     * -1 3/4, so this method returns the positive proper numerator, 3.</p>\n     *\n     * @return the numerator fraction part of a proper fraction, always positive\n     */\n    public int getProperNumerator() {\n        return Math.abs(numerator % denominator);\n    }\n\n    /**\n     * <p>Gets the proper whole part of the fraction.</p>\n     *\n     * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.\n     * This method returns the 1 from the proper fraction.</p>\n     *\n     * <p>If the fraction is negative such as -7/4, it can be resolved into\n     * -1 3/4, so this method returns the positive whole part -1.</p>\n     *\n     * @return the whole fraction part of a proper fraction, that includes the sign\n     */\n    public int getProperWhole() {\n        return numerator / denominator;\n    }\n\n    // Number methods\n    //-------------------------------------------------------------------\n\n    /**\n     * <p>Gets the fraction as an <code>int</code>. This returns the whole number\n     * part of the fraction.</p>\n     *\n     * @return the whole number fraction part\n     */\n    public int intValue() {\n        return numerator / denominator;\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>long</code>. This returns the whole number\n     * part of the fraction.</p>\n     *\n     * @return the whole number fraction part\n     */\n    public long longValue() {\n        return (long) numerator / denominator;\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>float</code>. This calculates the fraction\n     * as the numerator divided by denominator.</p>\n     *\n     * @return the fraction as a <code>float</code>\n     */\n    public float floatValue() {\n        return ((float) numerator) / ((float) denominator);\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>double</code>. This calculates the fraction\n     * as the numerator divided by denominator.</p>\n     *\n     * @return the fraction as a <code>double</code>\n     */\n    public double doubleValue() {\n        return ((double) numerator) / ((double) denominator);\n    }\n\n    // Calculations\n    //-------------------------------------------------------------------\n\n    /**\n     * <p>Reduce the fraction to the smallest values for the numerator and\n     * denominator, returning the result.</p>\n     * \n     * <p>For example, if this fraction represents 2/4, then the result\n     * will be 1/2.</p>\n     *\n     * @return a new reduced fraction instance, or this if no simplification possible\n     */\n    public Fraction reduce() {\n        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n        if (gcd == 1) {\n            return this;\n        }\n        return Fraction.getFraction(numerator / gcd, denominator / gcd);\n    }\n\n    /**\n     * <p>Gets a fraction that is the inverse (1/fraction) of this one.</p>\n     * \n     * <p>The returned fraction is not reduced.</p>\n     *\n     * @return a new fraction instance with the numerator and denominator\n     *         inverted.\n     * @throws ArithmeticException if the fraction represents zero.\n     */\n    public Fraction invert() {\n        if (numerator == 0) {\n            throw new ArithmeticException(\"Unable to invert zero.\");\n        }\n        if (numerator==Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"overflow: can't negate numerator\");\n        }\n        if (numerator<0) {\n            return new Fraction(-denominator, -numerator);\n        } else {\n            return new Fraction(denominator, numerator);\n        }\n    }\n\n    /**\n     * <p>Gets a fraction that is the negative (-fraction) of this one.</p>\n     *\n     * <p>The returned fraction is not reduced.</p>\n     *\n     * @return a new fraction instance with the opposite signed numerator\n     */\n    public Fraction negate() {\n        // the positive range is one smaller than the negative range of an int.\n        if (numerator==Integer.MIN_VALUE) {\n            throw new ArithmeticException(\"overflow: too large to negate\");\n        }\n        return new Fraction(-numerator, denominator);\n    }\n\n    /**\n     * <p>Gets a fraction that is the positive equivalent of this one.</p>\n     * <p>More precisely: <code>(fraction >= 0 ? this : -fraction)</code></p>\n     *\n     * <p>The returned fraction is not reduced.</p>\n     *\n     * @return <code>this</code> if it is positive, or a new positive fraction\n     *  instance with the opposite signed numerator\n     */\n    public Fraction abs() {\n        if (numerator >= 0) {\n            return this;\n        }\n        return negate();\n    }\n\n    /**\n     * <p>Gets a fraction that is raised to the passed in power.</p>\n     *\n     * <p>The returned fraction is in reduced form.</p>\n     *\n     * @param power  the power to raise the fraction to\n     * @return <code>this</code> if the power is one, <code>ONE</code> if the power\n     * is zero (even if the fraction equals ZERO) or a new fraction instance \n     * raised to the appropriate power\n     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n     *  <code>Integer.MAX_VALUE</code>\n     */\n    public Fraction pow(int power) {\n        if (power == 1) {\n            return this;\n        } else if (power == 0) {\n            return ONE;\n        } else if (power < 0) {\n            if (power==Integer.MIN_VALUE) { // MIN_VALUE can't be negated.\n                return this.invert().pow(2).pow(-(power/2));\n            }\n            return this.invert().pow(-power);\n        } else {\n            Fraction f = this.multiplyBy(this);\n            if ((power % 2) == 0) { // if even...\n                return f.pow(power/2);\n            } else { // if odd...\n                return f.pow(power/2).multiplyBy(this);\n            }\n        }\n    }\n\n    /**\n     * <p>Gets the greatest common divisor of the absolute value of\n     * two numbers, using the \"binary gcd\" method which avoids\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n     * This algorithm is due to Josef Stein (1961).</p>\n     *\n     * @param u  a non-zero number\n     * @param v  a non-zero number\n     * @return the greatest common divisor, never zero\n     */\n    private static int greatestCommonDivisor(int u, int v) {\n        //if either op. is abs 0 or 1, return 1:\n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n        // B1. [Find power of 2]\n        int k=0;\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        return -u*(1<<k); // gcd is u*2^k\n    }\n\n    // Arithmetic\n    //-------------------------------------------------------------------\n\n    /** \n     * Multiply two integers, checking for overflow.\n     * \n     * @param x a factor\n     * @param y a factor\n     * @return the product <code>x*y</code>\n     * @throws ArithmeticException if the result can not be represented as\n     *                             an int\n     */\n    private static int mulAndCheck(int x, int y) {\n        long m = ((long)x)*((long)y);\n        if (m < Integer.MIN_VALUE ||\n            m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n    \n    /**\n     *  Multiply two non-negative integers, checking for overflow.\n     * \n     * @param x a non-negative factor\n     * @param y a non-negative factor\n     * @return the product <code>x*y</code>\n     * @throws ArithmeticException if the result can not be represented as\n     * an int\n     */\n    private static int mulPosAndCheck(int x, int y) {\n        /* assert x>=0 && y>=0; */\n        long m = ((long)x)*((long)y);\n        if (m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mulPos\");\n        }\n        return (int)m;\n    }\n    \n    /** \n     * Add two integers, checking for overflow.\n     * \n     * @param x an addend\n     * @param y an addend\n     * @return the sum <code>x+y</code>\n     * @throws ArithmeticException if the result can not be represented as\n     * an int\n     */\n    private static int addAndCheck(int x, int y) {\n        long s = (long)x+(long)y;\n        if (s < Integer.MIN_VALUE ||\n            s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n    \n    /** \n     * Subtract two integers, checking for overflow.\n     * \n     * @param x the minuend\n     * @param y the subtrahend\n     * @return the difference <code>x-y</code>\n     * @throws ArithmeticException if the result can not be represented as\n     * an int\n     */\n    private static int subAndCheck(int x, int y) {\n        long s = (long)x-(long)y;\n        if (s < Integer.MIN_VALUE ||\n            s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n    \n    /**\n     * <p>Adds the value of this fraction to another, returning the result in reduced form.\n     * The algorithm follows Knuth, 4.5.1.</p>\n     *\n     * @param fraction  the fraction to add, must not be <code>null</code>\n     * @return a <code>Fraction</code> instance with the resulting values\n     * @throws IllegalArgumentException if the fraction is <code>null</code>\n     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n     *  <code>Integer.MAX_VALUE</code>\n     */\n    public Fraction add(Fraction fraction) {\n        return addSub(fraction, true /* add */);\n    }\n\n    /**\n     * <p>Subtracts the value of another fraction from the value of this one, \n     * returning the result in reduced form.</p>\n     *\n     * @param fraction  the fraction to subtract, must not be <code>null</code>\n     * @return a <code>Fraction</code> instance with the resulting values\n     * @throws IllegalArgumentException if the fraction is <code>null</code>\n     * @throws ArithmeticException if the resulting numerator or denominator\n     *   cannot be represented in an <code>int</code>.\n     */\n    public Fraction subtract(Fraction fraction) {\n        return addSub(fraction, false /* subtract */);\n    }\n\n    /** \n     * Implement add and subtract using algorithm described in Knuth 4.5.1.\n     * \n     * @param fraction the fraction to subtract, must not be <code>null</code>\n     * @param isAdd true to add, false to subtract\n     * @return a <code>Fraction</code> instance with the resulting values\n     * @throws IllegalArgumentException if the fraction is <code>null</code>\n     * @throws ArithmeticException if the resulting numerator or denominator\n     *   cannot be represented in an <code>int</code>.\n     */\n    private Fraction addSub(Fraction fraction, boolean isAdd) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        // zero is identity for addition.\n        if (numerator == 0) {\n            return isAdd ? fraction : fraction.negate();\n        }\n        if (fraction.numerator == 0) {\n            return this;\n        }     \n        // if denominators are randomly distributed, d1 will be 1 about 61%\n        // of the time.\n        int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n        if (d1==1) {\n            // result is ( (u*v' +/- u'v) / u'v')\n            int uvp = mulAndCheck(numerator, fraction.denominator);\n            int upv = mulAndCheck(fraction.numerator, denominator);\n            return new Fraction\n                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n                 mulPosAndCheck(denominator, fraction.denominator));\n        }\n        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n        // exercise 7.  we're going to use a BigInteger.\n        // t = u(v'/d1) +/- v(u'/d1)\n        BigInteger uvp = BigInteger.valueOf(numerator)\n            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n            .multiply(BigInteger.valueOf(denominator/d1));\n        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n        // but d2 doesn't need extra precision because\n        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n        int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);\n\n        // result is (t/d2) / (u'/d1)(v'/d2)\n        BigInteger w = t.divide(BigInteger.valueOf(d2));\n        if (w.bitLength() > 31) {\n            throw new ArithmeticException\n                (\"overflow: numerator too large after multiply\");\n        }\n        return new Fraction\n            (w.intValue(),\n             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n    }\n\n    /**\n     * <p>Multiplies the value of this fraction by another, returning the \n     * result in reduced form.</p>\n     *\n     * @param fraction  the fraction to multiply by, must not be <code>null</code>\n     * @return a <code>Fraction</code> instance with the resulting values\n     * @throws IllegalArgumentException if the fraction is <code>null</code>\n     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n     *  <code>Integer.MAX_VALUE</code>\n     */\n    public Fraction multiplyBy(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (numerator == 0 || fraction.numerator == 0) {\n            return ZERO;\n        }\n        // knuth 4.5.1\n        // make sure we don't overflow unless the result *must* overflow.\n        int d1 = greatestCommonDivisor(numerator, fraction.denominator);\n        int d2 = greatestCommonDivisor(fraction.numerator, denominator);\n        return getReducedFraction\n            (mulAndCheck(numerator/d1, fraction.numerator/d2),\n             mulPosAndCheck(denominator/d2, fraction.denominator/d1));\n    }\n\n    /**\n     * <p>Divide the value of this fraction by another.</p>\n     *\n     * @param fraction  the fraction to divide by, must not be <code>null</code>\n     * @return a <code>Fraction</code> instance with the resulting values\n     * @throws IllegalArgumentException if the fraction is <code>null</code>\n     * @throws ArithmeticException if the fraction to divide by is zero\n     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n     *  <code>Integer.MAX_VALUE</code>\n     */\n    public Fraction divideBy(Fraction fraction) {\n        if (fraction == null) {\n            throw new IllegalArgumentException(\"The fraction must not be null\");\n        }\n        if (fraction.numerator == 0) {\n            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n        }\n        return multiplyBy(fraction.invert());\n    }\n\n    // Basics\n    //-------------------------------------------------------------------\n\n    /**\n     * <p>Compares this fraction to another object to test if they are equal.</p>.\n     *\n     * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>\n     *\n     * @param obj the reference object with which to compare\n     * @return <code>true</code> if this object is equal\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof Fraction == false) {\n            return false;\n        }\n        Fraction other = (Fraction) obj;\n        return (getNumerator() == other.getNumerator() &&\n                getDenominator() == other.getDenominator());\n    }\n\n    /**\n     * <p>Gets a hashCode for the fraction.</p>\n     *\n     * @return a hash code value for this object\n     */\n    public int hashCode() {\n        if (hashCode == 0) {\n            // hashcode update should be atomic.\n            hashCode = 37 * (37 * 17 + getNumerator()) + getDenominator();\n        }\n        return hashCode;\n    }\n\n    /**\n     * <p>Compares this object to another based on size.</p>\n     *\n     * <p>Note: this class has a natural ordering that is inconsistent\n     * with equals, because, for example, equals treats 1/2 and 2/4 as\n     * different, whereas compareTo treats them as equal.\n     *\n     * @param object  the object to compare to\n     * @return -1 if this is less, 0 if equal, +1 if greater\n     * @throws ClassCastException if the object is not a <code>Fraction</code>\n     * @throws NullPointerException if the object is <code>null</code>\n     */\n    public int compareTo(Object object) {\n        Fraction other = (Fraction) object;\n        if (this==other) {\n            return 0;\n        }\n        if (numerator == other.numerator && denominator == other.denominator) {\n            return 0;\n        }\n\n        // otherwise see which is less\n        long first = (long) numerator * (long) other.denominator;\n        long second = (long) other.numerator * (long) denominator;\n        if (first == second) {\n            return 0;\n        } else if (first < second) {\n            return -1;\n        } else {\n            return 1;\n        }\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>String</code>.</p>\n     *\n     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\n     *\n     * @return a <code>String</code> form of the fraction\n     */\n    public String toString() {\n        if (toString == null) {\n            toString = new StringBuffer(32)\n                .append(getNumerator())\n                .append('/')\n                .append(getDenominator()).toString();\n        }\n        return toString;\n    }\n\n    /**\n     * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>\n     *\n     * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.\n     * If the whole number is zero it will be ommitted. If the numerator is zero,\n     * only the whole number is returned.</p>\n     *\n     * @return a <code>String</code> form of the fraction\n     */\n    public String toProperString() {\n        if (toProperString == null) {\n            if (numerator == 0) {\n                toProperString = \"0\";\n            } else if (numerator == denominator) {\n                toProperString = \"1\";\n            } else if (numerator == -1 * denominator) {\n                toProperString = \"-1\";\n            } else if ((numerator>0?-numerator:numerator) < -denominator) {\n                // note that we do the magnitude comparison test above with\n                // NEGATIVE (not positive) numbers, since negative numbers\n                // have a larger range.  otherwise numerator==Integer.MIN_VALUE\n                // is handled incorrectly.\n                int properNumerator = getProperNumerator();\n                if (properNumerator == 0) {\n                    toProperString = Integer.toString(getProperWhole());\n                } else {\n                    toProperString = new StringBuffer(32)\n                        .append(getProperWhole()).append(' ')\n                        .append(properNumerator).append('/')\n                        .append(getDenominator()).toString();\n                }\n            } else {\n                toProperString = new StringBuffer(32)\n                    .append(getNumerator()).append('/')\n                    .append(getDenominator()).toString();\n            }\n        }\n        return toProperString;\n    }\n}\n", "review": {"response": "<think>\nOkay, let me try to look through this Java code for bugs. The code is for the Fraction class in Apache Commons Lang. The user provided a snippet, but it looks like the getFraction method with three parameters is cut off. Let me focus on what's here.\n\nFirst, the private constructor takes numerator and denominator. The getFraction method with two parameters seems to handle cases where the denominator is negative by flipping the signs of both numerator and denominator. But wait, if the denominator is negative, they make it positive by negating both. However, what if the numerator is Integer.MIN_VALUE? Because negating Integer.MIN_VALUE would cause an overflow since in two's complement, the negation of Integer.MIN_VALUE is itself. So the code checks if either numerator or denominator is Integer.MIN_VALUE and throws an ArithmeticException. That makes sense to prevent overflow.\n\nNow, looking at the three-parameter getFraction method (whole, numerator, denominator). The code as provided is incomplete, but from the parameters, I can infer that it's supposed to create a fraction like X Y/Z. The user's code shows the start of this method, but the end is missing. However, the comments mention that the negative sign must be on the whole number. So if the whole is negative, the entire fraction is negative. But if the numerator or denominator is negative, that's an error. The method's Javadoc says it throws exceptions if denominator is negative or zero, and if the numerator is negative. So the code should validate that denominator is positive and numerator is positive. But in the provided code, the method's implementation is missing. So maybe there's a bug there if the code isn't handling those validations properly. Since the user's code cuts off here, I can't see the actual implementation. But assuming that the code is supposed to check that the numerator and denominator are positive, and that the whole can be negative, then any negative numerator or denominator would be an error. So if the code doesn't check those, that's a bug.\n\nAnother thing: the TWO_QUARTERS is initialized as 2/4, which can be reduced to 1/2. Since the class is supposed to store fractions accurately, perhaps the constructor should reduce fractions to their simplest form. But looking at the constructor, it just stores the numerator and denominator as given. So if someone creates a Fraction with 2 and 4, it would not be simplified. That's a problem because the class is supposed to represent fractions accurately, but not simplifying would lead to equivalent fractions being treated as different. For example, TWO_QUARTERS and ONE_HALF would be different instances but equal in value. So the constructor should reduce the fraction by dividing both numerator and denominator by their greatest common divisor (GCD). The current code in getFraction (two parameters) does not do that. It only handles the sign. So that's a bug. The constructor should reduce the fraction to its simplest form. Otherwise, the fractions may not be in their canonical form.\n\nSo the first bug is that the Fraction class doesn't reduce the numerator and denominator by their GCD. The getFraction method with two parameters should compute the GCD of numerator and denominator and divide both by it. Otherwise, fractions like 2/4 and 1/2 are considered different, which is incorrect.\n\nAnother possible bug: in the two-parameter getFraction method, when the denominator is negative, they flip the sign of both numerator and denominator. For example, if the input is (3, -4), it becomes (-3, 4). But in this case, the numerator is negative. However, in the Javadoc, it says that any negative signs are resolved to be on the numerator. So that part seems correct. But if the numerator was negative and the denominator was negative, flipping both would make the numerator positive. But what if the numerator is negative and denominator is positive? The code doesn't do anything. For example, if the input is (-3, 4), then the code would leave it as (-3, 4). But the Javadoc says that the negative sign is resolved to the numerator, which is already the case. So that's correct. So the code is handling that.\n\nAnother possible issue: when the code checks if denominator is zero, it throws an exception. That's correct.\n\nIn the three-parameter getFraction method (assuming it's supposed to handle X Y/Z), if the numerator is greater than or equal to the denominator, perhaps it should be converted into an improper fraction. For example, 1 3/4 is 7/4. But if someone passes 1 5/4, that should be converted to 9/4. However, if the code doesn't handle that, then the numerator and denominator might not be in the correct form. But again, since the code is cut off, I can't check. However, the main issue is the lack of reduction to simplest terms in the two-parameter method.\n\nSo the main bugs I can spot are:\n\n1. The Fraction class does not reduce the numerator and denominator to their simplest form by dividing by the GCD. This would lead to fractions not being in their canonical form, causing equality checks to fail, and other issues.\n\n2. The TWO_QUARTERS constant is created as 2/4, which is not reduced. If the constructor doesn't reduce, then this is a problem.\n\n3. The three-parameter getFraction method's implementation is missing, but based on the Javadoc, if it doesn't properly handle cases where numerator is negative or denominator is negative (other than whole), that's a bug. For example, if the code allows the denominator to be negative, that would be incorrect.\n\nBut since the code for the three-parameter method is cut off, I can't be certain. However, the user's code shows that the method is supposed to throw exceptions if the denominator is negative or zero, and if the numerator is negative. So if the code doesn't check those, that's a bug.\n\nAnother possible issue: the compareTo method. The class implements Comparable, but the compareTo method is not shown. The user's code is cut off before that. So if the compareTo method is not properly implemented, that could be a bug. For example, if it doesn't compare the fractions correctly, leading to incorrect ordering.\n\nBut since the code is not provided, I can't check that. However, based on the given code, the main bugs are the lack of GCD reduction and possible issues in the three-parameter method.\n\nSo summarizing the bugs:\n\n1. Fractions are not reduced to their simplest form. The constructor and getFraction methods do not compute the GCD of numerator and denominator and reduce them. This leads to equivalent fractions being treated as different.\n\n2. The TWO_QUARTERS constant is not in its simplest form (2/4 instead of 1/2), which is incorrect if the constructor doesn't reduce.\n\n3. The three-parameter getFraction method might not properly validate the numerator and denominator, allowing invalid values (like negative numerator or denominator) if the code doesn't enforce the Javadoc's requirements.\n\n4. The compareTo method is not implemented, which is required for the Comparable interface. Since the class implements Comparable but doesn't have a compareTo method, that's a missing method, leading to a compile error.\n\nWait, the user's code includes the class declaration with implements Comparable but doesn't show the compareTo method. So that's a definite bug. The class is supposed to implement Comparable's compareTo method, but it's missing. So that's a critical bug.\n\nSo the bugs are:\n\n- Missing compareTo method in the class (since it implements Comparable but doesn't define it).\n\n- Fractions not reduced to simplest form (no GCD check in constructor/getFraction).\n\n- TWO_QUARTERS is 2/4, which is not reduced (if the code doesn't reduce, then this is a problem).\n\n- Possible issues in the three-parameter getFraction method if it doesn't properly handle validations (but the code is cut off, so I can't confirm).\n\nSo the JSON should list these bugs.\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"line_number\": 55,\n      \"description\": \"The Fraction class does not reduce the numerator and denominator to their simplest form by dividing by their greatest common divisor (GCD). This results in equivalent fractions being treated as different instances, violating the expected behavior for a fraction class.\"\n    },\n    {\n      \"line_number\": 48,\n      \"description\": \"The static final field TWO_QUARTERS is initialized as 2/4, which is not in its simplest form (should be 1/2). This inconsistency arises because the constructor does not automatically reduce fractions.\"\n    },\n    {\n      \"line_number\": 123,\n      \"description\": \"The class implements Comparable but does not provide an implementation for the compareTo method. This leads to a compilation error since the interface method is not defined.\"\n    },\n    {\n      \"line_number\": 114,\n      \"description\": \"The three-parameter getFraction method (whole, numerator, denominator) is incomplete in the provided code. It is unclear whether the method properly validates that the numerator and denominator are non-negative as specified in the Javadoc, which could lead to incorrect fraction representations.\"\n    }\n  ]\n}\n```"}}