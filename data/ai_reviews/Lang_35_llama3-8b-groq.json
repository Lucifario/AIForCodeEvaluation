{"sample_id": "Lang_35", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3;\n\nimport java.lang.reflect.Array;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.builder.EqualsBuilder;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\n/**\n * <p>Operations on arrays, primitive arrays (like <code>int[]</code>) and\n * primitive wrapper arrays (like <code>Integer[]</code>).</p>\n *\n * <p>This class tries to handle <code>null</code> input gracefully.\n * An exception will not be thrown for a <code>null</code>\n * array input. However, an Object array that contains a <code>null</code>\n * element may throw an exception. Each method documents its behaviour.</p>\n *\n * @author Apache Software Foundation\n * @author Moritz Petersen\n * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n * @author Nikolay Metchev\n * @author Matthew Hawthorne\n * @author Tim O'Brien\n * @author Pete Gieser\n * @author Gary Gregory\n * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n * @author Maarten Coene\n * @since 2.0\n * @version $Id$\n */\npublic class ArrayUtils {\n\n    /**\n     * An empty immutable <code>Object</code> array.\n     */\n    public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n    /**\n     * An empty immutable <code>Class</code> array.\n     */\n    public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n    /**\n     * An empty immutable <code>String</code> array.\n     */\n    public static final String[] EMPTY_STRING_ARRAY = new String[0];\n    /**\n     * An empty immutable <code>long</code> array.\n     */\n    public static final long[] EMPTY_LONG_ARRAY = new long[0];\n    /**\n     * An empty immutable <code>Long</code> array.\n     */\n    public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n    /**\n     * An empty immutable <code>int</code> array.\n     */\n    public static final int[] EMPTY_INT_ARRAY = new int[0];\n    /**\n     * An empty immutable <code>Integer</code> array.\n     */\n    public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n    /**\n     * An empty immutable <code>short</code> array.\n     */\n    public static final short[] EMPTY_SHORT_ARRAY = new short[0];\n    /**\n     * An empty immutable <code>Short</code> array.\n     */\n    public static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n    /**\n     * An empty immutable <code>byte</code> array.\n     */\n    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n    /**\n     * An empty immutable <code>Byte</code> array.\n     */\n    public static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n    /**\n     * An empty immutable <code>double</code> array.\n     */\n    public static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n    /**\n     * An empty immutable <code>Double</code> array.\n     */\n    public static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n    /**\n     * An empty immutable <code>float</code> array.\n     */\n    public static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n    /**\n     * An empty immutable <code>Float</code> array.\n     */\n    public static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n    /**\n     * An empty immutable <code>boolean</code> array.\n     */\n    public static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n    /**\n     * An empty immutable <code>Boolean</code> array.\n     */\n    public static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n    /**\n     * An empty immutable <code>char</code> array.\n     */\n    public static final char[] EMPTY_CHAR_ARRAY = new char[0];\n    /**\n     * An empty immutable <code>Character</code> array.\n     */\n    public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n\n    /**\n     * The index value when an element is not found in a list or array: <code>-1</code>.\n     * This value is returned by methods in this class and can also be used in comparisons with values returned by\n     * various method from {@link java.util.List}.\n     */\n    public static final int INDEX_NOT_FOUND = -1;\n\n    /**\n     * <p>ArrayUtils instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as <code>ArrayUtils.clone(new int[] {2})</code>.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public ArrayUtils() {\n      super();\n    }\n\n    // Basic methods handling multi-dimensional arrays\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Outputs an array as a String, treating <code>null</code> as an empty array.</p>\n     *\n     * <p>Multi-dimensional arrays are handled correctly, including\n     * multi-dimensional primitive arrays.</p>\n     *\n     * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>\n     *\n     * @param array  the array to get a toString for, may be <code>null</code>\n     * @return a String representation of the array, '{}' if null array input\n     */\n    public static String toString(Object array) {\n        return toString(array, \"{}\");\n    }\n\n    /**\n     * <p>Outputs an array as a String handling <code>null</code>s.</p>\n     *\n     * <p>Multi-dimensional arrays are handled correctly, including\n     * multi-dimensional primitive arrays.</p>\n     *\n     * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>\n     *\n     * @param array  the array to get a toString for, may be <code>null</code>\n     * @param stringIfNull  the String to return if the array is <code>null</code>\n     * @return a String representation of the array\n     */\n    public static String toString(Object array, String stringIfNull) {\n        if (array == null) {\n            return stringIfNull;\n        }\n        return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();\n    }\n\n    /**\n     * <p>Compares two arrays, using equals(), handling multi-dimensional arrays\n     * correctly.</p>\n     *\n     * <p>Multi-dimensional primitive arrays are also handled correctly by this method.</p>\n     *\n     * @param array1  the left hand array to compare, may be <code>null</code>\n     * @param array2  the right hand array to compare, may be <code>null</code>\n     * @return <code>true</code> if the arrays are equal\n     */\n    public static boolean isEquals(Object array1, Object array2) {\n        return new EqualsBuilder().append(array1, array2).isEquals();\n    }\n\n    // To map\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Converts the given array into a {@link java.util.Map}. Each element of the array\n     * must be either a {@link java.util.Map.Entry} or an Array, containing at least two\n     * elements, where the first element is used as key and the second as\n     * value.</p>\n     *\n     * <p>This method can be used to initialize:</p>\n     * <pre>\n     * // Create a Map mapping colors.\n     * Map colorMap = MapUtils.toMap(new String[][] {{\n     *     {\"RED\", \"#FF0000\"},\n     *     {\"GREEN\", \"#00FF00\"},\n     *     {\"BLUE\", \"#0000FF\"}});\n     * </pre>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  an array whose elements are either a {@link java.util.Map.Entry} or\n     *  an Array containing at least two elements, may be <code>null</code>\n     * @return a <code>Map</code> that was created from the array\n     * @throws IllegalArgumentException  if one element of this Array is\n     *  itself an Array containing less then two elements\n     * @throws IllegalArgumentException  if the array contains elements other\n     *  than {@link java.util.Map.Entry} and an Array\n     */\n    public static Map<Object, Object> toMap(Object[] array) {\n        if (array == null) {\n            return null;\n        }\n        final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5));\n        for (int i = 0; i < array.length; i++) {\n            Object object = array[i];\n            if (object instanceof Map.Entry<?, ?>) {\n                Map.Entry<?,?> entry = (Map.Entry<?,?>) object;\n                map.put(entry.getKey(), entry.getValue());\n            } else if (object instanceof Object[]) {\n                Object[] entry = (Object[]) object;\n                if (entry.length < 2) {\n                    throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n                        + object\n                        + \"', has a length less than 2\");\n                }\n                map.put(entry[0], entry[1]);\n            } else {\n                throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n                        + object\n                        + \"', is neither of type Map.Entry nor an Array\");\n            }\n        }\n        return map;\n    }\n\n    // Generic array\n    //-----------------------------------------------------------------------\n    /**\n     * Create a type-safe generic array.\n     *\n     * <p>Arrays are covariant i.e. they cannot be created from a generic type:</p>\n     *\n     * <pre>\n    public static &lt;T&gt; T[] createAnArray(int size)\n    {\n        return T[size]; // compiler error here\n    }\n    public static &lt;T&gt; T[] createAnArray(int size)\n    {\n        return (T[])Object[size]; // ClassCastException at runtime\n    }\n     * </pre>\n     *\n     * <p>Therefore new arrays of generic types can be created with this method, e.g. an arrays\n     * of Strings:</p>\n     *\n     * <pre>\n    String[] array = ArrayUtils.toArray(\"1\", \"2\");\n    String[] emptyArray = ArrayUtils.&lt;String&gt;toArray();\n     * </pre>\n     * \n     * The method is typically used in scenarios, where the caller itself uses generic types\n     * that have to be combined into an array.\n     * \n     * Note, this method makes only sense to provide arguments of the same type so that the\n     * compiler can deduce the type of the array itself. While it is possible to select the\n     * type explicitly like in <code>Number[] array = ArrayUtils.<Number>toArray(new\n     * Integer(42), new Double(Math.PI))</code>, there is no real advantage to <code>new\n     * Number[] {new Integer(42), new Double(Math.PI)}</code> anymore.\n     *\n     * @param  <T>   the array's element type\n     * @param  items the items of the array\n     * @return the array\n     * @since  3.0\n     */\n    public static <T> T[] toArray(final T... items)\n    {\n        return items;\n    }\n    \n    // Clone\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Shallow clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>The objects in the array are not cloned, thus there is no special\n     * handling for multi-dimensional arrays.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to shallow clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static <T> T[] clone(T[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static long[] clone(long[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static int[] clone(int[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static short[] clone(short[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static char[] clone(char[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static byte[] clone(byte[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static double[] clone(double[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static float[] clone(float[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    /**\n     * <p>Clones an array returning a typecast result and handling\n     * <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to clone, may be <code>null</code>\n     * @return the cloned array, <code>null</code> if <code>null</code> input\n     */\n    public static boolean[] clone(boolean[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }\n\n    // Subarrays\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Produces a new array containing the elements between\n     * the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * <p>The component type of the subarray is always the same as\n     * that of the input array. Thus, if the input is an array of type\n     * <code>Date</code>, the following usage is envisaged:</p>\n     *\n     * <pre>\n     * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);\n     * </pre>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static <T> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        Class<?> type = array.getClass().getComponentType();\n        if (newSize <= 0) {\n            @SuppressWarnings(\"unchecked\") // OK, because array is of type T\n            final T[] emptyArray = (T[]) Array.newInstance(type, 0);\n            return emptyArray;\n        }\n        @SuppressWarnings(\"unchecked\") // OK, because array is of type T\n        T[] subarray = (T[]) Array.newInstance(type, newSize);\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>long</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n\n        long[] subarray = new long[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>int</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_INT_ARRAY;\n        }\n\n        int[] subarray = new int[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>short</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_SHORT_ARRAY;\n        }\n\n        short[] subarray = new short[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>char</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n\n        char[] subarray = new char[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>byte</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n\n        byte[] subarray = new byte[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>double</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_DOUBLE_ARRAY;\n        }\n\n        double[] subarray = new double[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>float</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_FLOAT_ARRAY;\n        }\n\n        float[] subarray = new float[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    /**\n     * <p>Produces a new <code>boolean</code> array containing the elements\n     * between the start and end indices.</p>\n     *\n     * <p>The start index is inclusive, the end index exclusive.\n     * Null array input produces null output.</p>\n     *\n     * @param array  the array\n     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n     *      is promoted to 0, overvalue (&gt;array.length) results\n     *      in an empty array.\n     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n     *      returned subarray. Undervalue (&lt; startIndex) produces\n     *      empty array, overvalue (&gt;array.length) is demoted to\n     *      array length.\n     * @return a new array containing the elements between\n     *      the start and end indices.\n     * @since 2.1\n     */\n    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        if (newSize <= 0) {\n            return EMPTY_BOOLEAN_ARRAY;\n        }\n\n        boolean[] subarray = new boolean[newSize];\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n\n    // Is same length\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.\n     *\n     * <p>Any multi-dimensional aspects of the arrays are ignored.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(Object[] array1, Object[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(long[] array1, long[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(int[] array1, int[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(short[] array1, short[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(char[] array1, char[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(byte[] array1, byte[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(double[] array1, double[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(float[] array1, float[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same length, treating\n     * <code>null</code> arrays as length <code>0</code>.</p>\n     *\n     * @param array1 the first array, may be <code>null</code>\n     * @param array2 the second array, may be <code>null</code>\n     * @return <code>true</code> if length of arrays matches, treating\n     *  <code>null</code> as an empty array\n     */\n    public static boolean isSameLength(boolean[] array1, boolean[] array2) {\n        if ((array1 == null && array2 != null && array2.length > 0) ||\n            (array2 == null && array1 != null && array1.length > 0) ||\n            (array1 != null && array2 != null && array1.length != array2.length)) {\n                return false;\n        }\n        return true;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Returns the length of the specified array.\n     * This method can deal with <code>Object</code> arrays and with primitive arrays.</p>\n     *\n     * <p>If the input array is <code>null</code>, <code>0</code> is returned.</p>\n     *\n     * <pre>\n     * ArrayUtils.getLength(null)            = 0\n     * ArrayUtils.getLength([])              = 0\n     * ArrayUtils.getLength([null])          = 1\n     * ArrayUtils.getLength([true, false])   = 2\n     * ArrayUtils.getLength([1, 2, 3])       = 3\n     * ArrayUtils.getLength([\"a\", \"b\", \"c\"]) = 3\n     * </pre>\n     *\n     * @param array  the array to retrieve the length from, may be null\n     * @return The length of the array, or <code>0</code> if the array is <code>null</code>\n     * @throws IllegalArgumentException if the object arguement is not an array.\n     * @since 2.1\n     */\n    public static int getLength(Object array) {\n        if (array == null) {\n            return 0;\n        }\n        return Array.getLength(array);\n    }\n\n    /**\n     * <p>Checks whether two arrays are the same type taking into account\n     * multi-dimensional arrays.</p>\n     *\n     * @param array1 the first array, must not be <code>null</code>\n     * @param array2 the second array, must not be <code>null</code>\n     * @return <code>true</code> if type of arrays matches\n     * @throws IllegalArgumentException if either array is <code>null</code>\n     */\n    public static boolean isSameType(Object array1, Object array2) {\n        if (array1 == null || array2 == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        return array1.getClass().getName().equals(array2.getClass().getName());\n    }\n\n    // Reverse\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>There is no special handling for multi-dimensional arrays.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(Object[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(long[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        long tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(int[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        int tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(short[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        short tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(char[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        char tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(byte[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        byte tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(double[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        double tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(float[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        float tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * <p>Reverses the order of the given array.</p>\n     *\n     * <p>This method does nothing for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to reverse, may be <code>null</code>\n     */\n    public static void reverse(boolean[] array) {\n        if (array == null) {\n            return;\n        }\n        int i = 0;\n        int j = array.length - 1;\n        boolean tmp;\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    // IndexOf search\n    // ----------------------------------------------------------------------\n\n    // Object IndexOf\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Finds the index of the given object in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @return the index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(Object[] array, Object objectToFind) {\n        return indexOf(array, objectToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given object in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @param startIndex  the index to start searching at\n     * @return the index of the object within the array starting at the index,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(Object[] array, Object objectToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given object within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @return the last index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(Object[] array, Object objectToFind) {\n        return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given object in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n     * the array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the object within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n            for (int i = startIndex; i >= 0; i--) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the object is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param objectToFind  the object to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(Object[] array, Object objectToFind) {\n        return indexOf(array, objectToFind) != INDEX_NOT_FOUND;\n    }\n\n    // long IndexOf\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(long[] array, long valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(long[] array, long valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(long[] array, long valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(long[] array, long valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    // int IndexOf\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(int[] array, int valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(int[] array, int valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(int[] array, int valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(int[] array, int valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    // short IndexOf\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(short[] array, short valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(short[] array, short valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(short[] array, short valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(short[] array, short valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    // char IndexOf\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int indexOf(char[] array, char valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int indexOf(char[] array, char valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int lastIndexOf(char[] array, char valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     * @since 2.1\n     */\n    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     * @since 2.1\n     */\n    public static boolean contains(char[] array, char valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    // byte IndexOf\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(byte[] array, byte valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(byte[] array, byte valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(byte[] array, byte valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(byte[] array, byte valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    // double IndexOf\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(double[] array, double valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value within a given tolerance in the array.\n     * This method will return the index of the first value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(double[] array, double valueToFind, double tolerance) {\n        return indexOf(array, valueToFind, 0, tolerance);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(double[] array, double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.\n     * This method will return the index of the first value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i < array.length; i++) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(double[] array, double valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value within a given tolerance in the array.\n     * This method will return the index of the last value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param tolerance tolerance of the search\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(double[] array, double valueToFind, double tolerance) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.\n     * This method will return the index of the last value which falls between the region\n     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @param tolerance  search for value within plus/minus this amount\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        double min = valueToFind - tolerance;\n        double max = valueToFind + tolerance;\n        for (int i = startIndex; i >= 0; i--) {\n            if (array[i] >= min && array[i] <= max) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(double[] array, double valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if a value falling within the given tolerance is in the\n     * given array.  If the array contains a value within the inclusive range\n     * defined by (value - tolerance) to (value + tolerance).</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array\n     * is passed in.</p>\n     *\n     * @param array  the array to search\n     * @param valueToFind  the value to find\n     * @param tolerance  the array contains the tolerance of the search\n     * @return true if value falling within tolerance is in array\n     */\n    public static boolean contains(double[] array, double valueToFind, double tolerance) {\n        return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND;\n    }\n\n    // float IndexOf\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(float[] array, float valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(float[] array, float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(float[] array, float valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n     * array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(float[] array, float valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    // boolean IndexOf\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Finds the index of the given value in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int indexOf(boolean[] array, boolean valueToFind) {\n        return indexOf(array, valueToFind, 0);\n    }\n\n    /**\n     * <p>Finds the index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n     *\n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the index to start searching at\n     * @return the index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>\n     *  array input\n     */\n    public static int indexOf(boolean[] array, boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        for (int i = startIndex; i < array.length; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Finds the last index of the given value within the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) if\n     * <code>null</code> array input.</p>\n     *\n     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n     * @param valueToFind  the object to find\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(boolean[] array, boolean valueToFind) {\n        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     *\n     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n     * the array length will search from the end of the array.</p>\n     *\n     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n     * @param valueToFind  the value to find\n     * @param startIndex  the start index to travers backwards from\n     * @return the last index of the value within the array,\n     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n     */\n    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {\n        if (ArrayUtils.isEmpty(array)) {\n            return INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            return INDEX_NOT_FOUND;\n        } else if (startIndex >= array.length) {\n            startIndex = array.length - 1;\n        }\n        for (int i = startIndex; i >= 0; i--) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>Checks if the value is in the given array.</p>\n     *\n     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n     *\n     * @param array  the array to search through\n     * @param valueToFind  the value to find\n     * @return <code>true</code> if the array contains the object\n     */\n    public static boolean contains(boolean[] array, boolean valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    // Primitive/Object array converters\n    // ----------------------------------------------------------------------\n\n    // Character array converters\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Converts an array of object Characters to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Character</code> array, may be <code>null</code>\n     * @return a <code>char</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static char[] toPrimitive(Character[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].charValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Character to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Character</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>char</code> array, <code>null</code> if null array input\n     */\n    public static char[] toPrimitive(Character[] array, char valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHAR_ARRAY;\n        }\n        final char[] result = new char[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Character b = array[i];\n            result[i] = (b == null ? valueForNull : b.charValue());\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive chars to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array a <code>char</code> array\n     * @return a <code>Character</code> array, <code>null</code> if null array input\n     */\n    public static Character[] toObject(char[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_CHARACTER_OBJECT_ARRAY;\n        }\n        final Character[] result = new Character[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Character.valueOf(array[i]);\n        }\n        return result;\n     }\n\n    // Long array converters\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Converts an array of object Longs to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Long</code> array, may be <code>null</code>\n     * @return a <code>long</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static long[] toPrimitive(Long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].longValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Long to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Long</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>long</code> array, <code>null</code> if null array input\n     */\n    public static long[] toPrimitive(Long[] array, long valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_ARRAY;\n        }\n        final long[] result = new long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Long b = array[i];\n            result[i] = (b == null ? valueForNull : b.longValue());\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive longs to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>long</code> array\n     * @return a <code>Long</code> array, <code>null</code> if null array input\n     */\n    public static Long[] toObject(long[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_LONG_OBJECT_ARRAY;\n        }\n        final Long[] result = new Long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Long.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    // Int array converters\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Converts an array of object Integers to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Integer</code> array, may be <code>null</code>\n     * @return an <code>int</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static int[] toPrimitive(Integer[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].intValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Integer to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Integer</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return an <code>int</code> array, <code>null</code> if null array input\n     */\n    public static int[] toPrimitive(Integer[] array, int valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive ints to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  an <code>int</code> array\n     * @return an <code>Integer</code> array, <code>null</code> if null array input\n     */\n    public static Integer[] toObject(int[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INTEGER_OBJECT_ARRAY;\n        }\n        final Integer[] result = new Integer[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Integer.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    // Short array converters\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Converts an array of object Shorts to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Short</code> array, may be <code>null</code>\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static short[] toPrimitive(Short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].shortValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Short to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Short</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     */\n    public static short[] toPrimitive(Short[] array, short valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_SHORT_ARRAY;\n        }\n        final short[] result = new short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Short b = array[i];\n            result[i] = (b == null ? valueForNull : b.shortValue());\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive shorts to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>short</code> array\n     * @return a <code>Short</code> array, <code>null</code> if null array input\n     */\n    public static Short[] toObject(short[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_SHORT_OBJECT_ARRAY;\n        }\n        final Short[] result = new Short[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Short.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    // Byte array converters\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Converts an array of object Bytes to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Byte</code> array, may be <code>null</code>\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static byte[] toPrimitive(Byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].byteValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Bytes to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Byte</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>byte</code> array, <code>null</code> if null array input\n     */\n    public static byte[] toPrimitive(Byte[] array, byte valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte[] result = new byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Byte b = array[i];\n            result[i] = (b == null ? valueForNull : b.byteValue());\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive bytes to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>byte</code> array\n     * @return a <code>Byte</code> array, <code>null</code> if null array input\n     */\n    public static Byte[] toObject(byte[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BYTE_OBJECT_ARRAY;\n        }\n        final Byte[] result = new Byte[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Byte.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    // Double array converters\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Converts an array of object Doubles to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Double</code> array, may be <code>null</code>\n     * @return a <code>double</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static double[] toPrimitive(Double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].doubleValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Doubles to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Double</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>double</code> array, <code>null</code> if null array input\n     */\n    public static double[] toPrimitive(Double[] array, double valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_DOUBLE_ARRAY;\n        }\n        final double[] result = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Double b = array[i];\n            result[i] = (b == null ? valueForNull : b.doubleValue());\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive doubles to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>double</code> array\n     * @return a <code>Double</code> array, <code>null</code> if null array input\n     */\n    public static Double[] toObject(double[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_DOUBLE_OBJECT_ARRAY;\n        }\n        final Double[] result = new Double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Double.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    //   Float array converters\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Converts an array of object Floats to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Float</code> array, may be <code>null</code>\n     * @return a <code>float</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static float[] toPrimitive(Float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].floatValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Floats to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Float</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>float</code> array, <code>null</code> if null array input\n     */\n    public static float[] toPrimitive(Float[] array, float valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_FLOAT_ARRAY;\n        }\n        final float[] result = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Float b = array[i];\n            result[i] = (b == null ? valueForNull : b.floatValue());\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive floats to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>float</code> array\n     * @return a <code>Float</code> array, <code>null</code> if null array input\n     */\n    public static Float[] toObject(float[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_FLOAT_OBJECT_ARRAY;\n        }\n        final Float[] result = new Float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = Float.valueOf(array[i]);\n        }\n        return result;\n    }\n\n    // Boolean array converters\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Converts an array of object Booleans to primitives.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n     * @return a <code>boolean</code> array, <code>null</code> if null array input\n     * @throws NullPointerException if array content is <code>null</code>\n     */\n    public static boolean[] toPrimitive(Boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i].booleanValue();\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of object Booleans to primitives handling <code>null</code>.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n     * @param valueForNull  the value to insert if <code>null</code> found\n     * @return a <code>boolean</code> array, <code>null</code> if null array input\n     */\n    public static boolean[] toPrimitive(Boolean[] array, boolean valueForNull) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BOOLEAN_ARRAY;\n        }\n        final boolean[] result = new boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Boolean b = array[i];\n            result[i] = (b == null ? valueForNull : b.booleanValue());\n        }\n        return result;\n    }\n\n    /**\n     * <p>Converts an array of primitive booleans to objects.</p>\n     *\n     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n     *\n     * @param array  a <code>boolean</code> array\n     * @return a <code>Boolean</code> array, <code>null</code> if null array input\n     */\n    public static Boolean[] toObject(boolean[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_BOOLEAN_OBJECT_ARRAY;\n        }\n        final Boolean[] result = new Boolean[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);\n        }\n        return result;\n    }\n\n    // ----------------------------------------------------------------------\n    /**\n     * <p>Checks if an array of Objects is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static <T> boolean isEmpty(T[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * <p>Checks if an array of primitive longs is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(long[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * <p>Checks if an array of primitive ints is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(int[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * <p>Checks if an array of primitive shorts is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(short[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * <p>Checks if an array of primitive chars is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(char[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * <p>Checks if an array of primitive bytes is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(byte[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(double[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * <p>Checks if an array of primitive floats is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(float[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * <p>Checks if an array of primitive booleans is empty or <code>null</code>.</p>\n     *\n     * @param array  the array to test\n     * @return <code>true</code> if the array is empty or <code>null</code>\n     * @since 2.1\n     */\n    public static boolean isEmpty(boolean[] array) {\n        if (array == null || array.length == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(null, null)     = null\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * ArrayUtils.addAll([null], [null]) = [null, null]\n     * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n     * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n     * @return The new array, <code>null</code> if both arrays are <code>null</code>.\n     *      The type of the new array is the type of the first array,\n     *      unless the first array is null, in which case the type is the same as the second array.\n     * @since 2.1\n     * @throws IllegalArgumentException if the array types are incompatible\n     */\n    public static <T> T[] addAll(T[] array1, T... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        final Class<?> type1 = array1.getClass().getComponentType();\n        @SuppressWarnings(\"unchecked\") // OK, because array is of type T\n        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        try {\n            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        } catch (ArrayStoreException ase) {\n            // Check if problem was due to incompatible types\n            /*\n             * We do this here, rather than before the copy because:\n             * - it would be a wasted check most of the time\n             * - safer, in case check turns out to be too strict\n             */\n            final Class<?> type2 = array2.getClass().getComponentType();\n            if (!type1.isAssignableFrom(type2)){\n                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName(), ase);\n            }\n            throw ase; // No, so rethrow original\n        }\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new boolean[] array.\n     * @since 2.1\n     */\n    public static boolean[] addAll(boolean[] array1, boolean... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        boolean[] joinedArray = new boolean[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new char[] array.\n     * @since 2.1\n     */\n    public static char[] addAll(char[] array1, char... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        char[] joinedArray = new char[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new byte[] array.\n     * @since 2.1\n     */\n    public static byte[] addAll(byte[] array1, byte... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        byte[] joinedArray = new byte[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new short[] array.\n     * @since 2.1\n     */\n    public static short[] addAll(short[] array1, short... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        short[] joinedArray = new short[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new int[] array.\n     * @since 2.1\n     */\n    public static int[] addAll(int[] array1, int... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        int[] joinedArray = new int[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new long[] array.\n     * @since 2.1\n     */\n    public static long[] addAll(long[] array1, long... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        long[] joinedArray = new long[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new float[] array.\n     * @since 2.1\n     */\n    public static float[] addAll(float[] array1, float... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        float[] joinedArray = new float[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Adds all the elements of the given arrays into a new array.</p>\n     * <p>The new array contains all of the element of <code>array1</code> followed\n     * by all of the elements <code>array2</code>. When an array is returned, it is always\n     * a new array.</p>\n     *\n     * <pre>\n     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n     * ArrayUtils.addAll([], [])         = []\n     * </pre>\n     *\n     * @param array1  the first array whose elements are added to the new array.\n     * @param array2  the second array whose elements are added to the new array.\n     * @return The new double[] array.\n     * @since 2.1\n     */\n    public static double[] addAll(double[] array1, double... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        double[] joinedArray = new double[array1.length + array2.length];\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element, unless the element itself is null,\n     *  in which case the return type is Object[]</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, null)      = [null]\n     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to \"add\" the element to, may be <code>null</code>\n     * @param element  the object to add, may be <code>null</code>\n     * @return A new array containing the existing elements plus the new element\n     * The returned array type will be that of the input array (unless null),\n     * in which case it will have the same type as the element.\n     * If both are null, an IllegalArgumentException is thrown\n     * @since 2.1\n     * @throws IllegalArgumentException if both arguments are null\n     */\n    public static <T> T[] add(T[] array, T element) {\n        Class<?> type;\n        if (array != null){\n            type = array.getClass();\n        } else if (element != null) {\n            type = element.getClass();\n        } else {\n            type = Object.class;\n        }\n        @SuppressWarnings(\"unchecked\") // type must be T\n        T[] newArray = (T[]) copyArrayGrow1(array, type);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, true)          = [true]\n     * ArrayUtils.add([true], false)       = [true, false]\n     * ArrayUtils.add([true, false], true) = [true, false, true]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static boolean[] add(boolean[] array, boolean element) {\n        boolean[] newArray = (boolean[])copyArrayGrow1(array, Boolean.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static byte[] add(byte[] array, byte element) {\n        byte[] newArray = (byte[])copyArrayGrow1(array, Byte.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, '0')       = ['0']\n     * ArrayUtils.add(['1'], '0')      = ['1', '0']\n     * ArrayUtils.add(['1', '0'], '1') = ['1', '0', '1']\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static char[] add(char[] array, char element) {\n        char[] newArray = (char[])copyArrayGrow1(array, Character.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static double[] add(double[] array, double element) {\n        double[] newArray = (double[])copyArrayGrow1(array, Double.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static float[] add(float[] array, float element) {\n        float[] newArray = (float[])copyArrayGrow1(array, Float.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static int[] add(int[] array, int element) {\n        int[] newArray = (int[])copyArrayGrow1(array, Integer.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static long[] add(long[] array, long element) {\n        long[] newArray = (long[])copyArrayGrow1(array, Long.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n     *\n     * <p>The new array contains the same elements of the input\n     * array plus the given element in the last position. The component type of\n     * the new array is the same as that of the input array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0)   = [0]\n     * ArrayUtils.add([1], 0)    = [1, 0]\n     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n     * </pre>\n     *\n     * @param array  the array to copy and add the element to, may be <code>null</code>\n     * @param element  the object to add at the last index of the new array\n     * @return A new array containing the existing elements plus the new element\n     * @since 2.1\n     */\n    public static short[] add(short[] array, short element) {\n        short[] newArray = (short[])copyArrayGrow1(array, Short.TYPE);\n        newArray[newArray.length - 1] = element;\n        return newArray;\n    }\n\n    /**\n     * Returns a copy of the given array of size 1 greater than the argument.\n     * The last value of the array is left to the default value.\n     *\n     * @param array The array to copy, must not be <code>null</code>.\n     * @param newArrayComponentType If <code>array</code> is <code>null</code>, create a\n     * size 1 array of this type.\n     * @return A new copy of the array of size 1 greater than the input.\n     */\n    private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentType) {\n        if (array != null) {\n            int arrayLength = Array.getLength(array);\n            Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n            System.arraycopy(array, 0, newArray, 0, arrayLength);\n            return newArray;\n        }\n        return Array.newInstance(newArrayComponentType, 1);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, null)      = [null]\n     * ArrayUtils.add(null, 0, \"a\")       = [\"a\"]\n     * ArrayUtils.add([\"a\"], 1, null)     = [\"a\", null]\n     * ArrayUtils.add([\"a\"], 1, \"b\")      = [\"a\", \"b\"]\n     * ArrayUtils.add([\"a\", \"b\"], 3, \"c\") = [\"a\", \"b\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     * @throws IllegalArgumentException if both array and element are null\n     */\n    public static <T> T[] add(T[] array, int index, T element) {\n        Class<?> clss = null;\n        if (array != null) {\n            clss = array.getClass().getComponentType();\n        } else if (element != null) {\n            clss = element.getClass();\n        } else {\n            return (T[]) new Object[] { null };\n        }\n        @SuppressWarnings(\"unchecked\") // the add method creates an array of type clss, which is type T\n        final T[] newArray = (T[]) add(array, index, element, clss);\n        return newArray;\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, true)          = [true]\n     * ArrayUtils.add([true], 0, false)       = [false, true]\n     * ArrayUtils.add([false], 1, true)       = [false, true]\n     * ArrayUtils.add([true, false], 1, true) = [true, true, false]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static boolean[] add(boolean[] array, int index, boolean element) {\n        return (boolean[]) add(array, index, Boolean.valueOf(element), Boolean.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add(null, 0, 'a')            = ['a']\n     * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']\n     * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']\n     * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']\n     * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static char[] add(char[] array, int index, char element) {\n        return (char[]) add(array, index, Character.valueOf(element), Character.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]\n     * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static byte[] add(byte[] array, int index, byte element) {\n        return (byte[]) add(array, index, Byte.valueOf(element), Byte.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static short[] add(short[] array, int index, short element) {\n        return (short[]) add(array, index, Short.valueOf(element), Short.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static int[] add(int[] array, int index, int element) {\n        return (int[]) add(array, index, Integer.valueOf(element), Integer.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1L], 0, 2L)           = [2L, 1L]\n     * ArrayUtils.add([2L, 6L], 2, 10L)      = [2L, 6L, 10L]\n     * ArrayUtils.add([2L, 6L], 0, -4L)      = [-4L, 2L, 6L]\n     * ArrayUtils.add([2L, 6L, 3L], 2, 1L)   = [2L, 6L, 1L, 3L]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static long[] add(long[] array, int index, long element) {\n        return (long[]) add(array, index, Long.valueOf(element), Long.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]\n     * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]\n     * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]\n     * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static float[] add(float[] array, int index, float element) {\n        return (float[]) add(array, index, Float.valueOf(element), Float.TYPE);\n    }\n\n    /**\n     * <p>Inserts the specified element at the specified position in the array.\n     * Shifts the element currently at that position (if any) and any subsequent\n     * elements to the right (adds one to their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array plus the given element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, a new one element array is returned\n     *  whose component type is the same as the element.</p>\n     *\n     * <pre>\n     * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]\n     * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]\n     * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]\n     * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]\n     * </pre>\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @return A new array containing the existing elements and the new element\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index > array.length).\n     */\n    public static double[] add(double[] array, int index, double element) {\n        return (double[]) add(array, index, Double.valueOf(element), Double.TYPE);\n    }\n\n    /**\n     * Underlying implementation of add(array, index, element) methods.\n     * The last parameter is the class, which may not equal element.getClass\n     * for primitives.\n     *\n     * @param array  the array to add the element to, may be <code>null</code>\n     * @param index  the position of the new object\n     * @param element  the object to add\n     * @param clss the type of the element being added\n     * @return A new array containing the existing elements and the new element\n     */\n    private static Object add(Object array, int index, Object element, Class<?> clss) {\n        if (array == null) {\n            if (index != 0) {\n                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n            }\n            Object joinedArray = Array.newInstance(clss, 1);\n            Array.set(joinedArray, 0, element);\n            return joinedArray;\n        }\n        int length = Array.getLength(array);\n        if (index > length || index < 0) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n        Object result = Array.newInstance(clss, length + 1);\n        System.arraycopy(array, 0, result, 0, index);\n        Array.set(result, index, element);\n        if (index < length) {\n            System.arraycopy(array, index, result, index + 1, length - index);\n        }\n        return result;\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([\"a\"], 0)           = []\n     * ArrayUtils.remove([\"a\", \"b\"], 0)      = [\"b\"]\n     * ArrayUtils.remove([\"a\", \"b\"], 1)      = [\"a\"]\n     * ArrayUtils.remove([\"a\", \"b\", \"c\"], 1) = [\"a\", \"c\"]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    @SuppressWarnings(\"unchecked\") // remove() always creates an array of the same type as its input\n    public static <T> T[] remove(T[] array, int index) {\n        return (T[]) remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, \"a\")            = null\n     * ArrayUtils.removeElement([], \"a\")              = []\n     * ArrayUtils.removeElement([\"a\"], \"b\")           = [\"a\"]\n     * ArrayUtils.removeElement([\"a\", \"b\"], \"a\")      = [\"b\"]\n     * ArrayUtils.removeElement([\"a\", \"b\", \"a\"], \"a\") = [\"b\", \"a\"]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static <T> T[] removeElement(T[] array, Object element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([true], 0)              = []\n     * ArrayUtils.remove([true, false], 0)       = [false]\n     * ArrayUtils.remove([true, false], 1)       = [true]\n     * ArrayUtils.remove([true, true, false], 1) = [true, false]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static boolean[] remove(boolean[] array, int index) {\n        return (boolean[]) remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, true)                = null\n     * ArrayUtils.removeElement([], true)                  = []\n     * ArrayUtils.removeElement([true], false)             = [true]\n     * ArrayUtils.removeElement([true, false], false)      = [true]\n     * ArrayUtils.removeElement([true, false, true], true) = [false, true]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static boolean[] removeElement(boolean[] array, boolean element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)          = []\n     * ArrayUtils.remove([1, 0], 0)       = [0]\n     * ArrayUtils.remove([1, 0], 1)       = [1]\n     * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static byte[] remove(byte[] array, int index) {\n        return (byte[]) remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)        = null\n     * ArrayUtils.removeElement([], 1)          = []\n     * ArrayUtils.removeElement([1], 0)         = [1]\n     * ArrayUtils.removeElement([1, 0], 0)      = [1]\n     * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static byte[] removeElement(byte[] array, byte element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove(['a'], 0)           = []\n     * ArrayUtils.remove(['a', 'b'], 0)      = ['b']\n     * ArrayUtils.remove(['a', 'b'], 1)      = ['a']\n     * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static char[] remove(char[] array, int index) {\n        return (char[]) remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 'a')            = null\n     * ArrayUtils.removeElement([], 'a')              = []\n     * ArrayUtils.removeElement(['a'], 'b')           = ['a']\n     * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']\n     * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static char[] removeElement(char[] array, char element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1.1], 0)           = []\n     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static double[] remove(double[] array, int index) {\n        return (double[]) remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1.1)            = null\n     * ArrayUtils.removeElement([], 1.1)              = []\n     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static double[] removeElement(double[] array, double element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1.1], 0)           = []\n     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static float[] remove(float[] array, int index) {\n        return (float[]) remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1.1)            = null\n     * ArrayUtils.removeElement([], 1.1)              = []\n     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static float[] removeElement(float[] array, float element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static int[] remove(int[] array, int index) {\n        return (int[]) remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static int[] removeElement(int[] array, int element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static long[] remove(long[] array, int index) {\n        return (long[]) remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static long[] removeElement(long[] array, long element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * <pre>\n     * ArrayUtils.remove([1], 0)         = []\n     * ArrayUtils.remove([2, 6], 0)      = [6]\n     * ArrayUtils.remove([2, 6], 1)      = [2]\n     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    public static short[] remove(short[] array, int index) {\n        return (short[]) remove((Object) array, index);\n    }\n\n    /**\n     * <p>Removes the first occurrence of the specified element from the\n     * specified array. All subsequent elements are shifted to the left\n     * (substracts one from their indices). If the array doesn't contains\n     * such an element, no elements are removed from the array.</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the first occurrence of the specified element. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <pre>\n     * ArrayUtils.removeElement(null, 1)      = null\n     * ArrayUtils.removeElement([], 1)        = []\n     * ArrayUtils.removeElement([1], 2)       = [1]\n     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n     * </pre>\n     *\n     * @param array  the array to remove the element from, may be <code>null</code>\n     * @param element  the element to be removed\n     * @return A new array containing the existing elements except the first\n     *         occurrence of the specified element.\n     * @since 2.1\n     */\n    public static short[] removeElement(short[] array, short element) {\n        int index = indexOf(array, element);\n        if (index == INDEX_NOT_FOUND) {\n            return clone(array);\n        }\n        return remove(array, index);\n    }\n\n    /**\n     * <p>Removes the element at the specified position from the specified array.\n     * All subsequent elements are shifted to the left (substracts one from\n     * their indices).</p>\n     *\n     * <p>This method returns a new array with the same elements of the input\n     * array except the element on the specified position. The component\n     * type of the returned array is always the same as that of the input\n     * array.</p>\n     *\n     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n     * will be thrown, because in that case no valid index can be specified.</p>\n     *\n     * @param array  the array to remove the element from, may not be <code>null</code>\n     * @param index  the position of the element to be removed\n     * @return A new array containing the existing elements except the element\n     *         at the specified position.\n     * @throws IndexOutOfBoundsException if the index is out of range\n     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n     * @since 2.1\n     */\n    private static Object remove(Object array, int index) {\n        int length = getLength(array);\n        if (index < 0 || index >= length) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n        }\n\n        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n        System.arraycopy(array, 0, result, 0, index);\n        if (index < length - 1) {\n            System.arraycopy(array, index + 1, result, index, length - index - 1);\n        }\n\n        return result;\n    }\n\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"type\": \"Potential NullPointerException\",\n         \"description\": \"In the toString method, if the array is null, it will return '{}'. However, if the array is not null but contains null elements, it will throw a NullPointerException when trying to call toString on the null elements.\",\n         \"location\": \"ArrayUtils.toString(Object array)\"\n      },\n      {\n         \"type\": \"Potential ClassCastException\",\n         \"description\": \"In the toString method, if the array contains elements of different classes, it will throw a ClassCastException when trying to call toString on the elements.\",\n         \"location\": \"ArrayUtils.toString(Object array)\"\n      },\n      {\n         \"type\": \"Potential StackOverflowError\",\n         \"description\": \"In the toString method, if the array is a multi-dimensional array with a very deep nesting level, it will throw a StackOverflowError when trying to recursively call toString on the sub-arrays.\",\n         \"location\": \"ArrayUtils.toString(Object array)\"\n      },\n      {\n         \"type\": \"Potential IndexOutOfBoundsException\",\n         \"description\": \"In the ArrayUtils class, some methods (like clone) do not check if the input array is null or empty before using it. This can lead to an IndexOutOfBoundsException if the input array is null or empty.\",\n         \"location\": \"ArrayUtils.clone(Object array)\"\n      }\n   ]\n}"}}