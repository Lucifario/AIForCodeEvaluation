{"sample_id": "Math_31", "model": "llama3-8b-groq", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math3.util;\n\nimport org.apache.commons.math3.exception.ConvergenceException;\nimport org.apache.commons.math3.exception.MaxCountExceededException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\n\n/**\n * Provides a generic means to evaluate continued fractions.  Subclasses simply\n * provided the a and b coefficients to evaluate the continued fraction.\n *\n * <p>\n * References:\n * <ul>\n * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n * Continued Fraction</a></li>\n * </ul>\n * </p>\n *\n * @version $Id$\n */\npublic abstract class ContinuedFraction {\n    /** Maximum allowed numerical error. */\n    private static final double DEFAULT_EPSILON = 10e-9;\n\n    /**\n     * Default constructor.\n     */\n    protected ContinuedFraction() {\n        super();\n    }\n\n    /**\n     * Access the n-th a coefficient of the continued fraction.  Since a can be\n     * a function of the evaluation point, x, that is passed in as well.\n     * @param n the coefficient index to retrieve.\n     * @param x the evaluation point.\n     * @return the n-th a coefficient.\n     */\n    protected abstract double getA(int n, double x);\n\n    /**\n     * Access the n-th b coefficient of the continued fraction.  Since b can be\n     * a function of the evaluation point, x, that is passed in as well.\n     * @param n the coefficient index to retrieve.\n     * @param x the evaluation point.\n     * @return the n-th b coefficient.\n     */\n    protected abstract double getB(int n, double x);\n\n    /**\n     * Evaluates the continued fraction at the value x.\n     * @param x the evaluation point.\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     */\n    public double evaluate(double x) {\n        return evaluate(x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Evaluates the continued fraction at the value x.\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     */\n    public double evaluate(double x, double epsilon) {\n        return evaluate(x, epsilon, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Evaluates the continued fraction at the value x.\n     * @param x the evaluation point.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     */\n    public double evaluate(double x, int maxIterations) {\n        return evaluate(x, DEFAULT_EPSILON, maxIterations);\n    }\n\n    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50;\n        double hPrev = getA(0, x);\n\n        // use the value of small as epsilon criteria for zero checks\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n\n        int n = 1;\n        double dPrev = 0.0;\n        double p0 = 1.0;\n        double q1 = 1.0;\n        double cPrev = hPrev;\n        double hN = hPrev;\n\n        while (n < maxIterations) {\n            final double a = getA(n, x);\n            final double b = getB(n, x);\n\n            double cN = a * hPrev + b * p0;\n            double q2 = a * q1 + b * dPrev;\n            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n                double scaleFactor = 1d;\n                double lastScaleFactor = 1d;\n                final int maxPower = 5;\n                final double scale = FastMath.max(a,b);\n                if (scale <= 0) {  // Can't scale\n                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n                }\n                for (int i = 0; i < maxPower; i++) {\n                    lastScaleFactor = scaleFactor;\n                    scaleFactor *= scale;\n                    if (a != 0.0 && a > b) {\n                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                    } else if (b != 0) {\n                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                    }\n                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                        break;\n                    }\n                }\n            }\n\n            final double deltaN = cN / q2 / cPrev;\n            hN = cPrev * deltaN;\n\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                               x);\n            }\n            if (Double.isNaN(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                               x);\n            }\n\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n\n            dPrev = q1;\n            cPrev = cN / q2;\n            p0 = hPrev;\n            hPrev = cN;\n            q1 = q2;\n            n++;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hN;\n    }\n\n}\n", "review": {"response": "{\n  \"bugs\":[\n      {\n         \"bug\":\"Potential Null Pointer Exception in getA(int n, double x) and getB(int n, double x) methods\",\n         \"description\":\"These methods are abstract and must be implemented by subclasses. However, they do not check if the subclass has implemented these methods. If a subclass does not implement these methods, calling these methods will result in a Null Pointer Exception.\",\n         \"solution\":\"Add a check in these methods to ensure that the subclass has implemented them.\"\n      },\n      {\n         \"bug\":\"Potential ConvergenceException in evaluate(double x) method\",\n         \"description\":\"This method calls the evaluate(double x, double epsilon, int maxIterations) method with default values for epsilon and maxIterations. However, it does not check if the default values are valid. If the default values are not valid, calling this method may result in a ConvergenceException.\",\n         \"solution\":\"Add a check in this method to ensure that the default values are valid.\"\n      },\n      {\n         \"bug\":\"Potential ConvergenceException in evaluate(double x, double epsilon) method\",\n         \"description\":\"This method calls the evaluate(double x, double epsilon, int maxIterations) method with a default value for maxIterations. However, it does not check if the default value is valid. If the default value is not valid, calling this method may result in a ConvergenceException.\",\n         \"solution\":\"Add a check in this method to ensure that the default value is valid.\"\n      },\n      {\n         \"bug\":\"Potential ConvergenceException in evaluate(double x, int maxIterations) method\",\n         \"description\":\"This method calls the evaluate(double x, double epsilon, int maxIterations) method with a default value for epsilon. However, it does not check if the default value is valid. If the default value is not valid, calling this method may result in a ConvergenceException.\",\n         \"solution\":\"Add a check in this method to ensure that the default value is valid.\"\n      },\n      {\n         \"bug\":\"Potential ConvergenceException in evaluate(double x, double epsilon, int maxIterations) method\",\n         \"description\":\"This method uses the Lentz algorithm to evaluate the continued fraction. However, it does not check if the algorithm has converged. If the algorithm has not converged, calling this method may result in a ConvergenceException.\",\n         \"solution\":\"Add a check in this method to ensure that the algorithm has converged.\"\n      }\n   ]\n}"}}