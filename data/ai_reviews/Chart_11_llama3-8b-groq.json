{"sample_id": "Chart_11", "model": "llama3-8b-groq", "code_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p1.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n", "review": {"response": "{\n  \"bugs\": [\n      {\n         \"description\": \"The clone method does not handle the cloning of shapes correctly. It does not actually clone the shape, but instead returns null.\",\n         \"line\": 44,\n         \"column\": 5\n      },\n      {\n         \"description\": \"The equal method does not handle the case where s1 and s2 are both null correctly. It should return true in this case.\",\n         \"line\": 143,\n         \"column\": 5\n      },\n      {\n         \"description\": \"The equal method does not handle the case where s1 and s2 are both Line2D instances correctly. It should return true if the lines are equal, and false otherwise.\",\n         \"line\": 149,\n         \"column\": 5\n      },\n      {\n         \"description\": \"The equal method does not handle the case where s1 and s2 are both Ellipse2D instances correctly. It should return true if the ellipses are equal, and false otherwise.\",\n         \"line\": 155,\n         \"column\": 5\n      },\n      {\n         \"description\": \"The equal method does not handle the case where s1 and s2 are both Arc2D instances correctly. It should return true if the arcs are equal, and false otherwise.\",\n         \"line\": 161,\n         \"column\": 5\n      },\n      {\n         \"description\": \"The equal method does not handle the case where s1 and s2 are both Polygon instances correctly. It should return true if the polygons are equal, and false otherwise.\",\n         \"line\": 167,\n         \"column\": 5\n      },\n      {\n         \"description\": \"The equal method does not handle the case where s1 and s2 are both GeneralPath instances correctly. It should return true if the general paths are equal, and false otherwise.\",\n         \"line\": 173,\n         \"column\": 5\n      },\n      {\n         \"description\": \"The equal method does not handle the case where s1 and s2 are both Arc2D instances correctly. It should return true if the arcs are equal, and false otherwise.\",\n         \"line\": 179,\n         \"column\": 5\n      }\n   ]\n}"}}