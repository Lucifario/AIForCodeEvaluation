{"sample_id": "Math_99", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.util;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.MathRuntimeException;\n\n/**\n * Some useful additions to the built-in functions in {@link Math}.\n * @version $Revision$ $Date$\n */\npublic final class MathUtils {\n\n    /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */\n    public static final double EPSILON = 0x1.0p-53;\n\n    /** Safe minimum, such that 1 / SAFE_MIN does not overflow.\n     * <p>In IEEE 754 arithmetic, this is also the smallest normalized\n     * number 2<sup>-1022</sup>.</p>\n     */\n    public static final double SAFE_MIN = 0x1.0p-1022;\n\n    /** -1.0 cast as a byte. */\n    private static final byte  NB = (byte)-1;\n\n    /** -1.0 cast as a short. */\n    private static final short NS = (short)-1;\n\n    /** 1.0 cast as a byte. */\n    private static final byte  PB = (byte)1;\n\n    /** 1.0 cast as a short. */\n    private static final short PS = (short)1;\n\n    /** 0.0 cast as a byte. */\n    private static final byte  ZB = (byte)0;\n\n    /** 0.0 cast as a short. */\n    private static final short ZS = (short)0;\n\n    /** 2 &pi;. */\n    private static final double TWO_PI = 2 * Math.PI;\n\n    /**\n     * Private Constructor\n     */\n    private MathUtils() {\n        super();\n    }\n\n    /**\n     * Add two integers, checking for overflow.\n     * \n     * @param x an addend\n     * @param y an addend\n     * @return the sum <code>x+y</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         int\n     * @since 1.1\n     */\n    public static int addAndCheck(int x, int y) {\n        long s = (long)x + (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: add\");\n        }\n        return (int)s;\n    }\n\n    /**\n     * Add two long integers, checking for overflow.\n     * \n     * @param a an addend\n     * @param b an addend\n     * @return the sum <code>a+b</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         long\n     * @since 1.2\n     */\n    public static long addAndCheck(long a, long b) {\n        return addAndCheck(a, b, \"overflow: add\");\n    }\n    \n    /**\n     * Add two long integers, checking for overflow.\n     * \n     * @param a an addend\n     * @param b an addend\n     * @param msg the message to use for any thrown exception.\n     * @return the sum <code>a+b</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         long\n     * @since 1.2\n     */\n    private static long addAndCheck(long a, long b, String msg) {\n        long ret;\n        if (a > b) {\n            // use symmetry to reduce boundary cases\n            ret = addAndCheck(b, a, msg);\n        } else {\n            // assert a <= b\n            \n            if (a < 0) {\n                if (b < 0) {\n                    // check for negative overflow\n                    if (Long.MIN_VALUE - b <= a) {\n                        ret = a + b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else {\n                    // opposite sign addition is always safe\n                    ret = a + b;\n                }\n            } else {\n                // assert a >= 0\n                // assert b >= 0\n\n                // check for positive overflow\n                if (a <= Long.MAX_VALUE - b) {\n                    ret = a + b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            }\n        }\n        return ret;\n    }\n    \n    /**\n     * Returns an exact representation of the <a\n     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n     * <code>k</code>-element subsets that can be selected from an\n     * <code>n</code>-element set.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>0 <= k <= n </code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * <li> The result is small enough to fit into a <code>long</code>. The\n     * largest value of <code>n</code> for which all coefficients are\n     * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds\n     * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is\n     * thrown.</li>\n     * </ul></p>\n     * \n     * @param n the size of the set\n     * @param k the size of the subsets to be counted\n     * @return <code>n choose k</code>\n     * @throws IllegalArgumentException if preconditions are not met.\n     * @throws ArithmeticException if the result is too large to be represented\n     *         by a long integer.\n     */\n    public static long binomialCoefficient(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 1;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        // Use symmetry for large k\n        if (k > n / 2)\n            return binomialCoefficient(n, n - k);\n        \n        // We use the formula\n        // (n choose k) = n! / (n-k)! / k!\n        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n        // which could be written\n        // (n choose k) == (n-1 choose k-1) * n / k\n        long result = 1;\n        if (n <= 61) {\n            // For n <= 61, the naive implementation cannot overflow.\n            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                result = result * i / j;\n            }\n        } else if (n <= 66) {\n            // For n > 61 but n <= 66, the result cannot overflow,\n            // but we must take care not to overflow intermediate values.\n            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                // We know that (result * i) is divisible by j,\n                // but (result * i) may overflow, so we split j:\n                // Filter out the gcd, d, so j/d and i/d are integer.\n                // result is divisible by (j/d) because (j/d)\n                // is relative prime to (i/d) and is a divisor of\n                // result * (i/d).\n                long d = gcd(i, j);\n                result = (result / (j / d)) * (i / d);\n            }\n        } else {\n            // For n > 66, a result overflow might occur, so we check\n            // the multiplication, taking care to not overflow\n            // unnecessary.\n            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                long d = gcd(i, j);\n                result = mulAndCheck((result / (j / d)), (i / d));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a <code>double</code> representation of the <a\n     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n     * <code>k</code>-element subsets that can be selected from an\n     * <code>n</code>-element set.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>0 <= k <= n </code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * <li> The result is small enough to fit into a <code>double</code>. The\n     * largest value of <code>n</code> for which all coefficients are <\n     * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n     * Double.POSITIVE_INFINITY is returned</li>\n     * </ul></p>\n     * \n     * @param n the size of the set\n     * @param k the size of the subsets to be counted\n     * @return <code>n choose k</code>\n     * @throws IllegalArgumentException if preconditions are not met.\n     */\n    public static double binomialCoefficientDouble(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 1d;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return n;\n        }\n        if (k > n/2) {\n            return binomialCoefficientDouble(n, n - k);\n        }\n        if (n < 67) {\n            return binomialCoefficient(n,k);\n        }\n        \n        double result = 1d;\n        for (int i = 1; i <= k; i++) {\n             result *= (double)(n - k + i) / (double)i;\n        }\n  \n        return Math.floor(result + 0.5);\n    }\n    \n    /**\n     * Returns the natural <code>log</code> of the <a\n     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n     * <code>k</code>-element subsets that can be selected from an\n     * <code>n</code>-element set.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>0 <= k <= n </code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * </ul></p>\n     * \n     * @param n the size of the set\n     * @param k the size of the subsets to be counted\n     * @return <code>n choose k</code>\n     * @throws IllegalArgumentException if preconditions are not met.\n     */\n    public static double binomialCoefficientLog(final int n, final int k) {\n        if (n < k) {\n            throw new IllegalArgumentException(\n                \"must have n >= k for binomial coefficient (n,k)\");\n        }\n        if (n < 0) {\n            throw new IllegalArgumentException(\n                \"must have n >= 0 for binomial coefficient (n,k)\");\n        }\n        if ((n == k) || (k == 0)) {\n            return 0;\n        }\n        if ((k == 1) || (k == n - 1)) {\n            return Math.log((double) n);\n        }\n        \n        /*\n         * For values small enough to do exact integer computation,\n         * return the log of the exact value \n         */\n        if (n < 67) {  \n            return Math.log(binomialCoefficient(n,k));\n        }\n        \n        /*\n         * Return the log of binomialCoefficientDouble for values that will not\n         * overflow binomialCoefficientDouble\n         */\n        if (n < 1030) { \n            return Math.log(binomialCoefficientDouble(n, k));\n        } \n\n        if (k > n / 2) {\n            return binomialCoefficientLog(n, n - k);\n        }\n\n        /*\n         * Sum logs for values that could overflow\n         */\n        double logSum = 0;\n\n        // n!/(n-k)!\n        for (int i = n - k + 1; i <= n; i++) {\n            logSum += Math.log((double) i);\n        }\n\n        // divide by k!\n        for (int i = 2; i <= k; i++) {\n            logSum -= Math.log((double) i);\n        }\n\n        return logSum;      \n    }\n    \n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n     * hyperbolic cosine</a> of x.\n     * \n     * @param x double value for which to find the hyperbolic cosine\n     * @return hyperbolic cosine of x\n     */\n    public static double cosh(double x) {\n        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n    }\n    \n    /**\n     * Returns true iff both arguments are NaN or neither is NaN and they are\n     * equal\n     * \n     * @param x first value\n     * @param y second value\n     * @return true if the values are equal or both are NaN\n     */\n    public static boolean equals(double x, double y) {\n        return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);\n    }\n\n    /**\n     * Returns true iff both arguments are equal or within the range of allowed\n     * error (inclusive).\n     * \n     * @param x first value\n     * @param y second value\n     * @param eps the amount of absolute error to allow\n     * @return true if the values are equal or within range of each other\n     */\n    public static boolean equals(double x, double y, double eps) {\n      return x == y || (x < y && (x + eps) >= y) || (x > y && x <= (y + eps));\n    }\n    \n    /**\n     * Returns true iff both arguments are null or have same dimensions\n     * and all their elements are {@link #equals(double,double) equals}\n     * \n     * @param x first array\n     * @param y second array\n     * @return true if the values are both null or have same dimension\n     * and equal elements\n     * @since 1.2\n     */\n    public static boolean equals(double[] x, double[] y) {\n        if ((x == null) || (y == null)) {\n            return !((x == null) ^ (y == null));\n        }\n        if (x.length != y.length) {\n            return false;\n        }\n        for (int i = 0; i < x.length; ++i) {\n            if (!equals(x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    /** All long-representable factorials */\n    private static final long[] factorials = new long[] \n       {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800,\n        479001600, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l,\n        355687428096000l, 6402373705728000l, 121645100408832000l,\n        2432902008176640000l};\n\n    /**\n     * Returns n!. Shorthand for <code>n</code> <a\n     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n     * product of the numbers <code>1,...,n</code>.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>n >= 0</code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * <li> The result is small enough to fit into a <code>long</code>. The\n     * largest value of <code>n</code> for which <code>n!</code> <\n     * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>\n     * an <code>ArithMeticException </code> is thrown.</li>\n     * </ul>\n     * </p>\n     * \n     * @param n argument\n     * @return <code>n!</code>\n     * @throws ArithmeticException if the result is too large to be represented\n     *         by a long integer.\n     * @throws IllegalArgumentException if n < 0\n     */\n    public static long factorial(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n > 20) {\n            throw new ArithmeticException(\n                    \"factorial value is too large to fit in a long\");\n        }\n        return factorials[n];\n    }\n\n    /**\n     * Returns n!. Shorthand for <code>n</code> <a\n     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n     * product of the numbers <code>1,...,n</code> as a <code>double</code>.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>n >= 0</code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * <li> The result is small enough to fit into a <code>double</code>. The\n     * largest value of <code>n</code> for which <code>n!</code> <\n     * Double.MAX_VALUE</code> is 170. If the computed value exceeds\n     * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n     * </ul>\n     * </p>\n     * \n     * @param n argument\n     * @return <code>n!</code>\n     * @throws IllegalArgumentException if n < 0\n     */\n    public static double factorialDouble(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n        }\n        if (n < 21) {\n            return factorial(n);\n        }\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n    }\n\n    /**\n     * Returns the natural logarithm of n!.\n     * <p>\n     * <Strong>Preconditions</strong>:\n     * <ul>\n     * <li> <code>n >= 0</code> (otherwise\n     * <code>IllegalArgumentException</code> is thrown)</li>\n     * </ul></p>\n     * \n     * @param n argument\n     * @return <code>n!</code>\n     * @throws IllegalArgumentException if preconditions are not met.\n     */\n    public static double factorialLog(final int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n        }\n        if (n < 21) {\n            return Math.log(factorial(n));\n        }\n        double logSum = 0;\n        for (int i = 2; i <= n; i++) {\n            logSum += Math.log((double)i);\n        }\n        return logSum;\n    }\n\n    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * Special cases:\n     * <ul>\n     * <li>The invocations\n     * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,\n     * <code>gcd(Integer.MIN_VALUE, 0)</code> and\n     * <code>gcd(0, Integer.MIN_VALUE)</code> throw an\n     * <code>ArithmeticException</code>, because the result would be 2^31, which\n     * is too large for an int value.</li>\n     * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and\n     * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except\n     * for the special cases above.\n     * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns\n     * <code>0</code>.</li>\n     * </ul>\n     * \n     * @param u any number\n     * @param v any number\n     * @return the greatest common divisor, never negative\n     * @throws ArithmeticException\n     *             if the result cannot be represented as a nonnegative int\n     *             value\n     * @since 1.1\n     */\n    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"overflow: gcd({0}, {1}) is 2^31\",\n                    new Object[] { p, q });\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }\n\n    /**\n     * Returns an integer hash code representing the given double value.\n     * \n     * @param value the value to be hashed\n     * @return the hash code\n     */\n    public static int hash(double value) {\n        return new Double(value).hashCode();\n    }\n\n    /**\n     * Returns an integer hash code representing the given double array.\n     * \n     * @param value the value to be hashed (may be null)\n     * @return the hash code\n     * @since 1.2\n     */\n    public static int hash(double[] value) {\n        return Arrays.hashCode(value);\n    }\n\n    /**\n     * For a byte value x, this method returns (byte)(+1) if x >= 0 and\n     * (byte)(-1) if x < 0.\n     * \n     * @param x the value, a byte\n     * @return (byte)(+1) or (byte)(-1), depending on the sign of x\n     */\n    public static byte indicator(final byte x) {\n        return (x >= ZB) ? PB : NB;\n    }\n\n    /**\n     * For a double precision value x, this method returns +1.0 if x >= 0 and\n     * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is\n     * <code>NaN</code>.\n     * \n     * @param x the value, a double\n     * @return +1.0 or -1.0, depending on the sign of x\n     */\n    public static double indicator(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x >= 0.0) ? 1.0 : -1.0;\n    }\n\n    /**\n     * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <\n     * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.\n     * \n     * @param x the value, a float\n     * @return +1.0F or -1.0F, depending on the sign of x\n     */\n    public static float indicator(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x >= 0.0F) ? 1.0F : -1.0F;\n    }\n\n    /**\n     * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.\n     * \n     * @param x the value, an int\n     * @return +1 or -1, depending on the sign of x\n     */\n    public static int indicator(final int x) {\n        return (x >= 0) ? 1 : -1;\n    }\n\n    /**\n     * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.\n     * \n     * @param x the value, a long\n     * @return +1L or -1L, depending on the sign of x\n     */\n    public static long indicator(final long x) {\n        return (x >= 0L) ? 1L : -1L;\n    }\n\n    /**\n     * For a short value x, this method returns (short)(+1) if x >= 0 and\n     * (short)(-1) if x < 0.\n     * \n     * @param x the value, a short\n     * @return (short)(+1) or (short)(-1), depending on the sign of x\n     */\n    public static short indicator(final short x) {\n        return (x >= ZS) ? PS : NS;\n    }\n\n    /**\n     * <p>\n     * Returns the least common multiple of the absolute value of two numbers,\n     * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.\n     * </p>\n     * Special cases:\n     * <ul>\n     * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and\n     * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a\n     * power of 2, throw an <code>ArithmeticException</code>, because the result\n     * would be 2^31, which is too large for an int value.</li>\n     * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is\n     * <code>0</code> for any <code>x</code>.\n     * </ul>\n     * \n     * @param a any number\n     * @param b any number\n     * @return the least common multiple, never negative\n     * @throws ArithmeticException\n     *             if the result cannot be represented as a nonnegative int\n     *             value\n     * @since 1.1\n     */\n    public static int lcm(int a, int b) {\n        if (a==0 || b==0){\n            return 0;\n        }\n        int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n        return lcm;\n    }\n\n    /** \n     * <p>Returns the \n     * <a href=\"http://mathworld.wolfram.com/Logarithm.html\">logarithm</a>\n     * for base <code>b</code> of <code>x</code>.\n     * </p>\n     * <p>Returns <code>NaN<code> if either argument is negative.  If \n     * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.\n     * If <code>base</code> is positive and <code>x</code> is 0, \n     * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments\n     * are 0, the result is <code>NaN</code>.</p>\n     * \n     * @param base the base of the logarithm, must be greater than 0\n     * @param x argument, must be greater than 0\n     * @return the value of the logarithm - the number y such that base^y = x.\n     * @since 1.2\n     */ \n    public static double log(double base, double x) {\n        return Math.log(x)/Math.log(base);\n    }\n\n    /**\n     * Multiply two integers, checking for overflow.\n     * \n     * @param x a factor\n     * @param y a factor\n     * @return the product <code>x*y</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         int\n     * @since 1.1\n     */\n    public static int mulAndCheck(int x, int y) {\n        long m = ((long)x) * ((long)y);\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: mul\");\n        }\n        return (int)m;\n    }\n\n    /**\n     * Multiply two long integers, checking for overflow.\n     * \n     * @param a first value\n     * @param b second value\n     * @return the product <code>a * b</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         long\n     * @since 1.2\n     */\n    public static long mulAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: multiply\";\n        if (a > b) {\n            // use symmetry to reduce boundary cases\n            ret = mulAndCheck(b, a);\n        } else {\n            if (a < 0) {\n                if (b < 0) {\n                    // check for positive overflow with negative a, negative b\n                    if (a >= Long.MAX_VALUE / b) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                    }\n                } else if (b > 0) {\n                    // check for negative overflow with negative a, positive b\n                    if (Long.MIN_VALUE / b <= a) {\n                        ret = a * b;\n                    } else {\n                        throw new ArithmeticException(msg);\n                        \n                    }\n                } else {\n                    // assert b == 0\n                    ret = 0;\n                }\n            } else if (a > 0) {\n                // assert a > 0\n                // assert b > 0\n                \n                // check for positive overflow with positive a, positive b\n                if (a <= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new ArithmeticException(msg);\n                }\n            } else {\n                // assert a == 0\n                ret = 0;\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Get the next machine representable number after a number, moving\n     * in the direction of another number.\n     * <p>\n     * If <code>direction</code> is greater than or equal to<code>d</code>,\n     * the smallest machine representable number strictly greater than\n     * <code>d</code> is returned; otherwise the largest representable number\n     * strictly less than <code>d</code> is returned.</p>\n     * <p>\n     * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>\n     * \n     * @param d base number\n     * @param direction (the only important thing is whether\n     * direction is greater or smaller than d)\n     * @return the next machine representable number in the specified direction\n     * @since 1.2\n     */\n    public static double nextAfter(double d, double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(d) || Double.isInfinite(d)) {\n                return d;\n        } else if (d == 0) {\n                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        // split the double in raw components\n        long bits     = Double.doubleToLongBits(d);\n        long sign     = bits & 0x8000000000000000L;\n        long exponent = bits & 0x7ff0000000000000L;\n        long mantissa = bits & 0x000fffffffffffffL;\n\n        if (d * (direction - d) >= 0) {\n                // we should increase the mantissa\n                if (mantissa == 0x000fffffffffffffL) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent + 0x0010000000000000L));\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa + 1));\n                }\n        } else {\n                // we should decrease the mantissa\n                if (mantissa == 0L) {\n                        return Double.longBitsToDouble(sign |\n                                        (exponent - 0x0010000000000000L) |\n                                        0x000fffffffffffffL);\n                } else {\n                        return Double.longBitsToDouble(sign |\n                                        exponent | (mantissa - 1));\n                }\n        }\n\n    }\n\n    /**\n     * Scale a number by 2<sup>scaleFactor</sup>.\n     * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>\n     * \n     * @param d base number\n     * @param scaleFactor power of two by which d sould be multiplied\n     * @return d &times; 2<sup>scaleFactor</sup>\n     * @since 2.0\n     */\n    public static double scalb(final double d, final int scaleFactor) {\n\n        // handling of some important special cases\n        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n            return d;\n        }\n\n        // split the double in raw components\n        final long bits     = Double.doubleToLongBits(d);\n        final long exponent = bits & 0x7ff0000000000000L;\n        final long rest     = bits & 0x800fffffffffffffL;\n\n        // shift the exponent\n        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n        return Double.longBitsToDouble(newBits);\n\n    }\n\n    /**\n     * Normalize an angle in a 2&pi wide interval around a center value.\n     * <p>This method has three main uses:</p>\n     * <ul>\n     *   <li>normalize an angle between 0 and 2&pi;:<br/>\n     *       <code>a = MathUtils.normalizeAngle(a, Math.PI);</code></li>\n     *   <li>normalize an angle between -&pi; and +&pi;<br/>\n     *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>\n     *   <li>compute the angle between two defining angular positions:<br>\n     *       <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>\n     * </ul>\n     * <p>Note that due to numerical accuracy and since &pi; cannot be represented\n     * exactly, the result interval is <em>closed</em>, it cannot be half-closed\n     * as would be more satisfactory in a purely mathematical view.</p>\n     * @param a angle to normalize\n     * @param center center of the desired 2&pi; interval for the result\n     * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;\n     * @since 1.2\n     */\n     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n     }\n\n    /**\n     * Round the given value to the specified number of decimal places. The\n     * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n     * \n     * @param x the value to round.\n     * @param scale the number of digits to the right of the decimal point.\n     * @return the rounded value.\n     * @since 1.1\n     */\n    public static double round(double x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    /**\n     * Round the given value to the specified number of decimal places. The\n     * value is rounded using the given method which is any method defined in\n     * {@link BigDecimal}.\n     * \n     * @param x the value to round.\n     * @param scale the number of digits to the right of the decimal point.\n     * @param roundingMethod the rounding method as defined in\n     *        {@link BigDecimal}.\n     * @return the rounded value.\n     * @since 1.1\n     */\n    public static double round(double x, int scale, int roundingMethod) {\n        try {\n            return (new BigDecimal\n                   (Double.toString(x))\n                   .setScale(scale, roundingMethod))\n                   .doubleValue();\n        } catch (NumberFormatException ex) {\n            if (Double.isInfinite(x)) {\n                return x;          \n            } else {\n                return Double.NaN;\n            }\n        }\n    }\n\n    /**\n     * Round the given value to the specified number of decimal places. The\n     * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.\n     * \n     * @param x the value to round.\n     * @param scale the number of digits to the right of the decimal point.\n     * @return the rounded value.\n     * @since 1.1\n     */\n    public static float round(float x, int scale) {\n        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n    }\n\n    /**\n     * Round the given value to the specified number of decimal places. The\n     * value is rounded using the given method which is any method defined in\n     * {@link BigDecimal}.\n     * \n     * @param x the value to round.\n     * @param scale the number of digits to the right of the decimal point.\n     * @param roundingMethod the rounding method as defined in\n     *        {@link BigDecimal}.\n     * @return the rounded value.\n     * @since 1.1\n     */\n    public static float round(float x, int scale, int roundingMethod) {\n        float sign = indicator(x);\n        float factor = (float)Math.pow(10.0f, scale) * sign;\n        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n    }\n\n    /**\n     * Round the given non-negative, value to the \"nearest\" integer. Nearest is\n     * determined by the rounding method specified. Rounding methods are defined\n     * in {@link BigDecimal}.\n     * \n     * @param unscaled the value to round.\n     * @param sign the sign of the original, scaled value.\n     * @param roundingMethod the rounding method as defined in\n     *        {@link BigDecimal}.\n     * @return the rounded value.\n     * @since 1.1\n     */\n    private static double roundUnscaled(double unscaled, double sign,\n        int roundingMethod) {\n        switch (roundingMethod) {\n        case BigDecimal.ROUND_CEILING :\n            if (sign == -1) {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            } else {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_DOWN :\n            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            break;\n        case BigDecimal.ROUND_FLOOR :\n            if (sign == -1) {\n                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n            } else {\n                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n            }\n            break;\n        case BigDecimal.ROUND_HALF_DOWN : {\n            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_EVEN : {\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction > 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else if (fraction < 0.5) {\n                unscaled = Math.floor(unscaled);\n            } else {\n                // The following equality test is intentional and needed for rounding purposes\n                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n                    .floor(unscaled) / 2.0)) { // even\n                    unscaled = Math.floor(unscaled);\n                } else { // odd\n                    unscaled = Math.ceil(unscaled);\n                }\n            }\n            break;\n        }\n        case BigDecimal.ROUND_HALF_UP : {\n            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n            double fraction = unscaled - Math.floor(unscaled);\n            if (fraction >= 0.5) {\n                unscaled = Math.ceil(unscaled);\n            } else {\n                unscaled = Math.floor(unscaled);\n            }\n            break;\n        }\n        case BigDecimal.ROUND_UNNECESSARY :\n            if (unscaled != Math.floor(unscaled)) {\n                throw new ArithmeticException(\"Inexact result from rounding\");\n            }\n            break;\n        case BigDecimal.ROUND_UP :\n            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n            break;\n        default :\n            throw new IllegalArgumentException(\"Invalid rounding method.\");\n        }\n        return unscaled;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n     * for byte value <code>x</code>.\n     * <p>\n     * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if\n     * x = 0, and (byte)(-1) if x < 0.</p>\n     * \n     * @param x the value, a byte\n     * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x\n     */\n    public static byte sign(final byte x) {\n        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n     * for double precision <code>x</code>.\n     * <p>\n     * For a double value <code>x</code>, this method returns\n     * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if\n     * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.\n     * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>\n     * \n     * @param x the value, a double\n     * @return +1.0, 0.0, or -1.0, depending on the sign of x\n     */\n    public static double sign(final double x) {\n        if (Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n     * for float value <code>x</code>.\n     * <p>\n     * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =\n     * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>\n     * is <code>NaN</code>.</p>\n     * \n     * @param x the value, a float\n     * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x\n     */\n    public static float sign(final float x) {\n        if (Float.isNaN(x)) {\n            return Float.NaN;\n        }\n        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n     * for int value <code>x</code>.\n     * <p>\n     * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1\n     * if x < 0.</p>\n     * \n     * @param x the value, an int\n     * @return +1, 0, or -1, depending on the sign of x\n     */\n    public static int sign(final int x) {\n        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n     * for long value <code>x</code>.\n     * <p>\n     * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and\n     * -1L if x < 0.</p>\n     * \n     * @param x the value, a long\n     * @return +1L, 0L, or -1L, depending on the sign of x\n     */\n    public static long sign(final long x) {\n        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n     * for short value <code>x</code>.\n     * <p>\n     * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)\n     * if x = 0, and (short)(-1) if x < 0.</p>\n     * \n     * @param x the value, a short\n     * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of\n     *         x\n     */\n    public static short sign(final short x) {\n        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n    }\n\n    /**\n     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\">\n     * hyperbolic sine</a> of x.\n     * \n     * @param x double value for which to find the hyperbolic sine\n     * @return hyperbolic sine of x\n     */\n    public static double sinh(double x) {\n        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n    }\n\n    /**\n     * Subtract two integers, checking for overflow.\n     * \n     * @param x the minuend\n     * @param y the subtrahend\n     * @return the difference <code>x-y</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         int\n     * @since 1.1\n     */\n    public static int subAndCheck(int x, int y) {\n        long s = (long)x - (long)y;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"overflow: subtract\");\n        }\n        return (int)s;\n    }\n\n    /**\n     * Subtract two long integers, checking for overflow.\n     * \n     * @param a first value\n     * @param b second value\n     * @return the difference <code>a-b</code>\n     * @throws ArithmeticException if the result can not be represented as an\n     *         long\n     * @since 1.2\n     */\n    public static long subAndCheck(long a, long b) {\n        long ret;\n        String msg = \"overflow: subtract\";\n        if (b == Long.MIN_VALUE) {\n            if (a < 0) {\n                ret = a - b;\n            } else {\n                throw new ArithmeticException(msg);\n            }\n        } else {\n            // use additive inverse\n            ret = addAndCheck(a, -b, msg);\n        }\n        return ret;\n    }\n\n}\n", "review": {"response": "Based on the provided Java code, here are some potential issues and \"bugs\":\n\n1. **Unused variables and methods**: There are several static final variables (like `NB`, `NS`, `PB`, `PS`, `ZB`, `ZS`, and `TWO_PI`) and a private constructor that are never used in the code. These can be safely removed to reduce the size of the class.\n\n2. **Unused import**: The import statement for `org.apache.commons.math.MathRuntimeException` is not used in the code. It can be removed.\n\n3. **Unused or poorly documented methods**: The method `addAndCheck(int x, int y)` is documented as adding two integers and checking for overflow, but it never throws an `ArithmeticException` even when overflow occurs. It seems to be a duplicate of `addAndCheck(long a, long b)`, which handles overflow correctly. The first method can be removed or its behavior should be consistent with the second method.\n\n4. **Potential precision loss**: In the `binomialCoefficient` method, the calculation is done using `long` data type. If the result exceeds the maximum value of `long`, an `ArithmeticException` is thrown. However, if `n` and `k` are large enough, the result might exceed `Long.MAX_VALUE` but still fit within `BigInteger` range. To handle this, consider using `BigInteger` for the calculation.\n\n5. **Lack of input validation**: In the `binomialCoefficient` method, the input validation only checks if `n >= k` and `n >= 0`. It might be useful to add checks for `k >= 0` and `n < Integer.MAX_VALUE - k` to ensure the result can fit into a `long`.\n\nHere's an updated version of the `binomialCoefficient` method with the suggested improvements:\n\n```java\nimport java.math.BigInteger;\n\n/**\n * Returns an exact representation of the Binomial Coefficient, \"n choose k\".\n * ...\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return n choose k\n * @throws IllegalArgumentException if preconditions are not met.\n */\npublic static BigInteger binomialCoefficient(final int n, final int k) {\n    if (n < 0 || k < 0 || n < k || n > Integer.MAX_VALUE - k) {\n        throw new IllegalArgumentException(\"Invalid arguments for binomial coefficient (n, k)\");\n    }\n    BigInteger result = BigInteger.ONE;\n    for (int i = 0; i < k; i++) {\n        result = result.multiply(BigInteger.valueOf(n - i)).divide(BigInteger.valueOf(i + 1));\n    }\n    return result;\n}\n```\n\nThis version uses `BigInteger` for the calculation, adds input validation for `k >= 0` and `n < Integer.MAX_VALUE - k`, and throws a more descriptive exception message."}}