{
  "source_item_id": 7956,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:56:48.299675",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.math;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.math.MathPreconditions.checkNoOverflow;\nimport static com.google.common.math.MathPreconditions.checkNonNegative;\nimport static com.google.common.math.MathPreconditions.checkPositive;\nimport static com.google.common.math.MathPreconditions.checkRoundingUnnecessary;\nimport static java.lang.Math.abs;\nimport static java.lang.Math.min;\nimport static java.math.RoundingMode.HALF_EVEN;\nimport static java.math.RoundingMode.HALF_UP;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.primitives.UnsignedLongs;\nimport com.google.errorprone.annotations.InlineMe;\nimport java.math.BigInteger;\nimport java.math.RoundingMode;\n\n/**\n * A class for arithmetic on values of type {@code long}. Where possible, methods are defined and\n * named analogously to their {@code BigInteger} counterparts.\n *\n * <p>The implementations of many methods in this class are based on material from Henry S. Warren,\n * Jr.'s <i>Hacker's Delight</i>, (Addison Wesley, 2002).\n *\n * <p>Similar functionality for {@code int} and for {@link BigInteger} can be found in {@link\n * IntMath} and {@link BigIntegerMath} respectively. For other common operations on {@code long}\n * values, see {@link com.google.common.primitives.Longs}.\n *\n * @author Louis Wasserman\n * @since 11.0\n */\n@GwtCompatible\npublic final class LongMath {\n  @VisibleForTesting static final long MAX_SIGNED_POWER_OF_TWO = 1L << (Long.SIZE - 2);\n\n  /**\n   * Returns the smallest power of two greater than or equal to {@code x}. This is equivalent to\n   * {@code checkedPow(2, log2(x, CEILING))}.\n   *\n   * @throws IllegalArgumentException if {@code x <= 0}\n   * @throws ArithmeticException of the next-higher power of two is not representable as a {@code\n   *     long}, i.e. when {@code x > 2^62}\n   * @since 20.0\n   */\n  public static long ceilingPowerOfTwo(long x) {\n    checkPositive(\"x\", x);\n    if (x > MAX_SIGNED_POWER_OF_TWO) {\n      throw new ArithmeticException(\"ceilingPowerOfTwo(\" + x + \") is not representable as a long\");\n    }\n    return 1L << -Long.numberOfLeadingZeros(x - 1);\n  }\n\n  /**\n   * Returns the largest power of two less than or equal to {@code x}. This is equivalent to {@code\n   * checkedPow(2, log2(x, FLOOR))}.\n   *\n   * @throws IllegalArgumentException if {@code x <= 0}\n   * @since 20.0\n   */\n  public static long floorPowerOfTwo(long x) {\n    checkPositive(\"x\", x);\n\n    // Long.highestOneBit was buggy on GWT.  We've fixed it, but I'm not certain when the fix will\n    // be released.\n    return 1L << ((Long.SIZE - 1) - Long.numberOfLeadingZeros(x));\n  }\n\n  /**\n   * Returns {@code true} if {@code x} represents a power of two.\n   *\n   * <p>This differs from {@code Long.bitCount(x) == 1}, because {@code\n   * Long.bitCount(Long.MIN_VALUE) == 1}, but {@link Long#MIN_VALUE} is not a power of two.\n   */\n  // Whenever both tests are cheap and functional, it's faster to use &, | instead of &&, ||\n  @SuppressWarnings(\"ShortCircuitBoolean\")\n  public static boolean isPowerOfTwo(long x) {\n    return x > 0 & (x & (x - 1)) == 0;\n  }\n\n  /**\n   * Returns 1 if {@code x < y} as unsigned longs, and 0 otherwise. Assumes that x - y fits into a\n   * signed long. The implementation is branch-free, and benchmarks suggest it is measurably faster\n   * than the straightforward ternary expression.\n   */\n  @VisibleForTesting\n  static int lessThanBranchFree(long x, long y) {\n    // Returns the sign bit of x - y.\n    return (int) (~~(x - y) >>> (Long.SIZE - 1));\n  }\n\n  /**\n   * Returns the base-2 logarithm of {@code x}, rounded according to the specified rounding mode.\n   *\n   * @throws IllegalArgumentException if {@code x <= 0}\n   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n   *     is not a power of two\n   */\n  @SuppressWarnings(\"fallthrough\")\n  // TODO(kevinb): remove after this warning is disabled globally\n  public static int log2(long x, RoundingMode mode) {\n    checkPositive(\"x\", x);\n    switch (mode) {\n      case UNNECESSARY:\n        checkRoundingUnnecessary(isPowerOfTwo(x));\n      // fall through\n      case DOWN:\n      case FLOOR:\n        return (Long.SIZE - 1) - Long.numberOfLeadingZeros(x);\n\n      case UP:\n      case CEILING:\n        return Long.SIZE - Long.numberOfLeadingZeros(x - 1);\n\n      case HALF_DOWN:\n      case HALF_UP:\n      case HALF_EVEN:\n        // Since sqrt(2) is irrational, log2(x) - logFloor cannot be exactly 0.5\n        int leadingZeros = Long.numberOfLeadingZeros(x);\n        long cmp = MAX_POWER_OF_SQRT2_UNSIGNED >>> leadingZeros;\n        // floor(2^(logFloor + 0.5))\n        int logFloor = (Long.SIZE - 1) - leadingZeros;\n        return logFloor + lessThanBranchFree(cmp, x);\n    }\n    throw new AssertionError(\"impossible\");\n  }\n\n  /** The biggest half power of two that fits into an unsigned long */\n  @VisibleForTesting static final long MAX_POWER_OF_SQRT2_UNSIGNED = 0xB504F333F9DE6484L;\n\n  /**\n   * Returns the base-10 logarithm of {@code x}, rounded according to the specified rounding mode.\n   *\n   * @throws IllegalArgumentException if {@code x <= 0}\n   * @throws ArithmeticException if {@code mode} is {@link RoundingMode#UNNECESSARY} and {@code x}\n   *     is not a power of ten\n   */\n  @GwtIncompatible // TODO\n  @SuppressWarnings(\"fallthrough\")\n  // TODO(kevinb): remove after this warning is disabled globally\n  public static int log10(long x, RoundingMode mode) {\n    checkPositive(\"x\", x);\n    int logFloor = log10Floor(x);\n    long floorPow = powersOf10[logFloor];\n    switch (mode) {\n      case UNNECESSARY:\n        checkRoundingUnnecessary(x == floorPow);\n      // fall through\n      case FLOOR:\n      case DOWN:\n        return logFloor;\n      case CEILING:\n      case UP:\n        return logFloor + lessThanBranchFree(floorPow, x);\n      case HALF_DOWN:\n      case HALF_UP:\n      case HALF_EVEN:\n        // sqrt(10) is irrational, so log10(x)-logFloor is never exactly 0.5\n        return logFloor + lessThanBranchFree(halfPowersOf10[logFloor], x);\n    }\n    throw new AssertionError();\n  }\n\n  @GwtIncompatible // TODO\n  static int log10Floor(long x) {\n    /*\n     * Based on Hacker's Delight Fig. 11-5, the two-table-lookup, branch-free implementation.\n     *\n     * The key idea is that based on the number of leading zeros (equivalently, floor(log2(x))), we\n     * can narrow the possible floor(log10(x)) values to two. For example, if floor(log2(x)) is 6,\n     * then 64 <= x < 128, so floor(log10(x)) is either 1 or 2.\n     */\n    int y = maxLog10ForLeadingZeros[Long.numberOfLeadingZeros(x)];\n    /*\n     * y is the higher of the two possible values of floor(log10(x)). If x < 10^y, then we want the\n     * lower of the two possible values, or y - 1, otherwise, we want y.\n     */\n    return y - lessThanBranchFree(x, powersOf10[y]);\n  }\n\n  // maxLog10ForLeadingZeros[i] == floor(log10(2^(Long.SIZE - i)))\n  @VisibleForTesting\n  static final byte[] maxLog10ForLeadingZeros = {\n    19, 18, 18, 18, 18, 17, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 13, 13, 13, 12, 12, 12,\n    12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3,\n    3, 2, 2, 2, ",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The checkArgument function is not sufficient to handle the case where x > MAX_SIGNED_POWER_OF_TWO. This is because the checkArgument function only checks if the argument is within a certain range, but it does not check if the argument is representable as a long.\",\n         \"suggested_fix\": \"Replace the checkArgument function with a check that also checks if x is representable as a long.\"\n      },\n      {\n         \"explanation\": \"The lessThanBranchFree function does not handle the case where x and y are both negative. This is because the function assumes that x and y are both positive.\",\n         \"suggested_fix\": \"Add a check to handle the case where x and y are both negative.\"\n      },\n      {\n         \"explanation\": \"The log2 function does not handle the case where x is a power of two and mode is UNNECESSARY. This is because the function does not check if x is a power of two before calling checkRoundingUnnecessary.\",\n         \"suggested_fix\": \"Add a check to handle the case where x is a power of two and mode is UNNECESSARY.\"\n      },\n      {\n         \"explanation\": \"The log10 function does not handle the case where x is a power of ten and mode is UNNECESSARY. This is because the function does not check if x is a power of ten before calling checkRoundingUnnecessary.\",\n         \"suggested_fix\": \"Add a check to handle the case where x is a power of ten and mode is UNNECESSARY.\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs found.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The checkArgument function is not sufficient to handle the case where x > MAX_SIGNED_POWER_OF_TWO. This is because the checkArgument function only checks if the argument is within a certain range, but it does not check if the argument is representable as a long.",
        "suggested_fix": "Replace the checkArgument function with a check that also checks if x is representable as a long."
      },
      {
        "explanation": "The lessThanBranchFree function does not handle the case where x and y are both negative. This is because the function assumes that x and y are both positive.",
        "suggested_fix": "Add a check to handle the case where x and y are both negative."
      },
      {
        "explanation": "The log2 function does not handle the case where x is a power of two and mode is UNNECESSARY. This is because the function does not check if x is a power of two before calling checkRoundingUnnecessary.",
        "suggested_fix": "Add a check to handle the case where x is a power of two and mode is UNNECESSARY."
      },
      {
        "explanation": "The log10 function does not handle the case where x is a power of ten and mode is UNNECESSARY. This is because the function does not check if x is a power of ten before calling checkRoundingUnnecessary.",
        "suggested_fix": "Add a check to handle the case where x is a power of ten and mode is UNNECESSARY."
      }
    ],
    "no_bugs_reasoning": "No bugs found."
  },
  "error": null
}