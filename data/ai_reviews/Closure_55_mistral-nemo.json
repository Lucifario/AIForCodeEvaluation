{"sample_id": "Closure_55", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2009 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Multimap;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Reduces the size of common function expressions.\n *\n * This pass will rewrite:\n *\n * C.prototype.getA = function() { return this.a_ };\n * C.prototype.setA = function(newValue) { this.a_ = newValue };\n *\n * as:\n *\n * C.prototype.getA = JSCompiler_get(\"a_);\n * C.prototype.setA = JSCompiler_set(\"a_);\n *\n * if by doing so we will save bytes, after the helper functions are\n * added and renaming is done.\n *\n */\nclass FunctionRewriter implements CompilerPass {\n  private final AbstractCompiler compiler;\n  // Safety margin used to avoid growing simple programs by a few bytes.\n  // Selected arbitrarily.\n  private static final int SAVINGS_THRESHOLD = 16;\n\n  FunctionRewriter(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(),\n                                              new GetterReducer(),\n                                              new SetterReducer(),\n                                              new EmptyFunctionReducer(),\n                                              new IdentityReducer());\n\n    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();\n\n    // Accumulate possible reductions in the reduction multi map.  They\n    // will be applied in the loop below.\n    NodeTraversal.traverse(compiler, root,\n                           new ReductionGatherer(reducers, reductionMap));\n\n    // Apply reductions iff they will provide some savings.\n    for (Reducer reducer : reducers) {\n      Collection<Reduction> reductions = reductionMap.get(reducer);\n      if (reductions.isEmpty()) {\n        continue;\n      }\n\n      Node helperCode = parseHelperCode(reducer);\n      if (helperCode == null) {\n        continue;\n      }\n\n      int helperCodeCost = InlineCostEstimator.getCost(helperCode);\n\n      // Estimate savings\n      int savings = 0;\n      for (Reduction reduction : reductions) {\n        savings += reduction.estimateSavings();\n      }\n\n      // Compare estimated savings against the helper cost.  Apply\n      // reductions if doing so will result in some savings.\n      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {\n        for (Reduction reduction : reductions) {\n          reduction.apply();\n        }\n\n        Node addingRoot = compiler.getNodeForCodeInsertion(null);\n        addingRoot.addChildrenToFront(helperCode);\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  /**\n   * Parse helper code needed by a reducer.\n   *\n   * @return Helper code root.  If parse fails, return null.\n   */\n  public Node parseHelperCode(Reducer reducer) {\n    Node root = compiler.parseSyntheticCode(\n        reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n    return (root != null) ? root.removeFirstChild() : null;\n  }\n\n  private static boolean isReduceableFunctionExpression(Node n) {\n    return NodeUtil.isFunctionExpression(n);\n  }\n\n  /**\n   * Information needed to apply a reduction.\n   */\n  private class Reduction {\n    private final Node parent;\n    private final Node oldChild;\n    private final Node newChild;\n\n    Reduction(Node parent, Node oldChild, Node newChild) {\n      this.parent = parent;\n      this.oldChild = oldChild;\n      this.newChild = newChild;\n    }\n\n    /**\n     * Apply the reduction by replacing the old child with the new child.\n     */\n    void apply() {\n      parent.replaceChild(oldChild, newChild);\n      compiler.reportCodeChange();\n    }\n\n    /**\n     * Estimate number of bytes saved by applying this reduction.\n     */\n    int estimateSavings() {\n      return InlineCostEstimator.getCost(oldChild) -\n          InlineCostEstimator.getCost(newChild);\n    }\n  }\n\n  /**\n   * Gathers a list of reductions to apply later by doing an in-order\n   * AST traversal.  If a suitable reduction is found, stop traversal\n   * in that branch.\n   */\n  private class ReductionGatherer implements Callback {\n    private final List<Reducer> reducers;\n    private final Multimap<Reducer, Reduction> reductions;\n\n    /**\n     * @param reducers List of reducers to apply during traversal.\n     * @param reductions Reducer -> Reduction multimap,\n     *                   populated during traversal.\n     */\n    ReductionGatherer(List<Reducer> reducers,\n                      Multimap<Reducer, Reduction> reductions) {\n      this.reducers = reducers;\n      this.reductions = reductions;\n    }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal raversal,\n                                  Node node,\n                                  Node parent) {\n      for (Reducer reducer : reducers) {\n        Node replacement = reducer.reduce(node);\n        if (replacement != node) {\n          reductions.put(reducer, new Reduction(parent, node, replacement));\n          return false;\n        }\n      }\n      return true;\n    }\n\n\n    @Override\n    public void visit(NodeTraversal traversal, Node node, Node parent) {\n    }\n  }\n\n  /**\n   * Interface implemented by the strength-reduction optimizers below.\n   */\n  abstract static class Reducer {\n    /**\n     * @return js source for helper methods used by this reduction.\n     */\n    abstract String getHelperSource();\n\n    /**\n     * @return root of the reduced subtree if a reduction was applied;\n     *         otherwise returns the node argument.\n     */\n    abstract Node reduce(Node node);\n\n    /**\n     * Builds a method call based on the the given method name,\n     * argument and history.\n     *\n     * @param methodName Method to call.\n     * @param argumentNode Method argument.\n     * @param lineno line number in original source.\n     * @param charno character offset in original line.\n     */\n    protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       int lineno, int charno) {\n      Node call = new Node(Token.CALL, lineno, charno);\n      call.putBooleanProp(Node.FREE_CALL, true);\n      call.addChildToBack(Node.newString(Token.NAME, methodName));\n      if (argumentNode != null) {\n        call.addChildToBack(argumentNode.cloneTree());\n      }\n      return call;\n    }\n  }\n\n  /**\n   * Reduces return immutable constant literal methods declarations\n   * with calls to a constant return method factory.\n   *\n   * Example:\n   *   a.prototype.b = function() {}\n   * is reduced to:\n   *   a.prototype.b = emptyFn();\n   */\n  private static class EmptyFunctionReducer extends Reducer {\n    static final String FACTORY_METHOD_NAME = \"JSCompiler_emptyFn\";\n    static final String HELPER_SOURCE =\n        \"function \" + FACTORY_METHOD_NAME + \"() {\" +\n        \"  return function() {}\" +\n        \"}\";\n\n    @Override\n    public String getHelperSource() {\n      return HELPER_SOURCE;\n    }\n\n    @Override\n    public Node reduce(Node node) {\n      if (NodeUtil.isEmptyFunctionExpression(node)) {\n        return buildCallNode(FACTORY_METHOD_NAME, null,\n                             node.getLineno(), node.getCharno());\n      } else {\n        return node;\n      }\n    }\n  }\n\n  /**\n   * Base class for reducers that match functions that contain a\n   * single return statement.\n   */\n  abstract static class SingleReturnStatementReducer extends Reducer {\n\n    /**\n     * @return function return value node if function body contains a\n     * single return statement.  Otherwise, null.\n     */\n    protected final Node maybeGetSingleReturnRValue(Node functionNode) {\n      Node body = functionNode.getLastChild();\n      if (!body.hasOneChild()) {\n        return null;\n      }\n\n      Node statement = body.getFirstChild();\n      if (statement.getType() == Token.RETURN) {\n        return statement.getFirstChild();\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Reduces property getter method declarations with calls to a\n   * getter method factory.\n   *\n   * Example:\n   *   a.prototype.b = function(a) {return a}\n   * is reduced to:\n   *   a.prototype.b = getter(a);\n   */\n  private static class IdentityReducer extends SingleReturnStatementReducer {\n    static final String FACTORY_METHOD_NAME = \"JSCompiler_identityFn\";\n    static final String HELPER_SOURCE =\n        \"function \" + FACTORY_METHOD_NAME + \"() {\" +\n        \"  return function(\" + FACTORY_METHOD_NAME + \"_value) {\" +\n             \"return \" + FACTORY_METHOD_NAME + \"_value}\" +\n        \"}\";\n\n    @Override\n    public String getHelperSource() {\n      return HELPER_SOURCE;\n    }\n\n    @Override\n    public Node reduce(Node node) {\n      if (!isReduceableFunctionExpression(node)) {\n        return node;\n      }\n\n      if (isIdentityFunction(node)) {\n        return buildCallNode(FACTORY_METHOD_NAME, null,\n                             node.getLineno(), node.getCharno());\n      } else {\n        return node;\n      }\n    }\n\n    /**\n     * Checks if the function matches the pattern:\n     *   function(<value>, <rest>) {return <value>}\n     *\n     * @return Whether the function matches the pattern.\n     */\n    private boolean isIdentityFunction(Node functionNode) {\n      Node argList = functionNode.getFirstChild().getNext();\n      Node paramNode = argList.getFirstChild();\n      if (paramNode == null) {\n        return false;\n      }\n\n      Node value = maybeGetSingleReturnRValue(functionNode);\n      if (value != null &&\n          NodeUtil.isName(value) &&\n          value.getString().equals(paramNode.getString())) {\n        return true;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Reduces return immutable constant literal methods declarations\n   * with calls to a constant return method factory.\n   *\n   * Example:\n   *   a.prototype.b = function() {return 10}\n   * is reduced to:\n   *   a.prototype.b = returnconst(10);\n   */\n  private static class ReturnConstantReducer\n      extends SingleReturnStatementReducer {\n    static final String FACTORY_METHOD_NAME = \"JSCompiler_returnArg\";\n    static final String HELPER_SOURCE =\n        \"function \" + FACTORY_METHOD_NAME +\n        \"(\" + FACTORY_METHOD_NAME + \"_value) {\" +\n        \"  return function() {return \" + FACTORY_METHOD_NAME + \"_value}\" +\n        \"}\";\n\n    @Override\n    public String getHelperSource() {\n      return HELPER_SOURCE;\n    }\n\n    @Override\n    public Node reduce(Node node) {\n      if (!isReduceableFunctionExpression(node)) {\n        return node;\n      }\n\n      Node valueNode = getValueNode(node);\n      if (valueNode != null) {\n        return buildCallNode(FACTORY_METHOD_NAME, valueNode,\n                             node.getLineno(), node.getCharno());\n      } else {\n        return node;\n      }\n    }\n\n    /**\n     * Checks if the function matches the pattern:\n     *   function(<args>) {return <immutable value>}\n     * and returns <immutable value> if a match is found.\n     *\n     * @return the immutable value node; or null.\n     */\n    private Node getValueNode(Node functionNode) {\n      Node value = maybeGetSingleReturnRValue(functionNode);\n      if (value != null &&\n          NodeUtil.isImmutableValue(value)) {\n        return value;\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Reduces property getter method declarations with calls to a\n   * getter method factory.\n   *\n   * Example:\n   *   a.prototype.b = function() {return this.b_}\n   * is reduced to:\n   *   a.prototype.b = getter(\"b_\");\n   */\n  private static class GetterReducer extends SingleReturnStatementReducer {\n    static final String FACTORY_METHOD_NAME = \"JSCompiler_get\";\n    static final String HELPER_SOURCE =\n        \"function \" + FACTORY_METHOD_NAME + \"(\" +\n        FACTORY_METHOD_NAME + \"_name) {\" +\n        \"  return function() {return this[\" + FACTORY_METHOD_NAME + \"_name]}\" +\n        \"}\";\n\n    @Override\n    public String getHelperSource() {\n      return HELPER_SOURCE;\n    }\n\n    @Override\n    public Node reduce(Node node) {\n      if (!isReduceableFunctionExpression(node)) {\n        return node;\n      }\n\n      Node propName = getGetPropertyName(node);\n      if (propName != null) {\n        if (propName.getType() != Token.STRING) {\n          throw new IllegalStateException(\n              \"Expected STRING, got \" + Token.name(propName.getType()));\n        }\n\n        return buildCallNode(FACTORY_METHOD_NAME, propName,\n                             node.getLineno(), node.getCharno());\n      } else {\n        return node;\n      }\n    }\n\n    /**\n     * Checks if the function matches the pattern:\n     *   function(<args>) {return this.<name>}\n     * and returns <name> if a match is found.\n     *\n     * @return STRING node that is the rhs of a this property get; or null.\n     */\n    private Node getGetPropertyName(Node functionNode) {\n      Node value = maybeGetSingleReturnRValue(functionNode);\n      if (value != null &&\n          NodeUtil.isGetProp(value) &&\n          NodeUtil.isThis(value.getFirstChild())) {\n        return value.getLastChild();\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Reduces property setter method declarations with calls to a\n   * setter method factory.\n   *\n   * Example:\n   *   a.prototype.setB = function(value) {this.b_ = value}\n   * reduces to:\n   *   a.prototype.setB = getter(\"b_\");\n   */\n  private static class SetterReducer extends Reducer {\n    static final String FACTORY_METHOD_NAME = \"JSCompiler_set\";\n    static final String HELPER_SOURCE =\n        \"function \" + FACTORY_METHOD_NAME + \"(\" +\n        FACTORY_METHOD_NAME + \"_name) {\" +\n        \"  return function(\" + FACTORY_METHOD_NAME + \"_value) {\" +\n        \"this[\" + FACTORY_METHOD_NAME + \"_name] = \" +\n        FACTORY_METHOD_NAME + \"_value}\" +\n        \"}\";\n\n    @Override\n    public String getHelperSource() {\n      return HELPER_SOURCE;\n    }\n\n    @Override\n    public Node reduce(Node node) {\n      if (!isReduceableFunctionExpression(node)) {\n        return node;\n      }\n\n      Node propName = getSetPropertyName(node);\n      if (propName != null) {\n        if (propName.getType() != Token.STRING) {\n          throw new IllegalStateException(\n              \"Expected STRING, got \" + Token.name(propName.getType()));\n        }\n\n        return buildCallNode(FACTORY_METHOD_NAME, propName,\n                             node.getLineno(), node.getCharno());\n      } else {\n        return node;\n      }\n    }\n\n    /**\n     * Checks if the function matches the pattern:\n     *   function(<value>, <rest>) {this.<name> = <value>}\n     * and returns <name> if a match is found.\n     *\n     * @return STRING node that is the rhs of a this property get; or null.\n     */\n    private Node getSetPropertyName(Node functionNode) {\n      Node body = functionNode.getLastChild();\n      if (!body.hasOneChild()) {\n        return null;\n      }\n\n      Node argList = functionNode.getFirstChild().getNext();\n      Node paramNode = argList.getFirstChild();\n      if (paramNode == null) {\n        return null;\n      }\n\n      Node statement = body.getFirstChild();\n      if (!NodeUtil.isExprAssign(statement)) {\n        return null;\n      }\n\n      Node assign = statement.getFirstChild();\n      Node lhs = assign.getFirstChild();\n      if (NodeUtil.isGetProp(lhs) && NodeUtil.isThis(lhs.getFirstChild())) {\n        Node rhs = assign.getLastChild();\n        if (NodeUtil.isName(rhs) &&\n            rhs.getString().equals(paramNode.getString())) {\n          Node propertyName = lhs.getLastChild();\n          return propertyName;\n        }\n      }\n      return null;\n    }\n  }\n}\n", "review": {"response": "{ \"bugs\": [] }"}}