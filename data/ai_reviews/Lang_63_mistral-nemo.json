{"sample_id": "Lang_63", "model": "mistral-nemo", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang.time;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.TimeZone;\n\n/**\n * <p>Duration formatting utilities and constants. The following table describes the tokens \n * used in the pattern language for formatting. </p>\n * <table border=\"1\">\n *  <tr><th>character</th><th>duration element</th></tr>\n *  <tr><td>y</td><td>years</td></tr>\n *  <tr><td>M</td><td>months</td></tr>\n *  <tr><td>d</td><td>days</td></tr>\n *  <tr><td>H</td><td>hours</td></tr>\n *  <tr><td>m</td><td>minutes</td></tr>\n *  <tr><td>s</td><td>seconds</td></tr>\n *  <tr><td>S</td><td>milliseconds</td></tr>\n * </table>\n *\n * @author Apache Ant - DateUtils\n * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n * @author Stephen Colebourne\n * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n * @author Henri Yandell\n * @since 2.1\n * @version $Id$\n */\npublic class DurationFormatUtils {\n\n    /**\n     * <p>DurationFormatUtils instances should NOT be constructed in standard programming.</p>\n     *\n     * <p>This constructor is public to permit tools that require a JavaBean instance\n     * to operate.</p>\n     */\n    public DurationFormatUtils() {\n        super();\n    }\n\n    /**\n     * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n     * for the ISO8601 period format used in durations.</p>\n     * \n     * @see org.apache.commons.lang.time.FastDateFormat\n     * @see java.text.SimpleDateFormat\n     */\n    public static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\";\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Formats the time gap as a string.</p>\n     * \n     * <p>The format used is ISO8601-like:\n     * <i>H</i>:<i>m</i>:<i>s</i>.<i>S</i>.</p>\n     * \n     * @param durationMillis  the duration to format\n     * @return the time as a String\n     */\n    public static String formatDurationHMS(long durationMillis) {\n        return formatDuration(durationMillis, \"H:mm:ss.SSS\");\n    }\n\n    /**\n     * <p>Formats the time gap as a string.</p>\n     * \n     * <p>The format used is the ISO8601 period format.</p>\n     * \n     * <p>This method formats durations using the days and lower fields of the\n     * ISO format pattern, such as P7D6TH5M4.321S.</p>\n     * \n     * @param durationMillis  the duration to format\n     * @return the time as a String\n     */\n    public static String formatDurationISO(long durationMillis) {\n        return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);\n    }\n\n    /**\n     * <p>Formats the time gap as a string, using the specified format, and padding with zeros and \n     * using the default timezone.</p>\n     * \n     * <p>This method formats durations using the days and lower fields of the\n     * format pattern. Months and larger are not used.</p>\n     * \n     * @param durationMillis  the duration to format\n     * @param format  the way in which to format the duration\n     * @return the time as a String\n     */\n    public static String formatDuration(long durationMillis, String format) {\n        return formatDuration(durationMillis, format, true);\n    }\n\n    /**\n     * <p>Formats the time gap as a string, using the specified format.\n     * Padding the left hand side of numbers with zeroes is optional and \n     * the timezone may be specified.</p>\n     * \n     * <p>This method formats durations using the days and lower fields of the\n     * format pattern. Months and larger are not used.</p>\n     * \n     * @param durationMillis  the duration to format\n     * @param format  the way in which to format the duration\n     * @param padWithZeros  whether to pad the left hand side of numbers with 0's\n     * @return the time as a String\n     */\n    public static String formatDuration(long durationMillis, String format, boolean padWithZeros) {\n\n        Token[] tokens = lexx(format);\n\n        int days         = 0;\n        int hours        = 0;\n        int minutes      = 0;\n        int seconds      = 0;\n        int milliseconds = 0;\n        \n        if (Token.containsTokenWithValue(tokens, d) ) {\n            days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);\n            durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);\n        }\n        if (Token.containsTokenWithValue(tokens, H) ) {\n            hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);\n            durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);\n        }\n        if (Token.containsTokenWithValue(tokens, m) ) {\n            minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);\n            durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);\n        }\n        if (Token.containsTokenWithValue(tokens, s) ) {\n            seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);\n            durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);\n        }\n        if (Token.containsTokenWithValue(tokens, S) ) {\n            milliseconds = (int) durationMillis;\n        }\n\n        return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n\n    /**\n     * <p>Formats an elapsed time into a plurialization correct string.</p>\n     * \n     * <p>This method formats durations using the days and lower fields of the\n     * format pattern. Months and larger are not used.</p>\n     * \n     * @param durationMillis  the elapsed time to report in milliseconds\n     * @param suppressLeadingZeroElements  suppresses leading 0 elements\n     * @param suppressTrailingZeroElements  suppresses trailing 0 elements\n     * @return the formatted text in days/hours/minutes/seconds\n     */\n    public static String formatDurationWords(\n        long durationMillis,\n        boolean suppressLeadingZeroElements,\n        boolean suppressTrailingZeroElements) {\n\n        // This method is generally replacable by the format method, but \n        // there are a series of tweaks and special cases that require \n        // trickery to replicate.\n        String duration = formatDuration(durationMillis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n        if (suppressLeadingZeroElements) {\n            // this is a temporary marker on the front. Like ^ in regexp.\n            duration = \" \" + duration;\n            String tmp = StringUtils.replaceOnce(duration, \" 0 days\", \"\");\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n                if (tmp.length() != duration.length()) {\n                    duration = tmp;\n                    tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n                    duration = tmp;\n                    if (tmp.length() != duration.length()) {\n                        duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", \"\");\n                    }\n                }\n            }\n            if (duration.length() != 0) {\n                // strip the space off again\n                duration = duration.substring(1);\n            }\n        }\n        if (suppressTrailingZeroElements) {\n            String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", \"\");\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n                if (tmp.length() != duration.length()) {\n                    duration = tmp;\n                    tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n                    if (tmp.length() != duration.length()) {\n                        duration = StringUtils.replaceOnce(tmp, \" 0 days\", \"\");\n                    }\n                }\n            }\n        }\n        // handle plurals\n        duration = \" \" + duration;\n        duration = StringUtils.replaceOnce(duration, \" 1 seconds\", \" 1 second\");\n        duration = StringUtils.replaceOnce(duration, \" 1 minutes\", \" 1 minute\");\n        duration = StringUtils.replaceOnce(duration, \" 1 hours\", \" 1 hour\");\n        duration = StringUtils.replaceOnce(duration, \" 1 days\", \" 1 day\");\n        return duration.trim();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Formats the time gap as a string.</p>\n     * \n     * <p>The format used is the ISO8601 period format.</p>\n     * \n     * @param startMillis  the start of the duration to format\n     * @param endMillis  the end of the duration to format\n     * @return the time as a String\n     */\n    public static String formatPeriodISO(long startMillis, long endMillis) {\n        return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());\n    }\n\n    /**\n     * <p>Formats the time gap as a string, using the specified format.\n     * Padding the left hand side of numbers with zeroes is optional.\n     * \n     * @param startMillis  the start of the duration\n     * @param endMillis  the end of the duration\n     * @param format  the way in which to format the duration\n     * @return the time as a String\n     */\n    public static String formatPeriod(long startMillis, long endMillis, String format) {\n        return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());\n    }\n\n    /**\n     * <p>Formats the time gap as a string, using the specified format.\n     * Padding the left hand side of numbers with zeroes is optional and \n     * the timezone may be specified. \n     * \n     * @param startMillis  the start of the duration\n     * @param endMillis  the end of the duration\n     * @param format  the way in which to format the duration\n     * @param padWithZeros whether to pad the left hand side of numbers with 0's\n     * @param timezone the millis are defined in\n     * @return the time as a String\n     */\n    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n//days += 31; // TODO: Need tests to show this is bad and the new code is good.\n// HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n// Also it's contextual - if asked for no M in the format then I should probably \n// be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        // This next block of code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>The internal method to do the formatting.</p>\n     * \n     * @param tokens  the tokens\n     * @param years  the number of years\n     * @param months  the number of months\n     * @param days  the number of days\n     * @param hours  the number of hours\n     * @param minutes  the number of minutes\n     * @param seconds  the number of seconds\n     * @param milliseconds  the number of millis\n     * @param padWithZeros  whether to pad\n     * @return the formetted string\n     */\n    static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds,\n            int milliseconds, boolean padWithZeros) {\n        StringBuffer buffer = new StringBuffer();\n        boolean lastOutputSeconds = false;\n        int sz = tokens.length;\n        for (int i = 0; i < sz; i++) {\n            Token token = tokens[i];\n            Object value = token.getValue();\n            int count = token.getCount();\n            if (value instanceof StringBuffer) {\n                buffer.append(value.toString());\n            } else {\n                if (value == y) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n                            .toString(years));\n                    lastOutputSeconds = false;\n                } else if (value == M) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n                            .toString(months));\n                    lastOutputSeconds = false;\n                } else if (value == d) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n                            .toString(days));\n                    lastOutputSeconds = false;\n                } else if (value == H) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n                            .toString(hours));\n                    lastOutputSeconds = false;\n                } else if (value == m) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n                            .toString(minutes));\n                    lastOutputSeconds = false;\n                } else if (value == s) {\n                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n                            .toString(seconds));\n                    lastOutputSeconds = true;\n                } else if (value == S) {\n                    if (lastOutputSeconds) {\n                        milliseconds += 1000;\n                        String str = padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds);\n                        buffer.append(str.substring(1));\n                    } else {\n                        buffer.append(padWithZeros\n                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n                                : Integer.toString(milliseconds));\n                    }\n                    lastOutputSeconds = false;\n                }\n            }\n        }\n        return buffer.toString();\n    }\n    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n        end.add( field, -1 * difference );\n        int endValue = end.get(field);\n        int startValue = start.get(field);\n        if (endValue < startValue) {\n            int newdiff = startValue - endValue;\n            end.add( field, newdiff );\n            return newdiff;\n        } else {\n            return 0;\n        }\n    }\n\n    static final Object y = \"y\";\n    static final Object M = \"M\";\n    static final Object d = \"d\";\n    static final Object H = \"H\";\n    static final Object m = \"m\";\n    static final Object s = \"s\";\n    static final Object S = \"S\";\n    \n    /**\n     * Parses a classic date format string into Tokens\n     *\n     * @param format to parse\n     * @return Token[] of tokens\n     */\n    static Token[] lexx(String format) {\n        char[] array = format.toCharArray();\n        java.util.ArrayList list = new java.util.ArrayList(array.length);\n\n        boolean inLiteral = false;\n        StringBuffer buffer = null;\n        Token previous = null;\n        int sz = array.length;\n        for(int i=0; i<sz; i++) {\n            char ch = array[i];\n            if(inLiteral && ch != '\\'') {\n                buffer.append(ch);\n                continue;\n            }\n            Object value = null;\n            switch(ch) {\n                // TODO: Need to handle escaping of '\n                case '\\'' : \n                  if(inLiteral) {\n                      buffer = null;\n                      inLiteral = false;\n                  } else {\n                      buffer = new StringBuffer();\n                      list.add(new Token(buffer));\n                      inLiteral = true;\n                  }\n                  break;\n                case 'y'  : value = y; break;\n                case 'M'  : value = M; break;\n                case 'd'  : value = d; break;\n                case 'H'  : value = H; break;\n                case 'm'  : value = m; break;\n                case 's'  : value = s; break;\n                case 'S'  : value = S; break;\n                default   : \n                  if(buffer == null) {\n                      buffer = new StringBuffer();\n                      list.add(new Token(buffer));\n                  }\n                  buffer.append(ch);\n            }\n\n            if(value != null) {\n                if(previous != null && previous.getValue() == value) {\n                    previous.increment();\n                } else {\n                    Token token = new Token(value);\n                    list.add(token); \n                    previous = token;\n                }\n                buffer = null; \n            }\n        }\n        return (Token[]) list.toArray( new Token[0] );\n    }\n\n    /**\n     * Element that is parsed from the format pattern.\n     */\n    static class Token {\n\n        /**\n         * Helper method to determine if a set of tokens contain a value\n         *\n         * @param tokens set to look in\n         * @param value to look for\n         * @return boolean <code>true</code> if contained\n         */\n        static boolean containsTokenWithValue(Token[] tokens, Object value) {\n            int sz = tokens.length;\n            for (int i = 0; i < sz; i++) {\n                if (tokens[i].getValue() == value) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private Object value;\n        private int count;\n\n        /**\n         * Wraps a token around a value. A value would be something like a 'Y'.\n         *\n         * @param value to wrap\n         */\n        Token(Object value) {\n            this.value = value;\n            this.count = 1;\n        }\n\n        /**\n         * Wraps a token around a repeated number of a value, for example it would \n         * store 'yyyy' as a value for y and a count of 4.\n         *\n         * @param value to wrap\n         * @param count to wrap\n         */\n        Token(Object value, int count) {\n            this.value = value;\n            this.count = count;\n        }\n\n        /**\n         * Adds another one of the value\n         */\n        void increment() { \n            count++;\n        }\n\n        /**\n         * Gets the current number of values represented\n         *\n         * @return int number of values represented\n         */\n        int getCount() {\n            return count;\n        }\n\n        /**\n         * Gets the particular value this token represents.\n         * \n         * @return Object value\n         */\n        Object getValue() {\n            return value;\n        }\n\n        /**\n         * Supports equality of this Token to another Token.\n         *\n         * @param obj2 Object to consider equality of\n         * @return boolean <code>true</code> if equal\n         */\n        public boolean equals(Object obj2) {\n            if (obj2 instanceof Token) {\n                Token tok2 = (Token) obj2;\n                if (this.value.getClass() != tok2.value.getClass()) {\n                    return false;\n                }\n                if (this.count != tok2.count) {\n                    return false;\n                }\n                if (this.value instanceof StringBuffer) {\n                    return this.value.toString().equals(tok2.value.toString());\n                } else if (this.value instanceof Number) {\n                    return this.value.equals(tok2.value);\n                } else {\n                    return this.value == tok2.value;\n                }\n            } else {\n                return false;\n            }\n        }\n\n        /**\n         * Returns a hashcode for the token equal to the \n         * hashcode for the token's value. Thus 'TT' and 'TTTT' \n         * will have the same hashcode. \n         *\n         * @return The hashcode for the token\n         */\n        public int hashCode() {\n            return this.value.hashCode();\n        }\n\n        /**\n         * Represents this token as a String.\n         *\n         * @return String representation of the token\n         */\n        public String toString() {\n            return StringUtils.repeat(this.value.toString(), this.count);\n        }\n    }\n\n}\n", "review": {"response": "[{\"code\": \"Token containsTokenWithValue(tokens, d) \"}, {\"code\": \"Token.containsTokenWithValue(tokens, H) \"}, {\"code\": \"Token.containsTokenWithValue(tokens, m) \"}, {\"code\": \"Token.containsTokenWithValue(tokens, s) \"}, {\"code\": \"Token.containsTokenWithValue(tokens, S) \"}, {\"code\": \"Token.containsTokenWithValue(tokens, y) \"}, {\"code\": \"Token.containsTokenWithValue(tokens, M) \"}, {\"code\": \"Token.containsTokenWithValue(tokens, ISO_EXTENDED_FORMAT_PATTERN) \"}, {\"code\": \"Token.containsTokenWithValue(tokens, 'T') \"}, {\"code\": \"Token.containsTokenWithValue(tokens, 'P') \"}, {\"code\": \"Token.containsTokenWithValue(tokens, 'S') \"}, {\"code\": \"Token.containsTokenWithValue(tokens, 'D') \"}, {\"code\": \"Token.containsTokenWithValue(tokens, 'H') \"}, {\"code\": \"Token.containsTokenWithValue(tokens, 'm') \"}, {\"code\": \"Token.containsTokenWithValue(tokens, 's') \"} ]"}}