{
  "source_item_id": 8052,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:46:04.873567",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2011 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static java.util.Objects.requireNonNull;\n\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.concurrent.LazyInit;\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongUnaryOperator;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * A map containing {@code long} values that can be atomically updated. While writes to a\n * traditional {@code Map} rely on {@code put(K, V)}, the typical mechanism for writing to this map\n * is {@code addAndGet(K, long)}, which adds a {@code long} to the value currently associated with\n * {@code K}. If a key has not yet been associated with a value, its implicit value is zero.\n *\n * <p>Most methods in this class treat absent values and zero values identically, as individually\n * documented. Exceptions to this are {@link #containsKey}, {@link #size}, {@link #isEmpty}, {@link\n * #asMap}, and {@link #toString}.\n *\n * <p>Instances of this class may be used by multiple threads concurrently. All operations are\n * atomic unless otherwise noted.\n *\n * <p>Instances of this class are serializable if the keys are serializable.\n *\n * <p><b>Note:</b> If your values are always positive and less than 2^31, you may wish to use a\n * {@link com.google.common.collect.Multiset} such as {@link\n * com.google.common.collect.ConcurrentHashMultiset} instead.\n *\n * <p><b>Warning:</b> Unlike {@code Multiset}, entries whose values are zero are not automatically\n * removed from the map. Instead they must be removed manually with {@link #removeAllZeros}.\n *\n * @author Charles Fry\n * @since 11.0\n */\n@GwtCompatible\npublic final class AtomicLongMap<K> implements Serializable {\n  private final ConcurrentHashMap<K, Long> map;\n\n  private AtomicLongMap(ConcurrentHashMap<K, Long> map) {\n    this.map = checkNotNull(map);\n  }\n\n  /** Creates an {@code AtomicLongMap}. */\n  public static <K> AtomicLongMap<K> create() {\n    return new AtomicLongMap<>(new ConcurrentHashMap<>());\n  }\n\n  /** Creates an {@code AtomicLongMap} with the same mappings as the specified {@code Map}. */\n  public static <K> AtomicLongMap<K> create(Map<? extends K, ? extends Long> m) {\n    AtomicLongMap<K> result = create();\n    result.putAll(m);\n    return result;\n  }\n\n  /**\n   * Returns the value associated with {@code key}, or zero if there is no value associated with\n   * {@code key}.\n   */\n  public long get(K key) {\n    return map.getOrDefault(key, 0L);\n  }\n\n  /**\n   * Increments by one the value currently associated with {@code key}, and returns the new value.\n   */\n  @CanIgnoreReturnValue\n  public long incrementAndGet(K key) {\n    return addAndGet(key, 1);\n  }\n\n  /**\n   * Decrements by one the value currently associated with {@code key}, and returns the new value.\n   */\n  @CanIgnoreReturnValue\n  public long decrementAndGet(K key) {\n    return addAndGet(key, -1);\n  }\n\n  /**\n   * Adds {@code delta} to the value currently associated with {@code key}, and returns the new\n   * value.\n   */\n  @CanIgnoreReturnValue\n  public long addAndGet(K key, long delta) {\n    return accumulateAndGet(key, delta, Long::sum);\n  }\n\n  /**\n   * Increments by one the value currently associated with {@code key}, and returns the old value.\n   */\n  @CanIgnoreReturnValue\n  public long getAndIncrement(K key) {\n    return getAndAdd(key, 1);\n  }\n\n  /**\n   * Decrements by one the value currently associated with {@code key}, and returns the old value.\n   */\n  @CanIgnoreReturnValue\n  public long getAndDecrement(K key) {\n    return getAndAdd(key, -1);\n  }\n\n  /**\n   * Adds {@code delta} to the value currently associated with {@code key}, and returns the old\n   * value.\n   */\n  @CanIgnoreReturnValue\n  public long getAndAdd(K key, long delta) {\n    return getAndAccumulate(key, delta, Long::sum);\n  }\n\n  /**\n   * Updates the value currently associated with {@code key} with the specified function, and\n   * returns the new value. If there is not currently a value associated with {@code key}, the\n   * function is applied to {@code 0L}.\n   *\n   * @since 21.0\n   */\n  @CanIgnoreReturnValue\n  public long updateAndGet(K key, LongUnaryOperator updaterFunction) {\n    checkNotNull(updaterFunction);\n    Long result =\n        map.compute(\n            key, (k, value) -> updaterFunction.applyAsLong(value == null ? 0L : value.longValue()));\n    return requireNonNull(result);\n  }\n\n  /**\n   * Updates the value currently associated with {@code key} with the specified function, and\n   * returns the old value. If there is not currently a value associated with {@code key}, the\n   * function is applied to {@code 0L}.\n   *\n   * @since 21.0\n   */\n  @CanIgnoreReturnValue\n  public long getAndUpdate(K key, LongUnaryOperator updaterFunction) {\n    checkNotNull(updaterFunction);\n    AtomicLong holder = new AtomicLong();\n    map.compute(\n        key,\n        (k, value) -> {\n          long oldValue = (value == null) ? 0L : value.longValue();\n          holder.set(oldValue);\n          return updaterFunction.applyAsLong(oldValue);\n        });\n    return holder.get();\n  }\n\n  /**\n   * Updates the value currently associated with {@code key} by combining it with {@code x} via the\n   * specified accumulator function, returning the new value. The previous value associated with\n   * {@code key} (or zero, if there is none) is passed as the first argument to {@code\n   * accumulatorFunction}, and {@code x} is passed as the second argument.\n   *\n   * @since 21.0\n   */\n  @CanIgnoreReturnValue\n  public long accumulateAndGet(K key, long x, LongBinaryOperator accumulatorFunction) {\n    checkNotNull(accumulatorFunction);\n    return updateAndGet(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));\n  }\n\n  /**\n   * Updates the value currently associated with {@code key} by combining it with {@code x} via the\n   * specified accumulator function, returning the old value. The previous value associated with\n   * {@code key} (or zero, if there is none) is passed as the first argument to {@code\n   * accumulatorFunction}, and {@code x} is passed as the second argument.\n   *\n   * @since 21.0\n   */\n  @CanIgnoreReturnValue\n  public long getAndAccumulate(K key, long x, LongBinaryOperator accumulatorFunction) {\n    checkNotNull(accumulatorFunction);\n    return getAndUpdate(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));\n  }\n\n  /**\n   * Associates {@code newValue} with {@code key} in this map, and returns the value previously\n   * associated with {@code key}, or zero if there was no such value.\n   */\n  @CanIgnoreReturnValue\n  public long put(K key, long newValue) {\n    return getAndUpdate(key, x -> newValue);\n  }\n\n  /**\n   * Copies all of the mappings from the specified map to this map. The effect of this call is\n   * equivalent to that of calling {@code put(k, v)} on this map once for each mapping from key\n   * {@code k} to value {@code v} in the specified map. The behavior of this operation is undefined\n   * if the specified map is modified while the operation is in progress.\n   */\n  public void putAll(Map<? extends ",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The `putAll` method does not check for null values in the map being copied.\",\n         \"suggested_fix\": \"public void putAll(Map<? extends K, ? extends Long> m) {\\n    if (m != null) {\\n        m.forEach(this::put);\\n    }\\n}\"\n      },\n      {\n         \"explanation\": \"The `updateAndGet` and `getAndUpdate` methods do not handle the case where the updater function throws an exception.\",\n         \"suggested_fix\": \"public long updateAndGet(K key, LongUnaryOperator updaterFunction) {\\n    try {\\n        return map.compute...\\n    } catch (Exception e) {\\n        // handle exception\\n    }\\n}\"\n      },\n      {\n         \"explanation\": \"The `accumulateAndGet` and `getAndAccumulate` methods do not check if the accumulator function is null.\",\n         \"suggested_fix\": \"public long accumulateAndGet(K key, long x, LongBinaryOperator accumulatorFunction) {\\n    if (accumulatorFunction == null) {\\n        throw new NullPointerException(\\\"accumulatorFunction is null\\\");\\n    }\\n    return updateAndGet(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));\\n}\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No bugs found in the provided code snippet.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The `putAll` method does not check for null values in the map being copied.",
        "suggested_fix": "public void putAll(Map<? extends K, ? extends Long> m) {\n    if (m != null) {\n        m.forEach(this::put);\n    }\n}"
      },
      {
        "explanation": "The `updateAndGet` and `getAndUpdate` methods do not handle the case where the updater function throws an exception.",
        "suggested_fix": "public long updateAndGet(K key, LongUnaryOperator updaterFunction) {\n    try {\n        return map.compute...\n    } catch (Exception e) {\n        // handle exception\n    }\n}"
      },
      {
        "explanation": "The `accumulateAndGet` and `getAndAccumulate` methods do not check if the accumulator function is null.",
        "suggested_fix": "public long accumulateAndGet(K key, long x, LongBinaryOperator accumulatorFunction) {\n    if (accumulatorFunction == null) {\n        throw new NullPointerException(\"accumulatorFunction is null\");\n    }\n    return updateAndGet(key, oldValue -> accumulatorFunction.applyAsLong(oldValue, x));\n}"
      }
    ],
    "no_bugs_reasoning": "No bugs found in the provided code snippet."
  },
  "error": null
}