{"sample_id": "Math_2", "model": "qwen-coder-32b", "code_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.distribution;\n\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.NotStrictlyPositiveException;\nimport org.apache.commons.math3.exception.NumberIsTooLargeException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.random.RandomGenerator;\nimport org.apache.commons.math3.random.Well19937c;\n\n/**\n * Implementation of the hypergeometric distribution.\n *\n * @see <a href=\"http://en.wikipedia.org/wiki/Hypergeometric_distribution\">Hypergeometric distribution (Wikipedia)</a>\n * @see <a href=\"http://mathworld.wolfram.com/HypergeometricDistribution.html\">Hypergeometric distribution (MathWorld)</a>\n * @version $Id$\n */\npublic class HypergeometricDistribution extends AbstractIntegerDistribution {\n    /** Serializable version identifier. */\n    private static final long serialVersionUID = -436928820673516179L;\n    /** The number of successes in the population. */\n    private final int numberOfSuccesses;\n    /** The population size. */\n    private final int populationSize;\n    /** The sample size. */\n    private final int sampleSize;\n    /** Cached numerical variance */\n    private double numericalVariance = Double.NaN;\n    /** Whether or not the numerical variance has been calculated */\n    private boolean numericalVarianceIsCalculated = false;\n\n    /**\n     * Construct a new hypergeometric distribution with the specified population\n     * size, number of successes in the population, and sample size.\n     *\n     * @param populationSize Population size.\n     * @param numberOfSuccesses Number of successes in the population.\n     * @param sampleSize Sample size.\n     * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n     * @throws NotStrictlyPositiveException if {@code populationSize <= 0}.\n     * @throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize},\n     * or {@code sampleSize > populationSize}.\n     */\n    public HypergeometricDistribution(int populationSize, int numberOfSuccesses, int sampleSize)\n    throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n        this(new Well19937c(), populationSize, numberOfSuccesses, sampleSize);\n    }\n\n    /**\n     * Creates a new hypergeometric distribution.\n     *\n     * @param rng Random number generator.\n     * @param populationSize Population size.\n     * @param numberOfSuccesses Number of successes in the population.\n     * @param sampleSize Sample size.\n     * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n     * @throws NotStrictlyPositiveException if {@code populationSize <= 0}.\n     * @throws NumberIsTooLargeException if {@code numberOfSuccesses > populationSize},\n     * or {@code sampleSize > populationSize}.\n     * @since 3.1\n     */\n    public HypergeometricDistribution(RandomGenerator rng,\n                                      int populationSize,\n                                      int numberOfSuccesses,\n                                      int sampleSize)\n    throws NotPositiveException, NotStrictlyPositiveException, NumberIsTooLargeException {\n        super(rng);\n\n        if (populationSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.POPULATION_SIZE,\n                                                   populationSize);\n        }\n        if (numberOfSuccesses < 0) {\n            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,\n                                           numberOfSuccesses);\n        }\n        if (sampleSize < 0) {\n            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                                           sampleSize);\n        }\n\n        if (numberOfSuccesses > populationSize) {\n            throw new NumberIsTooLargeException(LocalizedFormats.NUMBER_OF_SUCCESS_LARGER_THAN_POPULATION_SIZE,\n                                                numberOfSuccesses, populationSize, true);\n        }\n        if (sampleSize > populationSize) {\n            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE,\n                                                sampleSize, populationSize, true);\n        }\n\n        this.numberOfSuccesses = numberOfSuccesses;\n        this.populationSize = populationSize;\n        this.sampleSize = sampleSize;\n    }\n\n    /** {@inheritDoc} */\n    public double cumulativeProbability(int x) {\n        double ret;\n\n        int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n        if (x < domain[0]) {\n            ret = 0.0;\n        } else if (x >= domain[1]) {\n            ret = 1.0;\n        } else {\n            ret = innerCumulativeProbability(domain[0], x, 1);\n        }\n\n        return ret;\n    }\n\n    /**\n     * Return the domain for the given hypergeometric distribution parameters.\n     *\n     * @param n Population size.\n     * @param m Number of successes in the population.\n     * @param k Sample size.\n     * @return a two element array containing the lower and upper bounds of the\n     * hypergeometric distribution.\n     */\n    private int[] getDomain(int n, int m, int k) {\n        return new int[] { getLowerDomain(n, m, k), getUpperDomain(m, k) };\n    }\n\n    /**\n     * Return the lowest domain value for the given hypergeometric distribution\n     * parameters.\n     *\n     * @param n Population size.\n     * @param m Number of successes in the population.\n     * @param k Sample size.\n     * @return the lowest domain value of the hypergeometric distribution.\n     */\n    private int getLowerDomain(int n, int m, int k) {\n        return FastMath.max(0, m - (n - k));\n    }\n\n    /**\n     * Access the number of successes.\n     *\n     * @return the number of successes.\n     */\n    public int getNumberOfSuccesses() {\n        return numberOfSuccesses;\n    }\n\n    /**\n     * Access the population size.\n     *\n     * @return the population size.\n     */\n    public int getPopulationSize() {\n        return populationSize;\n    }\n\n    /**\n     * Access the sample size.\n     *\n     * @return the sample size.\n     */\n    public int getSampleSize() {\n        return sampleSize;\n    }\n\n    /**\n     * Return the highest domain value for the given hypergeometric distribution\n     * parameters.\n     *\n     * @param m Number of successes in the population.\n     * @param k Sample size.\n     * @return the highest domain value of the hypergeometric distribution.\n     */\n    private int getUpperDomain(int m, int k) {\n        return FastMath.min(k, m);\n    }\n\n    /** {@inheritDoc} */\n    public double probability(int x) {\n        double ret;\n\n        int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n        if (x < domain[0] || x > domain[1]) {\n            ret = 0.0;\n        } else {\n            double p = (double) sampleSize / (double) populationSize;\n            double q = (double) (populationSize - sampleSize) / (double) populationSize;\n            double p1 = SaddlePointExpansion.logBinomialProbability(x,\n                    numberOfSuccesses, p, q);\n            double p2 =\n                SaddlePointExpansion.logBinomialProbability(sampleSize - x,\n                    populationSize - numberOfSuccesses, p, q);\n            double p3 =\n                SaddlePointExpansion.logBinomialProbability(sampleSize, populationSize, p, q);\n            ret = FastMath.exp(p1 + p2 - p3);\n        }\n\n        return ret;\n    }\n\n    /**\n     * For this distribution, {@code X}, this method returns {@code P(X >= x)}.\n     *\n     * @param x Value at which the CDF is evaluated.\n     * @return the upper tail CDF for this distribution.\n     * @since 1.1\n     */\n    public double upperCumulativeProbability(int x) {\n        double ret;\n\n        final int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n        if (x <= domain[0]) {\n            ret = 1.0;\n        } else if (x > domain[1]) {\n            ret = 0.0;\n        } else {\n            ret = innerCumulativeProbability(domain[1], x, -1);\n        }\n\n        return ret;\n    }\n\n    /**\n     * For this distribution, {@code X}, this method returns\n     * {@code P(x0 <= X <= x1)}.\n     * This probability is computed by summing the point probabilities for the\n     * values {@code x0, x0 + 1, x0 + 2, ..., x1}, in the order directed by\n     * {@code dx}.\n     *\n     * @param x0 Inclusive lower bound.\n     * @param x1 Inclusive upper bound.\n     * @param dx Direction of summation (1 indicates summing from x0 to x1, and\n     * 0 indicates summing from x1 to x0).\n     * @return {@code P(x0 <= X <= x1)}.\n     */\n    private double innerCumulativeProbability(int x0, int x1, int dx) {\n        double ret = probability(x0);\n        while (x0 != x1) {\n            x0 += dx;\n            ret += probability(x0);\n        }\n        return ret;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the mean is {@code n * m / N}.\n     */\n    public double getNumericalMean() {\n        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the variance is\n     * {@code [n * m * (N - n) * (N - m)] / [N^2 * (N - 1)]}.\n     */\n    public double getNumericalVariance() {\n        if (!numericalVarianceIsCalculated) {\n            numericalVariance = calculateNumericalVariance();\n            numericalVarianceIsCalculated = true;\n        }\n        return numericalVariance;\n    }\n\n    /**\n     * Used by {@link #getNumericalVariance()}.\n     *\n     * @return the variance of this distribution\n     */\n    protected double calculateNumericalVariance() {\n        final double N = getPopulationSize();\n        final double m = getNumberOfSuccesses();\n        final double n = getSampleSize();\n        return (n * m * (N - n) * (N - m)) / (N * N * (N - 1));\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the lower bound of the support is\n     * {@code max(0, n + m - N)}.\n     *\n     * @return lower bound of the support\n     */\n    public int getSupportLowerBound() {\n        return FastMath.max(0,\n                            getSampleSize() + getNumberOfSuccesses() - getPopulationSize());\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * For number of successes {@code m} and sample size {@code n}, the upper\n     * bound of the support is {@code min(m, n)}.\n     *\n     * @return upper bound of the support\n     */\n    public int getSupportUpperBound() {\n        return FastMath.min(getNumberOfSuccesses(), getSampleSize());\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The support of this distribution is connected.\n     *\n     * @return {@code true}\n     */\n    public boolean isSupportConnected() {\n        return true;\n    }\n}\n", "review": {"response": "<think>\nOkay, I need to review this Java code for bugs and return a JSON with a 'bugs' list. Let me start by looking through the code carefully.\n\nFirst, the class is HypergeometricDistribution. The constructor checks parameters like populationSize, numberOfSuccesses, and sampleSize. Wait, in the first constructor, which calls the second one, there's a check for sampleSize < 0? Let me check the code. Oh, in the second constructor (the one with RandomGenerator), there's a check:\n\nif (sampleSize < 0) {\n    throw new NotPositiveException(...);\n}\n\nBut sampleSize can be zero. The problem is that the Hypergeometric distribution's sample size is typically a positive integer. However, the constructor here allows sampleSize to be zero? Wait, the NotPositiveException is thrown when the value is negative. But sampleSize can be zero, which is allowed? Let me check the exceptions. The constructor throws NotPositiveException for numberOfSuccesses < 0 and sampleSize < 0. However, in the Hypergeometric distribution, the sample size (k) can be zero, but in the parameters, the sample size is allowed to be zero? Or is it supposed to be strictly positive?\n\nLooking at the exception messages: the sampleSize is checked with NotPositiveException, which is thrown when the value is not positive (i.e., <=0). But according to the Hypergeometric distribution's definition, the sample size (k) must be a non-negative integer, but in the code, the check is for sampleSize < 0. However, the constructor's Javadoc says it throws NotPositiveException if numberOfSuccesses < 0, which is correct. But for sampleSize, the check is sampleSize < 0, which would allow sampleSize = 0. However, in the Hypergeometric distribution, the sample size (k) is usually required to be a non-negative integer (including zero). But in the code, the sampleSize is allowed to be zero. However, in the constructor, the sampleSize can be zero, but in the HypergeometricDistribution, when sampleSize is zero, the sample size can't be larger than the population size. For example, if populationSize is 5 and sampleSize is 0, then sampleSize is allowed. But according to the code's checks, sampleSize can be zero. However, in the Hypergeometric distribution, the sample size (k) can be zero. So maybe that's okay. Wait, but the code has a check for sampleSize > populationSize. For example, if sampleSize is 0 and populationSize is 5, then it's allowed. So that's okay.\n\nWait, but in the code, the sampleSize is allowed to be zero. However, in the Hypergeometric distribution, when sampleSize is zero, the probability of getting zero successes is 1. But the code's cumulativeProbability method would handle that. So maybe that's correct. So perhaps that's not a bug.\n\nAnother thing: the method getDomain is called in cumulativeProbability, but the code for getDomain is not shown here. The user's code is cut off at the end. The code for getDomain is private and probably returns the lower and upper bounds for the distribution. But since the code is incomplete, maybe there's a bug there. However, the code provided ends with:\n\nprivate```\n\nWait, the code is cut off here. The user's code shows:\n\nprivate``` \n\nwith a backtick, but maybe it's a typo. The actual code for getDomain is missing. So perhaps there's an issue there. But since the code is incomplete, maybe that's a problem. However, the user's code is cut off, so maybe there's a bug in the getDomain method that's not shown here. But since the user provided the code up to that point, perhaps that's a bug in the code as presented. The getDomain method is private and not defined, so the code would not compile. That's a bug.\n\nAnother thing: in the cumulativeProbability method, the code checks if x is less than domain[0], returns 0.0. If x is >= domain[1], returns 1.0. Otherwise, calls innerCumulativeProbability. But what if domain[0] is greater than domain[1]? For example, if the lower bound is higher than the upper bound. That would be a problem. However, the getDomain method should return the correct bounds. But since the code is not provided, we can't confirm.\n\nAnother possible issue: in the constructor, the code checks if sampleSize > populationSize. For example, if sampleSize is 5 and populationSize is 3, it throws an exception. That's correct. But what if sampleSize is equal to populationSize? For example, sampleSize = populationSize. That's allowed, but in that case, the number of successes in the sample would be exactly the number of successes in the population. However, the code allows that. So that's okay.\n\nAnother possible bug: in the constructor, the code checks if numberOfSuccesses > populationSize. That's correct. But what if numberOfSuccesses is negative? The code throws NotPositiveException if numberOfSuccesses < 0. That's correct.\n\nAnother thing: the method cumulativeProbability calls innerCumulativeProbability with parameters domain[0], x, 1. What is the third parameter? Maybe it's an indicator for something. But without seeing innerCumulativeProbability's code, it's hard to tell. However, if innerCumulativeProbability is not defined in this class, that's a problem. But since it's part of the code, assuming that innerCumulativeProbability is a method in the class, perhaps it's okay. But if it's not implemented, that's a bug. However, the code provided doesn't show that method, so maybe that's a missing method. But since the code is cut off, perhaps that's a problem.\n\nAnother possible issue: the code uses the Well19937c as a default RNG. But the constructor that doesn't take an RNG uses new Well19937c(). That's okay.\n\nAnother possible issue: in the constructor, the code checks sampleSize < 0, but sampleSize can be zero. However, according to the Hypergeometric distribution, the sample size (k) can be zero. So that's allowed, and the code allows it. So that's not a bug.\n\nAnother thing: in the code, the sampleSize is stored as a final variable. But the Hypergeometric distribution's sample size is a parameter. So that's okay.\n\nAnother possible bug: the code for getDomain is not provided. If getDomain is not correctly calculating the domain, then cumulativeProbability would be incorrect. But since the code is cut off, it's hard to tell. However, the presence of the method call to getDomain without its implementation is a compilation error. So that's a definite bug.\n\nSo, the main bugs I can see are:\n\n1. The getDomain method is declared but not implemented. The code ends with 'private```' which is incomplete. So the method is missing, leading to a compilation error.\n\n2. In the constructor, the sampleSize is checked for < 0, but sampleSize can be zero. However, according to the Hypergeometric distribution's parameters, sampleSize can be zero. So the check is correct. But perhaps the exception thrown is NotPositiveException, which is for values not positive (i.e., <=0). Wait, the NotPositiveException's message is LocalizedFormats.NUMBER_OF_SAMPLES, which is for sampleSize. The code throws NotPositiveException if sampleSize < 0. But sampleSize can be zero. So that's correct. Because sampleSize is allowed to be zero. So that's not a bug.\n\nWait, the NotPositiveException is thrown when the value is not positive, i.e., <=0. But the check is sampleSize < 0. So if sampleSize is zero, it's allowed. That's correct. So the code is correct here.\n\nAnother possible issue: the code for innerCumulativeProbability is not shown. If it's not implemented, then the code would not compile. But again, the code is cut off.\n\nBut based on the code provided, the main bugs are:\n\n- The getDomain method is not implemented, leading to a compilation error.\n\n- The code for getDomain is cut off, which is a syntax error.\n\nAnother possible issue: in the constructor, the sampleSize is checked for being less than zero, but if sampleSize is zero, it's allowed. However, in the Hypergeometric distribution, the sample size (k) must be a non-negative integer, which is correct here. So that's not a bug.\n\nSo the main bugs are:\n\n1. The getDomain method is not implemented, leading to a compilation error.\n\n2. The code for getDomain is incomplete (ends with 'private```'), which is a syntax error.\n\nAnother possible bug: in the cumulativeProbability method, the code uses domain[0] and domain[1], but if getDomain returns an array of length less than 2, that would cause an ArrayIndexOutOfBoundsException. However, since getDomain is supposed to return a two-element array, that's correct. But if getDomain is not implemented correctly, that's a problem. But since the code is not provided, we can't confirm.\n\nBut given the code provided, the main bugs are the missing getDomain method and the incomplete code.\n\nSo the JSON should list these as bugs.\n</think>\n\n```json\n{\n  \"bugs\": [\n    {\n      \"line_number\": 112,\n      \"description\": \"The method 'getDomain' is declared but not implemented. The code is cut off with 'private```', leading to a compilation error due to a missing method definition.\"\n    },\n    {\n      \"line_number\": 112,\n      \"description\": \"Incomplete syntax at the end of the code (private```) which is not valid Java syntax. This will cause a compilation error.\"\n    },\n    {\n      \"line_number\": 74,\n      \"description\": \"The sampleSize parameter is checked for being less than zero, which is correct. However, if sampleSize is zero, it is allowed in the Hypergeometric distribution. The code correctly allows sampleSize=0, so no bug here.\"\n    }\n  ]\n}\n```"}}