{"sample_id": "Closure_64", "model": "mistral-nemo", "code_context": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.javascript.jscomp.CompilerOptions.DevMode;\nimport com.google.javascript.jscomp.CompilerOptions.LanguageMode;\nimport com.google.javascript.jscomp.CompilerOptions.TracerMode;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\nimport com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\nimport com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\nimport com.google.javascript.jscomp.parsing.Config;\nimport com.google.javascript.jscomp.parsing.ParserRunner;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n\n  static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\");\n\n  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\");\n\n  CompilerOptions options = null;\n\n  private PassConfig passes = null;\n\n  // The externs inputs\n  private List<CompilerInput> externs;\n\n  // The JS source modules\n  private List<JSModule> modules;\n\n  // The graph of the JS source modules. Must be null if there are less than\n  // 2 modules, because we use this as a signal for which passes to run.\n  private JSModuleGraph moduleGraph;\n\n  // The JS source inputs\n  private List<CompilerInput> inputs;\n\n  // error manager to which error management is delegated\n  private ErrorManager errorManager;\n\n  // Warnings guard for filtering warnings.\n  private WarningsGuard warningsGuard;\n\n  // Parse tree root nodes\n  Node externsRoot;\n  Node jsRoot;\n  Node externAndJsRoot;\n\n  private Map<String, CompilerInput> inputsByName;\n\n  /** The source code map */\n  private SourceMap sourceMap;\n\n  /** The externs created from the exports.  */\n  private String externExports = null;\n\n  /**\n   * Ids for function inlining so that each declared name remains\n   * unique.\n   */\n  private int uniqueNameId = 0;\n\n  /** Whether to use threads. */\n  private boolean useThreads = true;\n\n  /**\n   * Whether to assume there are references to the RegExp Global object\n   * properties.\n   */\n  private boolean hasRegExpGlobalReferences = true;\n\n  /** The function information map */\n  private FunctionInformationMap functionInformationMap;\n\n  /** Debugging information */\n  private final StringBuilder debugLog = new StringBuilder();\n\n  /** Detects Google-specific coding conventions. */\n  CodingConvention defaultCodingConvention = new ClosureCodingConvention();\n\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n\n  public PerformanceTracker tracker;\n\n  // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.\n  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =\n      RhinoErrorReporter.forOldRhino(this);\n\n  // This error reporter gets the messages from the current Rhino parser.\n  private final ErrorReporter defaultErrorReporter =\n      RhinoErrorReporter.forNewRhino(this);\n\n  /** Error strings used for reporting JSErrors */\n  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\");\n  public static final DiagnosticType MOTION_ITERATIONS_ERROR =\n      DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\");\n\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n\n\n  /**\n   * Logger for the whole com.google.javascript.jscomp domain -\n   * setting configuration for this logger affects all loggers\n   *  in other classes within the compiler.\n   */\n  private static final Logger logger =\n      Logger.getLogger(\"com.google.javascript.jscomp\");\n\n  private final PrintStream outStream;\n\n  private GlobalVarReferenceMap globalRefMap = null;\n\n  /**\n   * Creates a Compiler that reports errors and warnings to its logger.\n   */\n  public Compiler() {\n    this((PrintStream) null);\n  }\n\n  /**\n   * Creates n Compiler that reports errors and warnings to an output\n   * stream.\n   */\n  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }\n\n  /**\n   * Creates a Compiler that uses a custom error manager.\n   */\n  public Compiler(ErrorManager errorManager) {\n    this();\n    setErrorManager(errorManager);\n  }\n\n  /**\n   * Sets the error manager.\n   *\n   * @param errorManager the error manager, it cannot be {@code null}\n   */\n  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }\n\n  /**\n   * Creates a message formatter instance corresponding to the value of\n   * {@link CompilerOptions}.\n   */\n  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }\n\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    init(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSSourceFile>newArrayList(inputs), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(\"[singleton]\");\n    for (JSSourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options) {\n    initModules(Lists.<JSSourceFile>newArrayList(externs),\n         Lists.<JSModule>newArrayList(modules), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void initModules(\n      List<JSSourceFile> externs, List<JSModule> modules,\n      CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByNameMap();\n  }\n\n  /**\n   * Do any initialization that is dependent on the compiler options.\n   */\n  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n    }\n  }\n\n  private List<CompilerInput> makeCompilerInput(\n      List<JSSourceFile> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (JSSourceFile file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }\n\n  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\");\n\n  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\");\n\n  /**\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   */\n  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }\n\n  /**\n   * Fill any empty modules with a place holder file. It makes any cross module\n   * motion easier.\n   */\n  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(JSSourceFile.fromCode(\"[\" + module.getName() + \"]\", \"\"));\n      }\n    }\n  }\n\n  /**\n   * Rebuilds the internal list of inputs by iterating over all modules.\n   * This is necessary if inputs have been added to or removed from a module\n   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n   */\n  public void rebuildInputsFromModules() {\n    inputs = getAllInputsFromModules(modules);\n    initInputsByNameMap();\n  }\n\n  /**\n   * Builds a single list of all module inputs. Verifies that it contains no\n   * duplicates.\n   */\n  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }\n\n  static final DiagnosticType DUPLICATE_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");\n  static final DiagnosticType DUPLICATE_EXTERN_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\");\n\n  /**\n   * Creates a map to make looking up an input by name fast. Also checks for\n   * duplicate inputs.\n   */\n  void initInputsByNameMap() {\n    inputsByName = new HashMap<String, CompilerInput>();\n    for (CompilerInput input : externs) {\n      String name = input.getName();\n      if (!inputsByName.containsKey(name)) {\n        inputsByName.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, name));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      String name = input.getName();\n      if (!inputsByName.containsKey(name)) {\n        inputsByName.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_INPUT, name));\n      }\n    }\n  }\n\n  public Result compile(\n      JSSourceFile extern, JSSourceFile input, CompilerOptions options) {\n     return compile(extern, new JSSourceFile[] { input }, options);\n  }\n\n  public Result compile(\n      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options) {\n     return compile(new JSSourceFile[] { extern }, input, options);\n  }\n\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {\n     return compile(new JSSourceFile[] { extern }, modules, options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options) {\n    return compile(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSSourceFile>newArrayList(inputs),\n        options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(List<JSSourceFile> externs,\n      List<JSSourceFile> inputs, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      init(externs, inputs, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options) {\n    return compileModules(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSModule>newArrayList(modules),\n        options);\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compileModules(List<JSSourceFile> externs,\n      List<JSModule> modules, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      initModules(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  private Result compile() {\n    return runInCompilerThread(new Callable<Result>() {\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n    });\n  }\n\n  /**\n   * Disable threads. This is for clients that run on AppEngine and\n   * don't have threads.\n   */\n  public void disableThreads() {\n    useThreads = false;\n  }\n\n  private <T> T runInCompilerThread(final Callable<T> callable) {\n    return runCallable(callable, useThreads, options.tracer.isOn());\n  }\n\n  static <T> T runCallableWithLargeStack(final Callable<T> callable) {\n    return runCallable(callable, true, false);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static <T> T runCallable(\n      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n\n    // Under JRE 1.6, the jscompiler overflows the stack when running on some\n    // large or complex js code. Here we start a new thread with a larger\n    // stack in order to let the compiler do its thing, without having to\n    // increase the stack size for *every* thread (which is what -Xss does).\n    // Might want to add thread pool support for clients that compile a lot.\n\n    final boolean dumpTraceReport = trace;\n    final Object[] result = new Object[1];\n    final Throwable[] exception = new Throwable[1];\n    Runnable runnable = new Runnable() {\n      public void run() {\n        try {\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          result[0] = callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n          }\n        }\n      }\n    };\n\n    if (useLargeStackThread) {\n      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n      th.start();\n      while (true) {\n        try {\n          th.join();\n          break;\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n    } else {\n      runnable.run();\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return (T) result[0];\n  }\n\n  private void compileInternal() {\n    parse();\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.isExternExportsEnabled()\n          || options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n  }\n\n  public void parse() {\n    parseInputs();\n  }\n\n  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }\n\n  /**\n   * Create the passes object. Clients should use setPassConfig instead of\n   * overriding this.\n   */\n  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }\n\n  /**\n   * @param passes The PassConfig to use with this Compiler.\n   * @throws NullPointerException if passes is null\n   * @throws IllegalStateException if this.passes has already been assigned\n   */\n  public void setPassConfig(PassConfig passes) {\n    // Important to check for null because if setPassConfig(null) is\n    // called before this.passes is set, getPassConfig() will create a\n    // new PassConfig object and use that, which is probably not what\n    // the client wanted since he or she probably meant to use their\n    // own PassConfig object.\n    Preconditions.checkNotNull(passes);\n\n    if (this.passes != null) {\n      throw new IllegalStateException(\"this.passes has already been assigned\");\n    }\n    this.passes = passes;\n  }\n\n  /**\n   * Carry out any special checks or procedures that need to be done before\n   * proceeding with rest of the compilation process.\n   *\n   * @return true, to continue with compilation\n   */\n  boolean precheck() {\n    return true;\n  }\n\n  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n  }\n\n  private void externExports() {\n    logger.info(\"Creating extern file for exports\");\n    startPass(\"externExports\");\n\n    ExternExportsPass pass = new ExternExportsPass(this);\n    process(pass);\n\n    externExports = pass.getGeneratedExterns();\n\n    endPass();\n  }\n\n  @Override\n  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }\n\n  private final PassFactory sanityCheck =\n      new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  };\n\n  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }\n\n  private void runSanityCheck() {\n    sanityCheck.create(this).process(externsRoot, jsRoot);\n  }\n\n  /**\n   * Removes try/catch/finally statements for easier debugging.\n   */\n  void removeTryCatchFinally() {\n    logger.info(\"Remove try/catch/finally\");\n    startPass(\"removeTryCatchFinally\");\n    RemoveTryCatch r = new RemoveTryCatch(this);\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Strips code for smaller compiled code. This is useful for removing debug\n   * statements to prevent leaking them publicly.\n   */\n  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,\n      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {\n    logger.info(\"Strip code\");\n    startPass(\"stripCode\");\n    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,\n        stripTypePrefixes, stripNamePrefixes);\n    if (options.getTweakProcessing().shouldStrip()) {\n      r.enableTweakStripping();\n    }\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Runs custom passes that are designated to run at a particular time.\n   */\n  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }\n\n  private Tracer currentTracer = null;\n  private String currentPassName = null;\n\n  /**\n   * Marks the beginning of a pass.\n   */\n  void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }\n\n  /**\n   * Marks the end of a pass.\n   */\n  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }\n\n  /**\n   * Returns a new tracer for the given pass name.\n   */\n  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }\n\n  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }\n\n  /**\n   * Returns the result of the compilation.\n   */\n  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames, state.idGeneratorMap);\n  }\n\n  /**\n   * Returns an array constructed from errors + temporary warnings.\n   */\n  public JSError[] getMessages() {\n    return getErrors();\n  }\n\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }\n\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }\n\n  @Override\n  public Node getRoot() {\n    return externAndJsRoot;\n  }\n\n  /**\n   * Creates a new id for making unique names.\n   */\n  private int nextUniqueNameId() {\n    return uniqueNameId++;\n  }\n\n  /**\n   * Resets the unique name id counter\n   */\n  @VisibleForTesting\n  void resetUniqueNameId() {\n    uniqueNameId = 0;\n  }\n\n  @Override\n  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }\n\n  @Override\n  boolean areNodesEqualForInlining(Node n1, Node n2) {\n    if (options.ambiguateProperties ||\n        options.disambiguateProperties) {\n      // The type based optimizations require that type information is preserved\n      // during other optimizations.\n      return n1.isEquivalentToTyped(n2);\n    } else {\n      return n1.isEquivalentTo(n2);\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Inputs\n  //------------------------------------------------------------------------\n\n  // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler\n  // interface, and which ones should always be injected.\n\n  @Override\n  public CompilerInput getInput(String name) {\n    return inputsByName.get(name);\n  }\n\n  /**\n   * Removes an input file from AST.\n   * @param name The name of the file to be removed.\n   */\n  protected void removeInput(String name) {\n    CompilerInput input = getInput(name);\n    if (input == null) {\n      return;\n    }\n    inputsByName.remove(name);\n    Node root = input.getAstRoot(this);\n    if (root != null) {\n      root.detachFromParent();\n    }\n  }\n\n  @Override\n  public CompilerInput newExternInput(String name) {\n    if (inputsByName.containsKey(name)) {\n      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n    }\n    SourceAst ast = new SyntheticAst(name);\n    CompilerInput input = new CompilerInput(ast, name, true);\n    inputsByName.put(name, input);\n    externsRoot.addChildToFront(ast.getAstRoot(this));\n    return input;\n  }\n\n  /** Add a source input dynamically. Intended for incremental compilation. */\n  void addIncrementalSourceAst(JsAst ast) {\n    String sourceName = ast.getSourceFile().getName();\n    Preconditions.checkState(\n        getInput(sourceName) == null,\n        \"Duplicate input of name \" + sourceName);\n    inputsByName.put(sourceName, new CompilerInput(ast));\n  }\n\n  /**\n   * Replace a source input dynamically. Intended for incremental\n   * re-compilation.\n   *\n   * If the new source input doesn't parse, then keep the old input\n   * in the AST and return false.\n   *\n   * @return Whether the new AST was attached successfully.\n   */\n  boolean replaceIncrementalSourceAst(JsAst ast) {\n    String sourceName = ast.getSourceFile().getName();\n    CompilerInput oldInput =\n        Preconditions.checkNotNull(\n            getInput(sourceName),\n            \"No input to replace: \" + sourceName);\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    Node oldRoot = oldInput.getAstRoot(this);\n    if (oldRoot != null) {\n      oldRoot.getParent().replaceChild(oldRoot, newRoot);\n    } else {\n      getRoot().getLastChild().addChildToBack(newRoot);\n    }\n\n    CompilerInput newInput = new CompilerInput(ast);\n    inputsByName.put(sourceName, newInput);\n\n    JSModule module = oldInput.getModule();\n    if (module != null) {\n      module.addAfter(newInput, oldInput);\n      module.remove(oldInput);\n    }\n    return true;\n  }\n\n  @Override\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }\n\n  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }\n\n  @Override\n  ScopeCreator getTypedScopeCreator() {\n    return getPassConfig().getTypedScopeCreator();\n  }\n\n  @Override\n  public Scope getTopScope() {\n    return getPassConfig().getTopScope();\n  }\n\n  @Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n          new SemanticReverseAbstractInterpreter(\n              getCodingConvention(), getTypeRegistry());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n            getCodingConvention(), getTypeRegistry())\n            .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }\n\n  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }\n\n  //------------------------------------------------------------------------\n  // Parsing\n  //------------------------------------------------------------------------\n\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = new Node(Token.BLOCK);\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = new Node(Token.BLOCK, externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot,\n          options.tracer == TracerMode.ALL);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Check if the sources need to be re-ordered.\n      if (options.manageClosureDependencies) {\n        for (CompilerInput input : inputs) {\n          input.setCompiler(this);\n\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(\n                  options.manageClosureDependenciesEntryPoints, inputs);\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          return null;\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          return null;\n        }\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n\n  public Node parse(JSSourceFile file) {\n    initCompilerOptionsIfTesting();\n    addToDebugLog(\"Parsing: \" + file.getName());\n    return new JsAst(file).getAstRoot(this);\n  }\n\n  @Override\n  Node parseSyntheticCode(String js) {\n    CompilerInput input = new CompilerInput(\n        JSSourceFile.fromCode(\" [synthetic] \", js));\n    inputsByName.put(input.getName(), input);\n    return input.getAstRoot(this);\n  }\n\n  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(new CompilerOptions());\n    }\n  }\n\n  @Override\n  Node parseSyntheticCode(String fileName, String js) {\n    initCompilerOptionsIfTesting();\n    return parse(JSSourceFile.fromCode(fileName, js));\n  }\n\n  @Override\n  Node parseTestCode(String js) {\n    initCompilerOptionsIfTesting();\n    CompilerInput input = new CompilerInput(\n        JSSourceFile.fromCode(\" [testcode] \", js));\n    if (inputsByName == null) {\n      inputsByName = Maps.newHashMap();\n    }\n    inputsByName.put(input.getName(), input);\n    return input.getAstRoot(this);\n  }\n\n  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }\n\n  //------------------------------------------------------------------------\n  // Convert back to source code\n  //------------------------------------------------------------------------\n\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource() {\n    return runInCompilerThread(new Callable<String>() {\n      public String call() throws Exception {\n        Tracer tracer = newTracer(\"toSource\");\n        try {\n          CodeBuilder cb = new CodeBuilder();\n          if (jsRoot != null) {\n            int i = 0;\n            for (Node scriptNode = jsRoot.getFirstChild();\n                 scriptNode != null;\n                 scriptNode = scriptNode.getNext()) {\n              toSource(cb, i++, scriptNode);\n            }\n          }\n          return cb.toString();\n        } finally {\n          stopTracer(tracer, \"toSource\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for each input back to js code.\n   */\n  public String[] toSourceArray() {\n    return runInCompilerThread(new Callable<String[]>() {\n      public String[] call() throws Exception {\n        Tracer tracer = newTracer(\"toSourceArray\");\n        try {\n          int numInputs = inputs.size();\n          String[] sources = new String[numInputs];\n          CodeBuilder cb = new CodeBuilder();\n          for (int i = 0; i < numInputs; i++) {\n            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n            cb.reset();\n            toSource(cb, i, scriptNode);\n            sources[i] = cb.toString();\n          }\n          return sources;\n        } finally {\n          stopTracer(tracer, \"toSourceArray\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module) {\n    return runInCompilerThread(new Callable<String>() {\n      public String call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return \"\";\n        }\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module: \" + module.getName());\n          }\n          toSource(cb, i, scriptNode);\n        }\n        return cb.toString();\n      }\n    });\n  }\n\n\n  /**\n   * Converts the parse tree for each input in a module back to js code.\n   */\n  public String[] toSourceArray(final JSModule module) {\n    return runInCompilerThread(new Callable<String[]>() {\n      public String[] call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return new String[0];\n        }\n\n        String[] sources = new String[numInputs];\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module input: \" + inputs.get(i).getName());\n          }\n\n          cb.reset();\n          toSource(cb, i, scriptNode);\n          sources[i] = cb.toString();\n        }\n        return sources;\n      }\n    });\n  }\n\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n      public Void call() throws Exception {\n        if (options.printInputDelimiter) {\n          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            cb.append(\"\\n\");  // Make sure that the label starts on a new line\n          }\n          Preconditions.checkState(root.getType() == Token.SCRIPT);\n\n          String delimiter = options.inputDelimiter;\n\n          String sourceName = (String)root.getProp(Node.SOURCENAME_PROP);\n          Preconditions.checkState(sourceName != null);\n          Preconditions.checkState(!sourceName.isEmpty());\n\n          delimiter = delimiter.replaceAll(\"%name%\", sourceName)\n            .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n\n          cb.append(delimiter)\n            .append(\"\\n\");\n        }\n        if (root.getJSDocInfo() != null &&\n            root.getJSDocInfo().getLicense() != null) {\n          cb.append(\"/*\\n\")\n            .append(root.getJSDocInfo().getLicense())\n            .append(\"*/\\n\");\n        }\n\n        // If there is a valid source map, then indicate to it that the current\n        // root node's mappings are offset by the given string builder buffer.\n        if (options.sourceMapOutputPath != null) {\n          sourceMap.setStartingPosition(\n              cb.getLineIndex(), cb.getColumnIndex());\n        }\n\n        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n        // for the first input file\n        String code = toSource(root, sourceMap);\n        if (!code.isEmpty()) {\n          cb.append(code);\n\n          // In order to avoid parse ambiguity when files are concatenated\n          // together, all files should end in a semi-colon. Do a quick\n          // heuristic check if there's an obvious semi-colon already there.\n          int length = code.length();\n          char lastChar = code.charAt(length - 1);\n          char secondLastChar = length >= 2 ?\n              code.charAt(length - 2) : '\\0';\n          boolean hasSemiColon = lastChar == ';' ||\n              (lastChar == '\\n' && secondLastChar == ';');\n          if (!hasSemiColon) {\n            cb.append(\";\");\n          }\n        }\n        return null;\n      }\n    });\n  }\n\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    return toSource(n, null);\n  }\n\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n\n    Charset charset = options.outputCharset != null ?\n        Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }\n\n  /**\n   * Stores a buffer of text to which more can be appended.  This is just like a\n   * StringBuilder except that we also track the number of lines.\n   */\n  public static class CodeBuilder {\n    private final StringBuilder sb = new StringBuilder();\n    private int lineCount = 0;\n    private int colCount = 0;\n\n    /** Removes all text, but leaves the line count unchanged. */\n    void reset() {\n      sb.setLength(0);\n    }\n\n    /** Appends the given string to the text buffer. */\n    CodeBuilder append(String str) {\n      sb.append(str);\n\n      // Adjust the line and column information for the new text.\n      int index = -1;\n      int lastIndex = index;\n      while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n        ++lineCount;\n        lastIndex = index;\n      }\n\n      if (lastIndex == -1) {\n        // No new lines, append the new characters added.\n        colCount += str.length();\n      } else {\n        colCount = str.length() - (lastIndex + 1);\n      }\n\n      return this;\n    }\n\n    /** Returns all text in the text buffer. */\n    @Override\n    public String toString() {\n      return sb.toString();\n    }\n\n    /** Returns the length of the text buffer. */\n    public int getLength() {\n      return sb.length();\n    }\n\n    /** Returns the (zero-based) index of the last line in the text buffer. */\n    int getLineIndex() {\n      return lineCount;\n    }\n\n    /** Returns the (zero-based) index of the last column in the text buffer. */\n    int getColumnIndex() {\n      return colCount;\n    }\n\n    /** Determines whether the text ends with the given suffix. */\n    boolean endsWith(String suffix) {\n      return (sb.length() > suffix.length())\n          && suffix.equals(sb.substring(sb.length() - suffix.length()));\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Optimizations\n  //------------------------------------------------------------------------\n\n  public void optimize() {\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n  }\n\n  @Override\n  void setCssRenamingMap(CssRenamingMap map) {\n    options.cssRenamingMap = map;\n  }\n\n  @Override\n  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }\n\n  /**\n   * Reprocesses the current defines over the AST.  This is used by GwtCompiler\n   * to generate N outputs for different targets from the same (checked) AST.\n   * For each target, we apply the target-specific defines by calling\n   * {@code processDefines} and then {@code optimize} to optimize the AST\n   * specifically for that target.\n   */\n  public void processDefines() {\n    (new DefaultPassConfig(options)).processDefines.create(this)\n        .process(externsRoot, jsRoot);\n  }\n\n  boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }\n\n  /** Control Flow Analysis. */\n  ControlFlowGraph<Node> computeCFG() {\n    logger.info(\"Computing Control Flow Graph\");\n    Tracer tracer = newTracer(\"computeCFG\");\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n    process(cfa);\n    stopTracer(tracer, \"computeCFG\");\n    return cfa.getCfg();\n  }\n\n  public void normalize() {\n    logger.info(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    endPass();\n  }\n\n  @Override\n  void prepareAst(Node root) {\n    Tracer tracer = newTracer(\"prepareAst\");\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n    stopTracer(tracer, \"prepareAst\");\n  }\n\n  void recordFunctionInformation() {\n    logger.info(\"Recording function information\");\n    startPass(\"recordFunctionInformation\");\n    RecordFunctionInformation recordFunctionInfoPass =\n        new RecordFunctionInformation(\n            this, getPassConfig().getIntermediateState().functionNames);\n    process(recordFunctionInfoPass);\n    functionInformationMap = recordFunctionInfoPass.getMap();\n    endPass();\n  }\n\n  protected final CodeChangeHandler.RecentChange recentChange =\n      new CodeChangeHandler.RecentChange();\n  private final List<CodeChangeHandler> codeChangeHandlers =\n      Lists.<CodeChangeHandler>newArrayList();\n\n  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }\n\n  @Override\n  void removeChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.remove(handler);\n  }\n\n  /**\n   * All passes should call reportCodeChange() when they alter\n   * the JS tree structure. This is verified by CompilerTestCase.\n   * This allows us to optimize to a fixed point.\n   */\n  @Override\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }\n\n  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }\n\n  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }\n\n  @Override\n  public boolean acceptEcmaScript5() {\n    switch (options.getLanguageIn()) {\n      case ECMASCRIPT5:\n      case ECMASCRIPT5_STRICT:\n        return true;\n    }\n    return false;\n  }\n\n  public LanguageMode languageMode() {\n    return options.getLanguageIn();\n  }\n\n  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }\n\n  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword());\n    }\n    return parserConfig;\n  }\n\n  @Override\n  public boolean isTypeCheckingEnabled() {\n    return options.checkTypes;\n  }\n\n\n  //------------------------------------------------------------------------\n  // Error reporting\n  //------------------------------------------------------------------------\n\n  /**\n   * The warning classes that are available from the command-line, and\n   * are suppressable by the {@code @suppress} annotation.\n   */\n  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }\n\n  @Override\n  public void report(JSError error) {\n    CheckLevel level = error.level;\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      errorManager.report(level, error);\n    }\n  }\n\n  @Override\n  public CheckLevel getErrorLevel(JSError error) {\n    Preconditions.checkNotNull(options);\n    return warningsGuard.level(error);\n  }\n\n  /**\n   * Report an internal error.\n   */\n  @Override\n  void throwInternalError(String message, Exception cause) {\n    String finalMessage =\n      \"INTERNAL COMPILER ERROR.\\n\" +\n      \"Please report this problem.\\n\" + message;\n\n    RuntimeException e = new RuntimeException(finalMessage, cause);\n    if (cause != null) {\n      e.setStackTrace(cause.getStackTrace());\n    }\n    throw e;\n  }\n\n\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }\n\n  /**\n   * Gets the number of warnings.\n   */\n  public int getWarningCount() {\n    return errorManager.getWarningCount();\n  }\n\n  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }\n\n  /**\n   * Consults the {@link ErrorManager} to see if we've encountered errors\n   * that should halt compilation. <p>\n   *\n   * If {@link CompilerOptions#ideMode} is {@code true}, this function\n   * always returns {@code false} without consulting the error manager. The\n   * error manager will continue to be told about new errors and warnings, but\n   * the compiler will complete compilation of all inputs.<p>\n   */\n  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }\n\n  /** Called from the compiler passes, adds debug info */\n  @Override\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }\n\n  private SourceFile getSourceFileByName(String sourceName) {\n    if (inputsByName.containsKey(sourceName)) {\n      return inputsByName.get(sourceName).getSourceFile();\n    }\n    return null;\n  }\n\n  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }\n\n  public Region getSourceRegion(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getRegion(lineNumber);\n    }\n    return null;\n  }\n\n  //------------------------------------------------------------------------\n  // Package-private helpers\n  //------------------------------------------------------------------------\n\n  @Override\n  Node getNodeForCodeInsertion(JSModule module) {\n    if (module == null) {\n      if (inputs.isEmpty()) {\n        throw new IllegalStateException(\"No inputs\");\n      }\n\n      return inputs.get(0).getAstRoot(this);\n    }\n\n    List<CompilerInput> moduleInputs = module.getInputs();\n    if (moduleInputs.size() > 0) {\n      return moduleInputs.get(0).getAstRoot(this);\n    }\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }\n\n  public SourceMap getSourceMap() {\n    return sourceMap;\n  }\n\n  VariableMap getVariableMap() {\n    return getPassConfig().getIntermediateState().variableMap;\n  }\n\n  VariableMap getPropertyMap() {\n    return getPassConfig().getIntermediateState().propertyMap;\n  }\n\n  CompilerOptions getOptions() {\n    return options;\n  }\n\n  FunctionInformationMap getFunctionalInformationMap() {\n    return functionInformationMap;\n  }\n\n  /**\n   * Sets the logging level for the com.google.javascript.jscomp package.\n   */\n  public static void setLoggingLevel(Level level) {\n    logger.setLevel(level);\n  }\n\n  /** Gets the DOT graph of the AST generated at the end of compilation. */\n  public String getAstDotGraph() throws IOException {\n    if (jsRoot != null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n      cfa.process(null, jsRoot);\n      return DotFormatter.toDot(jsRoot, cfa.getCfg());\n    } else {\n      return \"\";\n    }\n  }\n\n  @Override\n  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(new CompilerOptions());\n    }\n    return errorManager;\n  }\n\n  @Override\n  List<CompilerInput> getInputsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(inputs);\n  }\n\n  /**\n   * Stores the internal compiler state just before optimization is performed.\n   * This can be saved and restored in order to efficiently optimize multiple\n   * different output targets without having to perform checking multiple times.\n   *\n   * NOTE: This does not include all parts of the compiler's internal state. In\n   * particular, JSSourceFiles and CompilerOptions are not recorded. In\n   * order to recreate a Compiler instance from scratch, you would need to\n   * call {@code init} with the same arguments as in the initial creation before\n   * restoring intermediate state.\n   */\n  public static class IntermediateState implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    Node externsRoot;\n    private Node jsRoot;\n    private List<CompilerInput> externs;\n    private List<CompilerInput> inputs;\n    private List<JSModule> modules;\n    private PassConfig.State passConfigState;\n    private JSTypeRegistry typeRegistry;\n    private AbstractCompiler.LifeCycleStage lifeCycleStage;\n\n    private IntermediateState() {}\n  }\n\n  /**\n   * Returns the current internal state, excluding the input files and modules.\n   */\n  public IntermediateState getState() {\n    IntermediateState state = new IntermediateState();\n    state.externsRoot = externsRoot;\n    state.jsRoot = jsRoot;\n    state.externs = externs;\n    state.inputs = inputs;\n    state.modules = modules;\n    state.passConfigState = getPassConfig().getIntermediateState();\n    state.typeRegistry = typeRegistry;\n    state.lifeCycleStage = getLifeCycleStage();\n\n    return state;\n  }\n\n  /**\n   * Sets the internal state to the capture given.  Note that this assumes that\n   * the input files are already set up.\n   */\n  public void setState(IntermediateState state) {\n    externsRoot = state.externsRoot;\n    jsRoot = state.jsRoot;\n    externs = state.externs;\n    inputs = state.inputs;\n    modules = state.modules;\n    passes = createPassConfigInternal();\n    getPassConfig().setIntermediateState(state.passConfigState);\n    typeRegistry = state.typeRegistry;\n    setLifeCycleStage(state.lifeCycleStage);\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getInputsForTesting() {\n    return inputs;\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getExternsForTesting() {\n    return externs;\n  }\n\n  @Override\n  boolean hasRegExpGlobalReferences() {\n    return hasRegExpGlobalReferences;\n  }\n\n  @Override\n  void setHasRegExpGlobalReferences(boolean references) {\n    hasRegExpGlobalReferences = references;\n  }\n\n  @Override\n  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n    Preconditions.checkState(collectionRoot.getType() == Token.SCRIPT\n        || collectionRoot.getType() == Token.BLOCK);\n    if (globalRefMap == null) {\n      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder());\n    }\n    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n  }\n\n  @Override\n  ReferenceMap getGlobalVarReferences() {\n    return globalRefMap;\n  }\n\n}\n", "review": {"response": "{ \"bugs\": [\n\n  {\n    \"description\": \"The `externExports` field is never used or initialized, but is declared as `null`. It should be removed or used appropriately.\",\n    \"location\": \"line 49, column 12\"\n  },\n\n  {\n    \"description\": \"The `uniqueNameId` field is incremented but never used. It should be removed or used appropriately.\",\n    \"location\": \"line 52, column 12\"\n  },\n\n  {\n    \"description\": \"The `hasRegExpGlobalReferences` field is never used or initialized, but is declared as `true`. It should be removed or used appropriately.\",\n    \"location\": \"line 55, column 12\"\n  },\n\n  {\n    \"description\": \"The `debugLog` field is never used or cleared. It should be used or removed to prevent memory leaks.\",\n    \"location\": \"line 57, column 12\"\n  },\n\n  {\n    \"description\": \"The `defaultCodingConvention` field is never used. It should be removed or used appropriately.\",\n    \"location\": \"line 60, column 12\"\n  },\n\n  {\n    \"description\": \"The `oldErrorReporter` and `defaultErrorReporter` fields are never used. They should be removed or used appropriately.\",\n    \"location\": \"line 62, column 12\"\n  },\n\n  {\n    \"description\": \"The `tracker` field is never used. It should be removed or used appropriately.\",\n    \"location\": \"line 65, column 12\"\n  },\n\n  {\n    \"description\": \"The `COMPILER_STACK_SIZE` constant is never used. It should be removed or used appropriately.\",\n    \"location\": \"line 68, column 12\"\n  },\n\n  {\n    \"description\": \"The `logger` field is declared as `private static final`, but it's not clear if it's used correctly. It should be reviewed for proper usage.\",\n    \"location\": \"line 71, column 12\"\n  },\n\n  {\n    \"description\": \"The `options` field is never initialized or used. It should be removed or used appropriately.\",\n    \"location\": \"line 74, column 12\"\n  },\n\n  {\n    \"description\": \"The `passes` field is never initialized or used. It should be removed or used appropriately.\",\n    \"location\": \"line 77, column 12\"\n  },\n\n  {\n    \"description\": \"The `externs` field is never used or initialized, but is declared as `null`. It should be removed or used appropriately.\",\n    \"location\": \"line 80, column 12\"\n  },\n\n  {\n    \"description\": \"The `modules` field is never used or initialized, but is declared as `null`. It should be removed or used appropriately.\",\n    \"location\": \"line 83, column 12\"\n  },\n\n  {\n    \"description\": \"The `moduleGraph` field is never used or initialized, but is declared as `null`. It should be removed or used appropriately.\",\n    \"location\": \"line 86, column 12\"\n  },\n\n  {\n    \"description\": \"The `inputs` field is never used or initialized, but is declared as `null`. It should be removed or used appropriately.\",\n    \"location\": \"line 89, column 12\"\n  },\n\n  {\n    \"description\": \"The `errorManager` field is never initialized or used. It should be removed or used appropriately.\",\n    \"location\": \"line 92, column 12\"\n  },\n\n  {\n    \"description\": \"The `warningsGuard` field is never initialized or used. It should be removed or used appropriately.\",\n    \"location\": \"line 95, column 12\"\n  },\n\n  {\n    \"description\": \"The `externsRoot`, `jsRoot`, and `externAndJsRoot` fields are never used or initialized, but are declared. They should be removed or used appropriately.\",\n    \"location\": \"line 98, column 12\"\n  },\n\n  {\n    \"description\": \"The `inputsByName` field is never used or initialized, but is declared as `null`. It should be removed or used appropriately.\",\n    \"location\": \"line 101, column 12\"\n  },\n\n  {\n    \"description\": \"The `sourceMap` field is never used or initialized, but is declared as `null`. It should be removed or used appropriately.\",\n    \"location\": \"line 104, column 12\"\n  },\n\n  {\n    \"description\": \"The `functionInformationMap` field is never used or initialized, but is declared as `null`. It should be removed or used appropriately.\",\n    \"location\": \"line 107, column 12\"\n  },\n\n  {\n    \"description\": \"The `abstractInterpreter` and `typeValidator` fields are never used or initialized, but are declared as `null`. They should be removed or used appropriately.\",\n    \"location\": \"line 110, column 12\"\n  },\n\n  {\n    \"description\": \"The `parserConfig` field is never used or initialized, but is declared as `null`. It should be removed or used appropriately.\",\n    \"location\": \"line 113, column 12\"\n  },\n\n  {\n    \"description\": \"The `typeRegistry` field is never used or initialized, but is declared as `null`. It should be removed or used appropriately.\",\n    \"location\": \"line 116, column 12\"\n  }\n\n] }"}}