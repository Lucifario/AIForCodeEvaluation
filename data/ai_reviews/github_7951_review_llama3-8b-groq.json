{
  "source_item_id": 7951,
  "source_type": "github",
  "generator_model_id": "llama3-8b-groq",
  "generation_timestamp": "2025-10-26T13:51:10.778192",
  "input_code_language": "java",
  "input_code_snippet": "/*\n * Copyright (C) 2012 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.Iterators.singletonIterator;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.base.Function;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.Queue;\nimport org.jspecify.annotations.Nullable;\n\n/**\n * Views elements of a type {@code T} as nodes in a tree, and provides methods to traverse the trees\n * induced by this traverser.\n *\n * <p>For example, the tree\n *\n * {@snippet :\n *        h\n *      / | \\\n *     /  e  \\\n *    d       g\n *   /|\\      |\n *  / | \\     f\n * a  b  c\n * }\n *\n * <p>can be iterated over in preorder (hdabcegf), postorder (abcdefgh), or breadth-first order\n * (hdegabcf).\n *\n * <p>Null nodes are strictly forbidden.\n *\n * <p>Because this is an abstract class, not an interface, you can't use a lambda expression to\n * implement it:\n *\n * {@snippet :\n * // won't work\n * TreeTraverser<NodeType> traverser = node -> node.getChildNodes();\n * }\n *\n * Instead, you can pass a lambda expression to the {@code using} factory method:\n *\n * {@snippet :\n * TreeTraverser<NodeType> traverser = TreeTraverser.using(node -> node.getChildNodes());\n * }\n *\n * @author Louis Wasserman\n * @since 15.0\n * @deprecated Use {@link com.google.common.graph.Traverser} instead. All instance methods have\n *     their equivalent on the result of {@code Traverser.forTree(tree)} where {@code tree}\n *     implements {@code SuccessorsFunction}, which has a similar API as {@link #children} or can be\n *     the same lambda function as passed into {@link #using(Function)}.\n *     <p>This class is scheduled to be removed in October 2019.\n */\n// TODO(b/68134636): Remove by 2019-10\n@Deprecated\n@Beta\n@GwtCompatible\npublic abstract class TreeTraverser<T> {\n  /** Constructor for use by subclasses. */\n  public TreeTraverser() {}\n\n  /**\n   * Returns a tree traverser that uses the given function to navigate from a node to its children.\n   * This is useful if the function instance already exists, or so that you can supply a lambda\n   * expressions. If those circumstances don't apply, you probably don't need to use this; subclass\n   * {@code TreeTraverser} and implement its {@link #children} method directly.\n   *\n   * @since 20.0\n   * @deprecated Use {@link com.google.common.graph.Traverser#forTree} instead. If you are using a\n   *     lambda, these methods have exactly the same signature.\n   */\n  @Deprecated\n  public static <T> TreeTraverser<T> using(\n      Function<T, ? extends Iterable<T>> nodeToChildrenFunction) {\n    checkNotNull(nodeToChildrenFunction);\n    return new TreeTraverser<T>() {\n      @Override\n      public Iterable<T> children(T root) {\n        return nodeToChildrenFunction.apply(root);\n      }\n    };\n  }\n\n  /** Returns the children of the specified node. Must not contain null. */\n  public abstract Iterable<T> children(T root);\n\n  /**\n   * Returns an unmodifiable iterable over the nodes in a tree structure, using pre-order traversal.\n   * That is, each node's subtrees are traversed after the node itself is returned.\n   *\n   * <p>No guarantees are made about the behavior of the traversal when nodes change while iteration\n   * is in progress or when the iterators generated by {@link #children} are advanced.\n   *\n   * @deprecated Use {@link com.google.common.graph.Traverser#depthFirstPreOrder} instead, which has\n   *     the same behavior.\n   */\n  @Deprecated\n  public final FluentIterable<T> preOrderTraversal(T root) {\n    checkNotNull(root);\n    return new FluentIterable<T>() {\n      @Override\n      public UnmodifiableIterator<T> iterator() {\n        return preOrderIterator(root);\n      }\n    };\n  }\n\n  UnmodifiableIterator<T> preOrderIterator(T root) {\n    return new PreOrderIterator(root);\n  }\n\n  private final class PreOrderIterator extends UnmodifiableIterator<T> {\n    private final Deque<Iterator<T>> stack;\n\n    PreOrderIterator(T root) {\n      this.stack = new ArrayDeque<>();\n      stack.addLast(singletonIterator(checkNotNull(root)));\n    }\n\n    @Override\n    public boolean hasNext() {\n      return !stack.isEmpty();\n    }\n\n    @Override\n    public T next() {\n      Iterator<T> itr = stack.getLast(); // throws NSEE if empty\n      T result = checkNotNull(itr.next());\n      if (!itr.hasNext()) {\n        stack.removeLast();\n      }\n      Iterator<T> childItr = children(result).iterator();\n      if (childItr.hasNext()) {\n        stack.addLast(childItr);\n      }\n      return result;\n    }\n  }\n\n  /**\n   * Returns an unmodifiable iterable over the nodes in a tree structure, using post-order\n   * traversal. That is, each node's subtrees are traversed before the node itself is returned.\n   *\n   * <p>No guarantees are made about the behavior of the traversal when nodes change while iteration\n   * is in progress or when the iterators generated by {@link #children} are advanced.\n   *\n   * @deprecated Use {@link com.google.common.graph.Traverser#depthFirstPostOrder} instead, which\n   *     has the same behavior.\n   */\n  @Deprecated\n  public final FluentIterable<T> postOrderTraversal(T root) {\n    checkNotNull(root);\n    return new FluentIterable<T>() {\n      @Override\n      public UnmodifiableIterator<T> iterator() {\n        return postOrderIterator(root);\n      }\n    };\n  }\n\n  UnmodifiableIterator<T> postOrderIterator(T root) {\n    return new PostOrderIterator(root);\n  }\n\n  private static final class PostOrderNode<T> {\n    final T root;\n    final Iterator<T> childIterator;\n\n    PostOrderNode(T root, Iterator<T> childIterator) {\n      this.root = checkNotNull(root);\n      this.childIterator = checkNotNull(childIterator);\n    }\n  }\n\n  private final class PostOrderIterator extends AbstractIterator<T> {\n    private final ArrayDeque<PostOrderNode<T>> stack;\n\n    PostOrderIterator(T root) {\n      this.stack = new ArrayDeque<>();\n      stack.addLast(expand(root));\n    }\n\n    @Override\n    protected @Nullable T computeNext() {\n      while (!stack.isEmpty()) {\n        PostOrderNode<T> top = stack.getLast();\n        if (top.childIterator.hasNext()) {\n          T child = top.childIterator.next();\n          stack.addLast(expand(child));\n        } else {\n          stack.removeLast();\n          return top.root;\n        }\n      }\n      return endOfData();\n    }\n\n    private PostOrderNode<T> expand(T t) {\n      return new PostOrderNode<>(t, children(t).iterator());\n    }\n  }\n\n  /**\n   * Returns an unmodifiable iterable over the nodes in a tree structure, using breadth-first\n   * traversal. That is, all the nodes of depth 0 are returned, then depth 1, then 2, and so on.\n   *\n   * <p>No guarantees are made about the behavior of the traversal when nodes change while iteration\n   * is in progress or when the iterators generated by {@link #children} are advanced.\n   *\n   * @deprecated Use {@link com.google.common.graph.Traverser#breadthFirst} instead, which has the\n   *     same behavior.\n   */\n  @Deprecated\n  public final FluentIterable<T> breadthFirstTraversal(T root) {\n    checkNotNull(root);\n    return new FluentIterable<T>() {\n      @Override\n      public UnmodifiableIterator<T> iterator() {\n        return new BreadthFirstIterator(root);\n      }\n    };\n  }\n\n  private final class BreadthFirstIterator extends UnmodifiableIterator<T>\n      implements Peek",
  "raw_llm_output": "{\n  \"bugs_found\": [\n      {\n         \"explanation\": \"The PreOrderIterator class does not handle the case when the stack is empty, throwing a NullPointerException. This can be fixed by adding a null check before accessing the last element of the stack.\",\n         \"suggested_fix\": \"public boolean hasNext() {\\n    if (stack.isEmpty()) return false;\\n    return !stack.getLast().hasNext();\\n}\"\n      },\n      {\n         \"explanation\": \"The PostOrderIterator class does not handle the case when the child iterator has no next element, causing an infinite loop. This can be fixed by adding a null check before accessing the child iterator.\",\n         \"suggested_fix\": \"if (top.childIterator == null) return endOfData();\"\n      },\n      {\n         \"explanation\": \"The BreadthFirstIterator class does not implement the Peek interface correctly, causing a compilation error. This can be fixed by implementing the peek method.\",\n         \"suggested_fix\": \"public T peek() {\\n    if (!hasNext()) throw new NoSuchElementException();\\n    return next();\\n}\"\n      }\n   ],\n   \"no_bugs_reasoning\": \"No critical bugs, logic errors, memory leaks, null errors, or security issues were found in the provided code snippet.\"\n}",
  "parsed_llm_output": {
    "bugs_found": [
      {
        "explanation": "The PreOrderIterator class does not handle the case when the stack is empty, throwing a NullPointerException. This can be fixed by adding a null check before accessing the last element of the stack.",
        "suggested_fix": "public boolean hasNext() {\n    if (stack.isEmpty()) return false;\n    return !stack.getLast().hasNext();\n}"
      },
      {
        "explanation": "The PostOrderIterator class does not handle the case when the child iterator has no next element, causing an infinite loop. This can be fixed by adding a null check before accessing the child iterator.",
        "suggested_fix": "if (top.childIterator == null) return endOfData();"
      },
      {
        "explanation": "The BreadthFirstIterator class does not implement the Peek interface correctly, causing a compilation error. This can be fixed by implementing the peek method.",
        "suggested_fix": "public T peek() {\n    if (!hasNext()) throw new NoSuchElementException();\n    return next();\n}"
      }
    ],
    "no_bugs_reasoning": "No critical bugs, logic errors, memory leaks, null errors, or security issues were found in the provided code snippet."
  },
  "error": null
}